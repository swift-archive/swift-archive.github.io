<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 17, 2015 at 11:00:00pm</p></header><div class="content"><p>This a significantly updated proposal for typed annotations on the `throws` construct. The previous was closed due to not be complete; I believe I’ve addressed all of those concerns.<br></p><p>https://github.com/owensd/swift-evolution/blob/master/proposals/allow-type-annotations-on-throw.md<br></p><p>—<br></p><p>Allow Type Annotation on Throws<br>Proposal: SE-NNNN &lt;applewebdata://9C8E792C-9803-4E70-811E-D5169EDD5F6D&gt;<br>Author(s): David Owens II &lt;applewebdata://9C8E792C-9803-4E70-811E-D5169EDD5F6D&gt;<br>Status: Pending Approval for Review<br>Review manager: TBD<br>Introduction<br>The error handling system within Swift today creates an implicitly loose contract on the API. While this can be desirable in some cases, it’s certainly not desired in all cases. This proposal looks at modifying how the error handling mechanism works today by adding the ability to provide a strong API contract.<br></p><p>Error Handling State of the Union<br>This document will use the terminology and the premises defined in the Error Handling Rationale &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt; document.<br></p><p>To very briefly summarize, there are four basic classification of errors:<br></p><p>Simple Domain Errors<br>Recoverable Errors<br>Universal Errors<br>Logic Failures<br>Each of these types of errors are handled differently at the call sites. Today, only the first two are directly handled by Swift error handling mechanism. The second two are uncatchable in Swift (such as fatalError(), ObjC exceptions, and force-unwrapping of null optionals).<br></p><p>Simple Domain Errors<br></p><p>As stated in Error Handling Rationale &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt; document, the “Swift way” to handle such errors is to return an Optional&lt;T&gt;.<br></p><p>func parseInt(value: String) -&gt; Int? {}<br>The simple fact of the result being Optional.None signifies that the string could not be parsed and converted into an Int. No other information is necessary or warranted.<br></p><p>Recoverable Errors<br></p><p>In this context, these are errors that need to provide additional information to the caller. The caller can then decide a course of action that needs to be taken. This could be any number of things, including, but not limited to, logging error information, attempting a retry, or potentially invoking a different code path. All of these errors implement the ErrorType protocol.<br></p><p>func openFile(filename: String) throws {}<br>The throws keyword annotates that the function can return additional error information. The caller must also explicitly make use of this when invoking the function.<br></p><p>do {<br>  try openFile(&quot;path/to/somewhere&quot;)<br>}<br>catch {}<br>Errors are able to propagate if called within another context that can throw, thus alleviating the annoying “catch and rethrow” behavior:<br></p><p>func parent() throws {<br>  try openFile(&quot;path/to/somwhere&quot;)<br>}<br>Lastly, functions can be marked to selectively throw errors if they take a function parameter that throws with the rethrows keyword. The really interesting part is that it’s only necessary to use try when calling the function with a throwing closure.<br></p><p>func openFile(filename: String) throws {}<br>func say(message: String) {}<br></p><p>func sample(fn: (_: String) throws -&gt; ()) rethrows {<br>    try fn(&quot;hi&quot;)<br>}<br></p><p>try sample(openFile)<br>sample(say)<br>Converting Recoverable Errors to Domain Errors<br></p><p>Swift also has the try? construct. The notable thing about this construct is that it allows the caller to turn a “Recoverable Error” into a “Simple Domain Error”.<br></p><p>if let result = try? openFile(&quot;&quot;) {}<br>ErrorType Implementors<br></p><p>Errors are implemented using the ErrorType protocol. Since it is a protocol, new error types can be a class, a struct, or an enum. A type qualified throws clause would allow code authors to change the way that the catch-clauses need to be structured.<br></p><p>Enum Based ErrorType<br></p><p>When enums are used as the throwing mechanism, a generic catch-clause is still required as the compiler doesn’t have enough information. This leads to ambiguous code paths.<br></p><p>enum Errors: ErrorType {<br>    case OffBy1<br>    case MutatedValue<br>}<br></p><p>func f() throws { throw Errors.OffBy1 }<br></p><p>do {<br>    try f()<br>}<br>catch Errors.OffBy1 { print(&quot;increment by 1&quot;) }<br>catch Errors.MutatedValue { fatalError(&quot;data corrupted&quot;) }<br>The above code requires a catch {} clause, but it’s ambiguous what that case should do. There is no right way to handle this error. If the error is ignored, we’re now in the land of “Logic Errors”; the code path should never be hit. If we use a fatalError() construct, then we are now in the land of converting a potential compiler error into a “Universal Error”.<br></p><p>Both of these are undesirable.<br></p><p>Struct and Class Based ErrorType<br></p><p>In the current design, errors that are thrown require a catch-all all the time. In the proposed design, which will be explained further, a catch-all would not be required if there was a case-clause that matched the base type.<br></p><p>class ErrorOne: ErrorType {}<br>func g() throws { throw ErrorOne() }<br></p><p>do {<br>    try g()<br>}<br>catch is ErrorOne { print(&quot;ErrorOne&quot;) }<br>The advantage in these cases are different, these cases do not allow pattern matching over the error type members (as you can in a switch-statement, for example).<br></p><p>The workaround for this functionality is this:<br></p><p>class ErrorOne: ErrorType {<br>    let value: Int<br>    init(_ value: Int) { self.value = value }<br>}<br></p><p>do {<br>    try g()<br>}<br>catch {<br>    if let e = error as? ErrorOne {<br>        switch e {<br>        case _ where e.value == 0: print(&quot;0&quot;)<br>        case _ where e.value == 1: print(&quot;1&quot;)<br>        default: print(&quot;nothing&quot;)<br>        }<br>    }<br>}<br>This proposal would turn the above into:<br></p><p>class ErrorOne: ErrorType {<br>    let value: Int<br>    init(_ value: Int) { self.value = value }<br>}<br></p><p>do {<br>    try g()<br>}<br>catch _ where error.value == 0 { print(&quot;0&quot;) }<br>catch _ where error.value == 1 { print(&quot;1&quot;) }<br>catch { print(&quot;nothing&quot;) }<br>}<br>No gymnastics to go through, just straight-forward pattern-matching like you’d expect.<br></p><p>NOTE: This requires the promotion of the error constant to be allowed through the entirety of the catch-clauses.<br></p><p>Overriding<br></p><p>In the context of types, it’s completely possible to override functions with the throws annotations. The rules simply follow the rules today: covariance on the return type is allowed, contravariance is not.<br></p><p>Generics<br></p><p>When looking at generics, I cannot come up with a reason why they shouldn’t just work as normal:<br></p><p>func gen&lt;SomeError: ErrorType&gt;() throws SomeError {}<br>The only constraint would be that the specified error type must adhere to the ErrorType protocol. However, this is no different than today:<br></p><p>func f&lt;T&gt;(a: T) throws { throw a }<br>This results in the compiler error:<br></p><p>Thrown expression type ’T’ does not conform to ‘ErrorType’<br>This seems like it should “just work”.<br></p><p>Design Change Proposal<br>The design change is simple and straight-forward: allow for the annotation of the type of error that is being returned as an optional restriction. The default value would still be ErrorType.<br></p><p>func specific() throws MyError {}<br>func nonspecific() throws {}<br>There is a secondary result of this proposal: the error constant should be promoted to be allowed for use through-out all of the catch-clauses.<br></p><p>Impact on Existing Code<br></p><p>This is a non-breaking change. All existing constructs work today without change. That said, there are a few places where this change will have an impact on future usage.<br></p><p>Function Declarations<br></p><p>When a function has a throws clause that is attributed with a type, then that type becomes part of the function signature. This means that these two functions are not considered to be of the same type:<br></p><p>func one() throws {}<br>func two() throws NumberError {}<br>The function signatures are covariant though, so either one or two can be assigned to f below:<br></p><p>let f: () throws -&gt; ()<br>This is completely fine as NumberError still implements the ErrorType protocol.<br></p><p>However, in this case:<br></p><p>let g: () throws NumberError -&gt; ()<br>It would not be valid to assign one to g as the type signature is more specific.<br></p><p>throws and rethrows<br></p><p>Functions currently have the ability to be marked as rethrows. This basically says that if a closure parameter can throw, then the function will throw too. <br></p><p>func whatever(fn: () throws -&gt; ()) rethrows {}<br>The whatever function is up for anything that fn is up for. Keeping in line with this mentality, the rethrows would exhibit the same behavior: typed annotations simply apply if present and do not if they are missing.<br></p><p>func specific(fn: () throws HappyError -&gt; ()) rethrows {}<br>This all works as expected:<br></p><p>func f() throws HappyError {}<br>func g() {}<br></p><p>try specific(f)<br>specific(g)<br>This works for the same covariant reason as the non-qualified throws implementation works: a non-throwing function is always able to be passed in for a throwing function.<br></p><p>The do-catch statement<br></p><p>There are two rule changes here, but again, it’s non-breaking.<br></p><p>The first rule change is to promote the error constant that would normally only be allowed in the catch-all clause (no patterns) to be available throughout each of the catch clauses. This allows for the error information to be used in pattern matching, which is especially valuable in the non-enum case.<br></p><p>The second change is to allow the error constant to take on a specific type when all of the throwing functions throw the same specified type. When this is the case, two things become possible:<br></p><p>In the enum-type implementation of ErrorType, the catch-clauses can now be exhaustive.<br>In the all of the cases, the API of the specific ErrorType becomes available in the catch-clause without casting the error constant. This greatly simplifies the pattern-matching process.<br>In the case that there are heterogenous ErrorType implementations being returned, the errorconstant simply has the type of ErrorType.<br></p><p>The try call sites<br></p><p>There is no change for the try, try?, or try! uses. The only clarification I’ll add is that try?is still the appropriate way to promote an error from a “Recoverable Error” to a “Simple Domain Error”.<br></p><p>Alternate Proposals<br>There is another common error handling mechanism used in the community today: Either&lt;L, R&gt;. There are various implementations, but they all basically boil down to an enum that captures the value or the error information.<br></p><p>I actually consider my proposal syntactic sugar over this concept. If and when Swift supports covariant generics, there is not a significant reason I can see why the underlying implementation could not just be that.<br></p><p>The advantage is that the proposed (and existing) syntax of throws greatly increases the readability and understanding that this function actually possesses the ability to throw errors and they should be handled.<br></p><p>The other advantage of this syntax is that it doesn’t require a new construct to force the usage of the return type. <br></p><p>Further, if functions where to ever gain the ability to be marked as async, this could now be handled naturally within the compiler as the return type could a promise-like implementation for those.<br></p><p>Criticisms<br>From the earlier threads on the swift-evolution mailing list, there are a few primary points of contention about this proposal.<br></p><p>Aren’t we just creating Java checked-exceptions, which we all know are terrible?<br></p><p>No. The primary reason is that a function can only return a single error-type. The other major reason is that the error philosophy is very different in Swift than in Java.<br></p><p>Aren’t we creating fragile APIs that can cause breaking changes?<br></p><p>Potentially, yes. This depends on how the ABI is handled in Swift 3 for enums. The same problem exists today, although at a lesser extent, for any API that returns an enum today.<br></p><p>Chris Lattner mentioned this on the thread:<br></p><p>The resilience model addresses how the public API from a module can evolve without breaking clients (either at the source level or ABI level).  Notably, we want the ability to be able to add enum cases to something by default, but also to allow API authors to opt into more performance/strictness by saying that a public enum is “fragile” or “closed for evolution”.<br>So if enums have an attribute that allows API authors to denote the fragility enums, then this can be handled via that route.<br></p><p>Another potential fix is that only internal and private scoped functions are allowed to use the exhaustive-style catch-clauses. For all public APIs, they would still need the catch-all clauses.<br></p><p>For APIs that return non-enum based ErrorType implementations, then no, this does not contribute to the fragility problem.<br></p><p>Aren’t we creating the need for wrapper errors?<br></p><p>This is a philosophical debate. I’ll simply state that I believe that simply re-throwing an error, say some type of IO error, from your API that is not an IO-based API is design flaw: you are exposing implementation details to users. This creates a fragile API surface.<br></p><p>Also, since the type annotation is opt-in, I feel like this is a really minor argument. If your function is really able to throw errors from various different API calls, then just stick with the default ErrorType.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/4cd8fc8b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 18, 2015 at 07:00:00am</p></header><div class="content"><p>David,<br></p><p>Thank you for taking the time to continue working on a proposal for typed throws.  I agree that this feature is very desirable and appreciate the work you’re doing to bring forward a proposal.  I think it’s a great start but also has some room for improvement.<br></p><p>First, I think it could be strengthened by incorporating some learning from Rust.  My impression is that the Rust community is very happy with typed error handling.  Adding some detail about their experience would provide a counter-example to those who are concerned about the experience in Java and C++.<br></p><p>I agree that error types are an important part of an API contract.  One of the big hurdles to doing this well is the need to catch errors when all that needs to be done is to wrap and rethrow them.  Ideally should not need to do this just to perform a simple type translation to map the underlying error into the type we wish to expose as part of a stable API contract.  You might want to take a look at the From mechanism Rust uses to facilitate this.  IMO a proposal for typed error handling should address this issue in some way (even if the author determines this mechanism is not necessary or a good design cannot be identified).<br></p><p>I would also like to see much more detail on why you think allowing a function to throw multiple error types is problematic.  My impression is that you have concerns from a usability point of view.  I am on the fence here to some degree, but definitely leaning in the direction that allowing a function to throw multiple error types is better.  <br></p><p>The primary reason I lean this way is that it enables more re-use of standard error types.  Custom error types for an API often make sense, but not always.  I am concerned about the need to create them just because our API contract might reasonably include two or three of the standard error types.  Adding new types when they are not necessary introduces complexity and cognitive overhead.  It also complicates catching of errors if the new custom type is a two or three case enum that just embeds the underlying error.  <br></p><p>These problems will lead many people to just revert to an untyped throws clause.  Objections to typed errors along these lines are common and legitimate.  They will arise during review.  It is best if you address them in the proposal now in order to focus a review on your solutions.  My personal opinion is that allowing multiple error types and including a mechanism to perform automatic wrapping when appropriate would go a long way towards solving them.<br></p><p>Implementation challenges related to multi-typed errors have been discussed on the list quite a bit already.  They would obviously need to be addressed if we go in that direction.  I don’t want to downplay those.  But I do think we need to try to identify the most usable solution for typed errors that we can first and then focus on implementation details.  If the design needs to be modified to accommodate implementation at least we will have a better idea of what we are giving up.<br></p><p>I am willing to be convinced that a single error type is better than multiple error types but the current proposal does not provide a compelling argument in that direction.  It just says “Java checked exceptions”.  I know these have been pretty much universally considered a serious design mistake.  My impression is that there are quite a few reasons for that.  I don’t have any direct experience with Java and am not familiar with the details.  If you could elaborate on specifically why you believe allowing multiple error types was a significant contributor to the problem in a manner that indicates that they will be a problem in any language that includes them I would appreciate that.  Links would be sufficient if they are focused on answering this particular question.  <br></p><p>I’m looking forward to your feedback on these thoughts.<br></p><p>Thanks,<br>Matthew<br></p><p><br>&gt; On Dec 18, 2015, at 1:29 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This a significantly updated proposal for typed annotations on the `throws` construct. The previous was closed due to not be complete; I believe I’ve addressed all of those concerns.<br>&gt; <br>&gt; https://github.com/owensd/swift-evolution/blob/master/proposals/allow-type-annotations-on-throw.md &lt;https://github.com/owensd/swift-evolution/blob/master/proposals/allow-type-annotations-on-throw.md&gt;<br>&gt; <br>&gt; —<br>&gt; <br>&gt; Allow Type Annotation on Throws<br>&gt; Proposal: SE-NNNN &lt;applewebdata://E64F564F-E0C7-443D-BB19-243FAD102941&gt;<br>&gt; Author(s): David Owens II &lt;applewebdata://E64F564F-E0C7-443D-BB19-243FAD102941&gt;<br>&gt; Status: Pending Approval for Review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; The error handling system within Swift today creates an implicitly loose contract on the API. While this can be desirable in some cases, it’s certainly not desired in all cases. This proposal looks at modifying how the error handling mechanism works today by adding the ability to provide a strong API contract.<br>&gt; <br>&gt; Error Handling State of the Union<br>&gt; This document will use the terminology and the premises defined in the Error Handling Rationale &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt; document.<br>&gt; <br>&gt; To very briefly summarize, there are four basic classification of errors:<br>&gt; <br>&gt; Simple Domain Errors<br>&gt; Recoverable Errors<br>&gt; Universal Errors<br>&gt; Logic Failures<br>&gt; Each of these types of errors are handled differently at the call sites. Today, only the first two are directly handled by Swift error handling mechanism. The second two are uncatchable in Swift (such as fatalError(), ObjC exceptions, and force-unwrapping of null optionals).<br>&gt; <br>&gt; Simple Domain Errors<br>&gt; <br>&gt; As stated in Error Handling Rationale &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt; document, the “Swift way” to handle such errors is to return an Optional&lt;T&gt;.<br>&gt; <br>&gt; func parseInt(value: String) -&gt; Int? {}<br>&gt; The simple fact of the result being Optional.None signifies that the string could not be parsed and converted into an Int. No other information is necessary or warranted.<br>&gt; <br>&gt; Recoverable Errors<br>&gt; <br>&gt; In this context, these are errors that need to provide additional information to the caller. The caller can then decide a course of action that needs to be taken. This could be any number of things, including, but not limited to, logging error information, attempting a retry, or potentially invoking a different code path. All of these errors implement the ErrorType protocol.<br>&gt; <br>&gt; func openFile(filename: String) throws {}<br>&gt; The throws keyword annotates that the function can return additional error information. The caller must also explicitly make use of this when invoking the function.<br>&gt; <br>&gt; do {<br>&gt;   try openFile(&quot;path/to/somewhere&quot;)<br>&gt; }<br>&gt; catch {}<br>&gt; Errors are able to propagate if called within another context that can throw, thus alleviating the annoying “catch and rethrow” behavior:<br>&gt; <br>&gt; func parent() throws {<br>&gt;   try openFile(&quot;path/to/somwhere&quot;)<br>&gt; }<br>&gt; Lastly, functions can be marked to selectively throw errors if they take a function parameter that throws with the rethrows keyword. The really interesting part is that it’s only necessary to use try when calling the function with a throwing closure.<br>&gt; <br>&gt; func openFile(filename: String) throws {}<br>&gt; func say(message: String) {}<br>&gt; <br>&gt; func sample(fn: (_: String) throws -&gt; ()) rethrows {<br>&gt;     try fn(&quot;hi&quot;)<br>&gt; }<br>&gt; <br>&gt; try sample(openFile)<br>&gt; sample(say)<br>&gt; Converting Recoverable Errors to Domain Errors<br>&gt; <br>&gt; Swift also has the try? construct. The notable thing about this construct is that it allows the caller to turn a “Recoverable Error” into a “Simple Domain Error”.<br>&gt; <br>&gt; if let result = try? openFile(&quot;&quot;) {}<br>&gt; ErrorType Implementors<br>&gt; <br>&gt; Errors are implemented using the ErrorType protocol. Since it is a protocol, new error types can be a class, a struct, or an enum. A type qualified throws clause would allow code authors to change the way that the catch-clauses need to be structured.<br>&gt; <br>&gt; Enum Based ErrorType<br>&gt; <br>&gt; When enums are used as the throwing mechanism, a generic catch-clause is still required as the compiler doesn’t have enough information. This leads to ambiguous code paths.<br>&gt; <br>&gt; enum Errors: ErrorType {<br>&gt;     case OffBy1<br>&gt;     case MutatedValue<br>&gt; }<br>&gt; <br>&gt; func f() throws { throw Errors.OffBy1 }<br>&gt; <br>&gt; do {<br>&gt;     try f()<br>&gt; }<br>&gt; catch Errors.OffBy1 { print(&quot;increment by 1&quot;) }<br>&gt; catch Errors.MutatedValue { fatalError(&quot;data corrupted&quot;) }<br>&gt; The above code requires a catch {} clause, but it’s ambiguous what that case should do. There is no right way to handle this error. If the error is ignored, we’re now in the land of “Logic Errors”; the code path should never be hit. If we use a fatalError() construct, then we are now in the land of converting a potential compiler error into a “Universal Error”.<br>&gt; <br>&gt; Both of these are undesirable.<br>&gt; <br>&gt; Struct and Class Based ErrorType<br>&gt; <br>&gt; In the current design, errors that are thrown require a catch-all all the time. In the proposed design, which will be explained further, a catch-all would not be required if there was a case-clause that matched the base type.<br>&gt; <br>&gt; class ErrorOne: ErrorType {}<br>&gt; func g() throws { throw ErrorOne() }<br>&gt; <br>&gt; do {<br>&gt;     try g()<br>&gt; }<br>&gt; catch is ErrorOne { print(&quot;ErrorOne&quot;) }<br>&gt; The advantage in these cases are different, these cases do not allow pattern matching over the error type members (as you can in a switch-statement, for example).<br>&gt; <br>&gt; The workaround for this functionality is this:<br>&gt; <br>&gt; class ErrorOne: ErrorType {<br>&gt;     let value: Int<br>&gt;     init(_ value: Int) { self.value = value }<br>&gt; }<br>&gt; <br>&gt; do {<br>&gt;     try g()<br>&gt; }<br>&gt; catch {<br>&gt;     if let e = error as? ErrorOne {<br>&gt;         switch e {<br>&gt;         case _ where e.value == 0: print(&quot;0&quot;)<br>&gt;         case _ where e.value == 1: print(&quot;1&quot;)<br>&gt;         default: print(&quot;nothing&quot;)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; This proposal would turn the above into:<br>&gt; <br>&gt; class ErrorOne: ErrorType {<br>&gt;     let value: Int<br>&gt;     init(_ value: Int) { self.value = value }<br>&gt; }<br>&gt; <br>&gt; do {<br>&gt;     try g()<br>&gt; }<br>&gt; catch _ where error.value == 0 { print(&quot;0&quot;) }<br>&gt; catch _ where error.value == 1 { print(&quot;1&quot;) }<br>&gt; catch { print(&quot;nothing&quot;) }<br>&gt; }<br>&gt; No gymnastics to go through, just straight-forward pattern-matching like you’d expect.<br>&gt; <br>&gt; NOTE: This requires the promotion of the error constant to be allowed through the entirety of the catch-clauses.<br>&gt; <br>&gt; Overriding<br>&gt; <br>&gt; In the context of types, it’s completely possible to override functions with the throws annotations. The rules simply follow the rules today: covariance on the return type is allowed, contravariance is not.<br>&gt; <br>&gt; Generics<br>&gt; <br>&gt; When looking at generics, I cannot come up with a reason why they shouldn’t just work as normal:<br>&gt; <br>&gt; func gen&lt;SomeError: ErrorType&gt;() throws SomeError {}<br>&gt; The only constraint would be that the specified error type must adhere to the ErrorType protocol. However, this is no different than today:<br>&gt; <br>&gt; func f&lt;T&gt;(a: T) throws { throw a }<br>&gt; This results in the compiler error:<br>&gt; <br>&gt; Thrown expression type ’T’ does not conform to ‘ErrorType’<br>&gt; This seems like it should “just work”.<br>&gt; <br>&gt; Design Change Proposal<br>&gt; The design change is simple and straight-forward: allow for the annotation of the type of error that is being returned as an optional restriction. The default value would still be ErrorType.<br>&gt; <br>&gt; func specific() throws MyError {}<br>&gt; func nonspecific() throws {}<br>&gt; There is a secondary result of this proposal: the error constant should be promoted to be allowed for use through-out all of the catch-clauses.<br>&gt; <br>&gt; Impact on Existing Code<br>&gt; <br>&gt; This is a non-breaking change. All existing constructs work today without change. That said, there are a few places where this change will have an impact on future usage.<br>&gt; <br>&gt; Function Declarations<br>&gt; <br>&gt; When a function has a throws clause that is attributed with a type, then that type becomes part of the function signature. This means that these two functions are not considered to be of the same type:<br>&gt; <br>&gt; func one() throws {}<br>&gt; func two() throws NumberError {}<br>&gt; The function signatures are covariant though, so either one or two can be assigned to f below:<br>&gt; <br>&gt; let f: () throws -&gt; ()<br>&gt; This is completely fine as NumberError still implements the ErrorType protocol.<br>&gt; <br>&gt; However, in this case:<br>&gt; <br>&gt; let g: () throws NumberError -&gt; ()<br>&gt; It would not be valid to assign one to g as the type signature is more specific.<br>&gt; <br>&gt; throws and rethrows<br>&gt; <br>&gt; Functions currently have the ability to be marked as rethrows. This basically says that if a closure parameter can throw, then the function will throw too. <br>&gt; <br>&gt; func whatever(fn: () throws -&gt; ()) rethrows {}<br>&gt; The whatever function is up for anything that fn is up for. Keeping in line with this mentality, the rethrows would exhibit the same behavior: typed annotations simply apply if present and do not if they are missing.<br>&gt; <br>&gt; func specific(fn: () throws HappyError -&gt; ()) rethrows {}<br>&gt; This all works as expected:<br>&gt; <br>&gt; func f() throws HappyError {}<br>&gt; func g() {}<br>&gt; <br>&gt; try specific(f)<br>&gt; specific(g)<br>&gt; This works for the same covariant reason as the non-qualified throws implementation works: a non-throwing function is always able to be passed in for a throwing function.<br>&gt; <br>&gt; The do-catch statement<br>&gt; <br>&gt; There are two rule changes here, but again, it’s non-breaking.<br>&gt; <br>&gt; The first rule change is to promote the error constant that would normally only be allowed in the catch-all clause (no patterns) to be available throughout each of the catch clauses. This allows for the error information to be used in pattern matching, which is especially valuable in the non-enum case.<br>&gt; <br>&gt; The second change is to allow the error constant to take on a specific type when all of the throwing functions throw the same specified type. When this is the case, two things become possible:<br>&gt; <br>&gt; In the enum-type implementation of ErrorType, the catch-clauses can now be exhaustive.<br>&gt; In the all of the cases, the API of the specific ErrorType becomes available in the catch-clause without casting the error constant. This greatly simplifies the pattern-matching process.<br>&gt; In the case that there are heterogenous ErrorType implementations being returned, the errorconstant simply has the type of ErrorType.<br>&gt; <br>&gt; The try call sites<br>&gt; <br>&gt; There is no change for the try, try?, or try! uses. The only clarification I’ll add is that try?is still the appropriate way to promote an error from a “Recoverable Error” to a “Simple Domain Error”.<br>&gt; <br>&gt; Alternate Proposals<br>&gt; There is another common error handling mechanism used in the community today: Either&lt;L, R&gt;. There are various implementations, but they all basically boil down to an enum that captures the value or the error information.<br>&gt; <br>&gt; I actually consider my proposal syntactic sugar over this concept. If and when Swift supports covariant generics, there is not a significant reason I can see why the underlying implementation could not just be that.<br>&gt; <br>&gt; The advantage is that the proposed (and existing) syntax of throws greatly increases the readability and understanding that this function actually possesses the ability to throw errors and they should be handled.<br>&gt; <br>&gt; The other advantage of this syntax is that it doesn’t require a new construct to force the usage of the return type. <br>&gt; <br>&gt; Further, if functions where to ever gain the ability to be marked as async, this could now be handled naturally within the compiler as the return type could a promise-like implementation for those.<br>&gt; <br>&gt; Criticisms<br>&gt; From the earlier threads on the swift-evolution mailing list, there are a few primary points of contention about this proposal.<br>&gt; <br>&gt; Aren’t we just creating Java checked-exceptions, which we all know are terrible?<br>&gt; <br>&gt; No. The primary reason is that a function can only return a single error-type. The other major reason is that the error philosophy is very different in Swift than in Java.<br>&gt; <br>&gt; Aren’t we creating fragile APIs that can cause breaking changes?<br>&gt; <br>&gt; Potentially, yes. This depends on how the ABI is handled in Swift 3 for enums. The same problem exists today, although at a lesser extent, for any API that returns an enum today.<br>&gt; <br>&gt; Chris Lattner mentioned this on the thread:<br>&gt; <br>&gt; The resilience model addresses how the public API from a module can evolve without breaking clients (either at the source level or ABI level).  Notably, we want the ability to be able to add enum cases to something by default, but also to allow API authors to opt into more performance/strictness by saying that a public enum is “fragile” or “closed for evolution”.<br>&gt; So if enums have an attribute that allows API authors to denote the fragility enums, then this can be handled via that route.<br>&gt; <br>&gt; Another potential fix is that only internal and private scoped functions are allowed to use the exhaustive-style catch-clauses. For all public APIs, they would still need the catch-all clauses.<br>&gt; <br>&gt; For APIs that return non-enum based ErrorType implementations, then no, this does not contribute to the fragility problem.<br>&gt; <br>&gt; Aren’t we creating the need for wrapper errors?<br>&gt; <br>&gt; This is a philosophical debate. I’ll simply state that I believe that simply re-throwing an error, say some type of IO error, from your API that is not an IO-based API is design flaw: you are exposing implementation details to users. This creates a fragile API surface.<br>&gt; <br>&gt; Also, since the type annotation is opt-in, I feel like this is a really minor argument. If your function is really able to throw errors from various different API calls, then just stick with the default ErrorType.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/8ef718fc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 18, 2015 at 10:00:00am</p></header><div class="content"><p>The biggest problem I have with error handling is that most schemes aren&#39;t predictable. I like that Swift&#39;s model forces you to reduce the possible errors to a single type, most easily an enum type, because this promotes predictability: your function can fail for no more or no less than what the enum has. This goes hand in hand with forcing try on functions that throw, so that you always know what could go wrong and what has gone wrong.<br></p><p>What I invariably hate about the common exception model and the common error code model is that the error conditions are either theoretically or practically infinite. It makes it hard to determine which errors you can actually trigger, which in turns makes it hard to decide which cases should be handled and which cases should be forwarded, which perpetuates that it&#39;s hard to determine which errors you can trigger.<br></p><p>Integral error codes are limited, but the limit is far above what human beings can model and consider, and each integral value can be overloaded. Microsoft&#39;s HRESULT and Apple&#39;s OSStatus are two examples of large and overloaded status codes (see osstatus.com for how bad this can get). Luckily, this model is discouraged with Swift.<br></p><p>Polymorphic exceptions, on their end, have two major shortfalls: they allow an infinite class of errors to be raised at any point where the call graph isn&#39;t entirely static (since developers can subclass the error class), and they encourage errors to be classified by kind instead of by cause.<br></p><p>In my opinion, kind-based exception hierarchies are the original sin of exception handling. For a spectacular failure of exception design, look no further than Java&#39;s IOException hierarchy. A method that catches an IOException may be dealing with a ClosedChannelException, a MalformedURLException, a UserPrincipalNotFoundException, an UnsupportedEncodingException, or any other of the 31 direct known subclasses (or a subclass of any of these), or any other user subclass. These are all things that can happen during some I/O, but it makes IOException as a catchable type entirely meaningless.<br></p><p>Unfortunately, it&#39;s extremely tempting to categorize exceptions by kind, because object-oriented programming is all about categorizing things by kind. This was just one of the platoon of exception hierarchies that fell down the proverbial slippery slope.<br></p><p>For this reason, I don&#39;t like to encourage throwing polymorphic types, and I think that it&#39;s a misconception to pretend that having a single type in the throws annotation ensures that the function throws a single type. In my opinion, the fact that it&#39;s currently possible but awkward to use polymorphic types as errors is exactly as much support as the feature should receive.<br></p><p>&gt; Le 18 déc. 2015 à 08:53:44, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; David,<br>&gt; <br>&gt; Thank you for taking the time to continue working on a proposal for typed throws.  I agree that this feature is very desirable and appreciate the work you’re doing to bring forward a proposal.  I think it’s a great start but also has some room for improvement.<br>&gt; <br>&gt; First, I think it could be strengthened by incorporating some learning from Rust.  My impression is that the Rust community is very happy with typed error handling.  Adding some detail about their experience would provide a counter-example to those who are concerned about the experience in Java and C++.<br>&gt; <br>&gt; I agree that error types are an important part of an API contract.  One of the big hurdles to doing this well is the need to catch errors when all that needs to be done is to wrap and rethrow them.  Ideally should not need to do this just to perform a simple type translation to map the underlying error into the type we wish to expose as part of a stable API contract.  You might want to take a look at the From mechanism Rust uses to facilitate this.  IMO a proposal for typed error handling should address this issue in some way (even if the author determines this mechanism is not necessary or a good design cannot be identified).<br>&gt; <br>&gt; I would also like to see much more detail on why you think allowing a function to throw multiple error types is problematic.  My impression is that you have concerns from a usability point of view.  I am on the fence here to some degree, but definitely leaning in the direction that allowing a function to throw multiple error types is better.  <br>&gt; <br>&gt; The primary reason I lean this way is that it enables more re-use of standard error types.  Custom error types for an API often make sense, but not always.  I am concerned about the need to create them just because our API contract might reasonably include two or three of the standard error types.  Adding new types when they are not necessary introduces complexity and cognitive overhead.  It also complicates catching of errors if the new custom type is a two or three case enum that just embeds the underlying error.  <br>&gt; <br>&gt; These problems will lead many people to just revert to an untyped throws clause.  Objections to typed errors along these lines are common and legitimate.  They will arise during review.  It is best if you address them in the proposal now in order to focus a review on your solutions.  My personal opinion is that allowing multiple error types and including a mechanism to perform automatic wrapping when appropriate would go a long way towards solving them.<br>&gt; <br>&gt; Implementation challenges related to multi-typed errors have been discussed on the list quite a bit already.  They would obviously need to be addressed if we go in that direction.  I don’t want to downplay those.  But I do think we need to try to identify the most usable solution for typed errors that we can first and then focus on implementation details.  If the design needs to be modified to accommodate implementation at least we will have a better idea of what we are giving up.<br>&gt; <br>&gt; I am willing to be convinced that a single error type is better than multiple error types but the current proposal does not provide a compelling argument in that direction.  It just says “Java checked exceptions”.  I know these have been pretty much universally considered a serious design mistake.  My impression is that there are quite a few reasons for that.  I don’t have any direct experience with Java and am not familiar with the details.  If you could elaborate on specifically why you believe allowing multiple error types was a significant contributor to the problem in a manner that indicates that they will be a problem in any language that includes them I would appreciate that.  Links would be sufficient if they are focused on answering this particular question.  <br>&gt; <br>&gt; I’m looking forward to your feedback on these thoughts.<br>&gt; <br>&gt; Thanks,<br>&gt; Matthew<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 18, 2015, at 1:29 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This a significantly updated proposal for typed annotations on the `throws` construct. The previous was closed due to not be complete; I believe I’ve addressed all of those concerns.<br>&gt;&gt; <br>&gt;&gt; https://github.com/owensd/swift-evolution/blob/master/proposals/allow-type-annotations-on-throw.md &lt;https://github.com/owensd/swift-evolution/blob/master/proposals/allow-type-annotations-on-throw.md&gt;<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/8180bf75/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 18, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 9:03 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; The biggest problem I have with error handling is that most schemes aren&#39;t predictable. I like that Swift&#39;s model forces you to reduce the possible errors to a single type, most easily an enum type, because this promotes predictability: your function can fail for no more or no less than what the enum has. This goes hand in hand with forcing try on functions that throw, so that you always know what could go wrong and what has gone wrong.<br>&gt; <br>&gt; What I invariably hate about the common exception model and the common error code model is that the error conditions are either theoretically or practically infinite. It makes it hard to determine which errors you can actually trigger, which in turns makes it hard to decide which cases should be handled and which cases should be forwarded, which perpetuates that it&#39;s hard to determine which errors you can trigger.<br>&gt; <br>&gt; Integral error codes are limited, but the limit is far above what human beings can model and consider, and each integral value can be overloaded. Microsoft&#39;s HRESULT and Apple&#39;s OSStatus are two examples of large and overloaded status codes (see osstatus.com &lt;http://osstatus.com/&gt; for how bad this can get). Luckily, this model is discouraged with Swift.<br></p><p>+1 to these comments.  A finite list of non-polymorphic error types (ideally enums to explicitly declare the cases) has the same advantages of discoverability.  It also has the potential advantage that it is would be easier to re-use error types.  If this is done carefully it could facilitate improved re-use of error handling code.  The potential downside is that it could encourage less thoughtful API contracts where people just add any error type they might trigger to the list.  An error translation mechanism similar to From in Rust is probably necessary to mitigate this.<br></p><p>&gt; <br>&gt; Polymorphic exceptions, on their end, have two major shortfalls: they allow an infinite class of errors to be raised at any point where the call graph isn&#39;t entirely static (since developers can subclass the error class), and they encourage errors to be classified by kind instead of by cause.<br>&gt; <br>&gt; In my opinion, kind-based exception hierarchies are the original sin of exception handling. For a spectacular failure of exception design, look no further than Java&#39;s IOException hierarchy. A method that catches an IOException may be dealing with a ClosedChannelException, a MalformedURLException, a UserPrincipalNotFoundException, an UnsupportedEncodingException, or any other of the 31 direct known subclasses (or a subclass of any of these), or any other user subclass. These are all things that can happen during some I/O, but it makes IOException as a catchable type entirely meaningless.<br></p><p>Agree.  This sounds awful.<br></p><p>&gt; <br>&gt; Unfortunately, it&#39;s extremely tempting to categorize exceptions by kind, because object-oriented programming is all about categorizing things by kind. This was just one of the platoon of exception hierarchies that fell down the proverbial slippery slope.<br>&gt; <br>&gt; For this reason, I don&#39;t like to encourage throwing polymorphic types, and I think that it&#39;s a misconception to pretend that having a single type in the throws annotation ensures that the function throws a single type. In my opinion, the fact that it&#39;s currently possible but awkward to use polymorphic types as errors is exactly as much support as the feature should receive.<br></p><p>I agree with most of what you’re stating here.  Except that the only type information currently available for throwing functions is that they throw `ErrorType`.  It doesn’t get more polymorphic than that!<br></p><p>&gt; <br>&gt;&gt; Le 18 déc. 2015 à 08:53:44, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; David,<br>&gt;&gt; <br>&gt;&gt; Thank you for taking the time to continue working on a proposal for typed throws.  I agree that this feature is very desirable and appreciate the work you’re doing to bring forward a proposal.  I think it’s a great start but also has some room for improvement.<br>&gt;&gt; <br>&gt;&gt; First, I think it could be strengthened by incorporating some learning from Rust.  My impression is that the Rust community is very happy with typed error handling.  Adding some detail about their experience would provide a counter-example to those who are concerned about the experience in Java and C++.<br>&gt;&gt; <br>&gt;&gt; I agree that error types are an important part of an API contract.  One of the big hurdles to doing this well is the need to catch errors when all that needs to be done is to wrap and rethrow them.  Ideally should not need to do this just to perform a simple type translation to map the underlying error into the type we wish to expose as part of a stable API contract.  You might want to take a look at the From mechanism Rust uses to facilitate this.  IMO a proposal for typed error handling should address this issue in some way (even if the author determines this mechanism is not necessary or a good design cannot be identified).<br>&gt;&gt; <br>&gt;&gt; I would also like to see much more detail on why you think allowing a function to throw multiple error types is problematic.  My impression is that you have concerns from a usability point of view.  I am on the fence here to some degree, but definitely leaning in the direction that allowing a function to throw multiple error types is better.  <br>&gt;&gt; <br>&gt;&gt; The primary reason I lean this way is that it enables more re-use of standard error types.  Custom error types for an API often make sense, but not always.  I am concerned about the need to create them just because our API contract might reasonably include two or three of the standard error types.  Adding new types when they are not necessary introduces complexity and cognitive overhead.  It also complicates catching of errors if the new custom type is a two or three case enum that just embeds the underlying error.  <br>&gt;&gt; <br>&gt;&gt; These problems will lead many people to just revert to an untyped throws clause.  Objections to typed errors along these lines are common and legitimate.  They will arise during review.  It is best if you address them in the proposal now in order to focus a review on your solutions.  My personal opinion is that allowing multiple error types and including a mechanism to perform automatic wrapping when appropriate would go a long way towards solving them.<br>&gt;&gt; <br>&gt;&gt; Implementation challenges related to multi-typed errors have been discussed on the list quite a bit already.  They would obviously need to be addressed if we go in that direction.  I don’t want to downplay those.  But I do think we need to try to identify the most usable solution for typed errors that we can first and then focus on implementation details.  If the design needs to be modified to accommodate implementation at least we will have a better idea of what we are giving up.<br>&gt;&gt; <br>&gt;&gt; I am willing to be convinced that a single error type is better than multiple error types but the current proposal does not provide a compelling argument in that direction.  It just says “Java checked exceptions”.  I know these have been pretty much universally considered a serious design mistake.  My impression is that there are quite a few reasons for that.  I don’t have any direct experience with Java and am not familiar with the details.  If you could elaborate on specifically why you believe allowing multiple error types was a significant contributor to the problem in a manner that indicates that they will be a problem in any language that includes them I would appreciate that.  Links would be sufficient if they are focused on answering this particular question.  <br>&gt;&gt; <br>&gt;&gt; I’m looking forward to your feedback on these thoughts.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 18, 2015, at 1:29 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This a significantly updated proposal for typed annotations on the `throws` construct. The previous was closed due to not be complete; I believe I’ve addressed all of those concerns.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/owensd/swift-evolution/blob/master/proposals/allow-type-annotations-on-throw.md &lt;https://github.com/owensd/swift-evolution/blob/master/proposals/allow-type-annotations-on-throw.md&gt;<br>&gt;&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/b7db8ea7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 18, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 7:03 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; For this reason, I don&#39;t like to encourage throwing polymorphic types, and I think that it&#39;s a misconception to pretend that having a single type in the throws annotation ensures that the function throws a single type. In my opinion, the fact that it&#39;s currently possible but awkward to use polymorphic types as errors is exactly as much support as the feature should receive.<br></p><p>I don’t follow this. Declaring a type that is an enum or a struct absolutely guarantees that the function only returns a single type. If the type is a class-based error, then sure, there’s not guarantee.<br></p><p>However, the only option today is polymorphic error types. <br></p><p>-David<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 18, 2015 at 12:00:00pm</p></header><div class="content"><p>I&#39;m not sure I understand your comment either. If I understand correctly, you say that the problem I describe is applicable only to polymorphic types (which is true). However, you then say that the only option today is polymorphic error types. Isn&#39;t that an issue? (Also, why is it the only option today?)<br></p><p>&gt; Le 18 déc. 2015 à 11:58:44, David Owens II &lt;david at owensd.io&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 18, 2015, at 7:03 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; For this reason, I don&#39;t like to encourage throwing polymorphic types, and I think that it&#39;s a misconception to pretend that having a single type in the throws annotation ensures that the function throws a single type. In my opinion, the fact that it&#39;s currently possible but awkward to use polymorphic types as errors is exactly as much support as the feature should receive.<br>&gt; <br>&gt; I don’t follow this. Declaring a type that is an enum or a struct absolutely guarantees that the function only returns a single type. If the type is a class-based error, then sure, there’s not guarantee.<br>&gt; <br>&gt; However, the only option today is polymorphic error types. <br>&gt; <br>&gt; -David<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 18, 2015 at 12:00:00pm</p></header><div class="content"><p>Oh, I see what you mean. I considered polymorphic types to be class hierarchies, when you&#39;re talking about ErrorType polymorphism.<br></p><p>Yes, I think that the compiler should be aware of what the function can throw, but I would be happier if it stayed a bit inconvenient to use reference types.<br></p><p>&gt; Le 18 déc. 2015 à 12:17:06, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I&#39;m not sure I understand your comment either. If I understand correctly, you say that the problem I describe is applicable only to polymorphic types (which is true). However, you then say that the only option today is polymorphic error types. Isn&#39;t that an issue? (Also, why is it the only option today?)<br>&gt; <br>&gt;&gt; Le 18 déc. 2015 à 11:58:44, David Owens II &lt;david at owensd.io&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 18, 2015, at 7:03 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For this reason, I don&#39;t like to encourage throwing polymorphic types, and I think that it&#39;s a misconception to pretend that having a single type in the throws annotation ensures that the function throws a single type. In my opinion, the fact that it&#39;s currently possible but awkward to use polymorphic types as errors is exactly as much support as the feature should receive.<br>&gt;&gt; <br>&gt;&gt; I don’t follow this. Declaring a type that is an enum or a struct absolutely guarantees that the function only returns a single type. If the type is a class-based error, then sure, there’s not guarantee.<br>&gt;&gt; <br>&gt;&gt; However, the only option today is polymorphic error types. <br>&gt;&gt; <br>&gt;&gt; -David<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 18, 2015 at 09:00:00am</p></header><div class="content"><p>I’d be ok with having enum/struct only error types, however, I don’t have a compelling reason to really limit their usage context. Also, that would complicate the bridging with NSError at the moment.<br></p><p>FYI: I’ve added some updates to the criticism section to qualify the Java checked-exceptions and the multiple error type annotations.<br></p><p>-David<br></p><p>&gt; On Dec 18, 2015, at 9:21 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; Oh, I see what you mean. I considered polymorphic types to be class hierarchies, when you&#39;re talking about ErrorType polymorphism.<br>&gt; <br>&gt; Yes, I think that the compiler should be aware of what the function can throw, but I would be happier if it stayed a bit inconvenient to use reference types.<br>&gt; <br>&gt;&gt; Le 18 déc. 2015 à 12:17:06, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure I understand your comment either. If I understand correctly, you say that the problem I describe is applicable only to polymorphic types (which is true). However, you then say that the only option today is polymorphic error types. Isn&#39;t that an issue? (Also, why is it the only option today?)<br>&gt;&gt; <br>&gt;&gt;&gt; Le 18 déc. 2015 à 11:58:44, David Owens II &lt;david at owensd.io&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 18, 2015, at 7:03 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For this reason, I don&#39;t like to encourage throwing polymorphic types, and I think that it&#39;s a misconception to pretend that having a single type in the throws annotation ensures that the function throws a single type. In my opinion, the fact that it&#39;s currently possible but awkward to use polymorphic types as errors is exactly as much support as the feature should receive.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t follow this. Declaring a type that is an enum or a struct absolutely guarantees that the function only returns a single type. If the type is a class-based error, then sure, there’s not guarantee.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, the only option today is polymorphic error types. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -David<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 18, 2015 at 05:00:00pm</p></header><div class="content"><p>It certainly would complicate NSError bridging, David. What you could do is<br>treat it as a special case, so saying &quot;throws NSError&quot; in Swift would not<br>be allowed, but the objC functions that take an inout NSError parameter are<br>automatically annotated by &quot;throws NSError&quot; in Swift usage. This steps<br>around almost any restriction on what we programmers can specify to be<br>thrown in Swift.<br></p><p>On Fri, Dec 18, 2015 at 12:35 PM David Owens II via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I’d be ok with having enum/struct only error types, however, I don’t have<br>&gt; a compelling reason to really limit their usage context. Also, that would<br>&gt; complicate the bridging with NSError at the moment.<br>&gt;<br>&gt; FYI: I’ve added some updates to the criticism section to qualify the Java<br>&gt; checked-exceptions and the multiple error type annotations.<br>&gt;<br>&gt; -David<br>&gt;<br>&gt; &gt; On Dec 18, 2015, at 9:21 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Oh, I see what you mean. I considered polymorphic types to be class<br>&gt; hierarchies, when you&#39;re talking about ErrorType polymorphism.<br>&gt; &gt;<br>&gt; &gt; Yes, I think that the compiler should be aware of what the function can<br>&gt; throw, but I would be happier if it stayed a bit inconvenient to use<br>&gt; reference types.<br>&gt; &gt;<br>&gt; &gt;&gt; Le 18 déc. 2015 à 12:17:06, Félix Cloutier via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I&#39;m not sure I understand your comment either. If I understand<br>&gt; correctly, you say that the problem I describe is applicable only to<br>&gt; polymorphic types (which is true). However, you then say that the only<br>&gt; option today is polymorphic error types. Isn&#39;t that an issue? (Also, why is<br>&gt; it the only option today?)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Le 18 déc. 2015 à 11:58:44, David Owens II &lt;david at owensd.io&gt; a écrit :<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On Dec 18, 2015, at 7:03 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; For this reason, I don&#39;t like to encourage throwing polymorphic<br>&gt; types, and I think that it&#39;s a misconception to pretend that having a<br>&gt; single type in the throws annotation ensures that the function throws a<br>&gt; single type. In my opinion, the fact that it&#39;s currently possible but<br>&gt; awkward to use polymorphic types as errors is exactly as much support as<br>&gt; the feature should receive.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I don’t follow this. Declaring a type that is an enum or a struct<br>&gt; absolutely guarantees that the function only returns a single type. If the<br>&gt; type is a class-based error, then sure, there’s not guarantee.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; However, the only option today is polymorphic error types.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; -David<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/c4fb9e41/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 18, 2015 at 03:00:00pm</p></header><div class="content"><p>Genuinely, David, thank you for taking up the mantle of this problem. To<br>me, the lack of type annotations makes the error handling painful and I<br>wish the team just hadn&#39;t released it until the design was smoothed out<br>fully. Those dangling catch-all blocks when I&#39;ve caught all cases make it<br>uselessly verbose and moreover do not fit with the language at all.<br></p><p>As for the multiple vs. single type annotations, I do think that you need a<br>concrete example of why this will be different from java to quell the<br>concerns of all the people that skim the proposal, don&#39;t think about it,<br>and exclaim &quot;but everyone hates it in Java!&quot; so I agree on the singular<br>type annotations.<br></p><p>Also, your point about being able to mark functions async strongly supports<br>single type annotations until we get union types (if ever).<br></p><p>I am glad you addressed covariance/contravariance and the semantics of<br>function types when they throw general errors vs. a specific one.<br></p><p>One question, mainly to the compiler team: would it be reasonable to be<br>able to use generics covariant over the throws operator? For example, I<br>could define a function that takes a function which throws E and returns R,<br>and creates a function that takes a callback which takes an argument of<br>type Either&lt;R, E&gt; instead. This would be an incredibly powerful feature.<br></p><p>On Fri, Dec 18, 2015, 8:53 AM Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; David,<br>&gt;<br>&gt; Thank you for taking the time to continue working on a proposal for typed<br>&gt; throws.  I agree that this feature is very desirable and appreciate the<br>&gt; work you’re doing to bring forward a proposal.  I think it’s a great start<br>&gt; but also has some room for improvement.<br>&gt;<br>&gt; First, I think it could be strengthened by incorporating some learning<br>&gt; from Rust.  My impression is that the Rust community is very happy with<br>&gt; typed error handling.  Adding some detail about their experience would<br>&gt; provide a counter-example to those who are concerned about the experience<br>&gt; in Java and C++.<br>&gt;<br>&gt; I agree that error types are an important part of an API contract.  One of<br>&gt; the big hurdles to doing this well is the need to catch errors when all<br>&gt; that needs to be done is to wrap and rethrow them.  Ideally should not need<br>&gt; to do this just to perform a simple type translation to map the underlying<br>&gt; error into the type we wish to expose as part of a stable API contract.<br>&gt; You might want to take a look at the From mechanism Rust uses to facilitate<br>&gt; this.  IMO a proposal for typed error handling should address this issue in<br>&gt; some way (even if the author determines this mechanism is not necessary or<br>&gt; a good design cannot be identified).<br>&gt;<br>&gt; I would also like to see much more detail on why you think allowing a<br>&gt; function to throw multiple error types is problematic.  My impression is<br>&gt; that you have concerns from a usability point of view.  I am on the fence<br>&gt; here to some degree, but definitely leaning in the direction that allowing<br>&gt; a function to throw multiple error types is better.<br>&gt;<br>&gt; The primary reason I lean this way is that it enables more re-use of<br>&gt; standard error types.  Custom error types for an API often make sense, but<br>&gt; not always.  I am concerned about the need to create them just because our<br>&gt; API contract might reasonably include two or three of the standard error<br>&gt; types.  Adding new types when they are not necessary introduces complexity<br>&gt; and cognitive overhead.  It also complicates catching of errors if the new<br>&gt; custom type is a two or three case enum that just embeds the underlying<br>&gt; error.<br>&gt;<br>&gt; These problems will lead many people to just revert to an untyped throws<br>&gt; clause.  Objections to typed errors along these lines are common and<br>&gt; legitimate.  They will arise during review.  It is best if you address them<br>&gt; in the proposal now in order to focus a review on your solutions.  My<br>&gt; personal opinion is that allowing multiple error types and including a<br>&gt; mechanism to perform automatic wrapping when appropriate would go a long<br>&gt; way towards solving them.<br>&gt;<br>&gt; Implementation challenges related to multi-typed errors have been<br>&gt; discussed on the list quite a bit already.  They would obviously need to be<br>&gt; addressed if we go in that direction.  I don’t want to downplay those.  But<br>&gt; I do think we need to try to identify the most usable solution for typed<br>&gt; errors that we can first and then focus on implementation details.  If the<br>&gt; design needs to be modified to accommodate implementation at least we will<br>&gt; have a better idea of what we are giving up.<br>&gt;<br>&gt; I am willing to be convinced that a single error type is better than<br>&gt; multiple error types but the current proposal does not provide a compelling<br>&gt; argument in that direction.  It just says “Java checked exceptions”.  I<br>&gt; know these have been pretty much universally considered a serious design<br>&gt; mistake.  My impression is that there are quite a few reasons for that.  I<br>&gt; don’t have any direct experience with Java and am not familiar with the<br>&gt; details.  If you could elaborate on specifically why you believe allowing<br>&gt; multiple error types was a significant contributor to the problem in a<br>&gt; manner that indicates that they will be a problem in any language that<br>&gt; includes them I would appreciate that.  Links would be sufficient if they<br>&gt; are focused on answering this particular question.<br>&gt;<br>&gt; I’m looking forward to your feedback on these thoughts.<br>&gt;<br>&gt; Thanks,<br>&gt; Matthew<br>&gt;<br>&gt;<br>&gt; On Dec 18, 2015, at 1:29 AM, David Owens II via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; This a significantly updated proposal for typed annotations on the<br>&gt; `throws` construct. The previous was closed due to not be complete; I<br>&gt; believe I’ve addressed all of those concerns.<br>&gt;<br>&gt;<br>&gt; https://github.com/owensd/swift-evolution/blob/master/proposals/allow-type-annotations-on-throw.md<br>&gt;<br>&gt; —<br>&gt;<br>&gt; Allow Type Annotation on Throws<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    - Author(s): David Owens II<br>&gt;    - Status: *Pending Approval for Review*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; The error handling system within Swift today creates an implicitly loose<br>&gt; contract on the API. While this can be desirable in some cases, it’s<br>&gt; certainly not desired in *all* cases. This proposal looks at modifying<br>&gt; how the error handling mechanism works today by adding the ability to<br>&gt; provide a strong API contract.<br>&gt; Error Handling State of the Union<br>&gt;<br>&gt; This document will use the terminology and the premises defined in the Error<br>&gt; Handling Rationale<br>&gt; &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt;<br>&gt;  document.<br>&gt;<br>&gt; To very briefly summarize, there are four basic classification of errors:<br>&gt;<br>&gt;    1. Simple Domain Errors<br>&gt;    2. Recoverable Errors<br>&gt;    3. Universal Errors<br>&gt;    4. Logic Failures<br>&gt;<br>&gt; Each of these types of errors are handled differently at the call sites.<br>&gt; Today, only the first two are directly handled by Swift error handling<br>&gt; mechanism. The second two are uncatchable in Swift (such as fatalError(),<br>&gt; ObjC exceptions, and force-unwrapping of null optionals).<br>&gt; Simple Domain Errors<br>&gt;<br>&gt; As stated in Error Handling Rationale<br>&gt; &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt; document,<br>&gt; the “Swift way” to handle such errors is to return an Optional&lt;T&gt;.<br>&gt;<br>&gt; func parseInt(value: String) -&gt; Int? {}<br>&gt;<br>&gt; The simple fact of the result being Optional.None signifies that the<br>&gt; string could not be parsed and converted into an Int. No other<br>&gt; information is necessary or warranted.<br>&gt; Recoverable Errors<br>&gt;<br>&gt; In this context, these are errors that need to provide additional<br>&gt; information to the caller. The caller can then decide a course of action<br>&gt; that needs to be taken. This could be any number of things, including, but<br>&gt; not limited to, logging error information, attempting a retry, or<br>&gt; potentially invoking a different code path. All of these errors implement<br>&gt; the ErrorType protocol.<br>&gt;<br>&gt; func openFile(filename: String) throws {}<br>&gt;<br>&gt; The throws keyword annotates that the function can return additional<br>&gt; error information. The caller must also explicitly make use of this when<br>&gt; invoking the function.<br>&gt;<br>&gt; do {<br>&gt;   try openFile(&quot;path/to/somewhere&quot;)<br>&gt; }<br>&gt; catch {}<br>&gt;<br>&gt; Errors are able to propagate if called within another context that can<br>&gt; throw, thus alleviating the annoying “catch and rethrow” behavior:<br>&gt;<br>&gt; func parent() throws {<br>&gt;   try openFile(&quot;path/to/somwhere&quot;)<br>&gt; }<br>&gt;<br>&gt; Lastly, functions can be marked to selectively throw errors if they take a<br>&gt; function parameter that throws with the rethrows keyword. The really<br>&gt; interesting part is that it’s only necessary to use try when calling the<br>&gt; function with a throwing closure.<br>&gt;<br>&gt; func openFile(filename: String) throws {}<br>&gt; func say(message: String) {}<br>&gt;<br>&gt; func sample(fn: (_: String) throws -&gt; ()) rethrows {<br>&gt;     try fn(&quot;hi&quot;)<br>&gt; }<br>&gt;<br>&gt; try sample(openFile)<br>&gt; sample(say)<br>&gt;<br>&gt; Converting Recoverable Errors to Domain Errors<br>&gt;<br>&gt; Swift also has the try? construct. The notable thing about this construct<br>&gt; is that it allows the caller to turn a “Recoverable Error” into a “Simple<br>&gt; Domain Error”.<br>&gt;<br>&gt; if let result = try? openFile(&quot;&quot;) {}<br>&gt;<br>&gt; ErrorType Implementors<br>&gt;<br>&gt; Errors are implemented using the ErrorType protocol. Since it is a<br>&gt; protocol, new error types can be a class, a struct, or an enum. A type<br>&gt; qualified throws clause would allow code authors to change the way that<br>&gt; the catch-clauses need to be structured.<br>&gt; Enum Based ErrorType<br>&gt;<br>&gt; When enums are used as the throwing mechanism, a generic catch-clause is<br>&gt; still required as the compiler doesn’t have enough information. This leads<br>&gt; to ambiguous code paths.<br>&gt;<br>&gt; enum Errors: ErrorType {<br>&gt;     case OffBy1<br>&gt;     case MutatedValue<br>&gt; }<br>&gt;<br>&gt; func f() throws { throw Errors.OffBy1 }<br>&gt;<br>&gt; do {<br>&gt;     try f()<br>&gt; }<br>&gt; catch Errors.OffBy1 { print(&quot;increment by 1&quot;) }<br>&gt; catch Errors.MutatedValue { fatalError(&quot;data corrupted&quot;) }<br>&gt;<br>&gt; The above code requires a catch {} clause, but it’s ambiguous what that<br>&gt; case should do. There is no *right* way to handle this error. If the<br>&gt; error is ignored, we’re now in the land of “Logic Errors”; the code path<br>&gt; should never be hit. If we use a fatalError() construct, then we are now<br>&gt; in the land of converting a potential compiler error into a “Universal<br>&gt; Error”.<br>&gt;<br>&gt; Both of these are undesirable.<br>&gt; Struct and Class Based ErrorType<br>&gt;<br>&gt; In the current design, errors that are thrown require a catch-all all the<br>&gt; time. In the proposed design, which will be explained further, a catch-all<br>&gt; would not be required if there was a case-clause that matched the base type.<br>&gt;<br>&gt; class ErrorOne: ErrorType {}<br>&gt; func g() throws { throw ErrorOne() }<br>&gt;<br>&gt; do {<br>&gt;     try g()<br>&gt; }<br>&gt; catch is ErrorOne { print(&quot;ErrorOne&quot;) }<br>&gt;<br>&gt; The advantage in these cases are different, these cases do not allow<br>&gt; pattern matching over the error type members (as you can in a<br>&gt; switch-statement, for example).<br>&gt;<br>&gt; The workaround for this functionality is this:<br>&gt;<br>&gt; class ErrorOne: ErrorType {<br>&gt;     let value: Int<br>&gt;     init(_ value: Int) { self.value = value }<br>&gt; }<br>&gt;<br>&gt; do {<br>&gt;     try g()<br>&gt; }<br>&gt; catch {<br>&gt;     if let e = error as? ErrorOne {<br>&gt;         switch e {<br>&gt;         case _ where e.value == 0: print(&quot;0&quot;)<br>&gt;         case _ where e.value == 1: print(&quot;1&quot;)<br>&gt;         default: print(&quot;nothing&quot;)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; This proposal would turn the above into:<br>&gt;<br>&gt; class ErrorOne: ErrorType {<br>&gt;     let value: Int<br>&gt;     init(_ value: Int) { self.value = value }<br>&gt; }<br>&gt;<br>&gt; do {<br>&gt;     try g()<br>&gt; }<br>&gt; catch _ where error.value == 0 { print(&quot;0&quot;) }<br>&gt; catch _ where error.value == 1 { print(&quot;1&quot;) }<br>&gt; catch { print(&quot;nothing&quot;) }<br>&gt; }<br>&gt;<br>&gt; No gymnastics to go through, just straight-forward pattern-matching like<br>&gt; you’d expect.<br>&gt;<br>&gt; NOTE: This requires the promotion of the error constant to be allowed<br>&gt; through the entirety of the catch-clauses.<br>&gt; Overriding<br>&gt;<br>&gt; In the context of types, it’s completely possible to override functions<br>&gt; with the throws annotations. The rules simply follow the rules today:<br>&gt; covariance on the return type is allowed, contravariance is not.<br>&gt; Generics<br>&gt;<br>&gt; When looking at generics, I cannot come up with a reason why they<br>&gt; shouldn’t just work as normal:<br>&gt;<br>&gt; func gen&lt;SomeError: ErrorType&gt;() throws SomeError {}<br>&gt;<br>&gt; The only constraint would be that the specified error type must adhere to<br>&gt; the ErrorType protocol. However, this is no different than today:<br>&gt;<br>&gt; func f&lt;T&gt;(a: T) throws { throw a }<br>&gt;<br>&gt; This results in the compiler error:<br>&gt;<br>&gt; Thrown expression type ’T’ does not conform to ‘ErrorType’<br>&gt;<br>&gt; This seems like it should “just work”.<br>&gt; Design Change Proposal<br>&gt;<br>&gt; The design change is simple and straight-forward: allow for the annotation<br>&gt; of the type of error that is being returned as an optional restriction. The<br>&gt; default value would still be ErrorType.<br>&gt;<br>&gt; func specific() throws MyError {}<br>&gt; func nonspecific() throws {}<br>&gt;<br>&gt; There is a secondary result of this proposal: the error constant should<br>&gt; be promoted to be allowed for use through-out all of the catch-clauses.<br>&gt; Impact on Existing Code<br>&gt;<br>&gt; This is a non-breaking change. All existing constructs work today without<br>&gt; change. That said, there are a few places where this change will have an<br>&gt; impact on future usage.<br>&gt; Function Declarations<br>&gt;<br>&gt; When a function has a throws clause that is attributed with a type, then<br>&gt; that type becomes part of the function signature. This means that these two<br>&gt; functions are not considered to be of the same type:<br>&gt;<br>&gt; func one() throws {}<br>&gt; func two() throws NumberError {}<br>&gt;<br>&gt; The function signatures are covariant though, so either one or two can be<br>&gt; assigned to f below:<br>&gt;<br>&gt; let f: () throws -&gt; ()<br>&gt;<br>&gt; This is completely fine as NumberError still implements the ErrorType<br>&gt;  protocol.<br>&gt;<br>&gt; However, in this case:<br>&gt;<br>&gt; let g: () throws NumberError -&gt; ()<br>&gt;<br>&gt; It would not be valid to assign one to g as the type signature is more<br>&gt; specific.<br>&gt; throws and rethrows<br>&gt;<br>&gt; Functions currently have the ability to be marked as rethrows. This<br>&gt; basically says that if a closure parameter can throw, then the function<br>&gt; will throw too.<br>&gt;<br>&gt; func whatever(fn: () throws -&gt; ()) rethrows {}<br>&gt;<br>&gt; The whatever function is up for anything that fn is up for. Keeping in<br>&gt; line with this mentality, the rethrows would exhibit the same behavior:<br>&gt; typed annotations simply apply if present and do not if they are missing.<br>&gt;<br>&gt; func specific(fn: () throws HappyError -&gt; ()) rethrows {}<br>&gt;<br>&gt; This all works as expected:<br>&gt;<br>&gt; func f() throws HappyError {}<br>&gt; func g() {}<br>&gt;<br>&gt; try specific(f)<br>&gt; specific(g)<br>&gt;<br>&gt; This works for the same covariant reason as the non-qualified throws implementation<br>&gt; works: a non-throwing function is always able to be passed in for a<br>&gt; throwing function.<br>&gt; The do-catch statement<br>&gt;<br>&gt; There are two rule changes here, but again, it’s non-breaking.<br>&gt;<br>&gt; The first rule change is to promote the error constant that would<br>&gt; normally only be allowed in the catch-all clause (no patterns) to be<br>&gt; available throughout each of the catch clauses. This allows for the error<br>&gt; information to be used in pattern matching, which is especially valuable in<br>&gt; the non-enum case.<br>&gt;<br>&gt; The second change is to allow the error constant to take on a specific<br>&gt; type when *all* of the throwing functions throw the same specified type.<br>&gt; When this is the case, two things become possible:<br>&gt;<br>&gt;    1. In the enum-type implementation of ErrorType, the catch-clauses can<br>&gt;    now be exhaustive.<br>&gt;    2. In the all of the cases, the API of the specific ErrorType becomes<br>&gt;    available in the catch-clause without casting the error constant. This<br>&gt;    greatly simplifies the pattern-matching process.<br>&gt;<br>&gt; In the case that there are heterogenous ErrorType implementations being<br>&gt; returned, the errorconstant simply has the type of ErrorType.<br>&gt; The try call sites<br>&gt;<br>&gt; There is no change for the try, try?, or try! uses. The only<br>&gt; clarification I’ll add is that try?is still the appropriate way to<br>&gt; promote an error from a “Recoverable Error” to a “Simple Domain Error”.<br>&gt; Alternate Proposals<br>&gt;<br>&gt; There is another common error handling mechanism used in the community<br>&gt; today: Either&lt;L, R&gt;. There are various implementations, but they all<br>&gt; basically boil down to an enum that captures the value or the error<br>&gt; information.<br>&gt;<br>&gt; I actually consider my proposal syntactic sugar over this concept. If and<br>&gt; when Swift supports covariant generics, there is not a significant reason I<br>&gt; can see why the underlying implementation could not just be that.<br>&gt;<br>&gt; The advantage is that the proposed (and existing) syntax of throws greatly<br>&gt; increases the readability and understanding that this function actually<br>&gt; possesses the ability to throw errors and they should be handled.<br>&gt;<br>&gt; The other advantage of this syntax is that it doesn’t require a new<br>&gt; construct to force the usage of the return type.<br>&gt;<br>&gt; Further, if functions where to ever gain the ability to be marked as async,<br>&gt; this could now be handled naturally within the compiler as the return type<br>&gt; could a promise-like implementation for those.<br>&gt; Criticisms<br>&gt;<br>&gt; From the earlier threads on the swift-evolution mailing list, there are a<br>&gt; few primary points of contention about this proposal.<br>&gt; Aren’t we just creating Java checked-exceptions, which we all know are<br>&gt; terrible?<br>&gt;<br>&gt; No. The primary reason is that a function can only return a single<br>&gt; error-type. The other major reason is that the error philosophy is very<br>&gt; different in Swift than in Java.<br>&gt; Aren’t we creating fragile APIs that can cause breaking changes?<br>&gt;<br>&gt; Potentially, yes. This depends on how the ABI is handled in Swift 3 for<br>&gt; enums. The same problem exists today, although at a lesser extent, for any<br>&gt; API that returns an enum today.<br>&gt;<br>&gt; Chris Lattner mentioned this on the thread:<br>&gt;<br>&gt; The resilience model addresses how the public API from a module can evolve<br>&gt; without breaking clients (either at the source level or ABI level).<br>&gt; Notably, we want the ability to be able to add enum cases to something by<br>&gt; default, but also to allow API authors to opt into more<br>&gt; performance/strictness by saying that a public enum is “fragile” or “closed<br>&gt; for evolution”.<br>&gt;<br>&gt; So if enums have an attribute that allows API authors to denote the<br>&gt; fragility enums, then this can be handled via that route.<br>&gt;<br>&gt; Another potential fix is that *only* internal and private scoped<br>&gt; functions are allowed to use the exhaustive-style catch-clauses. For all<br>&gt; public APIs, they would still need the catch-all clauses.<br>&gt;<br>&gt; For APIs that return non-enum based ErrorType implementations, then no,<br>&gt; this does not contribute to the fragility problem.<br>&gt; Aren’t we creating the need for wrapper errors?<br>&gt;<br>&gt; This is a philosophical debate. I’ll simply state that I believe that<br>&gt; simply re-throwing an error, say some type of IO error, from your API that<br>&gt; is not an IO-based API is design flaw: you are exposing implementation<br>&gt; details to users. This creates a fragile API surface.<br>&gt;<br>&gt; Also, since the type annotation is opt-in, I feel like this is a really<br>&gt; minor argument. If your function is really able to throw errors from<br>&gt; various different API calls, then just stick with the default ErrorType.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/e9fe4bca/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 18, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 9:25 AM, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt; wrote:<br>&gt; <br>&gt; Genuinely, David, thank you for taking up the mantle of this problem. To me, the lack of type annotations makes the error handling painful and I wish the team just hadn&#39;t released it until the design was smoothed out fully. Those dangling catch-all blocks when I&#39;ve caught all cases make it uselessly verbose and moreover do not fit with the language at all. <br>&gt; <br>&gt; As for the multiple vs. single type annotations, I do think that you need a concrete example of why this will be different from java to quell the concerns of all the people that skim the proposal, don&#39;t think about it, and exclaim &quot;but everyone hates it in Java!&quot; so I agree on the singular type annotations.<br>&gt; <br>I definitely agree that we need to address the Java problem.  That said, I don’t think avoiding knee-jerk objection from people who don’t read and consider a proposal carefully is a good way to approach design.  There may be good reasons to choose singular type annotations but this is not one of them.<br></p><p>I believe Félix raised good points about polymorphism and complex hierarchy causing problems in Java.  That sounds like it is the source of at least a significant part of the problems with Java’s checked exception model.<br>&gt; Also, your point about being able to mark functions async strongly supports single type annotations until we get union types (if ever). <br>&gt; <br>&gt; I am glad you addressed covariance/contravariance and the semantics of function types when they throw general errors vs. a specific one. <br>&gt; <br>&gt; One question, mainly to the compiler team: would it be reasonable to be able to use generics covariant over the throws operator? For example, I could define a function that takes a function which throws E and returns R, and creates a function that takes a callback which takes an argument of type Either&lt;R, E&gt; instead. This would be an incredibly powerful feature. <br>&gt; <br>&gt; <br>&gt; On Fri, Dec 18, 2015, 8:53 AM Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; David,<br>&gt; <br>&gt; Thank you for taking the time to continue working on a proposal for typed throws.  I agree that this feature is very desirable and appreciate the work you’re doing to bring forward a proposal.  I think it’s a great start but also has some room for improvement.<br>&gt; <br>&gt; First, I think it could be strengthened by incorporating some learning from Rust.  My impression is that the Rust community is very happy with typed error handling.  Adding some detail about their experience would provide a counter-example to those who are concerned about the experience in Java and C++.<br>&gt; <br>&gt; I agree that error types are an important part of an API contract.  One of the big hurdles to doing this well is the need to catch errors when all that needs to be done is to wrap and rethrow them.  Ideally should not need to do this just to perform a simple type translation to map the underlying error into the type we wish to expose as part of a stable API contract.  You might want to take a look at the From mechanism Rust uses to facilitate this.  IMO a proposal for typed error handling should address this issue in some way (even if the author determines this mechanism is not necessary or a good design cannot be identified).<br>&gt; <br>&gt; I would also like to see much more detail on why you think allowing a function to throw multiple error types is problematic.  My impression is that you have concerns from a usability point of view.  I am on the fence here to some degree, but definitely leaning in the direction that allowing a function to throw multiple error types is better.  <br>&gt; <br>&gt; The primary reason I lean this way is that it enables more re-use of standard error types.  Custom error types for an API often make sense, but not always.  I am concerned about the need to create them just because our API contract might reasonably include two or three of the standard error types.  Adding new types when they are not necessary introduces complexity and cognitive overhead.  It also complicates catching of errors if the new custom type is a two or three case enum that just embeds the underlying error.  <br>&gt; <br>&gt; These problems will lead many people to just revert to an untyped throws clause.  Objections to typed errors along these lines are common and legitimate.  They will arise during review.  It is best if you address them in the proposal now in order to focus a review on your solutions.  My personal opinion is that allowing multiple error types and including a mechanism to perform automatic wrapping when appropriate would go a long way towards solving them.<br>&gt; <br>&gt; Implementation challenges related to multi-typed errors have been discussed on the list quite a bit already.  They would obviously need to be addressed if we go in that direction.  I don’t want to downplay those.  But I do think we need to try to identify the most usable solution for typed errors that we can first and then focus on implementation details.  If the design needs to be modified to accommodate implementation at least we will have a better idea of what we are giving up.<br>&gt; <br>&gt; I am willing to be convinced that a single error type is better than multiple error types but the current proposal does not provide a compelling argument in that direction.  It just says “Java checked exceptions”.  I know these have been pretty much universally considered a serious design mistake.  My impression is that there are quite a few reasons for that.  I don’t have any direct experience with Java and am not familiar with the details.  If you could elaborate on specifically why you believe allowing multiple error types was a significant contributor to the problem in a manner that indicates that they will be a problem in any language that includes them I would appreciate that.  Links would be sufficient if they are focused on answering this particular question.  <br>&gt; <br>&gt; I’m looking forward to your feedback on these thoughts.<br>&gt; <br>&gt; Thanks,<br>&gt; Matthew<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 18, 2015, at 1:29 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This a significantly updated proposal for typed annotations on the `throws` construct. The previous was closed due to not be complete; I believe I’ve addressed all of those concerns.<br>&gt;&gt; <br>&gt;&gt; https://github.com/owensd/swift-evolution/blob/master/proposals/allow-type-annotations-on-throw.md &lt;https://github.com/owensd/swift-evolution/blob/master/proposals/allow-type-annotations-on-throw.md&gt;<br>&gt;&gt; <br>&gt;&gt; —<br>&gt;&gt; <br>&gt;&gt; Allow Type Annotation on Throws<br>&gt;&gt; Proposal: SE-NNNN &lt;&gt;<br>&gt;&gt; Author(s): David Owens II &lt;&gt;<br>&gt;&gt; Status: Pending Approval for Review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; The error handling system within Swift today creates an implicitly loose contract on the API. While this can be desirable in some cases, it’s certainly not desired in all cases. This proposal looks at modifying how the error handling mechanism works today by adding the ability to provide a strong API contract.<br>&gt;&gt; <br>&gt;&gt; Error Handling State of the Union<br>&gt;&gt; This document will use the terminology and the premises defined in the Error Handling Rationale &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt; document.<br>&gt;&gt; <br>&gt;&gt; To very briefly summarize, there are four basic classification of errors:<br>&gt;&gt; <br>&gt;&gt; Simple Domain Errors<br>&gt;&gt; Recoverable Errors<br>&gt;&gt; Universal Errors<br>&gt;&gt; Logic Failures<br>&gt;&gt; Each of these types of errors are handled differently at the call sites. Today, only the first two are directly handled by Swift error handling mechanism. The second two are uncatchable in Swift (such as fatalError(), ObjC exceptions, and force-unwrapping of null optionals).<br>&gt;&gt; <br>&gt;&gt; Simple Domain Errors<br>&gt;&gt; <br>&gt;&gt; As stated in Error Handling Rationale &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt; document, the “Swift way” to handle such errors is to return an Optional&lt;T&gt;.<br>&gt;&gt; <br>&gt;&gt; func parseInt(value: String) -&gt; Int? {}<br>&gt;&gt; The simple fact of the result being Optional.None signifies that the string could not be parsed and converted into an Int. No other information is necessary or warranted.<br>&gt;&gt; <br>&gt;&gt; Recoverable Errors<br>&gt;&gt; <br>&gt;&gt; In this context, these are errors that need to provide additional information to the caller. The caller can then decide a course of action that needs to be taken. This could be any number of things, including, but not limited to, logging error information, attempting a retry, or potentially invoking a different code path. All of these errors implement the ErrorType protocol.<br>&gt;&gt; <br>&gt;&gt; func openFile(filename: String) throws {}<br>&gt;&gt; The throws keyword annotates that the function can return additional error information. The caller must also explicitly make use of this when invoking the function.<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt;   try openFile(&quot;path/to/somewhere&quot;)<br>&gt;&gt; }<br>&gt;&gt; catch {}<br>&gt;&gt; Errors are able to propagate if called within another context that can throw, thus alleviating the annoying “catch and rethrow” behavior:<br>&gt;&gt; <br>&gt;&gt; func parent() throws {<br>&gt;&gt;   try openFile(&quot;path/to/somwhere&quot;)<br>&gt;&gt; }<br>&gt;&gt; Lastly, functions can be marked to selectively throw errors if they take a function parameter that throws with the rethrows keyword. The really interesting part is that it’s only necessary to use try when calling the function with a throwing closure.<br>&gt;&gt; <br>&gt;&gt; func openFile(filename: String) throws {}<br>&gt;&gt; func say(message: String) {}<br>&gt;&gt; <br>&gt;&gt; func sample(fn: (_: String) throws -&gt; ()) rethrows {<br>&gt;&gt;     try fn(&quot;hi&quot;)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; try sample(openFile)<br>&gt;&gt; sample(say)<br>&gt;&gt; Converting Recoverable Errors to Domain Errors<br>&gt;&gt; <br>&gt;&gt; Swift also has the try? construct. The notable thing about this construct is that it allows the caller to turn a “Recoverable Error” into a “Simple Domain Error”.<br>&gt;&gt; <br>&gt;&gt; if let result = try? openFile(&quot;&quot;) {}<br>&gt;&gt; ErrorType Implementors<br>&gt;&gt; <br>&gt;&gt; Errors are implemented using the ErrorType protocol. Since it is a protocol, new error types can be a class, a struct, or an enum. A type qualified throws clause would allow code authors to change the way that the catch-clauses need to be structured.<br>&gt;&gt; <br>&gt;&gt; Enum Based ErrorType<br>&gt;&gt; <br>&gt;&gt; When enums are used as the throwing mechanism, a generic catch-clause is still required as the compiler doesn’t have enough information. This leads to ambiguous code paths.<br>&gt;&gt; <br>&gt;&gt; enum Errors: ErrorType {<br>&gt;&gt;     case OffBy1<br>&gt;&gt;     case MutatedValue<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func f() throws { throw Errors.OffBy1 }<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt;     try f()<br>&gt;&gt; }<br>&gt;&gt; catch Errors.OffBy1 { print(&quot;increment by 1&quot;) }<br>&gt;&gt; catch Errors.MutatedValue { fatalError(&quot;data corrupted&quot;) }<br>&gt;&gt; The above code requires a catch {} clause, but it’s ambiguous what that case should do. There is no right way to handle this error. If the error is ignored, we’re now in the land of “Logic Errors”; the code path should never be hit. If we use a fatalError() construct, then we are now in the land of converting a potential compiler error into a “Universal Error”.<br>&gt;&gt; <br>&gt;&gt; Both of these are undesirable.<br>&gt;&gt; <br>&gt;&gt; Struct and Class Based ErrorType<br>&gt;&gt; <br>&gt;&gt; In the current design, errors that are thrown require a catch-all all the time. In the proposed design, which will be explained further, a catch-all would not be required if there was a case-clause that matched the base type.<br>&gt;&gt; <br>&gt;&gt; class ErrorOne: ErrorType {}<br>&gt;&gt; func g() throws { throw ErrorOne() }<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt;     try g()<br>&gt;&gt; }<br>&gt;&gt; catch is ErrorOne { print(&quot;ErrorOne&quot;) }<br>&gt;&gt; The advantage in these cases are different, these cases do not allow pattern matching over the error type members (as you can in a switch-statement, for example).<br>&gt;&gt; <br>&gt;&gt; The workaround for this functionality is this:<br>&gt;&gt; <br>&gt;&gt; class ErrorOne: ErrorType {<br>&gt;&gt;     let value: Int<br>&gt;&gt;     init(_ value: Int) { self.value = value }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt;     try g()<br>&gt;&gt; }<br>&gt;&gt; catch {<br>&gt;&gt;     if let e = error as? ErrorOne {<br>&gt;&gt;         switch e {<br>&gt;&gt;         case _ where e.value == 0: print(&quot;0&quot;)<br>&gt;&gt;         case _ where e.value == 1: print(&quot;1&quot;)<br>&gt;&gt;         default: print(&quot;nothing&quot;)<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; This proposal would turn the above into:<br>&gt;&gt; <br>&gt;&gt; class ErrorOne: ErrorType {<br>&gt;&gt;     let value: Int<br>&gt;&gt;     init(_ value: Int) { self.value = value }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt;     try g()<br>&gt;&gt; }<br>&gt;&gt; catch _ where error.value == 0 { print(&quot;0&quot;) }<br>&gt;&gt; catch _ where error.value == 1 { print(&quot;1&quot;) }<br>&gt;&gt; catch { print(&quot;nothing&quot;) }<br>&gt;&gt; }<br>&gt;&gt; No gymnastics to go through, just straight-forward pattern-matching like you’d expect.<br>&gt;&gt; <br>&gt;&gt; NOTE: This requires the promotion of the error constant to be allowed through the entirety of the catch-clauses.<br>&gt;&gt; <br>&gt;&gt; Overriding<br>&gt;&gt; <br>&gt;&gt; In the context of types, it’s completely possible to override functions with the throws annotations. The rules simply follow the rules today: covariance on the return type is allowed, contravariance is not.<br>&gt;&gt; <br>&gt;&gt; Generics<br>&gt;&gt; <br>&gt;&gt; When looking at generics, I cannot come up with a reason why they shouldn’t just work as normal:<br>&gt;&gt; <br>&gt;&gt; func gen&lt;SomeError: ErrorType&gt;() throws SomeError {}<br>&gt;&gt; The only constraint would be that the specified error type must adhere to the ErrorType protocol. However, this is no different than today:<br>&gt;&gt; <br>&gt;&gt; func f&lt;T&gt;(a: T) throws { throw a }<br>&gt;&gt; This results in the compiler error:<br>&gt;&gt; <br>&gt;&gt; Thrown expression type ’T’ does not conform to ‘ErrorType’<br>&gt;&gt; This seems like it should “just work”.<br>&gt;&gt; <br>&gt;&gt; Design Change Proposal<br>&gt;&gt; The design change is simple and straight-forward: allow for the annotation of the type of error that is being returned as an optional restriction. The default value would still be ErrorType.<br>&gt;&gt; <br>&gt;&gt; func specific() throws MyError {}<br>&gt;&gt; func nonspecific() throws {}<br>&gt;&gt; There is a secondary result of this proposal: the error constant should be promoted to be allowed for use through-out all of the catch-clauses.<br>&gt;&gt; <br>&gt;&gt; Impact on Existing Code<br>&gt;&gt; <br>&gt;&gt; This is a non-breaking change. All existing constructs work today without change. That said, there are a few places where this change will have an impact on future usage.<br>&gt;&gt; <br>&gt;&gt; Function Declarations<br>&gt;&gt; <br>&gt;&gt; When a function has a throws clause that is attributed with a type, then that type becomes part of the function signature. This means that these two functions are not considered to be of the same type:<br>&gt;&gt; <br>&gt;&gt; func one() throws {}<br>&gt;&gt; func two() throws NumberError {}<br>&gt;&gt; The function signatures are covariant though, so either one or two can be assigned to f below:<br>&gt;&gt; <br>&gt;&gt; let f: () throws -&gt; ()<br>&gt;&gt; This is completely fine as NumberError still implements the ErrorType protocol.<br>&gt;&gt; <br>&gt;&gt; However, in this case:<br>&gt;&gt; <br>&gt;&gt; let g: () throws NumberError -&gt; ()<br>&gt;&gt; It would not be valid to assign one to g as the type signature is more specific.<br>&gt;&gt; <br>&gt;&gt; throws and rethrows<br>&gt;&gt; <br>&gt;&gt; Functions currently have the ability to be marked as rethrows. This basically says that if a closure parameter can throw, then the function will throw too. <br>&gt;&gt; <br>&gt;&gt; func whatever(fn: () throws -&gt; ()) rethrows {}<br>&gt;&gt; The whatever function is up for anything that fn is up for. Keeping in line with this mentality, the rethrows would exhibit the same behavior: typed annotations simply apply if present and do not if they are missing.<br>&gt;&gt; <br>&gt;&gt; func specific(fn: () throws HappyError -&gt; ()) rethrows {}<br>&gt;&gt; This all works as expected:<br>&gt;&gt; <br>&gt;&gt; func f() throws HappyError {}<br>&gt;&gt; func g() {}<br>&gt;&gt; <br>&gt;&gt; try specific(f)<br>&gt;&gt; specific(g)<br>&gt;&gt; This works for the same covariant reason as the non-qualified throws implementation works: a non-throwing function is always able to be passed in for a throwing function.<br>&gt;&gt; <br>&gt;&gt; The do-catch statement<br>&gt;&gt; <br>&gt;&gt; There are two rule changes here, but again, it’s non-breaking.<br>&gt;&gt; <br>&gt;&gt; The first rule change is to promote the error constant that would normally only be allowed in the catch-all clause (no patterns) to be available throughout each of the catch clauses. This allows for the error information to be used in pattern matching, which is especially valuable in the non-enum case.<br>&gt;&gt; <br>&gt;&gt; The second change is to allow the error constant to take on a specific type when all of the throwing functions throw the same specified type. When this is the case, two things become possible:<br>&gt;&gt; <br>&gt;&gt; In the enum-type implementation of ErrorType, the catch-clauses can now be exhaustive.<br>&gt;&gt; In the all of the cases, the API of the specific ErrorType becomes available in the catch-clause without casting the error constant. This greatly simplifies the pattern-matching process.<br>&gt;&gt; In the case that there are heterogenous ErrorType implementations being returned, the errorconstant simply has the type of ErrorType.<br>&gt;&gt; <br>&gt;&gt; The try call sites<br>&gt;&gt; <br>&gt;&gt; There is no change for the try, try?, or try! uses. The only clarification I’ll add is that try?is still the appropriate way to promote an error from a “Recoverable Error” to a “Simple Domain Error”.<br>&gt;&gt; <br>&gt;&gt; Alternate Proposals<br>&gt;&gt; There is another common error handling mechanism used in the community today: Either&lt;L, R&gt;. There are various implementations, but they all basically boil down to an enum that captures the value or the error information.<br>&gt;&gt; <br>&gt;&gt; I actually consider my proposal syntactic sugar over this concept. If and when Swift supports covariant generics, there is not a significant reason I can see why the underlying implementation could not just be that.<br>&gt;&gt; <br>&gt;&gt; The advantage is that the proposed (and existing) syntax of throws greatly increases the readability and understanding that this function actually possesses the ability to throw errors and they should be handled.<br>&gt;&gt; <br>&gt;&gt; The other advantage of this syntax is that it doesn’t require a new construct to force the usage of the return type. <br>&gt;&gt; <br>&gt;&gt; Further, if functions where to ever gain the ability to be marked as async, this could now be handled naturally within the compiler as the return type could a promise-like implementation for those.<br>&gt;&gt; <br>&gt;&gt; Criticisms<br>&gt;&gt; From the earlier threads on the swift-evolution mailing list, there are a few primary points of contention about this proposal.<br>&gt;&gt; <br>&gt;&gt; Aren’t we just creating Java checked-exceptions, which we all know are terrible?<br>&gt;&gt; <br>&gt;&gt; No. The primary reason is that a function can only return a single error-type. The other major reason is that the error philosophy is very different in Swift than in Java.<br>&gt;&gt; <br>&gt;&gt; Aren’t we creating fragile APIs that can cause breaking changes?<br>&gt;&gt; <br>&gt;&gt; Potentially, yes. This depends on how the ABI is handled in Swift 3 for enums. The same problem exists today, although at a lesser extent, for any API that returns an enum today.<br>&gt;&gt; <br>&gt;&gt; Chris Lattner mentioned this on the thread:<br>&gt;&gt; <br>&gt;&gt; The resilience model addresses how the public API from a module can evolve without breaking clients (either at the source level or ABI level).  Notably, we want the ability to be able to add enum cases to something by default, but also to allow API authors to opt into more performance/strictness by saying that a public enum is “fragile” or “closed for evolution”.<br>&gt;&gt; So if enums have an attribute that allows API authors to denote the fragility enums, then this can be handled via that route.<br>&gt;&gt; <br>&gt;&gt; Another potential fix is that only internal and private scoped functions are allowed to use the exhaustive-style catch-clauses. For all public APIs, they would still need the catch-all clauses.<br>&gt;&gt; <br>&gt;&gt; For APIs that return non-enum based ErrorType implementations, then no, this does not contribute to the fragility problem.<br>&gt;&gt; <br>&gt;&gt; Aren’t we creating the need for wrapper errors?<br>&gt;&gt; <br>&gt;&gt; This is a philosophical debate. I’ll simply state that I believe that simply re-throwing an error, say some type of IO error, from your API that is not an IO-based API is design flaw: you are exposing implementation details to users. This creates a fragile API surface.<br>&gt;&gt; <br>&gt;&gt; Also, since the type annotation is opt-in, I feel like this is a really minor argument. If your function is really able to throw errors from various different API calls, then just stick with the default ErrorType.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/98fa01d2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 18, 2015 at 05:00:00pm</p></header><div class="content"><p>Sorry Matthew, I think my email is having delivery issues because I didn&#39;t<br>see any of those messages when I sent mine, though I see them timestamped<br>before my message now.<br></p><p>Yes, Felix, those were valid concerns. But, as mentioned before, what we<br>have now is the most polymorphic thing possible. All those functions throw<br>ErrorType and that can literally be anything imaginable.<br></p><p>What could solve the issue is if type-annotated throws only allowed final<br>(closed) classes. Also, if I&#39;m not mistaken, enums are sealed and cannot be<br>extended so they are a fantastic candidate for avoiding the proliferation<br>of extending error classes. Maybe it could be limited to enums.<br></p><p><br></p><p>On Fri, Dec 18, 2015, 10:40 AM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt; On Dec 18, 2015, at 9:25 AM, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Genuinely, David, thank you for taking up the mantle of this problem. To<br>&gt; me, the lack of type annotations makes the error handling painful and I<br>&gt; wish the team just hadn&#39;t released it until the design was smoothed out<br>&gt; fully. Those dangling catch-all blocks when I&#39;ve caught all cases make it<br>&gt; uselessly verbose and moreover do not fit with the language at all.<br>&gt;<br>&gt; As for the multiple vs. single type annotations, I do think that you need<br>&gt; a concrete example of why this will be different from java to quell the<br>&gt; concerns of all the people that skim the proposal, don&#39;t think about it,<br>&gt; and exclaim &quot;but everyone hates it in Java!&quot; so I agree on the singular<br>&gt; type annotations.<br>&gt;<br>&gt; I definitely agree that we need to address the Java problem.  That said, I<br>&gt; don’t think avoiding knee-jerk objection from people who don’t read and<br>&gt; consider a proposal carefully is a good way to approach design.  There may<br>&gt; be good reasons to choose singular type annotations but this is not one of<br>&gt; them.<br>&gt;<br>&gt; I believe Félix raised good points about polymorphism and complex<br>&gt; hierarchy causing problems in Java.  That sounds like it is the source of<br>&gt; at least a significant part of the problems with Java’s checked exception<br>&gt; model.<br>&gt;<br>&gt; Also, your point about being able to mark functions async strongly<br>&gt; supports single type annotations until we get union types (if ever).<br>&gt;<br>&gt; I am glad you addressed covariance/contravariance and the semantics of<br>&gt; function types when they throw general errors vs. a specific one.<br>&gt;<br>&gt; One question, mainly to the compiler team: would it be reasonable to be<br>&gt; able to use generics covariant over the throws operator? For example, I<br>&gt; could define a function that takes a function which throws E and returns R,<br>&gt; and creates a function that takes a callback which takes an argument of<br>&gt; type Either&lt;R, E&gt; instead. This would be an incredibly powerful feature.<br>&gt;<br>&gt; On Fri, Dec 18, 2015, 8:53 AM Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; David,<br>&gt;&gt;<br>&gt;&gt; Thank you for taking the time to continue working on a proposal for typed<br>&gt;&gt; throws.  I agree that this feature is very desirable and appreciate the<br>&gt;&gt; work you’re doing to bring forward a proposal.  I think it’s a great start<br>&gt;&gt; but also has some room for improvement.<br>&gt;&gt;<br>&gt;&gt; First, I think it could be strengthened by incorporating some learning<br>&gt;&gt; from Rust.  My impression is that the Rust community is very happy with<br>&gt;&gt; typed error handling.  Adding some detail about their experience would<br>&gt;&gt; provide a counter-example to those who are concerned about the experience<br>&gt;&gt; in Java and C++.<br>&gt;&gt;<br>&gt;&gt; I agree that error types are an important part of an API contract.  One<br>&gt;&gt; of the big hurdles to doing this well is the need to catch errors when all<br>&gt;&gt; that needs to be done is to wrap and rethrow them.  Ideally should not need<br>&gt;&gt; to do this just to perform a simple type translation to map the underlying<br>&gt;&gt; error into the type we wish to expose as part of a stable API contract.<br>&gt;&gt; You might want to take a look at the From mechanism Rust uses to facilitate<br>&gt;&gt; this.  IMO a proposal for typed error handling should address this issue in<br>&gt;&gt; some way (even if the author determines this mechanism is not necessary or<br>&gt;&gt; a good design cannot be identified).<br>&gt;&gt;<br>&gt;&gt; I would also like to see much more detail on why you think allowing a<br>&gt;&gt; function to throw multiple error types is problematic.  My impression is<br>&gt;&gt; that you have concerns from a usability point of view.  I am on the fence<br>&gt;&gt; here to some degree, but definitely leaning in the direction that allowing<br>&gt;&gt; a function to throw multiple error types is better.<br>&gt;&gt;<br>&gt;&gt; The primary reason I lean this way is that it enables more re-use of<br>&gt;&gt; standard error types.  Custom error types for an API often make sense, but<br>&gt;&gt; not always.  I am concerned about the need to create them just because our<br>&gt;&gt; API contract might reasonably include two or three of the standard error<br>&gt;&gt; types.  Adding new types when they are not necessary introduces complexity<br>&gt;&gt; and cognitive overhead.  It also complicates catching of errors if the new<br>&gt;&gt; custom type is a two or three case enum that just embeds the underlying<br>&gt;&gt; error.<br>&gt;&gt;<br>&gt;&gt; These problems will lead many people to just revert to an untyped throws<br>&gt;&gt; clause.  Objections to typed errors along these lines are common and<br>&gt;&gt; legitimate.  They will arise during review.  It is best if you address them<br>&gt;&gt; in the proposal now in order to focus a review on your solutions.  My<br>&gt;&gt; personal opinion is that allowing multiple error types and including a<br>&gt;&gt; mechanism to perform automatic wrapping when appropriate would go a long<br>&gt;&gt; way towards solving them.<br>&gt;&gt;<br>&gt;&gt; Implementation challenges related to multi-typed errors have been<br>&gt;&gt; discussed on the list quite a bit already.  They would obviously need to be<br>&gt;&gt; addressed if we go in that direction.  I don’t want to downplay those.  But<br>&gt;&gt; I do think we need to try to identify the most usable solution for typed<br>&gt;&gt; errors that we can first and then focus on implementation details.  If the<br>&gt;&gt; design needs to be modified to accommodate implementation at least we will<br>&gt;&gt; have a better idea of what we are giving up.<br>&gt;&gt;<br>&gt;&gt; I am willing to be convinced that a single error type is better than<br>&gt;&gt; multiple error types but the current proposal does not provide a compelling<br>&gt;&gt; argument in that direction.  It just says “Java checked exceptions”.  I<br>&gt;&gt; know these have been pretty much universally considered a serious design<br>&gt;&gt; mistake.  My impression is that there are quite a few reasons for that.  I<br>&gt;&gt; don’t have any direct experience with Java and am not familiar with the<br>&gt;&gt; details.  If you could elaborate on specifically why you believe allowing<br>&gt;&gt; multiple error types was a significant contributor to the problem in a<br>&gt;&gt; manner that indicates that they will be a problem in any language that<br>&gt;&gt; includes them I would appreciate that.  Links would be sufficient if they<br>&gt;&gt; are focused on answering this particular question.<br>&gt;&gt;<br>&gt;&gt; I’m looking forward to your feedback on these thoughts.<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt; Matthew<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 18, 2015, at 1:29 AM, David Owens II via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; This a significantly updated proposal for typed annotations on the<br>&gt;&gt; `throws` construct. The previous was closed due to not be complete; I<br>&gt;&gt; believe I’ve addressed all of those concerns.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/owensd/swift-evolution/blob/master/proposals/allow-type-annotations-on-throw.md<br>&gt;&gt;<br>&gt;&gt; —<br>&gt;&gt;<br>&gt;&gt; Allow Type Annotation on Throws<br>&gt;&gt;<br>&gt;&gt;    - Proposal: SE-NNNN<br>&gt;&gt;    - Author(s): David Owens II<br>&gt;&gt;    - Status: *Pending Approval for Review*<br>&gt;&gt;    - Review manager: TBD<br>&gt;&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; The error handling system within Swift today creates an implicitly loose<br>&gt;&gt; contract on the API. While this can be desirable in some cases, it’s<br>&gt;&gt; certainly not desired in *all* cases. This proposal looks at modifying<br>&gt;&gt; how the error handling mechanism works today by adding the ability to<br>&gt;&gt; provide a strong API contract.<br>&gt;&gt; Error Handling State of the Union<br>&gt;&gt;<br>&gt;&gt; This document will use the terminology and the premises defined in the Error<br>&gt;&gt; Handling Rationale<br>&gt;&gt; &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt;<br>&gt;&gt;  document.<br>&gt;&gt;<br>&gt;&gt; To very briefly summarize, there are four basic classification of errors:<br>&gt;&gt;<br>&gt;&gt;    1. Simple Domain Errors<br>&gt;&gt;    2. Recoverable Errors<br>&gt;&gt;    3. Universal Errors<br>&gt;&gt;    4. Logic Failures<br>&gt;&gt;<br>&gt;&gt; Each of these types of errors are handled differently at the call sites.<br>&gt;&gt; Today, only the first two are directly handled by Swift error handling<br>&gt;&gt; mechanism. The second two are uncatchable in Swift (such as fatalError(),<br>&gt;&gt; ObjC exceptions, and force-unwrapping of null optionals).<br>&gt;&gt; Simple Domain Errors<br>&gt;&gt;<br>&gt;&gt; As stated in Error Handling Rationale<br>&gt;&gt; &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt; document,<br>&gt;&gt; the “Swift way” to handle such errors is to return an Optional&lt;T&gt;.<br>&gt;&gt;<br>&gt;&gt; func parseInt(value: String) -&gt; Int? {}<br>&gt;&gt;<br>&gt;&gt; The simple fact of the result being Optional.None signifies that the<br>&gt;&gt; string could not be parsed and converted into an Int. No other<br>&gt;&gt; information is necessary or warranted.<br>&gt;&gt; Recoverable Errors<br>&gt;&gt;<br>&gt;&gt; In this context, these are errors that need to provide additional<br>&gt;&gt; information to the caller. The caller can then decide a course of action<br>&gt;&gt; that needs to be taken. This could be any number of things, including, but<br>&gt;&gt; not limited to, logging error information, attempting a retry, or<br>&gt;&gt; potentially invoking a different code path. All of these errors implement<br>&gt;&gt; the ErrorType protocol.<br>&gt;&gt;<br>&gt;&gt; func openFile(filename: String) throws {}<br>&gt;&gt;<br>&gt;&gt; The throws keyword annotates that the function can return additional<br>&gt;&gt; error information. The caller must also explicitly make use of this when<br>&gt;&gt; invoking the function.<br>&gt;&gt;<br>&gt;&gt; do {<br>&gt;&gt;   try openFile(&quot;path/to/somewhere&quot;)<br>&gt;&gt; }<br>&gt;&gt; catch {}<br>&gt;&gt;<br>&gt;&gt; Errors are able to propagate if called within another context that can<br>&gt;&gt; throw, thus alleviating the annoying “catch and rethrow” behavior:<br>&gt;&gt;<br>&gt;&gt; func parent() throws {<br>&gt;&gt;   try openFile(&quot;path/to/somwhere&quot;)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Lastly, functions can be marked to selectively throw errors if they take<br>&gt;&gt; a function parameter that throws with the rethrows keyword. The really<br>&gt;&gt; interesting part is that it’s only necessary to use try when calling the<br>&gt;&gt; function with a throwing closure.<br>&gt;&gt;<br>&gt;&gt; func openFile(filename: String) throws {}<br>&gt;&gt; func say(message: String) {}<br>&gt;&gt;<br>&gt;&gt; func sample(fn: (_: String) throws -&gt; ()) rethrows {<br>&gt;&gt;     try fn(&quot;hi&quot;)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; try sample(openFile)<br>&gt;&gt; sample(say)<br>&gt;&gt;<br>&gt;&gt; Converting Recoverable Errors to Domain Errors<br>&gt;&gt;<br>&gt;&gt; Swift also has the try? construct. The notable thing about this<br>&gt;&gt; construct is that it allows the caller to turn a “Recoverable Error” into a<br>&gt;&gt; “Simple Domain Error”.<br>&gt;&gt;<br>&gt;&gt; if let result = try? openFile(&quot;&quot;) {}<br>&gt;&gt;<br>&gt;&gt; ErrorType Implementors<br>&gt;&gt;<br>&gt;&gt; Errors are implemented using the ErrorType protocol. Since it is a<br>&gt;&gt; protocol, new error types can be a class, a struct, or an enum. A type<br>&gt;&gt; qualified throws clause would allow code authors to change the way that<br>&gt;&gt; the catch-clauses need to be structured.<br>&gt;&gt; Enum Based ErrorType<br>&gt;&gt;<br>&gt;&gt; When enums are used as the throwing mechanism, a generic catch-clause is<br>&gt;&gt; still required as the compiler doesn’t have enough information. This leads<br>&gt;&gt; to ambiguous code paths.<br>&gt;&gt;<br>&gt;&gt; enum Errors: ErrorType {<br>&gt;&gt;     case OffBy1<br>&gt;&gt;     case MutatedValue<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; func f() throws { throw Errors.OffBy1 }<br>&gt;&gt;<br>&gt;&gt; do {<br>&gt;&gt;     try f()<br>&gt;&gt; }<br>&gt;&gt; catch Errors.OffBy1 { print(&quot;increment by 1&quot;) }<br>&gt;&gt; catch Errors.MutatedValue { fatalError(&quot;data corrupted&quot;) }<br>&gt;&gt;<br>&gt;&gt; The above code requires a catch {} clause, but it’s ambiguous what that<br>&gt;&gt; case should do. There is no *right* way to handle this error. If the<br>&gt;&gt; error is ignored, we’re now in the land of “Logic Errors”; the code path<br>&gt;&gt; should never be hit. If we use a fatalError() construct, then we are now<br>&gt;&gt; in the land of converting a potential compiler error into a “Universal<br>&gt;&gt; Error”.<br>&gt;&gt;<br>&gt;&gt; Both of these are undesirable.<br>&gt;&gt; Struct and Class Based ErrorType<br>&gt;&gt;<br>&gt;&gt; In the current design, errors that are thrown require a catch-all all the<br>&gt;&gt; time. In the proposed design, which will be explained further, a catch-all<br>&gt;&gt; would not be required if there was a case-clause that matched the base type.<br>&gt;&gt;<br>&gt;&gt; class ErrorOne: ErrorType {}<br>&gt;&gt; func g() throws { throw ErrorOne() }<br>&gt;&gt;<br>&gt;&gt; do {<br>&gt;&gt;     try g()<br>&gt;&gt; }<br>&gt;&gt; catch is ErrorOne { print(&quot;ErrorOne&quot;) }<br>&gt;&gt;<br>&gt;&gt; The advantage in these cases are different, these cases do not allow<br>&gt;&gt; pattern matching over the error type members (as you can in a<br>&gt;&gt; switch-statement, for example).<br>&gt;&gt;<br>&gt;&gt; The workaround for this functionality is this:<br>&gt;&gt;<br>&gt;&gt; class ErrorOne: ErrorType {<br>&gt;&gt;     let value: Int<br>&gt;&gt;     init(_ value: Int) { self.value = value }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; do {<br>&gt;&gt;     try g()<br>&gt;&gt; }<br>&gt;&gt; catch {<br>&gt;&gt;     if let e = error as? ErrorOne {<br>&gt;&gt;         switch e {<br>&gt;&gt;         case _ where e.value == 0: print(&quot;0&quot;)<br>&gt;&gt;         case _ where e.value == 1: print(&quot;1&quot;)<br>&gt;&gt;         default: print(&quot;nothing&quot;)<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; This proposal would turn the above into:<br>&gt;&gt;<br>&gt;&gt; class ErrorOne: ErrorType {<br>&gt;&gt;     let value: Int<br>&gt;&gt;     init(_ value: Int) { self.value = value }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; do {<br>&gt;&gt;     try g()<br>&gt;&gt; }<br>&gt;&gt; catch _ where error.value == 0 { print(&quot;0&quot;) }<br>&gt;&gt; catch _ where error.value == 1 { print(&quot;1&quot;) }<br>&gt;&gt; catch { print(&quot;nothing&quot;) }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; No gymnastics to go through, just straight-forward pattern-matching like<br>&gt;&gt; you’d expect.<br>&gt;&gt;<br>&gt;&gt; NOTE: This requires the promotion of the error constant to be allowed<br>&gt;&gt; through the entirety of the catch-clauses.<br>&gt;&gt; Overriding<br>&gt;&gt;<br>&gt;&gt; In the context of types, it’s completely possible to override functions<br>&gt;&gt; with the throws annotations. The rules simply follow the rules today:<br>&gt;&gt; covariance on the return type is allowed, contravariance is not.<br>&gt;&gt; Generics<br>&gt;&gt;<br>&gt;&gt; When looking at generics, I cannot come up with a reason why they<br>&gt;&gt; shouldn’t just work as normal:<br>&gt;&gt;<br>&gt;&gt; func gen&lt;SomeError: ErrorType&gt;() throws SomeError {}<br>&gt;&gt;<br>&gt;&gt; The only constraint would be that the specified error type must adhere to<br>&gt;&gt; the ErrorType protocol. However, this is no different than today:<br>&gt;&gt;<br>&gt;&gt; func f&lt;T&gt;(a: T) throws { throw a }<br>&gt;&gt;<br>&gt;&gt; This results in the compiler error:<br>&gt;&gt;<br>&gt;&gt; Thrown expression type ’T’ does not conform to ‘ErrorType’<br>&gt;&gt;<br>&gt;&gt; This seems like it should “just work”.<br>&gt;&gt; Design Change Proposal<br>&gt;&gt;<br>&gt;&gt; The design change is simple and straight-forward: allow for the<br>&gt;&gt; annotation of the type of error that is being returned as an optional<br>&gt;&gt; restriction. The default value would still be ErrorType.<br>&gt;&gt;<br>&gt;&gt; func specific() throws MyError {}<br>&gt;&gt; func nonspecific() throws {}<br>&gt;&gt;<br>&gt;&gt; There is a secondary result of this proposal: the error constant should<br>&gt;&gt; be promoted to be allowed for use through-out all of the catch-clauses.<br>&gt;&gt; Impact on Existing Code<br>&gt;&gt;<br>&gt;&gt; This is a non-breaking change. All existing constructs work today without<br>&gt;&gt; change. That said, there are a few places where this change will have an<br>&gt;&gt; impact on future usage.<br>&gt;&gt; Function Declarations<br>&gt;&gt;<br>&gt;&gt; When a function has a throws clause that is attributed with a type, then<br>&gt;&gt; that type becomes part of the function signature. This means that these two<br>&gt;&gt; functions are not considered to be of the same type:<br>&gt;&gt;<br>&gt;&gt; func one() throws {}<br>&gt;&gt; func two() throws NumberError {}<br>&gt;&gt;<br>&gt;&gt; The function signatures are covariant though, so either one or two can<br>&gt;&gt; be assigned to f below:<br>&gt;&gt;<br>&gt;&gt; let f: () throws -&gt; ()<br>&gt;&gt;<br>&gt;&gt; This is completely fine as NumberError still implements the ErrorType<br>&gt;&gt;  protocol.<br>&gt;&gt;<br>&gt;&gt; However, in this case:<br>&gt;&gt;<br>&gt;&gt; let g: () throws NumberError -&gt; ()<br>&gt;&gt;<br>&gt;&gt; It would not be valid to assign one to g as the type signature is more<br>&gt;&gt; specific.<br>&gt;&gt; throws and rethrows<br>&gt;&gt;<br>&gt;&gt; Functions currently have the ability to be marked as rethrows. This<br>&gt;&gt; basically says that if a closure parameter can throw, then the function<br>&gt;&gt; will throw too.<br>&gt;&gt;<br>&gt;&gt; func whatever(fn: () throws -&gt; ()) rethrows {}<br>&gt;&gt;<br>&gt;&gt; The whatever function is up for anything that fn is up for. Keeping in<br>&gt;&gt; line with this mentality, the rethrows would exhibit the same behavior:<br>&gt;&gt; typed annotations simply apply if present and do not if they are missing.<br>&gt;&gt;<br>&gt;&gt; func specific(fn: () throws HappyError -&gt; ()) rethrows {}<br>&gt;&gt;<br>&gt;&gt; This all works as expected:<br>&gt;&gt;<br>&gt;&gt; func f() throws HappyError {}<br>&gt;&gt; func g() {}<br>&gt;&gt;<br>&gt;&gt; try specific(f)<br>&gt;&gt; specific(g)<br>&gt;&gt;<br>&gt;&gt; This works for the same covariant reason as the non-qualified throws implementation<br>&gt;&gt; works: a non-throwing function is always able to be passed in for a<br>&gt;&gt; throwing function.<br>&gt;&gt; The do-catch statement<br>&gt;&gt;<br>&gt;&gt; There are two rule changes here, but again, it’s non-breaking.<br>&gt;&gt;<br>&gt;&gt; The first rule change is to promote the error constant that would<br>&gt;&gt; normally only be allowed in the catch-all clause (no patterns) to be<br>&gt;&gt; available throughout each of the catch clauses. This allows for the error<br>&gt;&gt; information to be used in pattern matching, which is especially valuable in<br>&gt;&gt; the non-enum case.<br>&gt;&gt;<br>&gt;&gt; The second change is to allow the error constant to take on a specific<br>&gt;&gt; type when *all* of the throwing functions throw the same specified type.<br>&gt;&gt; When this is the case, two things become possible:<br>&gt;&gt;<br>&gt;&gt;    1. In the enum-type implementation of ErrorType, the catch-clauses<br>&gt;&gt;    can now be exhaustive.<br>&gt;&gt;    2. In the all of the cases, the API of the specific ErrorType becomes<br>&gt;&gt;    available in the catch-clause without casting the error constant.<br>&gt;&gt;    This greatly simplifies the pattern-matching process.<br>&gt;&gt;<br>&gt;&gt; In the case that there are heterogenous ErrorType implementations being<br>&gt;&gt; returned, the errorconstant simply has the type of ErrorType.<br>&gt;&gt; The try call sites<br>&gt;&gt;<br>&gt;&gt; There is no change for the try, try?, or try! uses. The only<br>&gt;&gt; clarification I’ll add is that try?is still the appropriate way to<br>&gt;&gt; promote an error from a “Recoverable Error” to a “Simple Domain Error”.<br>&gt;&gt; Alternate Proposals<br>&gt;&gt;<br>&gt;&gt; There is another common error handling mechanism used in the community<br>&gt;&gt; today: Either&lt;L, R&gt;. There are various implementations, but they all<br>&gt;&gt; basically boil down to an enum that captures the value or the error<br>&gt;&gt; information.<br>&gt;&gt;<br>&gt;&gt; I actually consider my proposal syntactic sugar over this concept. If and<br>&gt;&gt; when Swift supports covariant generics, there is not a significant reason I<br>&gt;&gt; can see why the underlying implementation could not just be that.<br>&gt;&gt;<br>&gt;&gt; The advantage is that the proposed (and existing) syntax of throws greatly<br>&gt;&gt; increases the readability and understanding that this function actually<br>&gt;&gt; possesses the ability to throw errors and they should be handled.<br>&gt;&gt;<br>&gt;&gt; The other advantage of this syntax is that it doesn’t require a new<br>&gt;&gt; construct to force the usage of the return type.<br>&gt;&gt;<br>&gt;&gt; Further, if functions where to ever gain the ability to be marked as<br>&gt;&gt; async, this could now be handled naturally within the compiler as the<br>&gt;&gt; return type could a promise-like implementation for those.<br>&gt;&gt; Criticisms<br>&gt;&gt;<br>&gt;&gt; From the earlier threads on the swift-evolution mailing list, there are a<br>&gt;&gt; few primary points of contention about this proposal.<br>&gt;&gt; Aren’t we just creating Java checked-exceptions, which we all know are<br>&gt;&gt; terrible?<br>&gt;&gt;<br>&gt;&gt; No. The primary reason is that a function can only return a single<br>&gt;&gt; error-type. The other major reason is that the error philosophy is very<br>&gt;&gt; different in Swift than in Java.<br>&gt;&gt; Aren’t we creating fragile APIs that can cause breaking changes?<br>&gt;&gt;<br>&gt;&gt; Potentially, yes. This depends on how the ABI is handled in Swift 3 for<br>&gt;&gt; enums. The same problem exists today, although at a lesser extent, for any<br>&gt;&gt; API that returns an enum today.<br>&gt;&gt;<br>&gt;&gt; Chris Lattner mentioned this on the thread:<br>&gt;&gt;<br>&gt;&gt; The resilience model addresses how the public API from a module can<br>&gt;&gt; evolve without breaking clients (either at the source level or ABI level).<br>&gt;&gt; Notably, we want the ability to be able to add enum cases to something by<br>&gt;&gt; default, but also to allow API authors to opt into more<br>&gt;&gt; performance/strictness by saying that a public enum is “fragile” or “closed<br>&gt;&gt; for evolution”.<br>&gt;&gt;<br>&gt;&gt; So if enums have an attribute that allows API authors to denote the<br>&gt;&gt; fragility enums, then this can be handled via that route.<br>&gt;&gt;<br>&gt;&gt; Another potential fix is that *only* internal and private scoped<br>&gt;&gt; functions are allowed to use the exhaustive-style catch-clauses. For all<br>&gt;&gt; public APIs, they would still need the catch-all clauses.<br>&gt;&gt;<br>&gt;&gt; For APIs that return non-enum based ErrorType implementations, then no,<br>&gt;&gt; this does not contribute to the fragility problem.<br>&gt;&gt; Aren’t we creating the need for wrapper errors?<br>&gt;&gt;<br>&gt;&gt; This is a philosophical debate. I’ll simply state that I believe that<br>&gt;&gt; simply re-throwing an error, say some type of IO error, from your API that<br>&gt;&gt; is not an IO-based API is design flaw: you are exposing implementation<br>&gt;&gt; details to users. This creates a fragile API surface.<br>&gt;&gt;<br>&gt;&gt; Also, since the type annotation is opt-in, I feel like this is a really<br>&gt;&gt; minor argument. If your function is really able to throw errors from<br>&gt;&gt; various different API calls, then just stick with the default ErrorType.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/355b6cb5/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 18, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 5:53 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; David,<br>&gt; <br>&gt; Thank you for taking the time to continue working on a proposal for typed throws.  I agree that this feature is very desirable and appreciate the work you’re doing to bring forward a proposal.  I think it’s a great start but also has some room for improvement.<br>&gt; <br>&gt; First, I think it could be strengthened by incorporating some learning from Rust.  My impression is that the Rust community is very happy with typed error handling.  Adding some detail about their experience would provide a counter-example to those who are concerned about the experience in Java and C++.<br></p><p>I’m not involved in the Rust community so I wouldn’t feel comfortable making claims for them. <br></p><p>&gt; I agree that error types are an important part of an API contract.  One of the big hurdles to doing this well is the need to catch errors when all that needs to be done is to wrap and rethrow them.  Ideally should not need to do this just to perform a simple type translation to map the underlying error into the type we wish to expose as part of a stable API contract.  You might want to take a look at the From mechanism Rust uses to facilitate this.  IMO a proposal for typed error handling should address this issue in some way (even if the author determines this mechanism is not necessary or a good design cannot be identified).<br></p><p>The From() construct seems like a map(T) -&gt; U problem, but it seems heavily tied into the ability to create sum types. Swift doesn’t have this feature, and that feature is out-of-scope for this proposal. More on this later.<br></p><p>&gt; I would also like to see much more detail on why you think allowing a function to throw multiple error types is problematic.  My impression is that you have concerns from a usability point of view.  I am on the fence here to some degree, but definitely leaning in the direction that allowing a function to throw multiple error types is better.  <br></p><p>Sure. There’s no functionality today to auto-generate a sum type in Swift today, and that is what this request really is. If you want to return multiple return types, then you need to do exactly what Rust does and create a sum type that composes the various types of errors. This exposes the same potential fragile API surface as extending enums do. I did call this part out specifically.<br></p><p>I see this functionality as a general limitation in the language. For example, errors are not the only context where you may want to return a type of A, B, or C. There have been other proposals on how we might do that in Swift. If and when it was solved in the general case for type parameters, I can’t foresee a compelling reason why it wouldn’t work in this context as well.<br></p><p>&gt; I am willing to be convinced that a single error type is better than multiple error types but the current proposal does not provide a compelling argument in that direction.  It just says “Java checked exceptions”.  I know these have been pretty much universally considered a serious design mistake.  My impression is that there are quite a few reasons for that.  I don’t have any direct experience with Java and am not familiar with the details.  If you could elaborate on specifically why you believe allowing multiple error types was a significant contributor to the problem in a manner that indicates that they will be a problem in any language that includes them I would appreciate that.  Links would be sufficient if they are focused on answering this particular question.  <br></p><p>I guess I should have just specifically called this out in the proposal. It’s not because of “Java checked exceptions”, it’s because nowhere else in the language are types allowed to be essentially annotated in a sum-like fashion. We can’t directly say a function returns an Int or a String. We can’t say a parameter can take an Int or a Double. Similarly, I propose we can’t say a function can return an error A or B.<br></p><p>Thus, the primary reason is about type-system consistency.<br></p><p>Swift already supports a construct to create sum types: associated enums. What it doesn’t allow is the ability to create them in a syntactic shorthand. In this way, my error proposal does the same thing as Rust: multiple return types need to be combined into a single-type - enum.<br></p><p>On to Félix’s comments now!<br></p><p>-David<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 18, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 10:50 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 18, 2015, at 5:53 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; David,<br>&gt;&gt; <br>&gt;&gt; Thank you for taking the time to continue working on a proposal for typed throws.  I agree that this feature is very desirable and appreciate the work you’re doing to bring forward a proposal.  I think it’s a great start but also has some room for improvement.<br>&gt;&gt; <br>&gt;&gt; First, I think it could be strengthened by incorporating some learning from Rust.  My impression is that the Rust community is very happy with typed error handling.  Adding some detail about their experience would provide a counter-example to those who are concerned about the experience in Java and C++.<br>&gt; <br>&gt; I’m not involved in the Rust community so I wouldn’t feel comfortable making claims for them. <br></p><p>I’m not asking for you to speak for them.  But I do think we need to learn from communities that are having success with typed error handling.  Your proposal would be stronger if it went into detail about how it would avoid the problems that have been encountered in other languages.  The experience of Rust could help to make that case as it is concrete and not hypothetical.<br></p><p>&gt; <br>&gt;&gt; I agree that error types are an important part of an API contract.  One of the big hurdles to doing this well is the need to catch errors when all that needs to be done is to wrap and rethrow them.  Ideally should not need to do this just to perform a simple type translation to map the underlying error into the type we wish to expose as part of a stable API contract.  You might want to take a look at the From mechanism Rust uses to facilitate this.  IMO a proposal for typed error handling should address this issue in some way (even if the author determines this mechanism is not necessary or a good design cannot be identified).<br>&gt; <br>&gt; The From() construct seems like a map(T) -&gt; U problem, but it seems heavily tied into the ability to create sum types. Swift doesn’t have this feature, and that feature is out-of-scope for this proposal. More on this later.<br></p><p>My understanding is that Rust uses static multi-dispatch to do this.  I don’t believe it has anything to do with structural sum types.  Rust error handling uses a Result type with a single error case: http://doc.rust-lang.org/book/error-handling.html &lt;http://doc.rust-lang.org/book/error-handling.html&gt;.<br></p><p>If you don’t believe a mechanism like this is necessary and don’t include one in your design it will lead to either a lot of boilerplate or avoidance of typed errors (depending on the developer).  I think you should expect a lot of complaints about this and I think it will generate a lot of -1 votes for the proposal.<br></p><p>&gt; <br>&gt;&gt; I would also like to see much more detail on why you think allowing a function to throw multiple error types is problematic.  My impression is that you have concerns from a usability point of view.  I am on the fence here to some degree, but definitely leaning in the direction that allowing a function to throw multiple error types is better.  <br>&gt; <br>&gt; Sure. There’s no functionality today to auto-generate a sum type in Swift today, and that is what this request really is. If you want to return multiple return types, then you need to do exactly what Rust does and create a sum type that composes the various types of errors. This exposes the same potential fragile API surface as extending enums do. I did call this part out specifically.<br></p><p>How does this create a fragile API surface area?  Adding a new error type to the signature would be a breaking change to the API contract.  This is really no different than changing the type of error that can be thrown under your proposal.<br></p><p>&gt; I see this functionality as a general limitation in the language. For example, errors are not the only context where you may want to return a type of A, B, or C. There have been other proposals on how we might do that in Swift. If and when it was solved in the general case for type parameters, I can’t foresee a compelling reason why it wouldn’t work in this context as well.<br></p><p>That makes sense in some ways, but I don’t think it’s unreasonable to ask for some analysis of whether a better design for typed errors would be possible if we had them.  IMO it’s pretty important to get the design of typed errors right if / when we add them.  If we don’t it will be considered a major mistake and will lead to a lot of less than desirable outcomes down the road.<br></p><p>I also think typed errors may be one of the more important use cases for structural sum types of some kind.  If we are able to show that design problems that cannot be solved without them can be solved with them that might influence whether they are added or not.  It might also influence when it makes sense to add support for typed errors to the language.<br></p><p>&gt; <br>&gt;&gt; I am willing to be convinced that a single error type is better than multiple error types but the current proposal does not provide a compelling argument in that direction.  It just says “Java checked exceptions”.  I know these have been pretty much universally considered a serious design mistake.  My impression is that there are quite a few reasons for that.  I don’t have any direct experience with Java and am not familiar with the details.  If you could elaborate on specifically why you believe allowing multiple error types was a significant contributor to the problem in a manner that indicates that they will be a problem in any language that includes them I would appreciate that.  Links would be sufficient if they are focused on answering this particular question.  <br>&gt; <br>&gt; I guess I should have just specifically called this out in the proposal. It’s not because of “Java checked exceptions”, it’s because nowhere else in the language are types allowed to be essentially annotated in a sum-like fashion. We can’t directly say a function returns an Int or a String. We can’t say a parameter can take an Int or a Double. Similarly, I propose we can’t say a function can return an error A or B.<br>&gt; <br>&gt; Thus, the primary reason is about type-system consistency.<br>&gt; <br>&gt; Swift already supports a construct to create sum types: associated enums. What it doesn’t allow is the ability to create them in a syntactic shorthand. In this way, my error proposal does the same thing as Rust: multiple return types need to be combined into a single-type - enum.<br></p><p>That approach would make catch clauses rather clunky by nesting errors inside of associated values.  If you’re advocating for this approach do you have any ideas on how to streamline syntax for catching them?<br></p><p>Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/e53a8a51/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/49e77a417c2ab608756778c4a75ee14f?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>Alex Popov</string> &lt;hello at alexpopov.ca&gt;<p>December 18, 2015 at 10:00:00am</p></header><div class="content"><p>Hi all,<br></p><p>  <br></p><p>I am very much pro this addition, if for nothing else than more information<br>for the developer using the API.<br></p><p>  <br></p><p>Limiting `throws MyErrorType` to only Enums, Structs and final Classes gets<br>around the Java problems so far as I can see.<br></p><p>  <br></p><p>As for the usefulness of this, I&#39;m working on a fairly large project, and the<br>only way of documenting what errors can be thrown is through documentation<br>comments, which must then be maintained — there is little worse than incorrect<br>/out-of-date documentation. Although currently the catch-all is mandated,<br>guaranteeing safety, as a developer I&#39;m equally concerned about recovering<br>from an error: without knowing exactly which Enum can be thrown, or what<br>subset of cases can occur, I either have to navigate to the source code and go<br>down the rabbit hole of tracking that information down, or just accepting that<br>I don&#39;t know what&#39;ll be thrown (and thereby potentially not recovering from a<br>recoverable failure).<br></p><p>  <br></p><p>I find it really frustrating that the compiler is unable to help me out with<br>this, even though in certain cases I _can_ guarantee what will be thrown. If<br>this proposal also brings about more convenient pattern matching for error<br>handling, that&#39;s a +2 from me.<br></p><p>  <br></p><p>&lt;br  <br>—<br></p><p>&lt;br  <br></p><p>Alex Popov Jr.<br></p><p>Principal iOS Developer | Shelfie<br></p><p>&gt; On Dec 18 2015, at 9:42 am, Matthew Johnson via swift-evolution &amp;lt;swift-<br>evolution at swift.org&amp;gt; wrote:  <br>  <br></p><p>&gt;<br></p><p>&gt;&gt; On Dec 18, 2015, at 10:50 AM, David Owens II<br>&amp;lt;[david at owensd.io](mailto:david at owensd.io)&amp;gt; wrote:<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt;&gt; On Dec 18, 2015, at 5:53 AM, Matthew Johnson<br>&amp;lt;[matthew at anandabits.com](mailto:matthew at anandabits.com)&amp;gt; wrote:  <br>  <br>David,  <br>  <br>Thank you for taking the time to continue working on a proposal for typed<br>throws.  I agree that this feature is very desirable and appreciate the work<br>you’re doing to bring forward a proposal.  I think it’s a great start but also<br>has some room for improvement.  <br>  <br>First, I think it could be strengthened by incorporating some learning from<br>Rust.  My impression is that the Rust community is very happy with typed error<br>handling.  Adding some detail about their experience would provide a counter-<br>example to those who are concerned about the experience in Java and C++.  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br>I’m not involved in the Rust community so I wouldn’t feel comfortable making<br>claims for them.  <br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; I’m not asking for you to speak for them.  But I do think we need to learn<br>from communities that are having success with typed error handling.  Your<br>proposal would be stronger if it went into detail about how it would avoid the<br>problems that have been encountered in other languages.  The experience of<br>Rust could help to make that case as it is concrete and not hypothetical.<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt;&gt; I agree that error types are an important part of an API contract.  One of<br>the big hurdles to doing this well is the need to catch errors when all that<br>needs to be done is to wrap and rethrow them.  Ideally should not need to do<br>this just to perform a simple type translation to map the underlying error<br>into the type we wish to expose as part of a stable API contract.  You might<br>want to take a look at the From mechanism Rust uses to facilitate this.  IMO a<br>proposal for typed error handling should address this issue in some way (even<br>if the author determines this mechanism is not necessary or a good design<br>cannot be identified).  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br>The From() construct seems like a map(T) -&amp;gt; U problem, but it seems heavily<br>tied into the ability to create sum types. Swift doesn’t have this feature,<br>and that feature is out-of-scope for this proposal. More on this later.  <br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; My understanding is that Rust uses static multi-dispatch to do this.  I<br>don’t believe it has anything to do with structural sum types.  Rust error<br>handling uses a Result type with a single error case: &lt;http://doc.rust-<br>lang.org/book/error-handling.html&gt;.<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; If you don’t believe a mechanism like this is necessary and don’t include<br>one in your design it will lead to either a lot of boilerplate or avoidance of<br>typed errors (depending on the developer).  I think you should expect a lot of<br>complaints about this and I think it will generate a lot of -1 votes for the<br>proposal.<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt;&gt; I would also like to see much more detail on why you think allowing a<br>function to throw multiple error types is problematic.  My impression is that<br>you have concerns from a usability point of view.  I am on the fence here to<br>some degree, but definitely leaning in the direction that allowing a function<br>to throw multiple error types is better.  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br>Sure. There’s no functionality today to auto-generate a sum type in Swift<br>today, and that is what this request really is. If you want to return multiple<br>return types, then you need to do exactly what Rust does and create a sum type<br>that composes the various types of errors. This exposes the same potential<br>fragile API surface as extending enums do. I did call this part out<br>specifically.<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; How does this create a fragile API surface area?  Adding a new error type to<br>the signature would be a breaking change to the API contract.  This is really<br>no different than changing the type of error that can be thrown under your<br>proposal.<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt;&gt; I see this functionality as a general limitation in the language. For<br>example, errors are not the only context where you may want to return a type<br>of A, B, or C. There have been other proposals on how we might do that in<br>Swift. If and when it was solved in the general case for type parameters, I<br>can’t foresee a compelling reason why it wouldn’t work in this context as<br>well.  <br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; That makes sense in some ways, but I don’t think it’s unreasonable to ask<br>for some analysis of whether a better design for typed errors would be<br>possible if we had them.  IMO it’s pretty important to get the design of typed<br>errors right if / when we add them.  If we don’t it will be considered a major<br>mistake and will lead to a lot of less than desirable outcomes down the road.<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; I also think typed errors may be one of the more important use cases for<br>structural sum types of some kind.  If we are able to show that design<br>problems that **cannot** be solved without them **can** be solved with them<br>that might influence whether they are added or not.  It might also influence<br>**when** it makes sense to add support for typed errors to the language.<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt;&gt; I am willing to be convinced that a single error type is better than<br>multiple error types but the current proposal does not provide a compelling<br>argument in that direction.  It just says “Java checked exceptions”.  I know<br>these have been pretty much universally considered a serious design mistake.<br>My impression is that there are quite a few reasons for that.  I don’t have<br>any direct experience with Java and am not familiar with the details.  If you<br>could elaborate on specifically why you believe allowing multiple error types<br>was a significant contributor to the problem in a manner that indicates that<br>they will be a problem in any language that includes them I would appreciate<br>that.  Links would be sufficient if they are focused on answering this<br>particular question.  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br>I guess I should have just specifically called this out in the proposal. It’s<br>not because of “Java checked exceptions”, it’s because nowhere else in the<br>language are types allowed to be essentially annotated in a sum-like fashion.<br>We can’t directly say a function returns an Int or a String. We can’t say a<br>parameter can take an Int or a Double. Similarly, I propose we can’t say a<br>function can return an error A or B.  <br>  <br>Thus, the primary reason is about type-system consistency.  <br>  <br>Swift already supports a construct to create sum types: associated enums. What<br>it doesn’t allow is the ability to create them in a syntactic shorthand. In<br>this way, my error proposal does the same thing as Rust: multiple return types<br>need to be combined into a single-type - enum.<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; That approach would make catch clauses rather clunky by nesting errors<br>inside of associated values.  If you’re advocating for this approach do you<br>have any ideas on how to streamline syntax for catching them?<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; Matthew<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; ![](https://u2002410.ct.sendgrid.net/wf/open?upn=CmwAv3oRa0AH4Hd1bWC6X-<br>2BzbhPqo1YEo6mPHEujr90vUljsud-2BB6KUDP5cz-<br>2Fv0xXzcKh2I7l3AVBGsasABqpSVQZA47MBrZnIRbuczKfFabYpw7SI-2FEE3vWg8ZsRzYrusFrkP3<br>-2Fdfov48EZIMr1UIxRUjZjSkWFw5gJSpy8pL-2Fo1jlRzHx1-2B7tEBTDx1EdAI9LfCCL-<br>2FD4vOGJSJXCTPis0shiFWB5ZEKHAD1LQ3af20-3D)<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/aef8e60f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 18, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 9:41 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; I’m not asking for you to speak for them.  But I do think we need to learn from communities that are having success with typed error handling.  Your proposal would be stronger if it went into detail about how it would avoid the problems that have been encountered in other languages.  The experience of Rust could help to make that case as it is concrete and not hypothetical.<br></p><p>Sure, it could. It’s also anecdotal. It’s not necessarily true that something that works well in one context works well in another. It’s good to note that typed errors are wholly considered bad, but I’m not sure how much further we need to go then that. If you have specifics, then I could probably add them as an addendum to the proposal.<br></p><p>&gt; My understanding is that Rust uses static multi-dispatch to do this.  I don’t believe it has anything to do with structural sum types.  Rust error handling uses a Result type with a single error case: http://doc.rust-lang.org/book/error-handling.html &lt;http://doc.rust-lang.org/book/error-handling.html&gt;.<br></p><p>That example takes you through many of the options available. In the end, you end up at the sum-type for the error:<br>fn search&lt;P: AsRef&lt;Path&gt;&gt;<br>         (file_path: &amp;Option&lt;P&gt;, city: &amp;str)<br>         -&gt; Result&lt;Vec&lt;PopulationCount&gt;, CliError&gt; {<br>    ...<br>}<br>It’s the CliError which is defined as:<br>enum CliError {<br>    Io(io::Error),<br>    Csv(csv::Error),<br>    NotFound,<br>}<br>The From() function essentially allows the try! macro to expand these in a nicer way.<br></p><p>So back to the proposal, one of the key things is to promote the `error` constant throughout the catch-clauses. This means that we can already leverage Swift’s pattern matching to solve this problem:<br></p><p>enum Combined {<br>    case IO(String)<br>    case Number(Int)<br>}<br></p><p>func simulate(err: Combined) {<br>    switch err {<br>    case let Combined.IO(string) where string == &quot;hi&quot;: print(&quot;only hi!&quot;)<br>    case let Combined.IO(string): print(string)<br>    case let Combined.Number(value): print(value)<br>    }<br>}<br></p><p>simulate(Combined.IO(&quot;hi&quot;))<br>simulate(Combined.IO(&quot;io&quot;))<br>simulate(Combined.Number(9))<br></p><p>It’s not hard to use Swift’s pattern matching to extract out the inner information on an associated value enum and white the case/catch clauses. So unless I’m missing something, I think Swift already provides a good mechanism to do what you’re asking for, with the caveat that the `error` constant is promoted to be usable in the catch-clauses similar to how the switch-statements work.<br></p><p>Maybe adding this to the proposal would clarify usage?<br></p><p>&gt; How does this create a fragile API surface area?  Adding a new error type to the signature would be a breaking change to the API contract.  This is really no different than changing the type of error that can be thrown under your proposal.<br></p><p>It’s the same fragility that enums create; this was covered in the criticisms section. The likelihood of adding additional error cases is much greater than a change that would completely change the type of the error.<br></p><p>&gt; <br>&gt;&gt; I see this functionality as a general limitation in the language. For example, errors are not the only context where you may want to return a type of A, B, or C. There have been other proposals on how we might do that in Swift. If and when it was solved in the general case for type parameters, I can’t foresee a compelling reason why it wouldn’t work in this context as well.<br>&gt; <br>&gt; That makes sense in some ways, but I don’t think it’s unreasonable to ask for some analysis of whether a better design for typed errors would be possible if we had them.  IMO it’s pretty important to get the design of typed errors right if / when we add them.  If we don’t it will be considered a major mistake and will lead to a lot of less than desirable outcomes down the road.<br>&gt; <br>&gt; I also think typed errors may be one of the more important use cases for structural sum types of some kind.  If we are able to show that design problems that cannot be solved without them can be solved with them that might influence whether they are added or not.  It might also influence when it makes sense to add support for typed errors to the language.<br></p><p>The problem can be solved without implicitly generated sum types though. The design of typed errors, as proposed, is to be consistent with the Swift type system today. Regardless, I’ve added a response in the “cirticisms” section that hopefully addresses this in some manner - basically, yes it would be helpful, but out of scope for this proposal.<br></p><p>&gt; That approach would make catch clauses rather clunky by nesting errors inside of associated values.  If you’re advocating for this approach do you have any ideas on how to streamline syntax for catching them?<br></p><p>See above example. Does that address this concern?<br></p><p>-David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/922fb3c1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>December 18, 2015 at 07:00:00pm</p></header><div class="content"><p>Hi David<br></p><p>I started reading your proposal and I have a couple of questions. <br></p><p>In the Enum Base ErrorType example you mentioned that it requires a &quot;catch { }&quot; clause.  However the code is already covering the two possible Enum values (OffBy1 and MutatedValue). Why is the &quot;catch { }&quot; required? I typed that code into a playground and I did not get any errors. Are you saying that because the Enum type could add a value in the future?<br></p><p>Also, you proposed the catch clause to use error as the name of the constant holding the error.  Wouldn&#39;t it be better to let the programmer decide the name rather than hard coding it to use error? For example:<br></p><p>catch e where e.value == 0 { print(&quot;0&quot;) }<br>catch e where e.value == 1 { print(&quot;1&quot;) }<br>catch { print(&quot;nothing&quot;) }<br></p><p>Thank you <br>Ricardo<br></p><p>Sent from my iPhone<br></p><p>&gt; On Dec 18, 2015, at 1:36 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 18, 2015, at 9:41 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’m not asking for you to speak for them.  But I do think we need to learn from communities that are having success with typed error handling.  Your proposal would be stronger if it went into detail about how it would avoid the problems that have been encountered in other languages.  The experience of Rust could help to make that case as it is concrete and not hypothetical.<br>&gt; <br>&gt; Sure, it could. It’s also anecdotal. It’s not necessarily true that something that works well in one context works well in another. It’s good to note that typed errors are wholly considered bad, but I’m not sure how much further we need to go then that. If you have specifics, then I could probably add them as an addendum to the proposal.<br>&gt; <br>&gt;&gt; My understanding is that Rust uses static multi-dispatch to do this.  I don’t believe it has anything to do with structural sum types.  Rust error handling uses a Result type with a single error case: http://doc.rust-lang.org/book/error-handling.html.<br>&gt; <br>&gt; That example takes you through many of the options available. In the end, you end up at the sum-type for the error:<br>&gt; fn search&lt;P: AsRef&lt;Path&gt;&gt;<br>&gt;          (file_path: &amp;Option&lt;P&gt;, city: &amp;str)<br>&gt;          -&gt; Result&lt;Vec&lt;PopulationCount&gt;, CliError&gt; {<br>&gt;     ...<br>&gt; }<br>&gt; It’s the CliError which is defined as:<br>&gt; enum CliError {<br>&gt;     Io(io::Error),<br>&gt;     Csv(csv::Error),<br>&gt;     NotFound,<br>&gt; }<br>&gt; The From() function essentially allows the try! macro to expand these in a nicer way.<br>&gt; <br>&gt; So back to the proposal, one of the key things is to promote the `error` constant throughout the catch-clauses. This means that we can already leverage Swift’s pattern matching to solve this problem:<br>&gt; <br>&gt; enum Combined {<br>&gt;     case IO(String)<br>&gt;     case Number(Int)<br>&gt; }<br>&gt; <br>&gt; func simulate(err: Combined) {<br>&gt;     switch err {<br>&gt;     case let Combined.IO(string) where string == &quot;hi&quot;: print(&quot;only hi!&quot;)<br>&gt;     case let Combined.IO(string): print(string)<br>&gt;     case let Combined.Number(value): print(value)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; simulate(Combined.IO(&quot;hi&quot;))<br>&gt; simulate(Combined.IO(&quot;io&quot;))<br>&gt; simulate(Combined.Number(9))<br>&gt; <br>&gt; It’s not hard to use Swift’s pattern matching to extract out the inner information on an associated value enum and white the case/catch clauses. So unless I’m missing something, I think Swift already provides a good mechanism to do what you’re asking for, with the caveat that the `error` constant is promoted to be usable in the catch-clauses similar to how the switch-statements work.<br>&gt; <br>&gt; Maybe adding this to the proposal would clarify usage?<br>&gt; <br>&gt;&gt; How does this create a fragile API surface area?  Adding a new error type to the signature would be a breaking change to the API contract.  This is really no different than changing the type of error that can be thrown under your proposal.<br>&gt; <br>&gt; It’s the same fragility that enums create; this was covered in the criticisms section. The likelihood of adding additional error cases is much greater than a change that would completely change the type of the error.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; I see this functionality as a general limitation in the language. For example, errors are not the only context where you may want to return a type of A, B, or C. There have been other proposals on how we might do that in Swift. If and when it was solved in the general case for type parameters, I can’t foresee a compelling reason why it wouldn’t work in this context as well.<br>&gt;&gt; <br>&gt;&gt; That makes sense in some ways, but I don’t think it’s unreasonable to ask for some analysis of whether a better design for typed errors would be possible if we had them.  IMO it’s pretty important to get the design of typed errors right if / when we add them.  If we don’t it will be considered a major mistake and will lead to a lot of less than desirable outcomes down the road.<br>&gt;&gt; <br>&gt;&gt; I also think typed errors may be one of the more important use cases for structural sum types of some kind.  If we are able to show that design problems that cannot be solved without them can be solved with them that might influence whether they are added or not.  It might also influence when it makes sense to add support for typed errors to the language.<br>&gt; <br>&gt; The problem can be solved without implicitly generated sum types though. The design of typed errors, as proposed, is to be consistent with the Swift type system today. Regardless, I’ve added a response in the “cirticisms” section that hopefully addresses this in some manner - basically, yes it would be helpful, but out of scope for this proposal.<br>&gt; <br>&gt;&gt; That approach would make catch clauses rather clunky by nesting errors inside of associated values.  If you’re advocating for this approach do you have any ideas on how to streamline syntax for catching them?<br>&gt; <br>&gt; See above example. Does that address this concern?<br>&gt; <br>&gt; -David<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/ff79ca30/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 18, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 4:38 PM, Ricardo Parada &lt;rparada at mac.com&gt; wrote:<br>&gt; <br>&gt; Hi David<br>&gt; <br>&gt; I started reading your proposal and I have a couple of questions. <br>&gt; <br>&gt; In the Enum Base ErrorType example you mentioned that it requires a &quot;catch { }&quot; clause.  However the code is already covering the two possible Enum values (OffBy1 and MutatedValue). Why is the &quot;catch { }&quot; required? I typed that code into a playground and I did not get any errors. Are you saying that because the Enum type could add a value in the future?<br></p><p>Playgrounds are basically in an anonymous function that throws, so the problem doesn’t show up there at the top level. Copy this into your playground.<br></p><p>enum MyError: ErrorType {<br>    case OnlyOne<br>}<br></p><p>func thrower() throws { throw MyError.OnlyOne }<br></p><p>func nolies() {<br>    do {<br>        try thrower()<br>    }<br>    catch MyError.OnlyOne { print(&quot;handled&quot;) }<br>    // catch { print(&quot;compiler error until uncommented&quot;) }<br>}<br></p><p>&gt; Also, you proposed the catch clause to use error as the name of the constant holding the error.  Wouldn&#39;t it be better to let the programmer decide the name rather than hard coding it to use error? For example:<br>&gt; <br>&gt; catch e where e.value == 0 { print(&quot;0&quot;) }<br>&gt; catch e where e.value == 1 { print(&quot;1&quot;) }<br>&gt; catch { print(&quot;nothing&quot;) }<br></p><p>The “error” name is already specified in the Swift rules for what the constant is. I don’t see any compelling reason to propose a change to that.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/1d85ba22/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>December 18, 2015 at 09:00:00pm</p></header><div class="content"><p>Thanks for the clarification.  Why is the compiler saying that the catch is not exhaustive when it is covering all the possible values of the enum?  Is it to be able to catch future values added to the enum type?<br></p><p><br>&gt; On Dec 18, 2015, at 8:05 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 18, 2015, at 4:38 PM, Ricardo Parada &lt;rparada at mac.com &lt;mailto:rparada at mac.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi David<br>&gt;&gt; <br>&gt;&gt; I started reading your proposal and I have a couple of questions. <br>&gt;&gt; <br>&gt;&gt; In the Enum Base ErrorType example you mentioned that it requires a &quot;catch { }&quot; clause.  However the code is already covering the two possible Enum values (OffBy1 and MutatedValue). Why is the &quot;catch { }&quot; required? I typed that code into a playground and I did not get any errors. Are you saying that because the Enum type could add a value in the future?<br>&gt; <br>&gt; Playgrounds are basically in an anonymous function that throws, so the problem doesn’t show up there at the top level. Copy this into your playground.<br>&gt; <br>&gt; enum MyError: ErrorType {<br>&gt;     case OnlyOne<br>&gt; }<br>&gt; <br>&gt; func thrower() throws { throw MyError.OnlyOne }<br>&gt; <br>&gt; func nolies() {<br>&gt;     do {<br>&gt;         try thrower()<br>&gt;     }<br>&gt;     catch MyError.OnlyOne { print(&quot;handled&quot;) }<br>&gt;     // catch { print(&quot;compiler error until uncommented&quot;) }<br>&gt; }<br>&gt; <br>&gt;&gt; Also, you proposed the catch clause to use error as the name of the constant holding the error.  Wouldn&#39;t it be better to let the programmer decide the name rather than hard coding it to use error? For example:<br>&gt;&gt; <br>&gt;&gt; catch e where e.value == 0 { print(&quot;0&quot;) }<br>&gt;&gt; catch e where e.value == 1 { print(&quot;1&quot;) }<br>&gt;&gt; catch { print(&quot;nothing&quot;) }<br>&gt; <br>&gt; The “error” name is already specified in the Swift rules for what the constant is. I don’t see any compelling reason to propose a change to that.<br>&gt; <br>&gt; -David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/ab2d308d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 19, 2015 at 03:00:00pm</p></header><div class="content"><p>Right now, it&#39;s because throws does not specify a type to be thrown, and the compiler doesn&#39;t know that you&#39;ve checked all the possibilities. For all it knows, it could be something else than a MyError.<br></p><p>&gt; Le 18 déc. 2015 à 21:28:41, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Thanks for the clarification.  Why is the compiler saying that the catch is not exhaustive when it is covering all the possible values of the enum?  Is it to be able to catch future values added to the enum type?<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 18, 2015, at 8:05 PM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 18, 2015, at 4:38 PM, Ricardo Parada &lt;rparada at mac.com &lt;mailto:rparada at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi David<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I started reading your proposal and I have a couple of questions. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the Enum Base ErrorType example you mentioned that it requires a &quot;catch { }&quot; clause.  However the code is already covering the two possible Enum values (OffBy1 and MutatedValue). Why is the &quot;catch { }&quot; required? I typed that code into a playground and I did not get any errors. Are you saying that because the Enum type could add a value in the future?<br>&gt;&gt; <br>&gt;&gt; Playgrounds are basically in an anonymous function that throws, so the problem doesn’t show up there at the top level. Copy this into your playground.<br>&gt;&gt; <br>&gt;&gt; enum MyError: ErrorType {<br>&gt;&gt;     case OnlyOne<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func thrower() throws { throw MyError.OnlyOne }<br>&gt;&gt; <br>&gt;&gt; func nolies() {<br>&gt;&gt;     do {<br>&gt;&gt;         try thrower()<br>&gt;&gt;     }<br>&gt;&gt;     catch MyError.OnlyOne { print(&quot;handled&quot;) }<br>&gt;&gt;     // catch { print(&quot;compiler error until uncommented&quot;) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt;&gt; Also, you proposed the catch clause to use error as the name of the constant holding the error.  Wouldn&#39;t it be better to let the programmer decide the name rather than hard coding it to use error? For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; catch e where e.value == 0 { print(&quot;0&quot;) }<br>&gt;&gt;&gt; catch e where e.value == 1 { print(&quot;1&quot;) }<br>&gt;&gt;&gt; catch { print(&quot;nothing&quot;) }<br>&gt;&gt; <br>&gt;&gt; The “error” name is already specified in the Swift rules for what the constant is. I don’t see any compelling reason to propose a change to that.<br>&gt;&gt; <br>&gt;&gt; -David<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/b4fde2ce/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 21, 2015 at 08:00:00am</p></header><div class="content"><p>Hi David,<br></p><p>I spent a lot of time last night thinking about how my concerns can be addressed without changes to the type system.  I also spent some time working through some concrete examples this morning.  This has helped narrow my concerns considerably.<br></p><p>I am going to suggest one addition to the proposal at the end.  If you’re willing to incorporate that I will be pretty happy with what we can accomplish without any changes to the type system.<br></p><p>First, consider the case where there are some common errors which a library may throw in different places.  These are considered to be part of the API contract.  Some library functions may throw either common error depending on the code path taken.  <br></p><p>Your proposal suggests we should fall back to throwing ErrorType in that case.  This is not really a good solution in my mind.  <br></p><p>A library should be able to have a family of error types it publishes in its API contract and some functions should be able to throw more than one.  As you suggest, rather than a structural sum type we can manually create a sum type to do this.  <br></p><p>I had two concerns about this.  The first and most important was in the verbosity of catching the nested errors.  Here’s an example:<br></p><p>enum CommonOne: ErrorType {<br>    case One<br>    case Two<br>}<br>enum CommonTwo:ErrorType {<br>    case One<br>    case Two<br>}<br>enum Both: ErrorType {<br>    case One(CommonOne)<br>    case Two(CommonTwo)<br>}<br></p><p>I was concerned that we would need to do something like this involving some verbose and nasty nesting, etc:<br></p><p>func functionThatThrowsBoth() throws Both { … }<br></p><p>do {<br>    try functionThatThrowsBoth()<br>}<br>catch .One(let inner) {<br>    switch inner {<br>        case .one: ...<br>        case .two: ...<br>    }<br>}<br>catch .Two(let inner) {<br>    switch inner {<br>        case .one: ...<br>        case .two: ...<br>    }<br>}<br></p><p>As it turns out, I am still getting familiar with the power of nested pattern matching and this was an unfounded concern.  This is great!  We can actually do this:<br></p><p>do {<br>    try functionThatThrowsBoth()<br>}<br>catch .One(.One) { ... }<br>catch .One(.Two) { ... }<br>catch .Two(.One) { ... }<br>catch .Two(.Two) { ... }<br></p><p>(note: this works today if you include a Both prefix in the cases which will be unnecessary with a typed error)<br></p><p>That is great!  I have no concerns about this syntax for catching nested errors.  This covers use cases that need to throw “multiple” error types pretty well.  There are probably some edge cases where a structural sum type would be more convenient but I think they would be rare and am not concerned about them.<br></p><p>I would also like to comment that there are some interesting related ideas for enhancing enums in the &quot;[Pitch] Use enums as enum underlying types” thread.  They don’t directly impact the proposal but could make such use cases even more convenient if they are pursued independently.<br></p><p>The other concern I have is still valid, but I think a relatively straightforward solution is possible.<br></p><p>Continuing with the previous example, let’s look at the implementation of `functionThatThrowsBoth`:<br></p><p>func throwsInnerOne() throws InnerOne {<br>    throw InnerOne.One<br>}<br></p><p>func throwsInnerTwo() throws InnerTwo {<br>    throw InnerTwo.Two<br>}<br></p><p>func functionThatThrowsBoth(_ whichError: Bool) throws Both {<br>    do {<br>        if whichError {<br>            try throwsInnerOne()<br>        } else {<br>            try throwsInnerTwo()<br>        }<br>    }<br>    catch let inner as InnerOne { throw Both.One(inner) }<br>    catch let inner as InnerTwo { throw Both.Two(inner) }<br>}<br></p><p>The implementation is dominated by the concern of wrapping the error.  This is pretty gross.  This problem exists even if we are not wrapping the error, but rather translating the error from the underlying error type into the error type we are publishing in our API contract.  <br></p><p>Here is an example where we are not wrapping the error, but translating it:<br></p><p>func functionThatCallsUnderlingyingThrows(_ whichError: Bool) throws MyPublishedError {<br>    do {<br>        try funcThatThrowsAnErrorThatMustBeTranslatedIntoMyPublishedError()<br>    }<br>    // catching logic that eventually throws MyPublishedErrorSomehow<br>}<br></p><p>The best we can do is to create a translation function or initializer:<br></p><p>enum MyPublishedError: ErrorType {<br>    init(_ error: UnderlyingError) { … }<br>}<br></p><p>func functionThatCallsUnderlingyingThrows(_ whichError: Bool) throws MyPublishedError {<br>    do {<br>        try funcThatThrowsAnErrorThatMustBeTranslatedIntoMyPublishedError()<br>    }<br>    catch let error as UnderlyingError { throw MyPublishedError(error) }<br>}<br></p><p>This is better as it removes the logic from the function itself.  But it’s still not great as it introduces a lot of boilerplate everywhere we need to translate and / or wrap errors.  The boilerplate also grows for each underlying error we need to translate:<br></p><p>func functionThatCallsUnderlingyingThrows(_ whichError: Bool) throws MyPublishedError {<br>    do {<br>        // bunch of stuff throwing several different errors<br>    }<br>    catch let error as UnderlyingError { throw MyPublishedError(error) }<br>    catch let error as OtherUnderlyingError { throw MyPublishedError(error) }<br>    // more catch clauses until we have covered every possible error type thrown by the body<br>    // hopefully the compiler wouldn’t require a default clause here but it probably would<br>}<br></p><p>This is the problem that `From` addresses in Rust.  Swift is not Rust and our solution will look different.  The point is that this is a problem and it can and has been solved.<br></p><p>My suggestion is that we should allow implicit conversion during error propagation.  If the published error type has one and only one non-failable, non-throwing initializer that takes a single argument of the type that is thrown (including enum case initializers with a single associated value of the thrown type) that initializer is used to implicitly convert to the published error type.  This conversion could be accomplished by synthesizing the necessary boilerplate or by some other means.<br></p><p>Now we have:<br></p><p>func functionThatCallsUnderlingyingThrows(_ whichError: Bool) throws MyPublishedError {<br>        try funcThatThrowsAnErrorThatMustBeTranslatedIntoMyPublishedError()<br>}<br></p><p>This looks as it should.  We don’t pay a price of boilerplate for carefully designing the errors we expose in our API contract.  This also handles automatic wrapping of errors where that is appropriate.<br></p><p>I don’t suggest implicit conversion lightly.  I generally hate implicit conversions.  But I think it makes a lot of sense here.  It keeps concerns separate and removes boilerplate that distracts from the logic at hand, thus vastly improving readability.  It is also likely to help minimize code impact when implementation details change and we need to modify how we are translating errors into the contract we expose.<br></p><p>If we don’t support the implicit conversion there are three paths that can be taken by developers.  None of them are great and we will have three camps with different preference:<br></p><p>1. Just stick to untyped errors.  I think there are some pretty smart people who think this will be a common practice even if we have support for typed errors in the language.<br>2. Allow underlying errors to flow through (when there is only a single underlying error type).  This is brittle and I know you are of the opinion that it is a bad idea.  I agree.<br>3. Write the boilerplate manually.  This is annoying and is a significant barrier to clarity and readability.<br></p><p>I hope you will like the idea of implicit conversion during error propagation enough to add it to your proposal.  With it I will be an enthusiastic supporter.  It will help to establish good practices in the community for using typed errors in a robust and thoughtful way.<br></p><p>Without implicit error conversion I will still support the proposal but would plan to write a follow on proposal introducing the much needed (IMO) implicit conversion during error propagation.  I would also expect opposition to the proposal during review from people concerned about one or more of the above listed options for dealing with error translation.<br></p><p>I think the idea of restricting typed errors to structs, enums, NSError, and final classes that has come up is a good one.  It might be worth considering going further than that and restrict it to only enums and NSError.  One of the biggest issues I have encountered with error handling during my career is that all too often the possible error cases are quite poorly documented.  We have to allow NSError for Cocoa interop, but aside from the error types should really be enums IMO as they make it very clear what cases might need to be handled.<br></p><p>I want to thank you again for putting this proposal together and taking the time to consider and respond to feedback.  Typed errors will be a significant step forward for Swift and I am looking forward to it.  <br></p><p>Matthew<br></p><p><br></p><p><br></p><p>&gt; On Dec 18, 2015, at 12:36 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 18, 2015, at 9:41 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’m not asking for you to speak for them.  But I do think we need to learn from communities that are having success with typed error handling.  Your proposal would be stronger if it went into detail about how it would avoid the problems that have been encountered in other languages.  The experience of Rust could help to make that case as it is concrete and not hypothetical.<br>&gt; <br>&gt; Sure, it could. It’s also anecdotal. It’s not necessarily true that something that works well in one context works well in another. It’s good to note that typed errors are wholly considered bad, but I’m not sure how much further we need to go then that. If you have specifics, then I could probably add them as an addendum to the proposal.<br>&gt; <br>&gt;&gt; My understanding is that Rust uses static multi-dispatch to do this.  I don’t believe it has anything to do with structural sum types.  Rust error handling uses a Result type with a single error case: http://doc.rust-lang.org/book/error-handling.html &lt;http://doc.rust-lang.org/book/error-handling.html&gt;.<br>&gt; <br>&gt; That example takes you through many of the options available. In the end, you end up at the sum-type for the error:<br>&gt; fn search&lt;P: AsRef&lt;Path&gt;&gt;<br>&gt;          (file_path: &amp;Option&lt;P&gt;, city: &amp;str)<br>&gt;          -&gt; Result&lt;Vec&lt;PopulationCount&gt;, CliError&gt; {<br>&gt;     ...<br>&gt; }<br>&gt; It’s the CliError which is defined as:<br>&gt; enum CliError {<br>&gt;     Io(io::Error),<br>&gt;     Csv(csv::Error),<br>&gt;     NotFound,<br>&gt; }<br>&gt; The From() function essentially allows the try! macro to expand these in a nicer way.<br>&gt; <br>&gt; So back to the proposal, one of the key things is to promote the `error` constant throughout the catch-clauses. This means that we can already leverage Swift’s pattern matching to solve this problem:<br>&gt; <br>&gt; enum Combined {<br>&gt;     case IO(String)<br>&gt;     case Number(Int)<br>&gt; }<br>&gt; <br>&gt; func simulate(err: Combined) {<br>&gt;     switch err {<br>&gt;     case let Combined.IO(string) where string == &quot;hi&quot;: print(&quot;only hi!&quot;)<br>&gt;     case let Combined.IO(string): print(string)<br>&gt;     case let Combined.Number(value): print(value)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; simulate(Combined.IO(&quot;hi&quot;))<br>&gt; simulate(Combined.IO(&quot;io&quot;))<br>&gt; simulate(Combined.Number(9))<br>&gt; <br>&gt; It’s not hard to use Swift’s pattern matching to extract out the inner information on an associated value enum and white the case/catch clauses. So unless I’m missing something, I think Swift already provides a good mechanism to do what you’re asking for, with the caveat that the `error` constant is promoted to be usable in the catch-clauses similar to how the switch-statements work.<br>&gt; <br>&gt; Maybe adding this to the proposal would clarify usage?<br>&gt; <br>&gt;&gt; How does this create a fragile API surface area?  Adding a new error type to the signature would be a breaking change to the API contract.  This is really no different than changing the type of error that can be thrown under your proposal.<br>&gt; <br>&gt; It’s the same fragility that enums create; this was covered in the criticisms section. The likelihood of adding additional error cases is much greater than a change that would completely change the type of the error.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; I see this functionality as a general limitation in the language. For example, errors are not the only context where you may want to return a type of A, B, or C. There have been other proposals on how we might do that in Swift. If and when it was solved in the general case for type parameters, I can’t foresee a compelling reason why it wouldn’t work in this context as well.<br>&gt;&gt; <br>&gt;&gt; That makes sense in some ways, but I don’t think it’s unreasonable to ask for some analysis of whether a better design for typed errors would be possible if we had them.  IMO it’s pretty important to get the design of typed errors right if / when we add them.  If we don’t it will be considered a major mistake and will lead to a lot of less than desirable outcomes down the road.<br>&gt;&gt; <br>&gt;&gt; I also think typed errors may be one of the more important use cases for structural sum types of some kind.  If we are able to show that design problems that cannot be solved without them can be solved with them that might influence whether they are added or not.  It might also influence when it makes sense to add support for typed errors to the language.<br>&gt; <br>&gt; The problem can be solved without implicitly generated sum types though. The design of typed errors, as proposed, is to be consistent with the Swift type system today. Regardless, I’ve added a response in the “cirticisms” section that hopefully addresses this in some manner - basically, yes it would be helpful, but out of scope for this proposal.<br>&gt; <br>&gt;&gt; That approach would make catch clauses rather clunky by nesting errors inside of associated values.  If you’re advocating for this approach do you have any ideas on how to streamline syntax for catching them?<br>&gt; <br>&gt; See above example. Does that address this concern?<br>&gt; <br>&gt; -David<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/5aea3449/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 21, 2015 at 11:00:00am</p></header><div class="content"><p>I’m just going to interject a few thoughts in here.<br></p><p>&gt; On Dec 21, 2015, at 6:36 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; Hi David,<br>&gt; <br>&gt; (my paraphrase: pattern matching is great and solves more of my concerns than I originally realized.) <br></p><p>Awesome!<br></p><p>&gt; I would also like to comment that there are some interesting related ideas for enhancing enums in the &quot;[Pitch] Use enums as enum underlying types” thread.  They don’t directly impact the proposal but could make such use cases even more convenient if they are pursued independently.<br></p><p>I’m not sure I really like any of those proposals, but feedback for those is better on that thread, and I’ve only taken a cursory look at them.<br></p><p>&gt; The other concern I have is still valid, but I think a relatively straightforward solution is possible.<br>&gt; <br>&gt; (my paraphrase: Converting from an inner-error to a publicly exposed error is tedious, boilerplate code.)<br></p><p>Maybe. I think that depends on the assumption that you do nothing other than convert the inner error to a published error. Also, it assumes that all “recoverable” inner errors stay “recoverable” outer errors.<br></p><p>I tend to use a lot of telemetry markers and assertions within my code, so it’s not a one-liner conversion.<br></p><p>do {<br>    try some.implementation.detail.throwing.api()<br>}<br>catch {<br>    // what happens here?<br>}<br></p><p>I actually think there are various options of what to do at this place:<br></p><p>Simply propagate the error out (basically untyped errors)<br>Wrap the error (still exposes the internal implementation details)<br>Convert the error to a published error type<br>Promote the error to a non-recoverable error (e.g. fatalError())<br></p><p>All of these can have additional code in place, such as telemetry/logging or debug assertions. While it might be the case that people simply want to wrap an error, can we say that is the safe way to deal with the errors? I’m not sure I’m willing to make that statement.<br></p><p>I, obviously, recommend against doing options #1 and #2 above. I’ll talk about conversion below. And I believe promotion would look something like this:<br></p><p>guard ((try? some.implementation.detail.throwing.api()) != nil) else { fatalError(&quot;bad mojo!&quot;) }<br></p><p>Or if I want the error:<br></p><p>do {<br>    try some.implementation.detail.throwing.api()<br>}<br>catch {<br>    Telemetry.LogFatalIssue(error)<br>    fatalError(&quot;bad mojo!&quot;)<br>}<br></p><p>In an ideal world, I would also like to be able to do something like this:<br></p><p>guard try some.implementation.detail.throwing.api() else {<br>    Telemetry.LogFatalIssue(error)<br>    fatalError(&quot;bad mojo!&quot;)    <br>}<br></p><p>But that’s a syntax that’s out-of-scope for this proposal as well.<br></p><p>&gt; This is the problem that `From` addresses in Rust.  Swift is not Rust and our solution will look different.  The point is that this is a problem and it can and has been solved.<br>&gt; <br>&gt; My suggestion is that we should allow implicit conversion during error propagation.  If the published error type has one and only one non-failable, non-throwing initializer that takes a single argument of the type that is thrown (including enum case initializers with a single associated value of the thrown type) that initializer is used to implicitly convert to the published error type.  This conversion could be accomplished by synthesizing the necessary boilerplate or by some other means.<br>&gt; <br>&gt; Now we have:<br>&gt; <br>&gt; func functionThatCallsUnderlingyingThrows(_ whichError: Bool) throws MyPublishedError {<br>&gt;         try funcThatThrowsAnErrorThatMustBeTranslatedIntoMyPublishedError()<br>&gt; }<br>&gt; <br>&gt; This looks as it should.  We don’t pay a price of boilerplate for carefully designing the errors we expose in our API contract.  This also handles automatic wrapping of errors where that is appropriate.<br></p><p>I would argue against implicit conversion. Again, this is about consistency with the language. Also, Rust is using it’s macro system to generate the code; it’s not actually doing implicit conversions either.<br></p><p>You could make it “nicer” by doing something like this:<br></p><p>try MyError.convertFrom(try funcThatThrowsAnErrorThatMustBeTranslatedItoMyPublishedError())<br></p><p>All of the “boiler-plate” code (which you need to write the conversion code regardless) can be put where it needs to be and kept out of all of the call sites. You could then propose a “conversion” feature to Swift that would allow explicit conversions:<br></p><p>try funcThatThrowsAnErrorThatMustBeTranslatedItoMyPublishedError() as MyError<br></p><p>This could call the conversion initializers.<br></p><p>-David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/44586fce/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 21, 2015 at 02:00:00pm</p></header><div class="content"><p>Thanks for continuing the discussion David.<br></p><p>&gt; On Dec 21, 2015, at 1:30 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; I’m just going to interject a few thoughts in here.<br>&gt; <br>&gt;&gt; On Dec 21, 2015, at 6:36 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi David,<br>&gt;&gt; <br>&gt;&gt; (my paraphrase: pattern matching is great and solves more of my concerns than I originally realized.) <br>&gt; <br>&gt; Awesome!<br>&gt; <br>&gt;&gt; I would also like to comment that there are some interesting related ideas for enhancing enums in the &quot;[Pitch] Use enums as enum underlying types” thread.  They don’t directly impact the proposal but could make such use cases even more convenient if they are pursued independently.<br>&gt; <br>&gt; I’m not sure I really like any of those proposals, but feedback for those is better on that thread, and I’ve only taken a cursory look at them.<br></p><p>Sure, just wanted to mention them.  I’m not sure whether I like any of them either - even the ones I have posted.  I do think they are interesting to think about but I am not sure whether they are good ideas or not.<br></p><p>&gt; <br>&gt;&gt; The other concern I have is still valid, but I think a relatively straightforward solution is possible.<br>&gt;&gt; <br>&gt;&gt; (my paraphrase: Converting from an inner-error to a publicly exposed error is tedious, boilerplate code.)<br>&gt; <br>&gt; Maybe. I think that depends on the assumption that you do nothing other than convert the inner error to a published error. Also, it assumes that all “recoverable” inner errors stay “recoverable” outer errors.<br>&gt; <br>&gt; I tend to use a lot of telemetry markers and assertions within my code, so it’s not a one-liner conversion.<br>&gt; <br>&gt; do {<br>&gt;     try some.implementation.detail.throwing.api()<br>&gt; }<br>&gt; catch {<br>&gt;     // what happens here?<br>&gt; }<br>&gt; <br>&gt; I actually think there are various options of what to do at this place:<br>&gt; <br>&gt; Simply propagate the error out (basically untyped errors)<br>&gt; Wrap the error (still exposes the internal implementation details)<br>&gt; Convert the error to a published error type<br>&gt; Promote the error to a non-recoverable error (e.g. fatalError())<br>&gt; <br>&gt; All of these can have additional code in place, such as telemetry/logging or debug assertions. While it might be the case that people simply want to wrap an error, can we say that is the safe way to deal with the errors? I’m not sure I’m willing to make that statement.<br></p><p>I agree.  I am proposing a solution to reduce boilerplate where either option 2 or 3 is the right thing to do.  Obviously if you need to do something more complex you do need to handle the error, in which case it is not boilerplate.  The suggestion of implicit conversion would not prevent you from doing this.<br></p><p>Please note: sometimes option 2 exposes implementation details but not necessarily.  The example I discussed was describing a scenario where a library has a family of possible errors it publishes as part of its API contract and two (or more) different ones may be generated by the same function.<br></p><p>&gt; <br>&gt; I, obviously, recommend against doing options #1 and #2 above. I’ll talk about conversion below. And I believe promotion would look something like this:<br>&gt; <br>&gt; guard ((try? some.implementation.detail.throwing.api()) != nil) else { fatalError(&quot;bad mojo!&quot;) }<br>&gt; <br>&gt; Or if I want the error:<br>&gt; <br>&gt; do {<br>&gt;     try some.implementation.detail.throwing.api()<br>&gt; }<br>&gt; catch {<br>&gt;     Telemetry.LogFatalIssue(error)<br>&gt;     fatalError(&quot;bad mojo!&quot;)<br>&gt; }<br>&gt; <br>&gt; In an ideal world, I would also like to be able to do something like this:<br>&gt; <br>&gt; guard try some.implementation.detail.throwing.api() else {<br>&gt;     Telemetry.LogFatalIssue(error)<br>&gt;     fatalError(&quot;bad mojo!&quot;)    <br>&gt; }<br>&gt; <br>&gt; But that’s a syntax that’s out-of-scope for this proposal as well.<br>&gt; <br>&gt;&gt; This is the problem that `From` addresses in Rust.  Swift is not Rust and our solution will look different.  The point is that this is a problem and it can and has been solved.<br>&gt;&gt; <br>&gt;&gt; My suggestion is that we should allow implicit conversion during error propagation.  If the published error type has one and only one non-failable, non-throwing initializer that takes a single argument of the type that is thrown (including enum case initializers with a single associated value of the thrown type) that initializer is used to implicitly convert to the published error type.  This conversion could be accomplished by synthesizing the necessary boilerplate or by some other means.<br>&gt;&gt; <br>&gt;&gt; Now we have:<br>&gt;&gt; <br>&gt;&gt; func functionThatCallsUnderlingyingThrows(_ whichError: Bool) throws MyPublishedError {<br>&gt;&gt;         try funcThatThrowsAnErrorThatMustBeTranslatedIntoMyPublishedError()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This looks as it should.  We don’t pay a price of boilerplate for carefully designing the errors we expose in our API contract.  This also handles automatic wrapping of errors where that is appropriate.<br>&gt; <br>&gt; I would argue against implicit conversion. Again, this is about consistency with the language. Also, Rust is using it’s macro system to generate the code; it’s not actually doing implicit conversions either.<br></p><p>I understand that Rust is not doing implicit conversions, but the effect for the user is pretty much the same.  The try macro is converting the underlying error to the type that can be propagated.  As I stated, Swift is not Rust and deserves a different solution.  <br></p><p>Nevertheless, that does not minimize the need to solve the problem.  I maintain that the problem solved by the try macro is a significant one that is not addressed by the current proposal.  I would really like to see it addressed one way or another.<br></p><p>&gt; <br>&gt; You could make it “nicer” by doing something like this:<br>&gt; <br>&gt; try MyError.convertFrom(try funcThatThrowsAnErrorThatMustBeTranslatedItoMyPublishedError())<br></p><p>Can you elaborate on how you think this would work?  If funcThatThrowsAnErrorThatMustBeTranslatedItoMyPublishedError actually throws it will be propagated to the next enclosing catch clause.  MyError.convertFrom will not have a chance to do anything with it.<br></p><p>&gt; <br>&gt; All of the “boiler-plate” code (which you need to write the conversion code regardless) can be put where it needs to be and kept out of all of the call sites. You could then propose a “conversion” feature to Swift that would allow explicit conversions:<br>&gt; <br>&gt; try funcThatThrowsAnErrorThatMustBeTranslatedItoMyPublishedError() as MyError<br>&gt; <br>&gt; This could call the conversion initializers.<br>&gt; <br></p><p>This would be casting the return value, not the error value.  Again, the error would be propagated to the next enclosing catch block.<br></p><p>I would probably be ok with the need to *explicitly* declare a conversion like this at the call site if that were possible (although I would want to consider concrete examples).  It just isn’t possible in the language today so 1) it’s hard to know exactly what it would look like and 2) it shouldn’t be part of the discussion unless we are considering adding something specific to the proposal.<br></p><p>Are you willing to explore adding *explicit* syntax to convert thrown errors to your proposal?  That seems like it might be a reasonable compromise between implicit conversions and manual boilerplate.  <br></p><p>I still prefer implicit conversions in this case and believe the value they bring to the table far outweighs their cost.  We are not talking about implicit conversion of arbitrary expressions here.  We are talking about implicit conversion specifically at the time of error propagation *from* the explicitly stated error type in throwing functions that are called *to* the explicitly stated error type in the calling function *if* an eligible initializer exists.  <br></p><p>This is a pretty narrow case with pretty obvious results IMO.  And it only kicks in if the underlying error is propagated out of the function so you still have the ability to catch it and log it, suppress it, convert to fatalError(), etc if you need to do that.<br></p><p>Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/9d1be277/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 21, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; I understand that Rust is not doing implicit conversions, but the effect for the user is pretty much the same.  The try macro is converting the underlying error to the type that can be propagated.  As I stated, Swift is not Rust and deserves a different solution.  <br>&gt; <br>&gt; Nevertheless, that does not minimize the need to solve the problem.  I maintain that the problem solved by the try macro is a significant one that is not addressed by the current proposal.  I would really like to see it addressed one way or another.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; You could make it “nicer” by doing something like this:<br>&gt;&gt; <br>&gt;&gt; try MyError.convertFrom(try funcThatThrowsAnErrorThatMustBeTranslatedItoMyPublishedError())<br>&gt; <br>&gt; Can you elaborate on how you think this would work?  If funcThatThrowsAnErrorThatMustBeTranslatedItoMyPublishedError actually throws it will be propagated to the next enclosing catch clause.  MyError.convertFrom will not have a chance to do anything with it.<br></p><p>Here’s a full playground example (I’ve annotated in comments where the type of error could be described):<br></p><p>enum InternalError: ErrorType {<br>    case Internal(value: Int)<br>}<br></p><p>enum PublishedError: ErrorType {<br>    static func from&lt;T&gt;(@autoclosure fn: () throws -&gt; T) throws -&gt; T {<br>        do {<br>            return try fn()<br>        }<br>        catch InternalError.Internal(let value) {<br>            throw PublishedError.Converted(value: value)<br>        }<br>        catch {<br>            fatalError(&quot;unsupported conversion&quot;)<br>        }<br>    }<br>    <br>    case Converted(value: Int)<br>}<br></p><p><br>func example() {<br></p><p>    func bad(value: Int) throws /* InternalError */ -&gt; Int {<br>        if value % 2 == 0 { throw InternalError.Internal(value: value) }<br>        return value<br>    }<br></p><p>    func verbose(value: Int) throws /* PublishedError */ -&gt; Int {<br>        do {<br>            return try bad(value)<br>        }<br>        catch InternalError.Internal(let value) {<br>            throw PublishedError.Converted(value: value)<br>        }<br>        catch {<br>            fatalError(&quot;unsupported conversion&quot;)<br>        }<br>    }<br>    <br>    func convert(value: Int) throws /* PublishedError */ -&gt; Int {<br>        return try PublishedError.from(try bad(value))<br>    }<br>    <br>    do {<br>        let r1 = try verbose(11)<br>        print(&quot;verbose: \(r1)&quot;)<br>        <br>        let r2 = try convert(9)<br>        print(&quot;converted: \(r2)&quot;)<br>    }<br>    catch {<br>        print(&quot;error: \(error)&quot;)<br>    }<br></p><p>}<br></p><p>example()<br></p><p><br>As you can see, the “verbose()” and the “from()” conversion are basically the same implementation. What I’m saying is that I believe you can simply do the explicit conversion yourself without much fanfare (compare the verbose() and convert() implementations).<br></p><p>In the implementation of PublishedError.from() you can use Swift’s pattern matching to do all of your conversions in a single place. Note that where the implementation of “from” is at doesn’t matter, it could be on another type or a free function, whatever.<br></p><p>&gt; Are you willing to explore adding *explicit* syntax to convert thrown errors to your proposal?  That seems like it might be a reasonable compromise between implicit conversions and manual boilerplate.  <br></p><p>The only boiler plate I’m seeing is the explicit conversion call: PublishedError.from(try bad(value))<br></p><p>Am I misunderstanding something? <br></p><p>To me, this would be much more confusing:<br></p><p>    func convert(value: Int) throws /* PublishedError */ -&gt; Int {<br>        return try bad(value)     /* implicit conversion from InternalError -&gt; PublishedError */<br>    }<br></p><p>If there were implicit type conversions, this would have to be something that Swift supported all up. I’d be very hesitant to make this work for only errors. For example, how does implicit conversion work if we can later extend this to async behaviors? Do we have special conversions that can take an async error make it a synchronous error? How about vice-versa?<br></p><p>I guess I wouldn’t want to go further than having explicit conversions until we better understood all of those answers and how implicit type conversion would work in Swift generally. If I recall, Swift had implicit type conversion in the early versions, and it has been removed in most places. <br></p><p>-David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/5f4b8346/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 22, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 3:00 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; I understand that Rust is not doing implicit conversions, but the effect for the user is pretty much the same.  The try macro is converting the underlying error to the type that can be propagated.  As I stated, Swift is not Rust and deserves a different solution.  <br>&gt;&gt; <br>&gt;&gt; Nevertheless, that does not minimize the need to solve the problem.  I maintain that the problem solved by the try macro is a significant one that is not addressed by the current proposal.  I would really like to see it addressed one way or another.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You could make it “nicer” by doing something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; try MyError.convertFrom(try funcThatThrowsAnErrorThatMustBeTranslatedItoMyPublishedError())<br>&gt;&gt; <br>&gt;&gt; Can you elaborate on how you think this would work?  If funcThatThrowsAnErrorThatMustBeTranslatedItoMyPublishedError actually throws it will be propagated to the next enclosing catch clause.  MyError.convertFrom will not have a chance to do anything with it.<br>&gt; <br>&gt; Here’s a full playground example (I’ve annotated in comments where the type of error could be described):<br>&gt; <br>&gt; enum InternalError: ErrorType {<br>&gt;     case Internal(value: Int)<br>&gt; }<br>&gt; <br>&gt; enum PublishedError: ErrorType {<br>&gt;     static func from&lt;T&gt;(@autoclosure fn: () throws -&gt; T) throws -&gt; T {<br>&gt;         do {<br>&gt;             return try fn()<br>&gt;         }<br>&gt;         catch InternalError.Internal(let value) {<br>&gt;             throw PublishedError.Converted(value: value)<br>&gt;         }<br>&gt;         catch {<br>&gt;             fatalError(&quot;unsupported conversion&quot;)<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     case Converted(value: Int)<br>&gt; }<br>&gt; <br>&gt; <br>&gt; func example() {<br>&gt; <br>&gt;     func bad(value: Int) throws /* InternalError */ -&gt; Int {<br>&gt;         if value % 2 == 0 { throw InternalError.Internal(value: value) }<br>&gt;         return value<br>&gt;     }<br>&gt; <br>&gt;     func verbose(value: Int) throws /* PublishedError */ -&gt; Int {<br>&gt;         do {<br>&gt;             return try bad(value)<br>&gt;         }<br>&gt;         catch InternalError.Internal(let value) {<br>&gt;             throw PublishedError.Converted(value: value)<br>&gt;         }<br>&gt;         catch {<br>&gt;             fatalError(&quot;unsupported conversion&quot;)<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     func convert(value: Int) throws /* PublishedError */ -&gt; Int {<br>&gt;         return try PublishedError.from(try bad(value))<br>&gt;     }<br>&gt;     <br>&gt;     do {<br>&gt;         let r1 = try verbose(11)<br>&gt;         print(&quot;verbose: \(r1)&quot;)<br>&gt;         <br>&gt;         let r2 = try convert(9)<br>&gt;         print(&quot;converted: \(r2)&quot;)<br>&gt;     }<br>&gt;     catch {<br>&gt;         print(&quot;error: \(error)&quot;)<br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; example()<br>&gt; <br>&gt; <br>&gt; As you can see, the “verbose()” and the “from()” conversion are basically the same implementation. What I’m saying is that I believe you can simply do the explicit conversion yourself without much fanfare (compare the verbose() and convert() implementations).<br>&gt; <br>&gt; In the implementation of PublishedError.from() you can use Swift’s pattern matching to do all of your conversions in a single place. Note that where the implementation of “from” is at doesn’t matter, it could be on another type or a free function, whatever.<br></p><p>That is a pretty clever use of @autoclosure!  It can be made even be made even more concise with typed errors and a top level conversion function:<br></p><p>@protocol ErrorTypeConvertible {<br>	// implementations will have to include a default clause which is either going to call fatalError <br>        // or be an ‘UnknownError’ case in the enum<br>	init(underlyingError: ErrorType) { … }<br>        // or<br>	init&lt;E: ErrorType&gt;(underlyingError: E) { … } <br>}<br></p><p>func from&lt;T/*, Internal, Published: ErrorTypeConvertible*/&gt;(@autoclosure fn: () throws /* Internal */ -&gt; T) throws /* Published */ -&gt; T {<br>    do {<br>        return try fn()<br>    }<br>    catch let error as Internal {<br>        return Published(underlyingError: error)<br>    }<br>   // hopefully the compiler is able to detect that this is <br>}<br></p><p>    func convert(value: Int) throws /* PublishedError */ -&gt; Int {<br>        return try from(try bad(value))<br>    }<br></p><p>This addresses my largest concern which is cluttering up the control flow.  The additional noise of an extra ‘try&#39; and a call to ‘from’ isn’t great, but it is tolerable, at least initially (I think we would eventually learn that it is just noise and get rid of it).  <br></p><p>Unfortunately, I don’t see a way to make it safe.  You had to use fatalError in a default case to make it work.  An alternative would have been to include an ‘UnknownError’ case in ‘PublishedError’.  Neither is not an acceptable solution IMO.<br></p><p>If you can make PublishedError.from safe without requiring an ‘UnknownError’ case it will also be possible to make a top-level ‘from’ safe.  That would be acceptable, but I don’t believe it’s possible in the current language and I’m not aware of any proposed changes that would make it possible.<br></p><p>This top level `from` example also brings up a couple of points that I don’t recall being addressed in your proposal.  Specifically, the interaction of typed errors with generics and type inferrence.  The obvious thing to do is allow them to behave the same as any other part of the return type.  If that is what you expect and it is not already stated, you should update the proposal to specify that.  If you expect something different you definitely need to specify what that is.  An implementer will need to know how this should be handled.<br></p><p>I still consider this to be an unresolved concern.  I would like to have a safe way to perform error conversion during propagation without cluttering up my control flow and seriously degrading readability.  This is a problem that can and has been solved in other languages.  IMO it is should be considered an essential element of a proposal introducing typed errors.<br></p><p>Matthew<br></p><p>&gt; <br>&gt;&gt; Are you willing to explore adding *explicit* syntax to convert thrown errors to your proposal?  That seems like it might be a reasonable compromise between implicit conversions and manual boilerplate.  <br>&gt; <br>&gt; The only boiler plate I’m seeing is the explicit conversion call: PublishedError.from(try bad(value))<br>&gt; <br>&gt; Am I misunderstanding something? <br>&gt; <br>&gt; To me, this would be much more confusing:<br>&gt; <br>&gt;     func convert(value: Int) throws /* PublishedError */ -&gt; Int {<br>&gt;         return try bad(value)     /* implicit conversion from InternalError -&gt; PublishedError */<br>&gt;     }<br>&gt; <br>&gt; If there were implicit type conversions, this would have to be something that Swift supported all up. I’d be very hesitant to make this work for only errors. For example, how does implicit conversion work if we can later extend this to async behaviors? Do we have special conversions that can take an async error make it a synchronous error? How about vice-versa?<br>&gt; <br>&gt; I guess I wouldn’t want to go further than having explicit conversions until we better understood all of those answers and how implicit type conversion would work in Swift generally. If I recall, Swift had implicit type conversion in the early versions, and it has been removed in most places. <br>&gt; <br>&gt; -David<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/d7006ad4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 22, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 9:50 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; Unfortunately, I don’t see a way to make it safe.  You had to use fatalError in a default case to make it work.  An alternative would have been to include an ‘UnknownError’ case in ‘PublishedError’.  Neither is not an acceptable solution IMO.<br></p><p>I need the fatalError() because the sample is a working example in Swift today. If we had typed errors, this would simply work:<br></p><p>   static func from&lt;T&gt;(@autoclosure fn: () throws InternalError -&gt; T) throws PublishedError -&gt; T {<br>        do {<br>            return try fn()<br>        }<br>        catch InternalError.Internal(let value) {<br>            throw PublishedError.Converted(value: value)<br>        }<br>    }<br></p><p>This states that the only closure accepted is one that throws an InternalError. <br></p><p>&gt; This top level `from` example also brings up a couple of points that I don’t recall being addressed in your proposal.  Specifically, the interaction of typed errors with generics and type inferrence.<br></p><p>I call out in the proposal that errors work with generics no differently than other types.<br></p><p>&gt; I still consider this to be an unresolved concern.  I would like to have a safe way to perform error conversion during propagation without cluttering up my control flow and seriously degrading readability.  This is a problem that can and has been solved in other languages.  IMO it is should be considered an essential element of a proposal introducing typed errors.<br></p><p>When Swift has a macro as powerful as Rust, then this is a solved problem as well. However, Swift isn’t there yet. <br></p><p>-David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/49982a05/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 22, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 12:09 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 9:50 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Unfortunately, I don’t see a way to make it safe.  You had to use fatalError in a default case to make it work.  An alternative would have been to include an ‘UnknownError’ case in ‘PublishedError’.  Neither is not an acceptable solution IMO.<br>&gt; <br>&gt; I need the fatalError() because the sample is a working example in Swift today. If we had typed errors, this would simply work:<br>&gt; <br>&gt;    static func from&lt;T&gt;(@autoclosure fn: () throws InternalError -&gt; T) throws PublishedError -&gt; T {<br>&gt;         do {<br>&gt;             return try fn()<br>&gt;         }<br>&gt;         catch InternalError.Internal(let value) {<br>&gt;             throw PublishedError.Converted(value: value)<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt; This states that the only closure accepted is one that throws an InternalError. <br></p><p>Ok, so you suggest writing a specific overload for each combination of error types that are convertible.  Got it.  Not sure why I didn’t think of overloads.  I was too focused on a general try function dispatching to an initializer.<br></p><p>That is indeed safe and I can live with it.  Thanks for taking the time to work through these examples with me and help to identify patterns that address my concerns!<br></p><p>I still find it unfortunate that this is in the realm of a pattern though.  IMO it would be much better if it was part of the common Swift vocabulary, either as a language feature or a library function but that isn’t possible as a generic implementation isn’t possible.<br></p><p>&gt; <br>&gt;&gt; This top level `from` example also brings up a couple of points that I don’t recall being addressed in your proposal.  Specifically, the interaction of typed errors with generics and type inferrence.<br>&gt; <br>&gt; I call out in the proposal that errors work with generics no differently than other types.<br></p><p>Great, I must have missed that.<br></p><p>&gt; <br>&gt;&gt; I still consider this to be an unresolved concern.  I would like to have a safe way to perform error conversion during propagation without cluttering up my control flow and seriously degrading readability.  This is a problem that can and has been solved in other languages.  IMO it is should be considered an essential element of a proposal introducing typed errors.<br>&gt; <br>&gt; When Swift has a macro as powerful as Rust, then this is a solved problem as well. However, Swift isn’t there yet. <br></p><p>I would prefer a solution to this that didn’t require macros which would fit better in Swift.  This feature is buried in the `try!` macro in Rust as Rust doesn’t have built-in language level error handling support.  <br></p><p>Swift already has `try` built into the language.  IMO it would be better to have it handled by the built-in language level error handling support in Swift.  That seems like the more “Swifty” approach.  We could have a Swift macro `tryAndConvert` or something, but that seems inelegant.<br></p><p>We’ve gone back and forth on this quite a bit but nobody else has chimed in.  I’m curious to hear what others thing.  I would love it if any lurkers would jump in and comment!<br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/9719bcd2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 23, 2015 at 06:00:00am</p></header><div class="content"><p>David&#39;s proposal looks good enough for me.<br></p><p>With regards to Matthew&#39;s worry of cluttering the code with conversion I&#39;d like to remark that this conversion code should only live on the border of your API (the facade), so it should probably not be too invasive to your business logic.<br></p><p>-Thorsten <br></p><p><br></p><p>&gt; Am 22.12.2015 um 20:08 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Dec 22, 2015, at 12:09 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 22, 2015, at 9:50 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unfortunately, I don’t see a way to make it safe.  You had to use fatalError in a default case to make it work.  An alternative would have been to include an ‘UnknownError’ case in ‘PublishedError’.  Neither is not an acceptable solution IMO.<br>&gt;&gt; <br>&gt;&gt; I need the fatalError() because the sample is a working example in Swift today. If we had typed errors, this would simply work:<br>&gt;&gt; <br>&gt;&gt;    static func from&lt;T&gt;(@autoclosure fn: () throws InternalError -&gt; T) throws PublishedError -&gt; T {<br>&gt;&gt;         do {<br>&gt;&gt;             return try fn()<br>&gt;&gt;         }<br>&gt;&gt;         catch InternalError.Internal(let value) {<br>&gt;&gt;             throw PublishedError.Converted(value: value)<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; This states that the only closure accepted is one that throws an InternalError. <br>&gt; <br>&gt; Ok, so you suggest writing a specific overload for each combination of error types that are convertible.  Got it.  Not sure why I didn’t think of overloads.  I was too focused on a general try function dispatching to an initializer.<br>&gt; <br>&gt; That is indeed safe and I can live with it.  Thanks for taking the time to work through these examples with me and help to identify patterns that address my concerns!<br>&gt; <br>&gt; I still find it unfortunate that this is in the realm of a pattern though.  IMO it would be much better if it was part of the common Swift vocabulary, either as a language feature or a library function but that isn’t possible as a generic implementation isn’t possible.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; This top level `from` example also brings up a couple of points that I don’t recall being addressed in your proposal.  Specifically, the interaction of typed errors with generics and type inferrence.<br>&gt;&gt; <br>&gt;&gt; I call out in the proposal that errors work with generics no differently than other types.<br>&gt; <br>&gt; Great, I must have missed that.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; I still consider this to be an unresolved concern.  I would like to have a safe way to perform error conversion during propagation without cluttering up my control flow and seriously degrading readability.  This is a problem that can and has been solved in other languages.  IMO it is should be considered an essential element of a proposal introducing typed errors.<br>&gt;&gt; <br>&gt;&gt; When Swift has a macro as powerful as Rust, then this is a solved problem as well. However, Swift isn’t there yet. <br>&gt; <br>&gt; I would prefer a solution to this that didn’t require macros which would fit better in Swift.  This feature is buried in the `try!` macro in Rust as Rust doesn’t have built-in language level error handling support.  <br>&gt; <br>&gt; Swift already has `try` built into the language.  IMO it would be better to have it handled by the built-in language level error handling support in Swift.  That seems like the more “Swifty” approach.  We could have a Swift macro `tryAndConvert` or something, but that seems inelegant.<br>&gt; <br>&gt; We’ve gone back and forth on this quite a bit but nobody else has chimed in.  I’m curious to hear what others thing.  I would love it if any lurkers would jump in and comment!<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/79953a72/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4002684831b0a89736f4837d2e60f66a?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>Pierre Monod-Broca</string> &lt;pierremonodbroca at gmail.com&gt;<p>December 23, 2015 at 11:00:00am</p></header><div class="content"><p>I agree, David&#39;s proposal looks good. <br></p><p>Matthew concerned are interesting, and I think David answered them well.<br></p><p>Pierre<br></p><p>&gt; Le 23 déc. 2015 à 06:58, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; David&#39;s proposal looks good enough for me.<br>&gt; <br>&gt; With regards to Matthew&#39;s worry of cluttering the code with conversion I&#39;d like to remark that this conversion code should only live on the border of your API (the facade), so it should probably not be too invasive to your business logic.<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Am 22.12.2015 um 20:08 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 22, 2015, at 12:09 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 22, 2015, at 9:50 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unfortunately, I don’t see a way to make it safe.  You had to use fatalError in a default case to make it work.  An alternative would have been to include an ‘UnknownError’ case in ‘PublishedError’.  Neither is not an acceptable solution IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I need the fatalError() because the sample is a working example in Swift today. If we had typed errors, this would simply work:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    static func from&lt;T&gt;(@autoclosure fn: () throws InternalError -&gt; T) throws PublishedError -&gt; T {<br>&gt;&gt;&gt;         do {<br>&gt;&gt;&gt;             return try fn()<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         catch InternalError.Internal(let value) {<br>&gt;&gt;&gt;             throw PublishedError.Converted(value: value)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This states that the only closure accepted is one that throws an InternalError. <br>&gt;&gt; <br>&gt;&gt; Ok, so you suggest writing a specific overload for each combination of error types that are convertible.  Got it.  Not sure why I didn’t think of overloads.  I was too focused on a general try function dispatching to an initializer.<br>&gt;&gt; <br>&gt;&gt; That is indeed safe and I can live with it.  Thanks for taking the time to work through these examples with me and help to identify patterns that address my concerns!<br>&gt;&gt; <br>&gt;&gt; I still find it unfortunate that this is in the realm of a pattern though.  IMO it would be much better if it was part of the common Swift vocabulary, either as a language feature or a library function but that isn’t possible as a generic implementation isn’t possible.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This top level `from` example also brings up a couple of points that I don’t recall being addressed in your proposal.  Specifically, the interaction of typed errors with generics and type inferrence.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I call out in the proposal that errors work with generics no differently than other types.<br>&gt;&gt; <br>&gt;&gt; Great, I must have missed that.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I still consider this to be an unresolved concern.  I would like to have a safe way to perform error conversion during propagation without cluttering up my control flow and seriously degrading readability.  This is a problem that can and has been solved in other languages.  IMO it is should be considered an essential element of a proposal introducing typed errors.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When Swift has a macro as powerful as Rust, then this is a solved problem as well. However, Swift isn’t there yet. <br>&gt;&gt; <br>&gt;&gt; I would prefer a solution to this that didn’t require macros which would fit better in Swift.  This feature is buried in the `try!` macro in Rust as Rust doesn’t have built-in language level error handling support.  <br>&gt;&gt; <br>&gt;&gt; Swift already has `try` built into the language.  IMO it would be better to have it handled by the built-in language level error handling support in Swift.  That seems like the more “Swifty” approach.  We could have a Swift macro `tryAndConvert` or something, but that seems inelegant.<br>&gt;&gt; <br>&gt;&gt; We’ve gone back and forth on this quite a bit but nobody else has chimed in.  I’m curious to hear what others thing.  I would love it if any lurkers would jump in and comment!<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/fb90d53d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/33536e304f2318595dbd6104fdb0bd4a?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>Alejandro Martinez</string> &lt;alexito4 at gmail.com&gt;<p>December 24, 2015 at 09:00:00am</p></header><div class="content"><p>Hi!<br>I&#39;ve been following the conversation closely so here are my 2c<br></p><p>TL;TR: +1<br></p><p>After proposing solutions for the concerns about conversions this is a clear +1. Overloading the conversion functions is how it works in Rust and I think is a good tradeoff, even without the magical &quot;try!&quot; That Rust has. Maybe we could explore something like that when Swift give us a macro like system. But for now I will be happy with this.<br></p><p>The most important thing to remember is that this changes will not affect people that prefers the untyped throws, as they can continue doing it like now. I think this is really important as will allow us to ignore typed errors when writing prototyping code, but it will give the option to improve the safety of our code when is time for that.<br></p><p>Thanks for the proposal and the interesting discussion.<br></p><p>Sent from my iPad<br></p><p>PS: i&#39;ve been playing on porting the example from Rust errors page to Swift. <br>http://alejandromp.com/blog/2015/12/23/rust-error-handling-swift-script/<br>Will be interesting to try it again with the changes from this proposal ;)<br></p><p>&gt; On 23 Dec 2015, at 05:58, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; David&#39;s proposal looks good enough for me.<br>&gt; <br>&gt; With regards to Matthew&#39;s worry of cluttering the code with conversion I&#39;d like to remark that this conversion code should only live on the border of your API (the facade), so it should probably not be too invasive to your business logic.<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Am 22.12.2015 um 20:08 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 22, 2015, at 12:09 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 22, 2015, at 9:50 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unfortunately, I don’t see a way to make it safe.  You had to use fatalError in a default case to make it work.  An alternative would have been to include an ‘UnknownError’ case in ‘PublishedError’.  Neither is not an acceptable solution IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I need the fatalError() because the sample is a working example in Swift today. If we had typed errors, this would simply work:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    static func from&lt;T&gt;(@autoclosure fn: () throws InternalError -&gt; T) throws PublishedError -&gt; T {<br>&gt;&gt;&gt;         do {<br>&gt;&gt;&gt;             return try fn()<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         catch InternalError.Internal(let value) {<br>&gt;&gt;&gt;             throw PublishedError.Converted(value: value)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This states that the only closure accepted is one that throws an InternalError. <br>&gt;&gt; <br>&gt;&gt; Ok, so you suggest writing a specific overload for each combination of error types that are convertible.  Got it.  Not sure why I didn’t think of overloads.  I was too focused on a general try function dispatching to an initializer.<br>&gt;&gt; <br>&gt;&gt; That is indeed safe and I can live with it.  Thanks for taking the time to work through these examples with me and help to identify patterns that address my concerns!<br>&gt;&gt; <br>&gt;&gt; I still find it unfortunate that this is in the realm of a pattern though.  IMO it would be much better if it was part of the common Swift vocabulary, either as a language feature or a library function but that isn’t possible as a generic implementation isn’t possible.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This top level `from` example also brings up a couple of points that I don’t recall being addressed in your proposal.  Specifically, the interaction of typed errors with generics and type inferrence.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I call out in the proposal that errors work with generics no differently than other types.<br>&gt;&gt; <br>&gt;&gt; Great, I must have missed that.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I still consider this to be an unresolved concern.  I would like to have a safe way to perform error conversion during propagation without cluttering up my control flow and seriously degrading readability.  This is a problem that can and has been solved in other languages.  IMO it is should be considered an essential element of a proposal introducing typed errors.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When Swift has a macro as powerful as Rust, then this is a solved problem as well. However, Swift isn’t there yet. <br>&gt;&gt; <br>&gt;&gt; I would prefer a solution to this that didn’t require macros which would fit better in Swift.  This feature is buried in the `try!` macro in Rust as Rust doesn’t have built-in language level error handling support.  <br>&gt;&gt; <br>&gt;&gt; Swift already has `try` built into the language.  IMO it would be better to have it handled by the built-in language level error handling support in Swift.  That seems like the more “Swifty” approach.  We could have a Swift macro `tryAndConvert` or something, but that seems inelegant.<br>&gt;&gt; <br>&gt;&gt; We’ve gone back and forth on this quite a bit but nobody else has chimed in.  I’m curious to hear what others thing.  I would love it if any lurkers would jump in and comment!<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151224/4414087a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 24, 2015 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Dec 24, 2015, at 3:24 AM, Alejandro Martinez &lt;alexito4 at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hi!<br>&gt; I&#39;ve been following the conversation closely so here are my 2c<br>&gt; <br>&gt; TL;TR: +1<br>&gt; <br>&gt; After proposing solutions for the concerns about conversions this is a clear +1. Overloading the conversion functions is how it works in Rust and I think is a good tradeoff, even without the magical &quot;try!&quot; That Rust has. Maybe we could explore something like that when Swift give us a macro like system. But for now I will be happy with this.<br></p><p>Rust actually uses a trait (the Rust equivalent of a protocol) to do this.  It isn&#39;t possible in Swift because protocols cannot have type parameters like traits can in Rust and there is no other mechanism in Swift with equivalent capability.  <br></p><p>This means that Rust&#39;s From mechanism is generic and is part of the standard library.  It is part of the common vocabulary of Rust programmers.  This is a significant advantage over a solution that uses ad-hoc overloading relying on a convention that is likely to vary between teams.  Some teams probably won&#39;t even be aware of the possibility to adopt such a convention if it isn&#39;t part of our common vocabulary.<br></p><p>Here is what the Rust documentation has to say about this:<br></p><p>&gt; From is very useful because it gives us a generic way to talk about conversion from a particular type T to some other type (in this case, “some other type” is the subject of the impl, or Self). The crux of From is the set of implementations provided by the standard library.<br></p><p><br>Swift is not Rust and I personally believe a different approach to handling error translation during propagation would be more Swifty for a number of reasons.  I believe that would be the case even if we had macros and protocols with type parameters.  I am continuing to think about this and will probably submit a proposal if / when David&#39;s proposal is accepted.<br></p><p>IMO it is very important that we have a standard mechanism for translating errors during propagation.<br></p><p><br>&gt; <br>&gt; The most important thing to remember is that this changes will not affect people that prefers the untyped throws, as they can continue doing it like now. I think this is really important as will allow us to ignore typed errors when writing prototyping code, but it will give the option to improve the safety of our code when is time for that.<br>&gt; <br>&gt; Thanks for the proposal and the interesting discussion.<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; PS: i&#39;ve been playing on porting the example from Rust errors page to Swift. <br>&gt; http://alejandromp.com/blog/2015/12/23/rust-error-handling-swift-script/<br>&gt; Will be interesting to try it again with the changes from this proposal ;)<br>&gt; <br>&gt;&gt; On 23 Dec 2015, at 05:58, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; David&#39;s proposal looks good enough for me.<br>&gt;&gt; <br>&gt;&gt; With regards to Matthew&#39;s worry of cluttering the code with conversion I&#39;d like to remark that this conversion code should only live on the border of your API (the facade), so it should probably not be too invasive to your business logic.<br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 22.12.2015 um 20:08 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 12:09 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 9:50 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Unfortunately, I don’t see a way to make it safe.  You had to use fatalError in a default case to make it work.  An alternative would have been to include an ‘UnknownError’ case in ‘PublishedError’.  Neither is not an acceptable solution IMO.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I need the fatalError() because the sample is a working example in Swift today. If we had typed errors, this would simply work:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    static func from&lt;T&gt;(@autoclosure fn: () throws InternalError -&gt; T) throws PublishedError -&gt; T {<br>&gt;&gt;&gt;&gt;         do {<br>&gt;&gt;&gt;&gt;             return try fn()<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         catch InternalError.Internal(let value) {<br>&gt;&gt;&gt;&gt;             throw PublishedError.Converted(value: value)<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This states that the only closure accepted is one that throws an InternalError. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ok, so you suggest writing a specific overload for each combination of error types that are convertible.  Got it.  Not sure why I didn’t think of overloads.  I was too focused on a general try function dispatching to an initializer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is indeed safe and I can live with it.  Thanks for taking the time to work through these examples with me and help to identify patterns that address my concerns!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I still find it unfortunate that this is in the realm of a pattern though.  IMO it would be much better if it was part of the common Swift vocabulary, either as a language feature or a library function but that isn’t possible as a generic implementation isn’t possible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This top level `from` example also brings up a couple of points that I don’t recall being addressed in your proposal.  Specifically, the interaction of typed errors with generics and type inferrence.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I call out in the proposal that errors work with generics no differently than other types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Great, I must have missed that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I still consider this to be an unresolved concern.  I would like to have a safe way to perform error conversion during propagation without cluttering up my control flow and seriously degrading readability.  This is a problem that can and has been solved in other languages.  IMO it is should be considered an essential element of a proposal introducing typed errors.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When Swift has a macro as powerful as Rust, then this is a solved problem as well. However, Swift isn’t there yet. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would prefer a solution to this that didn’t require macros which would fit better in Swift.  This feature is buried in the `try!` macro in Rust as Rust doesn’t have built-in language level error handling support.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift already has `try` built into the language.  IMO it would be better to have it handled by the built-in language level error handling support in Swift.  That seems like the more “Swifty” approach.  We could have a Swift macro `tryAndConvert` or something, but that seems inelegant.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We’ve gone back and forth on this quite a bit but nobody else has chimed in.  I’m curious to hear what others thing.  I would love it if any lurkers would jump in and comment!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151224/099e5bf9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/33536e304f2318595dbd6104fdb0bd4a?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>Alejandro Martinez</string> &lt;alexito4 at gmail.com&gt;<p>December 25, 2015 at 01:00:00am</p></header><div class="content"><p>Absolutely agree Matthew.<br>My point was that if this is the temporary tradeoff that we have to support for me is worth it. Having typed throws looks like a great next step to improving the current error system.<br>Curious to see your ideas about that ;)<br></p><p>Cheers,<br></p><p>Sent from my iPad<br></p><p>&gt; On 24 Dec 2015, at 14:26, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Dec 24, 2015, at 3:24 AM, Alejandro Martinez &lt;alexito4 at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi!<br>&gt;&gt; I&#39;ve been following the conversation closely so here are my 2c<br>&gt;&gt; <br>&gt;&gt; TL;TR: +1<br>&gt;&gt; <br>&gt;&gt; After proposing solutions for the concerns about conversions this is a clear +1. Overloading the conversion functions is how it works in Rust and I think is a good tradeoff, even without the magical &quot;try!&quot; That Rust has. Maybe we could explore something like that when Swift give us a macro like system. But for now I will be happy with this.<br>&gt; <br>&gt; Rust actually uses a trait (the Rust equivalent of a protocol) to do this.  It isn&#39;t possible in Swift because protocols cannot have type parameters like traits can in Rust and there is no other mechanism in Swift with equivalent capability.  <br>&gt; <br>&gt; This means that Rust&#39;s From mechanism is generic and is part of the standard library.  It is part of the common vocabulary of Rust programmers.  This is a significant advantage over a solution that uses ad-hoc overloading relying on a convention that is likely to vary between teams.  Some teams probably won&#39;t even be aware of the possibility to adopt such a convention if it isn&#39;t part of our common vocabulary.<br>&gt; <br>&gt; Here is what the Rust documentation has to say about this:<br>&gt; <br>&gt;&gt; From is very useful because it gives us a generic way to talk about conversion from a particular type T to some other type (in this case, “some other type” is the subject of the impl, or Self). The crux of From is the set of implementations provided by the standard library.<br>&gt; <br>&gt; <br>&gt; Swift is not Rust and I personally believe a different approach to handling error translation during propagation would be more Swifty for a number of reasons.  I believe that would be the case even if we had macros and protocols with type parameters.  I am continuing to think about this and will probably submit a proposal if / when David&#39;s proposal is accepted.<br>&gt; <br>&gt; IMO it is very important that we have a standard mechanism for translating errors during propagation.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; The most important thing to remember is that this changes will not affect people that prefers the untyped throws, as they can continue doing it like now. I think this is really important as will allow us to ignore typed errors when writing prototyping code, but it will give the option to improve the safety of our code when is time for that.<br>&gt;&gt; <br>&gt;&gt; Thanks for the proposal and the interesting discussion.<br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; PS: i&#39;ve been playing on porting the example from Rust errors page to Swift. <br>&gt;&gt; http://alejandromp.com/blog/2015/12/23/rust-error-handling-swift-script/<br>&gt;&gt; Will be interesting to try it again with the changes from this proposal ;)<br>&gt;&gt; <br>&gt;&gt;&gt; On 23 Dec 2015, at 05:58, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; David&#39;s proposal looks good enough for me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With regards to Matthew&#39;s worry of cluttering the code with conversion I&#39;d like to remark that this conversion code should only live on the border of your API (the facade), so it should probably not be too invasive to your business logic.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 22.12.2015 um 20:08 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 12:09 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 9:50 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Unfortunately, I don’t see a way to make it safe.  You had to use fatalError in a default case to make it work.  An alternative would have been to include an ‘UnknownError’ case in ‘PublishedError’.  Neither is not an acceptable solution IMO.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I need the fatalError() because the sample is a working example in Swift today. If we had typed errors, this would simply work:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    static func from&lt;T&gt;(@autoclosure fn: () throws InternalError -&gt; T) throws PublishedError -&gt; T {<br>&gt;&gt;&gt;&gt;&gt;         do {<br>&gt;&gt;&gt;&gt;&gt;             return try fn()<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;         catch InternalError.Internal(let value) {<br>&gt;&gt;&gt;&gt;&gt;             throw PublishedError.Converted(value: value)<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This states that the only closure accepted is one that throws an InternalError. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ok, so you suggest writing a specific overload for each combination of error types that are convertible.  Got it.  Not sure why I didn’t think of overloads.  I was too focused on a general try function dispatching to an initializer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That is indeed safe and I can live with it.  Thanks for taking the time to work through these examples with me and help to identify patterns that address my concerns!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I still find it unfortunate that this is in the realm of a pattern though.  IMO it would be much better if it was part of the common Swift vocabulary, either as a language feature or a library function but that isn’t possible as a generic implementation isn’t possible.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This top level `from` example also brings up a couple of points that I don’t recall being addressed in your proposal.  Specifically, the interaction of typed errors with generics and type inferrence.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I call out in the proposal that errors work with generics no differently than other types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Great, I must have missed that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I still consider this to be an unresolved concern.  I would like to have a safe way to perform error conversion during propagation without cluttering up my control flow and seriously degrading readability.  This is a problem that can and has been solved in other languages.  IMO it is should be considered an essential element of a proposal introducing typed errors.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; When Swift has a macro as powerful as Rust, then this is a solved problem as well. However, Swift isn’t there yet. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would prefer a solution to this that didn’t require macros which would fit better in Swift.  This feature is buried in the `try!` macro in Rust as Rust doesn’t have built-in language level error handling support.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift already has `try` built into the language.  IMO it would be better to have it handled by the built-in language level error handling support in Swift.  That seems like the more “Swifty” approach.  We could have a Swift macro `tryAndConvert` or something, but that seems inelegant.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We’ve gone back and forth on this quite a bit but nobody else has chimed in.  I’m curious to hear what others thing.  I would love it if any lurkers would jump in and comment!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151225/d7c73f92/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 24, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 24, 2015, at 7:51 PM, Alejandro Martinez &lt;alexito4 at gmail.com&gt; wrote:<br>&gt; <br>&gt; Absolutely agree Matthew.<br>&gt; My point was that if this is the temporary tradeoff that we have to support for me is worth it. Having typed throws looks like a great next step to improving the current error system.<br>&gt; Curious to see your ideas about that ;)<br>&gt; <br></p><p>Agree with you on that.  I think a proposal for proper error conversion during propagation could actually follow this one pretty quickly so we may not have to wait too long.  I am hoping it is possible both could make it in the Swift 3 timeframe if both are accepted.<br></p><p><br>&gt; Cheers,<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On 24 Dec 2015, at 14:26, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On Dec 24, 2015, at 3:24 AM, Alejandro Martinez &lt;alexito4 at gmail.com &lt;mailto:alexito4 at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Hi!<br>&gt;&gt;&gt; I&#39;ve been following the conversation closely so here are my 2c<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; TL;TR: +1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; After proposing solutions for the concerns about conversions this is a clear +1. Overloading the conversion functions is how it works in Rust and I think is a good tradeoff, even without the magical &quot;try!&quot; That Rust has. Maybe we could explore something like that when Swift give us a macro like system. But for now I will be happy with this.<br>&gt;&gt; <br>&gt;&gt; Rust actually uses a trait (the Rust equivalent of a protocol) to do this.  It isn&#39;t possible in Swift because protocols cannot have type parameters like traits can in Rust and there is no other mechanism in Swift with equivalent capability.  <br>&gt;&gt; <br>&gt;&gt; This means that Rust&#39;s From mechanism is generic and is part of the standard library.  It is part of the common vocabulary of Rust programmers.  This is a significant advantage over a solution that uses ad-hoc overloading relying on a convention that is likely to vary between teams.  Some teams probably won&#39;t even be aware of the possibility to adopt such a convention if it isn&#39;t part of our common vocabulary.<br>&gt;&gt; <br>&gt;&gt; Here is what the Rust documentation has to say about this:<br>&gt;&gt; <br>&gt;&gt;&gt; From is very useful because it gives us a generic way to talk about conversion from a particular type T to some other type (in this case, “some other type” is the subject of the impl, or Self). The crux of From is the set of implementations provided by the standard library &lt;https://doc.rust-lang.org/std/convert/trait.From.html&gt;.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Swift is not Rust and I personally believe a different approach to handling error translation during propagation would be more Swifty for a number of reasons.  I believe that would be the case even if we had macros and protocols with type parameters.  I am continuing to think about this and will probably submit a proposal if / when David&#39;s proposal is accepted.<br>&gt;&gt; <br>&gt;&gt; IMO it is very important that we have a standard mechanism for translating errors during propagation.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The most important thing to remember is that this changes will not affect people that prefers the untyped throws, as they can continue doing it like now. I think this is really important as will allow us to ignore typed errors when writing prototyping code, but it will give the option to improve the safety of our code when is time for that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for the proposal and the interesting discussion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; PS: i&#39;ve been playing on porting the example from Rust errors page to Swift. <br>&gt;&gt;&gt; http://alejandromp.com/blog/2015/12/23/rust-error-handling-swift-script/ &lt;http://alejandromp.com/blog/2015/12/23/rust-error-handling-swift-script/&gt;<br>&gt;&gt;&gt; Will be interesting to try it again with the changes from this proposal ;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 23 Dec 2015, at 05:58, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; David&#39;s proposal looks good enough for me.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With regards to Matthew&#39;s worry of cluttering the code with conversion I&#39;d like to remark that this conversion code should only live on the border of your API (the facade), so it should probably not be too invasive to your business logic.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 22.12.2015 um 20:08 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 12:09 PM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 9:50 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Unfortunately, I don’t see a way to make it safe.  You had to use fatalError in a default case to make it work.  An alternative would have been to include an ‘UnknownError’ case in ‘PublishedError’.  Neither is not an acceptable solution IMO.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I need the fatalError() because the sample is a working example in Swift today. If we had typed errors, this would simply work:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    static func from&lt;T&gt;(@autoclosure fn: () throws InternalError -&gt; T) throws PublishedError -&gt; T {<br>&gt;&gt;&gt;&gt;&gt;&gt;         do {<br>&gt;&gt;&gt;&gt;&gt;&gt;             return try fn()<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;         catch InternalError.Internal(let value) {<br>&gt;&gt;&gt;&gt;&gt;&gt;             throw PublishedError.Converted(value: value)<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This states that the only closure accepted is one that throws an InternalError. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Ok, so you suggest writing a specific overload for each combination of error types that are convertible.  Got it.  Not sure why I didn’t think of overloads.  I was too focused on a general try function dispatching to an initializer.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That is indeed safe and I can live with it.  Thanks for taking the time to work through these examples with me and help to identify patterns that address my concerns!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I still find it unfortunate that this is in the realm of a pattern though.  IMO it would be much better if it was part of the common Swift vocabulary, either as a language feature or a library function but that isn’t possible as a generic implementation isn’t possible.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This top level `from` example also brings up a couple of points that I don’t recall being addressed in your proposal.  Specifically, the interaction of typed errors with generics and type inferrence.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I call out in the proposal that errors work with generics no differently than other types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Great, I must have missed that.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I still consider this to be an unresolved concern.  I would like to have a safe way to perform error conversion during propagation without cluttering up my control flow and seriously degrading readability.  This is a problem that can and has been solved in other languages.  IMO it is should be considered an essential element of a proposal introducing typed errors.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; When Swift has a macro as powerful as Rust, then this is a solved problem as well. However, Swift isn’t there yet. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would prefer a solution to this that didn’t require macros which would fit better in Swift.  This feature is buried in the `try!` macro in Rust as Rust doesn’t have built-in language level error handling support.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift already has `try` built into the language.  IMO it would be better to have it handled by the built-in language level error handling support in Swift.  That seems like the more “Swifty” approach.  We could have a Swift macro `tryAndConvert` or something, but that seems inelegant.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We’ve gone back and forth on this quite a bit but nobody else has chimed in.  I’m curious to hear what others thing.  I would love it if any lurkers would jump in and comment!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151224/57c89c61/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Allow Type Annotations on Throws</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 18, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 11:29 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This a significantly updated proposal for typed annotations on the `throws` construct. The previous was closed due to not be complete; I believe I’ve addressed all of those concerns.<br>&gt; <br>&gt; https://github.com/owensd/swift-evolution/blob/master/proposals/allow-type-annotations-on-throw.md &lt;https://github.com/owensd/swift-evolution/blob/master/proposals/allow-type-annotations-on-throw.md&gt;<br>&gt; <br></p><p>I haven’t had a chance to read this update in detail (but I have skimmed it): with that as a caveat, I am s till +1 on the proposal, and agree that we should stick with 0 or 1 declared thrown types.  It should also only happen after resilience features for enums are in place.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/1ea5e360/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
