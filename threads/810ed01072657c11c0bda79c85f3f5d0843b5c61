<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/094f3e16a9a1276cde39096860496ad8?s=50"></div><header><strong>retain cycle non-obvious when assigning method to closure</strong> from <string>Joshua Scott Emmons</string> &lt;skia at skia.net&gt;<p>January 17, 2016 at 01:00:00pm</p></header><div class="content"><p>There&#39;s a test case demonstrating what I&#39;m about to talking about: https://gist.github.com/jemmons/6f668006fa2712a84807<br></p><p>But here&#39;s the nut of it. Given a class like:<br></p><p>class Foo { <br>  var handler: (()-&gt;Void)?<br>  func noop(){}<br>  ...<br>}<br></p><p>If somewhere in this class I do something like:<br></p><p>handler = { self.noop() }<br></p><p>I&#39;ve created a retain cycle because handler holds a strong reference to a closure which holds a strong reference to self which holds a strong reference to a closure that…<br></p><p>In fact, my understanding is Swift&#39;s requirement that self be called out here explicitly is to highlight this danger. <br></p><p>Swift makes it easy to fix the problem with a capture list:<br></p><p>handler = { [unowned self] in self.noop() }<br></p><p>So far, so good. But what if I do something daft like assign noop directly:<br></p><p>handler = noop<br></p><p>This causes a retain loop for all the same reasons as our original example, but there&#39;s no self call-out to warn us of impending doom, and no support for some kind of capture list to fix the issue.<br></p><p>Is there any possibility of requiring &quot;self&quot; here? As in: &quot;handler = self.noop&quot; for example? And is there any way of specifying how we want self to be retained here?<br></p><p><br>Cheers,<br>-jemmons<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160117/810e5c61/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>retain cycle non-obvious when assigning method to closure</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 17, 2016 at 11:00:00am</p></header><div class="content"><p>I also noticed this problem with nested functions recently:<br></p><p>    class Foo {<br></p><p>        var handler: (() -&gt; Void)?<br></p><p>        func noop() {}<br></p><p>        func setup() {<br>            // *error:*<br>            handler = { noop() }<br></p><p>            // *no error:*<br>            handler = noop<br></p><p>            // *no error:*<br>            func innerFunc() { noop() }<br>            handler = { innerFunc() }<br>            handler = innerFunc<br>        }<br>    }<br></p><p>Jacob<br></p><p>On Sun, Jan 17, 2016 at 11:06 AM, Joshua Scott Emmons via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; There&#39;s a test case demonstrating what I&#39;m about to talking about:<br>&gt; https://gist.github.com/jemmons/6f668006fa2712a84807<br>&gt;<br>&gt; But here&#39;s the nut of it. Given a class like:<br>&gt;<br>&gt; class Foo {<br>&gt; var handler: (()-&gt;Void)?<br>&gt; func noop(){}<br>&gt; ...<br>&gt; }<br>&gt;<br>&gt; If somewhere in this class I do something like:<br>&gt;<br>&gt; handler = { self.noop() }<br>&gt;<br>&gt; I&#39;ve created a retain cycle because handler holds a strong reference to a<br>&gt; closure which holds a strong reference to self which holds a strong<br>&gt; reference to a closure that…<br>&gt;<br>&gt; In fact, my understanding is Swift&#39;s requirement that self be called out<br>&gt; here explicitly is to highlight this danger.<br>&gt;<br>&gt; Swift makes it easy to fix the problem with a capture list:<br>&gt;<br>&gt; handler = { [unowned self] in self.noop() }<br>&gt;<br>&gt; So far, so good. But what if I do something daft like assign noop<br>&gt; directly:<br>&gt;<br>&gt; handler = noop<br>&gt;<br>&gt; This causes a retain loop for all the same reasons as our original<br>&gt; example, but there&#39;s no self call-out to warn us of impending doom, and<br>&gt; no support for some kind of capture list to fix the issue.<br>&gt;<br>&gt; Is there any possibility of requiring &quot;self&quot; here? As in: &quot;handler = self.noop&quot;<br>&gt; for example? And is there any way of specifying how we want self to be<br>&gt; retained here?<br>&gt;<br>&gt;<br>&gt; Cheers,<br>&gt; -jemmons<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160117/408bab34/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7321934b88ca8da079d7b89926501a9c?s=50"></div><header><strong>retain cycle non-obvious when assigning method to closure</strong> from <string>David Turnbull</string> &lt;dturnbull at gmail.com&gt;<p>January 17, 2016 at 01:00:00pm</p></header><div class="content"><p>Why isn&#39;t self unowned by default? Seems like that would fix all kinds of<br>problems including being a novice.<br></p><p>Here&#39;s an example of a case where you need a strong self. Imagine that<br>[unowned self] is the default and the programmer made the mistake of<br>forgetting to use [strong self] .<br></p><p>class ClosureFactory {<br></p><p>    let s:String<br></p><p>    init(_ s:String) { self.s = s }<br></p><p>    func writeln() -&gt; () -&gt; Void {<br></p><p>        return {[unowned self] in print(self.s)}<br></p><p>    }<br></p><p>}<br></p><p>let writer = ClosureFactory(&quot;hi&quot;).writeln()<br></p><p>writer()<br></p><p>The program crashes. Wouldn&#39;t this be better than having a default that<br>makes it easy to write memory leaks? I&#39;d much rather be fixing a bug in<br>code I wrote 5 minutes ago than 5 months ago. Especially a memory leak.<br></p><p>-david https://github.com/AE9RB/SwiftGL<br></p><p><br></p><p>On Sun, Jan 17, 2016 at 11:57 AM, Jacob Bandes-Storch via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; I also noticed this problem with nested functions recently:<br>&gt;<br>&gt;     class Foo {<br>&gt;<br>&gt;         var handler: (() -&gt; Void)?<br>&gt;<br>&gt;         func noop() {}<br>&gt;<br>&gt;         func setup() {<br>&gt;             // *error:*<br>&gt;             handler = { noop() }<br>&gt;<br>&gt;             // *no error:*<br>&gt;             handler = noop<br>&gt;<br>&gt;             // *no error:*<br>&gt;             func innerFunc() { noop() }<br>&gt;             handler = { innerFunc() }<br>&gt;             handler = innerFunc<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt; Jacob<br>&gt;<br>&gt; On Sun, Jan 17, 2016 at 11:06 AM, Joshua Scott Emmons via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; There&#39;s a test case demonstrating what I&#39;m about to talking about:<br>&gt;&gt; https://gist.github.com/jemmons/6f668006fa2712a84807<br>&gt;&gt;<br>&gt;&gt; But here&#39;s the nut of it. Given a class like:<br>&gt;&gt;<br>&gt;&gt; class Foo {<br>&gt;&gt; var handler: (()-&gt;Void)?<br>&gt;&gt; func noop(){}<br>&gt;&gt; ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; If somewhere in this class I do something like:<br>&gt;&gt;<br>&gt;&gt; handler = { self.noop() }<br>&gt;&gt;<br>&gt;&gt; I&#39;ve created a retain cycle because handler holds a strong reference to<br>&gt;&gt; a closure which holds a strong reference to self which holds a strong<br>&gt;&gt; reference to a closure that…<br>&gt;&gt;<br>&gt;&gt; In fact, my understanding is Swift&#39;s requirement that self be called out<br>&gt;&gt; here explicitly is to highlight this danger.<br>&gt;&gt;<br>&gt;&gt; Swift makes it easy to fix the problem with a capture list:<br>&gt;&gt;<br>&gt;&gt; handler = { [unowned self] in self.noop() }<br>&gt;&gt;<br>&gt;&gt; So far, so good. But what if I do something daft like assign noop<br>&gt;&gt; directly:<br>&gt;&gt;<br>&gt;&gt; handler = noop<br>&gt;&gt;<br>&gt;&gt; This causes a retain loop for all the same reasons as our original<br>&gt;&gt; example, but there&#39;s no self call-out to warn us of impending doom, and<br>&gt;&gt; no support for some kind of capture list to fix the issue.<br>&gt;&gt;<br>&gt;&gt; Is there any possibility of requiring &quot;self&quot; here? As in: &quot;handler = self<br>&gt;&gt; .noop&quot; for example? And is there any way of specifying how we want self<br>&gt;&gt; to be retained here?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Cheers,<br>&gt;&gt; -jemmons<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160117/38b449e4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>retain cycle non-obvious when assigning method to closure</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 19, 2016 at 02:00:00pm</p></header><div class="content"><p>I agree that there are things we could do to improve this situation. My personal preference would be for &quot;implicit closures&quot; like this to be formed as @noescape, and require you to explicitly write a closure expression if the closure might escape. But any of these suggestions would count as language changes and should thus be discussed on swift-evolution.<br></p><p>Jordan<br></p><p>&gt; On Jan 17, 2016, at 13:31, David Turnbull via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Why isn&#39;t self unowned by default? Seems like that would fix all kinds of problems including being a novice.<br>&gt; <br>&gt; Here&#39;s an example of a case where you need a strong self. Imagine that [unowned self] is the default and the programmer made the mistake of forgetting to use [strong self] .<br>&gt; <br>&gt; class ClosureFactory {<br>&gt;     let s:String<br>&gt;     init(_ s:String) { self.s = s }<br>&gt;     func writeln() -&gt; () -&gt; Void {<br>&gt;         return {[unowned self] in print(self.s)}<br>&gt;     }<br>&gt; }<br>&gt; let writer = ClosureFactory(&quot;hi&quot;).writeln()<br>&gt; writer()<br>&gt; <br>&gt; The program crashes. Wouldn&#39;t this be better than having a default that makes it easy to write memory leaks? I&#39;d much rather be fixing a bug in code I wrote 5 minutes ago than 5 months ago. Especially a memory leak.<br>&gt; <br>&gt; -david https://github.com/AE9RB/SwiftGL &lt;https://github.com/AE9RB/SwiftGL&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Sun, Jan 17, 2016 at 11:57 AM, Jacob Bandes-Storch via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt; I also noticed this problem with nested functions recently:<br>&gt; <br>&gt;     class Foo {<br>&gt;         <br>&gt;         var handler: (() -&gt; Void)?<br>&gt;         <br>&gt;         func noop() {}<br>&gt;         <br>&gt;         func setup() {<br>&gt;             // error:<br>&gt;             handler = { noop() }<br>&gt;             <br>&gt;             // no error:<br>&gt;             handler = noop<br>&gt;             <br>&gt;             // no error:<br>&gt;             func innerFunc() { noop() }<br>&gt;             handler = { innerFunc() }<br>&gt;             handler = innerFunc<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Sun, Jan 17, 2016 at 11:06 AM, Joshua Scott Emmons via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt; There&#39;s a test case demonstrating what I&#39;m about to talking about: https://gist.github.com/jemmons/6f668006fa2712a84807 &lt;https://gist.github.com/jemmons/6f668006fa2712a84807&gt;<br>&gt; <br>&gt; But here&#39;s the nut of it. Given a class like:<br>&gt; <br>&gt; class Foo { <br>&gt;   var handler: (()-&gt;Void)?<br>&gt;   func noop(){}<br>&gt;   ...<br>&gt; }<br>&gt; <br>&gt; If somewhere in this class I do something like:<br>&gt; <br>&gt; handler = { self.noop() }<br>&gt; <br>&gt; I&#39;ve created a retain cycle because handler holds a strong reference to a closure which holds a strong reference to self which holds a strong reference to a closure that…<br>&gt; <br>&gt; In fact, my understanding is Swift&#39;s requirement that self be called out here explicitly is to highlight this danger. <br>&gt; <br>&gt; Swift makes it easy to fix the problem with a capture list:<br>&gt; <br>&gt; handler = { [unowned self] in self.noop() }<br>&gt; <br>&gt; So far, so good. But what if I do something daft like assign noop directly:<br>&gt; <br>&gt; handler = noop<br>&gt; <br>&gt; This causes a retain loop for all the same reasons as our original example, but there&#39;s no self call-out to warn us of impending doom, and no support for some kind of capture list to fix the issue.<br>&gt; <br>&gt; Is there any possibility of requiring &quot;self&quot; here? As in: &quot;handler = self.noop&quot; for example? And is there any way of specifying how we want self to be retained here?<br>&gt; <br>&gt; <br>&gt; Cheers,<br>&gt; -jemmons<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160119/92cc48ae/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
