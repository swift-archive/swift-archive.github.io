<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>dispatch concurrent map: is this right?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>October 30, 2016 at 11:00:00am</p></header><div class="content"><p>on Sun Oct 30 2016, Karl &lt;swift-users-AT-swift.org&gt; wrote:<br></p><p>&gt;&gt; On 30 Oct 2016, at 09:15, Karl &lt;raziel.im+swift-users at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I had the need for a concurrent map recently. I had a part of a<br>&gt;&gt; program which needed to read chunks of data and concurrently process<br>&gt;&gt; them and assemble the results in an array. This isn’t necessarily as<br>&gt;&gt; obvious as it sounds, because of arrays being value types. I came up<br>&gt;&gt; with the following snippet which I’d like to check for correctness;<br>&gt;&gt; it could also be helpful to others.<br>&gt;&gt; <br>&gt;&gt; Perhaps this is something Dispatch should provide out-of-the-box?<br>&gt;&gt; <br>&gt;&gt; - Karl<br>&gt;<br>&gt; Ah one second, I was refactoring this and forgot to test it. Here’s the actual code:<br></p><p>A map presumably requires an input <br></p><p>&gt; extension DispatchQueue {<br>&gt;<br>&gt;   static func concurrentMap&lt;T&gt;(iterations: Int, execute block: (Int) -&gt; T) -&gt; [T] {<br>&gt;<br>&gt;     let __result = UnsafeMutableRawBufferPointer.allocate(count: iterations * MemoryLayout&lt;T&gt;.stride)<br>&gt;     defer { __result.deallocate() }<br>&gt;     let _result  = __result.baseAddress?.assumingMemoryBound(to: T.self)<br></p><p>You never bound the memory to T, so this will be undefined behavior.  <br></p><p>&gt;     let result   = UnsafeMutableBufferPointer&lt;T&gt;(start: _result, count: iterations)<br>&gt;     concurrentPerform(iterations: iterations) { idx in<br>&gt;       result[idx] = block(idx)<br></p><p>You also never initialized the Ts in that memory region, so assigning<br>into them will also be undefined behavior.<br></p><p>&gt;     }<br>&gt;     return Array(result)<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; extension Array {<br>&gt;   func concurrentMap&lt;T&gt;(execute block: (Element)-&gt;T) -&gt; [T] {<br>&gt;     return DispatchQueue.concurrentMap(iterations: count) { block(self[$0]) }<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; Unfortunately I don’t think there’s a way to get an array to take over a +1<br>&gt; UnsafeMutableBufferPointer without copying.<br></p><p>The only correct way to do this without creating intermediate storage is<br>to have a way to initialize your result elements, e.g.:<br></p><p>  import Dispatch<br></p><p>  protocol DefaultInitializable {<br>    init()<br>  }<br></p><p>  extension RandomAccessCollection {<br>    func concurrentMap&lt;T&gt;(_ transform: (Iterator.Element)-&gt;T) -&gt; [T]<br>    where T : DefaultInitializable {<br>      var result = Array(<br>        repeating: T(), count: numericCast(self.count))<br></p><p>      DispatchQueue.concurrentPerform(iterations: result.count) {<br>        offset in <br>        result[offset] = transform(<br>          self[index(startIndex, offsetBy: numericCast(offset))])<br>      }<br>      return result<br>    }<br>  }<br></p><p>  extension Int : DefaultInitializable {  }<br></p><p>  print((3..&lt;20).concurrentMap { $0 * 2 })<br></p><p>If you don&#39;t want the DefaultInitializable requirement (or some other<br>way to prepare initialized elements), you&#39;ll need to manage memory<br>yourself:<br></p><p>  extension RandomAccessCollection {<br>    func concurrentMap&lt;T&gt;(_ transform: (Iterator.Element)-&gt;T) -&gt; [T] {<br>      let n = numericCast(self.count) as Int<br>      let p = UnsafeMutablePointer&lt;T&gt;.allocate(capacity: n)<br>      defer { p.deallocate(capacity: n) }<br></p><p>      DispatchQueue.concurrentPerform(iterations: n) {<br>        offset in<br>        (p + offset).initialize(<br>          to: transform(<br>            self[index(startIndex, offsetBy: numericCast(offset))]))<br>      }<br></p><p>      return Array(UnsafeMutableBufferPointer(start: p, count: n))<br>    }<br>  }<br></p><p>This posting highlights a couple of weaknesses in the standard library<br>for which I&#39;d appreciate bug reports:<br></p><p>1. No way to arbitrarily initialize an Array&#39;s storage.<br>2. UnsafeMutableBufferPointer doesn&#39;t have an allocating init<br></p><p>Thanks!<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>dispatch concurrent map: is this right?</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 31, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; On 30 Oct 2016, at 19:23, Dave Abrahams via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sun Oct 30 2016, Karl &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On 30 Oct 2016, at 09:15, Karl &lt;raziel.im+swift-users at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I had the need for a concurrent map recently. I had a part of a<br>&gt;&gt;&gt; program which needed to read chunks of data and concurrently process<br>&gt;&gt;&gt; them and assemble the results in an array. This isn’t necessarily as<br>&gt;&gt;&gt; obvious as it sounds, because of arrays being value types. I came up<br>&gt;&gt;&gt; with the following snippet which I’d like to check for correctness;<br>&gt;&gt;&gt; it could also be helpful to others.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Perhaps this is something Dispatch should provide out-of-the-box?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Karl<br>&gt;&gt; <br>&gt;&gt; Ah one second, I was refactoring this and forgot to test it. Here’s the actual code:<br>&gt; <br>&gt; A map presumably requires an input <br></p><p>DispatchQueue.concurrentMap maps a Range&lt;Int&gt; -&gt; T, but since the range is always 0..&lt;n, we only ask for the value of n. It could also be written quite naturally as an extension on Range and build everything on top of it.<br></p><p>&gt; <br>&gt;&gt; extension DispatchQueue {<br>&gt;&gt; <br>&gt;&gt;  static func concurrentMap&lt;T&gt;(iterations: Int, execute block: (Int) -&gt; T) -&gt; [T] {<br>&gt;&gt; <br>&gt;&gt;    let __result = UnsafeMutableRawBufferPointer.allocate(count: iterations * MemoryLayout&lt;T&gt;.stride)<br>&gt;&gt;    defer { __result.deallocate() }<br>&gt;&gt;    let _result  = __result.baseAddress?.assumingMemoryBound(to: T.self)<br>&gt; <br>&gt; You never bound the memory to T, so this will be undefined behavior.  <br>&gt; <br>&gt;&gt;    let result   = UnsafeMutableBufferPointer&lt;T&gt;(start: _result, count: iterations)<br>&gt;&gt;    concurrentPerform(iterations: iterations) { idx in<br>&gt;&gt;      result[idx] = block(idx)<br>&gt; <br>&gt; You also never initialized the Ts in that memory region, so assigning<br>&gt; into them will also be undefined behavior.<br>&gt; <br>&gt;&gt;    }<br>&gt;&gt;    return Array(result)<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Array {<br>&gt;&gt;  func concurrentMap&lt;T&gt;(execute block: (Element)-&gt;T) -&gt; [T] {<br>&gt;&gt;    return DispatchQueue.concurrentMap(iterations: count) { block(self[$0]) }<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Unfortunately I don’t think there’s a way to get an array to take over a +1<br>&gt;&gt; UnsafeMutableBufferPointer without copying.<br>&gt; <br>&gt; The only correct way to do this without creating intermediate storage is<br>&gt; to have a way to initialize your result elements, e.g.:<br>&gt; <br>&gt;  import Dispatch<br>&gt; <br>&gt;  protocol DefaultInitializable {<br>&gt;    init()<br>&gt;  }<br>&gt; <br>&gt;  extension RandomAccessCollection {<br>&gt;    func concurrentMap&lt;T&gt;(_ transform: (Iterator.Element)-&gt;T) -&gt; [T]<br>&gt;    where T : DefaultInitializable {<br>&gt;      var result = Array(<br>&gt;        repeating: T(), count: numericCast(self.count))<br>&gt; <br>&gt;      DispatchQueue.concurrentPerform(iterations: result.count) {<br>&gt;        offset in <br>&gt;        result[offset] = transform(<br>&gt;          self[index(startIndex, offsetBy: numericCast(offset))])<br>&gt;      }<br>&gt;      return result<br>&gt;    }<br>&gt;  }<br>&gt; <br>&gt;  extension Int : DefaultInitializable {  }<br>&gt; <br>&gt;  print((3..&lt;20).concurrentMap { $0 * 2 })<br>&gt; <br></p><p>I had a go at doing that before, using Optional&lt;T&gt; and unwrapping at the end — but it occurred to me that it would be very inefficient for things like Optional&lt;Int&gt;, and introduces more allocations.<br></p><p><br>&gt; If you don&#39;t want the DefaultInitializable requirement (or some other<br>&gt; way to prepare initialized elements), you&#39;ll need to manage memory<br>&gt; yourself:<br>&gt; <br>&gt;  extension RandomAccessCollection {<br>&gt;    func concurrentMap&lt;T&gt;(_ transform: (Iterator.Element)-&gt;T) -&gt; [T] {<br>&gt;      let n = numericCast(self.count) as Int<br>&gt;      let p = UnsafeMutablePointer&lt;T&gt;.allocate(capacity: n)<br>&gt;      defer { p.deallocate(capacity: n) }<br>&gt; <br>&gt;      DispatchQueue.concurrentPerform(iterations: n) {<br>&gt;        offset in<br>&gt;        (p + offset).initialize(<br>&gt;          to: transform(<br>&gt;            self[index(startIndex, offsetBy: numericCast(offset))]))<br>&gt;      }<br>&gt; <br>&gt;      return Array(UnsafeMutableBufferPointer(start: p, count: n))<br>&gt;    }<br>&gt;  }<br>&gt; <br>&gt; This posting highlights a couple of weaknesses in the standard library<br>&gt; for which I&#39;d appreciate bug reports:<br>&gt; <br>&gt; 1. No way to arbitrarily initialize an Array&#39;s storage.<br>&gt; 2. UnsafeMutableBufferPointer doesn&#39;t have an allocating init<br>&gt; <br>&gt; Thanks!<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p><br>Filed:<br></p><p>1. https://bugs.swift.org/browse/SR-3087<br>2. https://bugs.swift.org/browse/SR-3088<br></p><p>What is your opinion on the corelibs extending the standard library types? Foundation does it to provide APIs from NSString, but it’s kind of a special case. Would it be reasonable for Dispatch (which is not _such_ a special case) to also extend types like Range and Collection?<br></p><p>I quite like the API as an extension on Range. I think it would be a nice addition to Dispatch (once we start allowing additive proposals):<br></p><p>extension Range where Bound : Strideable, Bound.Stride : SignedInteger {<br></p><p>  func concurrentMap&lt;T&gt;(_ transform: (Bound) -&gt; T) -&gt; [T] {<br>    let n        = numericCast(count) as Int<br>    let buffer = UnsafeMutablePointer&lt;T&gt;.allocate(capacity: n)<br></p><p>    DispatchQueue.concurrentPerform(iterations: n) {<br>      (buffer + $0).initialize(to: transform(lowerBound + numericCast($0)))<br>    }<br></p><p>    // Unfortunately, the buffer is copied when making it an Array&lt;T&gt;.<br>    defer { buffer.deallocate(capacity: n) }<br>    return Array(UnsafeMutableBufferPointer&lt;T&gt;(start: buffer, count: n))<br>  }<br>}<br></p><p>extension Collection {<br>  func concurrentMap&lt;T&gt;(_ transform: (Iterator.Element)-&gt;T) -&gt; [T] {<br></p><p>    // ‘as Range’ because CountableRange is a collection, causing the function to be recursive.<br>    return ((0..&lt;numericCast(count)) as Range).concurrentMap {<br>      transform(self[index(startIndex, offsetBy: numericCast($0))])<br>    }<br>  }<br>}<br></p><p>Thanks<br></p><p>- Karl<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161031/6746157e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>dispatch concurrent map: is this right?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>October 30, 2016 at 09:00:00pm</p></header><div class="content"><p>on Sun Oct 30 2016, Karl &lt;razielim-AT-gmail.com&gt; wrote:<br></p><p>&gt;&gt; On 30 Oct 2016, at 19:23, Dave Abrahams via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sun Oct 30 2016, Karl &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On 30 Oct 2016, at 09:15, Karl &lt;raziel.im+swift-users at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I had the need for a concurrent map recently. I had a part of a<br>&gt;&gt;&gt;&gt; program which needed to read chunks of data and concurrently process<br>&gt;&gt;&gt;&gt; them and assemble the results in an array. This isn’t necessarily as<br>&gt;&gt;&gt;&gt; obvious as it sounds, because of arrays being value types. I came up<br>&gt;&gt;&gt;&gt; with the following snippet which I’d like to check for correctness;<br>&gt;&gt;&gt;&gt; it could also be helpful to others.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Perhaps this is something Dispatch should provide out-of-the-box?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Karl<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ah one second, I was refactoring this and forgot to test it. Here’s the actual code:<br>&gt;&gt; <br>&gt;&gt; A map presumably requires an input <br>&gt;<br>&gt; DispatchQueue.concurrentMap maps a Range&lt;Int&gt; -&gt; T, but since the<br>&gt; range is always 0..&lt;n, we only ask for the value of n. It could also<br>&gt; be written quite naturally as an extension on Range and build<br>&gt; everything on top of it.<br></p><p>Sorry, I wrote “a map presumably requires an input” before I realized<br>what you were doing.  I should have deleted that.<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; extension DispatchQueue {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  static func concurrentMap&lt;T&gt;(iterations: Int, execute block: (Int) -&gt; T) -&gt; [T] {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    let __result = UnsafeMutableRawBufferPointer.allocate(count: iterations * MemoryLayout&lt;T&gt;.stride)<br>&gt;&gt;&gt;    defer { __result.deallocate() }<br>&gt;&gt;&gt;    let _result  = __result.baseAddress?.assumingMemoryBound(to: T.self)<br>&gt;&gt; <br>&gt;&gt; You never bound the memory to T, so this will be undefined behavior.  <br>&gt;&gt; <br>&gt;&gt;&gt;    let result   = UnsafeMutableBufferPointer&lt;T&gt;(start: _result, count: iterations)<br>&gt;&gt;&gt;    concurrentPerform(iterations: iterations) { idx in<br>&gt;&gt;&gt;      result[idx] = block(idx)<br>&gt;&gt; <br>&gt;&gt; You also never initialized the Ts in that memory region, so assigning<br>&gt;&gt; into them will also be undefined behavior.<br>&gt;&gt; <br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt;    return Array(result)<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Array {<br>&gt;&gt;&gt;  func concurrentMap&lt;T&gt;(execute block: (Element)-&gt;T) -&gt; [T] {<br>&gt;&gt;&gt;    return DispatchQueue.concurrentMap(iterations: count) { block(self[$0]) }<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unfortunately I don’t think there’s a way to get an array to take over a +1<br>&gt;&gt;&gt; UnsafeMutableBufferPointer without copying.<br>&gt;&gt; <br>&gt;&gt; The only correct way to do this without creating intermediate storage is<br>&gt;&gt; to have a way to initialize your result elements, e.g.:<br>&gt;&gt; <br>&gt;&gt;  import Dispatch<br>&gt;&gt; <br>&gt;&gt;  protocol DefaultInitializable {<br>&gt;&gt;    init()<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  extension RandomAccessCollection {<br>&gt;&gt;    func concurrentMap&lt;T&gt;(_ transform: (Iterator.Element)-&gt;T) -&gt; [T]<br>&gt;&gt;    where T : DefaultInitializable {<br>&gt;&gt;      var result = Array(<br>&gt;&gt;        repeating: T(), count: numericCast(self.count))<br>&gt;&gt; <br>&gt;&gt;      DispatchQueue.concurrentPerform(iterations: result.count) {<br>&gt;&gt;        offset in <br>&gt;&gt;        result[offset] = transform(<br>&gt;&gt;          self[index(startIndex, offsetBy: numericCast(offset))])<br>&gt;&gt;      }<br>&gt;&gt;      return result<br>&gt;&gt;    }<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  extension Int : DefaultInitializable {  }<br>&gt;&gt; <br>&gt;&gt;  print((3..&lt;20).concurrentMap { $0 * 2 })<br>&gt;&gt; <br>&gt;<br>&gt; I had a go at doing that before, using Optional&lt;T&gt; and unwrapping at<br>&gt; the end — but it occurred to me that it would be very inefficient for<br>&gt; things like Optional&lt;Int&gt;, and introduces more allocations.<br></p><p>Yeah, optional is not really a good choice for that application.<br></p><p>&gt;&gt; If you don&#39;t want the DefaultInitializable requirement (or some other<br>&gt;&gt; way to prepare initialized elements), you&#39;ll need to manage memory<br>&gt;&gt; yourself:<br>&gt;&gt; <br>&gt;&gt;  extension RandomAccessCollection {<br>&gt;&gt;    func concurrentMap&lt;T&gt;(_ transform: (Iterator.Element)-&gt;T) -&gt; [T] {<br>&gt;&gt;      let n = numericCast(self.count) as Int<br>&gt;&gt;      let p = UnsafeMutablePointer&lt;T&gt;.allocate(capacity: n)<br>&gt;&gt;      defer { p.deallocate(capacity: n) }<br>&gt;&gt; <br>&gt;&gt;      DispatchQueue.concurrentPerform(iterations: n) {<br>&gt;&gt;        offset in<br>&gt;&gt;        (p + offset).initialize(<br>&gt;&gt;          to: transform(<br>&gt;&gt;            self[index(startIndex, offsetBy: numericCast(offset))]))<br>&gt;&gt;      }<br>&gt;&gt; <br>&gt;&gt;      return Array(UnsafeMutableBufferPointer(start: p, count: n))<br>&gt;&gt;    }<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt; This posting highlights a couple of weaknesses in the standard library<br>&gt;&gt; for which I&#39;d appreciate bug reports:<br>&gt;&gt; <br>&gt;&gt; 1. No way to arbitrarily initialize an Array&#39;s storage.<br>&gt;&gt; 2. UnsafeMutableBufferPointer doesn&#39;t have an allocating init<br>&gt;&gt; <br>&gt; Filed:<br>&gt;<br>&gt; 1. https://bugs.swift.org/browse/SR-3087<br>&gt; 2. https://bugs.swift.org/browse/SR-3088<br></p><p>Thanks for these!<br>&gt;<br>&gt; What is your opinion on the corelibs extending the standard library<br>&gt; types? <br>&gt; Foundation does it to provide APIs from NSString, but it’s kind of a<br>&gt; special case. <br></p><p>My opinion is that, *as a rule*, frameworks should avoid extending APIs<br>from other frameworks; it makes it very hard for the author of the<br>original type to manage the user experience of her type.  But there are<br>exceptions to every rule ;-)<br></p><p>&gt; Would it be reasonable for Dispatch (which is not _such_ a special<br>&gt; case) to also extend types like Range and Collection?<br></p><p>Oh, well now *Collection* is not a type (despite how it&#39;s defined in the<br>language); it&#39;s a protocol.  Extending Collection is the best way to<br>write generic algorithms over all Collections, so I support that.  But<br>it does have to be done very judiciously, because you have to realize<br>the API you are providing is going to appear on everything that conforms<br>to Collection.<br></p><p>&gt; I quite like the API as an extension on Range. I think it would be a<br>&gt; nice addition to Dispatch (once we start allowing additive proposals):<br>&gt;<br>&gt; extension Range where Bound : Strideable, Bound.Stride : SignedInteger {<br>&gt;<br>&gt;   func concurrentMap&lt;T&gt;(_ transform: (Bound) -&gt; T) -&gt; [T] {<br>&gt;     let n        = numericCast(count) as Int<br>&gt;     let buffer = UnsafeMutablePointer&lt;T&gt;.allocate(capacity: n)<br>&gt;<br>&gt;     DispatchQueue.concurrentPerform(iterations: n) {<br>&gt;       (buffer + $0).initialize(to: transform(lowerBound + numericCast($0)))<br>&gt;     }<br>&gt;<br>&gt;     // Unfortunately, the buffer is copied when making it an Array&lt;T&gt;.<br>&gt;     defer { buffer.deallocate(capacity: n) }<br>&gt;     return Array(UnsafeMutableBufferPointer&lt;T&gt;(start: buffer, count: n))<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; extension Collection {<br>&gt;   func concurrentMap&lt;T&gt;(_ transform: (Iterator.Element)-&gt;T) -&gt; [T] {<br>&gt;<br>&gt;     // ‘as Range’ because CountableRange is a collection, causing the function to be recursive.<br>&gt;     return ((0..&lt;numericCast(count)) as Range).concurrentMap {<br>&gt;       transform(self[index(startIndex, offsetBy: numericCast($0))])<br>&gt;     }<br>&gt;   }<br>&gt; }<br></p><p>I see the beauty in what you&#39;re doing here, but I don&#39;t see any<br>advantage to it for users.  Now Range (which will be collapsed with<br>CountableRange in Swift 4) will have two overloads of concurrentMap.  In<br>general, avoidable overloads are bad for the user experience.<br></p><p>HTH,<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>dispatch concurrent map: is this right?</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 31, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 31 Oct 2016, at 05:15, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sun Oct 30 2016, Karl &lt;razielim-AT-gmail.com &lt;http://razielim-at-gmail.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On 30 Oct 2016, at 19:23, Dave Abrahams via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Sun Oct 30 2016, Karl &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 30 Oct 2016, at 09:15, Karl &lt;raziel.im+swift-users at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I had the need for a concurrent map recently. I had a part of a<br>&gt;&gt;&gt;&gt;&gt; program which needed to read chunks of data and concurrently process<br>&gt;&gt;&gt;&gt;&gt; them and assemble the results in an array. This isn’t necessarily as<br>&gt;&gt;&gt;&gt;&gt; obvious as it sounds, because of arrays being value types. I came up<br>&gt;&gt;&gt;&gt;&gt; with the following snippet which I’d like to check for correctness;<br>&gt;&gt;&gt;&gt;&gt; it could also be helpful to others.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Perhaps this is something Dispatch should provide out-of-the-box?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Karl<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ah one second, I was refactoring this and forgot to test it. Here’s the actual code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A map presumably requires an input <br>&gt;&gt; <br>&gt;&gt; DispatchQueue.concurrentMap maps a Range&lt;Int&gt; -&gt; T, but since the<br>&gt;&gt; range is always 0..&lt;n, we only ask for the value of n. It could also<br>&gt;&gt; be written quite naturally as an extension on Range and build<br>&gt;&gt; everything on top of it.<br>&gt; <br>&gt; Sorry, I wrote “a map presumably requires an input” before I realized<br>&gt; what you were doing.  I should have deleted that.<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension DispatchQueue {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; static func concurrentMap&lt;T&gt;(iterations: Int, execute block: (Int) -&gt; T) -&gt; [T] {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   let __result = UnsafeMutableRawBufferPointer.allocate(count: iterations * MemoryLayout&lt;T&gt;.stride)<br>&gt;&gt;&gt;&gt;   defer { __result.deallocate() }<br>&gt;&gt;&gt;&gt;   let _result  = __result.baseAddress?.assumingMemoryBound(to: T.self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You never bound the memory to T, so this will be undefined behavior.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   let result   = UnsafeMutableBufferPointer&lt;T&gt;(start: _result, count: iterations)<br>&gt;&gt;&gt;&gt;   concurrentPerform(iterations: iterations) { idx in<br>&gt;&gt;&gt;&gt;     result[idx] = block(idx)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You also never initialized the Ts in that memory region, so assigning<br>&gt;&gt;&gt; into them will also be undefined behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   return Array(result)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Array {<br>&gt;&gt;&gt;&gt; func concurrentMap&lt;T&gt;(execute block: (Element)-&gt;T) -&gt; [T] {<br>&gt;&gt;&gt;&gt;   return DispatchQueue.concurrentMap(iterations: count) { block(self[$0]) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unfortunately I don’t think there’s a way to get an array to take over a +1<br>&gt;&gt;&gt;&gt; UnsafeMutableBufferPointer without copying.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The only correct way to do this without creating intermediate storage is<br>&gt;&gt;&gt; to have a way to initialize your result elements, e.g.:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; import Dispatch<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol DefaultInitializable {<br>&gt;&gt;&gt;   init()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension RandomAccessCollection {<br>&gt;&gt;&gt;   func concurrentMap&lt;T&gt;(_ transform: (Iterator.Element)-&gt;T) -&gt; [T]<br>&gt;&gt;&gt;   where T : DefaultInitializable {<br>&gt;&gt;&gt;     var result = Array(<br>&gt;&gt;&gt;       repeating: T(), count: numericCast(self.count))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     DispatchQueue.concurrentPerform(iterations: result.count) {<br>&gt;&gt;&gt;       offset in <br>&gt;&gt;&gt;       result[offset] = transform(<br>&gt;&gt;&gt;         self[index(startIndex, offsetBy: numericCast(offset))])<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     return result<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Int : DefaultInitializable {  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print((3..&lt;20).concurrentMap { $0 * 2 })<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I had a go at doing that before, using Optional&lt;T&gt; and unwrapping at<br>&gt;&gt; the end — but it occurred to me that it would be very inefficient for<br>&gt;&gt; things like Optional&lt;Int&gt;, and introduces more allocations.<br>&gt; <br>&gt; Yeah, optional is not really a good choice for that application.<br>&gt; <br>&gt;&gt;&gt; If you don&#39;t want the DefaultInitializable requirement (or some other<br>&gt;&gt;&gt; way to prepare initialized elements), you&#39;ll need to manage memory<br>&gt;&gt;&gt; yourself:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension RandomAccessCollection {<br>&gt;&gt;&gt;   func concurrentMap&lt;T&gt;(_ transform: (Iterator.Element)-&gt;T) -&gt; [T] {<br>&gt;&gt;&gt;     let n = numericCast(self.count) as Int<br>&gt;&gt;&gt;     let p = UnsafeMutablePointer&lt;T&gt;.allocate(capacity: n)<br>&gt;&gt;&gt;     defer { p.deallocate(capacity: n) }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     DispatchQueue.concurrentPerform(iterations: n) {<br>&gt;&gt;&gt;       offset in<br>&gt;&gt;&gt;       (p + offset).initialize(<br>&gt;&gt;&gt;         to: transform(<br>&gt;&gt;&gt;           self[index(startIndex, offsetBy: numericCast(offset))]))<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     return Array(UnsafeMutableBufferPointer(start: p, count: n))<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This posting highlights a couple of weaknesses in the standard library<br>&gt;&gt;&gt; for which I&#39;d appreciate bug reports:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. No way to arbitrarily initialize an Array&#39;s storage.<br>&gt;&gt;&gt; 2. UnsafeMutableBufferPointer doesn&#39;t have an allocating init<br>&gt;&gt;&gt; <br>&gt;&gt; Filed:<br>&gt;&gt; <br>&gt;&gt; 1. https://bugs.swift.org/browse/SR-3087 &lt;https://bugs.swift.org/browse/SR-3087&gt;<br>&gt;&gt; 2. https://bugs.swift.org/browse/SR-3088 &lt;https://bugs.swift.org/browse/SR-3088&gt;<br>&gt; <br>&gt; Thanks for these!<br>&gt;&gt; <br>&gt;&gt; What is your opinion on the corelibs extending the standard library<br>&gt;&gt; types? <br>&gt;&gt; Foundation does it to provide APIs from NSString, but it’s kind of a<br>&gt;&gt; special case. <br>&gt; <br>&gt; My opinion is that, *as a rule*, frameworks should avoid extending APIs<br>&gt; from other frameworks; it makes it very hard for the author of the<br>&gt; original type to manage the user experience of her type.  But there are<br>&gt; exceptions to every rule ;-)<br>&gt; <br>&gt;&gt; Would it be reasonable for Dispatch (which is not _such_ a special<br>&gt;&gt; case) to also extend types like Range and Collection?<br>&gt; <br>&gt; Oh, well now *Collection* is not a type (despite how it&#39;s defined in the<br>&gt; language); it&#39;s a protocol.  Extending Collection is the best way to<br>&gt; write generic algorithms over all Collections, so I support that.  But<br>&gt; it does have to be done very judiciously, because you have to realize<br>&gt; the API you are providing is going to appear on everything that conforms<br>&gt; to Collection.<br>&gt; <br>&gt;&gt; I quite like the API as an extension on Range. I think it would be a<br>&gt;&gt; nice addition to Dispatch (once we start allowing additive proposals):<br>&gt;&gt; <br>&gt;&gt; extension Range where Bound : Strideable, Bound.Stride : SignedInteger {<br>&gt;&gt; <br>&gt;&gt;  func concurrentMap&lt;T&gt;(_ transform: (Bound) -&gt; T) -&gt; [T] {<br>&gt;&gt;    let n        = numericCast(count) as Int<br>&gt;&gt;    let buffer = UnsafeMutablePointer&lt;T&gt;.allocate(capacity: n)<br>&gt;&gt; <br>&gt;&gt;    DispatchQueue.concurrentPerform(iterations: n) {<br>&gt;&gt;      (buffer + $0).initialize(to: transform(lowerBound + numericCast($0)))<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    // Unfortunately, the buffer is copied when making it an Array&lt;T&gt;.<br>&gt;&gt;    defer { buffer.deallocate(capacity: n) }<br>&gt;&gt;    return Array(UnsafeMutableBufferPointer&lt;T&gt;(start: buffer, count: n))<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Collection {<br>&gt;&gt;  func concurrentMap&lt;T&gt;(_ transform: (Iterator.Element)-&gt;T) -&gt; [T] {<br>&gt;&gt; <br>&gt;&gt;    // ‘as Range’ because CountableRange is a collection, causing the function to be recursive.<br>&gt;&gt;    return ((0..&lt;numericCast(count)) as Range).concurrentMap {<br>&gt;&gt;      transform(self[index(startIndex, offsetBy: numericCast($0))])<br>&gt;&gt;    }<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt; <br>&gt; I see the beauty in what you&#39;re doing here, but I don&#39;t see any<br>&gt; advantage to it for users.  Now Range (which will be collapsed with<br>&gt; CountableRange in Swift 4) will have two overloads of concurrentMap.  In<br>&gt; general, avoidable overloads are bad for the user experience.<br>&gt; <br>&gt; HTH,<br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p><p>Notwithstanding your comment about `collection.parallel.map { }.filter {}`, the issue here is with the literal being interpreted as CountableRange. That can be really annoying in general, and I’m glad the different Range types are going away.<br></p><p>If Range conditionally conforms to Collection (say, when its Bound is Strideable), then `(0..&lt;5).concurrentMap {}` should still call the function on Range because it’s “more specialised”, isn&#39;t that correct?<br></p><p>Thanks<br></p><p>- Karl<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161031/b24615fc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>dispatch concurrent map: is this right?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>October 31, 2016 at 03:00:00pm</p></header><div class="content"><p>on Mon Oct 31 2016, Karl &lt;razielim-AT-gmail.com&gt; wrote:<br></p><p>&gt;&gt; On 31 Oct 2016, at 05:15, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sun Oct 30 2016, Karl &lt;razielim-AT-gmail.com &lt;http://razielim-at-gmail.com/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On 30 Oct 2016, at 19:23, Dave Abrahams via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Sun Oct 30 2016, Karl &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 30 Oct 2016, at 09:15, Karl &lt;raziel.im+swift-users at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I had the need for a concurrent map recently. I had a part of a<br>&gt;&gt;&gt;&gt;&gt;&gt; program which needed to read chunks of data and concurrently process<br>&gt;&gt;&gt;&gt;&gt;&gt; them and assemble the results in an array. This isn’t necessarily as<br>&gt;&gt;&gt;&gt;&gt;&gt; obvious as it sounds, because of arrays being value types. I came up<br>&gt;&gt;&gt;&gt;&gt;&gt; with the following snippet which I’d like to check for correctness;<br>&gt;&gt;&gt;&gt;&gt;&gt; it could also be helpful to others.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Perhaps this is something Dispatch should provide out-of-the-box?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Karl<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Ah one second, I was refactoring this and forgot to test it. Here’s the actual code:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A map presumably requires an input <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; DispatchQueue.concurrentMap maps a Range&lt;Int&gt; -&gt; T, but since the<br>&gt;&gt;&gt; range is always 0..&lt;n, we only ask for the value of n. It could also<br>&gt;&gt;&gt; be written quite naturally as an extension on Range and build<br>&gt;&gt;&gt; everything on top of it.<br>&gt;&gt; <br>&gt;&gt; Sorry, I wrote “a map presumably requires an input” before I realized<br>&gt;&gt; what you were doing.  I should have deleted that.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension DispatchQueue {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; static func concurrentMap&lt;T&gt;(iterations: Int, execute block: (Int) -&gt; T) -&gt; [T] {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   let __result = UnsafeMutableRawBufferPointer.allocate(count: iterations * MemoryLayout&lt;T&gt;.stride)<br>&gt;&gt;&gt;&gt;&gt;   defer { __result.deallocate() }<br>&gt;&gt;&gt;&gt;&gt;   let _result  = __result.baseAddress?.assumingMemoryBound(to: T.self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You never bound the memory to T, so this will be undefined behavior.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   let result   = UnsafeMutableBufferPointer&lt;T&gt;(start: _result, count: iterations)<br>&gt;&gt;&gt;&gt;&gt;   concurrentPerform(iterations: iterations) { idx in<br>&gt;&gt;&gt;&gt;&gt;     result[idx] = block(idx)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You also never initialized the Ts in that memory region, so assigning<br>&gt;&gt;&gt;&gt; into them will also be undefined behavior.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   return Array(result)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension Array {<br>&gt;&gt;&gt;&gt;&gt; func concurrentMap&lt;T&gt;(execute block: (Element)-&gt;T) -&gt; [T] {<br>&gt;&gt;&gt;&gt;&gt;   return DispatchQueue.concurrentMap(iterations: count) { block(self[$0]) }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Unfortunately I don’t think there’s a way to get an array to take over a +1<br>&gt;&gt;&gt;&gt;&gt; UnsafeMutableBufferPointer without copying.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The only correct way to do this without creating intermediate storage is<br>&gt;&gt;&gt;&gt; to have a way to initialize your result elements, e.g.:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; import Dispatch<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol DefaultInitializable {<br>&gt;&gt;&gt;&gt;   init()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension RandomAccessCollection {<br>&gt;&gt;&gt;&gt;   func concurrentMap&lt;T&gt;(_ transform: (Iterator.Element)-&gt;T) -&gt; [T]<br>&gt;&gt;&gt;&gt;   where T : DefaultInitializable {<br>&gt;&gt;&gt;&gt;     var result = Array(<br>&gt;&gt;&gt;&gt;       repeating: T(), count: numericCast(self.count))<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     DispatchQueue.concurrentPerform(iterations: result.count) {<br>&gt;&gt;&gt;&gt;       offset in <br>&gt;&gt;&gt;&gt;       result[offset] = transform(<br>&gt;&gt;&gt;&gt;         self[index(startIndex, offsetBy: numericCast(offset))])<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     return result<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Int : DefaultInitializable {  }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; print((3..&lt;20).concurrentMap { $0 * 2 })<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I had a go at doing that before, using Optional&lt;T&gt; and unwrapping at<br>&gt;&gt;&gt; the end — but it occurred to me that it would be very inefficient for<br>&gt;&gt;&gt; things like Optional&lt;Int&gt;, and introduces more allocations.<br>&gt;&gt; <br>&gt;&gt; Yeah, optional is not really a good choice for that application.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; If you don&#39;t want the DefaultInitializable requirement (or some other<br>&gt;&gt;&gt;&gt; way to prepare initialized elements), you&#39;ll need to manage memory<br>&gt;&gt;&gt;&gt; yourself:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension RandomAccessCollection {<br>&gt;&gt;&gt;&gt;   func concurrentMap&lt;T&gt;(_ transform: (Iterator.Element)-&gt;T) -&gt; [T] {<br>&gt;&gt;&gt;&gt;     let n = numericCast(self.count) as Int<br>&gt;&gt;&gt;&gt;     let p = UnsafeMutablePointer&lt;T&gt;.allocate(capacity: n)<br>&gt;&gt;&gt;&gt;     defer { p.deallocate(capacity: n) }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     DispatchQueue.concurrentPerform(iterations: n) {<br>&gt;&gt;&gt;&gt;       offset in<br>&gt;&gt;&gt;&gt;       (p + offset).initialize(<br>&gt;&gt;&gt;&gt;         to: transform(<br>&gt;&gt;&gt;&gt;           self[index(startIndex, offsetBy: numericCast(offset))]))<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     return Array(UnsafeMutableBufferPointer(start: p, count: n))<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This posting highlights a couple of weaknesses in the standard library<br>&gt;&gt;&gt;&gt; for which I&#39;d appreciate bug reports:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. No way to arbitrarily initialize an Array&#39;s storage.<br>&gt;&gt;&gt;&gt; 2. UnsafeMutableBufferPointer doesn&#39;t have an allocating init<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; Filed:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. https://bugs.swift.org/browse/SR-3087 &lt;https://bugs.swift.org/browse/SR-3087&gt;<br>&gt;&gt;&gt; 2. https://bugs.swift.org/browse/SR-3088 &lt;https://bugs.swift.org/browse/SR-3088&gt;<br>&gt;&gt; <br>&gt;&gt; Thanks for these!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What is your opinion on the corelibs extending the standard library<br>&gt;&gt;&gt; types? <br>&gt;&gt;&gt; Foundation does it to provide APIs from NSString, but it’s kind of a<br>&gt;&gt;&gt; special case. <br>&gt;&gt; <br>&gt;&gt; My opinion is that, *as a rule*, frameworks should avoid extending APIs<br>&gt;&gt; from other frameworks; it makes it very hard for the author of the<br>&gt;&gt; original type to manage the user experience of her type.  But there are<br>&gt;&gt; exceptions to every rule ;-)<br>&gt;&gt; <br>&gt;&gt;&gt; Would it be reasonable for Dispatch (which is not _such_ a special<br>&gt;&gt;&gt; case) to also extend types like Range and Collection?<br>&gt;&gt; <br>&gt;&gt; Oh, well now *Collection* is not a type (despite how it&#39;s defined in the<br>&gt;&gt; language); it&#39;s a protocol.  Extending Collection is the best way to<br>&gt;&gt; write generic algorithms over all Collections, so I support that.  But<br>&gt;&gt; it does have to be done very judiciously, because you have to realize<br>&gt;&gt; the API you are providing is going to appear on everything that conforms<br>&gt;&gt; to Collection.<br>&gt;&gt; <br>&gt;&gt;&gt; I quite like the API as an extension on Range. I think it would be a<br>&gt;&gt;&gt; nice addition to Dispatch (once we start allowing additive proposals):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Range where Bound : Strideable, Bound.Stride : SignedInteger {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func concurrentMap&lt;T&gt;(_ transform: (Bound) -&gt; T) -&gt; [T] {<br>&gt;&gt;&gt;    let n        = numericCast(count) as Int<br>&gt;&gt;&gt;    let buffer = UnsafeMutablePointer&lt;T&gt;.allocate(capacity: n)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    DispatchQueue.concurrentPerform(iterations: n) {<br>&gt;&gt;&gt;      (buffer + $0).initialize(to: transform(lowerBound + numericCast($0)))<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    // Unfortunately, the buffer is copied when making it an Array&lt;T&gt;.<br>&gt;&gt;&gt;    defer { buffer.deallocate(capacity: n) }<br>&gt;&gt;&gt;    return Array(UnsafeMutableBufferPointer&lt;T&gt;(start: buffer, count: n))<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Collection {<br>&gt;&gt;&gt;  func concurrentMap&lt;T&gt;(_ transform: (Iterator.Element)-&gt;T) -&gt; [T] {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    // ‘as Range’ because CountableRange is a collection, causing the function to be recursive.<br>&gt;&gt;&gt;    return ((0..&lt;numericCast(count)) as Range).concurrentMap {<br>&gt;&gt;&gt;      transform(self[index(startIndex, offsetBy: numericCast($0))])<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I see the beauty in what you&#39;re doing here, but I don&#39;t see any<br>&gt;&gt; advantage to it for users.  Now Range (which will be collapsed with<br>&gt;&gt; CountableRange in Swift 4) will have two overloads of concurrentMap.  In<br>&gt;&gt; general, avoidable overloads are bad for the user experience.<br>&gt;&gt; <br>&gt;&gt; HTH,<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;<br>&gt; Notwithstanding your comment about `collection.parallel.map { }.filter<br>&gt; {}`, the issue here is with the literal being interpreted as<br>&gt; CountableRange. <br></p><p>Not to be blunt, but I don&#39;t see how that&#39;s the central issue at all.<br></p><p>&gt; That can be really annoying in general, and I’m glad the different<br>&gt; Range types are going away.<br></p><p>Me too.  Give me the compiler features I need, and I&#39;ll give you<br>beautiful, pleasurable APIs.<br></p><p>&gt; If Range conditionally conforms to Collection (say, when its Bound is<br>&gt; Strideable), then `(0..&lt;5).concurrentMap {}` should still call the<br>&gt; function on Range because it’s “more specialised”, isn&#39;t that correct?<br></p><p>Yes, but it wouldn&#39;t prevent the user from seeing two overloads for<br>concurrentMap.<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
