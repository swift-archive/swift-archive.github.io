<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06130940a44c84dfc6c5aeabfd8482f8?s=50"></div><header><strong>Advice on SR-580?</strong> from <string>Timothy Wood</string> &lt;tjw at me.com&gt;<p>March 18, 2016 at 02:00:00pm</p></header><div class="content"><p>Looking through the ‘StarterBug’ tag, I started looking into &lt;https://bugs.swift.org/browse/SR-580 &lt;https://bugs.swift.org/browse/SR-580&gt;&gt;, in which:<br></p><p>func foo(x: Int) -&gt; Int {<br> var result = x + 1<br>#if NOT_ENABLED<br> _ = result<br>#endif<br> return result<br>}<br></p><p>does not warn that “result&quot; was never written to.<br></p><p>The immediate cause seems to be in lib/Sema/MiscDiagnostics.cpp, in VarDeclUsageChecker::handleIfConfig(). This code walks the inactive #if blocks and does:<br></p><p>     // If we see a bound reference to a decl in an inactive #if block, then<br>     // conservatively mark it read and written.  This will silence &quot;variable<br>     // unused&quot; and &quot;could be marked let&quot; warnings for it.<br>     if (auto *DRE = dyn_cast&lt;DeclRefExpr&gt;(E)) {<br>       VDUC.addMark(DRE-&gt;getDecl(), RK_Read|RK_Written);<br>     }<br></p><p>In trying to replace that with something that really walks the Expr (by calling VDUC.walkToExprPre() instead or something of the like), I run into a bunch of checks like this:<br></p><p> // Sema leaves some subexpressions null, which seems really unfortunate.  It<br> // should replace them with ErrorExpr.<br> if (E == nullptr || !E-&gt;getType() || E-&gt;getType()-&gt;is&lt;ErrorType&gt;()) {<br>   sawError = true;<br>   return;<br> }<br></p><p>And, if I dump the AST for the test case, it has this section with all sorts of nulls:<br></p><p>     (#if_stmt<br>       (#if:<br>         (unresolved_decl_ref_expr type=&#39;&lt;null&gt;&#39; name=NOT_ENABLED specialized=no)<br>         (elements<br>           (sequence_expr type=&#39;&lt;null&gt;&#39;<br>             (discard_assignment_expr type=&#39;&lt;null&gt;&#39;)<br>             (assign_expr<br>               (**NULL EXPRESSION**)<br>               (**NULL EXPRESSION**))<br>             (declref_expr type=&#39;&lt;null&gt;&#39; decl=main.(file).func decl.qqq@/Users/bungi/Desktop/SR-580.swift:2:7 specialized=yes))))<br></p><p>Presumably VarDeclUsageChecker::handleIfConfig() could pass the right subset of RK_Read|RK_Written if the declref_expr had its accessType set, or maybe a more complete AST that could be walked.<br></p><p>So, then I started looking into places that look for IfConfig{Stmt,Decl} and bail, and found ASTWalker.cpp’s Traversal::visitIfConfigStmt(), and TypeCheckStmt.cpp’s visitIfConfigStmt(). I hacked in a walk() call in the Traversal case and broke all sorts of stuff (maybe since I didn’t do something similar in TypeCheckStmt.cpp). That was about the point that I thought I’d ask if I’m digging in the wrong spot =)<br></p><p>Presumably making more work get done for inactive #if branches will slow down the compiler some (hopefully the percentage of existing code inside a #if block at all is pretty low). But, worse, I can imaging there is a ton of other stuff in them that will cause errors if more of the compiler runs on them (whole missing types, selectors, …).<br></p><p>Is this direction even worth pursuing? Maybe I should look into whether there is a quicker way to get the access type of the declref_expr set when it is being created during the inactive #if parsing?<br></p><p>Thanks!<br></p><p>-tim<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160318/960da6ee/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/caa7226ca750e974668243476ffbafd5?s=50"></div><header><strong>Advice on SR-580?</strong> from <string>Greg Titus</string> &lt;greg at omnigroup.com&gt;<p>March 18, 2016 at 02:00:00pm</p></header><div class="content"><p>Tim,<br></p><p>FWIW, I think that one got incorrectly marked as a starter bug. I don’t think the bug is fixable as written. You are right about the immediate cause, and I think that the only thing we _can_ do is mark it conservatively, because that part of the code isn’t type-checked at all, and probably can’t be, if it is #if’d out due to it being for some other version of Swift. That variable could be passed to mutable functions or operators which don’t actually exist in this version of Swift, so there’s no knowing for certain whether it’s actually read or written.<br></p><p>	- Greg<br></p><p>&gt; On Mar 18, 2016, at 2:18 PM, Timothy Wood via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Looking through the ‘StarterBug’ tag, I started looking into &lt;https://bugs.swift.org/browse/SR-580 &lt;https://bugs.swift.org/browse/SR-580&gt;&gt;, in which:<br>&gt; <br>&gt; func foo(x: Int) -&gt; Int {<br>&gt;  var result = x + 1<br>&gt; #if NOT_ENABLED<br>&gt;  _ = result<br>&gt; #endif<br>&gt;  return result<br>&gt; }<br>&gt; <br>&gt; does not warn that “result&quot; was never written to.<br>&gt; <br>&gt; The immediate cause seems to be in lib/Sema/MiscDiagnostics.cpp, in VarDeclUsageChecker::handleIfConfig(). This code walks the inactive #if blocks and does:<br>&gt; <br>&gt;      // If we see a bound reference to a decl in an inactive #if block, then<br>&gt;      // conservatively mark it read and written.  This will silence &quot;variable<br>&gt;      // unused&quot; and &quot;could be marked let&quot; warnings for it.<br>&gt;      if (auto *DRE = dyn_cast&lt;DeclRefExpr&gt;(E)) {<br>&gt;        VDUC.addMark(DRE-&gt;getDecl(), RK_Read|RK_Written);<br>&gt;      }<br>&gt; <br>&gt; In trying to replace that with something that really walks the Expr (by calling VDUC.walkToExprPre() instead or something of the like), I run into a bunch of checks like this:<br>&gt; <br>&gt;  // Sema leaves some subexpressions null, which seems really unfortunate.  It<br>&gt;  // should replace them with ErrorExpr.<br>&gt;  if (E == nullptr || !E-&gt;getType() || E-&gt;getType()-&gt;is&lt;ErrorType&gt;()) {<br>&gt;    sawError = true;<br>&gt;    return;<br>&gt;  }<br>&gt; <br>&gt; And, if I dump the AST for the test case, it has this section with all sorts of nulls:<br>&gt; <br>&gt;      (#if_stmt<br>&gt;        (#if:<br>&gt;          (unresolved_decl_ref_expr type=&#39;&lt;null&gt;&#39; name=NOT_ENABLED specialized=no)<br>&gt;          (elements<br>&gt;            (sequence_expr type=&#39;&lt;null&gt;&#39;<br>&gt;              (discard_assignment_expr type=&#39;&lt;null&gt;&#39;)<br>&gt;              (assign_expr<br>&gt;                (**NULL EXPRESSION**)<br>&gt;                (**NULL EXPRESSION**))<br>&gt;              (declref_expr type=&#39;&lt;null&gt;&#39; decl=main.(file).func decl.qqq@/Users/bungi/Desktop/SR-580.swift:2:7 specialized=yes))))<br>&gt; <br>&gt; Presumably VarDeclUsageChecker::handleIfConfig() could pass the right subset of RK_Read|RK_Written if the declref_expr had its accessType set, or maybe a more complete AST that could be walked.<br>&gt; <br>&gt; So, then I started looking into places that look for IfConfig{Stmt,Decl} and bail, and found ASTWalker.cpp’s Traversal::visitIfConfigStmt(), and TypeCheckStmt.cpp’s visitIfConfigStmt(). I hacked in a walk() call in the Traversal case and broke all sorts of stuff (maybe since I didn’t do something similar in TypeCheckStmt.cpp). That was about the point that I thought I’d ask if I’m digging in the wrong spot =)<br>&gt; <br>&gt; Presumably making more work get done for inactive #if branches will slow down the compiler some (hopefully the percentage of existing code inside a #if block at all is pretty low). But, worse, I can imaging there is a ton of other stuff in them that will cause errors if more of the compiler runs on them (whole missing types, selectors, …).<br>&gt; <br>&gt; Is this direction even worth pursuing? Maybe I should look into whether there is a quicker way to get the access type of the declref_expr set when it is being created during the inactive #if parsing?<br>&gt; <br>&gt; Thanks!<br>&gt; <br>&gt; -tim<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160318/e5ebf3f8/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
