<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 22, 2016 at 07:00:00pm</p></header><div class="content"><p>on Fri Jul 22 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Jul 22, 2016, at 8:37 PM, Xiaodi Wu via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Fri, Jul 22, 2016 at 8:20 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; on Fri Jul 22 2016, Daniel Duan<br>&gt;&gt; &gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt; &lt;mailto:swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; think this is about identity.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt;&gt; &gt;&gt;&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better name.<br>&gt;&gt; &gt;&gt;&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt;&gt; &gt;&gt;&gt;&gt; benefit.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t consider<br>&gt;&gt; &gt;&gt;&gt; them part of their *identity*. I can follow this logic. My fear is most users<br>&gt;&gt; &gt;&gt;&gt; won’t make this leap on their own and get the same initial impression as I did.<br>&gt;&gt; &gt;&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated bikesheding<br>&gt;&gt; &gt;&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt;&gt; &gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt;&gt; &gt;&gt; it with ===.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; To spell this out (because I had to think about it for a second): === will be derived from<br>&gt;&gt; &gt; &lt;=&gt;,<br>&gt;&gt; &gt; but also becomes default implementation for ==, which remains open for<br>&gt;&gt; &gt; customization.<br>&gt;&gt; <br>&gt;&gt; I was imagining roughly this (untested):<br>&gt;&gt; <br>&gt;&gt;   /// Two references are identical if they refer to the same<br>&gt;&gt;   /// instance.<br>&gt;&gt;   ///<br>&gt;&gt;   /// - Note: Classes with a more-refined notion of “identical”<br>&gt;&gt;   ///   should conform to `Identifiable` and implement `===`.<br>&gt;&gt;   func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt;&gt;     ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   /// Supports testing that two values of `Self` are identical<br>&gt;&gt;   ///<br>&gt;&gt;   /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt;&gt;   /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;   /// type can document that specific observable characteristics<br>&gt;&gt;   /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;   /// thus not to be considered as part of the interchangeability<br>&gt;&gt;   /// guarantee.<br>&gt;&gt;   ///<br>&gt;&gt;   /// - Requires: `===` induces an equivalence relation over<br>&gt;&gt;   ///   instances.<br>&gt;&gt;   /// - Note: conforming types will gain an `==` operator that<br>&gt;&gt;   ///   forwards to `===`.<br>&gt;&gt;   /// - Note: Types that require domain-specific `==`<br>&gt;&gt;   ///   implementations with different semantics (e.g. floating<br>&gt;&gt;   ///   point) should define a more-specific overload of `==`,<br>&gt;&gt;   ///   which will be used in contexts where the static type is<br>&gt;&gt;   ///   known to the compiler.<br>&gt;&gt;   /// - Note: Generic code should usually use `==` to compare<br>&gt;&gt;   ///   conforming instances; that will always dispatch to `===`<br>&gt;&gt;   ///   and will be unaffected by more specific overloads of<br>&gt;&gt;   ///   `==`.<br>&gt;&gt;   protocol Identifiable { // née Equatable name is negotiable<br>&gt;&gt;     func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   /// Default definition of `==` for Identifiable types.<br>&gt;&gt;   func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;     return lhs === rhs<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   /// Conforming types have a default total ordering.<br>&gt;&gt;   ///<br>&gt;&gt;   /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt;&gt;   /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;   /// type can document that specific observable characteristics<br>&gt;&gt;   /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;   /// thus not to be considered as part of the interchangeability<br>&gt;&gt;   /// guarantee.<br>&gt;&gt;   ///<br>&gt;&gt;   /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt;&gt;   ///   instances.<br>&gt;&gt;   /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt;&gt;   ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent`<br>&gt;&gt;   ///   iff `a === b`.<br>&gt;&gt; <br>&gt;&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same` *but not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the sign of zero (so +0 = −0)”.<br>&gt;<br>&gt; The point of this design is that `===` means identity and that `.same ` also means identity.<br>&gt;<br>&gt; Since this is new territory I suppose we get to decide what identity<br>&gt; means for floating point.  Should +0 and -0 have the same identity or<br>&gt; not?  I’ll leave the answer to folks more knowledgable about numerics<br>&gt; than I.<br></p><p>It&#39;s settled law <br>https://en.wikipedia.org/wiki/IEEE_floating_point#Total-ordering_predicate<br>:-)<br></p><p>&gt;<br>&gt;<br>&gt;&gt;  <br>&gt;&gt;   /// - Note: conforming types will gain `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`<br>&gt;&gt;   ///   operators defined in terms of `&lt;=&gt;`.<br>&gt;&gt;   /// - Note: Types that require domain-specific `&lt;`, etc.<br>&gt;&gt;   ///   implementations with different semantics (e.g. floating<br>&gt;&gt;   ///   point) should define more-specific overloads of those<br>&gt;&gt;   ///   operators, which will be used in contexts where the<br>&gt;&gt;   ///   static type is known to the compiler.<br>&gt;&gt;   /// - Note: Generic code can freely use `&lt;=&gt;` or the traditional<br>&gt;&gt;   ///   comparison operators to compare conforming instances;<br>&gt;&gt;   ///   the result will always be supplied by `&lt;=&gt;`<br>&gt;&gt;   ///   and will be unaffected by more specific overloads of<br>&gt;&gt;   ///   the other operators.<br>&gt;&gt;   protocol Comparable : Identifiable {<br>&gt;&gt;     func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   /// Default implementations of `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`.<br>&gt;&gt;   extension Comparable {<br>&gt;&gt;     static func &lt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;       return (lhs &lt;=&gt; rhs) == .ascending<br>&gt;&gt;     }<br>&gt;&gt;     static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;       return (rhs &lt;=&gt; lhs) != .ascending<br>&gt;&gt;     }<br>&gt;&gt;     static func &gt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;       return (lhs &lt;=&gt; rhs) == .descending<br>&gt;&gt;     }<br>&gt;&gt;     static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;       return (rhs &lt;=&gt; lhs) != .descending<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; &gt; I like this idea. If we keep === as a separate thing, now users have 3 “opportunities” to define<br>&gt;&gt; &gt; equality. The must be few, if any, use cases for this.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Would love to see if anyone on the list can give us an example. Otherwise we should make<br>&gt;&gt; &gt; areSame === again™!<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Daniel Duan<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;xiaodi.wu at gmail.com<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:xiaodi.wu at gmail.com&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; This is nice. Is `areSame()` being proposed because static `==` is<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; the status quo and you&#39;re trying to make the point that `==` in the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; future need not guarantee the same semantics?<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Nit: I think the more common term in stdlib would be<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; `areEquivalent()`. Do you think `same` in that context (independent<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; of the word &quot;ordering&quot;) might erroneously suggest identity?<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift Community,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposal to clean up the semantics of ordering relations in the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; standard library.  We have a draft that you can get as a gist.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any feedback you might have about this proposal helps - though<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; please keeps your comments on Swift-Evolution and not on the gist.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; --<br>&gt;&gt; &gt;&gt;&gt;&gt; Dave<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; --<br>&gt;&gt; &gt;&gt; Dave<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt; &lt;mailto:swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 22, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jul 22, 2016, at 9:04 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Jul 22 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jul 22, 2016, at 8:37 PM, Xiaodi Wu via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Fri, Jul 22, 2016 at 8:20 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org &lt;http://daniel-at-duan.org/&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Fri Jul 22 2016, Daniel Duan<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think this is about identity.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better name.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; benefit.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t consider<br>&gt;&gt;&gt;&gt;&gt;&gt; them part of their *identity*. I can follow this logic. My fear is most users<br>&gt;&gt;&gt;&gt;&gt;&gt; won’t make this leap on their own and get the same initial impression as I did.<br>&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated bikesheding<br>&gt;&gt;&gt;&gt;&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt;&gt;&gt;&gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt;&gt;&gt;&gt;&gt; it with ===.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To spell this out (because I had to think about it for a second): === will be derived from<br>&gt;&gt;&gt;&gt; &lt;=&gt;,<br>&gt;&gt;&gt;&gt; but also becomes default implementation for ==, which remains open for<br>&gt;&gt;&gt;&gt; customization.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was imagining roughly this (untested):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  /// Two references are identical if they refer to the same<br>&gt;&gt;&gt;  /// instance.<br>&gt;&gt;&gt;  ///<br>&gt;&gt;&gt;  /// - Note: Classes with a more-refined notion of “identical”<br>&gt;&gt;&gt;  ///   should conform to `Identifiable` and implement `===`.<br>&gt;&gt;&gt;  func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt;&gt;&gt;    ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  /// Supports testing that two values of `Self` are identical<br>&gt;&gt;&gt;  ///<br>&gt;&gt;&gt;  /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt;&gt;&gt;  /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;&gt;  /// type can document that specific observable characteristics<br>&gt;&gt;&gt;  /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;&gt;  /// thus not to be considered as part of the interchangeability<br>&gt;&gt;&gt;  /// guarantee.<br>&gt;&gt;&gt;  ///<br>&gt;&gt;&gt;  /// - Requires: `===` induces an equivalence relation over<br>&gt;&gt;&gt;  ///   instances.<br>&gt;&gt;&gt;  /// - Note: conforming types will gain an `==` operator that<br>&gt;&gt;&gt;  ///   forwards to `===`.<br>&gt;&gt;&gt;  /// - Note: Types that require domain-specific `==`<br>&gt;&gt;&gt;  ///   implementations with different semantics (e.g. floating<br>&gt;&gt;&gt;  ///   point) should define a more-specific overload of `==`,<br>&gt;&gt;&gt;  ///   which will be used in contexts where the static type is<br>&gt;&gt;&gt;  ///   known to the compiler.<br>&gt;&gt;&gt;  /// - Note: Generic code should usually use `==` to compare<br>&gt;&gt;&gt;  ///   conforming instances; that will always dispatch to `===`<br>&gt;&gt;&gt;  ///   and will be unaffected by more specific overloads of<br>&gt;&gt;&gt;  ///   `==`.<br>&gt;&gt;&gt;  protocol Identifiable { // née Equatable name is negotiable<br>&gt;&gt;&gt;    func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  /// Default definition of `==` for Identifiable types.<br>&gt;&gt;&gt;  func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;&gt;    return lhs === rhs<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  /// Conforming types have a default total ordering.<br>&gt;&gt;&gt;  ///<br>&gt;&gt;&gt;  /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt;&gt;&gt;  /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;&gt;  /// type can document that specific observable characteristics<br>&gt;&gt;&gt;  /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;&gt;  /// thus not to be considered as part of the interchangeability<br>&gt;&gt;&gt;  /// guarantee.<br>&gt;&gt;&gt;  ///<br>&gt;&gt;&gt;  /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt;&gt;&gt;  ///   instances.<br>&gt;&gt;&gt;  /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt;&gt;&gt;  ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent`<br>&gt;&gt;&gt;  ///   iff `a === b`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same` *but not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the sign of zero (so +0 = −0)”.<br>&gt;&gt; <br>&gt;&gt; The point of this design is that `===` means identity and that `.same ` also means identity.<br>&gt;&gt; <br>&gt;&gt; Since this is new territory I suppose we get to decide what identity<br>&gt;&gt; means for floating point.  Should +0 and -0 have the same identity or<br>&gt;&gt; not?  I’ll leave the answer to folks more knowledgable about numerics<br>&gt;&gt; than I.<br>&gt; <br>&gt; It&#39;s settled law <br>&gt; https://en.wikipedia.org/wiki/IEEE_floating_point#Total-ordering_predicate &lt;https://en.wikipedia.org/wiki/IEEE_floating_point#Total-ordering_predicate&gt;<br>&gt; :-)<br></p><p>Yes, assuming we want to define identity in terms of the IEEE definition of total ordering.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  /// - Note: conforming types will gain `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`<br>&gt;&gt;&gt;  ///   operators defined in terms of `&lt;=&gt;`.<br>&gt;&gt;&gt;  /// - Note: Types that require domain-specific `&lt;`, etc.<br>&gt;&gt;&gt;  ///   implementations with different semantics (e.g. floating<br>&gt;&gt;&gt;  ///   point) should define more-specific overloads of those<br>&gt;&gt;&gt;  ///   operators, which will be used in contexts where the<br>&gt;&gt;&gt;  ///   static type is known to the compiler.<br>&gt;&gt;&gt;  /// - Note: Generic code can freely use `&lt;=&gt;` or the traditional<br>&gt;&gt;&gt;  ///   comparison operators to compare conforming instances;<br>&gt;&gt;&gt;  ///   the result will always be supplied by `&lt;=&gt;`<br>&gt;&gt;&gt;  ///   and will be unaffected by more specific overloads of<br>&gt;&gt;&gt;  ///   the other operators.<br>&gt;&gt;&gt;  protocol Comparable : Identifiable {<br>&gt;&gt;&gt;    func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  /// Default implementations of `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`.<br>&gt;&gt;&gt;  extension Comparable {<br>&gt;&gt;&gt;    static func &lt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;      return (lhs &lt;=&gt; rhs) == .ascending<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt;    static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;      return (rhs &lt;=&gt; lhs) != .ascending<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt;    static func &gt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;      return (lhs &lt;=&gt; rhs) == .descending<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt;    static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;      return (rhs &lt;=&gt; lhs) != .descending<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I like this idea. If we keep === as a separate thing, now users have 3 “opportunities” to define<br>&gt;&gt;&gt;&gt; equality. The must be few, if any, use cases for this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Would love to see if anyone on the list can give us an example. Otherwise we should make<br>&gt;&gt;&gt;&gt; areSame === again™!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel Duan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is nice. Is `areSame()` being proposed because static `==` is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the status quo and you&#39;re trying to make the point that `==` in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; future need not guarantee the same semantics?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Nit: I think the more common term in stdlib would be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `areEquivalent()`. Do you think `same` in that context (independent<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the word &quot;ordering&quot;) might erroneously suggest identity?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift Community,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposal to clean up the semantics of ordering relations in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; standard library.  We have a draft that you can get as a gist.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any feedback you might have about this proposal helps - though<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; please keeps your comments on Swift-Evolution and not on the gist.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Dave<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/6194d10f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 22, 2016 at 09:00:00pm</p></header><div class="content"><p>On Fri, Jul 22, 2016 at 9:15 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jul 22, 2016, at 9:04 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; on Fri Jul 22 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Jul 22, 2016, at 8:37 PM, Xiaodi Wu via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Fri, Jul 22, 2016 at 8:20 PM, Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org<br>&gt;<br>&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt; wrote:<br>&gt;<br>&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org<br>&gt; &lt;http://daniel-at-duan.org/&gt;&gt; wrote:<br>&gt;<br>&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt; on Fri Jul 22 2016, Daniel Duan<br>&gt; &lt;swift-evolution at swift.org<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt; on Thu Jul 21 2016, Duan<br>&gt;<br>&gt;<br>&gt; &lt;swift-evolution at swift.org<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;&gt;&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt; think this is about identity.<br>&gt;<br>&gt; I like areEquivalent() but there may be better names.<br>&gt;<br>&gt;<br>&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt; that doesn&#39;t change the fact that areEquivalent might be a better name.<br>&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt; benefit.<br>&gt;<br>&gt;<br>&gt; If the addresses of the arguments aren’t being used, then we don’t consider<br>&gt; them part of their *identity*. I can follow this logic. My fear is most<br>&gt; users<br>&gt; won’t make this leap on their own and get the same initial impression as I<br>&gt; did.<br>&gt; It&#39;s entirely possible this fear is unfounded. Some educated bikesheding<br>&gt; wouldn&#39;t hurt here IMO :)<br>&gt;<br>&gt;<br>&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt; it with ===.<br>&gt;<br>&gt;<br>&gt; To spell this out (because I had to think about it for a second): === will<br>&gt; be derived from<br>&gt; &lt;=&gt;,<br>&gt; but also becomes default implementation for ==, which remains open for<br>&gt; customization.<br>&gt;<br>&gt;<br>&gt; I was imagining roughly this (untested):<br>&gt;<br>&gt;  /// Two references are identical if they refer to the same<br>&gt;  /// instance.<br>&gt;  ///<br>&gt;  /// - Note: Classes with a more-refined notion of “identical”<br>&gt;  ///   should conform to `Identifiable` and implement `===`.<br>&gt;  func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt;    ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt;  }<br>&gt;<br>&gt;  /// Supports testing that two values of `Self` are identical<br>&gt;  ///<br>&gt;  /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt;  /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;  /// type can document that specific observable characteristics<br>&gt;  /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;  /// thus not to be considered as part of the interchangeability<br>&gt;  /// guarantee.<br>&gt;  ///<br>&gt;  /// - Requires: `===` induces an equivalence relation over<br>&gt;  ///   instances.<br>&gt;  /// - Note: conforming types will gain an `==` operator that<br>&gt;  ///   forwards to `===`.<br>&gt;  /// - Note: Types that require domain-specific `==`<br>&gt;  ///   implementations with different semantics (e.g. floating<br>&gt;  ///   point) should define a more-specific overload of `==`,<br>&gt;  ///   which will be used in contexts where the static type is<br>&gt;  ///   known to the compiler.<br>&gt;  /// - Note: Generic code should usually use `==` to compare<br>&gt;  ///   conforming instances; that will always dispatch to `===`<br>&gt;  ///   and will be unaffected by more specific overloads of<br>&gt;  ///   `==`.<br>&gt;  protocol Identifiable { // née Equatable name is negotiable<br>&gt;    func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt;  }<br>&gt;<br>&gt;  /// Default definition of `==` for Identifiable types.<br>&gt;  func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;    return lhs === rhs<br>&gt;  }<br>&gt;<br>&gt;  /// Conforming types have a default total ordering.<br>&gt;  ///<br>&gt;  /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt;  /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;  /// type can document that specific observable characteristics<br>&gt;  /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;  /// thus not to be considered as part of the interchangeability<br>&gt;  /// guarantee.<br>&gt;  ///<br>&gt;  /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt;  ///   instances.<br>&gt;  /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt;  ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent`<br>&gt;  ///   iff `a === b`.<br>&gt;<br>&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same` *but<br>&gt; not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the sign<br>&gt; of zero (so +0 = −0)”.<br>&gt;<br>&gt;<br>&gt; The point of this design is that `===` means identity and that `.same `<br>&gt; also means identity.<br>&gt;<br>&gt; Since this is new territory I suppose we get to decide what identity<br>&gt; means for floating point.  Should +0 and -0 have the same identity or<br>&gt; not?  I’ll leave the answer to folks more knowledgable about numerics<br>&gt; than I.<br>&gt;<br>&gt;<br>&gt; It&#39;s settled law<br>&gt; https://en.wikipedia.org/wiki/IEEE_floating_point#Total-ordering_predicate<br>&gt; :-)<br>&gt;<br>&gt;<br>&gt; Yes, assuming we want to define identity in terms of the IEEE definition<br>&gt; of total ordering.<br>&gt;<br></p><p>I see what you&#39;re saying here. That could work. Comparable `===` and<br>Equatable `&lt;=&gt;` could do its own thing, and FloatingPoint<br>`isTotallyOrdered(below:)` can preserve the IEEE definition of total<br>ordering.<br></p><p><br>&gt;  /// - Note: conforming types will gain `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`<br>&gt;  ///   operators defined in terms of `&lt;=&gt;`.<br>&gt;  /// - Note: Types that require domain-specific `&lt;`, etc.<br>&gt;  ///   implementations with different semantics (e.g. floating<br>&gt;  ///   point) should define more-specific overloads of those<br>&gt;  ///   operators, which will be used in contexts where the<br>&gt;  ///   static type is known to the compiler.<br>&gt;  /// - Note: Generic code can freely use `&lt;=&gt;` or the traditional<br>&gt;  ///   comparison operators to compare conforming instances;<br>&gt;  ///   the result will always be supplied by `&lt;=&gt;`<br>&gt;  ///   and will be unaffected by more specific overloads of<br>&gt;  ///   the other operators.<br>&gt;  protocol Comparable : Identifiable {<br>&gt;    func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;  }<br>&gt;<br>&gt;  /// Default implementations of `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`.<br>&gt;  extension Comparable {<br>&gt;    static func &lt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;      return (lhs &lt;=&gt; rhs) == .ascending<br>&gt;    }<br>&gt;    static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;      return (rhs &lt;=&gt; lhs) != .ascending<br>&gt;    }<br>&gt;    static func &gt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;      return (lhs &lt;=&gt; rhs) == .descending<br>&gt;    }<br>&gt;    static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;      return (rhs &lt;=&gt; lhs) != .descending<br>&gt;    }<br>&gt;  }<br>&gt;<br>&gt; I like this idea. If we keep === as a separate thing, now users have 3<br>&gt; “opportunities” to define<br>&gt; equality. The must be few, if any, use cases for this.<br>&gt;<br>&gt; Would love to see if anyone on the list can give us an example. Otherwise<br>&gt; we should make<br>&gt; areSame === again™!<br>&gt;<br>&gt;<br>&gt; Daniel Duan<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution<br>&gt; &lt;swift-evolution at swift.org<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu<br>&gt; &lt;xiaodi.wu at gmail.com<br>&gt; &lt;mailto:xiaodi.wu at gmail.com &lt;xiaodi.wu at gmail.com&gt;&gt;&gt;<br>&gt; wrote:<br>&gt;<br>&gt; This is nice. Is `areSame()` being proposed because static `==` is<br>&gt; the status quo and you&#39;re trying to make the point that `==` in the<br>&gt; future need not guarantee the same semantics?<br>&gt;<br>&gt;<br>&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt;<br>&gt;<br>&gt; Nit: I think the more common term in stdlib would be<br>&gt; `areEquivalent()`. Do you think `same` in that context (independent<br>&gt; of the word &quot;ordering&quot;) might erroneously suggest identity?<br>&gt;<br>&gt;<br>&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via<br>&gt; swift-evolution<br>&gt; &lt;swift-evolution at swift.org<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt; wrote:<br>&gt; Hello Swift Community,<br>&gt;<br>&gt; Harlan Haskins, Jaden Geller, and I have been working on a<br>&gt; proposal to clean up the semantics of ordering relations in the<br>&gt; standard library.  We have a draft that you can get as a gist.<br>&gt; Any feedback you might have about this proposal helps - though<br>&gt; please keeps your comments on Swift-Evolution and not on the gist.<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/f3c8799c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 22, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jul 22, 2016, at 9:17 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Jul 22, 2016 at 9:15 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 22, 2016, at 9:04 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Jul 22 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 22, 2016, at 8:37 PM, Xiaodi Wu via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Fri, Jul 22, 2016 at 8:20 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org &lt;http://daniel-at-duan.org/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Fri Jul 22 2016, Daniel Duan<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think this is about identity.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better name.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; benefit.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t consider<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; them part of their *identity*. I can follow this logic. My fear is most users<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; won’t make this leap on their own and get the same initial impression as I did.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated bikesheding<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt;&gt;&gt;&gt;&gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt;&gt;&gt;&gt;&gt;&gt; it with ===.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To spell this out (because I had to think about it for a second): === will be derived from<br>&gt;&gt;&gt;&gt;&gt; &lt;=&gt;,<br>&gt;&gt;&gt;&gt;&gt; but also becomes default implementation for ==, which remains open for<br>&gt;&gt;&gt;&gt;&gt; customization.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I was imagining roughly this (untested):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  /// Two references are identical if they refer to the same<br>&gt;&gt;&gt;&gt;  /// instance.<br>&gt;&gt;&gt;&gt;  ///<br>&gt;&gt;&gt;&gt;  /// - Note: Classes with a more-refined notion of “identical”<br>&gt;&gt;&gt;&gt;  ///   should conform to `Identifiable` and implement `===`.<br>&gt;&gt;&gt;&gt;  func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt;&gt;&gt;&gt;    ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  /// Supports testing that two values of `Self` are identical<br>&gt;&gt;&gt;&gt;  ///<br>&gt;&gt;&gt;&gt;  /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt;&gt;&gt;&gt;  /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;&gt;&gt;  /// type can document that specific observable characteristics<br>&gt;&gt;&gt;&gt;  /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;&gt;&gt;  /// thus not to be considered as part of the interchangeability<br>&gt;&gt;&gt;&gt;  /// guarantee.<br>&gt;&gt;&gt;&gt;  ///<br>&gt;&gt;&gt;&gt;  /// - Requires: `===` induces an equivalence relation over<br>&gt;&gt;&gt;&gt;  ///   instances.<br>&gt;&gt;&gt;&gt;  /// - Note: conforming types will gain an `==` operator that<br>&gt;&gt;&gt;&gt;  ///   forwards to `===`.<br>&gt;&gt;&gt;&gt;  /// - Note: Types that require domain-specific `==`<br>&gt;&gt;&gt;&gt;  ///   implementations with different semantics (e.g. floating<br>&gt;&gt;&gt;&gt;  ///   point) should define a more-specific overload of `==`,<br>&gt;&gt;&gt;&gt;  ///   which will be used in contexts where the static type is<br>&gt;&gt;&gt;&gt;  ///   known to the compiler.<br>&gt;&gt;&gt;&gt;  /// - Note: Generic code should usually use `==` to compare<br>&gt;&gt;&gt;&gt;  ///   conforming instances; that will always dispatch to `===`<br>&gt;&gt;&gt;&gt;  ///   and will be unaffected by more specific overloads of<br>&gt;&gt;&gt;&gt;  ///   `==`.<br>&gt;&gt;&gt;&gt;  protocol Identifiable { // née Equatable name is negotiable<br>&gt;&gt;&gt;&gt;    func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  /// Default definition of `==` for Identifiable types.<br>&gt;&gt;&gt;&gt;  func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;&gt;&gt;    return lhs === rhs<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  /// Conforming types have a default total ordering.<br>&gt;&gt;&gt;&gt;  ///<br>&gt;&gt;&gt;&gt;  /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt;&gt;&gt;&gt;  /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;&gt;&gt;  /// type can document that specific observable characteristics<br>&gt;&gt;&gt;&gt;  /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;&gt;&gt;  /// thus not to be considered as part of the interchangeability<br>&gt;&gt;&gt;&gt;  /// guarantee.<br>&gt;&gt;&gt;&gt;  ///<br>&gt;&gt;&gt;&gt;  /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt;&gt;&gt;&gt;  ///   instances.<br>&gt;&gt;&gt;&gt;  /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt;&gt;&gt;&gt;  ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent`<br>&gt;&gt;&gt;&gt;  ///   iff `a === b`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same` *but not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the sign of zero (so +0 = −0)”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The point of this design is that `===` means identity and that `.same ` also means identity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since this is new territory I suppose we get to decide what identity<br>&gt;&gt;&gt; means for floating point.  Should +0 and -0 have the same identity or<br>&gt;&gt;&gt; not?  I’ll leave the answer to folks more knowledgable about numerics<br>&gt;&gt;&gt; than I.<br>&gt;&gt; <br>&gt;&gt; It&#39;s settled law <br>&gt;&gt; https://en.wikipedia.org/wiki/IEEE_floating_point#Total-ordering_predicate &lt;https://en.wikipedia.org/wiki/IEEE_floating_point#Total-ordering_predicate&gt;<br>&gt;&gt; :-)<br>&gt; <br>&gt; Yes, assuming we want to define identity in terms of the IEEE definition of total ordering.<br>&gt; <br>&gt; I see what you&#39;re saying here. That could work. Comparable `===` and Equatable `&lt;=&gt;` could do its own thing, and FloatingPoint `isTotallyOrdered(below:)` can preserve the IEEE definition of total ordering<br></p><p>Actually, I was hinting at your argument that `===` true iff `&lt;=&gt;` same shouldn’t be a semantic requirement of the protocols.<br></p><p>This is another option, but I don’t think it’s going to fly.  It seems reasonable to assume that `&lt;=&gt;` will have IEEE semantics.  We will trip a lot of people up if it doesn’t.  That’s a big reason we can’t consider changing floating point `==` to define an equivalence relation.<br></p><p>&gt; .<br>&gt;  <br>&gt;&gt;&gt;&gt;  /// - Note: conforming types will gain `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`<br>&gt;&gt;&gt;&gt;  ///   operators defined in terms of `&lt;=&gt;`.<br>&gt;&gt;&gt;&gt;  /// - Note: Types that require domain-specific `&lt;`, etc.<br>&gt;&gt;&gt;&gt;  ///   implementations with different semantics (e.g. floating<br>&gt;&gt;&gt;&gt;  ///   point) should define more-specific overloads of those<br>&gt;&gt;&gt;&gt;  ///   operators, which will be used in contexts where the<br>&gt;&gt;&gt;&gt;  ///   static type is known to the compiler.<br>&gt;&gt;&gt;&gt;  /// - Note: Generic code can freely use `&lt;=&gt;` or the traditional<br>&gt;&gt;&gt;&gt;  ///   comparison operators to compare conforming instances;<br>&gt;&gt;&gt;&gt;  ///   the result will always be supplied by `&lt;=&gt;`<br>&gt;&gt;&gt;&gt;  ///   and will be unaffected by more specific overloads of<br>&gt;&gt;&gt;&gt;  ///   the other operators.<br>&gt;&gt;&gt;&gt;  protocol Comparable : Identifiable {<br>&gt;&gt;&gt;&gt;    func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  /// Default implementations of `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`.<br>&gt;&gt;&gt;&gt;  extension Comparable {<br>&gt;&gt;&gt;&gt;    static func &lt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;&gt;      return (lhs &lt;=&gt; rhs) == .ascending<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;    static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;&gt;      return (rhs &lt;=&gt; lhs) != .ascending<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;    static func &gt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;&gt;      return (lhs &lt;=&gt; rhs) == .descending<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;    static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;&gt;      return (rhs &lt;=&gt; lhs) != .descending<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I like this idea. If we keep === as a separate thing, now users have 3 “opportunities” to define<br>&gt;&gt;&gt;&gt;&gt; equality. The must be few, if any, use cases for this.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Would love to see if anyone on the list can give us an example. Otherwise we should make<br>&gt;&gt;&gt;&gt;&gt; areSame === again™!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel Duan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is nice. Is `areSame()` being proposed because static `==` is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the status quo and you&#39;re trying to make the point that `==` in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; future need not guarantee the same semantics?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Nit: I think the more common term in stdlib would be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `areEquivalent()`. Do you think `same` in that context (independent<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the word &quot;ordering&quot;) might erroneously suggest identity?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift Community,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposal to clean up the semantics of ordering relations in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; standard library.  We have a draft that you can get as a gist.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any feedback you might have about this proposal helps - though<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; please keeps your comments on Swift-Evolution and not on the gist.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/9e4f0217/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 22, 2016 at 09:00:00pm</p></header><div class="content"><p>On Fri, Jul 22, 2016 at 9:23 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jul 22, 2016, at 9:17 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Fri, Jul 22, 2016 at 9:15 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 22, 2016, at 9:04 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; on Fri Jul 22 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Jul 22, 2016, at 8:37 PM, Xiaodi Wu via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Fri, Jul 22, 2016 at 8:20 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org<br>&gt;&gt; &lt;http://daniel-at-duan.org/&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; on Fri Jul 22 2016, Daniel Duan<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt;&gt; think this is about identity.<br>&gt;&gt;<br>&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better name.<br>&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt;&gt; benefit.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t<br>&gt;&gt; consider<br>&gt;&gt; them part of their *identity*. I can follow this logic. My fear is most<br>&gt;&gt; users<br>&gt;&gt; won’t make this leap on their own and get the same initial impression as<br>&gt;&gt; I did.<br>&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated bikesheding<br>&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt;&gt; it with ===.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; To spell this out (because I had to think about it for a second): ===<br>&gt;&gt; will be derived from<br>&gt;&gt; &lt;=&gt;,<br>&gt;&gt; but also becomes default implementation for ==, which remains open for<br>&gt;&gt; customization.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I was imagining roughly this (untested):<br>&gt;&gt;<br>&gt;&gt;  /// Two references are identical if they refer to the same<br>&gt;&gt;  /// instance.<br>&gt;&gt;  ///<br>&gt;&gt;  /// - Note: Classes with a more-refined notion of “identical”<br>&gt;&gt;  ///   should conform to `Identifiable` and implement `===`.<br>&gt;&gt;  func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt;&gt;    ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt;&gt;  }<br>&gt;&gt;<br>&gt;&gt;  /// Supports testing that two values of `Self` are identical<br>&gt;&gt;  ///<br>&gt;&gt;  /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt;&gt;  /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;  /// type can document that specific observable characteristics<br>&gt;&gt;  /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;  /// thus not to be considered as part of the interchangeability<br>&gt;&gt;  /// guarantee.<br>&gt;&gt;  ///<br>&gt;&gt;  /// - Requires: `===` induces an equivalence relation over<br>&gt;&gt;  ///   instances.<br>&gt;&gt;  /// - Note: conforming types will gain an `==` operator that<br>&gt;&gt;  ///   forwards to `===`.<br>&gt;&gt;  /// - Note: Types that require domain-specific `==`<br>&gt;&gt;  ///   implementations with different semantics (e.g. floating<br>&gt;&gt;  ///   point) should define a more-specific overload of `==`,<br>&gt;&gt;  ///   which will be used in contexts where the static type is<br>&gt;&gt;  ///   known to the compiler.<br>&gt;&gt;  /// - Note: Generic code should usually use `==` to compare<br>&gt;&gt;  ///   conforming instances; that will always dispatch to `===`<br>&gt;&gt;  ///   and will be unaffected by more specific overloads of<br>&gt;&gt;  ///   `==`.<br>&gt;&gt;  protocol Identifiable { // née Equatable name is negotiable<br>&gt;&gt;    func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt;&gt;  }<br>&gt;&gt;<br>&gt;&gt;  /// Default definition of `==` for Identifiable types.<br>&gt;&gt;  func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;    return lhs === rhs<br>&gt;&gt;  }<br>&gt;&gt;<br>&gt;&gt;  /// Conforming types have a default total ordering.<br>&gt;&gt;  ///<br>&gt;&gt;  /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt;&gt;  /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;  /// type can document that specific observable characteristics<br>&gt;&gt;  /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;  /// thus not to be considered as part of the interchangeability<br>&gt;&gt;  /// guarantee.<br>&gt;&gt;  ///<br>&gt;&gt;  /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt;&gt;  ///   instances.<br>&gt;&gt;  /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt;&gt;  ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent`<br>&gt;&gt;  ///   iff `a === b`.<br>&gt;&gt;<br>&gt;&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same` *but<br>&gt;&gt; not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the sign<br>&gt;&gt; of zero (so +0 = −0)”.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The point of this design is that `===` means identity and that `.same `<br>&gt;&gt; also means identity.<br>&gt;&gt;<br>&gt;&gt; Since this is new territory I suppose we get to decide what identity<br>&gt;&gt; means for floating point.  Should +0 and -0 have the same identity or<br>&gt;&gt; not?  I’ll leave the answer to folks more knowledgable about numerics<br>&gt;&gt; than I.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It&#39;s settled law<br>&gt;&gt; https://en.wikipedia.org/wiki/IEEE_floating_point#Total-ordering_predicate<br>&gt;&gt; :-)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes, assuming we want to define identity in terms of the IEEE definition<br>&gt;&gt; of total ordering.<br>&gt;&gt;<br>&gt;<br>&gt; I see what you&#39;re saying here. That could work. Comparable `===` and<br>&gt; Equatable `&lt;=&gt;` could do its own thing, and FloatingPoint<br>&gt; `isTotallyOrdered(below:)` can preserve the IEEE definition of total<br>&gt; ordering<br>&gt;<br>&gt;<br>&gt; Actually, I was hinting at your argument that `===` true iff `&lt;=&gt;` same<br>&gt; shouldn’t be a semantic requirement of the protocols.<br>&gt;<br>&gt; This is another option, but I don’t think it’s going to fly.  It seems<br>&gt; reasonable to assume that `&lt;=&gt;` will have IEEE semantics.  We will trip a<br>&gt; lot of people up if it doesn’t.  That’s a big reason we can’t consider<br>&gt; changing floating point `==` to define an equivalence relation.<br>&gt;<br></p><p>Actually, here I doubt it. The total ordering isn&#39;t exposed as part of any<br>comparison operator defined in the IEEE spec. In fact, the total ordering<br>wasn&#39;t introduced until a (fairly) recent IEEE revision, IIUC. Breaking<br>`==` would definitely cause people to jump, but `&lt;=&gt;` needn&#39;t be the IEEE<br>totalOrder predicate IMO.<br></p><p><br>&gt;<br>&gt; .<br>&gt;<br>&gt;<br>&gt;&gt;  /// - Note: conforming types will gain `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`<br>&gt;&gt;  ///   operators defined in terms of `&lt;=&gt;`.<br>&gt;&gt;  /// - Note: Types that require domain-specific `&lt;`, etc.<br>&gt;&gt;  ///   implementations with different semantics (e.g. floating<br>&gt;&gt;  ///   point) should define more-specific overloads of those<br>&gt;&gt;  ///   operators, which will be used in contexts where the<br>&gt;&gt;  ///   static type is known to the compiler.<br>&gt;&gt;  /// - Note: Generic code can freely use `&lt;=&gt;` or the traditional<br>&gt;&gt;  ///   comparison operators to compare conforming instances;<br>&gt;&gt;  ///   the result will always be supplied by `&lt;=&gt;`<br>&gt;&gt;  ///   and will be unaffected by more specific overloads of<br>&gt;&gt;  ///   the other operators.<br>&gt;&gt;  protocol Comparable : Identifiable {<br>&gt;&gt;    func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt;  }<br>&gt;&gt;<br>&gt;&gt;  /// Default implementations of `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`.<br>&gt;&gt;  extension Comparable {<br>&gt;&gt;    static func &lt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;      return (lhs &lt;=&gt; rhs) == .ascending<br>&gt;&gt;    }<br>&gt;&gt;    static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;      return (rhs &lt;=&gt; lhs) != .ascending<br>&gt;&gt;    }<br>&gt;&gt;    static func &gt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;      return (lhs &lt;=&gt; rhs) == .descending<br>&gt;&gt;    }<br>&gt;&gt;    static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;      return (rhs &lt;=&gt; lhs) != .descending<br>&gt;&gt;    }<br>&gt;&gt;  }<br>&gt;&gt;<br>&gt;&gt; I like this idea. If we keep === as a separate thing, now users have 3<br>&gt;&gt; “opportunities” to define<br>&gt;&gt; equality. The must be few, if any, use cases for this.<br>&gt;&gt;<br>&gt;&gt; Would love to see if anyone on the list can give us an example. Otherwise<br>&gt;&gt; we should make<br>&gt;&gt; areSame === again™!<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Daniel Duan<br>&gt;&gt; Sent from my iPhone<br>&gt;&gt;<br>&gt;&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu<br>&gt;&gt; &lt;xiaodi.wu at gmail.com<br>&gt;&gt; &lt;mailto:xiaodi.wu at gmail.com &lt;xiaodi.wu at gmail.com&gt;&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; This is nice. Is `areSame()` being proposed because static `==` is<br>&gt;&gt; the status quo and you&#39;re trying to make the point that `==` in the<br>&gt;&gt; future need not guarantee the same semantics?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Nit: I think the more common term in stdlib would be<br>&gt;&gt; `areEquivalent()`. Do you think `same` in that context (independent<br>&gt;&gt; of the word &quot;ordering&quot;) might erroneously suggest identity?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via<br>&gt;&gt; swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; Hello Swift Community,<br>&gt;&gt;<br>&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a<br>&gt;&gt; proposal to clean up the semantics of ordering relations in the<br>&gt;&gt; standard library.  We have a draft that you can get as a gist.<br>&gt;&gt; Any feedback you might have about this proposal helps - though<br>&gt;&gt; please keeps your comments on Swift-Evolution and not on the gist.<br>&gt;&gt;<br>&gt;&gt; Cheers,<br>&gt;&gt;<br>&gt;&gt; ~Robert Widmann<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/9ae575fc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 22, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jul 22, 2016, at 9:26 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Jul 22, 2016 at 9:23 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 22, 2016, at 9:17 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Fri, Jul 22, 2016 at 9:15 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 22, 2016, at 9:04 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Fri Jul 22 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 22, 2016, at 8:37 PM, Xiaodi Wu via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Fri, Jul 22, 2016 at 8:20 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org &lt;http://daniel-at-duan.org/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Fri Jul 22 2016, Daniel Duan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think this is about identity.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better name.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; benefit.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t consider<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; them part of their *identity*. I can follow this logic. My fear is most users<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; won’t make this leap on their own and get the same initial impression as I did.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated bikesheding<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; it with ===.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; To spell this out (because I had to think about it for a second): === will be derived from<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;=&gt;,<br>&gt;&gt;&gt;&gt;&gt;&gt; but also becomes default implementation for ==, which remains open for<br>&gt;&gt;&gt;&gt;&gt;&gt; customization.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I was imagining roughly this (untested):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  /// Two references are identical if they refer to the same<br>&gt;&gt;&gt;&gt;&gt;  /// instance.<br>&gt;&gt;&gt;&gt;&gt;  ///<br>&gt;&gt;&gt;&gt;&gt;  /// - Note: Classes with a more-refined notion of “identical”<br>&gt;&gt;&gt;&gt;&gt;  ///   should conform to `Identifiable` and implement `===`.<br>&gt;&gt;&gt;&gt;&gt;  func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt;    ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  /// Supports testing that two values of `Self` are identical<br>&gt;&gt;&gt;&gt;&gt;  ///<br>&gt;&gt;&gt;&gt;&gt;  /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt;&gt;&gt;&gt;&gt;  /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;&gt;&gt;&gt;  /// type can document that specific observable characteristics<br>&gt;&gt;&gt;&gt;&gt;  /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;&gt;&gt;&gt;  /// thus not to be considered as part of the interchangeability<br>&gt;&gt;&gt;&gt;&gt;  /// guarantee.<br>&gt;&gt;&gt;&gt;&gt;  ///<br>&gt;&gt;&gt;&gt;&gt;  /// - Requires: `===` induces an equivalence relation over<br>&gt;&gt;&gt;&gt;&gt;  ///   instances.<br>&gt;&gt;&gt;&gt;&gt;  /// - Note: conforming types will gain an `==` operator that<br>&gt;&gt;&gt;&gt;&gt;  ///   forwards to `===`.<br>&gt;&gt;&gt;&gt;&gt;  /// - Note: Types that require domain-specific `==`<br>&gt;&gt;&gt;&gt;&gt;  ///   implementations with different semantics (e.g. floating<br>&gt;&gt;&gt;&gt;&gt;  ///   point) should define a more-specific overload of `==`,<br>&gt;&gt;&gt;&gt;&gt;  ///   which will be used in contexts where the static type is<br>&gt;&gt;&gt;&gt;&gt;  ///   known to the compiler.<br>&gt;&gt;&gt;&gt;&gt;  /// - Note: Generic code should usually use `==` to compare<br>&gt;&gt;&gt;&gt;&gt;  ///   conforming instances; that will always dispatch to `===`<br>&gt;&gt;&gt;&gt;&gt;  ///   and will be unaffected by more specific overloads of<br>&gt;&gt;&gt;&gt;&gt;  ///   `==`.<br>&gt;&gt;&gt;&gt;&gt;  protocol Identifiable { // née Equatable name is negotiable<br>&gt;&gt;&gt;&gt;&gt;    func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  /// Default definition of `==` for Identifiable types.<br>&gt;&gt;&gt;&gt;&gt;  func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt;    return lhs === rhs<br>&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  /// Conforming types have a default total ordering.<br>&gt;&gt;&gt;&gt;&gt;  ///<br>&gt;&gt;&gt;&gt;&gt;  /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt;&gt;&gt;&gt;&gt;  /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;&gt;&gt;&gt;  /// type can document that specific observable characteristics<br>&gt;&gt;&gt;&gt;&gt;  /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;&gt;&gt;&gt;  /// thus not to be considered as part of the interchangeability<br>&gt;&gt;&gt;&gt;&gt;  /// guarantee.<br>&gt;&gt;&gt;&gt;&gt;  ///<br>&gt;&gt;&gt;&gt;&gt;  /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt;&gt;&gt;&gt;&gt;  ///   instances.<br>&gt;&gt;&gt;&gt;&gt;  /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt;&gt;&gt;&gt;&gt;  ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent`<br>&gt;&gt;&gt;&gt;&gt;  ///   iff `a === b`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same` *but not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the sign of zero (so +0 = −0)”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The point of this design is that `===` means identity and that `.same ` also means identity.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since this is new territory I suppose we get to decide what identity<br>&gt;&gt;&gt;&gt; means for floating point.  Should +0 and -0 have the same identity or<br>&gt;&gt;&gt;&gt; not?  I’ll leave the answer to folks more knowledgable about numerics<br>&gt;&gt;&gt;&gt; than I.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s settled law <br>&gt;&gt;&gt; https://en.wikipedia.org/wiki/IEEE_floating_point#Total-ordering_predicate &lt;https://en.wikipedia.org/wiki/IEEE_floating_point#Total-ordering_predicate&gt;<br>&gt;&gt;&gt; :-)<br>&gt;&gt; <br>&gt;&gt; Yes, assuming we want to define identity in terms of the IEEE definition of total ordering.<br>&gt;&gt; <br>&gt;&gt; I see what you&#39;re saying here. That could work. Comparable `===` and Equatable `&lt;=&gt;` could do its own thing, and FloatingPoint `isTotallyOrdered(below:)` can preserve the IEEE definition of total ordering<br>&gt; <br>&gt; Actually, I was hinting at your argument that `===` true iff `&lt;=&gt;` same shouldn’t be a semantic requirement of the protocols.<br>&gt; <br>&gt; This is another option, but I don’t think it’s going to fly.  It seems reasonable to assume that `&lt;=&gt;` will have IEEE semantics.  We will trip a lot of people up if it doesn’t.  That’s a big reason we can’t consider changing floating point `==` to define an equivalence relation.<br>&gt; <br>&gt; Actually, here I doubt it. The total ordering isn&#39;t exposed as part of any comparison operator defined in the IEEE spec. In fact, the total ordering wasn&#39;t introduced until a (fairly) recent IEEE revision, IIUC. Breaking `==` would definitely cause people to jump, but `&lt;=&gt;` needn&#39;t be the IEEE totalOrder predicate IMO.<br></p><p>I’ll let you make that case to Dave and Steve.  If you can convince them I won’t object!  :)<br></p><p>&gt;  <br>&gt; <br>&gt;&gt; .<br>&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  /// - Note: conforming types will gain `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`<br>&gt;&gt;&gt;&gt;&gt;  ///   operators defined in terms of `&lt;=&gt;`.<br>&gt;&gt;&gt;&gt;&gt;  /// - Note: Types that require domain-specific `&lt;`, etc.<br>&gt;&gt;&gt;&gt;&gt;  ///   implementations with different semantics (e.g. floating<br>&gt;&gt;&gt;&gt;&gt;  ///   point) should define more-specific overloads of those<br>&gt;&gt;&gt;&gt;&gt;  ///   operators, which will be used in contexts where the<br>&gt;&gt;&gt;&gt;&gt;  ///   static type is known to the compiler.<br>&gt;&gt;&gt;&gt;&gt;  /// - Note: Generic code can freely use `&lt;=&gt;` or the traditional<br>&gt;&gt;&gt;&gt;&gt;  ///   comparison operators to compare conforming instances;<br>&gt;&gt;&gt;&gt;&gt;  ///   the result will always be supplied by `&lt;=&gt;`<br>&gt;&gt;&gt;&gt;&gt;  ///   and will be unaffected by more specific overloads of<br>&gt;&gt;&gt;&gt;&gt;  ///   the other operators.<br>&gt;&gt;&gt;&gt;&gt;  protocol Comparable : Identifiable {<br>&gt;&gt;&gt;&gt;&gt;    func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  /// Default implementations of `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`.<br>&gt;&gt;&gt;&gt;&gt;  extension Comparable {<br>&gt;&gt;&gt;&gt;&gt;    static func &lt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt;      return (lhs &lt;=&gt; rhs) == .ascending<br>&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;    static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt;      return (rhs &lt;=&gt; lhs) != .ascending<br>&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;    static func &gt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt;      return (lhs &lt;=&gt; rhs) == .descending<br>&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;    static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt;      return (rhs &lt;=&gt; lhs) != .descending<br>&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I like this idea. If we keep === as a separate thing, now users have 3 “opportunities” to define<br>&gt;&gt;&gt;&gt;&gt;&gt; equality. The must be few, if any, use cases for this.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Would love to see if anyone on the list can give us an example. Otherwise we should make<br>&gt;&gt;&gt;&gt;&gt;&gt; areSame === again™!<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel Duan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is nice. Is `areSame()` being proposed because static `==` is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the status quo and you&#39;re trying to make the point that `==` in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; future need not guarantee the same semantics?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Nit: I think the more common term in stdlib would be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `areEquivalent()`. Do you think `same` in that context (independent<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the word &quot;ordering&quot;) might erroneously suggest identity?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift Community,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposal to clean up the semantics of ordering relations in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; standard library.  We have a draft that you can get as a gist.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any feedback you might have about this proposal helps - though<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; please keeps your comments on Swift-Evolution and not on the gist.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/a89523f9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 22, 2016 at 07:00:00pm</p></header><div class="content"><p>on Fri Jul 22 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; On Fri, Jul 22, 2016 at 9:23 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 22, 2016, at 9:17 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Fri, Jul 22, 2016 at 9:15 PM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jul 22, 2016, at 9:04 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; on Fri Jul 22 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jul 22, 2016, at 8:37 PM, Xiaodi Wu via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Fri, Jul 22, 2016 at 8:20 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org<br>&gt;&gt;&gt; &lt;http://daniel-at-duan.org/&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; on Fri Jul 22 2016, Daniel Duan<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt;&gt;&gt; think this is about identity.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt;&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better name.<br>&gt;&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt;&gt;&gt; benefit.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t<br>&gt;&gt;&gt; consider<br>&gt;&gt;&gt; them part of their *identity*. I can follow this logic. My fear is most<br>&gt;&gt;&gt; users<br>&gt;&gt;&gt; won’t make this leap on their own and get the same initial impression as<br>&gt;&gt;&gt; I did.<br>&gt;&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated bikesheding<br>&gt;&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt;&gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt;&gt;&gt; it with ===.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; To spell this out (because I had to think about it for a second): ===<br>&gt;&gt;&gt; will be derived from<br>&gt;&gt;&gt; &lt;=&gt;,<br>&gt;&gt;&gt; but also becomes default implementation for ==, which remains open for<br>&gt;&gt;&gt; customization.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I was imagining roughly this (untested):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  /// Two references are identical if they refer to the same<br>&gt;&gt;&gt;  /// instance.<br>&gt;&gt;&gt;  ///<br>&gt;&gt;&gt;  /// - Note: Classes with a more-refined notion of “identical”<br>&gt;&gt;&gt;  ///   should conform to `Identifiable` and implement `===`.<br>&gt;&gt;&gt;  func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt;&gt;&gt;    ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  /// Supports testing that two values of `Self` are identical<br>&gt;&gt;&gt;  ///<br>&gt;&gt;&gt;  /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt;&gt;&gt;  /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;&gt;  /// type can document that specific observable characteristics<br>&gt;&gt;&gt;  /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;&gt;  /// thus not to be considered as part of the interchangeability<br>&gt;&gt;&gt;  /// guarantee.<br>&gt;&gt;&gt;  ///<br>&gt;&gt;&gt;  /// - Requires: `===` induces an equivalence relation over<br>&gt;&gt;&gt;  ///   instances.<br>&gt;&gt;&gt;  /// - Note: conforming types will gain an `==` operator that<br>&gt;&gt;&gt;  ///   forwards to `===`.<br>&gt;&gt;&gt;  /// - Note: Types that require domain-specific `==`<br>&gt;&gt;&gt;  ///   implementations with different semantics (e.g. floating<br>&gt;&gt;&gt;  ///   point) should define a more-specific overload of `==`,<br>&gt;&gt;&gt;  ///   which will be used in contexts where the static type is<br>&gt;&gt;&gt;  ///   known to the compiler.<br>&gt;&gt;&gt;  /// - Note: Generic code should usually use `==` to compare<br>&gt;&gt;&gt;  ///   conforming instances; that will always dispatch to `===`<br>&gt;&gt;&gt;  ///   and will be unaffected by more specific overloads of<br>&gt;&gt;&gt;  ///   `==`.<br>&gt;&gt;&gt;  protocol Identifiable { // née Equatable name is negotiable<br>&gt;&gt;&gt;    func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  /// Default definition of `==` for Identifiable types.<br>&gt;&gt;&gt;  func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;&gt;    return lhs === rhs<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  /// Conforming types have a default total ordering.<br>&gt;&gt;&gt;  ///<br>&gt;&gt;&gt;  /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt;&gt;&gt;  /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;&gt;  /// type can document that specific observable characteristics<br>&gt;&gt;&gt;  /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;&gt;  /// thus not to be considered as part of the interchangeability<br>&gt;&gt;&gt;  /// guarantee.<br>&gt;&gt;&gt;  ///<br>&gt;&gt;&gt;  /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt;&gt;&gt;  ///   instances.<br>&gt;&gt;&gt;  /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt;&gt;&gt;  ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent`<br>&gt;&gt;&gt;  ///   iff `a === b`.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same` *but<br>&gt;&gt;&gt; not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the sign<br>&gt;&gt;&gt; of zero (so +0 = −0)”.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The point of this design is that `===` means identity and that `.same `<br>&gt;&gt;&gt; also means identity.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Since this is new territory I suppose we get to decide what identity<br>&gt;&gt;&gt; means for floating point.  Should +0 and -0 have the same identity or<br>&gt;&gt;&gt; not?  I’ll leave the answer to folks more knowledgable about numerics<br>&gt;&gt;&gt; than I.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It&#39;s settled law<br>&gt;&gt;&gt; https://en.wikipedia.org/wiki/IEEE_floating_point#Total-ordering_predicate<br>&gt;&gt;&gt; :-)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes, assuming we want to define identity in terms of the IEEE definition<br>&gt;&gt;&gt; of total ordering.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I see what you&#39;re saying here. That could work. Comparable `===` and<br>&gt;&gt; Equatable `&lt;=&gt;` could do its own thing, and FloatingPoint<br>&gt;&gt; `isTotallyOrdered(below:)` can preserve the IEEE definition of total<br>&gt;&gt; ordering<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Actually, I was hinting at your argument that `===` true iff `&lt;=&gt;` same<br>&gt;&gt; shouldn’t be a semantic requirement of the protocols.<br>&gt;&gt;<br>&gt;&gt; This is another option, but I don’t think it’s going to fly.  It seems<br>&gt;&gt; reasonable to assume that `&lt;=&gt;` will have IEEE semantics.  We will trip a<br>&gt;&gt; lot of people up if it doesn’t.  That’s a big reason we can’t consider<br>&gt;&gt; changing floating point `==` to define an equivalence relation.<br>&gt;&gt;<br>&gt;<br>&gt; Actually, here I doubt it. The total ordering isn&#39;t exposed as part of any<br>&gt; comparison operator defined in the IEEE spec. In fact, the total ordering<br>&gt; wasn&#39;t introduced until a (fairly) recent IEEE revision, IIUC. Breaking<br>&gt; `==` would definitely cause people to jump, but `&lt;=&gt;` needn&#39;t be the IEEE<br>&gt; totalOrder predicate IMO.<br></p><p>Wait, I thought we were saying that `&lt;=&gt;` could be IEEE totalOrder, and<br>`===` could be like `==` but with well-behaved NaNs, so it&#39;s still an<br>equivalence relation, thus declaring the signedness of 0 to be<br>inessential.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 22, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jul 22, 2016, at 9:46 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Jul 22 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Fri, Jul 22, 2016 at 9:23 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jul 22, 2016, at 9:17 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Fri, Jul 22, 2016 at 9:15 PM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 22, 2016, at 9:04 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Fri Jul 22 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 22, 2016, at 8:37 PM, Xiaodi Wu via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Fri, Jul 22, 2016 at 8:20 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org<br>&gt;&gt;&gt;&gt; &lt;http://daniel-at-duan.org/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Fri Jul 22 2016, Daniel Duan<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt;&gt;&gt;&gt; think this is about identity.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt;&gt;&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better name.<br>&gt;&gt;&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt;&gt;&gt;&gt; benefit.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t<br>&gt;&gt;&gt;&gt; consider<br>&gt;&gt;&gt;&gt; them part of their *identity*. I can follow this logic. My fear is most<br>&gt;&gt;&gt;&gt; users<br>&gt;&gt;&gt;&gt; won’t make this leap on their own and get the same initial impression as<br>&gt;&gt;&gt;&gt; I did.<br>&gt;&gt;&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated bikesheding<br>&gt;&gt;&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt;&gt;&gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt;&gt;&gt;&gt; it with ===.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To spell this out (because I had to think about it for a second): ===<br>&gt;&gt;&gt;&gt; will be derived from<br>&gt;&gt;&gt;&gt; &lt;=&gt;,<br>&gt;&gt;&gt;&gt; but also becomes default implementation for ==, which remains open for<br>&gt;&gt;&gt;&gt; customization.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I was imagining roughly this (untested):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// Two references are identical if they refer to the same<br>&gt;&gt;&gt;&gt; /// instance.<br>&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt; /// - Note: Classes with a more-refined notion of “identical”<br>&gt;&gt;&gt;&gt; ///   should conform to `Identifiable` and implement `===`.<br>&gt;&gt;&gt;&gt; func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt;&gt;&gt;&gt;   ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// Supports testing that two values of `Self` are identical<br>&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt; /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt;&gt;&gt;&gt; /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;&gt;&gt; /// type can document that specific observable characteristics<br>&gt;&gt;&gt;&gt; /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;&gt;&gt; /// thus not to be considered as part of the interchangeability<br>&gt;&gt;&gt;&gt; /// guarantee.<br>&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt; /// - Requires: `===` induces an equivalence relation over<br>&gt;&gt;&gt;&gt; ///   instances.<br>&gt;&gt;&gt;&gt; /// - Note: conforming types will gain an `==` operator that<br>&gt;&gt;&gt;&gt; ///   forwards to `===`.<br>&gt;&gt;&gt;&gt; /// - Note: Types that require domain-specific `==`<br>&gt;&gt;&gt;&gt; ///   implementations with different semantics (e.g. floating<br>&gt;&gt;&gt;&gt; ///   point) should define a more-specific overload of `==`,<br>&gt;&gt;&gt;&gt; ///   which will be used in contexts where the static type is<br>&gt;&gt;&gt;&gt; ///   known to the compiler.<br>&gt;&gt;&gt;&gt; /// - Note: Generic code should usually use `==` to compare<br>&gt;&gt;&gt;&gt; ///   conforming instances; that will always dispatch to `===`<br>&gt;&gt;&gt;&gt; ///   and will be unaffected by more specific overloads of<br>&gt;&gt;&gt;&gt; ///   `==`.<br>&gt;&gt;&gt;&gt; protocol Identifiable { // née Equatable name is negotiable<br>&gt;&gt;&gt;&gt;   func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// Default definition of `==` for Identifiable types.<br>&gt;&gt;&gt;&gt; func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;&gt;&gt;   return lhs === rhs<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// Conforming types have a default total ordering.<br>&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt; /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt;&gt;&gt;&gt; /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;&gt;&gt; /// type can document that specific observable characteristics<br>&gt;&gt;&gt;&gt; /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;&gt;&gt; /// thus not to be considered as part of the interchangeability<br>&gt;&gt;&gt;&gt; /// guarantee.<br>&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt; /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt;&gt;&gt;&gt; ///   instances.<br>&gt;&gt;&gt;&gt; /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt;&gt;&gt;&gt; ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent`<br>&gt;&gt;&gt;&gt; ///   iff `a === b`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same` *but<br>&gt;&gt;&gt;&gt; not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the sign<br>&gt;&gt;&gt;&gt; of zero (so +0 = −0)”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The point of this design is that `===` means identity and that `.same `<br>&gt;&gt;&gt;&gt; also means identity.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since this is new territory I suppose we get to decide what identity<br>&gt;&gt;&gt;&gt; means for floating point.  Should +0 and -0 have the same identity or<br>&gt;&gt;&gt;&gt; not?  I’ll leave the answer to folks more knowledgable about numerics<br>&gt;&gt;&gt;&gt; than I.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s settled law<br>&gt;&gt;&gt;&gt; https://en.wikipedia.org/wiki/IEEE_floating_point#Total-ordering_predicate<br>&gt;&gt;&gt;&gt; :-)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, assuming we want to define identity in terms of the IEEE definition<br>&gt;&gt;&gt;&gt; of total ordering.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I see what you&#39;re saying here. That could work. Comparable `===` and<br>&gt;&gt;&gt; Equatable `&lt;=&gt;` could do its own thing, and FloatingPoint<br>&gt;&gt;&gt; `isTotallyOrdered(below:)` can preserve the IEEE definition of total<br>&gt;&gt;&gt; ordering<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Actually, I was hinting at your argument that `===` true iff `&lt;=&gt;` same<br>&gt;&gt;&gt; shouldn’t be a semantic requirement of the protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is another option, but I don’t think it’s going to fly.  It seems<br>&gt;&gt;&gt; reasonable to assume that `&lt;=&gt;` will have IEEE semantics.  We will trip a<br>&gt;&gt;&gt; lot of people up if it doesn’t.  That’s a big reason we can’t consider<br>&gt;&gt;&gt; changing floating point `==` to define an equivalence relation.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Actually, here I doubt it. The total ordering isn&#39;t exposed as part of any<br>&gt;&gt; comparison operator defined in the IEEE spec. In fact, the total ordering<br>&gt;&gt; wasn&#39;t introduced until a (fairly) recent IEEE revision, IIUC. Breaking<br>&gt;&gt; `==` would definitely cause people to jump, but `&lt;=&gt;` needn&#39;t be the IEEE<br>&gt;&gt; totalOrder predicate IMO.<br>&gt; <br>&gt; Wait, I thought we were saying that `&lt;=&gt;` could be IEEE totalOrder, and<br>&gt; `===` could be like `==` but with well-behaved NaNs, so it&#39;s still an<br>&gt; equivalence relation, thus declaring the signedness of 0 to be<br>&gt; inessential.<br></p><p>He’s considering two or three different approaches.  That’s one of them and abandoning IEEE total order for `&lt;=&gt;` is another.<br></p><p>&gt; <br>&gt; -- <br>&gt; Dave<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 22, 2016 at 09:00:00pm</p></header><div class="content"><p>On Fri, Jul 22, 2016 at 9:46 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; on Fri Jul 22 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt; &gt; On Fri, Jul 22, 2016 at 9:23 PM, Matthew Johnson &lt;matthew at anandabits.com<br>&gt; &gt;<br>&gt; &gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Jul 22, 2016, at 9:17 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Fri, Jul 22, 2016 at 9:15 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; &gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On Jul 22, 2016, at 9:04 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; on Fri Jul 22 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On Jul 22, 2016, at 8:37 PM, Xiaodi Wu via swift-evolution<br>&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On Fri, Jul 22, 2016 at 8:20 PM, Dave Abrahams via swift-evolution<br>&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org<br>&gt; &gt;&gt;&gt; &lt;http://daniel-at-duan.org/&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution<br>&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; on Fri Jul 22 2016, Daniel Duan<br>&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt; &gt;&gt;&gt; think this is about identity.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt; &gt;&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better name.<br>&gt; &gt;&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt; &gt;&gt;&gt; benefit.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t<br>&gt; &gt;&gt;&gt; consider<br>&gt; &gt;&gt;&gt; them part of their *identity*. I can follow this logic. My fear is most<br>&gt; &gt;&gt;&gt; users<br>&gt; &gt;&gt;&gt; won’t make this leap on their own and get the same initial impression<br>&gt; as<br>&gt; &gt;&gt;&gt; I did.<br>&gt; &gt;&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated<br>&gt; bikesheding<br>&gt; &gt;&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt; &gt;&gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt; &gt;&gt;&gt; it with ===.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; To spell this out (because I had to think about it for a second): ===<br>&gt; &gt;&gt;&gt; will be derived from<br>&gt; &gt;&gt;&gt; &lt;=&gt;,<br>&gt; &gt;&gt;&gt; but also becomes default implementation for ==, which remains open for<br>&gt; &gt;&gt;&gt; customization.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I was imagining roughly this (untested):<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;  /// Two references are identical if they refer to the same<br>&gt; &gt;&gt;&gt;  /// instance.<br>&gt; &gt;&gt;&gt;  ///<br>&gt; &gt;&gt;&gt;  /// - Note: Classes with a more-refined notion of “identical”<br>&gt; &gt;&gt;&gt;  ///   should conform to `Identifiable` and implement `===`.<br>&gt; &gt;&gt;&gt;  func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt; &gt;&gt;&gt;    ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt; &gt;&gt;&gt;  }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;  /// Supports testing that two values of `Self` are identical<br>&gt; &gt;&gt;&gt;  ///<br>&gt; &gt;&gt;&gt;  /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt; &gt;&gt;&gt;  /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt; &gt;&gt;&gt;  /// type can document that specific observable characteristics<br>&gt; &gt;&gt;&gt;  /// (such as the `capacity` of an `Array`) are inessential and<br>&gt; &gt;&gt;&gt;  /// thus not to be considered as part of the interchangeability<br>&gt; &gt;&gt;&gt;  /// guarantee.<br>&gt; &gt;&gt;&gt;  ///<br>&gt; &gt;&gt;&gt;  /// - Requires: `===` induces an equivalence relation over<br>&gt; &gt;&gt;&gt;  ///   instances.<br>&gt; &gt;&gt;&gt;  /// - Note: conforming types will gain an `==` operator that<br>&gt; &gt;&gt;&gt;  ///   forwards to `===`.<br>&gt; &gt;&gt;&gt;  /// - Note: Types that require domain-specific `==`<br>&gt; &gt;&gt;&gt;  ///   implementations with different semantics (e.g. floating<br>&gt; &gt;&gt;&gt;  ///   point) should define a more-specific overload of `==`,<br>&gt; &gt;&gt;&gt;  ///   which will be used in contexts where the static type is<br>&gt; &gt;&gt;&gt;  ///   known to the compiler.<br>&gt; &gt;&gt;&gt;  /// - Note: Generic code should usually use `==` to compare<br>&gt; &gt;&gt;&gt;  ///   conforming instances; that will always dispatch to `===`<br>&gt; &gt;&gt;&gt;  ///   and will be unaffected by more specific overloads of<br>&gt; &gt;&gt;&gt;  ///   `==`.<br>&gt; &gt;&gt;&gt;  protocol Identifiable { // née Equatable name is negotiable<br>&gt; &gt;&gt;&gt;    func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt; &gt;&gt;&gt;  }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;  /// Default definition of `==` for Identifiable types.<br>&gt; &gt;&gt;&gt;  func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt; &gt;&gt;&gt;    return lhs === rhs<br>&gt; &gt;&gt;&gt;  }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;  /// Conforming types have a default total ordering.<br>&gt; &gt;&gt;&gt;  ///<br>&gt; &gt;&gt;&gt;  /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt; &gt;&gt;&gt;  /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt; &gt;&gt;&gt;  /// type can document that specific observable characteristics<br>&gt; &gt;&gt;&gt;  /// (such as the `capacity` of an `Array`) are inessential and<br>&gt; &gt;&gt;&gt;  /// thus not to be considered as part of the interchangeability<br>&gt; &gt;&gt;&gt;  /// guarantee.<br>&gt; &gt;&gt;&gt;  ///<br>&gt; &gt;&gt;&gt;  /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt; &gt;&gt;&gt;  ///   instances.<br>&gt; &gt;&gt;&gt;  /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt; &gt;&gt;&gt;  ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent`<br>&gt; &gt;&gt;&gt;  ///   iff `a === b`.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same`<br>&gt; *but<br>&gt; &gt;&gt;&gt; not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the<br>&gt; sign<br>&gt; &gt;&gt;&gt; of zero (so +0 = −0)”.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The point of this design is that `===` means identity and that `.same `<br>&gt; &gt;&gt;&gt; also means identity.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Since this is new territory I suppose we get to decide what identity<br>&gt; &gt;&gt;&gt; means for floating point.  Should +0 and -0 have the same identity or<br>&gt; &gt;&gt;&gt; not?  I’ll leave the answer to folks more knowledgable about numerics<br>&gt; &gt;&gt;&gt; than I.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; It&#39;s settled law<br>&gt; &gt;&gt;&gt;<br>&gt; https://en.wikipedia.org/wiki/IEEE_floating_point#Total-ordering_predicate<br>&gt; &gt;&gt;&gt; :-)<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Yes, assuming we want to define identity in terms of the IEEE<br>&gt; definition<br>&gt; &gt;&gt;&gt; of total ordering.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I see what you&#39;re saying here. That could work. Comparable `===` and<br>&gt; &gt;&gt; Equatable `&lt;=&gt;` could do its own thing, and FloatingPoint<br>&gt; &gt;&gt; `isTotallyOrdered(below:)` can preserve the IEEE definition of total<br>&gt; &gt;&gt; ordering<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Actually, I was hinting at your argument that `===` true iff `&lt;=&gt;` same<br>&gt; &gt;&gt; shouldn’t be a semantic requirement of the protocols.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This is another option, but I don’t think it’s going to fly.  It seems<br>&gt; &gt;&gt; reasonable to assume that `&lt;=&gt;` will have IEEE semantics.  We will trip<br>&gt; a<br>&gt; &gt;&gt; lot of people up if it doesn’t.  That’s a big reason we can’t consider<br>&gt; &gt;&gt; changing floating point `==` to define an equivalence relation.<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt; Actually, here I doubt it. The total ordering isn&#39;t exposed as part of<br>&gt; any<br>&gt; &gt; comparison operator defined in the IEEE spec. In fact, the total ordering<br>&gt; &gt; wasn&#39;t introduced until a (fairly) recent IEEE revision, IIUC. Breaking<br>&gt; &gt; `==` would definitely cause people to jump, but `&lt;=&gt;` needn&#39;t be the IEEE<br>&gt; &gt; totalOrder predicate IMO.<br>&gt;<br>&gt; Wait, I thought we were saying that `&lt;=&gt;` could be IEEE totalOrder, and<br>&gt; `===` could be like `==` but with well-behaved NaNs, so it&#39;s still an<br>&gt; equivalence relation, thus declaring the signedness of 0 to be<br>&gt; inessential.<br>&gt;<br></p><p>I was (that was the &quot;=== if but not iff &lt;=&gt;&quot; business above), then I<br>thought Matthew was saying something different and agreed with him.<br></p><p>What I thought that Matthew thought was actually very insightful. He didn&#39;t<br>actually think this, apparently, but: IEEE totalOrder does exactly what it<br>says on the tin. But, it is not useful for any generic comparisons or (as<br>far as I&#39;m aware) any generic sorting algorithms. I cannot conceive of a<br>numeric algorithm or a generic algorithm that relies on two equal floating<br>point values being ordered based on their binary representation. We should<br>have some way of exposing totalOrder to a user of a BinaryFloatingPoint<br>type, but I don&#39;t know that it should be the basis for floating point<br>*identity* with respect to protocol conformance. It&#39;s explicitly *not* what<br>IEEE recommends for comparison anyway.<br></p><p><br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/f44d3b44/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 22, 2016 at 07:00:00pm</p></header><div class="content"><p>on Fri Jul 22 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; On Fri, Jul 22, 2016 at 9:46 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Fri Jul 22 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; On Fri, Jul 22, 2016 at 9:23 PM, Matthew Johnson &lt;matthew at anandabits.com<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; On Jul 22, 2016, at 9:17 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; On Fri, Jul 22, 2016 at 9:15 PM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On Jul 22, 2016, at 9:04 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; on Fri Jul 22 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On Jul 22, 2016, at 8:37 PM, Xiaodi Wu via swift-evolution<br>&gt;&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On Fri, Jul 22, 2016 at 8:20 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org<br>&gt;&gt; &gt;&gt;&gt; &lt;http://daniel-at-duan.org/&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; on Fri Jul 22 2016, Daniel Duan<br>&gt;&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt;&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt;&gt; &gt;&gt;&gt; think this is about identity.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt;&gt; &gt;&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better name.<br>&gt;&gt; &gt;&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt;&gt; &gt;&gt;&gt; benefit.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t<br>&gt;&gt; &gt;&gt;&gt; consider<br>&gt;&gt; &gt;&gt;&gt; them part of their *identity*. I can follow this logic. My fear is most<br>&gt;&gt; &gt;&gt;&gt; users<br>&gt;&gt; &gt;&gt;&gt; won’t make this leap on their own and get the same initial impression<br>&gt;&gt; as<br>&gt;&gt; &gt;&gt;&gt; I did.<br>&gt;&gt; &gt;&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated<br>&gt;&gt; bikesheding<br>&gt;&gt; &gt;&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt;&gt; &gt;&gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt;&gt; &gt;&gt;&gt; it with ===.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; To spell this out (because I had to think about it for a second): ===<br>&gt;&gt; &gt;&gt;&gt; will be derived from<br>&gt;&gt; &gt;&gt;&gt; &lt;=&gt;,<br>&gt;&gt; &gt;&gt;&gt; but also becomes default implementation for ==, which remains open for<br>&gt;&gt; &gt;&gt;&gt; customization.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; I was imagining roughly this (untested):<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;  /// Two references are identical if they refer to the same<br>&gt;&gt; &gt;&gt;&gt;  /// instance.<br>&gt;&gt; &gt;&gt;&gt;  ///<br>&gt;&gt; &gt;&gt;&gt;  /// - Note: Classes with a more-refined notion of “identical”<br>&gt;&gt; &gt;&gt;&gt;  ///   should conform to `Identifiable` and implement `===`.<br>&gt;&gt; &gt;&gt;&gt;  func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt;&gt; &gt;&gt;&gt;    ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt;&gt; &gt;&gt;&gt;  }<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;  /// Supports testing that two values of `Self` are identical<br>&gt;&gt; &gt;&gt;&gt;  ///<br>&gt;&gt; &gt;&gt;&gt;  /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt;&gt; &gt;&gt;&gt;  /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt; &gt;&gt;&gt;  /// type can document that specific observable characteristics<br>&gt;&gt; &gt;&gt;&gt;  /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt; &gt;&gt;&gt;  /// thus not to be considered as part of the interchangeability<br>&gt;&gt; &gt;&gt;&gt;  /// guarantee.<br>&gt;&gt; &gt;&gt;&gt;  ///<br>&gt;&gt; &gt;&gt;&gt;  /// - Requires: `===` induces an equivalence relation over<br>&gt;&gt; &gt;&gt;&gt;  ///   instances.<br>&gt;&gt; &gt;&gt;&gt;  /// - Note: conforming types will gain an `==` operator that<br>&gt;&gt; &gt;&gt;&gt;  ///   forwards to `===`.<br>&gt;&gt; &gt;&gt;&gt;  /// - Note: Types that require domain-specific `==`<br>&gt;&gt; &gt;&gt;&gt;  ///   implementations with different semantics (e.g. floating<br>&gt;&gt; &gt;&gt;&gt;  ///   point) should define a more-specific overload of `==`,<br>&gt;&gt; &gt;&gt;&gt;  ///   which will be used in contexts where the static type is<br>&gt;&gt; &gt;&gt;&gt;  ///   known to the compiler.<br>&gt;&gt; &gt;&gt;&gt;  /// - Note: Generic code should usually use `==` to compare<br>&gt;&gt; &gt;&gt;&gt;  ///   conforming instances; that will always dispatch to `===`<br>&gt;&gt; &gt;&gt;&gt;  ///   and will be unaffected by more specific overloads of<br>&gt;&gt; &gt;&gt;&gt;  ///   `==`.<br>&gt;&gt; &gt;&gt;&gt;  protocol Identifiable { // née Equatable name is negotiable<br>&gt;&gt; &gt;&gt;&gt;    func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt;&gt; &gt;&gt;&gt;  }<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;  /// Default definition of `==` for Identifiable types.<br>&gt;&gt; &gt;&gt;&gt;  func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt; &gt;&gt;&gt;    return lhs === rhs<br>&gt;&gt; &gt;&gt;&gt;  }<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;  /// Conforming types have a default total ordering.<br>&gt;&gt; &gt;&gt;&gt;  ///<br>&gt;&gt; &gt;&gt;&gt;  /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt;&gt; &gt;&gt;&gt;  /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt; &gt;&gt;&gt;  /// type can document that specific observable characteristics<br>&gt;&gt; &gt;&gt;&gt;  /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt; &gt;&gt;&gt;  /// thus not to be considered as part of the interchangeability<br>&gt;&gt; &gt;&gt;&gt;  /// guarantee.<br>&gt;&gt; &gt;&gt;&gt;  ///<br>&gt;&gt; &gt;&gt;&gt;  /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt;&gt; &gt;&gt;&gt;  ///   instances.<br>&gt;&gt; &gt;&gt;&gt;  /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt;&gt; &gt;&gt;&gt;  ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent`<br>&gt;&gt; &gt;&gt;&gt;  ///   iff `a === b`.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same`<br>&gt;&gt; *but<br>&gt;&gt; &gt;&gt;&gt; not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the<br>&gt;&gt; sign<br>&gt;&gt; &gt;&gt;&gt; of zero (so +0 = −0)”.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; The point of this design is that `===` means identity and that `.same `<br>&gt;&gt; &gt;&gt;&gt; also means identity.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Since this is new territory I suppose we get to decide what identity<br>&gt;&gt; &gt;&gt;&gt; means for floating point.  Should +0 and -0 have the same identity or<br>&gt;&gt; &gt;&gt;&gt; not?  I’ll leave the answer to folks more knowledgable about numerics<br>&gt;&gt; &gt;&gt;&gt; than I.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; It&#39;s settled law<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; https://en.wikipedia.org/wiki/IEEE_floating_point#Total-ordering_predicate<br>&gt;&gt; &gt;&gt;&gt; :-)<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Yes, assuming we want to define identity in terms of the IEEE<br>&gt;&gt; definition<br>&gt;&gt; &gt;&gt;&gt; of total ordering.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I see what you&#39;re saying here. That could work. Comparable `===` and<br>&gt;&gt; &gt;&gt; Equatable `&lt;=&gt;` could do its own thing, and FloatingPoint<br>&gt;&gt; &gt;&gt; `isTotallyOrdered(below:)` can preserve the IEEE definition of total<br>&gt;&gt; &gt;&gt; ordering<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Actually, I was hinting at your argument that `===` true iff `&lt;=&gt;` same<br>&gt;&gt; &gt;&gt; shouldn’t be a semantic requirement of the protocols.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; This is another option, but I don’t think it’s going to fly.  It seems<br>&gt;&gt; &gt;&gt; reasonable to assume that `&lt;=&gt;` will have IEEE semantics.  We will trip<br>&gt;&gt; a<br>&gt;&gt; &gt;&gt; lot of people up if it doesn’t.  That’s a big reason we can’t consider<br>&gt;&gt; &gt;&gt; changing floating point `==` to define an equivalence relation.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Actually, here I doubt it. The total ordering isn&#39;t exposed as part of<br>&gt;&gt; any<br>&gt;&gt; &gt; comparison operator defined in the IEEE spec. In fact, the total ordering<br>&gt;&gt; &gt; wasn&#39;t introduced until a (fairly) recent IEEE revision, IIUC. Breaking<br>&gt;&gt; &gt; `==` would definitely cause people to jump, but `&lt;=&gt;` needn&#39;t be the IEEE<br>&gt;&gt; &gt; totalOrder predicate IMO.<br>&gt;&gt;<br>&gt;&gt; Wait, I thought we were saying that `&lt;=&gt;` could be IEEE totalOrder, and<br>&gt;&gt; `===` could be like `==` but with well-behaved NaNs, so it&#39;s still an<br>&gt;&gt; equivalence relation, thus declaring the signedness of 0 to be<br>&gt;&gt; inessential.<br>&gt;&gt;<br>&gt;<br>&gt; I was (that was the &quot;=== if but not iff &lt;=&gt;&quot; business above), then I<br>&gt; thought Matthew was saying something different and agreed with him.<br>&gt;<br>&gt; What I thought that Matthew thought was actually very insightful. He didn&#39;t<br>&gt; actually think this, apparently, but: IEEE totalOrder does exactly what it<br>&gt; says on the tin. But, it is not useful for any generic comparisons or (as<br>&gt; far as I&#39;m aware) any generic sorting algorithms. I cannot conceive of a<br>&gt; numeric algorithm or a generic algorithm that relies on two equal floating<br>&gt; point values being ordered based on their binary representation. We should<br>&gt; have some way of exposing totalOrder to a user of a BinaryFloatingPoint<br>&gt; type, but I don&#39;t know that it should be the basis for floating point<br>&gt; *identity* with respect to protocol conformance. It&#39;s explicitly *not* what<br>&gt; IEEE recommends for comparison anyway.<br></p><p>That makes sense.  Perhaps IEEE hasn&#39;t actually made a principled<br>decision about which aspects of floating point numbers are essential,<br>and we have to do it for them.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 22, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jul 22, 2016, at 9:57 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Jul 22 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com &lt;http://xiaodi.wu-at-gmail.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Fri, Jul 22, 2016 at 9:46 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Fri Jul 22 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Fri, Jul 22, 2016 at 9:23 PM, Matthew Johnson &lt;matthew at anandabits.com<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 22, 2016, at 9:17 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Fri, Jul 22, 2016 at 9:15 PM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jul 22, 2016, at 9:04 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Fri Jul 22 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jul 22, 2016, at 8:37 PM, Xiaodi Wu via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Jul 22, 2016 at 8:20 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://daniel-at-duan.org/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Fri Jul 22 2016, Daniel Duan<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt;&gt;&gt;&gt;&gt;&gt; think this is about identity.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt;&gt;&gt;&gt;&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better name.<br>&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt;&gt;&gt;&gt;&gt;&gt; benefit.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t<br>&gt;&gt;&gt;&gt;&gt;&gt; consider<br>&gt;&gt;&gt;&gt;&gt;&gt; them part of their *identity*. I can follow this logic. My fear is most<br>&gt;&gt;&gt;&gt;&gt;&gt; users<br>&gt;&gt;&gt;&gt;&gt;&gt; won’t make this leap on their own and get the same initial impression<br>&gt;&gt;&gt; as<br>&gt;&gt;&gt;&gt;&gt;&gt; I did.<br>&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated<br>&gt;&gt;&gt; bikesheding<br>&gt;&gt;&gt;&gt;&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt;&gt;&gt;&gt;&gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt;&gt;&gt;&gt;&gt;&gt; it with ===.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; To spell this out (because I had to think about it for a second): ===<br>&gt;&gt;&gt;&gt;&gt;&gt; will be derived from<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;=&gt;,<br>&gt;&gt;&gt;&gt;&gt;&gt; but also becomes default implementation for ==, which remains open for<br>&gt;&gt;&gt;&gt;&gt;&gt; customization.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I was imagining roughly this (untested):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; /// Two references are identical if they refer to the same<br>&gt;&gt;&gt;&gt;&gt;&gt; /// instance.<br>&gt;&gt;&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt;&gt;&gt; /// - Note: Classes with a more-refined notion of “identical”<br>&gt;&gt;&gt;&gt;&gt;&gt; ///   should conform to `Identifiable` and implement `===`.<br>&gt;&gt;&gt;&gt;&gt;&gt; func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt;&gt;   ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; /// Supports testing that two values of `Self` are identical<br>&gt;&gt;&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt;&gt;&gt; /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt;&gt;&gt;&gt;&gt;&gt; /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;&gt;&gt;&gt;&gt; /// type can document that specific observable characteristics<br>&gt;&gt;&gt;&gt;&gt;&gt; /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;&gt;&gt;&gt;&gt; /// thus not to be considered as part of the interchangeability<br>&gt;&gt;&gt;&gt;&gt;&gt; /// guarantee.<br>&gt;&gt;&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt;&gt;&gt; /// - Requires: `===` induces an equivalence relation over<br>&gt;&gt;&gt;&gt;&gt;&gt; ///   instances.<br>&gt;&gt;&gt;&gt;&gt;&gt; /// - Note: conforming types will gain an `==` operator that<br>&gt;&gt;&gt;&gt;&gt;&gt; ///   forwards to `===`.<br>&gt;&gt;&gt;&gt;&gt;&gt; /// - Note: Types that require domain-specific `==`<br>&gt;&gt;&gt;&gt;&gt;&gt; ///   implementations with different semantics (e.g. floating<br>&gt;&gt;&gt;&gt;&gt;&gt; ///   point) should define a more-specific overload of `==`,<br>&gt;&gt;&gt;&gt;&gt;&gt; ///   which will be used in contexts where the static type is<br>&gt;&gt;&gt;&gt;&gt;&gt; ///   known to the compiler.<br>&gt;&gt;&gt;&gt;&gt;&gt; /// - Note: Generic code should usually use `==` to compare<br>&gt;&gt;&gt;&gt;&gt;&gt; ///   conforming instances; that will always dispatch to `===`<br>&gt;&gt;&gt;&gt;&gt;&gt; ///   and will be unaffected by more specific overloads of<br>&gt;&gt;&gt;&gt;&gt;&gt; ///   `==`.<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol Identifiable { // née Equatable name is negotiable<br>&gt;&gt;&gt;&gt;&gt;&gt;   func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; /// Default definition of `==` for Identifiable types.<br>&gt;&gt;&gt;&gt;&gt;&gt; func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt;&gt;   return lhs === rhs<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; /// Conforming types have a default total ordering.<br>&gt;&gt;&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt;&gt;&gt; /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt;&gt;&gt;&gt;&gt;&gt; /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;&gt;&gt;&gt;&gt; /// type can document that specific observable characteristics<br>&gt;&gt;&gt;&gt;&gt;&gt; /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;&gt;&gt;&gt;&gt; /// thus not to be considered as part of the interchangeability<br>&gt;&gt;&gt;&gt;&gt;&gt; /// guarantee.<br>&gt;&gt;&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt;&gt;&gt; /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt;&gt;&gt;&gt;&gt;&gt; ///   instances.<br>&gt;&gt;&gt;&gt;&gt;&gt; /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt;&gt;&gt;&gt;&gt;&gt; ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent`<br>&gt;&gt;&gt;&gt;&gt;&gt; ///   iff `a === b`.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same`<br>&gt;&gt;&gt; *but<br>&gt;&gt;&gt;&gt;&gt;&gt; not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the<br>&gt;&gt;&gt; sign<br>&gt;&gt;&gt;&gt;&gt;&gt; of zero (so +0 = −0)”.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The point of this design is that `===` means identity and that `.same `<br>&gt;&gt;&gt;&gt;&gt;&gt; also means identity.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Since this is new territory I suppose we get to decide what identity<br>&gt;&gt;&gt;&gt;&gt;&gt; means for floating point.  Should +0 and -0 have the same identity or<br>&gt;&gt;&gt;&gt;&gt;&gt; not?  I’ll leave the answer to folks more knowledgable about numerics<br>&gt;&gt;&gt;&gt;&gt;&gt; than I.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s settled law<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; https://en.wikipedia.org/wiki/IEEE_floating_point#Total-ordering_predicate<br>&gt;&gt;&gt;&gt;&gt;&gt; :-)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, assuming we want to define identity in terms of the IEEE<br>&gt;&gt;&gt; definition<br>&gt;&gt;&gt;&gt;&gt;&gt; of total ordering.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I see what you&#39;re saying here. That could work. Comparable `===` and<br>&gt;&gt;&gt;&gt;&gt; Equatable `&lt;=&gt;` could do its own thing, and FloatingPoint<br>&gt;&gt;&gt;&gt;&gt; `isTotallyOrdered(below:)` can preserve the IEEE definition of total<br>&gt;&gt;&gt;&gt;&gt; ordering<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Actually, I was hinting at your argument that `===` true iff `&lt;=&gt;` same<br>&gt;&gt;&gt;&gt;&gt; shouldn’t be a semantic requirement of the protocols.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is another option, but I don’t think it’s going to fly.  It seems<br>&gt;&gt;&gt;&gt;&gt; reasonable to assume that `&lt;=&gt;` will have IEEE semantics.  We will trip<br>&gt;&gt;&gt; a<br>&gt;&gt;&gt;&gt;&gt; lot of people up if it doesn’t.  That’s a big reason we can’t consider<br>&gt;&gt;&gt;&gt;&gt; changing floating point `==` to define an equivalence relation.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Actually, here I doubt it. The total ordering isn&#39;t exposed as part of<br>&gt;&gt;&gt; any<br>&gt;&gt;&gt;&gt; comparison operator defined in the IEEE spec. In fact, the total ordering<br>&gt;&gt;&gt;&gt; wasn&#39;t introduced until a (fairly) recent IEEE revision, IIUC. Breaking<br>&gt;&gt;&gt;&gt; `==` would definitely cause people to jump, but `&lt;=&gt;` needn&#39;t be the IEEE<br>&gt;&gt;&gt;&gt; totalOrder predicate IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Wait, I thought we were saying that `&lt;=&gt;` could be IEEE totalOrder, and<br>&gt;&gt;&gt; `===` could be like `==` but with well-behaved NaNs, so it&#39;s still an<br>&gt;&gt;&gt; equivalence relation, thus declaring the signedness of 0 to be<br>&gt;&gt;&gt; inessential.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I was (that was the &quot;=== if but not iff &lt;=&gt;&quot; business above), then I<br>&gt;&gt; thought Matthew was saying something different and agreed with him.<br>&gt;&gt; <br>&gt;&gt; What I thought that Matthew thought was actually very insightful. He didn&#39;t<br>&gt;&gt; actually think this, apparently, but: IEEE totalOrder does exactly what it<br>&gt;&gt; says on the tin. But, it is not useful for any generic comparisons or (as<br>&gt;&gt; far as I&#39;m aware) any generic sorting algorithms. I cannot conceive of a<br>&gt;&gt; numeric algorithm or a generic algorithm that relies on two equal floating<br>&gt;&gt; point values being ordered based on their binary representation. We should<br>&gt;&gt; have some way of exposing totalOrder to a user of a BinaryFloatingPoint<br>&gt;&gt; type, but I don&#39;t know that it should be the basis for floating point<br>&gt;&gt; *identity* with respect to protocol conformance. It&#39;s explicitly *not* what<br>&gt;&gt; IEEE recommends for comparison anyway.<br>&gt; <br>&gt; That makes sense.  Perhaps IEEE hasn&#39;t actually made a principled<br>&gt; decision about which aspects of floating point numbers are essential,<br>&gt; and we have to do it for them.<br></p><p>Xiaodi is swaying me on this point as well.  I am no numerics expert so I don’t know of cases where the difference between -0 and +0 matter and whether the reasons they matter in these cases are applicable to generic code or not. But maybe it is the case that they actually don’t.  (Or maybe they are just an artifact of the implementation in which case the difference really shouldn’t matter at all)<br></p><p>&gt; <br>&gt; -- <br>&gt; Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/ff81f14b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 22, 2016 at 10:00:00pm</p></header><div class="content"><p>On Fri, Jul 22, 2016 at 10:04 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jul 22, 2016, at 9:57 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; on Fri Jul 22 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com<br>&gt; &lt;http://xiaodi.wu-at-gmail.com/&gt;&gt; wrote:<br>&gt;<br>&gt; On Fri, Jul 22, 2016 at 9:46 PM, Dave Abrahams &lt;dabrahams at apple.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt; on Fri Jul 22 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com<br>&gt; &lt;http://xiaodi.wu-at-gmail.com&gt;&gt; wrote:<br>&gt;<br>&gt; On Fri, Jul 22, 2016 at 9:23 PM, Matthew Johnson &lt;matthew at anandabits.com<br>&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jul 22, 2016, at 9:17 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Fri, Jul 22, 2016 at 9:15 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jul 22, 2016, at 9:04 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; on Fri Jul 22 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Jul 22, 2016, at 8:37 PM, Xiaodi Wu via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Fri, Jul 22, 2016 at 8:20 PM, Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org<br>&gt;<br>&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt; swift-evolution at swift.org&gt;&gt;&gt;<br>&gt; wrote:<br>&gt;<br>&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org<br>&gt; &lt;http://daniel-at-duan.org&gt;<br>&gt; &lt;http://daniel-at-duan.org/&gt;&gt; wrote:<br>&gt;<br>&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt; swift-evolution at swift.org&gt;&gt;&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt; on Fri Jul 22 2016, Daniel Duan<br>&gt; &lt;swift-evolution at swift.org<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt; swift-evolution at swift.org&gt;&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt; swift-evolution at swift.org&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt; swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt; swift-evolution at swift.org&gt;&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt; swift-evolution at swift.org&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt; swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt; on Thu Jul 21 2016, Duan<br>&gt;<br>&gt;<br>&gt; &lt;swift-evolution at swift.org<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt; swift-evolution at swift.org&gt;&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt; swift-evolution at swift.org&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt; swift-evolution at swift.org&gt;&gt;&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt; swift-evolution at swift.org&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt; swift-evolution at swift.org&gt;&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt; swift-evolution at swift.org&gt;<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt; swift-evolution at swift.org&gt;&gt;&gt;&gt;&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt; think this is about identity.<br>&gt;<br>&gt; I like areEquivalent() but there may be better names.<br>&gt;<br>&gt;<br>&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt; that doesn&#39;t change the fact that areEquivalent might be a better name.<br>&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt; benefit.<br>&gt;<br>&gt;<br>&gt; If the addresses of the arguments aren’t being used, then we don’t<br>&gt; consider<br>&gt; them part of their *identity*. I can follow this logic. My fear is most<br>&gt; users<br>&gt; won’t make this leap on their own and get the same initial impression<br>&gt;<br>&gt; as<br>&gt;<br>&gt; I did.<br>&gt; It&#39;s entirely possible this fear is unfounded. Some educated<br>&gt;<br>&gt; bikesheding<br>&gt;<br>&gt; wouldn&#39;t hurt here IMO :)<br>&gt;<br>&gt;<br>&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt; it with ===.<br>&gt;<br>&gt;<br>&gt; To spell this out (because I had to think about it for a second): ===<br>&gt; will be derived from<br>&gt; &lt;=&gt;,<br>&gt; but also becomes default implementation for ==, which remains open for<br>&gt; customization.<br>&gt;<br>&gt;<br>&gt; I was imagining roughly this (untested):<br>&gt;<br>&gt; /// Two references are identical if they refer to the same<br>&gt; /// instance.<br>&gt; ///<br>&gt; /// - Note: Classes with a more-refined notion of “identical”<br>&gt; ///   should conform to `Identifiable` and implement `===`.<br>&gt; func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt;   ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt; }<br>&gt;<br>&gt; /// Supports testing that two values of `Self` are identical<br>&gt; ///<br>&gt; /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt; /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt; /// type can document that specific observable characteristics<br>&gt; /// (such as the `capacity` of an `Array`) are inessential and<br>&gt; /// thus not to be considered as part of the interchangeability<br>&gt; /// guarantee.<br>&gt; ///<br>&gt; /// - Requires: `===` induces an equivalence relation over<br>&gt; ///   instances.<br>&gt; /// - Note: conforming types will gain an `==` operator that<br>&gt; ///   forwards to `===`.<br>&gt; /// - Note: Types that require domain-specific `==`<br>&gt; ///   implementations with different semantics (e.g. floating<br>&gt; ///   point) should define a more-specific overload of `==`,<br>&gt; ///   which will be used in contexts where the static type is<br>&gt; ///   known to the compiler.<br>&gt; /// - Note: Generic code should usually use `==` to compare<br>&gt; ///   conforming instances; that will always dispatch to `===`<br>&gt; ///   and will be unaffected by more specific overloads of<br>&gt; ///   `==`.<br>&gt; protocol Identifiable { // née Equatable name is negotiable<br>&gt;   func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt; }<br>&gt;<br>&gt; /// Default definition of `==` for Identifiable types.<br>&gt; func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;   return lhs === rhs<br>&gt; }<br>&gt;<br>&gt; /// Conforming types have a default total ordering.<br>&gt; ///<br>&gt; /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt; /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt; /// type can document that specific observable characteristics<br>&gt; /// (such as the `capacity` of an `Array`) are inessential and<br>&gt; /// thus not to be considered as part of the interchangeability<br>&gt; /// guarantee.<br>&gt; ///<br>&gt; /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt; ///   instances.<br>&gt; /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt; ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent`<br>&gt; ///   iff `a === b`.<br>&gt;<br>&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same`<br>&gt;<br>&gt; *but<br>&gt;<br>&gt; not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the<br>&gt;<br>&gt; sign<br>&gt;<br>&gt; of zero (so +0 = −0)”.<br>&gt;<br>&gt;<br>&gt; The point of this design is that `===` means identity and that `.same `<br>&gt; also means identity.<br>&gt;<br>&gt; Since this is new territory I suppose we get to decide what identity<br>&gt; means for floating point.  Should +0 and -0 have the same identity or<br>&gt; not?  I’ll leave the answer to folks more knowledgable about numerics<br>&gt; than I.<br>&gt;<br>&gt;<br>&gt; It&#39;s settled law<br>&gt;<br>&gt; https://en.wikipedia.org/wiki/IEEE_floating_point#Total-ordering_predicate<br>&gt;<br>&gt; :-)<br>&gt;<br>&gt;<br>&gt; Yes, assuming we want to define identity in terms of the IEEE<br>&gt;<br>&gt; definition<br>&gt;<br>&gt; of total ordering.<br>&gt;<br>&gt;<br>&gt; I see what you&#39;re saying here. That could work. Comparable `===` and<br>&gt; Equatable `&lt;=&gt;` could do its own thing, and FloatingPoint<br>&gt; `isTotallyOrdered(below:)` can preserve the IEEE definition of total<br>&gt; ordering<br>&gt;<br>&gt;<br>&gt; Actually, I was hinting at your argument that `===` true iff `&lt;=&gt;` same<br>&gt; shouldn’t be a semantic requirement of the protocols.<br>&gt;<br>&gt; This is another option, but I don’t think it’s going to fly.  It seems<br>&gt; reasonable to assume that `&lt;=&gt;` will have IEEE semantics.  We will trip<br>&gt;<br>&gt; a<br>&gt;<br>&gt; lot of people up if it doesn’t.  That’s a big reason we can’t consider<br>&gt; changing floating point `==` to define an equivalence relation.<br>&gt;<br>&gt;<br>&gt; Actually, here I doubt it. The total ordering isn&#39;t exposed as part of<br>&gt;<br>&gt; any<br>&gt;<br>&gt; comparison operator defined in the IEEE spec. In fact, the total ordering<br>&gt; wasn&#39;t introduced until a (fairly) recent IEEE revision, IIUC. Breaking<br>&gt; `==` would definitely cause people to jump, but `&lt;=&gt;` needn&#39;t be the IEEE<br>&gt; totalOrder predicate IMO.<br>&gt;<br>&gt;<br>&gt; Wait, I thought we were saying that `&lt;=&gt;` could be IEEE totalOrder, and<br>&gt; `===` could be like `==` but with well-behaved NaNs, so it&#39;s still an<br>&gt; equivalence relation, thus declaring the signedness of 0 to be<br>&gt; inessential.<br>&gt;<br>&gt;<br>&gt; I was (that was the &quot;=== if but not iff &lt;=&gt;&quot; business above), then I<br>&gt; thought Matthew was saying something different and agreed with him.<br>&gt;<br>&gt; What I thought that Matthew thought was actually very insightful. He didn&#39;t<br>&gt; actually think this, apparently, but: IEEE totalOrder does exactly what it<br>&gt; says on the tin. But, it is not useful for any generic comparisons or (as<br>&gt; far as I&#39;m aware) any generic sorting algorithms. I cannot conceive of a<br>&gt; numeric algorithm or a generic algorithm that relies on two equal floating<br>&gt; point values being ordered based on their binary representation. We should<br>&gt; have some way of exposing totalOrder to a user of a BinaryFloatingPoint<br>&gt; type, but I don&#39;t know that it should be the basis for floating point<br>&gt; *identity* with respect to protocol conformance. It&#39;s explicitly *not* what<br>&gt; IEEE recommends for comparison anyway.<br>&gt;<br>&gt;<br>&gt; That makes sense.  Perhaps IEEE hasn&#39;t actually made a principled<br>&gt; decision about which aspects of floating point numbers are essential,<br>&gt; and we have to do it for them.<br>&gt;<br>&gt;<br>&gt; Xiaodi is swaying me on this point as well.  I am no numerics expert so I<br>&gt; don’t know of cases where the difference between -0 and +0 matter and<br>&gt; whether the reasons they matter in these cases are applicable to generic<br>&gt; code or not.<br>&gt;<br></p><p>Please don&#39;t let me sway you guys too much. I&#39;m dealing with floating point<br>values up to my eyeballs but I&#39;m not even close to being an expert. We<br>really need Steve to do a sanity check.<br></p><p>But maybe it is the case that they actually don’t.  (Or maybe they are just<br>&gt; an artifact of the implementation in which case the difference really<br>&gt; shouldn’t matter at all)<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/1590ffe0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 22, 2016 at 08:00:00pm</p></header><div class="content"><p>on Fri Jul 22 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; On Fri, Jul 22, 2016 at 10:04 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 22, 2016, at 9:57 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; on Fri Jul 22 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com<br>&gt;&gt; &lt;http://xiaodi.wu-at-gmail.com/&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Fri, Jul 22, 2016 at 9:46 PM, Dave Abrahams &lt;dabrahams at apple.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; on Fri Jul 22 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com<br>&gt;&gt; &lt;http://xiaodi.wu-at-gmail.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Fri, Jul 22, 2016 at 9:23 PM, Matthew Johnson &lt;matthew at anandabits.com<br>&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 22, 2016, at 9:17 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Fri, Jul 22, 2016 at 9:15 PM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 22, 2016, at 9:04 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; on Fri Jul 22 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Jul 22, 2016, at 8:37 PM, Xiaodi Wu via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Fri, Jul 22, 2016 at 8:20 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org<br>&gt;&gt; &lt;http://daniel-at-duan.org&gt;<br>&gt;&gt; &lt;http://daniel-at-duan.org/&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; on Fri Jul 22 2016, Daniel Duan<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt; &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt;&gt; think this is about identity.<br>&gt;&gt;<br>&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better name.<br>&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt;&gt; benefit.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t<br>&gt;&gt; consider<br>&gt;&gt; them part of their *identity*. I can follow this logic. My fear is most<br>&gt;&gt; users<br>&gt;&gt; won’t make this leap on their own and get the same initial impression<br>&gt;&gt;<br>&gt;&gt; as<br>&gt;&gt;<br>&gt;&gt; I did.<br>&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated<br>&gt;&gt;<br>&gt;&gt; bikesheding<br>&gt;&gt;<br>&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt;&gt; it with ===.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; To spell this out (because I had to think about it for a second): ===<br>&gt;&gt; will be derived from<br>&gt;&gt; &lt;=&gt;,<br>&gt;&gt; but also becomes default implementation for ==, which remains open for<br>&gt;&gt; customization.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I was imagining roughly this (untested):<br>&gt;&gt;<br>&gt;&gt; /// Two references are identical if they refer to the same<br>&gt;&gt; /// instance.<br>&gt;&gt; ///<br>&gt;&gt; /// - Note: Classes with a more-refined notion of “identical”<br>&gt;&gt; ///   should conform to `Identifiable` and implement `===`.<br>&gt;&gt; func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt;&gt;   ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; /// Supports testing that two values of `Self` are identical<br>&gt;&gt; ///<br>&gt;&gt; /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt;&gt; /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt; /// type can document that specific observable characteristics<br>&gt;&gt; /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt; /// thus not to be considered as part of the interchangeability<br>&gt;&gt; /// guarantee.<br>&gt;&gt; ///<br>&gt;&gt; /// - Requires: `===` induces an equivalence relation over<br>&gt;&gt; ///   instances.<br>&gt;&gt; /// - Note: conforming types will gain an `==` operator that<br>&gt;&gt; ///   forwards to `===`.<br>&gt;&gt; /// - Note: Types that require domain-specific `==`<br>&gt;&gt; ///   implementations with different semantics (e.g. floating<br>&gt;&gt; ///   point) should define a more-specific overload of `==`,<br>&gt;&gt; ///   which will be used in contexts where the static type is<br>&gt;&gt; ///   known to the compiler.<br>&gt;&gt; /// - Note: Generic code should usually use `==` to compare<br>&gt;&gt; ///   conforming instances; that will always dispatch to `===`<br>&gt;&gt; ///   and will be unaffected by more specific overloads of<br>&gt;&gt; ///   `==`.<br>&gt;&gt; protocol Identifiable { // née Equatable name is negotiable<br>&gt;&gt;   func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; /// Default definition of `==` for Identifiable types.<br>&gt;&gt; func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;   return lhs === rhs<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; /// Conforming types have a default total ordering.<br>&gt;&gt; ///<br>&gt;&gt; /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt;&gt; /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt; /// type can document that specific observable characteristics<br>&gt;&gt; /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt; /// thus not to be considered as part of the interchangeability<br>&gt;&gt; /// guarantee.<br>&gt;&gt; ///<br>&gt;&gt; /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt;&gt; ///   instances.<br>&gt;&gt; /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt;&gt; ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent`<br>&gt;&gt; ///   iff `a === b`.<br>&gt;&gt;<br>&gt;&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same`<br>&gt;&gt;<br>&gt;&gt; *but<br>&gt;&gt;<br>&gt;&gt; not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the<br>&gt;&gt;<br>&gt;&gt; sign<br>&gt;&gt;<br>&gt;&gt; of zero (so +0 = −0)”.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The point of this design is that `===` means identity and that `.same `<br>&gt;&gt; also means identity.<br>&gt;&gt;<br>&gt;&gt; Since this is new territory I suppose we get to decide what identity<br>&gt;&gt; means for floating point.  Should +0 and -0 have the same identity or<br>&gt;&gt; not?  I’ll leave the answer to folks more knowledgable about numerics<br>&gt;&gt; than I.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It&#39;s settled law<br>&gt;&gt;<br>&gt;&gt; https://en.wikipedia.org/wiki/IEEE_floating_point#Total-ordering_predicate<br>&gt;&gt;<br>&gt;&gt; :-)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes, assuming we want to define identity in terms of the IEEE<br>&gt;&gt;<br>&gt;&gt; definition<br>&gt;&gt;<br>&gt;&gt; of total ordering.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I see what you&#39;re saying here. That could work. Comparable `===` and<br>&gt;&gt; Equatable `&lt;=&gt;` could do its own thing, and FloatingPoint<br>&gt;&gt; `isTotallyOrdered(below:)` can preserve the IEEE definition of total<br>&gt;&gt; ordering<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Actually, I was hinting at your argument that `===` true iff `&lt;=&gt;` same<br>&gt;&gt; shouldn’t be a semantic requirement of the protocols.<br>&gt;&gt;<br>&gt;&gt; This is another option, but I don’t think it’s going to fly.  It seems<br>&gt;&gt; reasonable to assume that `&lt;=&gt;` will have IEEE semantics.  We will trip<br>&gt;&gt;<br>&gt;&gt; a<br>&gt;&gt;<br>&gt;&gt; lot of people up if it doesn’t.  That’s a big reason we can’t consider<br>&gt;&gt; changing floating point `==` to define an equivalence relation.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Actually, here I doubt it. The total ordering isn&#39;t exposed as part of<br>&gt;&gt;<br>&gt;&gt; any<br>&gt;&gt;<br>&gt;&gt; comparison operator defined in the IEEE spec. In fact, the total ordering<br>&gt;&gt; wasn&#39;t introduced until a (fairly) recent IEEE revision, IIUC. Breaking<br>&gt;&gt; `==` would definitely cause people to jump, but `&lt;=&gt;` needn&#39;t be the IEEE<br>&gt;&gt; totalOrder predicate IMO.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Wait, I thought we were saying that `&lt;=&gt;` could be IEEE totalOrder, and<br>&gt;&gt; `===` could be like `==` but with well-behaved NaNs, so it&#39;s still an<br>&gt;&gt; equivalence relation, thus declaring the signedness of 0 to be<br>&gt;&gt; inessential.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I was (that was the &quot;=== if but not iff &lt;=&gt;&quot; business above), then I<br>&gt;&gt; thought Matthew was saying something different and agreed with him.<br>&gt;&gt;<br>&gt;&gt; What I thought that Matthew thought was actually very insightful. He didn&#39;t<br>&gt;&gt; actually think this, apparently, but: IEEE totalOrder does exactly what it<br>&gt;&gt; says on the tin. But, it is not useful for any generic comparisons or (as<br>&gt;&gt; far as I&#39;m aware) any generic sorting algorithms. I cannot conceive of a<br>&gt;&gt; numeric algorithm or a generic algorithm that relies on two equal floating<br>&gt;&gt; point values being ordered based on their binary representation. We should<br>&gt;&gt; have some way of exposing totalOrder to a user of a BinaryFloatingPoint<br>&gt;&gt; type, but I don&#39;t know that it should be the basis for floating point<br>&gt;&gt; *identity* with respect to protocol conformance. It&#39;s explicitly *not* what<br>&gt;&gt; IEEE recommends for comparison anyway.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That makes sense.  Perhaps IEEE hasn&#39;t actually made a principled<br>&gt;&gt; decision about which aspects of floating point numbers are essential,<br>&gt;&gt; and we have to do it for them.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Xiaodi is swaying me on this point as well.  I am no numerics expert so I<br>&gt;&gt; don’t know of cases where the difference between -0 and +0 matter and<br>&gt;&gt; whether the reasons they matter in these cases are applicable to generic<br>&gt;&gt; code or not.<br>&gt;&gt;<br>&gt;<br>&gt; Please don&#39;t let me sway you guys too much. I&#39;m dealing with floating point<br>&gt; values up to my eyeballs but I&#39;m not even close to being an expert. We<br>&gt; really need Steve to do a sanity check.<br></p><p>Indeed.<br></p><p>&gt;&gt; But maybe it is the case that they actually don’t.  (Or maybe they are just<br>&gt;&gt; an artifact of the implementation in which case the difference really<br>&gt;&gt; shouldn’t matter at all)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>July 23, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; The point of this design is that `===` means identity and that `.same `<br>&gt; also means identity.<br>&gt; <br>&gt; Since this is new territory I suppose we get to decide what identity<br>&gt; means for floating point.  Should +0 and -0 have the same identity or<br>&gt; not?  I’ll leave the answer to folks more knowledgable about numerics<br>&gt; than I.<br></p><p>Boy, I take my wife out for a movie and come back to 50 new messages on SE.<br></p><p>I need to read the entire thread more carefully, but off the top of my head, I think that `-0 === +0` is False.  If we’re going to have an `isSame` / `isIdentical` / whatever it&#39;s called, I would expect it to imply substitutability.  Although -0 == +0, they are not equivalent when substituted:<br></p><p>- 1/(-0) != 1/0<br>- Float(-0).sign != Float(+0).sign<br>- etc<br></p><p>This probably then implies that `&lt;=&gt;` is not `.same` either.  I’ll read the rest of this and respond more completely tomorrow.<br></p><p>– Steve<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 23, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; Am 23.07.2016 um 06:34 schrieb Stephen Canon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; The point of this design is that `===` means identity and that `.same `<br>&gt;&gt; also means identity.<br>&gt;&gt; <br>&gt;&gt; Since this is new territory I suppose we get to decide what identity<br>&gt;&gt; means for floating point.  Should +0 and -0 have the same identity or<br>&gt;&gt; not?  I’ll leave the answer to folks more knowledgable about numerics<br>&gt;&gt; than I.<br>&gt; <br>&gt; Boy, I take my wife out for a movie and come back to 50 new messages on SE.<br></p><p>I had the same feeling (short nap for the night and 96 new messages to this thread). I really do like the discussion whether NaN != NaN and similar cases are breaking the contract of ==. I think it is. I started some proposals last week [0], where I pointed out, that implementing equivalence relations is error-prone and the std lib is relying on it. We had there these special cases for Floating points, too. I think it is crucial to get `==` right, and then we get `&lt;=` right :).<br></p><p>IMO, the core of the proposals idea is a good one: separating custom implementations from the ones that std lib relies on. Then you could have unchangeable default behavior (in terms of not allowing false-negatives like NaN != NaN) and still have custom implementations. The std lib (and any other library that needs equality and comparable follow the contract) will just continue working.<br></p><p>I didn’t read everything in this thread, but there were proposals to use === instead of isSame, but currently when I write `-0.0 === 0.0` just says that this operator is not implemented for Float (a value type). This makes totally sense, because value types have by definition no identity.<br></p><p>The discussions about is NaN != NaN and will code be portable and the like are reasonable, but Swift should IMO not try to make it easy for programmers of other languages to convert (hey Swift drops i++ and ++i and the like because this is not the focus), but to make it simple „as is“ (so for new programmers and for all who are willing to get oneself into Swift).<br></p><p>So putting all this special semantics for floating point into a special custom implementation would be good with me. It would be great if operators in Swift could contain letters. Then we could have `==` (standard conform) and `==f` or something like this for floating point semantics.<br></p><p>All the best<br>Johannes<br></p><p>[0]: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160718/024599.html<br></p><p>&gt; <br>&gt; I need to read the entire thread more carefully, but off the top of my head, I think that `-0 === +0` is False.  If we’re going to have an `isSame` / `isIdentical` / whatever it&#39;s called, I would expect it to imply substitutability.  Although -0 == +0, they are not equivalent when substituted:<br>&gt; <br>&gt; - 1/(-0) != 1/0<br>&gt; - Float(-0).sign != Float(+0).sign<br>&gt; - etc<br>&gt; <br>&gt; This probably then implies that `&lt;=&gt;` is not `.same` either.  I’ll read the rest of this and respond more completely tomorrow.<br>&gt; <br>&gt; – Steve<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160723/aa8ce6ce/attachment.sig&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 23, 2016 at 01:00:00pm</p></header><div class="content"><p>On Fri, Jul 22, 2016 at 11:34 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br></p><p>&gt; &gt; The point of this design is that `===` means identity and that `.same `<br>&gt; &gt; also means identity.<br>&gt; &gt;<br>&gt; &gt; Since this is new territory I suppose we get to decide what identity<br>&gt; &gt; means for floating point.  Should +0 and -0 have the same identity or<br>&gt; &gt; not?  I’ll leave the answer to folks more knowledgable about numerics<br>&gt; &gt; than I.<br>&gt;<br>&gt; Boy, I take my wife out for a movie and come back to 50 new messages on SE.<br>&gt;<br>&gt; I need to read the entire thread more carefully, but off the top of my<br>&gt; head, I think that `-0 === +0` is False.  If we’re going to have an<br>&gt; `isSame` / `isIdentical` / whatever it&#39;s called, I would expect it to imply<br>&gt; substitutability.  Although -0 == +0, they are not equivalent when<br>&gt; substituted:<br>&gt;<br>&gt; - 1/(-0) != 1/0<br>&gt; - Float(-0).sign != Float(+0).sign<br>&gt; - etc<br>&gt;<br>&gt; This probably then implies that `&lt;=&gt;` is not `.same` either.  I’ll read<br>&gt; the rest of this and respond more completely tomorrow.<br>&gt;<br></p><p>Eagerly await your evaluation of the discussion. In the meantime:<br></p><p>I think Dave&#39;s view that `===` defines identity in terms of &quot;essential&quot;<br>qualities implies that two identical values can be<br>different/non-substitutable in &quot;inessential&quot; qualities. For generic<br>purposes, the sign of zero could be one such inessential quality.<br></p><p>On the other hand, the stdlib stride algorithm is going to be borked if -0<br>&lt; +0. Of course, as we already started to do there, we could specialize for<br>floating point and then adjust accordingly. However, it seems to me that<br>every generic algorithm that performs comparisons and can take floating<br>point arguments would have to be specialized to account for floating point<br>-0 != +0 (`index(of:)` being the previous example). This appears to defeat<br>the aim of trying to accommodate FP at all in this revised design for<br>Comparables.<br></p><p>The argument for `-0 === +0` is that -0 and +0 should be equivalent when<br>substituted for every comparison operation. For FP operations, you&#39;d<br>continue to test (as you have to test now) `a == b &amp;&amp; a.sign == b.sign` if<br>you cared about the sign of zero. For non-FP arithmetic operations, hmm,<br>not sure how to square that circle.<br></p><p><br>&gt; – Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160723/915c64e3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 23, 2016 at 11:00:00am</p></header><div class="content"><p>on Sat Jul 23 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; On Fri, Jul 22, 2016 at 11:34 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; The point of this design is that `===` means identity and that `.same `<br>&gt;&gt; &gt; also means identity.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Since this is new territory I suppose we get to decide what identity<br>&gt;&gt; &gt; means for floating point.  Should +0 and -0 have the same identity or<br>&gt;&gt; &gt; not?  I’ll leave the answer to folks more knowledgable about numerics<br>&gt;&gt; &gt; than I.<br>&gt;&gt;<br>&gt;&gt; Boy, I take my wife out for a movie and come back to 50 new messages on SE.<br>&gt;&gt;<br>&gt;&gt; I need to read the entire thread more carefully, but off the top of my<br>&gt;&gt; head, I think that `-0 === +0` is False.  If we’re going to have an<br>&gt;&gt; `isSame` / `isIdentical` / whatever it&#39;s called, I would expect it to imply<br>&gt;&gt; substitutability.  Although -0 == +0, they are not equivalent when<br>&gt;&gt; substituted:<br>&gt;&gt;<br>&gt;&gt; - 1/(-0) != 1/0<br>&gt;&gt; - Float(-0).sign != Float(+0).sign<br>&gt;&gt; - etc<br>&gt;&gt;<br>&gt;&gt; This probably then implies that `&lt;=&gt;` is not `.same` either.  I’ll read<br>&gt;&gt; the rest of this and respond more completely tomorrow.<br>&gt;&gt;<br>&gt;<br>&gt; Eagerly await your evaluation of the discussion. In the meantime:<br>&gt;<br>&gt; I think Dave&#39;s view that `===` defines identity in terms of &quot;essential&quot;<br>&gt; qualities implies that two identical values can be<br>&gt; different/non-substitutable in &quot;inessential&quot; qualities. For generic<br>&gt; purposes, the sign of zero could be one such inessential quality.<br></p><p>Yes, and I think our view of how people work with numbers in swift (and<br>their protocol conformances) reflect this approach.  <br></p><p>http://article.gmane.org/gmane.comp.lang.swift.evolution/16321<br></p><p>My sense is that we want to choose the default notions of identity and<br>ordering so as to support the way people think about these numeric<br>types, inexact though it may be.  Therefore, finding 0.0 in a sequence<br>of floats should succeed when the sequence contains -0.0, and a stable<br>sort on floating point keys should preserve the relative order of all<br>elements having +0.0 and -0.0 keys.  <br></p><p>People that want to work with inessential qualities such as the sign of<br>zero can always pass Float.totalOrdering (or whatever) to their<br>closure-accepting algorithms.<br></p><p>[In order to support the user model, we still need to fix the semantics<br>of the default identity and ordering operations so that things like<br>sorting and searching work, which is why == and &lt; won&#39;t cut it for these<br>purposes]<br></p><p>&gt; On the other hand, the stdlib stride algorithm is going to be borked if -0<br>&gt; &lt; +0. Of course, as we already started to do there, we could specialize for<br>&gt; floating point and then adjust accordingly. However, it seems to me that<br>&gt; every generic algorithm that performs comparisons and can take floating<br>&gt; point arguments would have to be specialized to account for floating point<br>&gt; -0 != +0 (`index(of:)` being the previous example). This appears to defeat<br>&gt; the aim of trying to accommodate FP at all in this revised design for<br>&gt; Comparables.<br></p><p>Yes, that would be a disaster, generically speaking.<br></p><p>&gt; The argument for `-0 === +0` is that -0 and +0 should be equivalent when<br>&gt; substituted for every comparison operation. For FP operations, you&#39;d<br>&gt; continue to test (as you have to test now) `a == b &amp;&amp; a.sign == b.sign` if<br>&gt; you cared about the sign of zero. For non-FP arithmetic operations, hmm,<br>&gt; not sure how to square that circle.<br></p><p>I followed all of this... except, what are you getting at with that last<br>sentence?<br></p><p>--<br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 23, 2016 at 06:00:00pm</p></header><div class="content"><p>That last sentence: division is defined in Arithmetic (IIUC--I&#39;m not in<br>front of a traditional computer ATM). I would expect, for any arithmetic<br>type T, that the following would return true:<br></p><p>let a, b, c: T<br>if a == b {<br>return c/a == c/b<br>}<br></p><p>This would not hold for all a and b if -0 === +0.<br></p><p>On Sat, Jul 23, 2016 at 13:41 Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; on Sat Jul 23 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt; &gt; On Fri, Jul 22, 2016 at 11:34 PM, Stephen Canon &lt;scanon at apple.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; &gt; The point of this design is that `===` means identity and that `.same<br>&gt; `<br>&gt; &gt;&gt; &gt; also means identity.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; Since this is new territory I suppose we get to decide what identity<br>&gt; &gt;&gt; &gt; means for floating point.  Should +0 and -0 have the same identity or<br>&gt; &gt;&gt; &gt; not?  I’ll leave the answer to folks more knowledgable about numerics<br>&gt; &gt;&gt; &gt; than I.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Boy, I take my wife out for a movie and come back to 50 new messages on<br>&gt; SE.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I need to read the entire thread more carefully, but off the top of my<br>&gt; &gt;&gt; head, I think that `-0 === +0` is False.  If we’re going to have an<br>&gt; &gt;&gt; `isSame` / `isIdentical` / whatever it&#39;s called, I would expect it to<br>&gt; imply<br>&gt; &gt;&gt; substitutability.  Although -0 == +0, they are not equivalent when<br>&gt; &gt;&gt; substituted:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - 1/(-0) != 1/0<br>&gt; &gt;&gt; - Float(-0).sign != Float(+0).sign<br>&gt; &gt;&gt; - etc<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This probably then implies that `&lt;=&gt;` is not `.same` either.  I’ll read<br>&gt; &gt;&gt; the rest of this and respond more completely tomorrow.<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt; Eagerly await your evaluation of the discussion. In the meantime:<br>&gt; &gt;<br>&gt; &gt; I think Dave&#39;s view that `===` defines identity in terms of &quot;essential&quot;<br>&gt; &gt; qualities implies that two identical values can be<br>&gt; &gt; different/non-substitutable in &quot;inessential&quot; qualities. For generic<br>&gt; &gt; purposes, the sign of zero could be one such inessential quality.<br>&gt;<br>&gt; Yes, and I think our view of how people work with numbers in swift (and<br>&gt; their protocol conformances) reflect this approach.<br>&gt;<br>&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/16321<br>&gt;<br>&gt; My sense is that we want to choose the default notions of identity and<br>&gt; ordering so as to support the way people think about these numeric<br>&gt; types, inexact though it may be.  Therefore, finding 0.0 in a sequence<br>&gt; of floats should succeed when the sequence contains -0.0, and a stable<br>&gt; sort on floating point keys should preserve the relative order of all<br>&gt; elements having +0.0 and -0.0 keys.<br>&gt;<br>&gt; People that want to work with inessential qualities such as the sign of<br>&gt; zero can always pass Float.totalOrdering (or whatever) to their<br>&gt; closure-accepting algorithms.<br>&gt;<br>&gt; [In order to support the user model, we still need to fix the semantics<br>&gt; of the default identity and ordering operations so that things like<br>&gt; sorting and searching work, which is why == and &lt; won&#39;t cut it for these<br>&gt; purposes]<br>&gt;<br>&gt; &gt; On the other hand, the stdlib stride algorithm is going to be borked if<br>&gt; -0<br>&gt; &gt; &lt; +0. Of course, as we already started to do there, we could specialize<br>&gt; for<br>&gt; &gt; floating point and then adjust accordingly. However, it seems to me that<br>&gt; &gt; every generic algorithm that performs comparisons and can take floating<br>&gt; &gt; point arguments would have to be specialized to account for floating<br>&gt; point<br>&gt; &gt; -0 != +0 (`index(of:)` being the previous example). This appears to<br>&gt; defeat<br>&gt; &gt; the aim of trying to accommodate FP at all in this revised design for<br>&gt; &gt; Comparables.<br>&gt;<br>&gt; Yes, that would be a disaster, generically speaking.<br>&gt;<br>&gt; &gt; The argument for `-0 === +0` is that -0 and +0 should be equivalent when<br>&gt; &gt; substituted for every comparison operation. For FP operations, you&#39;d<br>&gt; &gt; continue to test (as you have to test now) `a == b &amp;&amp; a.sign == b.sign`<br>&gt; if<br>&gt; &gt; you cared about the sign of zero. For non-FP arithmetic operations, hmm,<br>&gt; &gt; not sure how to square that circle.<br>&gt;<br>&gt; I followed all of this... except, what are you getting at with that last<br>&gt; sentence?<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160723/2b85f196/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 23, 2016 at 01:00:00pm</p></header><div class="content"><p>on Sat Jul 23 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; That last sentence: division is defined in Arithmetic (IIUC--I&#39;m not in<br>&gt; front of a traditional computer ATM). <br></p><p>Yes.<br></p><p>&gt; I would expect, for any arithmetic type T, that the following would<br>&gt; return true:<br>&gt;<br>&gt; let a, b, c: T<br>&gt; if a == b {<br>&gt; return c/a == c/b<br>&gt; }<br>&gt;<br>&gt; This would not hold for all a and b if -0 === +0.<br></p><p>That would be nice, wouldn&#39;t it?  But there are lots of expected<br>arithmetic laws that floating point won&#39;t obey.<br></p><p>&gt;<br>&gt;<br>&gt; On Sat, Jul 23, 2016 at 13:41 Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Sat Jul 23 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; On Fri, Jul 22, 2016 at 11:34 PM, Stephen Canon &lt;scanon at apple.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; The point of this design is that `===` means identity and that `.same<br>&gt;&gt; `<br>&gt;&gt; &gt;&gt; &gt; also means identity.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Since this is new territory I suppose we get to decide what identity<br>&gt;&gt; &gt;&gt; &gt; means for floating point.  Should +0 and -0 have the same identity or<br>&gt;&gt; &gt;&gt; &gt; not?  I’ll leave the answer to folks more knowledgable about numerics<br>&gt;&gt; &gt;&gt; &gt; than I.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Boy, I take my wife out for a movie and come back to 50 new messages on<br>&gt;&gt; SE.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I need to read the entire thread more carefully, but off the top of my<br>&gt;&gt; &gt;&gt; head, I think that `-0 === +0` is False.  If we’re going to have an<br>&gt;&gt; &gt;&gt; `isSame` / `isIdentical` / whatever it&#39;s called, I would expect it to<br>&gt;&gt; imply<br>&gt;&gt; &gt;&gt; substitutability.  Although -0 == +0, they are not equivalent when<br>&gt;&gt; &gt;&gt; substituted:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; - 1/(-0) != 1/0<br>&gt;&gt; &gt;&gt; - Float(-0).sign != Float(+0).sign<br>&gt;&gt; &gt;&gt; - etc<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; This probably then implies that `&lt;=&gt;` is not `.same` either.  I’ll read<br>&gt;&gt; &gt;&gt; the rest of this and respond more completely tomorrow.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Eagerly await your evaluation of the discussion. In the meantime:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I think Dave&#39;s view that `===` defines identity in terms of &quot;essential&quot;<br>&gt;&gt; &gt; qualities implies that two identical values can be<br>&gt;&gt; &gt; different/non-substitutable in &quot;inessential&quot; qualities. For generic<br>&gt;&gt; &gt; purposes, the sign of zero could be one such inessential quality.<br>&gt;&gt;<br>&gt;&gt; Yes, and I think our view of how people work with numbers in swift (and<br>&gt;&gt; their protocol conformances) reflect this approach.<br>&gt;&gt;<br>&gt;&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/16321<br>&gt;&gt;<br>&gt;&gt; My sense is that we want to choose the default notions of identity and<br>&gt;&gt; ordering so as to support the way people think about these numeric<br>&gt;&gt; types, inexact though it may be.  Therefore, finding 0.0 in a sequence<br>&gt;&gt; of floats should succeed when the sequence contains -0.0, and a stable<br>&gt;&gt; sort on floating point keys should preserve the relative order of all<br>&gt;&gt; elements having +0.0 and -0.0 keys.<br>&gt;&gt;<br>&gt;&gt; People that want to work with inessential qualities such as the sign of<br>&gt;&gt; zero can always pass Float.totalOrdering (or whatever) to their<br>&gt;&gt; closure-accepting algorithms.<br>&gt;&gt;<br>&gt;&gt; [In order to support the user model, we still need to fix the semantics<br>&gt;&gt; of the default identity and ordering operations so that things like<br>&gt;&gt; sorting and searching work, which is why == and &lt; won&#39;t cut it for these<br>&gt;&gt; purposes]<br>&gt;&gt;<br>&gt;&gt; &gt; On the other hand, the stdlib stride algorithm is going to be borked if<br>&gt;&gt; -0<br>&gt;&gt; &gt; &lt; +0. Of course, as we already started to do there, we could specialize<br>&gt;&gt; for<br>&gt;&gt; &gt; floating point and then adjust accordingly. However, it seems to me that<br>&gt;&gt; &gt; every generic algorithm that performs comparisons and can take floating<br>&gt;&gt; &gt; point arguments would have to be specialized to account for floating<br>&gt;&gt; point<br>&gt;&gt; &gt; -0 != +0 (`index(of:)` being the previous example). This appears to<br>&gt;&gt; defeat<br>&gt;&gt; &gt; the aim of trying to accommodate FP at all in this revised design for<br>&gt;&gt; &gt; Comparables.<br>&gt;&gt;<br>&gt;&gt; Yes, that would be a disaster, generically speaking.<br>&gt;&gt;<br>&gt;&gt; &gt; The argument for `-0 === +0` is that -0 and +0 should be equivalent when<br>&gt;&gt; &gt; substituted for every comparison operation. For FP operations, you&#39;d<br>&gt;&gt; &gt; continue to test (as you have to test now) `a == b &amp;&amp; a.sign == b.sign`<br>&gt;&gt; if<br>&gt;&gt; &gt; you cared about the sign of zero. For non-FP arithmetic operations, hmm,<br>&gt;&gt; &gt; not sure how to square that circle.<br>&gt;&gt;<br>&gt;&gt; I followed all of this... except, what are you getting at with that last<br>&gt;&gt; sentence?<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>July 23, 2016 at 10:00:00pm</p></header><div class="content"><p>Given all this, I propose a simpler model that makes `a &lt;=&gt; b` follow the expected behaviour of &lt; and ==, with the tradeoff that `a &lt;=&gt; .nan` and `.nan &lt;=&gt; b` will abort with a precondition failure:<br></p><p>1) We keep the current Interface of Equatable  unchanged, with != defined in terms of ==.<br></p><p>2) Comparable would still refine Equatable, and include all the comparison operators, adding the new &lt;=&gt;:<br></p><p>    protocol Comparable : Equatable {<br>      static func &lt;=&gt;(lhs: Self, rhs: Self) -&gt; Ordering<br>      static func &lt;(lhs: Self, rhs: Self) -&gt; Bool<br>      static func &gt;(lhs: Self, rhs: Self) -&gt; Bool<br>      static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool<br>      static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool<br>    }<br></p><p>The comparison operators are kept in the interface so that partially ordered types such as Double can be supported in generic code. However, the documentation should recommend against defining `&lt;` manually.<br></p><p>3) Default implementations for &lt;Self : Comparable&gt; are provided for the following operators: ==, &lt;, &gt;, &lt;=, and &gt;=.<br></p><p>4) User-defined types will need to define just &lt;=&gt; to conform to Comparable. (Even == can be omitted!)<br></p><p>5) FloatingPoint types implement custom versions of ==, &lt;, &gt;, &lt;=, and &gt;= using the standard IEEE 754 definition (i.e. comparisons involving NaN return false). Zero is zero; `0.0 == -0.0 &amp;&amp; !(-0.0 &lt; 0.0)` holds.<br></p><p>6) FloatingPoint types implement &lt;=&gt; as:<br></p><p>    func &lt;=&gt; &lt;T : FloatingPoint&gt;(lhs: T, rhs: T) -&gt; Ordering {<br>      if lhs &lt; rhs { return .ascending }<br>      if rhs &lt; lhs { return .descending }<br>      precondition(lhs == rhs)<br>      return .same<br>    }<br></p><p>7) Algorithms using &lt;=&gt; directly should mention so in their documentation as a precondition that they require total order between elements. Many generic algorithms can be defined in terms of == or &lt;, and should.<br></p><p>If we took the oroginally planned route that distinguished between identities such as -0.0 vs. +0.0, or between the 2⁴⁹ - 2 ≈ 5.6 × 10¹⁴ possible NaN values that Double has, we&#39;d also need to consider other oddballs like the difference and ordering between the Strings &quot;ä&quot; and &quot;a\u{308}&quot;, which are considered equal but produce a different Unicode representation. I think it&#39;s best to hide those identities behind another interface than Equatable and Comparable, and let the protocols serve more mundane application logic.<br></p><p>— Pyry<br></p><p>&gt; Dave Abrahams wrote:<br>&gt; <br>&gt; <br>&gt;&gt; on Sat Jul 23 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Fri, Jul 22, 2016 at 11:34 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; The point of this design is that `===` means identity and that `.same `<br>&gt;&gt;&gt;&gt; also means identity.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since this is new territory I suppose we get to decide what identity<br>&gt;&gt;&gt;&gt; means for floating point.  Should +0 and -0 have the same identity or<br>&gt;&gt;&gt;&gt; not?  I’ll leave the answer to folks more knowledgable about numerics<br>&gt;&gt;&gt;&gt; than I.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Boy, I take my wife out for a movie and come back to 50 new messages on SE.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I need to read the entire thread more carefully, but off the top of my<br>&gt;&gt;&gt; head, I think that `-0 === +0` is False.  If we’re going to have an<br>&gt;&gt;&gt; `isSame` / `isIdentical` / whatever it&#39;s called, I would expect it to imply<br>&gt;&gt;&gt; substitutability.  Although -0 == +0, they are not equivalent when<br>&gt;&gt;&gt; substituted:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - 1/(-0) != 1/0<br>&gt;&gt;&gt; - Float(-0).sign != Float(+0).sign<br>&gt;&gt;&gt; - etc<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This probably then implies that `&lt;=&gt;` is not `.same` either.  I’ll read<br>&gt;&gt;&gt; the rest of this and respond more completely tomorrow.<br>&gt;&gt; <br>&gt;&gt; Eagerly await your evaluation of the discussion. In the meantime:<br>&gt;&gt; <br>&gt;&gt; I think Dave&#39;s view that `===` defines identity in terms of &quot;essential&quot;<br>&gt;&gt; qualities implies that two identical values can be<br>&gt;&gt; different/non-substitutable in &quot;inessential&quot; qualities. For generic<br>&gt;&gt; purposes, the sign of zero could be one such inessential quality.<br>&gt; <br>&gt; Yes, and I think our view of how people work with numbers in swift (and<br>&gt; their protocol conformances) reflect this approach.  <br>&gt; <br>&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/16321<br>&gt; <br>&gt; My sense is that we want to choose the default notions of identity and<br>&gt; ordering so as to support the way people think about these numeric<br>&gt; types, inexact though it may be.  Therefore, finding 0.0 in a sequence<br>&gt; of floats should succeed when the sequence contains -0.0, and a stable<br>&gt; sort on floating point keys should preserve the relative order of all<br>&gt; elements having +0.0 and -0.0 keys.  <br>&gt; <br>&gt; People that want to work with inessential qualities such as the sign of<br>&gt; zero can always pass Float.totalOrdering (or whatever) to their<br>&gt; closure-accepting algorithms.<br>&gt; <br>&gt; [In order to support the user model, we still need to fix the semantics<br>&gt; of the default identity and ordering operations so that things like<br>&gt; sorting and searching work, which is why == and &lt; won&#39;t cut it for these<br>&gt; purposes]<br>&gt; <br>&gt;&gt; On the other hand, the stdlib stride algorithm is going to be borked if -0<br>&gt;&gt; &lt; +0. Of course, as we already started to do there, we could specialize for<br>&gt;&gt; floating point and then adjust accordingly. However, it seems to me that<br>&gt;&gt; every generic algorithm that performs comparisons and can take floating<br>&gt;&gt; point arguments would have to be specialized to account for floating point<br>&gt;&gt; -0 != +0 (`index(of:)` being the previous example). This appears to defeat<br>&gt;&gt; the aim of trying to accommodate FP at all in this revised design for<br>&gt;&gt; Comparables.<br>&gt; <br>&gt; Yes, that would be a disaster, generically speaking.<br>&gt; <br>&gt;&gt; The argument for `-0 === +0` is that -0 and +0 should be equivalent when<br>&gt;&gt; substituted for every comparison operation. For FP operations, you&#39;d<br>&gt;&gt; continue to test (as you have to test now) `a == b &amp;&amp; a.sign == b.sign` if<br>&gt;&gt; you cared about the sign of zero. For non-FP arithmetic operations, hmm,<br>&gt;&gt; not sure how to square that circle.<br>&gt; <br>&gt; I followed all of this... except, what are you getting at with that last<br>&gt; sentence?<br>&gt; <br>&gt; --<br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 23, 2016 at 03:00:00pm</p></header><div class="content"><p>Throwing out some more radical ideas here. Suppose we had instead (taking<br>inspiration from IEEE notation):<br></p><p>[Pardon any errors; I&#39;m writing freehand in Gmail]<br></p><p>infix operator ==? { /* figure out precedence later */ }<br></p><p>protocol Equatable {<br>  static func ==? (lhs: Self, rhs: Self) -&gt; Bool?<br>  /* semantics:<br>     this function returns nil if lhs and rhs are unordered with respect to<br>each other<br>     otherwise, evaluate by means of a legal equivalence relation */<br>}<br></p><p>func == &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>  return (lhs ==? rhs) ?? false<br>}<br></p><p>protocol Comparable : Equatable {<br>  static func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>  /* semantics:<br>     this is a total ordering; thus:<br>     if `(a ==? b) == true`, then `(a &lt;=&gt; b) == .same`<br>     if `(a ==? b) == false`, then `(a &lt;=&gt; b) != .same`<br>     but, if `(a ==? b) == nil`, then `a &lt;=&gt; b` may yield any result<br>  */<br>}<br></p><p><br>On Sat, Jul 23, 2016 at 2:35 PM, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; wrote:<br></p><p>&gt; Given all this, I propose a simpler model that makes `a &lt;=&gt; b` follow the<br>&gt; expected behaviour of &lt; and ==, with the tradeoff that `a &lt;=&gt; .nan` and<br>&gt; `.nan &lt;=&gt; b` will abort with a precondition failure:<br>&gt;<br>&gt; 1) We keep the current Interface of Equatable  unchanged, with != defined<br>&gt; in terms of ==.<br>&gt;<br>&gt; 2) Comparable would still refine Equatable, and include all the comparison<br>&gt; operators, adding the new &lt;=&gt;:<br>&gt;<br>&gt;     protocol Comparable : Equatable {<br>&gt;       static func &lt;=&gt;(lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;       static func &lt;(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;       static func &gt;(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;       static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;       static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;     }<br>&gt;<br>&gt; The comparison operators are kept in the interface so that partially<br>&gt; ordered types such as Double can be supported in generic code. However, the<br>&gt; documentation should recommend against defining `&lt;` manually.<br>&gt;<br>&gt; 3) Default implementations for &lt;Self : Comparable&gt; are provided for the<br>&gt; following operators: ==, &lt;, &gt;, &lt;=, and &gt;=.<br>&gt;<br>&gt; 4) User-defined types will need to define just &lt;=&gt; to conform to<br>&gt; Comparable. (Even == can be omitted!)<br>&gt;<br>&gt; 5) FloatingPoint types implement custom versions of ==, &lt;, &gt;, &lt;=, and &gt;=<br>&gt; using the standard IEEE 754 definition (i.e. comparisons involving NaN<br>&gt; return false). Zero is zero; `0.0 == -0.0 &amp;&amp; !(-0.0 &lt; 0.0)` holds.<br>&gt;<br>&gt; 6) FloatingPoint types implement &lt;=&gt; as:<br>&gt;<br>&gt;     func &lt;=&gt; &lt;T : FloatingPoint&gt;(lhs: T, rhs: T) -&gt; Ordering {<br>&gt;       if lhs &lt; rhs { return .ascending }<br>&gt;       if rhs &lt; lhs { return .descending }<br>&gt;       precondition(lhs == rhs)<br>&gt;       return .same<br>&gt;     }<br>&gt;<br>&gt; 7) Algorithms using &lt;=&gt; directly should mention so in their documentation<br>&gt; as a precondition that they require total order between elements. Many<br>&gt; generic algorithms can be defined in terms of == or &lt;, and should.<br>&gt;<br>&gt; If we took the oroginally planned route that distinguished between<br>&gt; identities such as -0.0 vs. +0.0, or between the 2⁴⁹ - 2 ≈ 5.6 × 10¹⁴<br>&gt; possible NaN values that Double has, we&#39;d also need to consider other<br>&gt; oddballs like the difference and ordering between the Strings &quot;ä&quot; and<br>&gt; &quot;a\u{308}&quot;, which are considered equal but produce a different Unicode<br>&gt; representation. I think it&#39;s best to hide those identities behind another<br>&gt; interface than Equatable and Comparable, and let the protocols serve more<br>&gt; mundane application logic.<br>&gt;<br>&gt; — Pyry<br>&gt;<br>&gt; &gt; Dave Abrahams wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; on Sat Jul 23 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Fri, Jul 22, 2016 at 11:34 PM, Stephen Canon &lt;scanon at apple.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; The point of this design is that `===` means identity and that `.same<br>&gt; `<br>&gt; &gt;&gt;&gt;&gt; also means identity.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Since this is new territory I suppose we get to decide what identity<br>&gt; &gt;&gt;&gt;&gt; means for floating point.  Should +0 and -0 have the same identity or<br>&gt; &gt;&gt;&gt;&gt; not?  I’ll leave the answer to folks more knowledgable about numerics<br>&gt; &gt;&gt;&gt;&gt; than I.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Boy, I take my wife out for a movie and come back to 50 new messages<br>&gt; on SE.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I need to read the entire thread more carefully, but off the top of my<br>&gt; &gt;&gt;&gt; head, I think that `-0 === +0` is False.  If we’re going to have an<br>&gt; &gt;&gt;&gt; `isSame` / `isIdentical` / whatever it&#39;s called, I would expect it to<br>&gt; imply<br>&gt; &gt;&gt;&gt; substitutability.  Although -0 == +0, they are not equivalent when<br>&gt; &gt;&gt;&gt; substituted:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; - 1/(-0) != 1/0<br>&gt; &gt;&gt;&gt; - Float(-0).sign != Float(+0).sign<br>&gt; &gt;&gt;&gt; - etc<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; This probably then implies that `&lt;=&gt;` is not `.same` either.  I’ll read<br>&gt; &gt;&gt;&gt; the rest of this and respond more completely tomorrow.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Eagerly await your evaluation of the discussion. In the meantime:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I think Dave&#39;s view that `===` defines identity in terms of &quot;essential&quot;<br>&gt; &gt;&gt; qualities implies that two identical values can be<br>&gt; &gt;&gt; different/non-substitutable in &quot;inessential&quot; qualities. For generic<br>&gt; &gt;&gt; purposes, the sign of zero could be one such inessential quality.<br>&gt; &gt;<br>&gt; &gt; Yes, and I think our view of how people work with numbers in swift (and<br>&gt; &gt; their protocol conformances) reflect this approach.<br>&gt; &gt;<br>&gt; &gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/16321<br>&gt; &gt;<br>&gt; &gt; My sense is that we want to choose the default notions of identity and<br>&gt; &gt; ordering so as to support the way people think about these numeric<br>&gt; &gt; types, inexact though it may be.  Therefore, finding 0.0 in a sequence<br>&gt; &gt; of floats should succeed when the sequence contains -0.0, and a stable<br>&gt; &gt; sort on floating point keys should preserve the relative order of all<br>&gt; &gt; elements having +0.0 and -0.0 keys.<br>&gt; &gt;<br>&gt; &gt; People that want to work with inessential qualities such as the sign of<br>&gt; &gt; zero can always pass Float.totalOrdering (or whatever) to their<br>&gt; &gt; closure-accepting algorithms.<br>&gt; &gt;<br>&gt; &gt; [In order to support the user model, we still need to fix the semantics<br>&gt; &gt; of the default identity and ordering operations so that things like<br>&gt; &gt; sorting and searching work, which is why == and &lt; won&#39;t cut it for these<br>&gt; &gt; purposes]<br>&gt; &gt;<br>&gt; &gt;&gt; On the other hand, the stdlib stride algorithm is going to be borked if<br>&gt; -0<br>&gt; &gt;&gt; &lt; +0. Of course, as we already started to do there, we could specialize<br>&gt; for<br>&gt; &gt;&gt; floating point and then adjust accordingly. However, it seems to me that<br>&gt; &gt;&gt; every generic algorithm that performs comparisons and can take floating<br>&gt; &gt;&gt; point arguments would have to be specialized to account for floating<br>&gt; point<br>&gt; &gt;&gt; -0 != +0 (`index(of:)` being the previous example). This appears to<br>&gt; defeat<br>&gt; &gt;&gt; the aim of trying to accommodate FP at all in this revised design for<br>&gt; &gt;&gt; Comparables.<br>&gt; &gt;<br>&gt; &gt; Yes, that would be a disaster, generically speaking.<br>&gt; &gt;<br>&gt; &gt;&gt; The argument for `-0 === +0` is that -0 and +0 should be equivalent when<br>&gt; &gt;&gt; substituted for every comparison operation. For FP operations, you&#39;d<br>&gt; &gt;&gt; continue to test (as you have to test now) `a == b &amp;&amp; a.sign == b.sign`<br>&gt; if<br>&gt; &gt;&gt; you cared about the sign of zero. For non-FP arithmetic operations, hmm,<br>&gt; &gt;&gt; not sure how to square that circle.<br>&gt; &gt;<br>&gt; &gt; I followed all of this... except, what are you getting at with that last<br>&gt; &gt; sentence?<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Dave<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160723/56cc1dee/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 23, 2016 at 03:00:00pm</p></header><div class="content"><p>Sorry to overwhelm with more emails. I&#39;d like to show some work and further<br>analysis for your consideration that refines the sketch I just wrote:<br></p><p>Two FP values a and b can be, with respect to each other:<br></p><p>* ordered or unordered (per IEEE, NaN compares unordered to everything,<br>including itself)<br>* identical or not identical (for these purposes, we adopt Steve&#39;s proposed<br>test for identity: substitutable for all operations; thus +0 is not<br>identical to -0, but different binary representations of the same value are<br>identical)<br>* equal or not equal (i.e. the behavior of the == operator today)<br></p><p>So, if a and b are, with respect to each other:<br></p><p>* ordered, identical, equal -- this is what happens ordinarily with two<br>equal, non-NaN values<br>* ordered, identical, not equal -- this can never happen<br>* ordered, not identical, equal -- only +0 and -0<br>* ordered, not identical, not equal -- this is what happens ordinarily with<br>two unequal, non-NaN values<br></p><p>* unordered, identical, equal -- this can never happen, but if NaNs are to<br>be well-behaved (for a true equivalence relation), then we will need an<br>equivalence relation in which NaN == NaN<br>* unordered, identical, not equal -- this is what always happens, but if<br>NaNs are to be well-behaved, then such behavior will need to change<br>* unordered, not identical, equal -- this can never happen<br>* unordered, not identical, not equal -- this is what ordinarily happens<br>with one NaN and one non-NaN value<br></p><p>Equatable can have === and my proposed ==? as part of its protocol; a<br>generic ==, as originally proposed, would be defined outside the protocol.<br>A default implementation of ==? will forward to ===, and the generic ==<br>will be defined as `{ return (lhs ==? rhs) ?? (lhs === rhs) }`.<br>For floating point, ==? will be specialized and cease to forward to === so<br>that +0 and -0 compare true and NaN and anything compare nil, and floating<br>point == will be defined notionally as `{ return (lhs ==? rhs) ?? false }`.<br></p><p><br>On Sat, Jul 23, 2016 at 3:09 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; Throwing out some more radical ideas here. Suppose we had instead (taking<br>&gt; inspiration from IEEE notation):<br>&gt;<br>&gt; [Pardon any errors; I&#39;m writing freehand in Gmail]<br>&gt;<br>&gt; infix operator ==? { /* figure out precedence later */ }<br>&gt;<br>&gt; protocol Equatable {<br>&gt;   static func ==? (lhs: Self, rhs: Self) -&gt; Bool?<br>&gt;   /* semantics:<br>&gt;      this function returns nil if lhs and rhs are unordered with respect<br>&gt; to each other<br>&gt;      otherwise, evaluate by means of a legal equivalence relation */<br>&gt; }<br>&gt;<br>&gt; func == &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;   return (lhs ==? rhs) ?? false<br>&gt; }<br>&gt;<br>&gt; protocol Comparable : Equatable {<br>&gt;   static func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;   /* semantics:<br>&gt;      this is a total ordering; thus:<br>&gt;      if `(a ==? b) == true`, then `(a &lt;=&gt; b) == .same`<br>&gt;      if `(a ==? b) == false`, then `(a &lt;=&gt; b) != .same`<br>&gt;      but, if `(a ==? b) == nil`, then `a &lt;=&gt; b` may yield any result<br>&gt;   */<br>&gt; }<br>&gt;<br>&gt;<br>&gt; On Sat, Jul 23, 2016 at 2:35 PM, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; wrote:<br>&gt;<br>&gt;&gt; Given all this, I propose a simpler model that makes `a &lt;=&gt; b` follow the<br>&gt;&gt; expected behaviour of &lt; and ==, with the tradeoff that `a &lt;=&gt; .nan` and<br>&gt;&gt; `.nan &lt;=&gt; b` will abort with a precondition failure:<br>&gt;&gt;<br>&gt;&gt; 1) We keep the current Interface of Equatable  unchanged, with != defined<br>&gt;&gt; in terms of ==.<br>&gt;&gt;<br>&gt;&gt; 2) Comparable would still refine Equatable, and include all the<br>&gt;&gt; comparison operators, adding the new &lt;=&gt;:<br>&gt;&gt;<br>&gt;&gt;     protocol Comparable : Equatable {<br>&gt;&gt;       static func &lt;=&gt;(lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt;       static func &lt;(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;       static func &gt;(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;       static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;       static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; The comparison operators are kept in the interface so that partially<br>&gt;&gt; ordered types such as Double can be supported in generic code. However, the<br>&gt;&gt; documentation should recommend against defining `&lt;` manually.<br>&gt;&gt;<br>&gt;&gt; 3) Default implementations for &lt;Self : Comparable&gt; are provided for the<br>&gt;&gt; following operators: ==, &lt;, &gt;, &lt;=, and &gt;=.<br>&gt;&gt;<br>&gt;&gt; 4) User-defined types will need to define just &lt;=&gt; to conform to<br>&gt;&gt; Comparable. (Even == can be omitted!)<br>&gt;&gt;<br>&gt;&gt; 5) FloatingPoint types implement custom versions of ==, &lt;, &gt;, &lt;=, and &gt;=<br>&gt;&gt; using the standard IEEE 754 definition (i.e. comparisons involving NaN<br>&gt;&gt; return false). Zero is zero; `0.0 == -0.0 &amp;&amp; !(-0.0 &lt; 0.0)` holds.<br>&gt;&gt;<br>&gt;&gt; 6) FloatingPoint types implement &lt;=&gt; as:<br>&gt;&gt;<br>&gt;&gt;     func &lt;=&gt; &lt;T : FloatingPoint&gt;(lhs: T, rhs: T) -&gt; Ordering {<br>&gt;&gt;       if lhs &lt; rhs { return .ascending }<br>&gt;&gt;       if rhs &lt; lhs { return .descending }<br>&gt;&gt;       precondition(lhs == rhs)<br>&gt;&gt;       return .same<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; 7) Algorithms using &lt;=&gt; directly should mention so in their documentation<br>&gt;&gt; as a precondition that they require total order between elements. Many<br>&gt;&gt; generic algorithms can be defined in terms of == or &lt;, and should.<br>&gt;&gt;<br>&gt;&gt; If we took the oroginally planned route that distinguished between<br>&gt;&gt; identities such as -0.0 vs. +0.0, or between the 2⁴⁹ - 2 ≈ 5.6 × 10¹⁴<br>&gt;&gt; possible NaN values that Double has, we&#39;d also need to consider other<br>&gt;&gt; oddballs like the difference and ordering between the Strings &quot;ä&quot; and<br>&gt;&gt; &quot;a\u{308}&quot;, which are considered equal but produce a different Unicode<br>&gt;&gt; representation. I think it&#39;s best to hide those identities behind another<br>&gt;&gt; interface than Equatable and Comparable, and let the protocols serve more<br>&gt;&gt; mundane application logic.<br>&gt;&gt;<br>&gt;&gt; — Pyry<br>&gt;&gt;<br>&gt;&gt; &gt; Dave Abrahams wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; on Sat Jul 23 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; On Fri, Jul 22, 2016 at 11:34 PM, Stephen Canon &lt;scanon at apple.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; The point of this design is that `===` means identity and that<br>&gt;&gt; `.same `<br>&gt;&gt; &gt;&gt;&gt;&gt; also means identity.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Since this is new territory I suppose we get to decide what identity<br>&gt;&gt; &gt;&gt;&gt;&gt; means for floating point.  Should +0 and -0 have the same identity or<br>&gt;&gt; &gt;&gt;&gt;&gt; not?  I’ll leave the answer to folks more knowledgable about numerics<br>&gt;&gt; &gt;&gt;&gt;&gt; than I.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Boy, I take my wife out for a movie and come back to 50 new messages<br>&gt;&gt; on SE.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; I need to read the entire thread more carefully, but off the top of my<br>&gt;&gt; &gt;&gt;&gt; head, I think that `-0 === +0` is False.  If we’re going to have an<br>&gt;&gt; &gt;&gt;&gt; `isSame` / `isIdentical` / whatever it&#39;s called, I would expect it to<br>&gt;&gt; imply<br>&gt;&gt; &gt;&gt;&gt; substitutability.  Although -0 == +0, they are not equivalent when<br>&gt;&gt; &gt;&gt;&gt; substituted:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; - 1/(-0) != 1/0<br>&gt;&gt; &gt;&gt;&gt; - Float(-0).sign != Float(+0).sign<br>&gt;&gt; &gt;&gt;&gt; - etc<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; This probably then implies that `&lt;=&gt;` is not `.same` either.  I’ll<br>&gt;&gt; read<br>&gt;&gt; &gt;&gt;&gt; the rest of this and respond more completely tomorrow.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Eagerly await your evaluation of the discussion. In the meantime:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I think Dave&#39;s view that `===` defines identity in terms of &quot;essential&quot;<br>&gt;&gt; &gt;&gt; qualities implies that two identical values can be<br>&gt;&gt; &gt;&gt; different/non-substitutable in &quot;inessential&quot; qualities. For generic<br>&gt;&gt; &gt;&gt; purposes, the sign of zero could be one such inessential quality.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Yes, and I think our view of how people work with numbers in swift (and<br>&gt;&gt; &gt; their protocol conformances) reflect this approach.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/16321<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; My sense is that we want to choose the default notions of identity and<br>&gt;&gt; &gt; ordering so as to support the way people think about these numeric<br>&gt;&gt; &gt; types, inexact though it may be.  Therefore, finding 0.0 in a sequence<br>&gt;&gt; &gt; of floats should succeed when the sequence contains -0.0, and a stable<br>&gt;&gt; &gt; sort on floating point keys should preserve the relative order of all<br>&gt;&gt; &gt; elements having +0.0 and -0.0 keys.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; People that want to work with inessential qualities such as the sign of<br>&gt;&gt; &gt; zero can always pass Float.totalOrdering (or whatever) to their<br>&gt;&gt; &gt; closure-accepting algorithms.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; [In order to support the user model, we still need to fix the semantics<br>&gt;&gt; &gt; of the default identity and ordering operations so that things like<br>&gt;&gt; &gt; sorting and searching work, which is why == and &lt; won&#39;t cut it for these<br>&gt;&gt; &gt; purposes]<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On the other hand, the stdlib stride algorithm is going to be borked<br>&gt;&gt; if -0<br>&gt;&gt; &gt;&gt; &lt; +0. Of course, as we already started to do there, we could<br>&gt;&gt; specialize for<br>&gt;&gt; &gt;&gt; floating point and then adjust accordingly. However, it seems to me<br>&gt;&gt; that<br>&gt;&gt; &gt;&gt; every generic algorithm that performs comparisons and can take floating<br>&gt;&gt; &gt;&gt; point arguments would have to be specialized to account for floating<br>&gt;&gt; point<br>&gt;&gt; &gt;&gt; -0 != +0 (`index(of:)` being the previous example). This appears to<br>&gt;&gt; defeat<br>&gt;&gt; &gt;&gt; the aim of trying to accommodate FP at all in this revised design for<br>&gt;&gt; &gt;&gt; Comparables.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Yes, that would be a disaster, generically speaking.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; The argument for `-0 === +0` is that -0 and +0 should be equivalent<br>&gt;&gt; when<br>&gt;&gt; &gt;&gt; substituted for every comparison operation. For FP operations, you&#39;d<br>&gt;&gt; &gt;&gt; continue to test (as you have to test now) `a == b &amp;&amp; a.sign ==<br>&gt;&gt; b.sign` if<br>&gt;&gt; &gt;&gt; you cared about the sign of zero. For non-FP arithmetic operations,<br>&gt;&gt; hmm,<br>&gt;&gt; &gt;&gt; not sure how to square that circle.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I followed all of this... except, what are you getting at with that last<br>&gt;&gt; &gt; sentence?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Dave<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160723/a17b1790/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>July 23, 2016 at 05:00:00pm</p></header><div class="content"><p>Another option would be to leave the IEEE 754 NaN hijinks in Float and<br>Double (as numerics people expect), and create a new type (with a nice<br>approachable name) that “acts like” Double but does not model NaN. Then any<br>operation which would ordinarily produce a NaN, instead traps for the new<br>type. That way its comparison operators only have to worry about non-NaN<br>values, which makes everything much cleaner.<br></p><p>Sorting Doubles would retain its present functionality, warts and all,<br>which numerics people should be expected to handle. Whereas the new type<br>(“Number” sounds good, especially if we can make it subsume NSNumber) would<br>never have a NaN in the first place.<br></p><p>Nevin<br></p><p><br></p><p>On Sat, Jul 23, 2016 at 4:57 PM, Xiaodi Wu via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Sorry to overwhelm with more emails. I&#39;d like to show some work and<br>&gt; further analysis for your consideration that refines the sketch I just<br>&gt; wrote:<br>&gt;<br>&gt; Two FP values a and b can be, with respect to each other:<br>&gt;<br>&gt; * ordered or unordered (per IEEE, NaN compares unordered to everything,<br>&gt; including itself)<br>&gt; * identical or not identical (for these purposes, we adopt Steve&#39;s<br>&gt; proposed test for identity: substitutable for all operations; thus +0 is<br>&gt; not identical to -0, but different binary representations of the same value<br>&gt; are identical)<br>&gt; * equal or not equal (i.e. the behavior of the == operator today)<br>&gt;<br>&gt; So, if a and b are, with respect to each other:<br>&gt;<br>&gt; * ordered, identical, equal -- this is what happens ordinarily with two<br>&gt; equal, non-NaN values<br>&gt; * ordered, identical, not equal -- this can never happen<br>&gt; * ordered, not identical, equal -- only +0 and -0<br>&gt; * ordered, not identical, not equal -- this is what happens ordinarily<br>&gt; with two unequal, non-NaN values<br>&gt;<br>&gt; * unordered, identical, equal -- this can never happen, but if NaNs are to<br>&gt; be well-behaved (for a true equivalence relation), then we will need an<br>&gt; equivalence relation in which NaN == NaN<br>&gt; * unordered, identical, not equal -- this is what always happens, but if<br>&gt; NaNs are to be well-behaved, then such behavior will need to change<br>&gt; * unordered, not identical, equal -- this can never happen<br>&gt; * unordered, not identical, not equal -- this is what ordinarily happens<br>&gt; with one NaN and one non-NaN value<br>&gt;<br>&gt; Equatable can have === and my proposed ==? as part of its protocol; a<br>&gt; generic ==, as originally proposed, would be defined outside the protocol.<br>&gt; A default implementation of ==? will forward to ===, and the generic ==<br>&gt; will be defined as `{ return (lhs ==? rhs) ?? (lhs === rhs) }`.<br>&gt; For floating point, ==? will be specialized and cease to forward to === so<br>&gt; that +0 and -0 compare true and NaN and anything compare nil, and floating<br>&gt; point == will be defined notionally as `{ return (lhs ==? rhs) ?? false }`.<br>&gt;<br>&gt;<br>&gt; On Sat, Jul 23, 2016 at 3:09 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; Throwing out some more radical ideas here. Suppose we had instead (taking<br>&gt;&gt; inspiration from IEEE notation):<br>&gt;&gt;<br>&gt;&gt; [Pardon any errors; I&#39;m writing freehand in Gmail]<br>&gt;&gt;<br>&gt;&gt; infix operator ==? { /* figure out precedence later */ }<br>&gt;&gt;<br>&gt;&gt; protocol Equatable {<br>&gt;&gt;   static func ==? (lhs: Self, rhs: Self) -&gt; Bool?<br>&gt;&gt;   /* semantics:<br>&gt;&gt;      this function returns nil if lhs and rhs are unordered with respect<br>&gt;&gt; to each other<br>&gt;&gt;      otherwise, evaluate by means of a legal equivalence relation */<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; func == &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;   return (lhs ==? rhs) ?? false<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; protocol Comparable : Equatable {<br>&gt;&gt;   static func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt;   /* semantics:<br>&gt;&gt;      this is a total ordering; thus:<br>&gt;&gt;      if `(a ==? b) == true`, then `(a &lt;=&gt; b) == .same`<br>&gt;&gt;      if `(a ==? b) == false`, then `(a &lt;=&gt; b) != .same`<br>&gt;&gt;      but, if `(a ==? b) == nil`, then `a &lt;=&gt; b` may yield any result<br>&gt;&gt;   */<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sat, Jul 23, 2016 at 2:35 PM, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Given all this, I propose a simpler model that makes `a &lt;=&gt; b` follow<br>&gt;&gt;&gt; the expected behaviour of &lt; and ==, with the tradeoff that `a &lt;=&gt; .nan` and<br>&gt;&gt;&gt; `.nan &lt;=&gt; b` will abort with a precondition failure:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1) We keep the current Interface of Equatable  unchanged, with !=<br>&gt;&gt;&gt; defined in terms of ==.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2) Comparable would still refine Equatable, and include all the<br>&gt;&gt;&gt; comparison operators, adding the new &lt;=&gt;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     protocol Comparable : Equatable {<br>&gt;&gt;&gt;       static func &lt;=&gt;(lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt;&gt;       static func &lt;(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;       static func &gt;(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;       static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;       static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The comparison operators are kept in the interface so that partially<br>&gt;&gt;&gt; ordered types such as Double can be supported in generic code. However, the<br>&gt;&gt;&gt; documentation should recommend against defining `&lt;` manually.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 3) Default implementations for &lt;Self : Comparable&gt; are provided for the<br>&gt;&gt;&gt; following operators: ==, &lt;, &gt;, &lt;=, and &gt;=.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 4) User-defined types will need to define just &lt;=&gt; to conform to<br>&gt;&gt;&gt; Comparable. (Even == can be omitted!)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 5) FloatingPoint types implement custom versions of ==, &lt;, &gt;, &lt;=, and &gt;=<br>&gt;&gt;&gt; using the standard IEEE 754 definition (i.e. comparisons involving NaN<br>&gt;&gt;&gt; return false). Zero is zero; `0.0 == -0.0 &amp;&amp; !(-0.0 &lt; 0.0)` holds.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 6) FloatingPoint types implement &lt;=&gt; as:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func &lt;=&gt; &lt;T : FloatingPoint&gt;(lhs: T, rhs: T) -&gt; Ordering {<br>&gt;&gt;&gt;       if lhs &lt; rhs { return .ascending }<br>&gt;&gt;&gt;       if rhs &lt; lhs { return .descending }<br>&gt;&gt;&gt;       precondition(lhs == rhs)<br>&gt;&gt;&gt;       return .same<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 7) Algorithms using &lt;=&gt; directly should mention so in their<br>&gt;&gt;&gt; documentation as a precondition that they require total order between<br>&gt;&gt;&gt; elements. Many generic algorithms can be defined in terms of == or &lt;, and<br>&gt;&gt;&gt; should.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If we took the oroginally planned route that distinguished between<br>&gt;&gt;&gt; identities such as -0.0 vs. +0.0, or between the 2⁴⁹ - 2 ≈ 5.6 × 10¹⁴<br>&gt;&gt;&gt; possible NaN values that Double has, we&#39;d also need to consider other<br>&gt;&gt;&gt; oddballs like the difference and ordering between the Strings &quot;ä&quot; and<br>&gt;&gt;&gt; &quot;a\u{308}&quot;, which are considered equal but produce a different Unicode<br>&gt;&gt;&gt; representation. I think it&#39;s best to hide those identities behind another<br>&gt;&gt;&gt; interface than Equatable and Comparable, and let the protocols serve more<br>&gt;&gt;&gt; mundane application logic.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; — Pyry<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; Dave Abrahams wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; on Sat Jul 23 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; On Fri, Jul 22, 2016 at 11:34 PM, Stephen Canon &lt;scanon at apple.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; The point of this design is that `===` means identity and that<br>&gt;&gt;&gt; `.same `<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; also means identity.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; Since this is new territory I suppose we get to decide what identity<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; means for floating point.  Should +0 and -0 have the same identity<br>&gt;&gt;&gt; or<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; not?  I’ll leave the answer to folks more knowledgable about<br>&gt;&gt;&gt; numerics<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; than I.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Boy, I take my wife out for a movie and come back to 50 new messages<br>&gt;&gt;&gt; on SE.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; I need to read the entire thread more carefully, but off the top of<br>&gt;&gt;&gt; my<br>&gt;&gt;&gt; &gt;&gt;&gt; head, I think that `-0 === +0` is False.  If we’re going to have an<br>&gt;&gt;&gt; &gt;&gt;&gt; `isSame` / `isIdentical` / whatever it&#39;s called, I would expect it<br>&gt;&gt;&gt; to imply<br>&gt;&gt;&gt; &gt;&gt;&gt; substitutability.  Although -0 == +0, they are not equivalent when<br>&gt;&gt;&gt; &gt;&gt;&gt; substituted:<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; - 1/(-0) != 1/0<br>&gt;&gt;&gt; &gt;&gt;&gt; - Float(-0).sign != Float(+0).sign<br>&gt;&gt;&gt; &gt;&gt;&gt; - etc<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; This probably then implies that `&lt;=&gt;` is not `.same` either.  I’ll<br>&gt;&gt;&gt; read<br>&gt;&gt;&gt; &gt;&gt;&gt; the rest of this and respond more completely tomorrow.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Eagerly await your evaluation of the discussion. In the meantime:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; I think Dave&#39;s view that `===` defines identity in terms of<br>&gt;&gt;&gt; &quot;essential&quot;<br>&gt;&gt;&gt; &gt;&gt; qualities implies that two identical values can be<br>&gt;&gt;&gt; &gt;&gt; different/non-substitutable in &quot;inessential&quot; qualities. For generic<br>&gt;&gt;&gt; &gt;&gt; purposes, the sign of zero could be one such inessential quality.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Yes, and I think our view of how people work with numbers in swift (and<br>&gt;&gt;&gt; &gt; their protocol conformances) reflect this approach.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/16321<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; My sense is that we want to choose the default notions of identity and<br>&gt;&gt;&gt; &gt; ordering so as to support the way people think about these numeric<br>&gt;&gt;&gt; &gt; types, inexact though it may be.  Therefore, finding 0.0 in a sequence<br>&gt;&gt;&gt; &gt; of floats should succeed when the sequence contains -0.0, and a stable<br>&gt;&gt;&gt; &gt; sort on floating point keys should preserve the relative order of all<br>&gt;&gt;&gt; &gt; elements having +0.0 and -0.0 keys.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; People that want to work with inessential qualities such as the sign of<br>&gt;&gt;&gt; &gt; zero can always pass Float.totalOrdering (or whatever) to their<br>&gt;&gt;&gt; &gt; closure-accepting algorithms.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; [In order to support the user model, we still need to fix the semantics<br>&gt;&gt;&gt; &gt; of the default identity and ordering operations so that things like<br>&gt;&gt;&gt; &gt; sorting and searching work, which is why == and &lt; won&#39;t cut it for<br>&gt;&gt;&gt; these<br>&gt;&gt;&gt; &gt; purposes]<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; On the other hand, the stdlib stride algorithm is going to be borked<br>&gt;&gt;&gt; if -0<br>&gt;&gt;&gt; &gt;&gt; &lt; +0. Of course, as we already started to do there, we could<br>&gt;&gt;&gt; specialize for<br>&gt;&gt;&gt; &gt;&gt; floating point and then adjust accordingly. However, it seems to me<br>&gt;&gt;&gt; that<br>&gt;&gt;&gt; &gt;&gt; every generic algorithm that performs comparisons and can take<br>&gt;&gt;&gt; floating<br>&gt;&gt;&gt; &gt;&gt; point arguments would have to be specialized to account for floating<br>&gt;&gt;&gt; point<br>&gt;&gt;&gt; &gt;&gt; -0 != +0 (`index(of:)` being the previous example). This appears to<br>&gt;&gt;&gt; defeat<br>&gt;&gt;&gt; &gt;&gt; the aim of trying to accommodate FP at all in this revised design for<br>&gt;&gt;&gt; &gt;&gt; Comparables.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Yes, that would be a disaster, generically speaking.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; The argument for `-0 === +0` is that -0 and +0 should be equivalent<br>&gt;&gt;&gt; when<br>&gt;&gt;&gt; &gt;&gt; substituted for every comparison operation. For FP operations, you&#39;d<br>&gt;&gt;&gt; &gt;&gt; continue to test (as you have to test now) `a == b &amp;&amp; a.sign ==<br>&gt;&gt;&gt; b.sign` if<br>&gt;&gt;&gt; &gt;&gt; you cared about the sign of zero. For non-FP arithmetic operations,<br>&gt;&gt;&gt; hmm,<br>&gt;&gt;&gt; &gt;&gt; not sure how to square that circle.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I followed all of this... except, what are you getting at with that<br>&gt;&gt;&gt; last<br>&gt;&gt;&gt; &gt; sentence?<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt; &gt; Dave<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160723/913da8dd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 23, 2016 at 04:00:00pm</p></header><div class="content"><p>IMO what&#39;s causing the headaches now isn&#39;t NaN; it&#39;s actually +0 and -0.<br></p><p><br>On Sat, Jul 23, 2016 at 4:19 PM, Nevin Brackett-Rozinsky &lt;<br>nevin.brackettrozinsky at gmail.com&gt; wrote:<br></p><p>&gt; Another option would be to leave the IEEE 754 NaN hijinks in Float and<br>&gt; Double (as numerics people expect), and create a new type (with a nice<br>&gt; approachable name) that “acts like” Double but does not model NaN. Then any<br>&gt; operation which would ordinarily produce a NaN, instead traps for the new<br>&gt; type. That way its comparison operators only have to worry about non-NaN<br>&gt; values, which makes everything much cleaner.<br>&gt;<br>&gt; Sorting Doubles would retain its present functionality, warts and all,<br>&gt; which numerics people should be expected to handle. Whereas the new type<br>&gt; (“Number” sounds good, especially if we can make it subsume NSNumber) would<br>&gt; never have a NaN in the first place.<br>&gt;<br>&gt; Nevin<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Sat, Jul 23, 2016 at 4:57 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Sorry to overwhelm with more emails. I&#39;d like to show some work and<br>&gt;&gt; further analysis for your consideration that refines the sketch I just<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Two FP values a and b can be, with respect to each other:<br>&gt;&gt;<br>&gt;&gt; * ordered or unordered (per IEEE, NaN compares unordered to everything,<br>&gt;&gt; including itself)<br>&gt;&gt; * identical or not identical (for these purposes, we adopt Steve&#39;s<br>&gt;&gt; proposed test for identity: substitutable for all operations; thus +0 is<br>&gt;&gt; not identical to -0, but different binary representations of the same value<br>&gt;&gt; are identical)<br>&gt;&gt; * equal or not equal (i.e. the behavior of the == operator today)<br>&gt;&gt;<br>&gt;&gt; So, if a and b are, with respect to each other:<br>&gt;&gt;<br>&gt;&gt; * ordered, identical, equal -- this is what happens ordinarily with two<br>&gt;&gt; equal, non-NaN values<br>&gt;&gt; * ordered, identical, not equal -- this can never happen<br>&gt;&gt; * ordered, not identical, equal -- only +0 and -0<br>&gt;&gt; * ordered, not identical, not equal -- this is what happens ordinarily<br>&gt;&gt; with two unequal, non-NaN values<br>&gt;&gt;<br>&gt;&gt; * unordered, identical, equal -- this can never happen, but if NaNs are<br>&gt;&gt; to be well-behaved (for a true equivalence relation), then we will need an<br>&gt;&gt; equivalence relation in which NaN == NaN<br>&gt;&gt; * unordered, identical, not equal -- this is what always happens, but if<br>&gt;&gt; NaNs are to be well-behaved, then such behavior will need to change<br>&gt;&gt; * unordered, not identical, equal -- this can never happen<br>&gt;&gt; * unordered, not identical, not equal -- this is what ordinarily happens<br>&gt;&gt; with one NaN and one non-NaN value<br>&gt;&gt;<br>&gt;&gt; Equatable can have === and my proposed ==? as part of its protocol; a<br>&gt;&gt; generic ==, as originally proposed, would be defined outside the protocol.<br>&gt;&gt; A default implementation of ==? will forward to ===, and the generic ==<br>&gt;&gt; will be defined as `{ return (lhs ==? rhs) ?? (lhs === rhs) }`.<br>&gt;&gt; For floating point, ==? will be specialized and cease to forward to ===<br>&gt;&gt; so that +0 and -0 compare true and NaN and anything compare nil, and<br>&gt;&gt; floating point == will be defined notionally as `{ return (lhs ==? rhs) ??<br>&gt;&gt; false }`.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sat, Jul 23, 2016 at 3:09 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Throwing out some more radical ideas here. Suppose we had instead<br>&gt;&gt;&gt; (taking inspiration from IEEE notation):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; [Pardon any errors; I&#39;m writing freehand in Gmail]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; infix operator ==? { /* figure out precedence later */ }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;   static func ==? (lhs: Self, rhs: Self) -&gt; Bool?<br>&gt;&gt;&gt;   /* semantics:<br>&gt;&gt;&gt;      this function returns nil if lhs and rhs are unordered with respect<br>&gt;&gt;&gt; to each other<br>&gt;&gt;&gt;      otherwise, evaluate by means of a legal equivalence relation */<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func == &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;&gt;   return (lhs ==? rhs) ?? false<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Comparable : Equatable {<br>&gt;&gt;&gt;   static func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt;&gt;   /* semantics:<br>&gt;&gt;&gt;      this is a total ordering; thus:<br>&gt;&gt;&gt;      if `(a ==? b) == true`, then `(a &lt;=&gt; b) == .same`<br>&gt;&gt;&gt;      if `(a ==? b) == false`, then `(a &lt;=&gt; b) != .same`<br>&gt;&gt;&gt;      but, if `(a ==? b) == nil`, then `a &lt;=&gt; b` may yield any result<br>&gt;&gt;&gt;   */<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sat, Jul 23, 2016 at 2:35 PM, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Given all this, I propose a simpler model that makes `a &lt;=&gt; b` follow<br>&gt;&gt;&gt;&gt; the expected behaviour of &lt; and ==, with the tradeoff that `a &lt;=&gt; .nan` and<br>&gt;&gt;&gt;&gt; `.nan &lt;=&gt; b` will abort with a precondition failure:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 1) We keep the current Interface of Equatable  unchanged, with !=<br>&gt;&gt;&gt;&gt; defined in terms of ==.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 2) Comparable would still refine Equatable, and include all the<br>&gt;&gt;&gt;&gt; comparison operators, adding the new &lt;=&gt;:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     protocol Comparable : Equatable {<br>&gt;&gt;&gt;&gt;       static func &lt;=&gt;(lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt;&gt;&gt;       static func &lt;(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;       static func &gt;(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;       static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;       static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The comparison operators are kept in the interface so that partially<br>&gt;&gt;&gt;&gt; ordered types such as Double can be supported in generic code. However, the<br>&gt;&gt;&gt;&gt; documentation should recommend against defining `&lt;` manually.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 3) Default implementations for &lt;Self : Comparable&gt; are provided for the<br>&gt;&gt;&gt;&gt; following operators: ==, &lt;, &gt;, &lt;=, and &gt;=.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 4) User-defined types will need to define just &lt;=&gt; to conform to<br>&gt;&gt;&gt;&gt; Comparable. (Even == can be omitted!)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 5) FloatingPoint types implement custom versions of ==, &lt;, &gt;, &lt;=, and<br>&gt;&gt;&gt;&gt; &gt;= using the standard IEEE 754 definition (i.e. comparisons involving NaN<br>&gt;&gt;&gt;&gt; return false). Zero is zero; `0.0 == -0.0 &amp;&amp; !(-0.0 &lt; 0.0)` holds.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 6) FloatingPoint types implement &lt;=&gt; as:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     func &lt;=&gt; &lt;T : FloatingPoint&gt;(lhs: T, rhs: T) -&gt; Ordering {<br>&gt;&gt;&gt;&gt;       if lhs &lt; rhs { return .ascending }<br>&gt;&gt;&gt;&gt;       if rhs &lt; lhs { return .descending }<br>&gt;&gt;&gt;&gt;       precondition(lhs == rhs)<br>&gt;&gt;&gt;&gt;       return .same<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 7) Algorithms using &lt;=&gt; directly should mention so in their<br>&gt;&gt;&gt;&gt; documentation as a precondition that they require total order between<br>&gt;&gt;&gt;&gt; elements. Many generic algorithms can be defined in terms of == or &lt;, and<br>&gt;&gt;&gt;&gt; should.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If we took the oroginally planned route that distinguished between<br>&gt;&gt;&gt;&gt; identities such as -0.0 vs. +0.0, or between the 2⁴⁹ - 2 ≈ 5.6 × 10¹⁴<br>&gt;&gt;&gt;&gt; possible NaN values that Double has, we&#39;d also need to consider other<br>&gt;&gt;&gt;&gt; oddballs like the difference and ordering between the Strings &quot;ä&quot; and<br>&gt;&gt;&gt;&gt; &quot;a\u{308}&quot;, which are considered equal but produce a different Unicode<br>&gt;&gt;&gt;&gt; representation. I think it&#39;s best to hide those identities behind another<br>&gt;&gt;&gt;&gt; interface than Equatable and Comparable, and let the protocols serve more<br>&gt;&gt;&gt;&gt; mundane application logic.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; — Pyry<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; Dave Abrahams wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; on Sat Jul 23 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; On Fri, Jul 22, 2016 at 11:34 PM, Stephen Canon &lt;scanon at apple.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; The point of this design is that `===` means identity and that<br>&gt;&gt;&gt;&gt; `.same `<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; also means identity.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; Since this is new territory I suppose we get to decide what<br>&gt;&gt;&gt;&gt; identity<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; means for floating point.  Should +0 and -0 have the same identity<br>&gt;&gt;&gt;&gt; or<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; not?  I’ll leave the answer to folks more knowledgable about<br>&gt;&gt;&gt;&gt; numerics<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; than I.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; Boy, I take my wife out for a movie and come back to 50 new<br>&gt;&gt;&gt;&gt; messages on SE.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; I need to read the entire thread more carefully, but off the top of<br>&gt;&gt;&gt;&gt; my<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; head, I think that `-0 === +0` is False.  If we’re going to have an<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; `isSame` / `isIdentical` / whatever it&#39;s called, I would expect it<br>&gt;&gt;&gt;&gt; to imply<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; substitutability.  Although -0 == +0, they are not equivalent when<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; substituted:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; - 1/(-0) != 1/0<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; - Float(-0).sign != Float(+0).sign<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; - etc<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; This probably then implies that `&lt;=&gt;` is not `.same` either.  I’ll<br>&gt;&gt;&gt;&gt; read<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; the rest of this and respond more completely tomorrow.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Eagerly await your evaluation of the discussion. In the meantime:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; I think Dave&#39;s view that `===` defines identity in terms of<br>&gt;&gt;&gt;&gt; &quot;essential&quot;<br>&gt;&gt;&gt;&gt; &gt;&gt; qualities implies that two identical values can be<br>&gt;&gt;&gt;&gt; &gt;&gt; different/non-substitutable in &quot;inessential&quot; qualities. For generic<br>&gt;&gt;&gt;&gt; &gt;&gt; purposes, the sign of zero could be one such inessential quality.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Yes, and I think our view of how people work with numbers in swift<br>&gt;&gt;&gt;&gt; (and<br>&gt;&gt;&gt;&gt; &gt; their protocol conformances) reflect this approach.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/16321<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; My sense is that we want to choose the default notions of identity and<br>&gt;&gt;&gt;&gt; &gt; ordering so as to support the way people think about these numeric<br>&gt;&gt;&gt;&gt; &gt; types, inexact though it may be.  Therefore, finding 0.0 in a sequence<br>&gt;&gt;&gt;&gt; &gt; of floats should succeed when the sequence contains -0.0, and a stable<br>&gt;&gt;&gt;&gt; &gt; sort on floating point keys should preserve the relative order of all<br>&gt;&gt;&gt;&gt; &gt; elements having +0.0 and -0.0 keys.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; People that want to work with inessential qualities such as the sign<br>&gt;&gt;&gt;&gt; of<br>&gt;&gt;&gt;&gt; &gt; zero can always pass Float.totalOrdering (or whatever) to their<br>&gt;&gt;&gt;&gt; &gt; closure-accepting algorithms.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; [In order to support the user model, we still need to fix the<br>&gt;&gt;&gt;&gt; semantics<br>&gt;&gt;&gt;&gt; &gt; of the default identity and ordering operations so that things like<br>&gt;&gt;&gt;&gt; &gt; sorting and searching work, which is why == and &lt; won&#39;t cut it for<br>&gt;&gt;&gt;&gt; these<br>&gt;&gt;&gt;&gt; &gt; purposes]<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; On the other hand, the stdlib stride algorithm is going to be borked<br>&gt;&gt;&gt;&gt; if -0<br>&gt;&gt;&gt;&gt; &gt;&gt; &lt; +0. Of course, as we already started to do there, we could<br>&gt;&gt;&gt;&gt; specialize for<br>&gt;&gt;&gt;&gt; &gt;&gt; floating point and then adjust accordingly. However, it seems to me<br>&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt; &gt;&gt; every generic algorithm that performs comparisons and can take<br>&gt;&gt;&gt;&gt; floating<br>&gt;&gt;&gt;&gt; &gt;&gt; point arguments would have to be specialized to account for floating<br>&gt;&gt;&gt;&gt; point<br>&gt;&gt;&gt;&gt; &gt;&gt; -0 != +0 (`index(of:)` being the previous example). This appears to<br>&gt;&gt;&gt;&gt; defeat<br>&gt;&gt;&gt;&gt; &gt;&gt; the aim of trying to accommodate FP at all in this revised design for<br>&gt;&gt;&gt;&gt; &gt;&gt; Comparables.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Yes, that would be a disaster, generically speaking.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; The argument for `-0 === +0` is that -0 and +0 should be equivalent<br>&gt;&gt;&gt;&gt; when<br>&gt;&gt;&gt;&gt; &gt;&gt; substituted for every comparison operation. For FP operations, you&#39;d<br>&gt;&gt;&gt;&gt; &gt;&gt; continue to test (as you have to test now) `a == b &amp;&amp; a.sign ==<br>&gt;&gt;&gt;&gt; b.sign` if<br>&gt;&gt;&gt;&gt; &gt;&gt; you cared about the sign of zero. For non-FP arithmetic operations,<br>&gt;&gt;&gt;&gt; hmm,<br>&gt;&gt;&gt;&gt; &gt;&gt; not sure how to square that circle.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I followed all of this... except, what are you getting at with that<br>&gt;&gt;&gt;&gt; last<br>&gt;&gt;&gt;&gt; &gt; sentence?<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt;&gt; &gt; Dave<br>&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160723/3940fb42/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 23, 2016 at 04:00:00pm</p></header><div class="content"><p>On Sat, Jul 23, 2016 at 4:19 PM, Nevin Brackett-Rozinsky &lt;<br>nevin.brackettrozinsky at gmail.com&gt; wrote:<br></p><p>&gt; Another option would be to leave the IEEE 754 NaN hijinks in Float and<br>&gt; Double (as numerics people expect), and create a new type (with a nice<br>&gt; approachable name) that “acts like” Double but does not model NaN. Then any<br>&gt; operation which would ordinarily produce a NaN, instead traps for the new<br>&gt; type. That way its comparison operators only have to worry about non-NaN<br>&gt; values, which makes everything much cleaner.<br>&gt;<br>&gt; Sorting Doubles would retain its present functionality, warts and all,<br>&gt; which numerics people should be expected to handle. Whereas the new type<br>&gt; (“Number” sounds good, especially if we can make it subsume NSNumber) would<br>&gt; never have a NaN in the first place.<br>&gt;<br></p><p>The other comment I would make here is that, as mentioned earlier by Pyry,<br>there are other types for which we&#39;ll need to reckon with domain-specific<br>&quot;hijinks&quot; that don&#39;t offer easy notions of identity, Unicode being one<br>example. I&#39;d expect that many types that model an existing domain of human<br>endeavor will run into something like this. Thus, carefully working through<br>a design for fundamental protocols like Equatable and Comparable that don&#39;t<br>fall down with FP will prove more broadly fruitful. I don&#39;t think that<br>segregating all hijinks and modeling what we *wish* the world to be is as<br>beneficial in terms of allowing generic algorithms to work meaningfully<br>with types that people actually use in real-world scenarios.<br></p><p><br>&gt; Nevin<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Sat, Jul 23, 2016 at 4:57 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Sorry to overwhelm with more emails. I&#39;d like to show some work and<br>&gt;&gt; further analysis for your consideration that refines the sketch I just<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Two FP values a and b can be, with respect to each other:<br>&gt;&gt;<br>&gt;&gt; * ordered or unordered (per IEEE, NaN compares unordered to everything,<br>&gt;&gt; including itself)<br>&gt;&gt; * identical or not identical (for these purposes, we adopt Steve&#39;s<br>&gt;&gt; proposed test for identity: substitutable for all operations; thus +0 is<br>&gt;&gt; not identical to -0, but different binary representations of the same value<br>&gt;&gt; are identical)<br>&gt;&gt; * equal or not equal (i.e. the behavior of the == operator today)<br>&gt;&gt;<br>&gt;&gt; So, if a and b are, with respect to each other:<br>&gt;&gt;<br>&gt;&gt; * ordered, identical, equal -- this is what happens ordinarily with two<br>&gt;&gt; equal, non-NaN values<br>&gt;&gt; * ordered, identical, not equal -- this can never happen<br>&gt;&gt; * ordered, not identical, equal -- only +0 and -0<br>&gt;&gt; * ordered, not identical, not equal -- this is what happens ordinarily<br>&gt;&gt; with two unequal, non-NaN values<br>&gt;&gt;<br>&gt;&gt; * unordered, identical, equal -- this can never happen, but if NaNs are<br>&gt;&gt; to be well-behaved (for a true equivalence relation), then we will need an<br>&gt;&gt; equivalence relation in which NaN == NaN<br>&gt;&gt; * unordered, identical, not equal -- this is what always happens, but if<br>&gt;&gt; NaNs are to be well-behaved, then such behavior will need to change<br>&gt;&gt; * unordered, not identical, equal -- this can never happen<br>&gt;&gt; * unordered, not identical, not equal -- this is what ordinarily happens<br>&gt;&gt; with one NaN and one non-NaN value<br>&gt;&gt;<br>&gt;&gt; Equatable can have === and my proposed ==? as part of its protocol; a<br>&gt;&gt; generic ==, as originally proposed, would be defined outside the protocol.<br>&gt;&gt; A default implementation of ==? will forward to ===, and the generic ==<br>&gt;&gt; will be defined as `{ return (lhs ==? rhs) ?? (lhs === rhs) }`.<br>&gt;&gt; For floating point, ==? will be specialized and cease to forward to ===<br>&gt;&gt; so that +0 and -0 compare true and NaN and anything compare nil, and<br>&gt;&gt; floating point == will be defined notionally as `{ return (lhs ==? rhs) ??<br>&gt;&gt; false }`.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sat, Jul 23, 2016 at 3:09 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Throwing out some more radical ideas here. Suppose we had instead<br>&gt;&gt;&gt; (taking inspiration from IEEE notation):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; [Pardon any errors; I&#39;m writing freehand in Gmail]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; infix operator ==? { /* figure out precedence later */ }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;   static func ==? (lhs: Self, rhs: Self) -&gt; Bool?<br>&gt;&gt;&gt;   /* semantics:<br>&gt;&gt;&gt;      this function returns nil if lhs and rhs are unordered with respect<br>&gt;&gt;&gt; to each other<br>&gt;&gt;&gt;      otherwise, evaluate by means of a legal equivalence relation */<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func == &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;&gt;   return (lhs ==? rhs) ?? false<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Comparable : Equatable {<br>&gt;&gt;&gt;   static func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt;&gt;   /* semantics:<br>&gt;&gt;&gt;      this is a total ordering; thus:<br>&gt;&gt;&gt;      if `(a ==? b) == true`, then `(a &lt;=&gt; b) == .same`<br>&gt;&gt;&gt;      if `(a ==? b) == false`, then `(a &lt;=&gt; b) != .same`<br>&gt;&gt;&gt;      but, if `(a ==? b) == nil`, then `a &lt;=&gt; b` may yield any result<br>&gt;&gt;&gt;   */<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sat, Jul 23, 2016 at 2:35 PM, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Given all this, I propose a simpler model that makes `a &lt;=&gt; b` follow<br>&gt;&gt;&gt;&gt; the expected behaviour of &lt; and ==, with the tradeoff that `a &lt;=&gt; .nan` and<br>&gt;&gt;&gt;&gt; `.nan &lt;=&gt; b` will abort with a precondition failure:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 1) We keep the current Interface of Equatable  unchanged, with !=<br>&gt;&gt;&gt;&gt; defined in terms of ==.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 2) Comparable would still refine Equatable, and include all the<br>&gt;&gt;&gt;&gt; comparison operators, adding the new &lt;=&gt;:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     protocol Comparable : Equatable {<br>&gt;&gt;&gt;&gt;       static func &lt;=&gt;(lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt;&gt;&gt;       static func &lt;(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;       static func &gt;(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;       static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;       static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The comparison operators are kept in the interface so that partially<br>&gt;&gt;&gt;&gt; ordered types such as Double can be supported in generic code. However, the<br>&gt;&gt;&gt;&gt; documentation should recommend against defining `&lt;` manually.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 3) Default implementations for &lt;Self : Comparable&gt; are provided for the<br>&gt;&gt;&gt;&gt; following operators: ==, &lt;, &gt;, &lt;=, and &gt;=.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 4) User-defined types will need to define just &lt;=&gt; to conform to<br>&gt;&gt;&gt;&gt; Comparable. (Even == can be omitted!)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 5) FloatingPoint types implement custom versions of ==, &lt;, &gt;, &lt;=, and<br>&gt;&gt;&gt;&gt; &gt;= using the standard IEEE 754 definition (i.e. comparisons involving NaN<br>&gt;&gt;&gt;&gt; return false). Zero is zero; `0.0 == -0.0 &amp;&amp; !(-0.0 &lt; 0.0)` holds.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 6) FloatingPoint types implement &lt;=&gt; as:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     func &lt;=&gt; &lt;T : FloatingPoint&gt;(lhs: T, rhs: T) -&gt; Ordering {<br>&gt;&gt;&gt;&gt;       if lhs &lt; rhs { return .ascending }<br>&gt;&gt;&gt;&gt;       if rhs &lt; lhs { return .descending }<br>&gt;&gt;&gt;&gt;       precondition(lhs == rhs)<br>&gt;&gt;&gt;&gt;       return .same<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 7) Algorithms using &lt;=&gt; directly should mention so in their<br>&gt;&gt;&gt;&gt; documentation as a precondition that they require total order between<br>&gt;&gt;&gt;&gt; elements. Many generic algorithms can be defined in terms of == or &lt;, and<br>&gt;&gt;&gt;&gt; should.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If we took the oroginally planned route that distinguished between<br>&gt;&gt;&gt;&gt; identities such as -0.0 vs. +0.0, or between the 2⁴⁹ - 2 ≈ 5.6 × 10¹⁴<br>&gt;&gt;&gt;&gt; possible NaN values that Double has, we&#39;d also need to consider other<br>&gt;&gt;&gt;&gt; oddballs like the difference and ordering between the Strings &quot;ä&quot; and<br>&gt;&gt;&gt;&gt; &quot;a\u{308}&quot;, which are considered equal but produce a different Unicode<br>&gt;&gt;&gt;&gt; representation. I think it&#39;s best to hide those identities behind another<br>&gt;&gt;&gt;&gt; interface than Equatable and Comparable, and let the protocols serve more<br>&gt;&gt;&gt;&gt; mundane application logic.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; — Pyry<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; Dave Abrahams wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; on Sat Jul 23 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; On Fri, Jul 22, 2016 at 11:34 PM, Stephen Canon &lt;scanon at apple.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; The point of this design is that `===` means identity and that<br>&gt;&gt;&gt;&gt; `.same `<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; also means identity.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; Since this is new territory I suppose we get to decide what<br>&gt;&gt;&gt;&gt; identity<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; means for floating point.  Should +0 and -0 have the same identity<br>&gt;&gt;&gt;&gt; or<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; not?  I’ll leave the answer to folks more knowledgable about<br>&gt;&gt;&gt;&gt; numerics<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; than I.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; Boy, I take my wife out for a movie and come back to 50 new<br>&gt;&gt;&gt;&gt; messages on SE.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; I need to read the entire thread more carefully, but off the top of<br>&gt;&gt;&gt;&gt; my<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; head, I think that `-0 === +0` is False.  If we’re going to have an<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; `isSame` / `isIdentical` / whatever it&#39;s called, I would expect it<br>&gt;&gt;&gt;&gt; to imply<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; substitutability.  Although -0 == +0, they are not equivalent when<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; substituted:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; - 1/(-0) != 1/0<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; - Float(-0).sign != Float(+0).sign<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; - etc<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; This probably then implies that `&lt;=&gt;` is not `.same` either.  I’ll<br>&gt;&gt;&gt;&gt; read<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; the rest of this and respond more completely tomorrow.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Eagerly await your evaluation of the discussion. In the meantime:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; I think Dave&#39;s view that `===` defines identity in terms of<br>&gt;&gt;&gt;&gt; &quot;essential&quot;<br>&gt;&gt;&gt;&gt; &gt;&gt; qualities implies that two identical values can be<br>&gt;&gt;&gt;&gt; &gt;&gt; different/non-substitutable in &quot;inessential&quot; qualities. For generic<br>&gt;&gt;&gt;&gt; &gt;&gt; purposes, the sign of zero could be one such inessential quality.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Yes, and I think our view of how people work with numbers in swift<br>&gt;&gt;&gt;&gt; (and<br>&gt;&gt;&gt;&gt; &gt; their protocol conformances) reflect this approach.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/16321<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; My sense is that we want to choose the default notions of identity and<br>&gt;&gt;&gt;&gt; &gt; ordering so as to support the way people think about these numeric<br>&gt;&gt;&gt;&gt; &gt; types, inexact though it may be.  Therefore, finding 0.0 in a sequence<br>&gt;&gt;&gt;&gt; &gt; of floats should succeed when the sequence contains -0.0, and a stable<br>&gt;&gt;&gt;&gt; &gt; sort on floating point keys should preserve the relative order of all<br>&gt;&gt;&gt;&gt; &gt; elements having +0.0 and -0.0 keys.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; People that want to work with inessential qualities such as the sign<br>&gt;&gt;&gt;&gt; of<br>&gt;&gt;&gt;&gt; &gt; zero can always pass Float.totalOrdering (or whatever) to their<br>&gt;&gt;&gt;&gt; &gt; closure-accepting algorithms.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; [In order to support the user model, we still need to fix the<br>&gt;&gt;&gt;&gt; semantics<br>&gt;&gt;&gt;&gt; &gt; of the default identity and ordering operations so that things like<br>&gt;&gt;&gt;&gt; &gt; sorting and searching work, which is why == and &lt; won&#39;t cut it for<br>&gt;&gt;&gt;&gt; these<br>&gt;&gt;&gt;&gt; &gt; purposes]<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; On the other hand, the stdlib stride algorithm is going to be borked<br>&gt;&gt;&gt;&gt; if -0<br>&gt;&gt;&gt;&gt; &gt;&gt; &lt; +0. Of course, as we already started to do there, we could<br>&gt;&gt;&gt;&gt; specialize for<br>&gt;&gt;&gt;&gt; &gt;&gt; floating point and then adjust accordingly. However, it seems to me<br>&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt; &gt;&gt; every generic algorithm that performs comparisons and can take<br>&gt;&gt;&gt;&gt; floating<br>&gt;&gt;&gt;&gt; &gt;&gt; point arguments would have to be specialized to account for floating<br>&gt;&gt;&gt;&gt; point<br>&gt;&gt;&gt;&gt; &gt;&gt; -0 != +0 (`index(of:)` being the previous example). This appears to<br>&gt;&gt;&gt;&gt; defeat<br>&gt;&gt;&gt;&gt; &gt;&gt; the aim of trying to accommodate FP at all in this revised design for<br>&gt;&gt;&gt;&gt; &gt;&gt; Comparables.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Yes, that would be a disaster, generically speaking.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; The argument for `-0 === +0` is that -0 and +0 should be equivalent<br>&gt;&gt;&gt;&gt; when<br>&gt;&gt;&gt;&gt; &gt;&gt; substituted for every comparison operation. For FP operations, you&#39;d<br>&gt;&gt;&gt;&gt; &gt;&gt; continue to test (as you have to test now) `a == b &amp;&amp; a.sign ==<br>&gt;&gt;&gt;&gt; b.sign` if<br>&gt;&gt;&gt;&gt; &gt;&gt; you cared about the sign of zero. For non-FP arithmetic operations,<br>&gt;&gt;&gt;&gt; hmm,<br>&gt;&gt;&gt;&gt; &gt;&gt; not sure how to square that circle.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I followed all of this... except, what are you getting at with that<br>&gt;&gt;&gt;&gt; last<br>&gt;&gt;&gt;&gt; &gt; sentence?<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt;&gt; &gt; Dave<br>&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160723/9865ca42/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>July 23, 2016 at 11:00:00pm</p></header><div class="content"><p>This might be a radical suggestion ... or possibly a naive or unoriginal<br>one, I&#39;ll find out once I suggest it.<br></p><p>Swift took the bold step of establishing optionals as a central type,<br>rather than assigning dual meanings to &#39;default&#39; values such as zero or<br>false. Recognising the concept of not having a value, and safeguarding<br>against that, is core to Swift.<br>Is it possible for Swift to recognise that there are values which simply<br>aren&#39;t comparable, rather than forcing a choice between ascending, same,<br>descending? Could we add a fourth: incomparable?<br></p><p>What if a sort operation didn&#39;t simply return an array of ordered values?<br>What if it *partitioned* the values into comparable and incomparable<br>values, and returned a sorted array of the former and an unordered<br>collection of the latter?<br>Maybe, this being Swift, we could use some kind of &#39;sort!&#39; exclamation mark<br>to forcibly express that every value in the collection-to-be-sorted is<br>implicitly comparable, if we&#39;re sure.<br></p><p><br>On Sat, Jul 23, 2016 at 10:37 PM, Xiaodi Wu via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Sat, Jul 23, 2016 at 4:19 PM, Nevin Brackett-Rozinsky &lt;<br>&gt; nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; Another option would be to leave the IEEE 754 NaN hijinks in Float and<br>&gt;&gt; Double (as numerics people expect), and create a new type (with a nice<br>&gt;&gt; approachable name) that “acts like” Double but does not model NaN. Then any<br>&gt;&gt; operation which would ordinarily produce a NaN, instead traps for the new<br>&gt;&gt; type. That way its comparison operators only have to worry about non-NaN<br>&gt;&gt; values, which makes everything much cleaner.<br>&gt;&gt;<br>&gt;&gt; Sorting Doubles would retain its present functionality, warts and all,<br>&gt;&gt; which numerics people should be expected to handle. Whereas the new type<br>&gt;&gt; (“Number” sounds good, especially if we can make it subsume NSNumber) would<br>&gt;&gt; never have a NaN in the first place.<br>&gt;&gt;<br>&gt;<br>&gt; The other comment I would make here is that, as mentioned earlier by Pyry,<br>&gt; there are other types for which we&#39;ll need to reckon with domain-specific<br>&gt; &quot;hijinks&quot; that don&#39;t offer easy notions of identity, Unicode being one<br>&gt; example. I&#39;d expect that many types that model an existing domain of human<br>&gt; endeavor will run into something like this. Thus, carefully working through<br>&gt; a design for fundamental protocols like Equatable and Comparable that don&#39;t<br>&gt; fall down with FP will prove more broadly fruitful. I don&#39;t think that<br>&gt; segregating all hijinks and modeling what we *wish* the world to be is as<br>&gt; beneficial in terms of allowing generic algorithms to work meaningfully<br>&gt; with types that people actually use in real-world scenarios.<br>&gt;<br>&gt;<br>&gt;&gt; Nevin<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sat, Jul 23, 2016 at 4:57 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Sorry to overwhelm with more emails. I&#39;d like to show some work and<br>&gt;&gt;&gt; further analysis for your consideration that refines the sketch I just<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Two FP values a and b can be, with respect to each other:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * ordered or unordered (per IEEE, NaN compares unordered to everything,<br>&gt;&gt;&gt; including itself)<br>&gt;&gt;&gt; * identical or not identical (for these purposes, we adopt Steve&#39;s<br>&gt;&gt;&gt; proposed test for identity: substitutable for all operations; thus +0 is<br>&gt;&gt;&gt; not identical to -0, but different binary representations of the same value<br>&gt;&gt;&gt; are identical)<br>&gt;&gt;&gt; * equal or not equal (i.e. the behavior of the == operator today)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So, if a and b are, with respect to each other:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * ordered, identical, equal -- this is what happens ordinarily with two<br>&gt;&gt;&gt; equal, non-NaN values<br>&gt;&gt;&gt; * ordered, identical, not equal -- this can never happen<br>&gt;&gt;&gt; * ordered, not identical, equal -- only +0 and -0<br>&gt;&gt;&gt; * ordered, not identical, not equal -- this is what happens ordinarily<br>&gt;&gt;&gt; with two unequal, non-NaN values<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * unordered, identical, equal -- this can never happen, but if NaNs are<br>&gt;&gt;&gt; to be well-behaved (for a true equivalence relation), then we will need an<br>&gt;&gt;&gt; equivalence relation in which NaN == NaN<br>&gt;&gt;&gt; * unordered, identical, not equal -- this is what always happens, but if<br>&gt;&gt;&gt; NaNs are to be well-behaved, then such behavior will need to change<br>&gt;&gt;&gt; * unordered, not identical, equal -- this can never happen<br>&gt;&gt;&gt; * unordered, not identical, not equal -- this is what ordinarily happens<br>&gt;&gt;&gt; with one NaN and one non-NaN value<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Equatable can have === and my proposed ==? as part of its protocol; a<br>&gt;&gt;&gt; generic ==, as originally proposed, would be defined outside the protocol.<br>&gt;&gt;&gt; A default implementation of ==? will forward to ===, and the generic ==<br>&gt;&gt;&gt; will be defined as `{ return (lhs ==? rhs) ?? (lhs === rhs) }`.<br>&gt;&gt;&gt; For floating point, ==? will be specialized and cease to forward to ===<br>&gt;&gt;&gt; so that +0 and -0 compare true and NaN and anything compare nil, and<br>&gt;&gt;&gt; floating point == will be defined notionally as `{ return (lhs ==? rhs) ??<br>&gt;&gt;&gt; false }`.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sat, Jul 23, 2016 at 3:09 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Throwing out some more radical ideas here. Suppose we had instead<br>&gt;&gt;&gt;&gt; (taking inspiration from IEEE notation):<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; [Pardon any errors; I&#39;m writing freehand in Gmail]<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; infix operator ==? { /* figure out precedence later */ }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;&gt;   static func ==? (lhs: Self, rhs: Self) -&gt; Bool?<br>&gt;&gt;&gt;&gt;   /* semantics:<br>&gt;&gt;&gt;&gt;      this function returns nil if lhs and rhs are unordered with<br>&gt;&gt;&gt;&gt; respect to each other<br>&gt;&gt;&gt;&gt;      otherwise, evaluate by means of a legal equivalence relation */<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func == &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;&gt;&gt;   return (lhs ==? rhs) ?? false<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; protocol Comparable : Equatable {<br>&gt;&gt;&gt;&gt;   static func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt;&gt;&gt;   /* semantics:<br>&gt;&gt;&gt;&gt;      this is a total ordering; thus:<br>&gt;&gt;&gt;&gt;      if `(a ==? b) == true`, then `(a &lt;=&gt; b) == .same`<br>&gt;&gt;&gt;&gt;      if `(a ==? b) == false`, then `(a &lt;=&gt; b) != .same`<br>&gt;&gt;&gt;&gt;      but, if `(a ==? b) == nil`, then `a &lt;=&gt; b` may yield any result<br>&gt;&gt;&gt;&gt;   */<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Sat, Jul 23, 2016 at 2:35 PM, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Given all this, I propose a simpler model that makes `a &lt;=&gt; b` follow<br>&gt;&gt;&gt;&gt;&gt; the expected behaviour of &lt; and ==, with the tradeoff that `a &lt;=&gt; .nan` and<br>&gt;&gt;&gt;&gt;&gt; `.nan &lt;=&gt; b` will abort with a precondition failure:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 1) We keep the current Interface of Equatable  unchanged, with !=<br>&gt;&gt;&gt;&gt;&gt; defined in terms of ==.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 2) Comparable would still refine Equatable, and include all the<br>&gt;&gt;&gt;&gt;&gt; comparison operators, adding the new &lt;=&gt;:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     protocol Comparable : Equatable {<br>&gt;&gt;&gt;&gt;&gt;       static func &lt;=&gt;(lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt;&gt;&gt;&gt;       static func &lt;(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;       static func &gt;(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;       static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;       static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; The comparison operators are kept in the interface so that partially<br>&gt;&gt;&gt;&gt;&gt; ordered types such as Double can be supported in generic code. However, the<br>&gt;&gt;&gt;&gt;&gt; documentation should recommend against defining `&lt;` manually.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 3) Default implementations for &lt;Self : Comparable&gt; are provided for<br>&gt;&gt;&gt;&gt;&gt; the following operators: ==, &lt;, &gt;, &lt;=, and &gt;=.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 4) User-defined types will need to define just &lt;=&gt; to conform to<br>&gt;&gt;&gt;&gt;&gt; Comparable. (Even == can be omitted!)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 5) FloatingPoint types implement custom versions of ==, &lt;, &gt;, &lt;=, and<br>&gt;&gt;&gt;&gt;&gt; &gt;= using the standard IEEE 754 definition (i.e. comparisons involving NaN<br>&gt;&gt;&gt;&gt;&gt; return false). Zero is zero; `0.0 == -0.0 &amp;&amp; !(-0.0 &lt; 0.0)` holds.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 6) FloatingPoint types implement &lt;=&gt; as:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     func &lt;=&gt; &lt;T : FloatingPoint&gt;(lhs: T, rhs: T) -&gt; Ordering {<br>&gt;&gt;&gt;&gt;&gt;       if lhs &lt; rhs { return .ascending }<br>&gt;&gt;&gt;&gt;&gt;       if rhs &lt; lhs { return .descending }<br>&gt;&gt;&gt;&gt;&gt;       precondition(lhs == rhs)<br>&gt;&gt;&gt;&gt;&gt;       return .same<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 7) Algorithms using &lt;=&gt; directly should mention so in their<br>&gt;&gt;&gt;&gt;&gt; documentation as a precondition that they require total order between<br>&gt;&gt;&gt;&gt;&gt; elements. Many generic algorithms can be defined in terms of == or &lt;, and<br>&gt;&gt;&gt;&gt;&gt; should.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; If we took the oroginally planned route that distinguished between<br>&gt;&gt;&gt;&gt;&gt; identities such as -0.0 vs. +0.0, or between the 2⁴⁹ - 2 ≈ 5.6 × 10¹⁴<br>&gt;&gt;&gt;&gt;&gt; possible NaN values that Double has, we&#39;d also need to consider other<br>&gt;&gt;&gt;&gt;&gt; oddballs like the difference and ordering between the Strings &quot;ä&quot; and<br>&gt;&gt;&gt;&gt;&gt; &quot;a\u{308}&quot;, which are considered equal but produce a different Unicode<br>&gt;&gt;&gt;&gt;&gt; representation. I think it&#39;s best to hide those identities behind another<br>&gt;&gt;&gt;&gt;&gt; interface than Equatable and Comparable, and let the protocols serve more<br>&gt;&gt;&gt;&gt;&gt; mundane application logic.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; — Pyry<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Dave Abrahams wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; on Sat Jul 23 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; On Fri, Jul 22, 2016 at 11:34 PM, Stephen Canon &lt;scanon at apple.com&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; The point of this design is that `===` means identity and that<br>&gt;&gt;&gt;&gt;&gt; `.same `<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; also means identity.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; Since this is new territory I suppose we get to decide what<br>&gt;&gt;&gt;&gt;&gt; identity<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; means for floating point.  Should +0 and -0 have the same<br>&gt;&gt;&gt;&gt;&gt; identity or<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; not?  I’ll leave the answer to folks more knowledgable about<br>&gt;&gt;&gt;&gt;&gt; numerics<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; than I.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; Boy, I take my wife out for a movie and come back to 50 new<br>&gt;&gt;&gt;&gt;&gt; messages on SE.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; I need to read the entire thread more carefully, but off the top<br>&gt;&gt;&gt;&gt;&gt; of my<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; head, I think that `-0 === +0` is False.  If we’re going to have an<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; `isSame` / `isIdentical` / whatever it&#39;s called, I would expect it<br>&gt;&gt;&gt;&gt;&gt; to imply<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; substitutability.  Although -0 == +0, they are not equivalent when<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; substituted:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; - 1/(-0) != 1/0<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; - Float(-0).sign != Float(+0).sign<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; - etc<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; This probably then implies that `&lt;=&gt;` is not `.same` either.  I’ll<br>&gt;&gt;&gt;&gt;&gt; read<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; the rest of this and respond more completely tomorrow.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Eagerly await your evaluation of the discussion. In the meantime:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; I think Dave&#39;s view that `===` defines identity in terms of<br>&gt;&gt;&gt;&gt;&gt; &quot;essential&quot;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; qualities implies that two identical values can be<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; different/non-substitutable in &quot;inessential&quot; qualities. For generic<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; purposes, the sign of zero could be one such inessential quality.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Yes, and I think our view of how people work with numbers in swift<br>&gt;&gt;&gt;&gt;&gt; (and<br>&gt;&gt;&gt;&gt;&gt; &gt; their protocol conformances) reflect this approach.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/16321<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; My sense is that we want to choose the default notions of identity<br>&gt;&gt;&gt;&gt;&gt; and<br>&gt;&gt;&gt;&gt;&gt; &gt; ordering so as to support the way people think about these numeric<br>&gt;&gt;&gt;&gt;&gt; &gt; types, inexact though it may be.  Therefore, finding 0.0 in a<br>&gt;&gt;&gt;&gt;&gt; sequence<br>&gt;&gt;&gt;&gt;&gt; &gt; of floats should succeed when the sequence contains -0.0, and a<br>&gt;&gt;&gt;&gt;&gt; stable<br>&gt;&gt;&gt;&gt;&gt; &gt; sort on floating point keys should preserve the relative order of all<br>&gt;&gt;&gt;&gt;&gt; &gt; elements having +0.0 and -0.0 keys.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; People that want to work with inessential qualities such as the sign<br>&gt;&gt;&gt;&gt;&gt; of<br>&gt;&gt;&gt;&gt;&gt; &gt; zero can always pass Float.totalOrdering (or whatever) to their<br>&gt;&gt;&gt;&gt;&gt; &gt; closure-accepting algorithms.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; [In order to support the user model, we still need to fix the<br>&gt;&gt;&gt;&gt;&gt; semantics<br>&gt;&gt;&gt;&gt;&gt; &gt; of the default identity and ordering operations so that things like<br>&gt;&gt;&gt;&gt;&gt; &gt; sorting and searching work, which is why == and &lt; won&#39;t cut it for<br>&gt;&gt;&gt;&gt;&gt; these<br>&gt;&gt;&gt;&gt;&gt; &gt; purposes]<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; On the other hand, the stdlib stride algorithm is going to be<br>&gt;&gt;&gt;&gt;&gt; borked if -0<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; &lt; +0. Of course, as we already started to do there, we could<br>&gt;&gt;&gt;&gt;&gt; specialize for<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; floating point and then adjust accordingly. However, it seems to me<br>&gt;&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; every generic algorithm that performs comparisons and can take<br>&gt;&gt;&gt;&gt;&gt; floating<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; point arguments would have to be specialized to account for<br>&gt;&gt;&gt;&gt;&gt; floating point<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; -0 != +0 (`index(of:)` being the previous example). This appears to<br>&gt;&gt;&gt;&gt;&gt; defeat<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; the aim of trying to accommodate FP at all in this revised design<br>&gt;&gt;&gt;&gt;&gt; for<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Comparables.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Yes, that would be a disaster, generically speaking.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; The argument for `-0 === +0` is that -0 and +0 should be equivalent<br>&gt;&gt;&gt;&gt;&gt; when<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; substituted for every comparison operation. For FP operations, you&#39;d<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; continue to test (as you have to test now) `a == b &amp;&amp; a.sign ==<br>&gt;&gt;&gt;&gt;&gt; b.sign` if<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; you cared about the sign of zero. For non-FP arithmetic operations,<br>&gt;&gt;&gt;&gt;&gt; hmm,<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; not sure how to square that circle.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I followed all of this... except, what are you getting at with that<br>&gt;&gt;&gt;&gt;&gt; last<br>&gt;&gt;&gt;&gt;&gt; &gt; sentence?<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt;&gt;&gt; &gt; Dave<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160723/8f827dcb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>July 23, 2016 at 05:00:00pm</p></header><div class="content"><p>Daniel Duan<br>Sent from my iPhone<br></p><p>&gt; On Jul 23, 2016, at 3:15 PM, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This might be a radical suggestion ... or possibly a naive or unoriginal one, I&#39;ll find out once I suggest it.<br>&gt; <br>&gt; Swift took the bold step of establishing optionals as a central type, rather than assigning dual meanings to &#39;default&#39; values such as zero or false. Recognising the concept of not having a value, and safeguarding against that, is core to Swift.<br></p><p>Optional is nothing new or &quot;bold&quot;. It&#39;s been main stream for years. Even C++ has it :)<br></p><p>&gt; Is it possible for Swift to recognise that there are values which simply aren&#39;t comparable, rather than forcing a choice between ascending, same, descending? Could we add a fourth: incomparable?<br>&gt; <br></p><p>The problem we are trying to solve here is strict total ordering: https://en.m.wikipedia.org/wiki/Total_order<br></p><p>&gt; What if a sort operation didn&#39;t simply return an array of ordered values? What if it partitioned the values into comparable and incomparable values, and returned a sorted array of the former and an unordered collection of the latter?<br>&gt; Maybe, this being Swift, we could use some kind of &#39;sort!&#39; exclamation mark to forcibly express that every value in the collection-to-be-sorted is implicitly comparable, if we&#39;re sure.<br>&gt; <br>&gt; <br>&gt;&gt; On Sat, Jul 23, 2016 at 10:37 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; On Sat, Jul 23, 2016 at 4:19 PM, Nevin Brackett-Rozinsky &lt;nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt;&gt;&gt; Another option would be to leave the IEEE 754 NaN hijinks in Float and Double (as numerics people expect), and create a new type (with a nice approachable name) that “acts like” Double but does not model NaN. Then any operation which would ordinarily produce a NaN, instead traps for the new type. That way its comparison operators only have to worry about non-NaN values, which makes everything much cleaner.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorting Doubles would retain its present functionality, warts and all, which numerics people should be expected to handle. Whereas the new type (“Number” sounds good, especially if we can make it subsume NSNumber) would never have a NaN in the first place.<br>&gt;&gt; <br>&gt;&gt; The other comment I would make here is that, as mentioned earlier by Pyry, there are other types for which we&#39;ll need to reckon with domain-specific &quot;hijinks&quot; that don&#39;t offer easy notions of identity, Unicode being one example. I&#39;d expect that many types that model an existing domain of human endeavor will run into something like this. Thus, carefully working through a design for fundamental protocols like Equatable and Comparable that don&#39;t fall down with FP will prove more broadly fruitful. I don&#39;t think that segregating all hijinks and modeling what we *wish* the world to be is as beneficial in terms of allowing generic algorithms to work meaningfully with types that people actually use in real-world scenarios.<br>&gt;&gt;  <br>&gt;&gt;&gt; Nevin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sat, Jul 23, 2016 at 4:57 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Sorry to overwhelm with more emails. I&#39;d like to show some work and further analysis for your consideration that refines the sketch I just wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Two FP values a and b can be, with respect to each other:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * ordered or unordered (per IEEE, NaN compares unordered to everything, including itself)<br>&gt;&gt;&gt;&gt; * identical or not identical (for these purposes, we adopt Steve&#39;s proposed test for identity: substitutable for all operations; thus +0 is not identical to -0, but different binary representations of the same value are identical)<br>&gt;&gt;&gt;&gt; * equal or not equal (i.e. the behavior of the == operator today)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So, if a and b are, with respect to each other:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * ordered, identical, equal -- this is what happens ordinarily with two equal, non-NaN values<br>&gt;&gt;&gt;&gt; * ordered, identical, not equal -- this can never happen<br>&gt;&gt;&gt;&gt; * ordered, not identical, equal -- only +0 and -0<br>&gt;&gt;&gt;&gt; * ordered, not identical, not equal -- this is what happens ordinarily with two unequal, non-NaN values<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * unordered, identical, equal -- this can never happen, but if NaNs are to be well-behaved (for a true equivalence relation), then we will need an equivalence relation in which NaN == NaN<br>&gt;&gt;&gt;&gt; * unordered, identical, not equal -- this is what always happens, but if NaNs are to be well-behaved, then such behavior will need to change<br>&gt;&gt;&gt;&gt; * unordered, not identical, equal -- this can never happen<br>&gt;&gt;&gt;&gt; * unordered, not identical, not equal -- this is what ordinarily happens with one NaN and one non-NaN value<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Equatable can have === and my proposed ==? as part of its protocol; a generic ==, as originally proposed, would be defined outside the protocol.<br>&gt;&gt;&gt;&gt; A default implementation of ==? will forward to ===, and the generic == will be defined as `{ return (lhs ==? rhs) ?? (lhs === rhs) }`.<br>&gt;&gt;&gt;&gt; For floating point, ==? will be specialized and cease to forward to === so that +0 and -0 compare true and NaN and anything compare nil, and floating point == will be defined notionally as `{ return (lhs ==? rhs) ?? false }`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sat, Jul 23, 2016 at 3:09 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Throwing out some more radical ideas here. Suppose we had instead (taking inspiration from IEEE notation):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; [Pardon any errors; I&#39;m writing freehand in Gmail]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; infix operator ==? { /* figure out precedence later */ }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;&gt;&gt;   static func ==? (lhs: Self, rhs: Self) -&gt; Bool?<br>&gt;&gt;&gt;&gt;&gt;   /* semantics:<br>&gt;&gt;&gt;&gt;&gt;      this function returns nil if lhs and rhs are unordered with respect to each other<br>&gt;&gt;&gt;&gt;&gt;      otherwise, evaluate by means of a legal equivalence relation */<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func == &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt;   return (lhs ==? rhs) ?? false<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol Comparable : Equatable {<br>&gt;&gt;&gt;&gt;&gt;   static func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt;&gt;&gt;&gt;   /* semantics:<br>&gt;&gt;&gt;&gt;&gt;      this is a total ordering; thus:<br>&gt;&gt;&gt;&gt;&gt;      if `(a ==? b) == true`, then `(a &lt;=&gt; b) == .same`<br>&gt;&gt;&gt;&gt;&gt;      if `(a ==? b) == false`, then `(a &lt;=&gt; b) != .same`<br>&gt;&gt;&gt;&gt;&gt;      but, if `(a ==? b) == nil`, then `a &lt;=&gt; b` may yield any result<br>&gt;&gt;&gt;&gt;&gt;   */<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Sat, Jul 23, 2016 at 2:35 PM, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Given all this, I propose a simpler model that makes `a &lt;=&gt; b` follow the expected behaviour of &lt; and ==, with the tradeoff that `a &lt;=&gt; .nan` and `.nan &lt;=&gt; b` will abort with a precondition failure:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1) We keep the current Interface of Equatable  unchanged, with != defined in terms of ==.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2) Comparable would still refine Equatable, and include all the comparison operators, adding the new &lt;=&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     protocol Comparable : Equatable {<br>&gt;&gt;&gt;&gt;&gt;&gt;       static func &lt;=&gt;(lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt;&gt;&gt;&gt;&gt;       static func &lt;(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;&gt;       static func &gt;(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;&gt;       static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;&gt;       static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The comparison operators are kept in the interface so that partially ordered types such as Double can be supported in generic code. However, the documentation should recommend against defining `&lt;` manually.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 3) Default implementations for &lt;Self : Comparable&gt; are provided for the following operators: ==, &lt;, &gt;, &lt;=, and &gt;=.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 4) User-defined types will need to define just &lt;=&gt; to conform to Comparable. (Even == can be omitted!)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 5) FloatingPoint types implement custom versions of ==, &lt;, &gt;, &lt;=, and &gt;= using the standard IEEE 754 definition (i.e. comparisons involving NaN return false). Zero is zero; `0.0 == -0.0 &amp;&amp; !(-0.0 &lt; 0.0)` holds.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 6) FloatingPoint types implement &lt;=&gt; as:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     func &lt;=&gt; &lt;T : FloatingPoint&gt;(lhs: T, rhs: T) -&gt; Ordering {<br>&gt;&gt;&gt;&gt;&gt;&gt;       if lhs &lt; rhs { return .ascending }<br>&gt;&gt;&gt;&gt;&gt;&gt;       if rhs &lt; lhs { return .descending }<br>&gt;&gt;&gt;&gt;&gt;&gt;       precondition(lhs == rhs)<br>&gt;&gt;&gt;&gt;&gt;&gt;       return .same<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 7) Algorithms using &lt;=&gt; directly should mention so in their documentation as a precondition that they require total order between elements. Many generic algorithms can be defined in terms of == or &lt;, and should.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If we took the oroginally planned route that distinguished between identities such as -0.0 vs. +0.0, or between the 2⁴⁹ - 2 ≈ 5.6 × 10¹⁴ possible NaN values that Double has, we&#39;d also need to consider other oddballs like the difference and ordering between the Strings &quot;ä&quot; and &quot;a\u{308}&quot;, which are considered equal but produce a different Unicode representation. I think it&#39;s best to hide those identities behind another interface than Equatable and Comparable, and let the protocols serve more mundane application logic.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; — Pyry<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Dave Abrahams wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; on Sat Jul 23 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On Fri, Jul 22, 2016 at 11:34 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; The point of this design is that `===` means identity and that `.same `<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; also means identity.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; Since this is new territory I suppose we get to decide what identity<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; means for floating point.  Should +0 and -0 have the same identity or<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; not?  I’ll leave the answer to folks more knowledgable about numerics<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; than I.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; Boy, I take my wife out for a movie and come back to 50 new messages on SE.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; I need to read the entire thread more carefully, but off the top of my<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; head, I think that `-0 === +0` is False.  If we’re going to have an<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; `isSame` / `isIdentical` / whatever it&#39;s called, I would expect it to imply<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; substitutability.  Although -0 == +0, they are not equivalent when<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; substituted:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; - 1/(-0) != 1/0<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; - Float(-0).sign != Float(+0).sign<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; - etc<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; This probably then implies that `&lt;=&gt;` is not `.same` either.  I’ll read<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; the rest of this and respond more completely tomorrow.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Eagerly await your evaluation of the discussion. In the meantime:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I think Dave&#39;s view that `===` defines identity in terms of &quot;essential&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; qualities implies that two identical values can be<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; different/non-substitutable in &quot;inessential&quot; qualities. For generic<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; purposes, the sign of zero could be one such inessential quality.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Yes, and I think our view of how people work with numbers in swift (and<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; their protocol conformances) reflect this approach.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/16321<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; My sense is that we want to choose the default notions of identity and<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; ordering so as to support the way people think about these numeric<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; types, inexact though it may be.  Therefore, finding 0.0 in a sequence<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; of floats should succeed when the sequence contains -0.0, and a stable<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; sort on floating point keys should preserve the relative order of all<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; elements having +0.0 and -0.0 keys.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; People that want to work with inessential qualities such as the sign of<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; zero can always pass Float.totalOrdering (or whatever) to their<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; closure-accepting algorithms.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; [In order to support the user model, we still need to fix the semantics<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; of the default identity and ordering operations so that things like<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; sorting and searching work, which is why == and &lt; won&#39;t cut it for these<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; purposes]<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On the other hand, the stdlib stride algorithm is going to be borked if -0<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; &lt; +0. Of course, as we already started to do there, we could specialize for<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; floating point and then adjust accordingly. However, it seems to me that<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; every generic algorithm that performs comparisons and can take floating<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; point arguments would have to be specialized to account for floating point<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; -0 != +0 (`index(of:)` being the previous example). This appears to defeat<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; the aim of trying to accommodate FP at all in this revised design for<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Comparables.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Yes, that would be a disaster, generically speaking.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; The argument for `-0 === +0` is that -0 and +0 should be equivalent when<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; substituted for every comparison operation. For FP operations, you&#39;d<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; continue to test (as you have to test now) `a == b &amp;&amp; a.sign == b.sign` if<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; you cared about the sign of zero. For non-FP arithmetic operations, hmm,<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; not sure how to square that circle.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; I followed all of this... except, what are you getting at with that last<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; sentence?<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160723/3571c93f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 24, 2016 at 09:00:00am</p></header><div class="content"><p>on Sat Jul 23 2016, Pyry Jahkola &lt;pyry.jahkola-AT-iki.fi&gt; wrote:<br></p><p>&gt; Given all this, I propose a simpler model that makes `a &lt;=&gt; b` follow<br>&gt; the expected behaviour of &lt; and ==, with the tradeoff that `a &lt;=&gt;<br>&gt; .nan` and `.nan &lt;=&gt; b` will abort with a precondition failure:<br></p><p>This effectively makes it a precondition violation to default-sort<br>a sequence of floats that contains a NaN or even to ask whether<br>someSequence.contains(.nan).  IMO that&#39;s not really acceptable.<br></p><p>&gt; 1) We keep the current Interface of Equatable unchanged, with !=<br>&gt; defined in terms of ==.<br>&gt;<br>&gt; 2) Comparable would still refine Equatable, and include all the<br>&gt; comparison operators, adding the new &lt;=&gt;:<br>&gt;<br>&gt;     protocol Comparable : Equatable {<br>&gt;       static func &lt;=&gt;(lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;       static func &lt;(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;       static func &gt;(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;       static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;       static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;     }<br>&gt;<br>&gt; The comparison operators are kept in the interface so that partially<br>&gt; ordered types such as Double can be supported in generic<br>&gt; code. However, the documentation should recommend against defining `&lt;`<br>&gt; manually.<br>&gt;<br>&gt; 3) Default implementations for &lt;Self : Comparable&gt; are provided for<br>&gt; the following operators: ==, &lt;, &gt;, &lt;=, and &gt;=.<br>&gt;<br>&gt; 4) User-defined types will need to define just &lt;=&gt; to conform to<br>&gt; Comparable. (Even == can be omitted!)<br>&gt;<br>&gt; 5) FloatingPoint types implement custom versions of ==, &lt;, &gt;, &lt;=, and<br>&gt;&gt;= using the standard IEEE 754 definition (i.e. comparisons involving<br>&gt; NaN return false). Zero is zero; `0.0 == -0.0 &amp;&amp; !(-0.0 &lt; 0.0)` holds.<br>&gt;<br>&gt; 6) FloatingPoint types implement &lt;=&gt; as:<br>&gt;<br>&gt;     func &lt;=&gt; &lt;T : FloatingPoint&gt;(lhs: T, rhs: T) -&gt; Ordering {<br>&gt;       if lhs &lt; rhs { return .ascending }<br>&gt;       if rhs &lt; lhs { return .descending }<br>&gt;       precondition(lhs == rhs)<br>&gt;       return .same<br>&gt;     }<br>&gt;<br>&gt; 7) Algorithms using &lt;=&gt; directly should mention so in their<br>&gt; documentation as a precondition that they require total order between<br>&gt; elements. Many generic algorithms can be defined in terms of == or &lt;,<br>&gt; and should.<br>&gt;<br>&gt; If we took the oroginally planned route that distinguished between<br>&gt; identities such as -0.0 vs. +0.0, or between the 2⁴⁹ - 2 ≈ 5.6 × 10¹⁴<br>&gt; possible NaN values that Double has, <br></p><p>I agree that our default ordering and equivalence tests should not<br>consider these differences to be essential/salient.<br></p><p>&gt; we&#39;d also need to consider other oddballs like the difference and<br>&gt; ordering between the Strings &quot;ä&quot; and &quot;a\u{308}&quot;, which are considered<br>&gt; equal but produce a different Unicode representation. I think it&#39;s<br>&gt; best to hide those identities behind another interface than Equatable<br>&gt; and Comparable, and let the protocols serve more mundane application<br>&gt; logic.<br>&gt;<br>&gt; — Pyry<br>&gt;<br>&gt;&gt; Dave Abrahams wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; on Sat Jul 23 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Fri, Jul 22, 2016 at 11:34 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The point of this design is that `===` means identity and that `.same `<br>&gt;&gt;&gt;&gt;&gt; also means identity.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Since this is new territory I suppose we get to decide what identity<br>&gt;&gt;&gt;&gt;&gt; means for floating point.  Should +0 and -0 have the same identity or<br>&gt;&gt;&gt;&gt;&gt; not?  I’ll leave the answer to folks more knowledgable about numerics<br>&gt;&gt;&gt;&gt;&gt; than I.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Boy, I take my wife out for a movie and come back to 50 new messages on SE.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I need to read the entire thread more carefully, but off the top of my<br>&gt;&gt;&gt;&gt; head, I think that `-0 === +0` is False.  If we’re going to have an<br>&gt;&gt;&gt;&gt; `isSame` / `isIdentical` / whatever it&#39;s called, I would expect it to imply<br>&gt;&gt;&gt;&gt; substitutability.  Although -0 == +0, they are not equivalent when<br>&gt;&gt;&gt;&gt; substituted:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - 1/(-0) != 1/0<br>&gt;&gt;&gt;&gt; - Float(-0).sign != Float(+0).sign<br>&gt;&gt;&gt;&gt; - etc<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This probably then implies that `&lt;=&gt;` is not `.same` either.  I’ll read<br>&gt;&gt;&gt;&gt; the rest of this and respond more completely tomorrow.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Eagerly await your evaluation of the discussion. In the meantime:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think Dave&#39;s view that `===` defines identity in terms of &quot;essential&quot;<br>&gt;&gt;&gt; qualities implies that two identical values can be<br>&gt;&gt;&gt; different/non-substitutable in &quot;inessential&quot; qualities. For generic<br>&gt;&gt;&gt; purposes, the sign of zero could be one such inessential quality.<br>&gt;&gt; <br>&gt;&gt; Yes, and I think our view of how people work with numbers in swift (and<br>&gt;&gt; their protocol conformances) reflect this approach.  <br>&gt;&gt; <br>&gt;&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/16321<br>&gt;&gt; <br>&gt;&gt; My sense is that we want to choose the default notions of identity and<br>&gt;&gt; ordering so as to support the way people think about these numeric<br>&gt;&gt; types, inexact though it may be.  Therefore, finding 0.0 in a sequence<br>&gt;&gt; of floats should succeed when the sequence contains -0.0, and a stable<br>&gt;&gt; sort on floating point keys should preserve the relative order of all<br>&gt;&gt; elements having +0.0 and -0.0 keys.  <br>&gt;&gt; <br>&gt;&gt; People that want to work with inessential qualities such as the sign of<br>&gt;&gt; zero can always pass Float.totalOrdering (or whatever) to their<br>&gt;&gt; closure-accepting algorithms.<br>&gt;&gt; <br>&gt;&gt; [In order to support the user model, we still need to fix the semantics<br>&gt;&gt; of the default identity and ordering operations so that things like<br>&gt;&gt; sorting and searching work, which is why == and &lt; won&#39;t cut it for these<br>&gt;&gt; purposes]<br>&gt;&gt; <br>&gt;&gt;&gt; On the other hand, the stdlib stride algorithm is going to be borked if -0<br>&gt;&gt;&gt; &lt; +0. Of course, as we already started to do there, we could specialize for<br>&gt;&gt;&gt; floating point and then adjust accordingly. However, it seems to me that<br>&gt;&gt;&gt; every generic algorithm that performs comparisons and can take floating<br>&gt;&gt;&gt; point arguments would have to be specialized to account for floating point<br>&gt;&gt;&gt; -0 != +0 (`index(of:)` being the previous example). This appears to defeat<br>&gt;&gt;&gt; the aim of trying to accommodate FP at all in this revised design for<br>&gt;&gt;&gt; Comparables.<br>&gt;&gt; <br>&gt;&gt; Yes, that would be a disaster, generically speaking.<br>&gt;&gt; <br>&gt;&gt;&gt; The argument for `-0 === +0` is that -0 and +0 should be equivalent when<br>&gt;&gt;&gt; substituted for every comparison operation. For FP operations, you&#39;d<br>&gt;&gt;&gt; continue to test (as you have to test now) `a == b &amp;&amp; a.sign == b.sign` if<br>&gt;&gt;&gt; you cared about the sign of zero. For non-FP arithmetic operations, hmm,<br>&gt;&gt;&gt; not sure how to square that circle.<br>&gt;&gt; <br>&gt;&gt; I followed all of this... except, what are you getting at with that<br>&gt; last<br>&gt;&gt; sentence?<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>July 24, 2016 at 08:00:00pm</p></header><div class="content"><p>Dave Abrahams wrote:<br></p><p>&gt;&gt; Given all this, I propose a simpler model that makes `a &lt;=&gt; b` follow<br>&gt;&gt; the expected behaviour of &lt; and ==, with the tradeoff that `a &lt;=&gt;<br>&gt;&gt; .nan` and `.nan &lt;=&gt; b` will abort with a precondition failure:<br>&gt; <br>&gt; This effectively makes it a precondition violation to default-sort<br>&gt; a sequence of floats that contains a NaN<br></p><p>Correct. I&#39;m still pondering if that could be alleviated in this model with minor modifications. Note however, that the proposed IEEE 754 total order would put negative NaNs at front and positive NaNs at the end. I can&#39;t say that&#39;s too useful either.<br></p><p>&gt; or even to ask whether<br>&gt; someSequence.contains(.nan).  IMO that&#39;s not really acceptable.<br></p><p>Not correct. Algorithms like contains(_:) or firstIndex(of:) would use the == operator which is part of the protocol and thus wouldn&#39;t call &lt;=&gt; on FloatingPoint types which override the default implementation.<br></p><p>— Pyry<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>July 24, 2016 at 08:00:00pm</p></header><div class="content"><p>Pyry Jahkola wrote:<br></p><p>&gt;&gt; or even to ask whether<br>&gt;&gt; someSequence.contains(.nan).  IMO that&#39;s not really acceptable.<br>&gt; <br>&gt; Not correct. Algorithms like contains(_:) or firstIndex(of:) would use the == operator which is part of the protocol and thus wouldn&#39;t call &lt;=&gt; on FloatingPoint types which override the default implementation.<br></p><p>Oops, spoke too soon. Well, I think it&#39;s easy enough to require people to write numbers.contains(where: { $0.isNaN }) in this use case.<br></p><p>— Pyry<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 24, 2016 at 01:00:00pm</p></header><div class="content"><p>Asking whether zero appears in a sequence that happened to contain a NaN would equally be a precondition violation. I don&#39;t think that&#39;s an acceptable cliff. The point of NaNs and Infs is that they flow through a multidimensional calculation without disturbing the parts that are still valid, rather than, e.g., <br>trapping. <br></p><p>Sent from my moss-covered three-handled family gradunza<br></p><p>&gt; On Jul 24, 2016, at 10:40 AM, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; wrote:<br>&gt; <br>&gt; Pyry Jahkola wrote:<br>&gt; <br>&gt;&gt;&gt; or even to ask whether<br>&gt;&gt;&gt; someSequence.contains(.nan).  IMO that&#39;s not really acceptable.<br>&gt;&gt; <br>&gt;&gt; Not correct. Algorithms like contains(_:) or firstIndex(of:) would use the == operator which is part of the protocol and thus wouldn&#39;t call &lt;=&gt; on FloatingPoint types which override the default implementation.<br>&gt; <br>&gt; Oops, spoke too soon. Well, I think it&#39;s easy enough to require people to write numbers.contains(where: { $0.isNaN }) in this use case.<br>&gt; <br>&gt; — Pyry<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>July 25, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Dave Abrahams wrote:<br>&gt; <br>&gt; Asking whether zero appears in a sequence that happened to contain a NaN would equally be a precondition violation.<br></p><p>No, it wouldn&#39;t because Double would implement Equatable + Comparable by providing custom implementations of ==, &lt;, &gt;, &lt;=, and &gt;=, in addition to Double.&lt;=&gt; which may trap.<br></p><p>My point in https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160718/025375.html is that by keeping all those operators within the required interface of protocol Comparable, such customisation remains possible. The original proposal only suggested == in Equatable and &lt;=&gt; in Comparable. If that were the case, then generic algorithms would necessarily end up calling &lt;=&gt;.<br></p><p>It is key that not only &lt;=&gt; is a customisation point of Comparable. Only those generic algorithms which used &lt;=&gt; directly (e.g. sort, partition, binary search) would see precondition violations if the sequence contained one or more NaNs.<br></p><p>***<br></p><p>Another possible choice would be to return .descending whenever either of the comparands were NaN, while also making &lt;, &gt;, &lt;=, and &gt;= return false in such cases. Then we wouldn&#39;t see preconditionFailures but instead produced bogus results from sort, partition etc. That&#39;s the tradeoff Haskell has chosen for its `compare` function over Double, FWIW.<br></p><p>— Pyry<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160725/1d207c55/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 24, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jul 24, 2016, at 9:06 PM, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Another possible choice would be to return .descending whenever either of the comparands were NaN, while also making &lt;, &gt;, &lt;=, and &gt;= return false in such cases. Then we wouldn&#39;t see preconditionFailures but instead produced bogus results from sort, partition etc. That&#39;s the tradeoff Haskell has chosen for its `compare` function over Double, FWIW.<br></p><p>That&#39;s essentially what we currently have. I think we&#39;d like to fix it.<br></p><p>Honestly, I think the most natural result is that calls like `sort()` and `max()` ignore NaNs—for instance, an Array&lt;Double&gt; might have fewer elements if you sort it. That seems to be the behavior implied by `FloatingPoint.maximum/minimum(_:_:)`. However, it is still possible to access and use the total ordering if you need it.<br></p><p>This sort of suggests we should have two levels of comparisons:<br></p><p>* `===` and `&lt;===&gt;` are total.<br></p><p>* `==` and `&lt;=&gt;` may not work on, or may conflate, some values.<br></p><p>How to actually accomplish this is a more difficult question. The simplest solution might be something like:<br></p><p>	protocol Equatable {<br>		static func === (…) -&gt; Bool<br>		static func == (…) -&gt; Bool<br>	}<br>	extension Equatable {<br>		static func == (…) -&gt; Bool {<br>			return lhs === rhs<br>		}<br>	}<br></p><p>	protocol Comparable: Equatable {<br>		/// Total ordering which works on and distinguishes between all values of the type.<br>		static func &lt;===&gt; (…) -&gt; Ordering<br>		<br>		/// &quot;Friendly&quot; ordering which may conflate or not work on some values of the type.<br>		/// <br>		/// - Precondition: Neither `lhs` nor `rhs` returns `true` from `isAberration`.<br>		static func &lt;=&gt; (…) -&gt; Ordering<br>		<br>		/// If true, this instance should be ignored when using the &lt;=&gt; operator.<br>		var isAberration: Bool { get }<br>	}<br>	extension Comparable {<br>		static func === (…) -&gt; Bool {<br>			return (lhs &lt;===&gt; rhs) == .same<br>		}<br>		static func == (…) -&gt; Bool {<br>			return (lhs &lt;=&gt; rhs) == .same<br>		}<br>		static func &lt;=&gt; (…) -&gt; Ordering {<br>			return lhs &lt;===&gt; rhs<br>		}<br>		var isAberration: Bool {<br>			return true<br>		}<br>	}<br></p><p>However, this means that sorting requires two functions, not one (or that, when using a custom sorting function, you must separately pre-filter the aberrations from your data set). An alternative would be to introduce a PartialOrdering type:<br></p><p><br>	enum PartialOrdering {<br>		case ordered (Ordering)<br>		case leftUnordered<br>		case bothUnordered<br>		case rightUnordered<br>	}<br>	// As above, except...<br>	protocol Comparable: Equatable {<br>		...<br>		<br>		/// &quot;Friendly&quot; ordering which may not work on some values of the type.<br>		/// <br>		/// - Precondition: Neither `lhs` nor `rhs` returns `true` from `isAberration`.<br>		static func &lt;=&gt; (…) -&gt; PartialOrdering<br>	}<br></p><p>This wouldn&#39;t necessarily handle the `-0.0 == +0.0` case well, though. That *could* be handled with extra cases meaning &quot;equal but ordered&quot;, but this is looking messier and messier.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 25, 2016 at 01:00:00am</p></header><div class="content"><p>On Mon, Jul 25, 2016 at 1:12 AM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; On Jul 24, 2016, at 9:06 PM, Pyry Jahkola via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Another possible choice would be to return .descending whenever either<br>&gt; of the comparands were NaN, while also making &lt;, &gt;, &lt;=, and &gt;= return false<br>&gt; in such cases. Then we wouldn&#39;t see preconditionFailures but instead<br>&gt; produced bogus results from sort, partition etc. That&#39;s the tradeoff<br>&gt; Haskell has chosen for its `compare` function over Double, FWIW.<br>&gt;<br>&gt; That&#39;s essentially what we currently have. I think we&#39;d like to fix it.<br>&gt;<br>&gt; Honestly, I think the most natural result is that calls like `sort()` and<br>&gt; `max()` ignore NaNs—for instance, an Array&lt;Double&gt; might have fewer<br>&gt; elements if you sort it. That seems to be the behavior implied by<br>&gt; `FloatingPoint.maximum/minimum(_:_:)`. However, it is still possible to<br>&gt; access and use the total ordering if you need it.<br>&gt;<br>&gt; This sort of suggests we should have two levels of comparisons:<br>&gt;<br>&gt; * `===` and `&lt;===&gt;` are total.<br>&gt;<br>&gt; * `==` and `&lt;=&gt;` may not work on, or may conflate, some values.<br>&gt;<br></p><p>Agreed very much. Although, any &quot;friendly&quot; `&lt;=&gt;` can be derived from what<br>you call `&lt;===&gt;` and `==`.<br></p><p>I&#39;ve been playing with a variation where I have a &quot;friendly&quot; equivalence<br>relation `==?` (returns `Bool?` so that it&#39;s `nil` when there&#39;s a argument<br>that doesn&#39;t make sense to compare) and a finer equivalence relation `===`<br>as protocol requirements on Equatable, with a generic `==` defined as `{<br>return (lhs ==? rhs) ?? (lhs === rhs) }`. In that model, traditional<br>comparison operators can be synthesized from a total ordering (which you<br>call `&lt;===&gt;` and the original proposal calls `&lt;=&gt;`) by first consulting the<br>value of the friendly `==?` to determine if two operands are the same.<br></p><p>How to actually accomplish this is a more difficult question. The simplest<br>&gt; solution might be something like:<br>&gt;<br>&gt;         protocol Equatable {<br>&gt;                 static func === (…) -&gt; Bool<br>&gt;                 static func == (…) -&gt; Bool<br>&gt;         }<br>&gt;         extension Equatable {<br>&gt;                 static func == (…) -&gt; Bool {<br>&gt;                         return lhs === rhs<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt;         protocol Comparable: Equatable {<br>&gt;                 /// Total ordering which works on and distinguishes<br>&gt; between all values of the type.<br>&gt;                 static func &lt;===&gt; (…) -&gt; Ordering<br>&gt;<br>&gt;                 /// &quot;Friendly&quot; ordering which may conflate or not work on<br>&gt; some values of the type.<br>&gt;                 ///<br>&gt;                 /// - Precondition: Neither `lhs` nor `rhs` returns `true`<br>&gt; from `isAberration`.<br>&gt;                 static func &lt;=&gt; (…) -&gt; Ordering<br>&gt;<br>&gt;                 /// If true, this instance should be ignored when using<br>&gt; the &lt;=&gt; operator.<br>&gt;                 var isAberration: Bool { get }<br>&gt;         }<br>&gt;         extension Comparable {<br>&gt;                 static func === (…) -&gt; Bool {<br>&gt;                         return (lhs &lt;===&gt; rhs) == .same<br>&gt;                 }<br>&gt;                 static func == (…) -&gt; Bool {<br>&gt;                         return (lhs &lt;=&gt; rhs) == .same<br>&gt;                 }<br>&gt;                 static func &lt;=&gt; (…) -&gt; Ordering {<br>&gt;                         return lhs &lt;===&gt; rhs<br>&gt;                 }<br>&gt;                 var isAberration: Bool {<br>&gt;                         return true<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt; However, this means that sorting requires two functions, not one (or that,<br>&gt; when using a custom sorting function, you must separately pre-filter the<br>&gt; aberrations from your data set). An alternative would be to introduce a<br>&gt; PartialOrdering type:<br>&gt;<br>&gt;<br>&gt;         enum PartialOrdering {<br>&gt;                 case ordered (Ordering)<br>&gt;                 case leftUnordered<br>&gt;                 case bothUnordered<br>&gt;                 case rightUnordered<br>&gt;         }<br>&gt;         // As above, except...<br>&gt;         protocol Comparable: Equatable {<br>&gt;                 ...<br>&gt;<br>&gt;                 /// &quot;Friendly&quot; ordering which may not work on some values<br>&gt; of the type.<br>&gt;                 ///<br>&gt;                 /// - Precondition: Neither `lhs` nor `rhs` returns `true`<br>&gt; from `isAberration`.<br>&gt;                 static func &lt;=&gt; (…) -&gt; PartialOrdering<br>&gt;         }<br>&gt;<br>&gt; This wouldn&#39;t necessarily handle the `-0.0 == +0.0` case well, though.<br>&gt; That *could* be handled with extra cases meaning &quot;equal but ordered&quot;, but<br>&gt; this is looking messier and messier.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160725/4805633a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 22, 2016 at 10:00:00pm</p></header><div class="content"><p>On Fri, Jul 22, 2016 at 9:57 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; on Fri Jul 22 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt; &gt; On Fri, Jul 22, 2016 at 9:46 PM, Dave Abrahams &lt;dabrahams at apple.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; on Fri Jul 22 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt; On Fri, Jul 22, 2016 at 9:23 PM, Matthew Johnson &lt;<br>&gt; matthew at anandabits.com<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; wrote:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; On Jul 22, 2016, at 9:17 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; On Fri, Jul 22, 2016 at 9:15 PM, Matthew Johnson via swift-evolution<br>&gt; &lt;<br>&gt; &gt;&gt; &gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; On Jul 22, 2016, at 9:04 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; &gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; on Fri Jul 22 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt;<br>&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; On Jul 22, 2016, at 8:37 PM, Xiaodi Wu via swift-evolution<br>&gt; &gt;&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; On Fri, Jul 22, 2016 at 8:20 PM, Dave Abrahams via swift-evolution<br>&gt; &gt;&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org<br>&gt; &gt;&gt; &gt;&gt;&gt; &lt;http://daniel-at-duan.org/&gt;&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution<br>&gt; &gt;&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt; &gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; on Fri Jul 22 2016, Daniel Duan<br>&gt; &gt;&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt; &gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt; &gt;&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt; &gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt; &gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt; &gt;&gt; &gt;&gt;&gt; think this is about identity.<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; It really *is* about identity as I posted in a previous message.<br>&gt; But<br>&gt; &gt;&gt; &gt;&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better<br>&gt; name.<br>&gt; &gt;&gt; &gt;&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no<br>&gt; real<br>&gt; &gt;&gt; &gt;&gt;&gt; benefit.<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t<br>&gt; &gt;&gt; &gt;&gt;&gt; consider<br>&gt; &gt;&gt; &gt;&gt;&gt; them part of their *identity*. I can follow this logic. My fear is<br>&gt; most<br>&gt; &gt;&gt; &gt;&gt;&gt; users<br>&gt; &gt;&gt; &gt;&gt;&gt; won’t make this leap on their own and get the same initial<br>&gt; impression<br>&gt; &gt;&gt; as<br>&gt; &gt;&gt; &gt;&gt;&gt; I did.<br>&gt; &gt;&gt; &gt;&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated<br>&gt; &gt;&gt; bikesheding<br>&gt; &gt;&gt; &gt;&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt; &gt;&gt; &gt;&gt;&gt; additional API surface implied by areSame, or wether we should<br>&gt; collapse<br>&gt; &gt;&gt; &gt;&gt;&gt; it with ===.<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; To spell this out (because I had to think about it for a second):<br>&gt; ===<br>&gt; &gt;&gt; &gt;&gt;&gt; will be derived from<br>&gt; &gt;&gt; &gt;&gt;&gt; &lt;=&gt;,<br>&gt; &gt;&gt; &gt;&gt;&gt; but also becomes default implementation for ==, which remains open<br>&gt; for<br>&gt; &gt;&gt; &gt;&gt;&gt; customization.<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; I was imagining roughly this (untested):<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;  /// Two references are identical if they refer to the same<br>&gt; &gt;&gt; &gt;&gt;&gt;  /// instance.<br>&gt; &gt;&gt; &gt;&gt;&gt;  ///<br>&gt; &gt;&gt; &gt;&gt;&gt;  /// - Note: Classes with a more-refined notion of “identical”<br>&gt; &gt;&gt; &gt;&gt;&gt;  ///   should conform to `Identifiable` and implement `===`.<br>&gt; &gt;&gt; &gt;&gt;&gt;  func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt; &gt;&gt; &gt;&gt;&gt;    ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt; &gt;&gt; &gt;&gt;&gt;  }<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;  /// Supports testing that two values of `Self` are identical<br>&gt; &gt;&gt; &gt;&gt;&gt;  ///<br>&gt; &gt;&gt; &gt;&gt;&gt;  /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt; &gt;&gt; &gt;&gt;&gt;  /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt; &gt;&gt; &gt;&gt;&gt;  /// type can document that specific observable characteristics<br>&gt; &gt;&gt; &gt;&gt;&gt;  /// (such as the `capacity` of an `Array`) are inessential and<br>&gt; &gt;&gt; &gt;&gt;&gt;  /// thus not to be considered as part of the interchangeability<br>&gt; &gt;&gt; &gt;&gt;&gt;  /// guarantee.<br>&gt; &gt;&gt; &gt;&gt;&gt;  ///<br>&gt; &gt;&gt; &gt;&gt;&gt;  /// - Requires: `===` induces an equivalence relation over<br>&gt; &gt;&gt; &gt;&gt;&gt;  ///   instances.<br>&gt; &gt;&gt; &gt;&gt;&gt;  /// - Note: conforming types will gain an `==` operator that<br>&gt; &gt;&gt; &gt;&gt;&gt;  ///   forwards to `===`.<br>&gt; &gt;&gt; &gt;&gt;&gt;  /// - Note: Types that require domain-specific `==`<br>&gt; &gt;&gt; &gt;&gt;&gt;  ///   implementations with different semantics (e.g. floating<br>&gt; &gt;&gt; &gt;&gt;&gt;  ///   point) should define a more-specific overload of `==`,<br>&gt; &gt;&gt; &gt;&gt;&gt;  ///   which will be used in contexts where the static type is<br>&gt; &gt;&gt; &gt;&gt;&gt;  ///   known to the compiler.<br>&gt; &gt;&gt; &gt;&gt;&gt;  /// - Note: Generic code should usually use `==` to compare<br>&gt; &gt;&gt; &gt;&gt;&gt;  ///   conforming instances; that will always dispatch to `===`<br>&gt; &gt;&gt; &gt;&gt;&gt;  ///   and will be unaffected by more specific overloads of<br>&gt; &gt;&gt; &gt;&gt;&gt;  ///   `==`.<br>&gt; &gt;&gt; &gt;&gt;&gt;  protocol Identifiable { // née Equatable name is negotiable<br>&gt; &gt;&gt; &gt;&gt;&gt;    func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt; &gt;&gt; &gt;&gt;&gt;  }<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;  /// Default definition of `==` for Identifiable types.<br>&gt; &gt;&gt; &gt;&gt;&gt;  func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt; &gt;&gt; &gt;&gt;&gt;    return lhs === rhs<br>&gt; &gt;&gt; &gt;&gt;&gt;  }<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;  /// Conforming types have a default total ordering.<br>&gt; &gt;&gt; &gt;&gt;&gt;  ///<br>&gt; &gt;&gt; &gt;&gt;&gt;  /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt; &gt;&gt; &gt;&gt;&gt;  /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt; &gt;&gt; &gt;&gt;&gt;  /// type can document that specific observable characteristics<br>&gt; &gt;&gt; &gt;&gt;&gt;  /// (such as the `capacity` of an `Array`) are inessential and<br>&gt; &gt;&gt; &gt;&gt;&gt;  /// thus not to be considered as part of the interchangeability<br>&gt; &gt;&gt; &gt;&gt;&gt;  /// guarantee.<br>&gt; &gt;&gt; &gt;&gt;&gt;  ///<br>&gt; &gt;&gt; &gt;&gt;&gt;  /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt; &gt;&gt; &gt;&gt;&gt;  ///   instances.<br>&gt; &gt;&gt; &gt;&gt;&gt;  /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt; &gt;&gt; &gt;&gt;&gt;  ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent`<br>&gt; &gt;&gt; &gt;&gt;&gt;  ///   iff `a === b`.<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same`<br>&gt; &gt;&gt; *but<br>&gt; &gt;&gt; &gt;&gt;&gt; not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the<br>&gt; &gt;&gt; sign<br>&gt; &gt;&gt; &gt;&gt;&gt; of zero (so +0 = −0)”.<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; The point of this design is that `===` means identity and that<br>&gt; `.same `<br>&gt; &gt;&gt; &gt;&gt;&gt; also means identity.<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; Since this is new territory I suppose we get to decide what identity<br>&gt; &gt;&gt; &gt;&gt;&gt; means for floating point.  Should +0 and -0 have the same identity<br>&gt; or<br>&gt; &gt;&gt; &gt;&gt;&gt; not?  I’ll leave the answer to folks more knowledgable about<br>&gt; numerics<br>&gt; &gt;&gt; &gt;&gt;&gt; than I.<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; It&#39;s settled law<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;<br>&gt; https://en.wikipedia.org/wiki/IEEE_floating_point#Total-ordering_predicate<br>&gt; &gt;&gt; &gt;&gt;&gt; :-)<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; Yes, assuming we want to define identity in terms of the IEEE<br>&gt; &gt;&gt; definition<br>&gt; &gt;&gt; &gt;&gt;&gt; of total ordering.<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; I see what you&#39;re saying here. That could work. Comparable `===` and<br>&gt; &gt;&gt; &gt;&gt; Equatable `&lt;=&gt;` could do its own thing, and FloatingPoint<br>&gt; &gt;&gt; &gt;&gt; `isTotallyOrdered(below:)` can preserve the IEEE definition of total<br>&gt; &gt;&gt; &gt;&gt; ordering<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; Actually, I was hinting at your argument that `===` true iff `&lt;=&gt;`<br>&gt; same<br>&gt; &gt;&gt; &gt;&gt; shouldn’t be a semantic requirement of the protocols.<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; This is another option, but I don’t think it’s going to fly.  It<br>&gt; seems<br>&gt; &gt;&gt; &gt;&gt; reasonable to assume that `&lt;=&gt;` will have IEEE semantics.  We will<br>&gt; trip<br>&gt; &gt;&gt; a<br>&gt; &gt;&gt; &gt;&gt; lot of people up if it doesn’t.  That’s a big reason we can’t<br>&gt; consider<br>&gt; &gt;&gt; &gt;&gt; changing floating point `==` to define an equivalence relation.<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; Actually, here I doubt it. The total ordering isn&#39;t exposed as part of<br>&gt; &gt;&gt; any<br>&gt; &gt;&gt; &gt; comparison operator defined in the IEEE spec. In fact, the total<br>&gt; ordering<br>&gt; &gt;&gt; &gt; wasn&#39;t introduced until a (fairly) recent IEEE revision, IIUC.<br>&gt; Breaking<br>&gt; &gt;&gt; &gt; `==` would definitely cause people to jump, but `&lt;=&gt;` needn&#39;t be the<br>&gt; IEEE<br>&gt; &gt;&gt; &gt; totalOrder predicate IMO.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Wait, I thought we were saying that `&lt;=&gt;` could be IEEE totalOrder, and<br>&gt; &gt;&gt; `===` could be like `==` but with well-behaved NaNs, so it&#39;s still an<br>&gt; &gt;&gt; equivalence relation, thus declaring the signedness of 0 to be<br>&gt; &gt;&gt; inessential.<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt; I was (that was the &quot;=== if but not iff &lt;=&gt;&quot; business above), then I<br>&gt; &gt; thought Matthew was saying something different and agreed with him.<br>&gt; &gt;<br>&gt; &gt; What I thought that Matthew thought was actually very insightful. He<br>&gt; didn&#39;t<br>&gt; &gt; actually think this, apparently, but: IEEE totalOrder does exactly what<br>&gt; it<br>&gt; &gt; says on the tin. But, it is not useful for any generic comparisons or (as<br>&gt; &gt; far as I&#39;m aware) any generic sorting algorithms. I cannot conceive of a<br>&gt; &gt; numeric algorithm or a generic algorithm that relies on two equal<br>&gt; floating<br>&gt; &gt; point values being ordered based on their binary representation. We<br>&gt; should<br>&gt; &gt; have some way of exposing totalOrder to a user of a BinaryFloatingPoint<br>&gt; &gt; type, but I don&#39;t know that it should be the basis for floating point<br>&gt; &gt; *identity* with respect to protocol conformance. It&#39;s explicitly *not*<br>&gt; what<br>&gt; &gt; IEEE recommends for comparison anyway.<br>&gt;<br>&gt; That makes sense.  Perhaps IEEE hasn&#39;t actually made a principled<br>&gt; decision about which aspects of floating point numbers are essential,<br>&gt; and we have to do it for them.<br>&gt;<br></p><p>I may have to walk back some comments. IEEE totalOrder rules should work<br>fine for &lt;=&gt; if we relax &quot;a === b iff (a &lt;=&gt; b) == .same&quot;, as it explicitly<br>states:<br></p><p>a) If x &lt; y, totalOrder(x, y) is true. [i.e. compares ascending]<br>b) If x &gt; y, totalOrder(x, y) is false. [i.e. does not compare ascending]<br></p><p>This is where Steve&#39;s expertise comes in. In either case, I think we might<br>have a solution for `===` behaving weirdly in generic algorithms.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/e174a93d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 22, 2016 at 07:00:00pm</p></header><div class="content"><p>on Fri Jul 22 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;&gt; On Jul 22, 2016, at 9:04 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Jul 22 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Jul 22, 2016, at 8:37 PM, Xiaodi Wu via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Fri, Jul 22, 2016 at 8:20 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org &lt;http://daniel-at-duan.org/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Fri Jul 22 2016, Daniel Duan<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think this is about identity.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better name.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; benefit.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t consider<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; them part of their *identity*. I can follow this logic. My fear is most users<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; won’t make this leap on their own and get the same initial impression as I did.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated bikesheding<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt;&gt;&gt;&gt;&gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt;&gt;&gt;&gt;&gt;&gt; it with ===.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To spell this out (because I had to think about it for a second): === will be derived from<br>&gt;&gt;&gt;&gt;&gt; &lt;=&gt;,<br>&gt;&gt;&gt;&gt;&gt; but also becomes default implementation for ==, which remains open for<br>&gt;&gt;&gt;&gt;&gt; customization.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I was imagining roughly this (untested):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  /// Two references are identical if they refer to the same<br>&gt;&gt;&gt;&gt;  /// instance.<br>&gt;&gt;&gt;&gt;  ///<br>&gt;&gt;&gt;&gt;  /// - Note: Classes with a more-refined notion of “identical”<br>&gt;&gt;&gt;&gt;  ///   should conform to `Identifiable` and implement `===`.<br>&gt;&gt;&gt;&gt;  func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt;&gt;&gt;&gt;    ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  /// Supports testing that two values of `Self` are identical<br>&gt;&gt;&gt;&gt;  ///<br>&gt;&gt;&gt;&gt;  /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt;&gt;&gt;&gt;  /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;&gt;&gt;  /// type can document that specific observable characteristics<br>&gt;&gt;&gt;&gt;  /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;&gt;&gt;  /// thus not to be considered as part of the interchangeability<br>&gt;&gt;&gt;&gt;  /// guarantee.<br>&gt;&gt;&gt;&gt;  ///<br>&gt;&gt;&gt;&gt;  /// - Requires: `===` induces an equivalence relation over<br>&gt;&gt;&gt;&gt;  ///   instances.<br>&gt;&gt;&gt;&gt;  /// - Note: conforming types will gain an `==` operator that<br>&gt;&gt;&gt;&gt;  ///   forwards to `===`.<br>&gt;&gt;&gt;&gt;  /// - Note: Types that require domain-specific `==`<br>&gt;&gt;&gt;&gt;  ///   implementations with different semantics (e.g. floating<br>&gt;&gt;&gt;&gt;  ///   point) should define a more-specific overload of `==`,<br>&gt;&gt;&gt;&gt;  ///   which will be used in contexts where the static type is<br>&gt;&gt;&gt;&gt;  ///   known to the compiler.<br>&gt;&gt;&gt;&gt;  /// - Note: Generic code should usually use `==` to compare<br>&gt;&gt;&gt;&gt;  ///   conforming instances; that will always dispatch to `===`<br>&gt;&gt;&gt;&gt;  ///   and will be unaffected by more specific overloads of<br>&gt;&gt;&gt;&gt;  ///   `==`.<br>&gt;&gt;&gt;&gt;  protocol Identifiable { // née Equatable name is negotiable<br>&gt;&gt;&gt;&gt;    func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  /// Default definition of `==` for Identifiable types.<br>&gt;&gt;&gt;&gt;  func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;&gt;&gt;    return lhs === rhs<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  /// Conforming types have a default total ordering.<br>&gt;&gt;&gt;&gt;  ///<br>&gt;&gt;&gt;&gt;  /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt;&gt;&gt;&gt;  /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;&gt;&gt;  /// type can document that specific observable characteristics<br>&gt;&gt;&gt;&gt;  /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;&gt;&gt;  /// thus not to be considered as part of the interchangeability<br>&gt;&gt;&gt;&gt;  /// guarantee.<br>&gt;&gt;&gt;&gt;  ///<br>&gt;&gt;&gt;&gt;  /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt;&gt;&gt;&gt;  ///   instances.<br>&gt;&gt;&gt;&gt;  /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt;&gt;&gt;&gt;  ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent`<br>&gt;&gt;&gt;&gt;  ///   iff `a === b`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same` *but not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the sign of zero (so +0 = −0)”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The point of this design is that `===` means identity and that `.same ` also means identity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since this is new territory I suppose we get to decide what identity<br>&gt;&gt;&gt; means for floating point.  Should +0 and -0 have the same identity or<br>&gt;&gt;&gt; not?  I’ll leave the answer to folks more knowledgable about numerics<br>&gt;&gt;&gt; than I.<br>&gt;&gt; <br>&gt;&gt; It&#39;s settled law <br>&gt;&gt; https://en.wikipedia.org/wiki/IEEE_floating_point#Total-ordering_predicate<br>&gt;&gt; &lt;https://en.wikipedia.org/wiki/IEEE_floating_point#Total-ordering_predicate&gt;<br>&gt;&gt; :-)<br>&gt;<br>&gt; Yes, assuming we want to define identity in terms of the IEEE definition of total ordering.<br></p><p>We do :-)<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  /// - Note: conforming types will gain `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`<br>&gt;&gt;&gt;&gt;  ///   operators defined in terms of `&lt;=&gt;`.<br>&gt;&gt;&gt;&gt;  /// - Note: Types that require domain-specific `&lt;`, etc.<br>&gt;&gt;&gt;&gt;  ///   implementations with different semantics (e.g. floating<br>&gt;&gt;&gt;&gt;  ///   point) should define more-specific overloads of those<br>&gt;&gt;&gt;&gt;  ///   operators, which will be used in contexts where the<br>&gt;&gt;&gt;&gt;  ///   static type is known to the compiler.<br>&gt;&gt;&gt;&gt;  /// - Note: Generic code can freely use `&lt;=&gt;` or the traditional<br>&gt;&gt;&gt;&gt;  ///   comparison operators to compare conforming instances;<br>&gt;&gt;&gt;&gt;  ///   the result will always be supplied by `&lt;=&gt;`<br>&gt;&gt;&gt;&gt;  ///   and will be unaffected by more specific overloads of<br>&gt;&gt;&gt;&gt;  ///   the other operators.<br>&gt;&gt;&gt;&gt;  protocol Comparable : Identifiable {<br>&gt;&gt;&gt;&gt;    func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  /// Default implementations of `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`.<br>&gt;&gt;&gt;&gt;  extension Comparable {<br>&gt;&gt;&gt;&gt;    static func &lt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;&gt;      return (lhs &lt;=&gt; rhs) == .ascending<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;    static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;&gt;      return (rhs &lt;=&gt; lhs) != .ascending<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;    static func &gt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;&gt;      return (lhs &lt;=&gt; rhs) == .descending<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;    static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;&gt;      return (rhs &lt;=&gt; lhs) != .descending<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I like this idea. If we keep === as a separate thing, now users have 3 “opportunities” to define<br>&gt;&gt;&gt;&gt;&gt; equality. The must be few, if any, use cases for this.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Would love to see if anyone on the list can give us an example. Otherwise we should make<br>&gt;&gt;&gt;&gt;&gt; areSame === again™!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel Duan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is nice. Is `areSame()` being proposed because static `==` is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the status quo and you&#39;re trying to make the point that `==` in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; future need not guarantee the same semantics?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Nit: I think the more common term in stdlib would be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `areEquivalent()`. Do you think `same` in that context (independent<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the word &quot;ordering&quot;) might erroneously suggest identity?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift Community,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposal to clean up the semantics of ordering relations in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; standard library.  We have a draft that you can get as a gist.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any feedback you might have about this proposal helps - though<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; please keeps your comments on Swift-Evolution and not on the gist.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 22, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jul 22, 2016, at 9:24 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Jul 22 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jul 22, 2016, at 9:04 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Fri Jul 22 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 22, 2016, at 8:37 PM, Xiaodi Wu via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Fri, Jul 22, 2016 at 8:20 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Fri Jul 22 2016, Daniel Duan &lt;daniel-AT-duan.org &lt;http://daniel-at-duan.org/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 22, 2016, at 3:00 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Fri Jul 22 2016, Daniel Duan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 22, 2016, at 11:05 AM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Thu Jul 21 2016, Duan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Great proposal. I want to second that areSame may mislead user to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think this is about identity.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like areEquivalent() but there may be better names.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It really *is* about identity as I posted in a previous message.  But<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that doesn&#39;t change the fact that areEquivalent might be a better name.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s one of the things we considered; it just seemed long for no real<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; benefit.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If the addresses of the arguments aren’t being used, then we don’t consider<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; them part of their *identity*. I can follow this logic. My fear is most users<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; won’t make this leap on their own and get the same initial impression as I did.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s entirely possible this fear is unfounded. Some educated bikesheding<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wouldn&#39;t hurt here IMO :)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Well, it&#39;s still a very real question whether we ought to have the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; additional API surface implied by areSame, or wether we should collapse<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; it with ===.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; To spell this out (because I had to think about it for a second): === will be derived from<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;=&gt;,<br>&gt;&gt;&gt;&gt;&gt;&gt; but also becomes default implementation for ==, which remains open for<br>&gt;&gt;&gt;&gt;&gt;&gt; customization.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I was imagining roughly this (untested):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; /// Two references are identical if they refer to the same<br>&gt;&gt;&gt;&gt;&gt; /// instance.<br>&gt;&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt;&gt; /// - Note: Classes with a more-refined notion of “identical”<br>&gt;&gt;&gt;&gt;&gt; ///   should conform to `Identifiable` and implement `===`.<br>&gt;&gt;&gt;&gt;&gt; func ===(lhs: AnyObject, rhs: AnyObject) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt;   ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; /// Supports testing that two values of `Self` are identical<br>&gt;&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt;&gt; /// If `a` and `b` are of type `Self`, `a === b` means that<br>&gt;&gt;&gt;&gt;&gt; /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;&gt;&gt;&gt; /// type can document that specific observable characteristics<br>&gt;&gt;&gt;&gt;&gt; /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;&gt;&gt;&gt; /// thus not to be considered as part of the interchangeability<br>&gt;&gt;&gt;&gt;&gt; /// guarantee.<br>&gt;&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt;&gt; /// - Requires: `===` induces an equivalence relation over<br>&gt;&gt;&gt;&gt;&gt; ///   instances.<br>&gt;&gt;&gt;&gt;&gt; /// - Note: conforming types will gain an `==` operator that<br>&gt;&gt;&gt;&gt;&gt; ///   forwards to `===`.<br>&gt;&gt;&gt;&gt;&gt; /// - Note: Types that require domain-specific `==`<br>&gt;&gt;&gt;&gt;&gt; ///   implementations with different semantics (e.g. floating<br>&gt;&gt;&gt;&gt;&gt; ///   point) should define a more-specific overload of `==`,<br>&gt;&gt;&gt;&gt;&gt; ///   which will be used in contexts where the static type is<br>&gt;&gt;&gt;&gt;&gt; ///   known to the compiler.<br>&gt;&gt;&gt;&gt;&gt; /// - Note: Generic code should usually use `==` to compare<br>&gt;&gt;&gt;&gt;&gt; ///   conforming instances; that will always dispatch to `===`<br>&gt;&gt;&gt;&gt;&gt; ///   and will be unaffected by more specific overloads of<br>&gt;&gt;&gt;&gt;&gt; ///   `==`.<br>&gt;&gt;&gt;&gt;&gt; protocol Identifiable { // née Equatable name is negotiable<br>&gt;&gt;&gt;&gt;&gt;   func ===(_: Self, _: aSelf) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; /// Default definition of `==` for Identifiable types.<br>&gt;&gt;&gt;&gt;&gt; func ==&lt;T: Identifiable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt;   return lhs === rhs<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; /// Conforming types have a default total ordering.<br>&gt;&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt;&gt; /// If `a` and `b` are of type `Self`, `a &lt;=&gt; b` means that<br>&gt;&gt;&gt;&gt;&gt; /// `a` and `b` are interchangeable in most code.  A conforming<br>&gt;&gt;&gt;&gt;&gt; /// type can document that specific observable characteristics<br>&gt;&gt;&gt;&gt;&gt; /// (such as the `capacity` of an `Array`) are inessential and<br>&gt;&gt;&gt;&gt;&gt; /// thus not to be considered as part of the interchangeability<br>&gt;&gt;&gt;&gt;&gt; /// guarantee.<br>&gt;&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt;&gt; /// - Requires: `&lt;=&gt;` induces a total ordering over<br>&gt;&gt;&gt;&gt;&gt; ///   instances.<br>&gt;&gt;&gt;&gt;&gt; /// - Requires: the semantics of `&lt;=&gt;` are  consistent with<br>&gt;&gt;&gt;&gt;&gt; ///   those of `===`.  That is, `(a &lt;=&gt; b) == .equivalent`<br>&gt;&gt;&gt;&gt;&gt; ///   iff `a === b`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For floating point, I&#39;d hope that `a === b` if `(a &lt;=&gt; b) == .same` *but not iff*. This is to satisfy IEEE 754: &quot;Comparisons shall ignore the sign of zero (so +0 = −0)”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The point of this design is that `===` means identity and that `.same ` also means identity.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since this is new territory I suppose we get to decide what identity<br>&gt;&gt;&gt;&gt; means for floating point.  Should +0 and -0 have the same identity or<br>&gt;&gt;&gt;&gt; not?  I’ll leave the answer to folks more knowledgable about numerics<br>&gt;&gt;&gt;&gt; than I.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s settled law <br>&gt;&gt;&gt; https://en.wikipedia.org/wiki/IEEE_floating_point#Total-ordering_predicate<br>&gt;&gt;&gt; &lt;https://en.wikipedia.org/wiki/IEEE_floating_point#Total-ordering_predicate&gt;<br>&gt;&gt;&gt; :-)<br>&gt;&gt; <br>&gt;&gt; Yes, assuming we want to define identity in terms of the IEEE definition of total ordering.<br>&gt; <br>&gt; We do :-)<br></p><p>Yes, that is the sensible thing to do.  I was alluding to the argument Xiaodi is making.  :)<br></p><p>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; /// - Note: conforming types will gain `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`<br>&gt;&gt;&gt;&gt;&gt; ///   operators defined in terms of `&lt;=&gt;`.<br>&gt;&gt;&gt;&gt;&gt; /// - Note: Types that require domain-specific `&lt;`, etc.<br>&gt;&gt;&gt;&gt;&gt; ///   implementations with different semantics (e.g. floating<br>&gt;&gt;&gt;&gt;&gt; ///   point) should define more-specific overloads of those<br>&gt;&gt;&gt;&gt;&gt; ///   operators, which will be used in contexts where the<br>&gt;&gt;&gt;&gt;&gt; ///   static type is known to the compiler.<br>&gt;&gt;&gt;&gt;&gt; /// - Note: Generic code can freely use `&lt;=&gt;` or the traditional<br>&gt;&gt;&gt;&gt;&gt; ///   comparison operators to compare conforming instances;<br>&gt;&gt;&gt;&gt;&gt; ///   the result will always be supplied by `&lt;=&gt;`<br>&gt;&gt;&gt;&gt;&gt; ///   and will be unaffected by more specific overloads of<br>&gt;&gt;&gt;&gt;&gt; ///   the other operators.<br>&gt;&gt;&gt;&gt;&gt; protocol Comparable : Identifiable {<br>&gt;&gt;&gt;&gt;&gt;   func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; /// Default implementations of `&lt;`, `&lt;=`, `&gt;`, and `&gt;=`.<br>&gt;&gt;&gt;&gt;&gt; extension Comparable {<br>&gt;&gt;&gt;&gt;&gt;   static func &lt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt;     return (lhs &lt;=&gt; rhs) == .ascending<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   static func &lt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt;     return (rhs &lt;=&gt; lhs) != .ascending<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   static func &gt;(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt;     return (lhs &lt;=&gt; rhs) == .descending<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   static func &gt;=(lhs: Self, rhs: Self) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt;     return (rhs &lt;=&gt; lhs) != .descending<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I like this idea. If we keep === as a separate thing, now users have 3 “opportunities” to define<br>&gt;&gt;&gt;&gt;&gt;&gt; equality. The must be few, if any, use cases for this.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Would love to see if anyone on the list can give us an example. Otherwise we should make<br>&gt;&gt;&gt;&gt;&gt;&gt; areSame === again™!<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel Duan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:32 PM, Robert Widmann via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 6:19 PM, Xiaodi Wu<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is nice. Is `areSame()` being proposed because static `==` is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the status quo and you&#39;re trying to make the point that `==` in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; future need not guarantee the same semantics?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yep!  Equivalence and equality are strictly very different things.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Nit: I think the more common term in stdlib would be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `areEquivalent()`. Do you think `same` in that context (independent<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the word &quot;ordering&quot;) might erroneously suggest identity?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There is room for improvement here.  Keep ‘em coming.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jul 21, 2016 at 8:11 PM, Robert Widmann via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift Community,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposal to clean up the semantics of ordering relations in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; standard library.  We have a draft that you can get as a gist.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any feedback you might have about this proposal helps - though<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; please keeps your comments on Swift-Evolution and not on the gist.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; -- <br>&gt; Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
