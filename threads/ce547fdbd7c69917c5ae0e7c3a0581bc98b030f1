<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Resolving operator precedence conflicts</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>March  8, 2016 at 11:00:00pm</p></header><div class="content"><p>There have been complaints on current syntax of operator declarations:<br></p><p>infix operator &lt;&gt; { associativity left precedence 100 assignment }<br></p><p>It looks like a collection of random words. Dictionary syntax would suit<br>better here. Additionally, `assignment` has been deprecated for a long<br>time, but not removed.<br></p><p>Many syntaxes were suggested. For example:<br></p><p>#operator(&lt;&gt;, fixity: infix, associativity: left, precedence: 100)<br></p><p>*But* Joe Groff uncovered a deeper problem. Current operators cannot be<br>given precedence and associativity per concrete operator function.<br></p><p>Moreover, it makes more sense for operators to only allow parenthesis<br>omission for some other operators. (C/C++ gives warnings for relying on<br>precedence for unrelated operators.)<br></p><p>Operator declarations may lie in different modules and not know anything<br>about each other, but they will create a conflict if their names happen to<br>be identical.<br></p><p>The following is my attempt at solving the problem.<br></p><p>1.<br>All operators are aliases for functions.<br></p><p>#operator(+, name: numericAdd, fixity: infix, associativity: left)<br></p><p>func numericAdd(left: Int, _ right: Int) -&gt; Int<br></p><p>#operator(+, name: numericUnaryPlus, fixity: prefix)<br></p><p>func unaryPlus(right: Int) -&gt; Int<br></p><p>+1 + 2  // same as numericAdd(numericUnaryPlus(1), 2)<br></p><p>2.<br>Operators with same &quot;operator form&quot; use overloading, modified to accomodate<br>associativity and precedence.<br></p><p>#operator(+, name: append, fixity: infix)<br></p><p>func append&lt;T&gt;(left: [T], right: T) -&gt; [T]<br></p><p>var arr = [1, 2, 3]<br>1 + 2 + 3  //=&gt; 6<br>[1, 2] + 3  //=&gt; 1 2 3<br>[1, 2] + 3 + 4  // error<br></p><p>Compiler must try to apply rules of both `numericAdd` and `append` in all<br>combinations. Complexity of this should not be exponential: most branches<br>will be cut off fast, starting from the inside.<br></p><p>In 1 + 2 + 3, `append` cannot be applied both to 1+2 and to 2+3, so we are<br>left with `numericAdd`.<br>In [1,2] + 3 + 4, `numericAdd` cannot be applied to [1,2] + 3, and `append`<br>cannot be applied to 3 + 4. But if we assume `append` and `numericAdd`,<br>then no precedence rule is defined between `numericAdd` and `append`.<br></p><p>Overall, algorithm for compiler is to be developed.<br></p><p>3.<br>Operators can define precedence (omission of parentheses), only compared to<br>other specific operators.<br></p><p>#precedence(append, lessThan: numericAdd)<br></p><p>#precedence(numericAdd, equalTo: numericSubtract)<br></p><p>4.<br>Precedence applies to unary operators as well:<br></p><p>let v: Bool? = false<br>let u = !v!  // error, precedence between logicalNot and forceUnwrap is not<br>defined<br></p><p>#precedence(forceUnwrap, greaterThan: logicalNot)<br></p><p>let u = !v!  // true<br></p><p>That said, precedence of unary operators is always higher than of any<br>binary operator.<br></p><p>- Anton<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/ce5430f1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Draft] Resolving operator precedence conflicts</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>March  8, 2016 at 12:00:00pm</p></header><div class="content"><p>I agree that operator syntax needs to be reworked, but I prefer that<br>whatever proposal ends up being accepted not abuse the word &#39;fixity&#39; to<br>mean something it doesn&#39;t.<br></p><p>On Tue, Mar 8, 2016 at 12:13 PM, Антон Жилин &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; There have been complaints on current syntax of operator declarations:<br>&gt;<br>&gt; infix operator &lt;&gt; { associativity left precedence 100 assignment }<br>&gt;<br>&gt; It looks like a collection of random words. Dictionary syntax would suit<br>&gt; better here. Additionally, `assignment` has been deprecated for a long<br>&gt; time, but not removed.<br>&gt;<br>&gt; Many syntaxes were suggested. For example:<br>&gt;<br>&gt; #operator(&lt;&gt;, fixity: infix, associativity: left, precedence: 100)<br>&gt;<br>&gt; *But* Joe Groff uncovered a deeper problem. Current operators cannot be<br>&gt; given precedence and associativity per concrete operator function.<br>&gt;<br>&gt; Moreover, it makes more sense for operators to only allow parenthesis<br>&gt; omission for some other operators. (C/C++ gives warnings for relying on<br>&gt; precedence for unrelated operators.)<br>&gt;<br>&gt; Operator declarations may lie in different modules and not know anything<br>&gt; about each other, but they will create a conflict if their names happen to<br>&gt; be identical.<br>&gt;<br>&gt; The following is my attempt at solving the problem.<br>&gt;<br>&gt; 1.<br>&gt; All operators are aliases for functions.<br>&gt;<br>&gt; #operator(+, name: numericAdd, fixity: infix, associativity: left)<br>&gt;<br>&gt; func numericAdd(left: Int, _ right: Int) -&gt; Int<br>&gt;<br>&gt; #operator(+, name: numericUnaryPlus, fixity: prefix)<br>&gt;<br>&gt; func unaryPlus(right: Int) -&gt; Int<br>&gt;<br>&gt; +1 + 2  // same as numericAdd(numericUnaryPlus(1), 2)<br>&gt;<br>&gt; 2.<br>&gt; Operators with same &quot;operator form&quot; use overloading, modified to<br>&gt; accomodate associativity and precedence.<br>&gt;<br>&gt; #operator(+, name: append, fixity: infix)<br>&gt;<br>&gt; func append&lt;T&gt;(left: [T], right: T) -&gt; [T]<br>&gt;<br>&gt; var arr = [1, 2, 3]<br>&gt; 1 + 2 + 3  //=&gt; 6<br>&gt; [1, 2] + 3  //=&gt; 1 2 3<br>&gt; [1, 2] + 3 + 4  // error<br>&gt;<br>&gt; Compiler must try to apply rules of both `numericAdd` and `append` in all<br>&gt; combinations. Complexity of this should not be exponential: most branches<br>&gt; will be cut off fast, starting from the inside.<br>&gt;<br>&gt; In 1 + 2 + 3, `append` cannot be applied both to 1+2 and to 2+3, so we are<br>&gt; left with `numericAdd`.<br>&gt; In [1,2] + 3 + 4, `numericAdd` cannot be applied to [1,2] + 3, and<br>&gt; `append` cannot be applied to 3 + 4. But if we assume `append` and<br>&gt; `numericAdd`, then no precedence rule is defined between `numericAdd` and<br>&gt; `append`.<br>&gt;<br>&gt; Overall, algorithm for compiler is to be developed.<br>&gt;<br>&gt; 3.<br>&gt; Operators can define precedence (omission of parentheses), only compared<br>&gt; to other specific operators.<br>&gt;<br>&gt; #precedence(append, lessThan: numericAdd)<br>&gt;<br>&gt; #precedence(numericAdd, equalTo: numericSubtract)<br>&gt;<br>&gt; 4.<br>&gt; Precedence applies to unary operators as well:<br>&gt;<br>&gt; let v: Bool? = false<br>&gt; let u = !v!  // error, precedence between logicalNot and forceUnwrap is<br>&gt; not defined<br>&gt;<br>&gt; #precedence(forceUnwrap, greaterThan: logicalNot)<br>&gt;<br>&gt; let u = !v!  // true<br>&gt;<br>&gt; That said, precedence of unary operators is always higher than of any<br>&gt; binary operator.<br>&gt;<br>&gt; - Anton<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/8c781c1d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>[Draft] Resolving operator precedence conflicts</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>March  8, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Mar 8, 2016, at 12:33 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree that operator syntax needs to be reworked, but I prefer that whatever proposal ends up being accepted not abuse the word &#39;fixity&#39; to mean something it doesn’t.<br></p><p>I can’t say with certainty whether “fixity” is cromulent or incromulent ;-), but how about: “position” or “placement”?<br></p><p>&gt; <br>&gt; On Tue, Mar 8, 2016 at 12:13 PM, Антон Жилин &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; There have been complaints on current syntax of operator declarations:<br>&gt; <br>&gt; infix operator &lt;&gt; { associativity left precedence 100 assignment }<br>&gt; <br>&gt; It looks like a collection of random words. Dictionary syntax would suit better here. Additionally, `assignment` has been deprecated for a long time, but not removed.<br>&gt; <br>&gt; Many syntaxes were suggested. For example:<br>&gt; <br>&gt; #operator(&lt;&gt;, fixity: infix, associativity: left, precedence: 100)<br>&gt; <br>&gt; *But* Joe Groff uncovered a deeper problem. Current operators cannot be given precedence and associativity per concrete operator function.<br>&gt; <br>&gt; Moreover, it makes more sense for operators to only allow parenthesis omission for some other operators. (C/C++ gives warnings for relying on precedence for unrelated operators.) <br>&gt; <br>&gt; Operator declarations may lie in different modules and not know anything about each other, but they will create a conflict if their names happen to be identical.<br>&gt; <br>&gt; The following is my attempt at solving the problem.<br>&gt; <br>&gt; 1.<br>&gt; All operators are aliases for functions.<br>&gt; <br>&gt; #operator(+, name: numericAdd, fixity: infix, associativity: left)<br>&gt; <br>&gt; func numericAdd(left: Int, _ right: Int) -&gt; Int<br>&gt; <br>&gt; #operator(+, name: numericUnaryPlus, fixity: prefix)<br>&gt; <br>&gt; func unaryPlus(right: Int) -&gt; Int<br>&gt; <br>&gt; +1 + 2  // same as numericAdd(numericUnaryPlus(1), 2)<br>&gt; <br>&gt; 2.<br>&gt; Operators with same &quot;operator form&quot; use overloading, modified to accomodate associativity and precedence.<br>&gt; <br>&gt; #operator(+, name: append, fixity: infix)<br>&gt; <br>&gt; func append&lt;T&gt;(left: [T], right: T) -&gt; [T]<br>&gt; <br>&gt; var arr = [1, 2, 3]<br>&gt; 1 + 2 + 3  //=&gt; 6<br>&gt; [1, 2] + 3  //=&gt; 1 2 3<br>&gt; [1, 2] + 3 + 4  // error<br>&gt; <br>&gt; Compiler must try to apply rules of both `numericAdd` and `append` in all combinations. Complexity of this should not be exponential: most branches will be cut off fast, starting from the inside.<br>&gt; <br>&gt; In 1 + 2 + 3, `append` cannot be applied both to 1+2 and to 2+3, so we are left with `numericAdd`.<br>&gt; In [1,2] + 3 + 4, `numericAdd` cannot be applied to [1,2] + 3, and `append` cannot be applied to 3 + 4. But if we assume `append` and `numericAdd`, then no precedence rule is defined between `numericAdd` and `append`.<br>&gt; <br>&gt; Overall, algorithm for compiler is to be developed.<br>&gt; <br>&gt; 3.<br>&gt; Operators can define precedence (omission of parentheses), only compared to other specific operators.<br>&gt; <br>&gt; #precedence(append, lessThan: numericAdd)<br>&gt; <br>&gt; #precedence(numericAdd, equalTo: numericSubtract)<br>&gt; <br>&gt; 4.<br>&gt; Precedence applies to unary operators as well:<br>&gt; <br>&gt; let v: Bool? = false<br>&gt; let u = !v!  // error, precedence between logicalNot and forceUnwrap is not defined<br>&gt; <br>&gt; #precedence(forceUnwrap, greaterThan: logicalNot)<br>&gt; <br>&gt; let u = !v!  // true<br>&gt; <br>&gt; That said, precedence of unary operators is always higher than of any binary operator.<br>&gt; <br>&gt; - Anton<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/0f3a59c0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Draft] Resolving operator precedence conflicts</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March  8, 2016 at 02:00:00pm</p></header><div class="content"><p>cite The Swift Programming Language (Swift 2.2)<br></p><p>http://imgur.com/sFPhPxz &lt;http://imgur.com/sFPhPxz&gt;<br></p><p>-- E<br></p><p><br>&gt; On Mar 8, 2016, at 2:42 PM, Charles Kissinger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 8, 2016, at 12:33 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I agree that operator syntax needs to be reworked, but I prefer that whatever proposal ends up being accepted not abuse the word &#39;fixity&#39; to mean something it doesn’t.<br>&gt; <br>&gt; I can’t say with certainty whether “fixity” is cromulent or incromulent ;-), but how about: “position” or “placement”?<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/aaadbacb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Draft] Resolving operator precedence conflicts</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>March  8, 2016 at 01:00:00pm</p></header><div class="content"><p>&#39;Fixity&#39; already has a non-technical meaning (&quot;the state of being unchanged<br>and permanent&quot;), and an unrelated technical one (a synonym for<br>associativity; search &quot;assocativity fixity operator&quot; for examples). If<br>we&#39;re using it in this different way, I respectfully submit that we should<br>reconsider.<br></p><p>Best,<br>Austin<br></p><p>On Tue, Mar 8, 2016 at 1:48 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt; cite The Swift Programming Language (Swift 2.2)<br>&gt;<br>&gt; http://imgur.com/sFPhPxz<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; On Mar 8, 2016, at 2:42 PM, Charles Kissinger via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Mar 8, 2016, at 12:33 PM, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I agree that operator syntax needs to be reworked, but I prefer that<br>&gt; whatever proposal ends up being accepted not abuse the word &#39;fixity&#39; to<br>&gt; mean something it doesn’t.<br>&gt;<br>&gt;<br>&gt; I can’t say with certainty whether “fixity” is cromulent or incromulent<br>&gt; ;-), but how about: “position” or “placement”?<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/827002ed/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>[Draft] Resolving operator precedence conflicts</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>March  9, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 8, 2016, at 1:52 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; &#39;Fixity&#39; already has a non-technical meaning (&quot;the state of being unchanged and permanent&quot;), and an unrelated technical one (a synonym for associativity; search &quot;assocativity fixity operator&quot; for examples). If we&#39;re using it in this different way, I respectfully submit that we should reconsider.<br></p><p>You are correct, of course, but a subset of computer scientists have been abusing the term in this way for at least a couple of decades. Their novel usage of “fixity” now has a degree of fixity, so it may be too late to fix &quot;fixity&quot;.<br></p><p>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; On Tue, Mar 8, 2016 at 1:48 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt; cite The Swift Programming Language (Swift 2.2)<br>&gt; <br>&gt; http://imgur.com/sFPhPxz &lt;http://imgur.com/sFPhPxz&gt;<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 8, 2016, at 2:42 PM, Charles Kissinger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mar 8, 2016, at 12:33 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that operator syntax needs to be reworked, but I prefer that whatever proposal ends up being accepted not abuse the word &#39;fixity&#39; to mean something it doesn’t.<br>&gt;&gt; <br>&gt;&gt; I can’t say with certainty whether “fixity” is cromulent or incromulent ;-), but how about: “position” or “placement”?<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/28d86560/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Draft] Resolving operator precedence conflicts</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March  9, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Mar 9, 2016, at 12:10 PM, Charles Kissinger &lt;crk at akkyra.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 8, 2016, at 1:52 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &#39;Fixity&#39; already has a non-technical meaning (&quot;the state of being unchanged and permanent&quot;), and an unrelated technical one (a synonym for associativity; search &quot;assocativity fixity operator&quot; for examples). If we&#39;re using it in this different way, I respectfully submit that we should reconsider.<br>&gt; <br>&gt; You are correct, of course, but a subset of computer scientists have been abusing the term in this way for at least a couple of decades. Their novel usage of “fixity” now has a degree of fixity, so it may be too late to fix &quot;fixity&quot;.<br></p><p>It&#39;s become a termity of art.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/711d9fb2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Draft] Resolving operator precedence conflicts</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>March  9, 2016 at 01:00:00pm</p></header><div class="content"><p>Isn’t this essentially describing it’s expression-ness? Why not just use “expression” like:<br></p><p>expression: infix<br>expression: postfix<br>expression: prefix<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Mar 9, 2016, at 1:12 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 9, 2016, at 12:10 PM, Charles Kissinger &lt;crk at akkyra.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 8, 2016, at 1:52 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &#39;Fixity&#39; already has a non-technical meaning (&quot;the state of being unchanged and permanent&quot;), and an unrelated technical one (a synonym for associativity; search &quot;assocativity fixity operator&quot; for examples). If we&#39;re using it in this different way, I respectfully submit that we should reconsider.<br>&gt;&gt; <br>&gt;&gt; You are correct, of course, but a subset of computer scientists have been abusing the term in this way for at least a couple of decades. Their novel usage of “fixity” now has a degree of fixity, so it may be too late to fix &quot;fixity&quot;.<br>&gt; <br>&gt; It&#39;s become a termity of art.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Draft] Resolving operator precedence conflicts</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March  9, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Mar 9, 2016, at 11:15 AM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Isn’t this essentially describing it’s expression-ness? Why not just use “expression” like:<br>&gt; <br>&gt; expression: infix<br>&gt; expression: postfix<br>&gt; expression: prefix<br></p><p>Are any of these proposals *better* than “infix operator + {“ ?<br></p><p>I’m not claiming that the body of the operator declaration is great, but one nice thing about it is that the required terms are part of the decl modifier, the optional gunk is in the body, and it reads well.<br></p><p>-Chris<br></p><p><br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 9, 2016, at 1:12 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 9, 2016, at 12:10 PM, Charles Kissinger &lt;crk at akkyra.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 8, 2016, at 1:52 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &#39;Fixity&#39; already has a non-technical meaning (&quot;the state of being unchanged and permanent&quot;), and an unrelated technical one (a synonym for associativity; search &quot;assocativity fixity operator&quot; for examples). If we&#39;re using it in this different way, I respectfully submit that we should reconsider.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You are correct, of course, but a subset of computer scientists have been abusing the term in this way for at least a couple of decades. Their novel usage of “fixity” now has a degree of fixity, so it may be too late to fix &quot;fixity&quot;.<br>&gt;&gt; <br>&gt;&gt; It&#39;s become a termity of art.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Resolving operator precedence conflicts</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>March 10, 2016 at 03:00:00pm</p></header><div class="content"><p>TLDR: Previous draft did not carry the idea well, I will rewrite it.<br></p><p>In my original post, I didn&#39;t intend to make an accent on syntax. I mainly<br>tried to rework how operator precedence works.<br></p><p>Consider following example.<br>Module A defines operator |&gt; that acts on Stream, is left-associative and<br>has precedence rules X.<br>Module B defines operator |&gt; that acts on Serializable, is<br>right-associative and has precedence rules Y.<br></p><p>A and B don&#39;t know anything about each other.<br>Without the proposal, definitions of |&gt; would be in conflict.<br>With the proposal, there would be no conflict for |&gt;. They would<br>define different operators with different precedence rules and<br>associativity.<br></p><p>In expression a + b + c, first and second + would have different precedence<br>and associativity, depending on #operator directives, types of a,b,c and<br>available perator functions.<br></p><p>Now I think that probably, having conflicts in operator definitions is<br>better than to have complex compiler rules for parsing expressions as<br>simple as a + b + c.<br></p><p>- Anton<br></p><p>четверг, 10 марта 2016 г. пользователь Chris Lattner написал:<br></p><p>&gt;<br>&gt; &gt; On Mar 9, 2016, at 11:15 AM, Sean Heber via swift-evolution &lt;<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Isn’t this essentially describing it’s expression-ness? Why not just use<br>&gt; “expression” like:<br>&gt; &gt;<br>&gt; &gt; expression: infix<br>&gt; &gt; expression: postfix<br>&gt; &gt; expression: prefix<br>&gt;<br>&gt; Are any of these proposals *better* than “infix operator + {“ ?<br>&gt;<br>&gt; I’m not claiming that the body of the operator declaration is great, but<br>&gt; one nice thing about it is that the required terms are part of the decl<br>&gt; modifier, the optional gunk is in the body, and it reads well.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; &gt;<br>&gt; &gt; l8r<br>&gt; &gt; Sean<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Mar 9, 2016, at 1:12 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Mar 9, 2016, at 12:10 PM, Charles Kissinger &lt;crk at akkyra.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On Mar 8, 2016, at 1:52 PM, Austin Zheng &lt;austinzheng at gmail.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; &#39;Fixity&#39; already has a non-technical meaning (&quot;the state of being<br>&gt; unchanged and permanent&quot;), and an unrelated technical one (a synonym for<br>&gt; associativity; search &quot;assocativity fixity operator&quot; for examples). If<br>&gt; we&#39;re using it in this different way, I respectfully submit that we should<br>&gt; reconsider.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; You are correct, of course, but a subset of computer scientists have<br>&gt; been abusing the term in this way for at least a couple of decades. Their<br>&gt; novel usage of “fixity” now has a degree of fixity, so it may be too late<br>&gt; to fix &quot;fixity&quot;.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; It&#39;s become a termity of art.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -- E<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/82ecdc0a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>[Draft] Resolving operator precedence conflicts</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>March  9, 2016 at 11:00:00am</p></header><div class="content"><p>Anton,<br></p><p>Could your idea be simplified by having an operator attribute that applies only to the following function declaration rather than referring to one by name?<br></p><p>#operator(fixity: infix, associativity: left)<br>func +(left: Int, _ right: Int) -&gt; Int<br></p><p>#operator(fixity: prefix)<br>func +(right: Int) -&gt; Int<br></p><p><br>—CK<br></p><p>&gt; On Mar 8, 2016, at 12:13 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There have been complaints on current syntax of operator declarations:<br>&gt; <br>&gt; infix operator &lt;&gt; { associativity left precedence 100 assignment }<br>&gt; <br>&gt; It looks like a collection of random words. Dictionary syntax would suit better here. Additionally, `assignment` has been deprecated for a long time, but not removed.<br>&gt; <br>&gt; Many syntaxes were suggested. For example:<br>&gt; <br>&gt; #operator(&lt;&gt;, fixity: infix, associativity: left, precedence: 100)<br>&gt; <br>&gt; *But* Joe Groff uncovered a deeper problem. Current operators cannot be given precedence and associativity per concrete operator function.<br>&gt; <br>&gt; Moreover, it makes more sense for operators to only allow parenthesis omission for some other operators. (C/C++ gives warnings for relying on precedence for unrelated operators.) <br>&gt; <br>&gt; Operator declarations may lie in different modules and not know anything about each other, but they will create a conflict if their names happen to be identical.<br>&gt; <br>&gt; The following is my attempt at solving the problem.<br>&gt; <br>&gt; 1.<br>&gt; All operators are aliases for functions.<br>&gt; <br>&gt; #operator(+, name: numericAdd, fixity: infix, associativity: left)<br>&gt; <br>&gt; func numericAdd(left: Int, _ right: Int) -&gt; Int<br>&gt; <br>&gt; #operator(+, name: numericUnaryPlus, fixity: prefix)<br>&gt; <br>&gt; func unaryPlus(right: Int) -&gt; Int<br>&gt; <br>&gt; +1 + 2  // same as numericAdd(numericUnaryPlus(1), 2)<br>&gt; <br>&gt; 2.<br>&gt; Operators with same &quot;operator form&quot; use overloading, modified to accomodate associativity and precedence.<br>&gt; <br>&gt; #operator(+, name: append, fixity: infix)<br>&gt; <br>&gt; func append&lt;T&gt;(left: [T], right: T) -&gt; [T]<br>&gt; <br>&gt; var arr = [1, 2, 3]<br>&gt; 1 + 2 + 3  //=&gt; 6<br>&gt; [1, 2] + 3  //=&gt; 1 2 3<br>&gt; [1, 2] + 3 + 4  // error<br>&gt; <br>&gt; Compiler must try to apply rules of both `numericAdd` and `append` in all combinations. Complexity of this should not be exponential: most branches will be cut off fast, starting from the inside.<br>&gt; <br>&gt; In 1 + 2 + 3, `append` cannot be applied both to 1+2 and to 2+3, so we are left with `numericAdd`.<br>&gt; In [1,2] + 3 + 4, `numericAdd` cannot be applied to [1,2] + 3, and `append` cannot be applied to 3 + 4. But if we assume `append` and `numericAdd`, then no precedence rule is defined between `numericAdd` and `append`.<br>&gt; <br>&gt; Overall, algorithm for compiler is to be developed.<br>&gt; <br>&gt; 3.<br>&gt; Operators can define precedence (omission of parentheses), only compared to other specific operators.<br>&gt; <br>&gt; #precedence(append, lessThan: numericAdd)<br>&gt; <br>&gt; #precedence(numericAdd, equalTo: numericSubtract)<br>&gt; <br>&gt; 4.<br>&gt; Precedence applies to unary operators as well:<br>&gt; <br>&gt; let v: Bool? = false<br>&gt; let u = !v!  // error, precedence between logicalNot and forceUnwrap is not defined<br>&gt; <br>&gt; #precedence(forceUnwrap, greaterThan: logicalNot)<br>&gt; <br>&gt; let u = !v!  // true<br>&gt; <br>&gt; That said, precedence of unary operators is always higher than of any binary operator.<br>&gt; <br>&gt; - Anton<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
