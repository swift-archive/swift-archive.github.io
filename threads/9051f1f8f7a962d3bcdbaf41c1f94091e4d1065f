<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Draft] @intendedcontext to hint at symbol relevance</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January  7, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>I&#39;d like to share this draft for an @intendedcontext attribute: https://gist.github.com/zneak/e53494c38bb3739201ac &lt;https://gist.github.com/zneak/e53494c38bb3739201ac&gt;<br></p><p>The purpose, broadly, is to help tools determine whether a (technically) visible symbol should be used where you have your cursor at or not. It could help with shorter autocompletion lists and linters.<br></p><p>Félix<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/9051065f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b660eecceda60138f137d353b8289925?s=50"></div><header><strong>[Draft] @intendedcontext to hint at symbol relevance</strong> from <string>Janosch Hildebrand</string> &lt;jnosh at jnosh.com&gt;<p>January  8, 2016 at 12:00:00am</p></header><div class="content"><p>Hi Félix,<br></p><p>Perhaps it might make more sense to model such non-binding extra information as doc comment fields instead of attributes.<br></p><p>From swift/Changelog.md:<br>&gt; Three new doc comment fields, namely - keyword:, - recommended: and - recommendedover:, allow Swift users to cooperate with code completion engine to deliver more effective code completion results. The - keyword: field specifies concepts that are not fully manifested in declaration names. - recommended: indicates other declarations are preferred to the one decorated; to the contrary, - recommendedover: indicates the decorated declaration is preferred to those declarations whose names are specified.<br>&gt; <br>This seems to be similar in spirit and I think it makes sense to separate such annotations from actual code.<br></p><p><br>&gt; On 08 Jan 2016, at 00:15, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; I&#39;d like to share this draft for an @intendedcontext attribute: https://gist.github.com/zneak/e53494c38bb3739201ac &lt;https://gist.github.com/zneak/e53494c38bb3739201ac&gt;<br>&gt; <br>&gt; The purpose, broadly, is to help tools determine whether a (technically) visible symbol should be used where you have your cursor at or not. It could help with shorter autocompletion lists and linters.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>- Janosch<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/a99502b1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Draft] @intendedcontext to hint at symbol relevance</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January  7, 2016 at 06:00:00pm</p></header><div class="content"><p>I wasn&#39;t aware of that. I&#39;ll revisit it some time later today or tomorrow.<br></p><p>Félix<br></p><p>&gt; Le 7 janv. 2016 à 18:30:24, Janosch Hildebrand &lt;jnosh at jnosh.com&gt; a écrit :<br>&gt; <br>&gt; Hi Félix,<br>&gt; <br>&gt; Perhaps it might make more sense to model such non-binding extra information as doc comment fields instead of attributes.<br>&gt; <br>&gt; From swift/Changelog.md:<br>&gt;&gt; Three new doc comment fields, namely - keyword:, - recommended: and - recommendedover:, allow Swift users to cooperate with code completion engine to deliver more effective code completion results. The - keyword: field specifies concepts that are not fully manifested in declaration names. - recommended: indicates other declarations are preferred to the one decorated; to the contrary, - recommendedover: indicates the decorated declaration is preferred to those declarations whose names are specified.<br>&gt;&gt; <br>&gt; This seems to be similar in spirit and I think it makes sense to separate such annotations from actual code.<br>&gt; <br>&gt; <br>&gt;&gt; On 08 Jan 2016, at 00:15, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to share this draft for an @intendedcontext attribute: https://gist.github.com/zneak/e53494c38bb3739201ac &lt;https://gist.github.com/zneak/e53494c38bb3739201ac&gt;<br>&gt;&gt; <br>&gt;&gt; The purpose, broadly, is to help tools determine whether a (technically) visible symbol should be used where you have your cursor at or not. It could help with shorter autocompletion lists and linters.<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; - Janosch<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/043beaae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Draft] intendeduse documentation attribute</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 12, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>I finally updated my proposal to use a documentation tag instead of an attribute (thanks Janosch): https://gist.github.com/zneak/e53494c38bb3739201ac<br></p><p>Félix<br></p><p>---<br></p><p># `intendeduse` Documentation Attribute<br></p><p>* Proposal: SE-NNNN<br>* Author(s): [Félix Cloutier](https://github.com/zneak)<br>* Status: **Draft**<br>* Review manager: TBD<br></p><p>## Introduction<br></p><p>This proposal suggests a new documentation field that can be used to hint that a symbol is relevant only in certain contexts. This hint can be picked up by tools (like SourceKit) and analyzers (like [SwiftLint][1]) to offer better diagnostics or less irrelevant autocomplete suggestions.<br></p><p>## Motivation<br></p><p>Swift does not adopt typical object-oriented access modifiers. Instead, its `public`, `internal` and `private` modifiers map closer to the linker&#39;s notion of visibility. While this reduces surprises about what&#39;s accessible and what isn&#39;t in a native program, in some scenarios it will make symbols discoverable in locations where they aren&#39;t helpful, cluttering autocomplete suggestions at best and misleading developers at worst.<br></p><p>There are several relevant scenarios where one could prefer to show a member in specific contexts only. For instance:<br></p><p> *  Some Swift users like to separate a class&#39;s implementation across several files by defining the core in one and using extensions in the others. This pattern is also popular in Objective-C, where class implementations can be split into multiple categories. Other languages have similar notions: for instance, C# supports &quot;partial classes&quot; which do essentially the same thing. However, using this pattern in Swift, some class members members that could otherwise be marked `private` now need to be marked `internal` to be reachable from extension files. The members now show up as autocompleting suggestions in every file of the project, even though the developer only cares about them in a few select files. ([swift-evolution thread][2])<br> *  Even though Swift generally does not encourage classes to grow into a hierarchy, it is sometimes useful to have functions that are meant to be called from subclasses. These currently have to be marked `internal` or `public` because Swift does not have a `protected` modifier. Even though there is no intention to enforce more specific access control with this proposal, a member marked &quot;for subclasses&quot; is useful documentation to other developers.<br> *  Some classes, like NSView, expose significant API surface for customization. It can become overwhelming, to the point where developers are pushed to make a chart of which method are intended for external use and which methods are intended to be merely overridden (and not called directly). All these methods will clutter autocomplete and obscure which ones should be called directly. ([swift-evolution thread][5])<br> *  Some Swift users interoperate with Objective-C to a degree large enough that it makes sense to have API entry points better suited for one language or the other. On its side, Apple added an Objective-C attribute called `swift_private` that indicates that a symbol can be used from Objective-C but not from Swift. On the Swift side, some developers would like to be able to mark an entry point as meant specifically for Objective-C, simply because a better one exists for Swift. The Objective-C-specific entry point will however show side-by-side with the Swift one because there&#39;s no way to mask it. If it becomes possible to call Swift code from C or any other language, it may eventually become a problem there as well. ([swift-evolution thread][4])<br> *  Tools generating Swift code may find it useful to mark  members as &quot;tool-private&quot;: members that need to have a looser access modifier for technical reasons but that shouldn&#39;t be used directly by the client. This is the use case that .NET&#39;s similar [`EditorBrowsable`][3] attribute supports.<br></p><p>## Proposed solution<br></p><p>This proposal suggests a new `- intendeduse` (name to be bikeshedded in typical Internet fashion) documentation tag that hints whether a member should be used in a certain context or not. It is not meant to implement access control: the compiler must not restrict access to the member based on it. It is meant to document symbols and help tools offer better suggestions.<br></p><p>It exists in the spirit of the new-ish `keyword`, `recommended` and `recommendedover` documentation tags that allow &quot;[to cooperate with code completion engine to deliver more effective code completion results][6]&quot;.<br></p><p>The documentation tag would accept a context parameter and an optional message that explains why the symbol is not intended to be used in the full extent of its access modifier.<br></p><p>Tools like SourceKit and SwiftLint would be responsible for how they wish to interpret the hint. For instance, Xcode could hide or strike members that don&#39;t belong. SwiftLint could detect violations and report them, showing the message parameter (if any).<br></p><p>## Detailed design<br></p><p>The basic syntax would be:<br></p><p>    /// - intendeduse: `context` (`optional message`)<br></p><p>Backticks are used as delimiters here and are not intended to be part of the syntax. For instance:<br></p><p>    /// - intendeduse: private (don&#39;t call me directly!)<br></p><p>Context values could be one of:<br></p><p>  * `extension`: this type member is intended to be used from extensions.<br>  * `interop`: this symbol is intended to be used from other languages that interface with Swift.<br>  * `override`: this symbol is intended to be overridden only.<br>  * `private`: this symbol is not intended to be used directly.<br>  * `subclass`: this type member is intended to be used from subclasses.<br></p><p>The `extension` context can only be used on type members. A member with this intended context is considered &quot;in context&quot; if it is used from a file that defines an extension to its host type.<br></p><p>The `interop` context can be used on any non-private symbol [somebody remind me if mixing Swift and Objective-C in the same target allows Objective-C to access `internal` members?]. These symbols are never considered &quot;in context&quot; when used in Swift code.<br></p><p>The `override` context can be used on any virtual symbol. These symbols are intended to be overridden by subclasses to implement customized behavior. These symbols are considered &quot;in context&quot; when editing the declaring class or an extension to it.<br></p><p>The `private` context can be used on any non-private symbol. These symbols are never considered &quot;in context&quot;. [The paradox is that they will be used somewhere, otherwise they wouldn&#39;t be needed at all. While it&#39;s pretty clear that these shouldn&#39;t show up in autocompletion lists, it&#39;s unclear how a linter should react to it.]<br></p><p>The `subclass` context can be used on any class member. These symbols are considered &quot;in context&quot; when they&#39;re used from the file that declares the base class and any other file that declares a subclass.<br></p><p>## Possible future directions<br></p><p>In the future, this documentation tag could perhaps take over the role of `@deprecated`. `@available` is also fundamentally documentation, but it needs to abort compilation because the symbol isn&#39;t available, so it is less likely within the scope of a documentation attribute.<br></p><p>Through some sort of convention, it could become possible to offer fix-it hints for some out-of-context uses.<br></p><p>One solution to the `private` gambit would be to allow user-defined contexts. A tool could emit code that uses a string as a context name and specify that some file, class, function, or other code unit can rightfully use it:<br></p><p>    /// - intendeduse: supertool (don&#39;t use me directly!)<br>    func leaveMeAlone() { ... }<br>    <br>    @context(&quot;supertool&quot;)<br>    func publicEntryPoint() {<br>    	leaveMeAlone()<br>    }<br></p><p>## Impact on existing code<br></p><p>This change does not alter any existing behavior.<br></p><p>## Alternatives considered<br></p><p>The most obvious alternative is to do nothing about it. Even though it is not the author&#39;s opinion, it can be argued that the Swift language doesn&#39;t need an attribute that looks like it wants to provide finer-grained access control but doesn&#39;t really do it.<br></p><p>Other alternatives considered were the piecewise solutions that the three aforementioned swift-evolution threads considered:<br></p><p>  * An attribute that hides the entry point from Swift entirely, causing an error when it is used. However, completely hiding the entry point makes the attribute less useful in the context of gradually porting an Objective-C program or library to Swift. If creating Swift-ier entry points is a low-priority task, we can assume that existing Swift code uses to-be Objective-C entry points; therefore, hiding them would force more modifications than may be desirable.<br>  * A new access modifier, like `private(extension)`, that acts like `internal` in files that declare an extension to the owning type but `private` elsewhere. This modifier&#39;s behavior does not align with linker visibility and would be significantly different from what currently exists.<br>  * A new access modifier, like `private(call)`, that means that a member can be overridden but not called. This modifier&#39;s behavior does not align with linker visibility and would be significantly different from what currently exists.<br></p><p>  [1]: https://github.com/realm/SwiftLint<br>  [2]: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005446.html<br>  [3]: https://msdn.microsoft.com/en-us/library/system.componentmodel.editorbrowsableattribute(v=vs.110).aspx<br>  [4]: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005406.html<br>  [5]: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006321.html<br>  [6]: https://github.com/apple/swift/blob/master/CHANGELOG.md<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/cb4d28b2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
