<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal Draft] Importing Objective-C Lightweight Generics</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January  9, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p><br>Here’s a proposal I’m working on to import Objective-C lightweight generics as generic classes in Swift. It’s also available here:<br></p><p>	https://github.com/DougGregor/swift-evolution/blob/importing-objc-generics/proposals/0000-importing-objc-generics.md &lt;https://github.com/DougGregor/swift-evolution/blob/importing-objc-generics/proposals/0000-importing-objc-generics.md&gt;<br></p><p>Comments welcome!<br></p><p>	- Doug<br></p><p><br></p><p><br>Importing Objective-C Lightweight Generics<br></p><p>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-importing-objc-generics.md&gt;<br>Author: Doug Gregor &lt;https://github.com/DougGregor&gt;<br>Status: Awaiting review<br>Review manager: TBD<br> &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#introduction&gt;Introduction<br></p><p>Objective-C&#39;s lightweight generics feature allows Objective-C classes to be parameterized on the types they work with, similarly to Swift&#39;s generics syntax. Their adoption in Foundation&#39;s collection classes allow Objective-C APIs to be bridged more effectively into Swift. For example, an NSArray&lt;NSString *&gt; * bridges to [String] rather than the far-weaker [AnyObject]. However, parameterized Objective-C classes lose their type parameters when they are imported into Swift, so uses of type parameters outside of bridged, typed collections (NSArray, NSDictionary, NSSet) don&#39;t benefit in Swift. This proposal introduces a way to import the type parameters of Objective-C classes into Swift.<br></p><p>Swift-evolution thread: TODO &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br> &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#motivation&gt;Motivation<br></p><p>Cocoa and Cocoa Touch include a number of APIs that have adopted Objective-C lightweight generics to improve static type safety and expressiveness. However, because the type parameters are lost when these APIs are imported into Swift, they are effectively less type safe in Swift than in Objective-C, a situation we clearly cannot abide. This proposal aims to improve the projection of these Objective-C APIs in Swift.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#proposed-solution&gt;Proposed solution<br></p><p>A parameterized class written in Objective-C will be imported into Swift as a generic class with the same number of type parameters. The bounds on the type parameters in Objective-C will be translated into requirements on the generic type parameters in Swift:<br></p><p>The generic type parameters in Swift will always be class-bound, i.e., the generic class will have the requirement T : AnyObject.<br>If the bound includes a class type (e.g., T : NSValue * in Objective-C), the generic Swift class will have the corresponding superclass requirement (T : NSValue).<br>If the bound includes protocol qualification (e.g., T : id&lt;NSCopying&gt; in Objective-C), each protocol bound is turned into a conformance requirement (T : NSCopying) on the generic Swift class.<br>The following Objective-C code:<br></p><p>@interface MySet&lt;T : id&lt;NSCopying&gt;&gt; : NSObject<br>-(MySet&lt;T&gt; *)unionWithSet:(MySet&lt;T&gt; *)otherSet;<br>@end<br></p><p>@interface MySomething : NSObject<br>- (MySet&lt;NSValue *&gt; *)valueSet;<br>@end<br>will be imported as:<br></p><p>class MySet&lt;T : NSCopying&gt; : NSObject {<br>  func unionWithSet(otherSet: MySet&lt;T&gt;) -&gt; MySet&lt;T&gt;<br>}<br></p><p>class MySomething : NSObject {<br>  func valueSet() -&gt; MySet&lt;NSValue&gt;<br>}<br> &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#importing-unspecialized-types&gt;Importing unspecialized types<br></p><p>When importing an unspecialized Objective-C type into Swift, we will substitute the bounds for the type arguments. For example:<br></p><p>@interface MySomething (ObjectSet)<br>- (MySet *)objectSet;    // note: no type arguments to MySet<br>@end<br>will be imported as:<br></p><p>extension MySomething {<br>  func objectSet() -&gt; MySet&lt;NSCopying&gt; // note: uses the type bound<br>}<br> &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#restrictions-on-uses-of-objective-c-parameterized-classes&gt;Restrictions on uses of Objective-C parameterized classes<br></p><p>While the Swift and Objective-C generics systems look similar on the surface, they use fundamentally different semantic models. Specifically, Objective-C lightweight generics are based on type erasure, so we cannot in general recover the type arguments from the metaclass of an Objective-C parameterized class (i.e., because MySet, MySet&lt;NSString *&gt;, and MySet&lt;NSNumber *&gt; all share a metaclass). This leads to several restrictions:<br></p><p>Downcasting to an instance or metatype of a parameterized Objective-C class is inherently uncheckable, so we place limits on such casts. For example,<br></p><p>let obj: AnyObject = ...<br>if let set1 = obj as? MySet&lt;NSCopying&gt; {<br>  // okay: every MySet is a MySet&lt;NSCopying&gt; by construction, so<br>  // we&#39;re just checking that this is a &#39;MySet&#39;.<br>}<br></p><p>if let set2 = obj as? MySet&lt;NSNumber&gt; {<br>  // error: conditional cast to specialized Objective-C instance<br>  // doesn&#39;t check type argument &#39;NSNumber&#39;<br>}<br></p><p>let set3 = obj as! MySet&lt;NSNumber&gt; // okay: we assert that it is safe<br></p><p>if let set4 = obj as? MySet&lt;NSCopying&gt; {<br>  let set5 = set4 as! MySet&lt;NSNumber&gt; // here&#39;s how to get a MySet&lt;NSNumber&gt;<br>}<br>Extensions of parameterized Objective-C classes cannot reference the type paramaeters in any way. For example:<br></p><p>extension MySet {<br>  func someNewMethod(x: T) { ... } // error: cannot use `T`.<br>}<br> &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#opting-in-to-type-argument-discovery&gt;Opting in to type argument discovery<br></p><p>Some Objective-C parameterized classes do carry information about their type arguments. When this is the case, it is possible to lift some of the restrictions described in the above section. There are two distinct cases:<br></p><p>Abstract parameterized classes whose concrete subclasses are not parameterized: NSLayoutAnchor &lt;https://developer.apple.com/library/mac/documentation/AppKit/Reference/NSLayoutAnchor_ClassReference/index.html#//apple_ref/occ/cl/NSLayoutAnchor&gt; is one such example: it is parameterized on the anchor type, but there is a fixed set of such anchor types that are represented by subclasses: NSLayoutXAxisAnchor subclasses NSLayoutAnchor&lt;NSLayoutXAxisAnchor *&gt;, NSLayoutDimensionsubclasses NSLayoutAnchor&lt;NSLayoutDimension *&gt;, etc. Therefore, the type arguments can be recovered by looking at the actual metaclass.<br></p><p>Parameterized classes that store their type arguments in instances: GKComponentSystem &lt;https://developer.apple.com/library/ios/documentation/GameplayKit/Reference/GKComponentSystem_Class/&gt; is one such example: it is parameterized on the component type it stores, but it&#39;s initializer (-initWithComponentClass:) requires one to pass the component type&#39;s metaclass. Therefore, every instance of GKComponentSystem knows its type arguments.<br></p><p>A parameterized Objective-C class can opt in to providing information about its type argument by implementing a methodclassForGenericArgumentAtIndex: either as a class method (for the first case described above) or as an instance method (for the second case described above). The method returns the metaclass for the type argument at the given, zero-based index.<br></p><p>For example, NSLayoutAnchor would provide a class method classForGenericArgumentAtIndex: that must be implemented by each of its subclasses:<br></p><p>@interface NSLayoutAnchor&lt;AnchorType&gt; (SwiftSupport)<br>/// Note: must be implemented by each subclass<br>+(nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index;<br>@end<br></p><p>@implementation NSLayoutAnchor<br>+(nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index {<br>  NSAssert(false, @&quot;subclass must override +classForGenericArgumentAtIndex:&quot;);<br>}<br>@end<br></p><p>@implementation NSLayoutXAxisAnchor (SwiftSupport)<br>+(nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index {<br>  return [NSLayoutXAxisAnchor class];<br>}<br>@end<br></p><p>@implementation NSLayoutYAxisAnchor (SwiftSupport)<br>+(nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index {<br>  return [NSLayoutYAxisAnchor class];<br>}<br>@end<br></p><p>@implementation NSLayoutDimension (SwiftSupport)<br>+(nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index {<br>  return [NSLayoutDimension class];<br>}<br>@end<br>On the other hand, GKComponentSystem would implement an instance method classForGenericArgumentAtIndex::<br></p><p>@interface GKComponentSystem&lt;ComponentType : GKComponent *&gt; (SwiftSupport)<br>- (nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index;<br>@end<br></p><p>@implementation GKComponentSystem (SwiftSupport)<br>- (nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index {<br>  return self.componentClass;<br>}<br>@end<br>Note that many parameterized Objective-C classes cannot provide either of these methods, because they don&#39;t carry enough information in their instances. For example, an NSMutableArray has no record of what the element type of the array is intended to be.<br></p><p>However, when a parameterized class does provide this information, we can lift some of the restrictions from the previous section:<br></p><p>If the parameterized class provides an instance method classForGenericArgumentAtIndex:, the extension can use the type arguments in its instance methods, including accessors for instance properties and subscripts. For example:<br></p><p>extension GKComponentSystem {<br>  var reversedComponents: [ComponentType] {<br>    return components.reversed()<br>  }<br></p><p>  static func notifyComponents(components: [ComponentType]) {<br>    // error: cannot use `ComponentType` in a static method<br>  }<br>}<br>If the parametized class provides a class method classForGenericArgumentAtIndex:, the extension can use type arguments anywhere.<br></p><p>extension NSLayoutAnchor {<br>  func doSomething(x: AnchorType) { ... }<br>  class func doSomethingClassy(x: AnchorType) { ... }<br>}<br> &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#subclassing-parameterized-objective-c-classes-from-swift&gt;Subclassing parameterized Objective-C classes from Swift<br></p><p>When subclassing a parameterized Objective-C class from Swift, the Swift compiler will define +classForGenericArgumentAtIndex: and -classForGenericArgumentAtIndex:. The Swift compiler has the complete type metadata required, because it is stored in the (Swift) type metadata, so these definitions will be correct. For example:<br></p><p>class Employee : NSObject { ... }<br></p><p>class EmployeeArray : NSMutableArray&lt;Employee&gt; {<br>  // +[EmployeeArray classForGenericArgumentAtIndex:] always returns<br>  // ObjC type metadata for Employee<br>}<br></p><p>class MyMutableArray&lt;T : AnyObject&gt; : NSMutableArray&lt;T&gt; {<br>  // +[MyMutableArray classForGenericArgumentAtIndex:] returns the<br>  // ObjC type metadata for T, extracted from the Swift metatype for<br>  // `self`.<br>}<br> &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#impact-on-existing-code&gt;Impact on existing code<br></p><p>In Swift 2, parameterized Objective-C classes are imported as non-parameterized classes. Importing them as parameterized classes will break any existing references to the affecting APIs. There are a handful of cases where type inference may paper over the problems:<br></p><p>let array: NSArray = [&quot;hello&quot;, &quot;world&quot;] // okay, infer NSArray&lt;NSString&gt;<br>// old<br></p><p>var mutArray = NSMutableArray() // error: need type arguments for NSMutableArray<br>A migrator could introduce the type bounds as arguments, e.g., NSArray would get migrated to NSArray&lt;AnyObject&gt;. It is not the best migration---many developers would likely want to tighten up the bounds to improve their Swift code---but it should migrate existing code.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#alternatives-considered&gt;Alternatives considered<br></p><p>The only major alternative design involves bringing type erasure into the Swift generics system as an alternative implementation. It would lift the restrictions on extensions of parameterized Objective-C classes by treating type parameters in such contexts as the type bounds:<br></p><p>extension MySet {<br>  func someNewMethod(x: T) { ... } // okay: `T` is treated like `NSCopying`<br>}<br>Doing so could allow the use of &quot;unspecialized&quot; generic types within Swift, e.g., NSMutableArray with no type bounds (possibly spelled NSMutableArray&lt;*&gt;), which would more accurately represent Objective-C semantics in Swift.<br></p><p>However, doing so comes at the cost of having two incompatible generics models implemented in Swift, which produces both a high conceptual burden as well as a high implementation cost. The proposed solution implies less implementation cost and puts the limitations on what one can express when working with parameterized Objective-C classes without fundamentally changing the Swift model.<br>Status &lt;https://status.github.com/&gt; API &lt;https://developer.github.com/&gt; Training &lt;https://training.github.com/&gt; Shop &lt;https://shop.github.com/&gt; Blog &lt;https://github.com/blog&gt; About &lt;https://github.com/about&gt; Pricing &lt;https://github.com/pricing&gt; &lt;https://github.com/&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/cba5444f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Proposal Draft] Importing Objective-C Lightweight Generics</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January  9, 2016 at 04:00:00pm</p></header><div class="content"><p>This is an interesting proposal.<br></p><p>Would there be any interactions between this proposal and the covariant,<br>contravariant, and invariant specifiers that Objective-C generics support<br>on type parameters?<br></p><p>Austin<br></p><p>On Sat, Jan 9, 2016 at 3:50 PM, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi all,<br>&gt;<br>&gt; Here’s a proposal I’m working on to import Objective-C lightweight<br>&gt; generics as generic classes in Swift. It’s also available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/DougGregor/swift-evolution/blob/importing-objc-generics/proposals/0000-importing-objc-generics.md<br>&gt;<br>&gt; Comments welcome!<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt; Importing Objective-C Lightweight Generics<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-importing-objc-generics.md&gt;<br>&gt;    - Author: Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;    - Status: *Awaiting review*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Objective-C&#39;s *lightweight generics* feature allows Objective-C classes<br>&gt; to be parameterized on the types they work with, similarly to Swift&#39;s<br>&gt; generics syntax. Their adoption in Foundation&#39;s collection classes allow<br>&gt; Objective-C APIs to be bridged more effectively into Swift. For example, an NSArray&lt;NSString<br>&gt; *&gt; * bridges to [String] rather than the far-weaker [AnyObject]. However,<br>&gt; parameterized Objective-C classes lose their type parameters when they are<br>&gt; imported into Swift, so uses of type parameters outside of bridged, typed<br>&gt; collections (NSArray, NSDictionary, NSSet) don&#39;t benefit in Swift. This<br>&gt; proposal introduces a way to import the type parameters of Objective-C<br>&gt; classes into Swift.<br>&gt;<br>&gt; Swift-evolution thread: TODO<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Cocoa and Cocoa Touch include a number of APIs that have adopted<br>&gt; Objective-C lightweight generics to improve static type safety and<br>&gt; expressiveness. However, because the type parameters are lost when these<br>&gt; APIs are imported into Swift, they are effectively *less* type safe in<br>&gt; Swift than in Objective-C, a situation we clearly cannot abide. This<br>&gt; proposal aims to improve the projection of these Objective-C APIs in Swift.<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; A parameterized class written in Objective-C will be imported into Swift<br>&gt; as a generic class with the same number of type parameters. The bounds on<br>&gt; the type parameters in Objective-C will be translated into requirements on<br>&gt; the generic type parameters in Swift:<br>&gt;<br>&gt;    - The generic type parameters in Swift will always be class-bound,<br>&gt;    i.e., the generic class will have the requirement T : AnyObject.<br>&gt;    - If the bound includes a class type (e.g., T : NSValue * in<br>&gt;    Objective-C), the generic Swift class will have the corresponding<br>&gt;    superclass requirement (T : NSValue).<br>&gt;    - If the bound includes protocol qualification (e.g., T : id&lt;NSCopying&gt; in<br>&gt;    Objective-C), each protocol bound is turned into a conformance requirement (T<br>&gt;    : NSCopying) on the generic Swift class.<br>&gt;<br>&gt; The following Objective-C code:<br>&gt;<br>&gt; @interface MySet&lt;T : id&lt;NSCopying&gt;&gt; : NSObject<br>&gt; -(MySet&lt;T&gt; *)unionWithSet:(MySet&lt;T&gt; *)otherSet;<br>&gt; @end<br>&gt;<br>&gt; @interface MySomething : NSObject<br>&gt; - (MySet&lt;NSValue *&gt; *)valueSet;<br>&gt; @end<br>&gt;<br>&gt; will be imported as:<br>&gt;<br>&gt; class MySet&lt;T : NSCopying&gt; : NSObject {<br>&gt;   func unionWithSet(otherSet: MySet&lt;T&gt;) -&gt; MySet&lt;T&gt;<br>&gt; }<br>&gt; class MySomething : NSObject {<br>&gt;   func valueSet() -&gt; MySet&lt;NSValue&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#importing-unspecialized-types&gt;Importing<br>&gt; unspecialized types<br>&gt;<br>&gt; When importing an unspecialized Objective-C type into Swift, we will<br>&gt; substitute the bounds for the type arguments. For example:<br>&gt;<br>&gt; @interface MySomething (ObjectSet)<br>&gt; - (MySet *)objectSet;    // note: no type arguments to MySet<br>&gt; @end<br>&gt;<br>&gt; will be imported as:<br>&gt;<br>&gt; extension MySomething {<br>&gt;   func objectSet() -&gt; MySet&lt;NSCopying&gt; // note: uses the type bound<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#restrictions-on-uses-of-objective-c-parameterized-classes&gt;Restrictions<br>&gt; on uses of Objective-C parameterized classes<br>&gt;<br>&gt; While the Swift and Objective-C generics systems look similar on the<br>&gt; surface, they use fundamentally different semantic models. Specifically,<br>&gt; Objective-C lightweight generics are based on *type erasure*, so we<br>&gt; cannot in general recover the type arguments from the metaclass of an<br>&gt; Objective-C parameterized class (i.e., because MySet, MySet&lt;NSString *&gt;,<br>&gt; and MySet&lt;NSNumber *&gt; all share a metaclass). This leads to several<br>&gt; restrictions:<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Downcasting to an instance or metatype of a parameterized Objective-C<br>&gt;    class is inherently uncheckable, so we place limits on such casts. For<br>&gt;    example,<br>&gt;<br>&gt;    let obj: AnyObject = ...if let set1 = obj as? MySet&lt;NSCopying&gt; {<br>&gt;      // okay: every MySet is a MySet&lt;NSCopying&gt; by construction, so<br>&gt;      // we&#39;re just checking that this is a &#39;MySet&#39;.<br>&gt;    }<br>&gt;    if let set2 = obj as? MySet&lt;NSNumber&gt; {<br>&gt;      // error: conditional cast to specialized Objective-C instance<br>&gt;      // doesn&#39;t check type argument &#39;NSNumber&#39;<br>&gt;    }<br>&gt;    let set3 = obj as! MySet&lt;NSNumber&gt; // okay: we assert that it is safe<br>&gt;    if let set4 = obj as? MySet&lt;NSCopying&gt; {<br>&gt;      let set5 = set4 as! MySet&lt;NSNumber&gt; // here&#39;s how to get a MySet&lt;NSNumber&gt;<br>&gt;    }<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Extensions of parameterized Objective-C classes cannot reference the<br>&gt;    type paramaeters in any way. For example:<br>&gt;<br>&gt;    extension MySet {<br>&gt;      func someNewMethod(x: T) { ... } // error: cannot use `T`.<br>&gt;    }<br>&gt;<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#opting-in-to-type-argument-discovery&gt;Opting<br>&gt; in to type argument discovery<br>&gt;<br>&gt; Some Objective-C parameterized classes do carry information about their<br>&gt; type arguments. When this is the case, it is possible to lift some of the<br>&gt; restrictions described in the above section. There are two distinct cases:<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    *Abstract parameterized classes whose concrete subclasses are not<br>&gt;    parameterized*: NSLayoutAnchor<br>&gt;    &lt;https://developer.apple.com/library/mac/documentation/AppKit/Reference/NSLayoutAnchor_ClassReference/index.html#//apple_ref/occ/cl/NSLayoutAnchor&gt; is<br>&gt;    one such example: it is parameterized on the anchor type, but there is a<br>&gt;    fixed set of such anchor types that are represented by subclasses:<br>&gt;    NSLayoutXAxisAnchor subclasses NSLayoutAnchor&lt;NSLayoutXAxisAnchor *&gt;,<br>&gt;    NSLayoutDimensionsubclasses NSLayoutAnchor&lt;NSLayoutDimension *&gt;, etc.<br>&gt;    Therefore, the type arguments can be recovered by looking at the actual<br>&gt;    metaclass.<br>&gt;    -<br>&gt;<br>&gt;    *Parameterized classes that store their type arguments in instances*:<br>&gt;    GKComponentSystem<br>&gt;    &lt;https://developer.apple.com/library/ios/documentation/GameplayKit/Reference/GKComponentSystem_Class/&gt; is<br>&gt;    one such example: it is parameterized on the component type it stores, but<br>&gt;    it&#39;s initializer (-initWithComponentClass:) requires one to pass the<br>&gt;    component type&#39;s metaclass. Therefore, every *instance* of<br>&gt;    GKComponentSystem knows its type arguments.<br>&gt;<br>&gt; A parameterized Objective-C class can opt in to providing information<br>&gt; about its type argument by implementing a method<br>&gt; classForGenericArgumentAtIndex: either as a class method (for the first<br>&gt; case described above) or as an instance method (for the second case<br>&gt; described above). The method returns the metaclass for the type argument at<br>&gt; the given, zero-based index.<br>&gt;<br>&gt; For example, NSLayoutAnchor would provide a class method<br>&gt; classForGenericArgumentAtIndex: that must be implemented by each of its<br>&gt; subclasses:<br>&gt;<br>&gt; @interface NSLayoutAnchor&lt;AnchorType&gt; (SwiftSupport)<br>&gt; /// Note: must be implemented by each subclass<br>&gt; +(nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index;<br>&gt; @end<br>&gt;<br>&gt; @implementation NSLayoutAnchor<br>&gt; +(nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index {<br>&gt;   NSAssert(false, @&quot;subclass must override +classForGenericArgumentAtIndex:&quot;);<br>&gt; }<br>&gt; @end<br>&gt;<br>&gt; @implementation NSLayoutXAxisAnchor (SwiftSupport)<br>&gt; +(nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index {<br>&gt;   return [NSLayoutXAxisAnchor class];<br>&gt; }<br>&gt; @end<br>&gt;<br>&gt; @implementation NSLayoutYAxisAnchor (SwiftSupport)<br>&gt; +(nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index {<br>&gt;   return [NSLayoutYAxisAnchor class];<br>&gt; }<br>&gt; @end<br>&gt;<br>&gt; @implementation NSLayoutDimension (SwiftSupport)<br>&gt; +(nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index {<br>&gt;   return [NSLayoutDimension class];<br>&gt; }<br>&gt; @end<br>&gt;<br>&gt; On the other hand, GKComponentSystem would implement an instance method<br>&gt; classForGenericArgumentAtIndex::<br>&gt;<br>&gt; @interface GKComponentSystem&lt;ComponentType : GKComponent *&gt; (SwiftSupport)<br>&gt; - (nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index;<br>&gt; @end<br>&gt;<br>&gt; @implementation GKComponentSystem (SwiftSupport)<br>&gt; - (nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index {<br>&gt;   return self.componentClass;<br>&gt; }<br>&gt; @end<br>&gt;<br>&gt; Note that many parameterized Objective-C classes cannot provide either of<br>&gt; these methods, because they don&#39;t carry enough information in their<br>&gt; instances. For example, an NSMutableArray has no record of what the<br>&gt; element type of the array is intended to be.<br>&gt;<br>&gt; However, when a parameterized class does provide this information, we can<br>&gt; lift some of the restrictions from the previous section:<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    If the parameterized class provides an instance method<br>&gt;    classForGenericArgumentAtIndex:, the extension can use the type<br>&gt;    arguments in its instance methods, including accessors for instance<br>&gt;    properties and subscripts. For example:<br>&gt;<br>&gt;    extension GKComponentSystem {<br>&gt;      var reversedComponents: [ComponentType] {<br>&gt;        return components.reversed()<br>&gt;      }<br>&gt;<br>&gt;      static func notifyComponents(components: [ComponentType]) {<br>&gt;        // error: cannot use `ComponentType` in a static method<br>&gt;      }<br>&gt;    }<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    If the parametized class provides a class method<br>&gt;    classForGenericArgumentAtIndex:, the extension can use type arguments<br>&gt;    anywhere.<br>&gt;<br>&gt;    extension NSLayoutAnchor {<br>&gt;      func doSomething(x: AnchorType) { ... }<br>&gt;      class func doSomethingClassy(x: AnchorType) { ... }<br>&gt;    }<br>&gt;<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#subclassing-parameterized-objective-c-classes-from-swift&gt;Subclassing<br>&gt; parameterized Objective-C classes from Swift<br>&gt;<br>&gt; When subclassing a parameterized Objective-C class from Swift, the Swift<br>&gt; compiler will define +classForGenericArgumentAtIndex: and<br>&gt; -classForGenericArgumentAtIndex:. The Swift compiler has the complete<br>&gt; type metadata required, because it is stored in the (Swift) type metadata,<br>&gt; so these definitions will be correct. For example:<br>&gt;<br>&gt; class Employee : NSObject { ... }<br>&gt; class EmployeeArray : NSMutableArray&lt;Employee&gt; {<br>&gt;   // +[EmployeeArray classForGenericArgumentAtIndex:] always returns<br>&gt;   // ObjC type metadata for Employee<br>&gt; }<br>&gt; class MyMutableArray&lt;T : AnyObject&gt; : NSMutableArray&lt;T&gt; {<br>&gt;   // +[MyMutableArray classForGenericArgumentAtIndex:] returns the<br>&gt;   // ObjC type metadata for T, extracted from the Swift metatype for<br>&gt;   // `self`.<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; In Swift 2, parameterized Objective-C classes are imported as<br>&gt; non-parameterized classes. Importing them as parameterized classes will<br>&gt; break any existing references to the affecting APIs. There are a handful of<br>&gt; cases where type inference may paper over the problems:<br>&gt;<br>&gt; let array: NSArray = [&quot;hello&quot;, &quot;world&quot;] // okay, infer NSArray&lt;NSString&gt;// old<br>&gt; var mutArray = NSMutableArray() // error: need type arguments for NSMutableArray<br>&gt;<br>&gt; A migrator could introduce the type bounds as arguments, e.g., NSArray would<br>&gt; get migrated to NSArray&lt;AnyObject&gt;. It is not the best migration---many<br>&gt; developers would likely want to tighten up the bounds to improve their<br>&gt; Swift code---but it should migrate existing code.<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt; The only major alternative design involves bringing type erasure into the<br>&gt; Swift generics system as an alternative implementation. It would lift the<br>&gt; restrictions on extensions of parameterized Objective-C classes by treating<br>&gt; type parameters in such contexts as the type bounds:<br>&gt;<br>&gt; extension MySet {<br>&gt;   func someNewMethod(x: T) { ... } // okay: `T` is treated like `NSCopying`<br>&gt; }<br>&gt;<br>&gt; Doing so could allow the use of &quot;unspecialized&quot; generic types within<br>&gt; Swift, e.g., NSMutableArray with no type bounds (possibly spelled<br>&gt; NSMutableArray&lt;*&gt;), which would more accurately represent Objective-C<br>&gt; semantics in Swift.<br>&gt; However, doing so comes at the cost of having two incompatible generics<br>&gt; models implemented in Swift, which produces both a high conceptual burden<br>&gt; as well as a high implementation cost. The proposed solution implies less<br>&gt; implementation cost and puts the limitations on what one can express when<br>&gt; working with parameterized Objective-C classes without fundamentally<br>&gt; changing the Swift model.<br>&gt;<br>&gt;    - Status &lt;https://status.github.com/&gt;<br>&gt;    - API &lt;https://developer.github.com/&gt;<br>&gt;    - Training &lt;https://training.github.com/&gt;<br>&gt;    - Shop &lt;https://shop.github.com/&gt;<br>&gt;    - Blog &lt;https://github.com/blog&gt;<br>&gt;    - About &lt;https://github.com/about&gt;<br>&gt;    - Pricing &lt;https://github.com/pricing&gt;<br>&gt;<br>&gt; &lt;https://github.com/&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/8c8118e1/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal Draft] Importing Objective-C Lightweight Generics</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January  9, 2016 at 04:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Jan 9, 2016, at 4:14 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; This is an interesting proposal.<br>&gt; <br>&gt; Would there be any interactions between this proposal and the covariant, contravariant, and invariant specifiers that Objective-C generics support on type parameters?<br></p><p>Objective-C has variance for its generic type arguments. Since Swift does not, we would just drop that information and treat everything as invariant. <br>&gt; <br>&gt; Austin<br>&gt; <br>&gt;&gt; On Sat, Jan 9, 2016 at 3:50 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Here’s a proposal I’m working on to import Objective-C lightweight generics as generic classes in Swift. It’s also available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/DougGregor/swift-evolution/blob/importing-objc-generics/proposals/0000-importing-objc-generics.md<br>&gt;&gt; <br>&gt;&gt; Comments welcome!<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Importing Objective-C Lightweight Generics<br>&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt; Author: Doug Gregor<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; Objective-C&#39;s lightweight generics feature allows Objective-C classes to be parameterized on the types they work with, similarly to Swift&#39;s generics syntax. Their adoption in Foundation&#39;s collection classes allow Objective-C APIs to be bridged more effectively into Swift. For example, an NSArray&lt;NSString *&gt; * bridges to [String] rather than the far-weaker [AnyObject]. However, parameterized Objective-C classes lose their type parameters when they are imported into Swift, so uses of type parameters outside of bridged, typed collections (NSArray, NSDictionary, NSSet) don&#39;t benefit in Swift. This proposal introduces a way to import the type parameters of Objective-C classes into Swift.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: TODO<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; Cocoa and Cocoa Touch include a number of APIs that have adopted Objective-C lightweight generics to improve static type safety and expressiveness. However, because the type parameters are lost when these APIs are imported into Swift, they are effectively less type safe in Swift than in Objective-C, a situation we clearly cannot abide. This proposal aims to improve the projection of these Objective-C APIs in Swift.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; A parameterized class written in Objective-C will be imported into Swift as a generic class with the same number of type parameters. The bounds on the type parameters in Objective-C will be translated into requirements on the generic type parameters in Swift:<br>&gt;&gt; <br>&gt;&gt; The generic type parameters in Swift will always be class-bound, i.e., the generic class will have the requirement T : AnyObject.<br>&gt;&gt; If the bound includes a class type (e.g., T : NSValue * in Objective-C), the generic Swift class will have the corresponding superclass requirement (T : NSValue).<br>&gt;&gt; If the bound includes protocol qualification (e.g., T : id&lt;NSCopying&gt; in Objective-C), each protocol bound is turned into a conformance requirement (T : NSCopying) on the generic Swift class.<br>&gt;&gt; The following Objective-C code:<br>&gt;&gt; <br>&gt;&gt; @interface MySet&lt;T : id&lt;NSCopying&gt;&gt; : NSObject<br>&gt;&gt; -(MySet&lt;T&gt; *)unionWithSet:(MySet&lt;T&gt; *)otherSet;<br>&gt;&gt; @end<br>&gt;&gt; <br>&gt;&gt; @interface MySomething : NSObject<br>&gt;&gt; - (MySet&lt;NSValue *&gt; *)valueSet;<br>&gt;&gt; @end<br>&gt;&gt; will be imported as:<br>&gt;&gt; <br>&gt;&gt; class MySet&lt;T : NSCopying&gt; : NSObject {<br>&gt;&gt;   func unionWithSet(otherSet: MySet&lt;T&gt;) -&gt; MySet&lt;T&gt;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class MySomething : NSObject {<br>&gt;&gt;   func valueSet() -&gt; MySet&lt;NSValue&gt;<br>&gt;&gt; }<br>&gt;&gt; Importing unspecialized types<br>&gt;&gt; <br>&gt;&gt; When importing an unspecialized Objective-C type into Swift, we will substitute the bounds for the type arguments. For example:<br>&gt;&gt; <br>&gt;&gt; @interface MySomething (ObjectSet)<br>&gt;&gt; - (MySet *)objectSet;    // note: no type arguments to MySet<br>&gt;&gt; @end<br>&gt;&gt; will be imported as:<br>&gt;&gt; <br>&gt;&gt; extension MySomething {<br>&gt;&gt;   func objectSet() -&gt; MySet&lt;NSCopying&gt; // note: uses the type bound<br>&gt;&gt; }<br>&gt;&gt; Restrictions on uses of Objective-C parameterized classes<br>&gt;&gt; <br>&gt;&gt; While the Swift and Objective-C generics systems look similar on the surface, they use fundamentally different semantic models. Specifically, Objective-C lightweight generics are based on type erasure, so we cannot in general recover the type arguments from the metaclass of an Objective-C parameterized class (i.e., because MySet, MySet&lt;NSString *&gt;, and MySet&lt;NSNumber *&gt; all share a metaclass). This leads to several restrictions:<br>&gt;&gt; <br>&gt;&gt; Downcasting to an instance or metatype of a parameterized Objective-C class is inherently uncheckable, so we place limits on such casts. For example,<br>&gt;&gt; <br>&gt;&gt; let obj: AnyObject = ...<br>&gt;&gt; if let set1 = obj as? MySet&lt;NSCopying&gt; {<br>&gt;&gt;   // okay: every MySet is a MySet&lt;NSCopying&gt; by construction, so<br>&gt;&gt;   // we&#39;re just checking that this is a &#39;MySet&#39;.<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; if let set2 = obj as? MySet&lt;NSNumber&gt; {<br>&gt;&gt;   // error: conditional cast to specialized Objective-C instance<br>&gt;&gt;   // doesn&#39;t check type argument &#39;NSNumber&#39;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let set3 = obj as! MySet&lt;NSNumber&gt; // okay: we assert that it is safe<br>&gt;&gt; <br>&gt;&gt; if let set4 = obj as? MySet&lt;NSCopying&gt; {<br>&gt;&gt;   let set5 = set4 as! MySet&lt;NSNumber&gt; // here&#39;s how to get a MySet&lt;NSNumber&gt;<br>&gt;&gt; }<br>&gt;&gt; Extensions of parameterized Objective-C classes cannot reference the type paramaeters in any way. For example:<br>&gt;&gt; <br>&gt;&gt; extension MySet {<br>&gt;&gt;   func someNewMethod(x: T) { ... } // error: cannot use `T`.<br>&gt;&gt; }<br>&gt;&gt; Opting in to type argument discovery<br>&gt;&gt; <br>&gt;&gt; Some Objective-C parameterized classes do carry information about their type arguments. When this is the case, it is possible to lift some of the restrictions described in the above section. There are two distinct cases:<br>&gt;&gt; <br>&gt;&gt; Abstract parameterized classes whose concrete subclasses are not parameterized: NSLayoutAnchor is one such example: it is parameterized on the anchor type, but there is a fixed set of such anchor types that are represented by subclasses: NSLayoutXAxisAnchor subclasses NSLayoutAnchor&lt;NSLayoutXAxisAnchor *&gt;, NSLayoutDimensionsubclasses NSLayoutAnchor&lt;NSLayoutDimension *&gt;, etc. Therefore, the type arguments can be recovered by looking at the actual metaclass.<br>&gt;&gt; <br>&gt;&gt; Parameterized classes that store their type arguments in instances: GKComponentSystem is one such example: it is parameterized on the component type it stores, but it&#39;s initializer (-initWithComponentClass:) requires one to pass the component type&#39;s metaclass. Therefore, every instance of GKComponentSystem knows its type arguments.<br>&gt;&gt; <br>&gt;&gt; A parameterized Objective-C class can opt in to providing information about its type argument by implementing a methodclassForGenericArgumentAtIndex: either as a class method (for the first case described above) or as an instance method (for the second case described above). The method returns the metaclass for the type argument at the given, zero-based index.<br>&gt;&gt; <br>&gt;&gt; For example, NSLayoutAnchor would provide a class method classForGenericArgumentAtIndex: that must be implemented by each of its subclasses:<br>&gt;&gt; <br>&gt;&gt; @interface NSLayoutAnchor&lt;AnchorType&gt; (SwiftSupport)<br>&gt;&gt; /// Note: must be implemented by each subclass<br>&gt;&gt; +(nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index;<br>&gt;&gt; @end<br>&gt;&gt; <br>&gt;&gt; @implementation NSLayoutAnchor<br>&gt;&gt; +(nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index {<br>&gt;&gt;   NSAssert(false, @&quot;subclass must override +classForGenericArgumentAtIndex:&quot;);<br>&gt;&gt; }<br>&gt;&gt; @end<br>&gt;&gt; <br>&gt;&gt; @implementation NSLayoutXAxisAnchor (SwiftSupport)<br>&gt;&gt; +(nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index {<br>&gt;&gt;   return [NSLayoutXAxisAnchor class];<br>&gt;&gt; }<br>&gt;&gt; @end<br>&gt;&gt; <br>&gt;&gt; @implementation NSLayoutYAxisAnchor (SwiftSupport)<br>&gt;&gt; +(nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index {<br>&gt;&gt;   return [NSLayoutYAxisAnchor class];<br>&gt;&gt; }<br>&gt;&gt; @end<br>&gt;&gt; <br>&gt;&gt; @implementation NSLayoutDimension (SwiftSupport)<br>&gt;&gt; +(nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index {<br>&gt;&gt;   return [NSLayoutDimension class];<br>&gt;&gt; }<br>&gt;&gt; @end<br>&gt;&gt; On the other hand, GKComponentSystem would implement an instance method classForGenericArgumentAtIndex::<br>&gt;&gt; <br>&gt;&gt; @interface GKComponentSystem&lt;ComponentType : GKComponent *&gt; (SwiftSupport)<br>&gt;&gt; - (nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index;<br>&gt;&gt; @end<br>&gt;&gt; <br>&gt;&gt; @implementation GKComponentSystem (SwiftSupport)<br>&gt;&gt; - (nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index {<br>&gt;&gt;   return self.componentClass;<br>&gt;&gt; }<br>&gt;&gt; @end<br>&gt;&gt; Note that many parameterized Objective-C classes cannot provide either of these methods, because they don&#39;t carry enough information in their instances. For example, an NSMutableArray has no record of what the element type of the array is intended to be.<br>&gt;&gt; <br>&gt;&gt; However, when a parameterized class does provide this information, we can lift some of the restrictions from the previous section:<br>&gt;&gt; <br>&gt;&gt; If the parameterized class provides an instance method classForGenericArgumentAtIndex:, the extension can use the type arguments in its instance methods, including accessors for instance properties and subscripts. For example:<br>&gt;&gt; <br>&gt;&gt; extension GKComponentSystem {<br>&gt;&gt;   var reversedComponents: [ComponentType] {<br>&gt;&gt;     return components.reversed()<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   static func notifyComponents(components: [ComponentType]) {<br>&gt;&gt;     // error: cannot use `ComponentType` in a static method<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; If the parametized class provides a class method classForGenericArgumentAtIndex:, the extension can use type arguments anywhere.<br>&gt;&gt; <br>&gt;&gt; extension NSLayoutAnchor {<br>&gt;&gt;   func doSomething(x: AnchorType) { ... }<br>&gt;&gt;   class func doSomethingClassy(x: AnchorType) { ... }<br>&gt;&gt; }<br>&gt;&gt; Subclassing parameterized Objective-C classes from Swift<br>&gt;&gt; <br>&gt;&gt; When subclassing a parameterized Objective-C class from Swift, the Swift compiler will define +classForGenericArgumentAtIndex: and -classForGenericArgumentAtIndex:. The Swift compiler has the complete type metadata required, because it is stored in the (Swift) type metadata, so these definitions will be correct. For example:<br>&gt;&gt; <br>&gt;&gt; class Employee : NSObject { ... }<br>&gt;&gt; <br>&gt;&gt; class EmployeeArray : NSMutableArray&lt;Employee&gt; {<br>&gt;&gt;   // +[EmployeeArray classForGenericArgumentAtIndex:] always returns<br>&gt;&gt;   // ObjC type metadata for Employee<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class MyMutableArray&lt;T : AnyObject&gt; : NSMutableArray&lt;T&gt; {<br>&gt;&gt;   // +[MyMutableArray classForGenericArgumentAtIndex:] returns the<br>&gt;&gt;   // ObjC type metadata for T, extracted from the Swift metatype for<br>&gt;&gt;   // `self`.<br>&gt;&gt; }<br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; In Swift 2, parameterized Objective-C classes are imported as non-parameterized classes. Importing them as parameterized classes will break any existing references to the affecting APIs. There are a handful of cases where type inference may paper over the problems:<br>&gt;&gt; <br>&gt;&gt; let array: NSArray = [&quot;hello&quot;, &quot;world&quot;] // okay, infer NSArray&lt;NSString&gt;<br>&gt;&gt; // old<br>&gt;&gt; <br>&gt;&gt; var mutArray = NSMutableArray() // error: need type arguments for NSMutableArray<br>&gt;&gt; A migrator could introduce the type bounds as arguments, e.g., NSArray would get migrated to NSArray&lt;AnyObject&gt;. It is not the best migration---many developers would likely want to tighten up the bounds to improve their Swift code---but it should migrate existing code.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; The only major alternative design involves bringing type erasure into the Swift generics system as an alternative implementation. It would lift the restrictions on extensions of parameterized Objective-C classes by treating type parameters in such contexts as the type bounds:<br>&gt;&gt; <br>&gt;&gt; extension MySet {<br>&gt;&gt;   func someNewMethod(x: T) { ... } // okay: `T` is treated like `NSCopying`<br>&gt;&gt; }<br>&gt;&gt; Doing so could allow the use of &quot;unspecialized&quot; generic types within Swift, e.g., NSMutableArray with no type bounds (possibly spelled NSMutableArray&lt;*&gt;), which would more accurately represent Objective-C semantics in Swift.<br>&gt;&gt; <br>&gt;&gt; However, doing so comes at the cost of having two incompatible generics models implemented in Swift, which produces both a high conceptual burden as well as a high implementation cost. The proposed solution implies less implementation cost and puts the limitations on what one can express when working with parameterized Objective-C classes without fundamentally changing the Swift model.<br>&gt;&gt; Status API Training Shop Blog About Pricing<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/a710060d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Proposal Draft] Importing Objective-C Lightweight Generics</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>January  9, 2016 at 09:00:00pm</p></header><div class="content"><p>Could you include in the proposal an explicit example of how something like this would get imported to Swift:<br></p><p>@interface CoordinatorView&lt;T:UIView*&gt; : UIView<br></p><p>@property(nonatomic, strong, nonnull) NSArray&lt;T&gt; *normalSubviews;<br>@property(nonatomic, strong, nonnull) NSArray&lt;T&lt;RichViewProtocol&gt;&gt; *richSubviews;<br>// ^ this one, specifically<br></p><p>@end<br></p><p>…?<br></p><p>&gt; On Jan 9, 2016, at 5:50 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; <br>&gt; Here’s a proposal I’m working on to import Objective-C lightweight generics as generic classes in Swift. It’s also available here:<br>&gt; <br>&gt; 	https://github.com/DougGregor/swift-evolution/blob/importing-objc-generics/proposals/0000-importing-objc-generics.md &lt;https://github.com/DougGregor/swift-evolution/blob/importing-objc-generics/proposals/0000-importing-objc-generics.md&gt;<br>&gt; <br>&gt; Comments welcome!<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; Importing Objective-C Lightweight Generics<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-importing-objc-generics.md&gt;<br>&gt; Author: Doug Gregor &lt;https://github.com/DougGregor&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#introduction&gt;Introduction<br>&gt; <br>&gt; Objective-C&#39;s lightweight generics feature allows Objective-C classes to be parameterized on the types they work with, similarly to Swift&#39;s generics syntax. Their adoption in Foundation&#39;s collection classes allow Objective-C APIs to be bridged more effectively into Swift. For example, an NSArray&lt;NSString *&gt; * bridges to [String] rather than the far-weaker [AnyObject]. However, parameterized Objective-C classes lose their type parameters when they are imported into Swift, so uses of type parameters outside of bridged, typed collections (NSArray, NSDictionary, NSSet) don&#39;t benefit in Swift. This proposal introduces a way to import the type parameters of Objective-C classes into Swift.<br>&gt; <br>&gt; Swift-evolution thread: TODO &lt;https://lists.swift.org/pipermail/swift-evolution&gt;<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#motivation&gt;Motivation<br>&gt; <br>&gt; Cocoa and Cocoa Touch include a number of APIs that have adopted Objective-C lightweight generics to improve static type safety and expressiveness. However, because the type parameters are lost when these APIs are imported into Swift, they are effectively less type safe in Swift than in Objective-C, a situation we clearly cannot abide. This proposal aims to improve the projection of these Objective-C APIs in Swift.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; A parameterized class written in Objective-C will be imported into Swift as a generic class with the same number of type parameters. The bounds on the type parameters in Objective-C will be translated into requirements on the generic type parameters in Swift:<br>&gt; <br>&gt; The generic type parameters in Swift will always be class-bound, i.e., the generic class will have the requirement T : AnyObject.<br>&gt; If the bound includes a class type (e.g., T : NSValue * in Objective-C), the generic Swift class will have the corresponding superclass requirement (T : NSValue).<br>&gt; If the bound includes protocol qualification (e.g., T : id&lt;NSCopying&gt; in Objective-C), each protocol bound is turned into a conformance requirement (T : NSCopying) on the generic Swift class.<br>&gt; The following Objective-C code:<br>&gt; <br>&gt; @interface MySet&lt;T : id&lt;NSCopying&gt;&gt; : NSObject<br>&gt; -(MySet&lt;T&gt; *)unionWithSet:(MySet&lt;T&gt; *)otherSet;<br>&gt; @end<br>&gt; <br>&gt; @interface MySomething : NSObject<br>&gt; - (MySet&lt;NSValue *&gt; *)valueSet;<br>&gt; @end<br>&gt; will be imported as:<br>&gt; <br>&gt; class MySet&lt;T : NSCopying&gt; : NSObject {<br>&gt;   func unionWithSet(otherSet: MySet&lt;T&gt;) -&gt; MySet&lt;T&gt;<br>&gt; }<br>&gt; <br>&gt; class MySomething : NSObject {<br>&gt;   func valueSet() -&gt; MySet&lt;NSValue&gt;<br>&gt; }<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#importing-unspecialized-types&gt;Importing unspecialized types<br>&gt; <br>&gt; When importing an unspecialized Objective-C type into Swift, we will substitute the bounds for the type arguments. For example:<br>&gt; <br>&gt; @interface MySomething (ObjectSet)<br>&gt; - (MySet *)objectSet;    // note: no type arguments to MySet<br>&gt; @end<br>&gt; will be imported as:<br>&gt; <br>&gt; extension MySomething {<br>&gt;   func objectSet() -&gt; MySet&lt;NSCopying&gt; // note: uses the type bound<br>&gt; }<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#restrictions-on-uses-of-objective-c-parameterized-classes&gt;Restrictions on uses of Objective-C parameterized classes<br>&gt; <br>&gt; While the Swift and Objective-C generics systems look similar on the surface, they use fundamentally different semantic models. Specifically, Objective-C lightweight generics are based on type erasure, so we cannot in general recover the type arguments from the metaclass of an Objective-C parameterized class (i.e., because MySet, MySet&lt;NSString *&gt;, and MySet&lt;NSNumber *&gt; all share a metaclass). This leads to several restrictions:<br>&gt; <br>&gt; Downcasting to an instance or metatype of a parameterized Objective-C class is inherently uncheckable, so we place limits on such casts. For example,<br>&gt; <br>&gt; let obj: AnyObject = ...<br>&gt; if let set1 = obj as? MySet&lt;NSCopying&gt; {<br>&gt;   // okay: every MySet is a MySet&lt;NSCopying&gt; by construction, so<br>&gt;   // we&#39;re just checking that this is a &#39;MySet&#39;.<br>&gt; }<br>&gt; <br>&gt; if let set2 = obj as? MySet&lt;NSNumber&gt; {<br>&gt;   // error: conditional cast to specialized Objective-C instance<br>&gt;   // doesn&#39;t check type argument &#39;NSNumber&#39;<br>&gt; }<br>&gt; <br>&gt; let set3 = obj as! MySet&lt;NSNumber&gt; // okay: we assert that it is safe<br>&gt; <br>&gt; if let set4 = obj as? MySet&lt;NSCopying&gt; {<br>&gt;   let set5 = set4 as! MySet&lt;NSNumber&gt; // here&#39;s how to get a MySet&lt;NSNumber&gt;<br>&gt; }<br>&gt; Extensions of parameterized Objective-C classes cannot reference the type paramaeters in any way. For example:<br>&gt; <br>&gt; extension MySet {<br>&gt;   func someNewMethod(x: T) { ... } // error: cannot use `T`.<br>&gt; }<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#opting-in-to-type-argument-discovery&gt;Opting in to type argument discovery<br>&gt; <br>&gt; Some Objective-C parameterized classes do carry information about their type arguments. When this is the case, it is possible to lift some of the restrictions described in the above section. There are two distinct cases:<br>&gt; <br>&gt; Abstract parameterized classes whose concrete subclasses are not parameterized: NSLayoutAnchor &lt;https://developer.apple.com/library/mac/documentation/AppKit/Reference/NSLayoutAnchor_ClassReference/index.html#//apple_ref/occ/cl/NSLayoutAnchor&gt; is one such example: it is parameterized on the anchor type, but there is a fixed set of such anchor types that are represented by subclasses: NSLayoutXAxisAnchor subclasses NSLayoutAnchor&lt;NSLayoutXAxisAnchor *&gt;, NSLayoutDimensionsubclasses NSLayoutAnchor&lt;NSLayoutDimension *&gt;, etc. Therefore, the type arguments can be recovered by looking at the actual metaclass.<br>&gt; <br>&gt; Parameterized classes that store their type arguments in instances: GKComponentSystem &lt;https://developer.apple.com/library/ios/documentation/GameplayKit/Reference/GKComponentSystem_Class/&gt; is one such example: it is parameterized on the component type it stores, but it&#39;s initializer (-initWithComponentClass:) requires one to pass the component type&#39;s metaclass. Therefore, every instance of GKComponentSystem knows its type arguments.<br>&gt; <br>&gt; A parameterized Objective-C class can opt in to providing information about its type argument by implementing a methodclassForGenericArgumentAtIndex: either as a class method (for the first case described above) or as an instance method (for the second case described above). The method returns the metaclass for the type argument at the given, zero-based index.<br>&gt; <br>&gt; For example, NSLayoutAnchor would provide a class method classForGenericArgumentAtIndex: that must be implemented by each of its subclasses:<br>&gt; <br>&gt; @interface NSLayoutAnchor&lt;AnchorType&gt; (SwiftSupport)<br>&gt; /// Note: must be implemented by each subclass<br>&gt; +(nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index;<br>&gt; @end<br>&gt; <br>&gt; @implementation NSLayoutAnchor<br>&gt; +(nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index {<br>&gt;   NSAssert(false, @&quot;subclass must override +classForGenericArgumentAtIndex:&quot;);<br>&gt; }<br>&gt; @end<br>&gt; <br>&gt; @implementation NSLayoutXAxisAnchor (SwiftSupport)<br>&gt; +(nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index {<br>&gt;   return [NSLayoutXAxisAnchor class];<br>&gt; }<br>&gt; @end<br>&gt; <br>&gt; @implementation NSLayoutYAxisAnchor (SwiftSupport)<br>&gt; +(nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index {<br>&gt;   return [NSLayoutYAxisAnchor class];<br>&gt; }<br>&gt; @end<br>&gt; <br>&gt; @implementation NSLayoutDimension (SwiftSupport)<br>&gt; +(nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index {<br>&gt;   return [NSLayoutDimension class];<br>&gt; }<br>&gt; @end<br>&gt; On the other hand, GKComponentSystem would implement an instance method classForGenericArgumentAtIndex::<br>&gt; <br>&gt; @interface GKComponentSystem&lt;ComponentType : GKComponent *&gt; (SwiftSupport)<br>&gt; - (nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index;<br>&gt; @end<br>&gt; <br>&gt; @implementation GKComponentSystem (SwiftSupport)<br>&gt; - (nonnull Class)classForGenericArgumentAtIndex:(NSUInteger)index {<br>&gt;   return self.componentClass;<br>&gt; }<br>&gt; @end<br>&gt; Note that many parameterized Objective-C classes cannot provide either of these methods, because they don&#39;t carry enough information in their instances. For example, an NSMutableArray has no record of what the element type of the array is intended to be.<br>&gt; <br>&gt; However, when a parameterized class does provide this information, we can lift some of the restrictions from the previous section:<br>&gt; <br>&gt; If the parameterized class provides an instance method classForGenericArgumentAtIndex:, the extension can use the type arguments in its instance methods, including accessors for instance properties and subscripts. For example:<br>&gt; <br>&gt; extension GKComponentSystem {<br>&gt;   var reversedComponents: [ComponentType] {<br>&gt;     return components.reversed()<br>&gt;   }<br>&gt; <br>&gt;   static func notifyComponents(components: [ComponentType]) {<br>&gt;     // error: cannot use `ComponentType` in a static method<br>&gt;   }<br>&gt; }<br>&gt; If the parametized class provides a class method classForGenericArgumentAtIndex:, the extension can use type arguments anywhere.<br>&gt; <br>&gt; extension NSLayoutAnchor {<br>&gt;   func doSomething(x: AnchorType) { ... }<br>&gt;   class func doSomethingClassy(x: AnchorType) { ... }<br>&gt; }<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#subclassing-parameterized-objective-c-classes-from-swift&gt;Subclassing parameterized Objective-C classes from Swift<br>&gt; <br>&gt; When subclassing a parameterized Objective-C class from Swift, the Swift compiler will define +classForGenericArgumentAtIndex: and -classForGenericArgumentAtIndex:. The Swift compiler has the complete type metadata required, because it is stored in the (Swift) type metadata, so these definitions will be correct. For example:<br>&gt; <br>&gt; class Employee : NSObject { ... }<br>&gt; <br>&gt; class EmployeeArray : NSMutableArray&lt;Employee&gt; {<br>&gt;   // +[EmployeeArray classForGenericArgumentAtIndex:] always returns<br>&gt;   // ObjC type metadata for Employee<br>&gt; }<br>&gt; <br>&gt; class MyMutableArray&lt;T : AnyObject&gt; : NSMutableArray&lt;T&gt; {<br>&gt;   // +[MyMutableArray classForGenericArgumentAtIndex:] returns the<br>&gt;   // ObjC type metadata for T, extracted from the Swift metatype for<br>&gt;   // `self`.<br>&gt; }<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; In Swift 2, parameterized Objective-C classes are imported as non-parameterized classes. Importing them as parameterized classes will break any existing references to the affecting APIs. There are a handful of cases where type inference may paper over the problems:<br>&gt; <br>&gt; let array: NSArray = [&quot;hello&quot;, &quot;world&quot;] // okay, infer NSArray&lt;NSString&gt;<br>&gt; // old<br>&gt; <br>&gt; var mutArray = NSMutableArray() // error: need type arguments for NSMutableArray<br>&gt; A migrator could introduce the type bounds as arguments, e.g., NSArray would get migrated to NSArray&lt;AnyObject&gt;. It is not the best migration---many developers would likely want to tighten up the bounds to improve their Swift code---but it should migrate existing code.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/tree/importing-objc-generics#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; The only major alternative design involves bringing type erasure into the Swift generics system as an alternative implementation. It would lift the restrictions on extensions of parameterized Objective-C classes by treating type parameters in such contexts as the type bounds:<br>&gt; <br>&gt; extension MySet {<br>&gt;   func someNewMethod(x: T) { ... } // okay: `T` is treated like `NSCopying`<br>&gt; }<br>&gt; Doing so could allow the use of &quot;unspecialized&quot; generic types within Swift, e.g., NSMutableArray with no type bounds (possibly spelled NSMutableArray&lt;*&gt;), which would more accurately represent Objective-C semantics in Swift.<br>&gt; <br>&gt; However, doing so comes at the cost of having two incompatible generics models implemented in Swift, which produces both a high conceptual burden as well as a high implementation cost. The proposed solution implies less implementation cost and puts the limitations on what one can express when working with parameterized Objective-C classes without fundamentally changing the Swift model.<br>&gt; Status &lt;https://status.github.com/&gt; API &lt;https://developer.github.com/&gt; Training &lt;https://training.github.com/&gt; Shop &lt;https://shop.github.com/&gt; Blog &lt;https://github.com/blog&gt; About &lt;https://github.com/about&gt; Pricing &lt;https://github.com/pricing&gt; &lt;https://github.com/&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/3175808d/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
