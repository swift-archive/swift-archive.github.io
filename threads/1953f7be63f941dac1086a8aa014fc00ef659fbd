<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d2801909c31fdeb277ad069243d14f36?s=50"></div><header><strong>Huge difference in speed in Array&lt;Class&gt;/Array&lt;Struct&gt; on OSX/Ubuntu platform with same? toolchain</strong> from <string>Sergey Kuratov</string> &lt;ksubox.swift at gmail.com&gt;<p>January 29, 2016 at 03:00:00pm</p></header><div class="content"><p>Hello,<br>I&#39;ve just started to work with Swift (have C++ background) and try to make<br>some tests to avoid problems in design. But from beginning I met very<br>disappointing case.<br></p><p>1. So I have 2 similar computers:<br>- Ubuntu 15.10 with clang and Swift-2.2 dev 2016.01.25 for Ubuntu 15.10<br>- iMac with OSX 10.11 and  Swift-2.2 dev 2016.01.25 fro OSX (switched to<br>this toolchain)<br></p><p>2. Took extremely simple source code from n-body sample<br>&lt;http://benchmarksgame.alioth.debian.org/u64q/program.php?test=nbody&amp;lang=swift&amp;id=3&gt;<br></p><p>3. Set Release version with -Ounchecked -whole-module-optimization for both<br>computers and get results:<br></p><p>Ubuntu - 8.4 sec<br>OSX - 167.3 sec<br>Was demolished by results<br></p><p>4. Changed &quot;class Body&quot; to &quot;struct Body&quot; and get another results:<br></p><p>Ubuntu - 12.2 sec<br>OSX - 10.0 sec<br>Again was deeply moved by results<br></p><p>5. Added<br>*let arrPtr = UnsafeMutablePointer&lt;Body&gt;(bodies)*<br>before loops and used arrPtr instead of bodies in loops. Got new result:<br></p><p>For &quot;class Body&quot; variant:<br>Ubuntu - 7.3 sec<br>OSX - 11.1 sec<br></p><p>For &quot;struct Body&quot; variant:<br>Ubuntu - 6.7 sec<br>OSX - 8.8 sec<br></p><p>I believe something wrong with Swift compiler/optimizer if for the same x64<br>processor same toolchain generate very different code. Especially in 1 case<br>with &quot;class Body&quot; on OSX platform - I guess it&#39;s bug. Can somebody comment<br>results ?<br></p><p>PS: Forgot to say - similar Java program n-body in Java<br>&lt;http://benchmarksgame.alioth.debian.org/u64q/program.php?test=nbody&amp;lang=java&amp;id=2&gt;<br>takes 6.5 sec on Ubuntu and 9.2 sec on OSX<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160129/19539fbd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Huge difference in speed in Array&lt;Class&gt;/Array&lt;Struct&gt; on OSX/Ubuntu platform with same? toolchain</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 29, 2016 at 11:00:00am</p></header><div class="content"><p>Arrays of class type have additional overhead on Apple platforms due to the NSArray interoperability. You can use ContiguousArray&lt;Class&gt; if you don&#39;t need to interoperate with Objective-C to get more consistent performance.<br></p><p>-Joe<br></p><p>&gt; On Jan 28, 2016, at 10:30 PM, Sergey Kuratov via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello,<br>&gt; I&#39;ve just started to work with Swift (have C++ background) and try to make some tests to avoid problems in design. But from beginning I met very disappointing case.<br>&gt; <br>&gt; 1. So I have 2 similar computers:<br>&gt; - Ubuntu 15.10 with clang and Swift-2.2 dev 2016.01.25 for Ubuntu 15.10<br>&gt; - iMac with OSX 10.11 and  Swift-2.2 dev 2016.01.25 fro OSX (switched to this toolchain)<br>&gt; <br>&gt; 2. Took extremely simple source code from n-body sample &lt;http://benchmarksgame.alioth.debian.org/u64q/program.php?test=nbody&amp;lang=swift&amp;id=3&gt;<br>&gt; <br>&gt; 3. Set Release version with -Ounchecked -whole-module-optimization for both computers and get results:<br>&gt; <br>&gt; Ubuntu - 8.4 sec<br>&gt; OSX - 167.3 sec<br>&gt; Was demolished by results<br>&gt; <br>&gt; 4. Changed &quot;class Body&quot; to &quot;struct Body&quot; and get another results:<br>&gt; <br>&gt; Ubuntu - 12.2 sec<br>&gt; OSX - 10.0 sec<br>&gt; Again was deeply moved by results<br>&gt; <br>&gt; 5. Added<br>&gt; let arrPtr = UnsafeMutablePointer&lt;Body&gt;(bodies)<br>&gt; before loops and used arrPtr instead of bodies in loops. Got new result:<br>&gt; <br>&gt; For &quot;class Body&quot; variant:<br>&gt; Ubuntu - 7.3 sec<br>&gt; OSX - 11.1 sec<br>&gt; <br>&gt; For &quot;struct Body&quot; variant:<br>&gt; Ubuntu - 6.7 sec<br>&gt; OSX - 8.8 sec<br>&gt; <br>&gt; I believe something wrong with Swift compiler/optimizer if for the same x64 processor same toolchain generate very different code. Especially in 1 case with &quot;class Body&quot; on OSX platform - I guess it&#39;s bug. Can somebody comment results ?<br>&gt; <br>&gt; PS: Forgot to say - similar Java program n-body in Java &lt;http://benchmarksgame.alioth.debian.org/u64q/program.php?test=nbody&amp;lang=java&amp;id=2&gt; takes 6.5 sec on Ubuntu and 9.2 sec on OSX<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160129/5905511c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>Huge difference in speed in Array&lt;Class&gt;/Array&lt;Struct&gt; on OSX/Ubuntu platform with same? toolchain</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>January 29, 2016 at 02:00:00pm</p></header><div class="content"><p>I haven&#39;t looked at the bridging code yet, but is it possible that the<br>overhead could only be incurred on the first conversion to NSArray? That<br>way if you don&#39;t use that functionality it&#39;s consistent across platforms,<br>and if you do use it, you get an initial O(n) hit and then O(1) afterwards.<br></p><p>On Fri, Jan 29, 2016 at 2:27 PM, Joe Groff via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; Arrays of class type have additional overhead on Apple platforms due to<br>&gt; the NSArray interoperability. You can use ContiguousArray&lt;Class&gt; if you<br>&gt; don&#39;t need to interoperate with Objective-C to get more consistent<br>&gt; performance.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; On Jan 28, 2016, at 10:30 PM, Sergey Kuratov via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt; Hello,<br>&gt; I&#39;ve just started to work with Swift (have C++ background) and try to make<br>&gt; some tests to avoid problems in design. But from beginning I met very<br>&gt; disappointing case.<br>&gt;<br>&gt; 1. So I have 2 similar computers:<br>&gt; - Ubuntu 15.10 with clang and Swift-2.2 dev 2016.01.25 for Ubuntu 15.10<br>&gt; - iMac with OSX 10.11 and  Swift-2.2 dev 2016.01.25 fro OSX (switched to<br>&gt; this toolchain)<br>&gt;<br>&gt; 2. Took extremely simple source code from n-body sample<br>&gt; &lt;http://benchmarksgame.alioth.debian.org/u64q/program.php?test=nbody&amp;lang=swift&amp;id=3&gt;<br>&gt;<br>&gt; 3. Set Release version with -Ounchecked -whole-module-optimization for<br>&gt; both computers and get results:<br>&gt;<br>&gt; Ubuntu - 8.4 sec<br>&gt; OSX - 167.3 sec<br>&gt; Was demolished by results<br>&gt;<br>&gt; 4. Changed &quot;class Body&quot; to &quot;struct Body&quot; and get another results:<br>&gt;<br>&gt; Ubuntu - 12.2 sec<br>&gt; OSX - 10.0 sec<br>&gt; Again was deeply moved by results<br>&gt;<br>&gt; 5. Added<br>&gt; *let arrPtr = UnsafeMutablePointer&lt;Body&gt;(bodies)*<br>&gt; before loops and used arrPtr instead of bodies in loops. Got new result:<br>&gt;<br>&gt; For &quot;class Body&quot; variant:<br>&gt; Ubuntu - 7.3 sec<br>&gt; OSX - 11.1 sec<br>&gt;<br>&gt; For &quot;struct Body&quot; variant:<br>&gt; Ubuntu - 6.7 sec<br>&gt; OSX - 8.8 sec<br>&gt;<br>&gt; I believe something wrong with Swift compiler/optimizer if for the same<br>&gt; x64 processor same toolchain generate very different code. Especially in 1<br>&gt; case with &quot;class Body&quot; on OSX platform - I guess it&#39;s bug. Can somebody<br>&gt; comment results ?<br>&gt;<br>&gt; PS: Forgot to say - similar Java program n-body in Java<br>&gt; &lt;http://benchmarksgame.alioth.debian.org/u64q/program.php?test=nbody&amp;lang=java&amp;id=2&gt;<br>&gt; takes 6.5 sec on Ubuntu and 9.2 sec on OSX<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160129/ffe3fe03/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Huge difference in speed in Array&lt;Class&gt;/Array&lt;Struct&gt; on OSX/Ubuntu platform with same? toolchain</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 29, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 29, 2016, at 11:32 AM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt; <br>&gt; I haven&#39;t looked at the bridging code yet, but is it possible that the overhead could only be incurred on the first conversion to NSArray? That way if you don&#39;t use that functionality it&#39;s consistent across platforms, and if you do use it, you get an initial O(n) hit and then O(1) afterwards.<br></p><p>Dave Abrahams can probably elaborate on the history better than me, but the current design balances a number of considerations. Microbenchmarks tend to be poor indicators of real-world performance, and in most Cocoa application code, arrays are shuttled into and out of Cocoa pretty frequently, so forcing every index read operation to do a deep conversion was unacceptable.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d2801909c31fdeb277ad069243d14f36?s=50"></div><header><strong>Huge difference in speed in Array&lt;Class&gt;/Array&lt;Struct&gt; on OSX/Ubuntu platform with same? toolchain</strong> from <string>Sergey Kuratov</string> &lt;ksubox.swift at gmail.com&gt;<p>January 30, 2016 at 12:00:00pm</p></header><div class="content"><p>Basically I understand what&#39;s going on (especially from Instruments), but<br>question is not about implementation.<br>I&#39;m speaking about UNIFORM behaviour for all platform (actually I guess we<br>will see Windows/Android and so on ports).<br>So Array on Linux should work as Array on OSX, Windows, Android, ....<br>If we need specific OS behaviour we should make specific class like<br>ObjcArray&lt;Class&gt;, .... Isn&#39;t it right way ?<br>Or at least in language guide should be written &quot;Use Array only if you need<br>to interact with ObjC runtime...&quot; and of course same about all other ObjC<br>classes. Right ?<br></p><p><br>On Sat, Jan 30, 2016 at 5:55 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jan 29, 2016, at 11:32 AM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I haven&#39;t looked at the bridging code yet, but is it possible that the<br>&gt; overhead could only be incurred on the first conversion to NSArray? That<br>&gt; way if you don&#39;t use that functionality it&#39;s consistent across platforms,<br>&gt; and if you do use it, you get an initial O(n) hit and then O(1) afterwards.<br>&gt;<br>&gt; Dave Abrahams can probably elaborate on the history better than me, but<br>&gt; the current design balances a number of considerations. Microbenchmarks<br>&gt; tend to be poor indicators of real-world performance, and in most Cocoa<br>&gt; application code, arrays are shuttled into and out of Cocoa pretty<br>&gt; frequently, so forcing every index read operation to do a deep conversion<br>&gt; was unacceptable.<br>&gt;<br>&gt; -Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160130/44095815/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Huge difference in speed in Array&lt;Class&gt;/Array&lt;Struct&gt; on OSX/Ubuntu platform with same? toolchain</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February  1, 2016 at 02:00:00pm</p></header><div class="content"><p>on Fri Jan 29 2016, Trent Nadeau &lt;swift-users-AT-swift.org&gt; wrote:<br></p><p>&gt; I haven&#39;t looked at the bridging code yet, but is it possible that the<br>&gt; overhead could only be incurred on the first conversion to NSArray? That<br>&gt; way if you don&#39;t use that functionality it&#39;s consistent across platforms,<br>&gt; and if you do use it, you get an initial O(n) hit and then O(1)<br>&gt; afterwards.<br></p><p>There&#39;s no overhead on conversion to NSArray.  The overhead applies to<br>all arrays aren&#39;t statically known not to be backed by a NSArray that<br>comes from ObjC.  In practice, that&#39;s all Arrays whose Element type is a<br>class or ObjC existential.  The overhead is due to a branch on each access,<br>where we decide whether to take the fast path (the backing storage was<br>created by Swift, a.k.a. a &quot;native&quot; buffer) or the slow path (the<br>backing storage is an otherwise unknown NSArray).  There is a similar<br>slow path for a deferred type when accessing elements in the results of<br></p><p>  someArrayOfBase as [Derived]<br></p><p>We have discussed other ways to slice the efficiency and usability<br>tradeoffs here; if you&#39;d like to talk about that I&#39;d recommend bringing<br>it up on the swift-evolution list.<br></p><p>&gt; On Fri, Jan 29, 2016 at 2:27 PM, Joe Groff via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Arrays of class type have additional overhead on Apple platforms due to<br>&gt;&gt; the NSArray interoperability. You can use ContiguousArray&lt;Class&gt; if you<br>&gt;&gt; don&#39;t need to interoperate with Objective-C to get more consistent<br>&gt;&gt; performance.<br>&gt;&gt;<br>&gt;&gt; -Joe<br>&gt;&gt;<br>&gt;&gt; On Jan 28, 2016, at 10:30 PM, Sergey Kuratov via swift-users &lt;<br>&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hello,<br>&gt;&gt; I&#39;ve just started to work with Swift (have C++ background) and try to make<br>&gt;&gt; some tests to avoid problems in design. But from beginning I met very<br>&gt;&gt; disappointing case.<br>&gt;&gt;<br>&gt;&gt; 1. So I have 2 similar computers:<br>&gt;&gt; - Ubuntu 15.10 with clang and Swift-2.2 dev 2016.01.25 for Ubuntu 15.10<br>&gt;&gt; - iMac with OSX 10.11 and  Swift-2.2 dev 2016.01.25 fro OSX (switched to<br>&gt;&gt; this toolchain)<br>&gt;&gt;<br>&gt;&gt; 2. Took extremely simple source code from n-body sample<br>&gt;&gt; &lt;http://benchmarksgame.alioth.debian.org/u64q/program.php?test=nbody&amp;lang=swift&amp;id=3&gt;<br>&gt;&gt;<br>&gt;&gt; 3. Set Release version with -Ounchecked -whole-module-optimization for<br>&gt;&gt; both computers and get results:<br>&gt;&gt;<br>&gt;&gt; Ubuntu - 8.4 sec<br>&gt;&gt; OSX - 167.3 sec<br>&gt;&gt; Was demolished by results<br>&gt;&gt;<br>&gt;&gt; 4. Changed &quot;class Body&quot; to &quot;struct Body&quot; and get another results:<br>&gt;&gt;<br>&gt;&gt; Ubuntu - 12.2 sec<br>&gt;&gt; OSX - 10.0 sec<br>&gt;&gt; Again was deeply moved by results<br>&gt;&gt;<br>&gt;&gt; 5. Added<br>&gt;&gt; *let arrPtr = UnsafeMutablePointer&lt;Body&gt;(bodies)*<br>&gt;&gt; before loops and used arrPtr instead of bodies in loops. Got new result:<br>&gt;&gt;<br>&gt;&gt; For &quot;class Body&quot; variant:<br>&gt;&gt; Ubuntu - 7.3 sec<br>&gt;&gt; OSX - 11.1 sec<br>&gt;&gt;<br>&gt;&gt; For &quot;struct Body&quot; variant:<br>&gt;&gt; Ubuntu - 6.7 sec<br>&gt;&gt; OSX - 8.8 sec<br>&gt;&gt;<br>&gt;&gt; I believe something wrong with Swift compiler/optimizer if for the same<br>&gt;&gt; x64 processor same toolchain generate very different code. Especially in 1<br>&gt;&gt; case with &quot;class Body&quot; on OSX platform - I guess it&#39;s bug. Can somebody<br>&gt;&gt; comment results ?<br>&gt;&gt;<br>&gt;&gt; PS: Forgot to say - similar Java program n-body in Java<br>&gt;&gt; &lt;http://benchmarksgame.alioth.debian.org/u64q/program.php?test=nbody&amp;lang=java&amp;id=2&gt;<br>&gt;&gt; takes 6.5 sec on Ubuntu and 9.2 sec on OSX<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;<br>&gt;&gt;<br></p><p>HTH,<br></p><p>-- <br>-Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/18c60397fcda8f42900d42ba4db4f029?s=50"></div><header><strong>Huge difference in speed in Array&lt;Class&gt;/Array&lt;Struct&gt; on OSX/Ubuntu platform with same? toolchain</strong> from <string>Nadav Rotem</string> &lt;nrotem at apple.com&gt;<p>February  2, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 29, 2016, at 11:27 AM, Joe Groff via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Arrays of class type have additional overhead on Apple platforms due to the NSArray interoperability. You can use ContiguousArray&lt;Class&gt; if you don&#39;t need to interoperate with Objective-C to get more consistent performance.<br>&gt; <br></p><p>Using ContiguousArray is a very good idea. You can find other optimization tips and tricks here:<br></p><p>https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst<br></p><p>-Nadav<br></p><p><br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 10:30 PM, Sergey Kuratov via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello,<br>&gt;&gt; I&#39;ve just started to work with Swift (have C++ background) and try to make some tests to avoid problems in design. But from beginning I met very disappointing case.<br>&gt;&gt; <br>&gt;&gt; 1. So I have 2 similar computers:<br>&gt;&gt; - Ubuntu 15.10 with clang and Swift-2.2 dev 2016.01.25 for Ubuntu 15.10<br>&gt;&gt; - iMac with OSX 10.11 and  Swift-2.2 dev 2016.01.25 fro OSX (switched to this toolchain)<br>&gt;&gt; <br>&gt;&gt; 2. Took extremely simple source code from n-body sample &lt;http://benchmarksgame.alioth.debian.org/u64q/program.php?test=nbody&amp;lang=swift&amp;id=3&gt;<br>&gt;&gt; <br>&gt;&gt; 3. Set Release version with -Ounchecked -whole-module-optimization for both computers and get results:<br>&gt;&gt; <br>&gt;&gt; Ubuntu - 8.4 sec<br>&gt;&gt; OSX - 167.3 sec<br>&gt;&gt; Was demolished by results<br>&gt;&gt; <br>&gt;&gt; 4. Changed &quot;class Body&quot; to &quot;struct Body&quot; and get another results:<br>&gt;&gt; <br>&gt;&gt; Ubuntu - 12.2 sec<br>&gt;&gt; OSX - 10.0 sec<br>&gt;&gt; Again was deeply moved by results<br>&gt;&gt; <br>&gt;&gt; 5. Added<br>&gt;&gt; let arrPtr = UnsafeMutablePointer&lt;Body&gt;(bodies)<br>&gt;&gt; before loops and used arrPtr instead of bodies in loops. Got new result:<br>&gt;&gt; <br>&gt;&gt; For &quot;class Body&quot; variant:<br>&gt;&gt; Ubuntu - 7.3 sec<br>&gt;&gt; OSX - 11.1 sec<br>&gt;&gt; <br>&gt;&gt; For &quot;struct Body&quot; variant:<br>&gt;&gt; Ubuntu - 6.7 sec<br>&gt;&gt; OSX - 8.8 sec<br>&gt;&gt; <br>&gt;&gt; I believe something wrong with Swift compiler/optimizer if for the same x64 processor same toolchain generate very different code. Especially in 1 case with &quot;class Body&quot; on OSX platform - I guess it&#39;s bug. Can somebody comment results ?<br>&gt;&gt; <br>&gt;&gt; PS: Forgot to say - similar Java program n-body in Java &lt;http://benchmarksgame.alioth.debian.org/u64q/program.php?test=nbody&amp;lang=java&amp;id=2&gt; takes 6.5 sec on Ubuntu and 9.2 sec on OSX<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160202/818c42f6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
