<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15ed660cd9d971062f9dd5084932a698?s=50"></div><header><strong>[Draft] Lazy evaluation when assigning static variables</strong> from <string>David Rönnqvist</string> &lt;david.ronnqvist at gmail.com&gt;<p>May 30, 2016 at 10:00:00pm</p></header><div class="content"><p>Several weeks ago I posted that I was confused by the differences between how static variables and lazy variables evaluated (or - as I would expect - didn’t evaluate) when initially assigned with a different value. It didn’t result in any discussion, but I encountered it again and decided to draft a proposal hoping that there will be some discussion around it. The draft is available here: https://github.com/d-ronnqvist/swift-evolution/blob/master/proposals/0000-static-var-lazy-behavior.md &lt;https://github.com/d-ronnqvist/swift-evolution/blob/master/proposals/0000-static-var-lazy-behavior.md&gt;<br></p><p>Please let me know what you think, and if you believe this is something that’s worth pursuing.<br></p><p>- David<br></p><p><br>Lazy evaluation when assigning static variables<br></p><p>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>Author(s): David Rönnqvist &lt;https://github.com/d-ronnqvist&gt;<br>Status: Awaiting review &lt;https://github.com/d-ronnqvist/swift-evolution#rationale&gt;<br>Review manager: TBD<br> &lt;https://github.com/d-ronnqvist/swift-evolution#introduction&gt;Introduction<br></p><p>Both stored type properties (static) and lazy stored properties (lazy var) are lazily initialized. However, they have different initialization behavior in that stored type properties evaluate even when assigning them a new value.<br></p><p>The following code will print &quot;static&quot;, but not &quot;lazy&quot;:<br></p><p>class Foo {<br>    static var bar: String = {<br>        print(&quot;static&quot;)<br>        return &quot;Default&quot;<br>    }()<br></p><p>    lazy var baz: String = {<br>        print(&quot;lazy&quot;)<br>        return &quot;Lazy&quot;<br>    }()<br>}<br></p><p>Foo.bar = &quot;Set&quot; // this evaluates the initial value of `bar` before setting a new value<br></p><p>let foo = Foo()<br>foo.baz = &quot;Set&quot; // this doesn&#39;t evaluate `baz` before setting a new value<br>Swift-evolution thread: [Discussion] Difference between static and lazy variables regarding evaluation of closure &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14086&gt;<br> &lt;https://github.com/d-ronnqvist/swift-evolution#motivation&gt;Motivation<br></p><p>Swift currently evaluates stored type properties even when assigning a new value. This behavior is very subtle and can lead to objects being needlessly initialized and &quot;immediately&quot; de-initialized, as well as unwanted side effects (caused by the initialized objects).<br></p><p>For example, a shared re-assignable instance that is replaced during unit test set up will initialize the &quot;real&quot; object before assigning the test replacement. <br></p><p> &lt;https://github.com/d-ronnqvist/swift-evolution#detailed-design&gt;Detailed design<br></p><p>This proposal seeks to unify the lazy evaluation on assignment of stored type properties (static) and lazy stored properties (lazy var) so that the value being replaced isn&#39;t evaluated (the current behavior of lazy stored properties). <br></p><p>However, it seeks to keep their respective behaviors and guarantees regarding multithreaded simultaneous access:<br></p><p>From the The Swift Programming Language (Swift 2.2) &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID254&gt; regarding lazy stored properties: <br></p><p>If a property marked with the lazy modifier is accessed by multiple threads simultaneously and the property has not yet been initialized, there is no guarantee that the property will be initialized only once.<br>and regarding stored type properties:<br></p><p>Stored type properties are lazily initialized on their first access. They are guaranteed to be initialized only once, even when accessed by multiple threads simultaneously, and they do not need to be marked with the lazy modifier.<br>No changes to the syntax is proposed. <br></p><p>This provides a more consistent lazy evaluation behavior, and fixes a (small) source of potential, subtle bugs.<br></p><p> &lt;https://github.com/d-ronnqvist/swift-evolution#impact-on-existing-code&gt;Impact on existing code<br></p><p>This proposal changes the lazy evaluation of stored type properties when assigning a new value. <br></p><p>Any code that is relying on this effect would break in subtle ways. This is hard to detect and migrate, but hopefully very rare (and to the best of my knowledge the behavior that code would be relying upon is undocumented).<br></p><p> &lt;https://github.com/d-ronnqvist/swift-evolution#alternatives-considered&gt;Alternatives considered<br></p><p>One alternative is to be consistent with the stored type properties and always evaluate the initial value, even when re-assigning it. However, this version doesn&#39;t address the subtle bugs that can arise from this behavior.<br></p><p>Another alternative is to leave the the respective behaviors as is and mention their differences in The Swift Programming Language guide. This might still be the most viable alternative in case the current behavior is a consequence of their respective implementations with regards to multithreaded access.<br></p><p> &lt;https://github.com/d-ronnqvist/swift-evolution#rationale&gt;Rationale<br></p><p>On [Date], the core team decided to (TBD) this proposal. When the core team makes a decision regarding this proposal, their rationale for the decision will be written here.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/baafad5e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15ed660cd9d971062f9dd5084932a698?s=50"></div><header><strong>[Draft] Lazy evaluation when assigning static variables</strong> from <string>David Rönnqvist</string> &lt;david.ronnqvist at gmail.com&gt;<p>May 31, 2016 at 08:00:00am</p></header><div class="content"><p>It appears that this email never showed up on the list. I&#39;m sending it again, with the risk of it appearing twice later. <br></p><p>&gt; 30 maj 2016 kl. 22:56 skrev Gmail &lt;david.ronnqvist at gmail.com&gt;:<br>&gt; <br>&gt; Several weeks ago I posted that I was confused by the differences between how static variables and lazy variables evaluated (or - as I would expect - didn’t evaluate) when initially assigned with a different value. It didn’t result in any discussion, but I encountered it again and decided to draft a proposal hoping that there will be some discussion around it. The draft is available here: https://github.com/d-ronnqvist/swift-evolution/blob/master/proposals/0000-static-var-lazy-behavior.md<br>&gt; <br>&gt; Please let me know what you think, and if you believe this is something that’s worth pursuing.<br>&gt; <br>&gt; - David<br>&gt; <br>&gt; <br>&gt; Lazy evaluation when assigning static variables<br>&gt; Proposal: SE-NNNN<br>&gt; Author(s): David Rönnqvist<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; Both stored type properties (static) and lazy stored properties (lazy var) are lazily initialized. However, they have different initialization behavior in that stored type properties evaluate even when assigning them a new value.<br>&gt; <br>&gt; The following code will print &quot;static&quot;, but not &quot;lazy&quot;:<br>&gt; <br>&gt; class Foo {<br>&gt;     static var bar: String = {<br>&gt;         print(&quot;static&quot;)<br>&gt;         return &quot;Default&quot;<br>&gt;     }()<br>&gt; <br>&gt;     lazy var baz: String = {<br>&gt;         print(&quot;lazy&quot;)<br>&gt;         return &quot;Lazy&quot;<br>&gt;     }()<br>&gt; }<br>&gt; <br>&gt; Foo.bar = &quot;Set&quot; // this evaluates the initial value of `bar` before setting a new value<br>&gt; <br>&gt; let foo = Foo()<br>&gt; foo.baz = &quot;Set&quot; // this doesn&#39;t evaluate `baz` before setting a new value<br>&gt; Swift-evolution thread: [Discussion] Difference between static and lazy variables regarding evaluation of closure<br>&gt; <br>&gt; Motivation<br>&gt; Swift currently evaluates stored type properties even when assigning a new value. This behavior is very subtle and can lead to objects being needlessly initialized and &quot;immediately&quot; de-initialized, as well as unwanted side effects (caused by the initialized objects).<br>&gt; <br>&gt; For example, a shared re-assignable instance that is replaced during unit test set up will initialize the &quot;real&quot; object before assigning the test replacement. <br>&gt; <br>&gt; Detailed design<br>&gt; This proposal seeks to unify the lazy evaluation on assignment of stored type properties (static) and lazy stored properties (lazy var) so that the value being replaced isn&#39;t evaluated (the current behavior of lazy stored properties). <br>&gt; <br>&gt; However, it seeks to keep their respective behaviors and guarantees regarding multithreaded simultaneous access:<br>&gt; <br>&gt; From the The Swift Programming Language (Swift 2.2) regarding lazy stored properties: <br>&gt; <br>&gt; If a property marked with the lazy modifier is accessed by multiple threads simultaneously and the property has not yet been initialized, there is no guarantee that the property will be initialized only once.<br>&gt; and regarding stored type properties:<br>&gt; <br>&gt; Stored type properties are lazily initialized on their first access. They are guaranteed to be initialized only once, even when accessed by multiple threads simultaneously, and they do not need to be marked with the lazy modifier.<br>&gt; No changes to the syntax is proposed. <br>&gt; <br>&gt; This provides a more consistent lazy evaluation behavior, and fixes a (small) source of potential, subtle bugs.<br>&gt; <br>&gt; Impact on existing code<br>&gt; This proposal changes the lazy evaluation of stored type properties when assigning a new value. <br>&gt; <br>&gt; Any code that is relying on this effect would break in subtle ways. This is hard to detect and migrate, but hopefully very rare (and to the best of my knowledge the behavior that code would be relying upon is undocumented).<br>&gt; <br>&gt; Alternatives considered<br>&gt; One alternative is to be consistent with the stored type properties and always evaluate the initial value, even when re-assigning it. However, this version doesn&#39;t address the subtle bugs that can arise from this behavior.<br>&gt; <br>&gt; Another alternative is to leave the the respective behaviors as is and mention their differences in The Swift Programming Language guide. This might still be the most viable alternative in case the current behavior is a consequence of their respective implementations with regards to multithreaded access.<br>&gt; <br>&gt; Rationale<br>&gt; On [Date], the core team decided to (TBD) this proposal. When the core team makes a decision regarding this proposal, their rationale for the decision will be written here.<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/3c7e80f3/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
