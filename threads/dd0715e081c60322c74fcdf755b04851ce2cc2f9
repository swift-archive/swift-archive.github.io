<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>My personal beef with leading-dot syntax</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April  4, 2016 at 01:00:00pm</p></header><div class="content"><p>on Mon Apr 04 2016, Joe Groff &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Apr 4, 2016, at 12:51 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon Apr 04 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Apr 4, 2016, at 11:44 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Mon Apr 04 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Apr 4, 2016, at 11:05 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Mon Apr 04 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; asked:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Can you ping me off-list or in another thread and explain what the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; issues are?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; All of the following make me uncomfortable with our leading-dot thang:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * The rules for lookup don&#39;t seem obvious to me.  I admit this is very<br>&gt;&gt;&gt;&gt;&gt;&gt; personal/subjective.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * There is some evidence that people think it means something it doesn&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt; (“enum case”), as mentioned in SE-0036.  That suggests it is a<br>&gt;&gt;&gt;&gt;&gt;&gt; confusing feature.  That confusion may be fairly harmless so far, but<br>&gt;&gt;&gt;&gt;&gt;&gt; still.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * The dot doesn&#39;t seem to buy enough to be worth the complexity it adds<br>&gt;&gt;&gt;&gt;&gt;&gt; to the language; why not just let those names be looked up without the<br>&gt;&gt;&gt;&gt;&gt;&gt; dot?  You can always disambiguate with full qualification if you have<br>&gt;&gt;&gt;&gt;&gt;&gt; to.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Making every unqualified reference context-dependent would be<br>&gt;&gt;&gt;&gt;&gt; impractical. `foo.bar(bas)` would become an exponential search to find<br>&gt;&gt;&gt;&gt;&gt; a contextual type containing a `foo` which has a `bar` member that can<br>&gt;&gt;&gt;&gt;&gt; accept an type containing a `bas` member.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t think I&#39;m talking about making every unqualified reference<br>&gt;&gt;&gt;&gt; context-dependent.  When I have a context that demands an instance of a<br>&gt;&gt;&gt;&gt; particular enum type, I think it&#39;s reasonable to look up the names in<br>&gt;&gt;&gt;&gt; the enum without qualification, and I strongly question the value of<br>&gt;&gt;&gt;&gt; leading-dot syntax for general static member lookup.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Therein lies the rub—*any* context an unqualified name can appear in<br>&gt;&gt;&gt; could potentially demand an instance of a particular enum type, until<br>&gt;&gt;&gt; the type checker rules that out. Limiting the behavior to enums<br>&gt;&gt;&gt; doesn&#39;t simplify the implementation.<br>&gt;&gt; <br>&gt;&gt; I&#39;m afraid I don&#39;t understand how that&#39;s a serious problem yet.<br>&gt;<br>&gt; Right now, we limit the contextual lookup to places where it&#39;s<br>&gt; syntactically asked for, using the leading dot. Without the leading<br>&gt; dot, we&#39;d have to extend it to every unqualified name, which makes it<br>&gt; much more likely you&#39;ll fall into problematic cases.<br></p><p>I don&#39;t know how to evaluate whether that likelihood is a problem in<br>practice, or not, though.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>My personal beef with leading-dot syntax</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April  5, 2016 at 06:00:00am</p></header><div class="content"><p>Moving away from the compiler, I like the leading dot for the programmer to<br>distinguish static and instance members. The &#39;missing&#39; receiver natural<br>means static to me.<br></p><p>On Tuesday, 5 April 2016, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Mon Apr 04 2016, Joe Groff &lt;swift-evolution at swift.org &lt;javascript:;&gt;&gt;<br>&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; On Apr 4, 2016, at 12:51 PM, Dave Abrahams &lt;dabrahams at apple.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; on Mon Apr 04 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt;&gt;&gt;&gt; On Apr 4, 2016, at 11:44 AM, Dave Abrahams &lt;dabrahams at apple.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; on Mon Apr 04 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Apr 4, 2016, at 11:05 AM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; on Mon Apr 04 2016, Erica Sadun &lt;swift-evolution at swift.org<br>&gt; &lt;javascript:;&gt;&gt; asked:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Can you ping me off-list or in another thread and explain what the<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; issues are?<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; All of the following make me uncomfortable with our leading-dot<br>&gt; thang:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; * The rules for lookup don&#39;t seem obvious to me.  I admit this is<br>&gt; very<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; personal/subjective.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; * There is some evidence that people think it means something it<br>&gt; doesn&#39;t<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; (“enum case”), as mentioned in SE-0036.  That suggests it is a<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; confusing feature.  That confusion may be fairly harmless so far,<br>&gt; but<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; still.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; * The dot doesn&#39;t seem to buy enough to be worth the complexity it<br>&gt; adds<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; to the language; why not just let those names be looked up without<br>&gt; the<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; dot?  You can always disambiguate with full qualification if you<br>&gt; have<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; to.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Making every unqualified reference context-dependent would be<br>&gt; &gt;&gt;&gt;&gt;&gt; impractical. `foo.bar(bas)` would become an exponential search to<br>&gt; find<br>&gt; &gt;&gt;&gt;&gt;&gt; a contextual type containing a `foo` which has a `bar` member that<br>&gt; can<br>&gt; &gt;&gt;&gt;&gt;&gt; accept an type containing a `bas` member.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; I don&#39;t think I&#39;m talking about making every unqualified reference<br>&gt; &gt;&gt;&gt;&gt; context-dependent.  When I have a context that demands an instance of<br>&gt; a<br>&gt; &gt;&gt;&gt;&gt; particular enum type, I think it&#39;s reasonable to look up the names in<br>&gt; &gt;&gt;&gt;&gt; the enum without qualification, and I strongly question the value of<br>&gt; &gt;&gt;&gt;&gt; leading-dot syntax for general static member lookup.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Therein lies the rub—*any* context an unqualified name can appear in<br>&gt; &gt;&gt;&gt; could potentially demand an instance of a particular enum type, until<br>&gt; &gt;&gt;&gt; the type checker rules that out. Limiting the behavior to enums<br>&gt; &gt;&gt;&gt; doesn&#39;t simplify the implementation.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I&#39;m afraid I don&#39;t understand how that&#39;s a serious problem yet.<br>&gt; &gt;<br>&gt; &gt; Right now, we limit the contextual lookup to places where it&#39;s<br>&gt; &gt; syntactically asked for, using the leading dot. Without the leading<br>&gt; &gt; dot, we&#39;d have to extend it to every unqualified name, which makes it<br>&gt; &gt; much more likely you&#39;ll fall into problematic cases.<br>&gt;<br>&gt; I don&#39;t know how to evaluate whether that likelihood is a problem in<br>&gt; practice, or not, though.<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/0e3aef88/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>My personal beef with leading-dot syntax</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>April  4, 2016 at 09:00:00pm</p></header><div class="content"><p>Is a solution to this actually making the leading dot mean enum lookup,<br>full stop and allowing `Self.foo`? The case that that doesn&#39;t cover is<br>static members on a type other than `Self`. I use it to great effect for<br>standard instances of types, so I would appreciate *some* facility to<br>provide that, but it doesn&#39;t have to be a leading dot if we can think of a<br>way which is less problematic.<br></p><p>I am simply spitballing here but would<br>1 period for enum look up<br>2 periods for static member lookup<br></p><p>or something similar be a solution? It doesn&#39;t use another character or<br>keyword and it makes it clear which feature is being used.<br></p><p>TJ<br></p><p>On Mon, Apr 4, 2016 at 4:22 PM, Howard Lovatt via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Moving away from the compiler, I like the leading dot for the programmer<br>&gt; to distinguish static and instance members. The &#39;missing&#39; receiver natural<br>&gt; means static to me.<br>&gt;<br>&gt;<br>&gt; On Tuesday, 5 April 2016, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Mon Apr 04 2016, Joe Groff &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt;&gt; On Apr 4, 2016, at 12:51 PM, Dave Abrahams &lt;dabrahams at apple.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; on Mon Apr 04 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; On Apr 4, 2016, at 11:44 AM, Dave Abrahams &lt;dabrahams at apple.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; on Mon Apr 04 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Apr 4, 2016, at 11:05 AM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; on Mon Apr 04 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; asked:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Can you ping me off-list or in another thread and explain what the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; issues are?<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; All of the following make me uncomfortable with our leading-dot<br>&gt;&gt; thang:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; * The rules for lookup don&#39;t seem obvious to me.  I admit this is<br>&gt;&gt; very<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; personal/subjective.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; * There is some evidence that people think it means something it<br>&gt;&gt; doesn&#39;t<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; (“enum case”), as mentioned in SE-0036.  That suggests it is a<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; confusing feature.  That confusion may be fairly harmless so far,<br>&gt;&gt; but<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; still.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; * The dot doesn&#39;t seem to buy enough to be worth the complexity it<br>&gt;&gt; adds<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; to the language; why not just let those names be looked up without<br>&gt;&gt; the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; dot?  You can always disambiguate with full qualification if you<br>&gt;&gt; have<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; to.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Making every unqualified reference context-dependent would be<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; impractical. `foo.bar(bas)` would become an exponential search to<br>&gt;&gt; find<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; a contextual type containing a `foo` which has a `bar` member that<br>&gt;&gt; can<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; accept an type containing a `bas` member.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; I don&#39;t think I&#39;m talking about making every unqualified reference<br>&gt;&gt; &gt;&gt;&gt;&gt; context-dependent.  When I have a context that demands an instance<br>&gt;&gt; of a<br>&gt;&gt; &gt;&gt;&gt;&gt; particular enum type, I think it&#39;s reasonable to look up the names in<br>&gt;&gt; &gt;&gt;&gt;&gt; the enum without qualification, and I strongly question the value of<br>&gt;&gt; &gt;&gt;&gt;&gt; leading-dot syntax for general static member lookup.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Therein lies the rub—*any* context an unqualified name can appear in<br>&gt;&gt; &gt;&gt;&gt; could potentially demand an instance of a particular enum type, until<br>&gt;&gt; &gt;&gt;&gt; the type checker rules that out. Limiting the behavior to enums<br>&gt;&gt; &gt;&gt;&gt; doesn&#39;t simplify the implementation.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I&#39;m afraid I don&#39;t understand how that&#39;s a serious problem yet.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Right now, we limit the contextual lookup to places where it&#39;s<br>&gt;&gt; &gt; syntactically asked for, using the leading dot. Without the leading<br>&gt;&gt; &gt; dot, we&#39;d have to extend it to every unqualified name, which makes it<br>&gt;&gt; &gt; much more likely you&#39;ll fall into problematic cases.<br>&gt;&gt;<br>&gt;&gt; I don&#39;t know how to evaluate whether that likelihood is a problem in<br>&gt;&gt; practice, or not, though.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; -- Howard.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/7dec70b3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>My personal beef with leading-dot syntax</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April  4, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Apr 4, 2016, at 6:27 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Is a solution to this actually making the leading dot mean enum lookup, full stop and allowing `Self.foo`? The case that that doesn&#39;t cover is static members on a type other than `Self`. I use it to great effect for standard instances of types, so I would appreciate *some* facility to provide that, but it doesn&#39;t have to be a leading dot if we can think of a way which is less problematic. <br>&gt; <br>&gt; I am simply spitballing here but would <br>&gt; 1 period for enum look up<br>&gt; 2 periods for static member lookup<br>&gt; <br>&gt; or something similar be a solution? It doesn&#39;t use another character or keyword and it makes it clear which feature is being used.  <br></p><p>I don&#39;t see any reason for a split here. Enum cases *are* static members, they just happen to be the ones people encounter most often.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>My personal beef with leading-dot syntax</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>April  4, 2016 at 10:00:00pm</p></header><div class="content"><p>Because semantically they seem more like types unto themselves–which is why<br>I disagree with the lower camel casing but I digress–and the fact that they<br>are static members seems like an implementation detail more than anything<br>else.<br></p><p>TJ<br></p><p>On Mon, Apr 4, 2016 at 10:15 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Apr 4, 2016, at 6:27 PM, T.J. Usiyan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Is a solution to this actually making the leading dot mean enum lookup,<br>&gt; full stop and allowing `Self.foo`? The case that that doesn&#39;t cover is<br>&gt; static members on a type other than `Self`. I use it to great effect for<br>&gt; standard instances of types, so I would appreciate *some* facility to<br>&gt; provide that, but it doesn&#39;t have to be a leading dot if we can think of a<br>&gt; way which is less problematic.<br>&gt; &gt;<br>&gt; &gt; I am simply spitballing here but would<br>&gt; &gt; 1 period for enum look up<br>&gt; &gt; 2 periods for static member lookup<br>&gt; &gt;<br>&gt; &gt; or something similar be a solution? It doesn&#39;t use another character or<br>&gt; keyword and it makes it clear which feature is being used.<br>&gt;<br>&gt; I don&#39;t see any reason for a split here. Enum cases *are* static members,<br>&gt; they just happen to be the ones people encounter most often.<br>&gt;<br>&gt; -Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/f3bac441/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>My personal beef with leading-dot syntax</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April  4, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Because semantically they seem more like types unto themselves<br></p><p>But they aren&#39;t types.<br></p><p>* You can&#39;t declare a variable/property/parameter of a particular case.<br>* You can&#39;t constrain a generic type parameter to a case.<br>* You can&#39;t cast to a case with `as` and friends or test for a case with `is`.<br>* You can&#39;t conform different cases to different protocols.<br>* You can&#39;t give different cases different members. (The associated value tuple is not a member; you can only access it with pattern matching.)<br></p><p>There is nothing subtle or ambiguous about this. Swift does not even blur the line anywhere, except in the switch statement (which is full of ad-hoc magic) and in the now-corrected capitalization convention. Cases simply *are not* types. They are different values which may be stored in the same type, just as `Int(1)` and `Int(2)` are not different types.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>My personal beef with leading-dot syntax</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>April  4, 2016 at 11:00:00pm</p></header><div class="content"><p>*like* types. I, at no point, said that they are types.<br></p><p>Pointing out what they can&#39;t do is not a great stance, in my opinion,<br>because some of those things are perfectly reasonable but simply might not<br>have been considered or attempted yet. I am *not* arguing that they are<br>types. I am arguing that they are semantically different from static<br>members. If they aren&#39;t, why not simply give us a means to pattern match<br>over custom values and call it a day?<br></p><p>My point is that enum are special.<br></p><p>``` swift<br>enum Boolean {<br>    case True, False<br>}<br>```<br></p><p>We could argue that `True` and `False` are just instances of Boolean. I<br>will argue that you provide no significant state (Void) in either case to<br>&#39;create&#39; or &#39;choose&#39; either `True` or `False`. You provide such  a raw<br>value to `Int`  to create each instance but you do no such thing for an<br>enum without an associate value. You do, however, provide a significant bit<br>of state to enums with associated values. Both the case choses AND the<br>state define identity, which places it between an enum without associated<br>values and a struct/class/product type<br></p><p>``` swift<br>enum Optional&lt;T&gt; {<br>    case Some(T)<br>    case None<br>}<br>```<br></p><p>Again, I agree that they are not types. I disagree that they are just like<br>`Int` Each case is a signifier between member value and type.<br>TJ<br></p><p><br></p><p><br></p><p>On Mon, Apr 4, 2016 at 11:04 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; Because semantically they seem more like types unto themselves<br>&gt;<br>&gt; But they aren&#39;t types.<br>&gt;<br>&gt; * You can&#39;t declare a variable/property/parameter of a particular case.<br>&gt; * You can&#39;t constrain a generic type parameter to a case.<br>&gt; * You can&#39;t cast to a case with `as` and friends or test for a case with<br>&gt; `is`.<br>&gt; * You can&#39;t conform different cases to different protocols.<br>&gt; * You can&#39;t give different cases different members. (The associated value<br>&gt; tuple is not a member; you can only access it with pattern matching.)<br>&gt;<br>&gt; There is nothing subtle or ambiguous about this. Swift does not even blur<br>&gt; the line anywhere, except in the switch statement (which is full of ad-hoc<br>&gt; magic) and in the now-corrected capitalization convention. Cases simply<br>&gt; *are not* types. They are different values which may be stored in the same<br>&gt; type, just as `Int(1)` and `Int(2)` are not different types.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/44fd7e17/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
