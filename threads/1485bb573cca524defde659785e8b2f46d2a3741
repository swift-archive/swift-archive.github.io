<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>Passing an optional first argument to sequence(first:next:)</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>August 15, 2016 at 01:00:00am</p></header><div class="content"><p>sequence(first:next:) takes a non-optional first argument. Is there a reason for that? sequence(state:next:) allows empty sequences, and I don’t see why sequence(first:next:) shouldn’t. The fix would be to simply add the `?` in the function signature; no other changes are required to make it work.<br></p><p>I considered just filing a bug report, but since this is a change of the public API...<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Passing an optional first argument to sequence(first:next:)</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>August 15, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi Tim,<br></p><p>If you pass &quot;nil&quot; to &quot;first&quot; isn&#39;t this an empty sequence? So it would be redundant.<br></p><p>Best regards<br>Maximilian<br></p><p>&gt; Am 15.08.2016 um 01:27 schrieb Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; sequence(first:next:) takes a non-optional first argument. Is there a reason for that? sequence(state:next:) allows empty sequences, and I don’t see why sequence(first:next:) shouldn’t. The fix would be to simply add the `?` in the function signature; no other changes are required to make it work.<br>&gt; <br>&gt; I considered just filing a bug report, but since this is a change of the public API...<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>Passing an optional first argument to sequence(first:next:)</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>August 15, 2016 at 10:00:00pm</p></header><div class="content"><p>You can’t; the `first` parameter has type `T`, not `T?`.<br></p><p>&gt; On 15 Aug 2016, at 22:10, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt; <br>&gt; Hi Tim,<br>&gt; <br>&gt; If you pass &quot;nil&quot; to &quot;first&quot; isn&#39;t this an empty sequence? So it would be redundant.<br>&gt; <br>&gt; Best regards<br>&gt; Maximilian<br>&gt; <br>&gt;&gt; Am 15.08.2016 um 01:27 schrieb Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; sequence(first:next:) takes a non-optional first argument. Is there a reason for that? sequence(state:next:) allows empty sequences, and I don’t see why sequence(first:next:) shouldn’t. The fix would be to simply add the `?` in the function signature; no other changes are required to make it work.<br>&gt;&gt; <br>&gt;&gt; I considered just filing a bug report, but since this is a change of the public API...<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Passing an optional first argument to sequence(first:next:)</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>August 15, 2016 at 10:00:00pm</p></header><div class="content"><p>Probably I didn&#39;t understand your proposal. What do you want to change exactly?<br></p><p>I thought:<br>public func sequence&lt;T&gt;(first: T, next: @escaping (T) -&gt; T?) -&gt; UnfoldFirstSequence&lt;T&gt; { ... }<br></p><p>To:<br>public func sequence&lt;T&gt;(first: T?, next: @escaping (T) -&gt; T?) -&gt; UnfoldFirstSequence&lt;T&gt; { ... }<br></p><p>&gt; Am 15.08.2016 um 22:17 schrieb Tim Vermeulen &lt;tvermeulen at me.com&gt;:<br>&gt; <br>&gt; You can’t; the `first` parameter has type `T`, not `T?`.<br>&gt; <br>&gt;&gt; On 15 Aug 2016, at 22:10, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Tim,<br>&gt;&gt; <br>&gt;&gt; If you pass &quot;nil&quot; to &quot;first&quot; isn&#39;t this an empty sequence? So it would be redundant.<br>&gt;&gt; <br>&gt;&gt; Best regards<br>&gt;&gt; Maximilian<br>&gt;&gt; <br>&gt;&gt;&gt; Am 15.08.2016 um 01:27 schrieb Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; sequence(first:next:) takes a non-optional first argument. Is there a reason for that? sequence(state:next:) allows empty sequences, and I don’t see why sequence(first:next:) shouldn’t. The fix would be to simply add the `?` in the function signature; no other changes are required to make it work.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I considered just filing a bug report, but since this is a change of the public API...<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c53218a6524f4d644b6a75a4441ea631?s=50"></div><header><strong>Passing an optional first argument to sequence(first:next:)</strong> from <string>Max Moiseev</string> &lt;moiseev at apple.com&gt;<p>August 18, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi Tim,<br></p><p>Thanks for bringing this up.<br>Here are my thoughts on the change you’re proposing.<br></p><p>func sequence&lt;T&gt;(first: T, next: (T) -&gt; T?) -&gt; UnfoldFirstSequence&lt;T&gt;<br></p><p>To me the type of the function as it is tells a clear story of what’s going to happen: take the `first`, make it a head of the resulting sequence, and then try to produce the tail by a series of applications of `next`. The only thing that controls when the sequence generation terminates is the result of `next`.<br></p><p>If we change the type of `first` to an Optional&lt;T&gt;, it would make the termination condition non-trivial. After all, the only thing it would do is try to unwrap the `first`, before doing what it needs to, but we already have a `map` for that. One should be able to simply do the `first.map { sequence(first: $0, next: next) } ?? []` but that won’t work with the types very well, unfortunately.<br></p><p>As an alternative, `let first: Int? = ...; sequence(first: first, next: next).flatMap({$0})` (or even `.lazy.flatMap({$0})`) will do the right thing without making an API more complex.<br></p><p>I see the point of `sequence(first:next:)` to be precisely the &quot;generate the non-empty sequence using a seed and a simple producer&quot;, for anything more than that, there is `sequence(state:next:)`.<br></p><p>What do you think?<br></p><p>Max<br></p><p>&gt; On Aug 14, 2016, at 4:27 PM, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; sequence(first:next:) takes a non-optional first argument. Is there a reason for that? sequence(state:next:) allows empty sequences, and I don’t see why sequence(first:next:) shouldn’t. The fix would be to simply add the `?` in the function signature; no other changes are required to make it work.<br>&gt; <br>&gt; I considered just filing a bug report, but since this is a change of the public API...<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160818/409d8c74/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>Passing an optional first argument to sequence(first:next:)</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>August 19, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi Max, thanks for having a look.<br></p><p>A big part of why I’m not really happy with the current implementation is that the function always produces a nonempty sequence, though the compiler doesn’t know it. `sequence(first: first, next: next).last` returns an optional, even though it can’t possibly be nil. The same goes for something like `sequence(first: 5, next: { $0 * 3 }).first(where: { $0 &gt; 1000 })`, because the sequence is infinite, which means `first(while:)` will either keep running forever, or return a non-optional.<br></p><p>Ideally, we’d have three types of sequences, with three corresponding `sequence(first:next:)` functions:<br></p><p>func sequence&lt;T&gt;(first: T?, next: (T) -&gt; T?) — returns any sequence<br>func sequence&lt;T&gt;(first: T,  next: (T) -&gt; T?) — returns a nonempty sequence<br>func sequence&lt;T&gt;(first: T,  next: (T) -&gt; T)  — returns an infinite sequence<br></p><p>Default implementations for methods on sequences would either return optionals or non-optionals depending on their emptiness/finiteness. We just have the first kind of sequence right now, so in that regard it would make sense to also give `sequence(first:next)` the corresponding signature.  Later, when the language / standard library supports the other two kinds of sequences (if that ever happens), the other versions could be added.<br></p><p>Another reason that makes me think that the version that accepts an optional `first` argument is more natural, is the fact that the function body doesn’t need to be changed at all. It supports optional seeds by design; only the signature prevents it.<br></p><p>I know these arguments might not be very convincing, but I feel like Swift misses an opportunity if it unnecessarily constrains the `first` parameter to be non-optional. The `.lazy.flatMap({ $0 })` alternative that you pointed out does work, but it makes everything very unreadable: not just the `.lazy.flatMap({ $0 })` part, but also the body of the `next` parameter because you’re now dealing with optionals (i.e. you have to `flatMap` over the closure argument). The best solution I’ve come up with is to copy the `sequence(first:next)` implementation from the source code and change the signature. :-/<br></p><p>`sequence(state:next:)` isn’t very appropriate for this task either, because naive usage with an optional seed has the downside of being unnecessarily eager just like a naive `sequence(first:next)` implementation (as described in a comment in the source code).<br></p><p>&gt; On 19 Aug 2016, at 00:18, Max Moiseev &lt;moiseev at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi Tim,<br>&gt; <br>&gt; Thanks for bringing this up.<br>&gt; Here are my thoughts on the change you’re proposing.<br>&gt; <br>&gt; func sequence&lt;T&gt;(first: T, next: (T) -&gt; T?) -&gt; UnfoldFirstSequence&lt;T&gt;<br>&gt; <br>&gt; To me the type of the function as it is tells a clear story of what’s going to happen: take the `first`, make it a head of the resulting sequence, and then try to produce the tail by a series of applications of `next`. The only thing that controls when the sequence generation terminates is the result of `next`.<br>&gt; <br>&gt; If we change the type of `first` to an Optional&lt;T&gt;, it would make the termination condition non-trivial. After all, the only thing it would do is try to unwrap the `first`, before doing what it needs to, but we already have a `map` for that. One should be able to simply do the `first.map { sequence(first: $0, next: next) } ?? []` but that won’t work with the types very well, unfortunately.<br>&gt; <br>&gt; As an alternative, `let first: Int? = ...; sequence(first: first, next: next).flatMap({$0})` (or even `.lazy.flatMap({$0})`) will do the right thing without making an API more complex.<br>&gt; <br>&gt; I see the point of `sequence(first:next:)` to be precisely the &quot;generate the non-empty sequence using a seed and a simple producer&quot;, for anything more than that, there is `sequence(state:next:)`.<br>&gt; <br>&gt; What do you think?<br>&gt; <br>&gt; Max<br>&gt; <br>&gt;&gt; On Aug 14, 2016, at 4:27 PM, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; sequence(first:next:) takes a non-optional first argument. Is there a reason for that? sequence(state:next:) allows empty sequences, and I don’t see why sequence(first:next:) shouldn’t. The fix would be to simply add the `?` in the function signature; no other changes are required to make it work.<br>&gt;&gt; <br>&gt;&gt; I considered just filing a bug report, but since this is a change of the public API...<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160819/d1a7b227/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c53218a6524f4d644b6a75a4441ea631?s=50"></div><header><strong>Passing an optional first argument to sequence(first:next:)</strong> from <string>Max Moiseev</string> &lt;moiseev at apple.com&gt;<p>August 19, 2016 at 10:00:00am</p></header><div class="content"><p>+ Erica, Kevin, as the authors of the original proposal.<br></p><p>Do you remember the problem of non-emptiness being discussed before? And if not, what’s your opinion on the proposed change?<br></p><p>Thanks,<br>Max<br></p><p>&gt; On Aug 19, 2016, at 7:53 AM, Tim Vermeulen &lt;tvermeulen at me.com&gt; wrote:<br>&gt; <br>&gt; Hi Max, thanks for having a look.<br>&gt; <br>&gt; A big part of why I’m not really happy with the current implementation is that the function always produces a nonempty sequence, though the compiler doesn’t know it. `sequence(first: first, next: next).last` returns an optional, even though it can’t possibly be nil. The same goes for something like `sequence(first: 5, next: { $0 * 3 }).first(where: { $0 &gt; 1000 })`, because the sequence is infinite, which means `first(while:)` will either keep running forever, or return a non-optional.<br>&gt; <br>&gt; Ideally, we’d have three types of sequences, with three corresponding `sequence(first:next:)` functions:<br>&gt; <br>&gt; func sequence&lt;T&gt;(first: T?, next: (T) -&gt; T?) — returns any sequence<br>&gt; func sequence&lt;T&gt;(first: T,  next: (T) -&gt; T?) — returns a nonempty sequence<br>&gt; func sequence&lt;T&gt;(first: T,  next: (T) -&gt; T)  — returns an infinite sequence<br>&gt; <br>&gt; Default implementations for methods on sequences would either return optionals or non-optionals depending on their emptiness/finiteness. We just have the first kind of sequence right now, so in that regard it would make sense to also give `sequence(first:next)` the corresponding signature.  Later, when the language / standard library supports the other two kinds of sequences (if that ever happens), the other versions could be added.<br>&gt; <br>&gt; Another reason that makes me think that the version that accepts an optional `first` argument is more natural, is the fact that the function body doesn’t need to be changed at all. It supports optional seeds by design; only the signature prevents it.<br>&gt; <br>&gt; I know these arguments might not be very convincing, but I feel like Swift misses an opportunity if it unnecessarily constrains the `first` parameter to be non-optional. The `.lazy.flatMap({ $0 })` alternative that you pointed out does work, but it makes everything very unreadable: not just the `.lazy.flatMap({ $0 })` part, but also the body of the `next` parameter because you’re now dealing with optionals (i.e. you have to `flatMap` over the closure argument). The best solution I’ve come up with is to copy the `sequence(first:next)` implementation from the source code and change the signature. :-/<br>&gt; <br>&gt; `sequence(state:next:)` isn’t very appropriate for this task either, because naive usage with an optional seed has the downside of being unnecessarily eager just like a naive `sequence(first:next)` implementation (as described in a comment in the source code).<br>&gt; <br>&gt;&gt; On 19 Aug 2016, at 00:18, Max Moiseev &lt;moiseev at apple.com &lt;mailto:moiseev at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Tim,<br>&gt;&gt; <br>&gt;&gt; Thanks for bringing this up.<br>&gt;&gt; Here are my thoughts on the change you’re proposing.<br>&gt;&gt; <br>&gt;&gt; func sequence&lt;T&gt;(first: T, next: (T) -&gt; T?) -&gt; UnfoldFirstSequence&lt;T&gt;<br>&gt;&gt; <br>&gt;&gt; To me the type of the function as it is tells a clear story of what’s going to happen: take the `first`, make it a head of the resulting sequence, and then try to produce the tail by a series of applications of `next`. The only thing that controls when the sequence generation terminates is the result of `next`.<br>&gt;&gt; <br>&gt;&gt; If we change the type of `first` to an Optional&lt;T&gt;, it would make the termination condition non-trivial. After all, the only thing it would do is try to unwrap the `first`, before doing what it needs to, but we already have a `map` for that. One should be able to simply do the `first.map { sequence(first: $0, next: next) } ?? []` but that won’t work with the types very well, unfortunately.<br>&gt;&gt; <br>&gt;&gt; As an alternative, `let first: Int? = ...; sequence(first: first, next: next).flatMap({$0})` (or even `.lazy.flatMap({$0})`) will do the right thing without making an API more complex.<br>&gt;&gt; <br>&gt;&gt; I see the point of `sequence(first:next:)` to be precisely the &quot;generate the non-empty sequence using a seed and a simple producer&quot;, for anything more than that, there is `sequence(state:next:)`.<br>&gt;&gt; <br>&gt;&gt; What do you think?<br>&gt;&gt; <br>&gt;&gt; Max<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 14, 2016, at 4:27 PM, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; sequence(first:next:) takes a non-optional first argument. Is there a reason for that? sequence(state:next:) allows empty sequences, and I don’t see why sequence(first:next:) shouldn’t. The fix would be to simply add the `?` in the function signature; no other changes are required to make it work.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I considered just filing a bug report, but since this is a change of the public API...<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160819/10bea150/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Passing an optional first argument to sequence(first:next:)</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>August 19, 2016 at 10:00:00am</p></header><div class="content"><p>AFAIK this issue has never been discussed with sequence(first:next:)<br>before. It certainly wasn&#39;t brought up during review.<br></p><p>As for my opinion, I&#39;m really not sure. I was going to point out that<br>right now sequence(first:next:) guarantees that the first element of the<br>resulting sequence is the value provided as &quot;first&quot;, but it occurs to me<br>that if you treat the nil result from next() as an element, then this<br>still holds true. So I guess my biggest worry is this change will make<br>it harder to use sequence(first:next:) to produce sequences of optional<br>values. So I guess I&#39;m ambivalent, and would prefer to defer to the<br>wisdom of the Swift core team on this matter.<br></p><p>That said, didn&#39;t the deadline for source-breaking changes already<br>come and go?<br></p><p>-Kevin Ballard<br></p><p>On Fri, Aug 19, 2016, at 10:37 AM, Max Moiseev wrote:<br>&gt; + Erica, Kevin, as the authors of the original proposal.<br>&gt;<br>&gt; Do you remember the problem of non-emptiness being discussed before?<br>&gt; And if not, what’s your opinion on the proposed change?<br>&gt;<br>&gt; Thanks,<br>&gt; Max<br>&gt;<br>&gt;&gt; On Aug 19, 2016, at 7:53 AM, Tim Vermeulen &lt;tvermeulen at me.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi Max, thanks for having a look.<br>&gt;&gt;<br>&gt;&gt; A big part of why I’m not really happy with the current<br>&gt;&gt; implementation is that the function always produces a nonempty<br>&gt;&gt; sequence, though the compiler doesn’t know it. `sequence(first:<br>&gt;&gt; first, next: next).last` returns an optional, even though it can’t<br>&gt;&gt; possibly be nil. The same goes for something like `sequence(first: 5,<br>&gt;&gt; next: { $0 * 3 }).first(where: { $0 &gt; 1000 })`, because the sequence<br>&gt;&gt; is infinite, which means `first(while:)` will either keep running<br>&gt;&gt; forever, or return a non-optional.<br>&gt;&gt;<br>&gt;&gt; Ideally, we’d have three types of sequences, with three corresponding<br>&gt;&gt; `sequence(first:next:)` functions:<br>&gt;&gt;<br>&gt;&gt; func sequence&lt;T&gt;(first: T?, next: (T) -&gt; T?) — returns any sequence<br>&gt;&gt; func sequence&lt;T&gt;(first: T,  next: (T) -&gt; T?) — returns a nonempty<br>&gt;&gt; sequence<br>&gt;&gt; func sequence&lt;T&gt;(first: T,  next: (T) -&gt; T)  — returns an infinite<br>&gt;&gt; sequence<br>&gt;&gt;<br>&gt;&gt; Default implementations for methods on sequences would either return<br>&gt;&gt; optionals or non-optionals depending on their emptiness/finiteness.<br>&gt;&gt; We just have the first kind of sequence right now, so in that regard<br>&gt;&gt; it would make sense to also give `sequence(first:next)` the<br>&gt;&gt; corresponding signature.  Later, when the language / standard library<br>&gt;&gt; supports the other two kinds of sequences (if that ever happens), the<br>&gt;&gt; other versions could be added.<br>&gt;&gt;<br>&gt;&gt; Another reason that makes me think that the version that accepts an<br>&gt;&gt; optional `first` argument is more natural, is the fact that the<br>&gt;&gt; function body doesn’t need to be changed at all. It supports optional<br>&gt;&gt; seeds by design; only the signature prevents it.<br>&gt;&gt;<br>&gt;&gt; I know these arguments might not be very convincing, but I feel like<br>&gt;&gt; Swift misses an opportunity if it unnecessarily constrains the<br>&gt;&gt; `first` parameter to be non-optional. The `.lazy.flatMap({ $0 })`<br>&gt;&gt; alternative that you pointed out does work, but it makes everything<br>&gt;&gt; very unreadable: not just the `.lazy.flatMap({ $0 })` part, but also<br>&gt;&gt; the body of the `next` parameter because you’re now dealing with<br>&gt;&gt; optionals (i.e. you have to `flatMap` over the closure argument). The<br>&gt;&gt; best solution I’ve come up with is to copy the `sequence(first:next)`<br>&gt;&gt; implementation from the source code and change the signature. :-/<br>&gt;&gt;<br>&gt;&gt; `sequence(state:next:)` isn’t very appropriate for this task either,<br>&gt;&gt; because naive usage with an optional seed has the downside of being<br>&gt;&gt; unnecessarily eager just like a naive `sequence(first:next)`<br>&gt;&gt; implementation (as described in a comment in the source code).<br>&gt;&gt;<br>&gt;&gt;&gt; On 19 Aug 2016, at 00:18, Max Moiseev &lt;moiseev at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hi Tim,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks for bringing this up.<br>&gt;&gt;&gt; Here are my thoughts on the change you’re proposing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func sequence&lt;T&gt;(first: T, next: (T) -&gt; T?) -&gt;<br>&gt;&gt;&gt; UnfoldFirstSequence&lt;T&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; To me the type of the function as it is tells a clear story of<br>&gt;&gt;&gt; what’s going to happen: take the `first`, make it a head of the<br>&gt;&gt;&gt; resulting sequence, and then try to produce the tail by a series of<br>&gt;&gt;&gt; applications of `next`. The only thing that controls when the<br>&gt;&gt;&gt; sequence generation terminates is the result of `next`.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If we change the type of `first` to an Optional&lt;T&gt;, it would make<br>&gt;&gt;&gt; the termination condition non-trivial. After all, the only thing it<br>&gt;&gt;&gt; would do is try to unwrap the `first`, before doing what it needs<br>&gt;&gt;&gt; to, but we already have a `map` for that. One should be able to<br>&gt;&gt;&gt; simply do the `first.map { sequence(first: $0, next: next) } ?? []`<br>&gt;&gt;&gt; but that won’t work with the types very well, unfortunately.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As an alternative, `let first: Int? = ...; sequence(first: first,<br>&gt;&gt;&gt; next: next).flatMap({$0})` (or even `.lazy.flatMap({$0})`) will do<br>&gt;&gt;&gt; the right thing without making an API more complex.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I see the point of `sequence(first:next:)` to be precisely the<br>&gt;&gt;&gt; &quot;generate the non-empty sequence using a seed and a simple<br>&gt;&gt;&gt; producer&quot;, for anything more than that, there is<br>&gt;&gt;&gt; `sequence(state:next:)`.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What do you think?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Max<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Aug 14, 2016, at 4:27 PM, Tim Vermeulen via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; sequence(first:next:) takes a non-optional first argument. Is there<br>&gt;&gt;&gt;&gt; a reason for that? sequence(state:next:) allows empty sequences,<br>&gt;&gt;&gt;&gt; and I don’t see why sequence(first:next:) shouldn’t. The fix would<br>&gt;&gt;&gt;&gt; be to simply add the `?` in the function signature; no other<br>&gt;&gt;&gt;&gt; changes are required to make it work.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I considered just filing a bug report, but since this is a change<br>&gt;&gt;&gt;&gt; of the public API...<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160819/1aba6d3a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>Passing an optional first argument to sequence(first:next:)</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>August 20, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On 19 Aug 2016, at 19:48, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; AFAIK this issue has never been discussed with sequence(first:next:) before. It certainly wasn&#39;t brought up during review.<br>&gt; <br>&gt; As for my opinion, I&#39;m really not sure. I was going to point out that right now sequence(first:next:) guarantees that the first element of the resulting sequence is the value provided as &quot;first&quot;, but it occurs to me that if you treat the nil result from next() as an element, then this still holds true. So I guess my biggest worry is this change will make it harder to use sequence(first:next:) to produce sequences of optional values.<br></p><p>I don’t think producing sequences of optional values would really be a problem, because type inference will figure this out based on whether you treat the argument to the `next` closure as an optional or not. And if you only do things in `next` that work both with optionals and non-optionals (very unlikely), you can always manually specify the type of the sequence.<br></p><p>&gt; So I guess I&#39;m ambivalent, and would prefer to defer to the wisdom of the Swift core team on this matter.<br>&gt; <br>&gt; That said, didn&#39;t the deadline for source-breaking changes already come and go?<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; On Fri, Aug 19, 2016, at 10:37 AM, Max Moiseev wrote:<br>&gt;&gt; + Erica, Kevin, as the authors of the original proposal.<br>&gt;&gt; <br>&gt;&gt; Do you remember the problem of non-emptiness being discussed before? And if not, what’s your opinion on the proposed change?<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Max<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 19, 2016, at 7:53 AM, Tim Vermeulen &lt;tvermeulen at me.com &lt;mailto:tvermeulen at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Max, thanks for having a look.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A big part of why I’m not really happy with the current implementation is that the function always produces a nonempty sequence, though the compiler doesn’t know it. `sequence(first: first, next: next).last` returns an optional, even though it can’t possibly be nil. The same goes for something like `sequence(first: 5, next: { $0 * 3 }).first(where: { $0 &gt; 1000 })`, because the sequence is infinite, which means `first(while:)` will either keep running forever, or return a non-optional.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ideally, we’d have three types of sequences, with three corresponding `sequence(first:next:)` functions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func sequence&lt;T&gt;(first: T?, next: (T) -&gt; T?) — returns any sequence<br>&gt;&gt;&gt; func sequence&lt;T&gt;(first: T,  next: (T) -&gt; T?) — returns a nonempty sequence<br>&gt;&gt;&gt; func sequence&lt;T&gt;(first: T,  next: (T) -&gt; T)  — returns an infinite sequence<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Default implementations for methods on sequences would either return optionals or non-optionals depending on their emptiness/finiteness. We just have the first kind of sequence right now, so in that regard it would make sense to also give `sequence(first:next)` the corresponding signature.  Later, when the language / standard library supports the other two kinds of sequences (if that ever happens), the other versions could be added.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another reason that makes me think that the version that accepts an optional `first` argument is more natural, is the fact that the function body doesn’t need to be changed at all. It supports optional seeds by design; only the signature prevents it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I know these arguments might not be very convincing, but I feel like Swift misses an opportunity if it unnecessarily constrains the `first` parameter to be non-optional. The `.lazy.flatMap({ $0 })` alternative that you pointed out does work, but it makes everything very unreadable: not just the `.lazy.flatMap({ $0 })` part, but also the body of the `next` parameter because you’re now dealing with optionals (i.e. you have to `flatMap` over the closure argument). The best solution I’ve come up with is to copy the `sequence(first:next)` implementation from the source code and change the signature. :-/<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `sequence(state:next:)` isn’t very appropriate for this task either, because naive usage with an optional seed has the downside of being unnecessarily eager just like a naive `sequence(first:next)` implementation (as described in a comment in the source code).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 19 Aug 2016, at 00:18, Max Moiseev &lt;moiseev at apple.com &lt;mailto:moiseev at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Tim,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks for bringing this up.<br>&gt;&gt;&gt;&gt; Here are my thoughts on the change you’re proposing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func sequence&lt;T&gt;(first: T, next: (T) -&gt; T?) -&gt; UnfoldFirstSequence&lt;T&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To me the type of the function as it is tells a clear story of what’s going to happen: take the `first`, make it a head of the resulting sequence, and then try to produce the tail by a series of applications of `next`. The only thing that controls when the sequence generation terminates is the result of `next`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we change the type of `first` to an Optional&lt;T&gt;, it would make the termination condition non-trivial. After all, the only thing it would do is try to unwrap the `first`, before doing what it needs to, but we already have a `map` for that. One should be able to simply do the `first.map { sequence(first: $0, next: next) } ?? []` but that won’t work with the types very well, unfortunately.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As an alternative, `let first: Int? = ...; sequence(first: first, next: next).flatMap({$0})` (or even `.lazy.flatMap({$0})`) will do the right thing without making an API more complex.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I see the point of `sequence(first:next:)` to be precisely the &quot;generate the non-empty sequence using a seed and a simple producer&quot;, for anything more than that, there is `sequence(state:next:)`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What do you think?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Max<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 14, 2016, at 4:27 PM, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; sequence(first:next:) takes a non-optional first argument. Is there a reason for that? sequence(state:next:) allows empty sequences, and I don’t see why sequence(first:next:) shouldn’t. The fix would be to simply add the `?` in the function signature; no other changes are required to make it work.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I considered just filing a bug report, but since this is a change of the public API...<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160820/28fc72e7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c53218a6524f4d644b6a75a4441ea631?s=50"></div><header><strong>Passing an optional first argument to sequence(first:next:)</strong> from <string>Max Moiseev</string> &lt;moiseev at apple.com&gt;<p>August 19, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi Tim,<br></p><p>I still believe that having 2 termination conditions is wrong. But I guess we need a tie breaker here, someone with a strong opinion about the problem.<br>As Kevin mentioned we are very late in the release process, so waiting for another opinion for a day or two won’t change anything, really.<br></p><p>Meanwhile, I played a little bit with an idea of making `first.map { sequence(first $0, next: next} ?? []` work. <br>Turns out, if we add an `ExpressibleByArrayLiteral` protocol conformance to the `UnfoldSequence`, this snippet will compile just fine. One downside is that the `ExpressibleByArrayLiteral` protocol allows creating non-empty sequences as well, which does not make sense for the `UnfoldSequence`.<br></p><p><br>Max<br></p><p>&gt; On Aug 19, 2016, at 3:48 PM, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On 19 Aug 2016, at 19:48, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; AFAIK this issue has never been discussed with sequence(first:next:) before. It certainly wasn&#39;t brought up during review.<br>&gt;&gt; <br>&gt;&gt; As for my opinion, I&#39;m really not sure. I was going to point out that right now sequence(first:next:) guarantees that the first element of the resulting sequence is the value provided as &quot;first&quot;, but it occurs to me that if you treat the nil result from next() as an element, then this still holds true. So I guess my biggest worry is this change will make it harder to use sequence(first:next:) to produce sequences of optional values.<br>&gt; <br>&gt; I don’t think producing sequences of optional values would really be a problem, because type inference will figure this out based on whether you treat the argument to the `next` closure as an optional or not. And if you only do things in `next` that work both with optionals and non-optionals (very unlikely), you can always manually specify the type of the sequence.<br>&gt; <br>&gt;&gt; So I guess I&#39;m ambivalent, and would prefer to defer to the wisdom of the Swift core team on this matter.<br>&gt;&gt; <br>&gt;&gt; That said, didn&#39;t the deadline for source-breaking changes already come and go?<br>&gt;&gt; <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt; <br>&gt;&gt; On Fri, Aug 19, 2016, at 10:37 AM, Max Moiseev wrote:<br>&gt;&gt;&gt; + Erica, Kevin, as the authors of the original proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Do you remember the problem of non-emptiness being discussed before? And if not, what’s your opinion on the proposed change?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Max<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 19, 2016, at 7:53 AM, Tim Vermeulen &lt;tvermeulen at me.com &lt;mailto:tvermeulen at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Max, thanks for having a look.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A big part of why I’m not really happy with the current implementation is that the function always produces a nonempty sequence, though the compiler doesn’t know it. `sequence(first: first, next: next).last` returns an optional, even though it can’t possibly be nil. The same goes for something like `sequence(first: 5, next: { $0 * 3 }).first(where: { $0 &gt; 1000 })`, because the sequence is infinite, which means `first(while:)` will either keep running forever, or return a non-optional.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ideally, we’d have three types of sequences, with three corresponding `sequence(first:next:)` functions:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func sequence&lt;T&gt;(first: T?, next: (T) -&gt; T?) — returns any sequence<br>&gt;&gt;&gt;&gt; func sequence&lt;T&gt;(first: T,  next: (T) -&gt; T?) — returns a nonempty sequence<br>&gt;&gt;&gt;&gt; func sequence&lt;T&gt;(first: T,  next: (T) -&gt; T)  — returns an infinite sequence<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Default implementations for methods on sequences would either return optionals or non-optionals depending on their emptiness/finiteness. We just have the first kind of sequence right now, so in that regard it would make sense to also give `sequence(first:next)` the corresponding signature.  Later, when the language / standard library supports the other two kinds of sequences (if that ever happens), the other versions could be added.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another reason that makes me think that the version that accepts an optional `first` argument is more natural, is the fact that the function body doesn’t need to be changed at all. It supports optional seeds by design; only the signature prevents it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I know these arguments might not be very convincing, but I feel like Swift misses an opportunity if it unnecessarily constrains the `first` parameter to be non-optional. The `.lazy.flatMap({ $0 })` alternative that you pointed out does work, but it makes everything very unreadable: not just the `.lazy.flatMap({ $0 })` part, but also the body of the `next` parameter because you’re now dealing with optionals (i.e. you have to `flatMap` over the closure argument). The best solution I’ve come up with is to copy the `sequence(first:next)` implementation from the source code and change the signature. :-/<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `sequence(state:next:)` isn’t very appropriate for this task either, because naive usage with an optional seed has the downside of being unnecessarily eager just like a naive `sequence(first:next)` implementation (as described in a comment in the source code).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 19 Aug 2016, at 00:18, Max Moiseev &lt;moiseev at apple.com &lt;mailto:moiseev at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi Tim,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks for bringing this up.<br>&gt;&gt;&gt;&gt;&gt; Here are my thoughts on the change you’re proposing.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func sequence&lt;T&gt;(first: T, next: (T) -&gt; T?) -&gt; UnfoldFirstSequence&lt;T&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To me the type of the function as it is tells a clear story of what’s going to happen: take the `first`, make it a head of the resulting sequence, and then try to produce the tail by a series of applications of `next`. The only thing that controls when the sequence generation terminates is the result of `next`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If we change the type of `first` to an Optional&lt;T&gt;, it would make the termination condition non-trivial. After all, the only thing it would do is try to unwrap the `first`, before doing what it needs to, but we already have a `map` for that. One should be able to simply do the `first.map { sequence(first: $0, next: next) } ?? []` but that won’t work with the types very well, unfortunately.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As an alternative, `let first: Int? = ...; sequence(first: first, next: next).flatMap({$0})` (or even `.lazy.flatMap({$0})`) will do the right thing without making an API more complex.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I see the point of `sequence(first:next:)` to be precisely the &quot;generate the non-empty sequence using a seed and a simple producer&quot;, for anything more than that, there is `sequence(state:next:)`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What do you think?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Max<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Aug 14, 2016, at 4:27 PM, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; sequence(first:next:) takes a non-optional first argument. Is there a reason for that? sequence(state:next:) allows empty sequences, and I don’t see why sequence(first:next:) shouldn’t. The fix would be to simply add the `?` in the function signature; no other changes are required to make it work.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I considered just filing a bug report, but since this is a change of the public API...<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160819/87ff296e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>Passing an optional first argument to sequence(first:next:)</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>August 20, 2016 at 11:00:00am</p></header><div class="content"><p>What you’re saying makes sense, and I might not have brought this up in the first place if `first.map { sequence(first: $0, next: next } ?? []` worked. The main annoyance is that the best solution (currently) seems to be to copy the source code and make a change.<br></p><p>(cc-ing Jordan Rose because of a related swift-users thread) This might be a bit of a stretch, but can’t Swift upcast sequences to AnySequence implicitly, like is done with AnyHashable? That would make `first.map { sequence(first: $0, next: next } ?? []` instantly valid, I think. There’s also something to be said for consistency between type erasers. (I’m not necessarily talking about Swift 3)<br></p><p>&gt; On 20 Aug 2016, at 02:22, Max Moiseev &lt;moiseev at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi Tim,<br>&gt; <br>&gt; I still believe that having 2 termination conditions is wrong. But I guess we need a tie breaker here, someone with a strong opinion about the problem.<br>&gt; As Kevin mentioned we are very late in the release process, so waiting for another opinion for a day or two won’t change anything, really.<br>&gt; <br>&gt; Meanwhile, I played a little bit with an idea of making `first.map { sequence(first $0, next: next} ?? []` work. <br>&gt; Turns out, if we add an `ExpressibleByArrayLiteral` protocol conformance to the `UnfoldSequence`, this snippet will compile just fine. One downside is that the `ExpressibleByArrayLiteral` protocol allows creating non-empty sequences as well, which does not make sense for the `UnfoldSequence`.<br>&gt; <br>&gt; <br>&gt; Max<br>&gt; <br>&gt;&gt; On Aug 19, 2016, at 3:48 PM, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 19 Aug 2016, at 19:48, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; AFAIK this issue has never been discussed with sequence(first:next:) before. It certainly wasn&#39;t brought up during review.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As for my opinion, I&#39;m really not sure. I was going to point out that right now sequence(first:next:) guarantees that the first element of the resulting sequence is the value provided as &quot;first&quot;, but it occurs to me that if you treat the nil result from next() as an element, then this still holds true. So I guess my biggest worry is this change will make it harder to use sequence(first:next:) to produce sequences of optional values.<br>&gt;&gt; <br>&gt;&gt; I don’t think producing sequences of optional values would really be a problem, because type inference will figure this out based on whether you treat the argument to the `next` closure as an optional or not. And if you only do things in `next` that work both with optionals and non-optionals (very unlikely), you can always manually specify the type of the sequence.<br>&gt;&gt; <br>&gt;&gt;&gt; So I guess I&#39;m ambivalent, and would prefer to defer to the wisdom of the Swift core team on this matter.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That said, didn&#39;t the deadline for source-breaking changes already come and go?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Fri, Aug 19, 2016, at 10:37 AM, Max Moiseev wrote:<br>&gt;&gt;&gt;&gt; + Erica, Kevin, as the authors of the original proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Do you remember the problem of non-emptiness being discussed before? And if not, what’s your opinion on the proposed change?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; Max<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 19, 2016, at 7:53 AM, Tim Vermeulen &lt;tvermeulen at me.com &lt;mailto:tvermeulen at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi Max, thanks for having a look.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A big part of why I’m not really happy with the current implementation is that the function always produces a nonempty sequence, though the compiler doesn’t know it. `sequence(first: first, next: next).last` returns an optional, even though it can’t possibly be nil. The same goes for something like `sequence(first: 5, next: { $0 * 3 }).first(where: { $0 &gt; 1000 })`, because the sequence is infinite, which means `first(while:)` will either keep running forever, or return a non-optional.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Ideally, we’d have three types of sequences, with three corresponding `sequence(first:next:)` functions:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func sequence&lt;T&gt;(first: T?, next: (T) -&gt; T?) — returns any sequence<br>&gt;&gt;&gt;&gt;&gt; func sequence&lt;T&gt;(first: T,  next: (T) -&gt; T?) — returns a nonempty sequence<br>&gt;&gt;&gt;&gt;&gt; func sequence&lt;T&gt;(first: T,  next: (T) -&gt; T)  — returns an infinite sequence<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Default implementations for methods on sequences would either return optionals or non-optionals depending on their emptiness/finiteness. We just have the first kind of sequence right now, so in that regard it would make sense to also give `sequence(first:next)` the corresponding signature.  Later, when the language / standard library supports the other two kinds of sequences (if that ever happens), the other versions could be added.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Another reason that makes me think that the version that accepts an optional `first` argument is more natural, is the fact that the function body doesn’t need to be changed at all. It supports optional seeds by design; only the signature prevents it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I know these arguments might not be very convincing, but I feel like Swift misses an opportunity if it unnecessarily constrains the `first` parameter to be non-optional. The `.lazy.flatMap({ $0 })` alternative that you pointed out does work, but it makes everything very unreadable: not just the `.lazy.flatMap({ $0 })` part, but also the body of the `next` parameter because you’re now dealing with optionals (i.e. you have to `flatMap` over the closure argument). The best solution I’ve come up with is to copy the `sequence(first:next)` implementation from the source code and change the signature. :-/<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; `sequence(state:next:)` isn’t very appropriate for this task either, because naive usage with an optional seed has the downside of being unnecessarily eager just like a naive `sequence(first:next)` implementation (as described in a comment in the source code).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 19 Aug 2016, at 00:18, Max Moiseev &lt;moiseev at apple.com &lt;mailto:moiseev at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hi Tim,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks for bringing this up.<br>&gt;&gt;&gt;&gt;&gt;&gt; Here are my thoughts on the change you’re proposing.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func sequence&lt;T&gt;(first: T, next: (T) -&gt; T?) -&gt; UnfoldFirstSequence&lt;T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; To me the type of the function as it is tells a clear story of what’s going to happen: take the `first`, make it a head of the resulting sequence, and then try to produce the tail by a series of applications of `next`. The only thing that controls when the sequence generation terminates is the result of `next`.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If we change the type of `first` to an Optional&lt;T&gt;, it would make the termination condition non-trivial. After all, the only thing it would do is try to unwrap the `first`, before doing what it needs to, but we already have a `map` for that. One should be able to simply do the `first.map { sequence(first: $0, next: next) } ?? []` but that won’t work with the types very well, unfortunately.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As an alternative, `let first: Int? = ...; sequence(first: first, next: next).flatMap({$0})` (or even `.lazy.flatMap({$0})`) will do the right thing without making an API more complex.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I see the point of `sequence(first:next:)` to be precisely the &quot;generate the non-empty sequence using a seed and a simple producer&quot;, for anything more than that, there is `sequence(state:next:)`.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What do you think?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Max<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Aug 14, 2016, at 4:27 PM, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequence(first:next:) takes a non-optional first argument. Is there a reason for that? sequence(state:next:) allows empty sequences, and I don’t see why sequence(first:next:) shouldn’t. The fix would be to simply add the `?` in the function signature; no other changes are required to make it work.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I considered just filing a bug report, but since this is a change of the public API...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160820/eb8d56db/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c53218a6524f4d644b6a75a4441ea631?s=50"></div><header><strong>Passing an optional first argument to sequence(first:next:)</strong> from <string>Max Moiseev</string> &lt;moiseev at apple.com&gt;<p>August 24, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi Tim,<br></p><p>After having a quick conversation with Dave, here is the question I should have asked right away: can you share the typical problem you are solving with your overload of the `sequence(first:next:)` function?<br></p><p>Max<br></p><p><br>&gt; On Aug 20, 2016, at 2:26 AM, Tim Vermeulen &lt;tvermeulen at me.com&gt; wrote:<br>&gt; <br>&gt; What you’re saying makes sense, and I might not have brought this up in the first place if `first.map { sequence(first: $0, next: next } ?? []` worked. The main annoyance is that the best solution (currently) seems to be to copy the source code and make a change.<br>&gt; <br>&gt; (cc-ing Jordan Rose because of a related swift-users thread) This might be a bit of a stretch, but can’t Swift upcast sequences to AnySequence implicitly, like is done with AnyHashable? That would make `first.map { sequence(first: $0, next: next } ?? []` instantly valid, I think. There’s also something to be said for consistency between type erasers. (I’m not necessarily talking about Swift 3)<br>&gt; <br>&gt;&gt; On 20 Aug 2016, at 02:22, Max Moiseev &lt;moiseev at apple.com &lt;mailto:moiseev at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Tim,<br>&gt;&gt; <br>&gt;&gt; I still believe that having 2 termination conditions is wrong. But I guess we need a tie breaker here, someone with a strong opinion about the problem.<br>&gt;&gt; As Kevin mentioned we are very late in the release process, so waiting for another opinion for a day or two won’t change anything, really.<br>&gt;&gt; <br>&gt;&gt; Meanwhile, I played a little bit with an idea of making `first.map { sequence(first $0, next: next} ?? []` work. <br>&gt;&gt; Turns out, if we add an `ExpressibleByArrayLiteral` protocol conformance to the `UnfoldSequence`, this snippet will compile just fine. One downside is that the `ExpressibleByArrayLiteral` protocol allows creating non-empty sequences as well, which does not make sense for the `UnfoldSequence`.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Max<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 19, 2016, at 3:48 PM, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 19 Aug 2016, at 19:48, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; AFAIK this issue has never been discussed with sequence(first:next:) before. It certainly wasn&#39;t brought up during review.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As for my opinion, I&#39;m really not sure. I was going to point out that right now sequence(first:next:) guarantees that the first element of the resulting sequence is the value provided as &quot;first&quot;, but it occurs to me that if you treat the nil result from next() as an element, then this still holds true. So I guess my biggest worry is this change will make it harder to use sequence(first:next:) to produce sequences of optional values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t think producing sequences of optional values would really be a problem, because type inference will figure this out based on whether you treat the argument to the `next` closure as an optional or not. And if you only do things in `next` that work both with optionals and non-optionals (very unlikely), you can always manually specify the type of the sequence.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So I guess I&#39;m ambivalent, and would prefer to defer to the wisdom of the Swift core team on this matter.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That said, didn&#39;t the deadline for source-breaking changes already come and go?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Fri, Aug 19, 2016, at 10:37 AM, Max Moiseev wrote:<br>&gt;&gt;&gt;&gt;&gt; + Erica, Kevin, as the authors of the original proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Do you remember the problem of non-emptiness being discussed before? And if not, what’s your opinion on the proposed change?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt; Max<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Aug 19, 2016, at 7:53 AM, Tim Vermeulen &lt;tvermeulen at me.com &lt;mailto:tvermeulen at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hi Max, thanks for having a look.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A big part of why I’m not really happy with the current implementation is that the function always produces a nonempty sequence, though the compiler doesn’t know it. `sequence(first: first, next: next).last` returns an optional, even though it can’t possibly be nil. The same goes for something like `sequence(first: 5, next: { $0 * 3 }).first(where: { $0 &gt; 1000 })`, because the sequence is infinite, which means `first(while:)` will either keep running forever, or return a non-optional.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Ideally, we’d have three types of sequences, with three corresponding `sequence(first:next:)` functions:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func sequence&lt;T&gt;(first: T?, next: (T) -&gt; T?) — returns any sequence<br>&gt;&gt;&gt;&gt;&gt;&gt; func sequence&lt;T&gt;(first: T,  next: (T) -&gt; T?) — returns a nonempty sequence<br>&gt;&gt;&gt;&gt;&gt;&gt; func sequence&lt;T&gt;(first: T,  next: (T) -&gt; T)  — returns an infinite sequence<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Default implementations for methods on sequences would either return optionals or non-optionals depending on their emptiness/finiteness. We just have the first kind of sequence right now, so in that regard it would make sense to also give `sequence(first:next)` the corresponding signature.  Later, when the language / standard library supports the other two kinds of sequences (if that ever happens), the other versions could be added.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Another reason that makes me think that the version that accepts an optional `first` argument is more natural, is the fact that the function body doesn’t need to be changed at all. It supports optional seeds by design; only the signature prevents it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I know these arguments might not be very convincing, but I feel like Swift misses an opportunity if it unnecessarily constrains the `first` parameter to be non-optional. The `.lazy.flatMap({ $0 })` alternative that you pointed out does work, but it makes everything very unreadable: not just the `.lazy.flatMap({ $0 })` part, but also the body of the `next` parameter because you’re now dealing with optionals (i.e. you have to `flatMap` over the closure argument). The best solution I’ve come up with is to copy the `sequence(first:next)` implementation from the source code and change the signature. :-/<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; `sequence(state:next:)` isn’t very appropriate for this task either, because naive usage with an optional seed has the downside of being unnecessarily eager just like a naive `sequence(first:next)` implementation (as described in a comment in the source code).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 19 Aug 2016, at 00:18, Max Moiseev &lt;moiseev at apple.com &lt;mailto:moiseev at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Tim,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks for bringing this up.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Here are my thoughts on the change you’re proposing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func sequence&lt;T&gt;(first: T, next: (T) -&gt; T?) -&gt; UnfoldFirstSequence&lt;T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; To me the type of the function as it is tells a clear story of what’s going to happen: take the `first`, make it a head of the resulting sequence, and then try to produce the tail by a series of applications of `next`. The only thing that controls when the sequence generation terminates is the result of `next`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we change the type of `first` to an Optional&lt;T&gt;, it would make the termination condition non-trivial. After all, the only thing it would do is try to unwrap the `first`, before doing what it needs to, but we already have a `map` for that. One should be able to simply do the `first.map { sequence(first: $0, next: next) } ?? []` but that won’t work with the types very well, unfortunately.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; As an alternative, `let first: Int? = ...; sequence(first: first, next: next).flatMap({$0})` (or even `.lazy.flatMap({$0})`) will do the right thing without making an API more complex.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I see the point of `sequence(first:next:)` to be precisely the &quot;generate the non-empty sequence using a seed and a simple producer&quot;, for anything more than that, there is `sequence(state:next:)`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; What do you think?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Max<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Aug 14, 2016, at 4:27 PM, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequence(first:next:) takes a non-optional first argument. Is there a reason for that? sequence(state:next:) allows empty sequences, and I don’t see why sequence(first:next:) shouldn’t. The fix would be to simply add the `?` in the function signature; no other changes are required to make it work.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I considered just filing a bug report, but since this is a change of the public API...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/b39e07d6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Passing an optional first argument to sequence(first:next:)</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>August 25, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Aug 20, 2016, at 02:26, Tim Vermeulen &lt;tvermeulen at me.com&gt; wrote:<br>&gt; <br>&gt; What you’re saying makes sense, and I might not have brought this up in the first place if `first.map { sequence(first: $0, next: next } ?? []` worked. The main annoyance is that the best solution (currently) seems to be to copy the source code and make a change.<br>&gt; <br>&gt; (cc-ing Jordan Rose because of a related swift-users thread) This might be a bit of a stretch, but can’t Swift upcast sequences to AnySequence implicitly, like is done with AnyHashable? That would make `first.map { sequence(first: $0, next: next } ?? []` instantly valid, I think. There’s also something to be said for consistency between type erasers. (I’m not necessarily talking about Swift 3)<br></p><p>Sorry to let this sit. I really would not want to implement this by upcasting to AnySequence. That would be tremendously inefficient.<br></p><p>In general, AnyHashable is special because of dictionary literals, where the same thing would have to be specified over and over again. That’s not true here. (And we weren’t even going to do it for AnyHashable originally.)<br></p><p>I’m mildly in favor of the very original form of this proposal,<br></p><p>func sequence(first: T?, next: @escaping (T) -&gt; T?) -&gt; UnfoldFirstSequence&lt;T&gt;<br></p><p>It’s also very nearly an additive change; the only existing code that would change meaning is that IUOs would not cause traps. (And the contrived examples with almost no type information, where the user is currently trying to infer T = Optional&lt;X&gt; and return a sequence of Optional&lt;X&gt;.)<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160825/37c78840/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
