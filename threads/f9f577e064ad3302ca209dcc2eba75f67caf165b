<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 26, 2016 at 10:00:00am</p></header><div class="content"><p>on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;<br>&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt; confusion?<br></p><p>Some of us believe that “existential” is way too theoretical a word to<br>force into the official lexicon of Swift.  I think “Any&lt;...&gt;” is much<br>more conceptually accessible.<br></p><p>&gt; <br>&gt;   This would allow `typealias Any = Existential&lt;&gt;`.  * Should<br>&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt; deprecate it.  * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt; want to use any class requirement existential directly? If second, we<br>&gt; will need to allow direct existential usage on protocols (right now we<br>&gt; only can use typealiases as a worksround).<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 26, 2016 at 07:00:00pm</p></header><div class="content"><p>I’m not against Any&lt;…&gt; or something, I just wanted to throw this in the room because I’ve seen someone being confused about what Any&lt;…&gt; might mean. The generic manifesto has a nice wordplay that explains the true meaning: “Any type that conforms to … (all constraints) … .”<br></p><p>But someone might still think that this type awaits any type from within the angle brackets (something like oneOf&lt;A, B&gt;).<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 26. Mai 2016 bei 19:15:19, Dave Abrahams via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p><br>on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;<br>&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt; confusion?<br></p><p>Some of us believe that “existential” is way too theoretical a word to<br>force into the official lexicon of Swift. I think “Any&lt;...&gt;” is much<br>more conceptually accessible.<br></p><p>&gt;  <br>&gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt; want to use any class requirement existential directly? If second, we<br>&gt; will need to allow direct existential usage on protocols (right now we<br>&gt; only can use typealiases as a worksround).<br></p><p>--  <br>Dave<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/a5759ca9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 26, 2016 at 07:00:00pm</p></header><div class="content"><p>Inventing all these oneOf&lt;&gt; AllOf&lt;&gt;  feel like an incomplete algebra that only exist because of a fixation on cramming everything inside the Any&lt;&gt; box.<br></p><p>What are they? How will they be described in Swift programming manuals? Pseudo protocols? Protocols? Then what will their .Type be?<br></p><p>I&#39;m sorry, I cannot see where this is all going.<br></p><p>&gt; On May 26, 2016, at 7:23 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m not against Any&lt;…&gt; or something, I just wanted to throw this in the room because I’ve seen someone being confused about what Any&lt;…&gt; might mean. The generic manifesto has a nice wordplay that explains the true meaning: “Any type that conforms to … (all constraints) … .”<br>&gt; <br>&gt; But someone might still think that this type awaits any type from within the angle brackets (something like oneOf&lt;A, B&gt;).<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 26. Mai 2016 bei 19:15:19, Dave Abrahams via swift-evolution (swift-evolution at swift.org) schrieb:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt;&gt; &gt; confusion?<br>&gt;&gt; <br>&gt;&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt;&gt; force into the official lexicon of Swift. I think “Any&lt;...&gt;” is much<br>&gt;&gt; more conceptually accessible.<br>&gt;&gt; <br>&gt;&gt; &gt; <br>&gt;&gt; &gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt;&gt; &gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt;&gt; &gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt;&gt; &gt; want to use any class requirement existential directly? If second, we<br>&gt;&gt; &gt; will need to allow direct existential usage on protocols (right now we<br>&gt;&gt; &gt; only can use typealiases as a worksround).<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/607197d8/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 26, 2016 at 07:00:00pm</p></header><div class="content"><p>How about something like Type{P1 &amp; P2 | P3}  the point being that &quot;&lt;...&gt;&quot; has an established meaning in Swift today which is not what is expressed in the &quot;&lt;P1,P2,P3&gt;&quot; contained inside Any&lt;P1, P2,P3&gt;.<br></p><p>&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;&gt; <br>&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt;&gt; confusion?<br>&gt; <br>&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt; force into the official lexicon of Swift.  I think “Any&lt;...&gt;” is much<br>&gt; more conceptually accessible.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;  This would allow `typealias Any = Existential&lt;&gt;`.  * Should<br>&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt;&gt; deprecate it.  * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt;&gt; want to use any class requirement existential directly? If second, we<br>&gt;&gt; will need to allow direct existential usage on protocols (right now we<br>&gt;&gt; only can use typealiases as a worksround).<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 26, 2016 at 08:00:00pm</p></header><div class="content"><p>Don&#39;t think {} is better here, as they also have &quot;established meaning in <br>Swift today&quot;.<br></p><p>How about just Type(P1 &amp; P2 | P3) - as IMO we can think of such <br>construction as &quot;creation&quot; of new type and `P1 &amp; P2 | P3` could be treated <br>as parameters to initializer.<br></p><p>func f(t: Type(P1 &amp; P2 | P3)) {..}<br></p><p><br>On 26.05.2016 20:32, L. Mihalkovic via swift-evolution wrote:<br>&gt; How about something like Type{P1 &amp; P2 | P3}  the point being that &quot;&lt;...&gt;&quot; has an established meaning in Swift today which is not what is expressed in the &quot;&lt;P1,P2,P3&gt;&quot; contained inside Any&lt;P1, P2,P3&gt;.<br>&gt;<br>&gt;&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt;&gt;&gt; confusion?<br>&gt;&gt;<br>&gt;&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt;&gt; force into the official lexicon of Swift.  I think “Any&lt;...&gt;” is much<br>&gt;&gt; more conceptually accessible.<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  This would allow `typealias Any = Existential&lt;&gt;`.  * Should<br>&gt;&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt;&gt;&gt; deprecate it.  * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt;&gt;&gt; want to use any class requirement existential directly? If second, we<br>&gt;&gt;&gt; will need to allow direct existential usage on protocols (right now we<br>&gt;&gt;&gt; only can use typealiases as a worksround).<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 26, 2016 at 08:00:00pm</p></header><div class="content"><p>Something like type&lt;…&gt; was considered at the very start of the whole discussion (in this thread), but it does not solve the meaning of an existential type and also might lead to even more confusion.<br></p><p>From my perspective I wouldn’t use parentheses here because it looks more like an init without any label Type.init(…) or Type(…). I could live with Any[…] but this doesn’t look shiny and Swifty to me. Thats only my personal view. ;)<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 26. Mai 2016 bei 19:48:04, Vladimir.S via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>Don&#39;t think {} is better here, as they also have &quot;established meaning in  <br>Swift today&quot;.<br></p><p>How about just Type(P1 &amp; P2 | P3) - as IMO we can think of such  <br>construction as &quot;creation&quot; of new type and `P1 &amp; P2 | P3` could be treated  <br>as parameters to initializer.<br></p><p>func f(t: Type(P1 &amp; P2 | P3)) {..}<br></p><p><br>On 26.05.2016 20:32, L. Mihalkovic via swift-evolution wrote:<br>&gt; How about something like Type{P1 &amp; P2 | P3} the point being that &quot;&lt;...&gt;&quot; has an established meaning in Swift today which is not what is expressed in the &quot;&lt;P1,P2,P3&gt;&quot; contained inside Any&lt;P1, P2,P3&gt;.<br>&gt;<br>&gt;&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt;&gt;&gt; confusion?<br>&gt;&gt;<br>&gt;&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt;&gt; force into the official lexicon of Swift. I think “Any&lt;...&gt;” is much<br>&gt;&gt; more conceptually accessible.<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt;&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt;&gt;&gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt;&gt;&gt; want to use any class requirement existential directly? If second, we<br>&gt;&gt;&gt; will need to allow direct existential usage on protocols (right now we<br>&gt;&gt;&gt; only can use typealiases as a worksround).<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/7e3453c1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 27, 2016 at 10:00:00am</p></header><div class="content"><p>We could just write<br></p><p>let x: P &amp; Q<br>instead of<br>let x: Any&lt;P, Q&gt;<br></p><p>let x: Collection where .Element: P<br>instead of<br>let x: Any&lt;Collection where .Element: P&gt;<br></p><p>let x: P &amp; Q where P.T == Q.T<br>instead of<br>let x: Any&lt;P, Q where P.T == Q.T&gt;<br></p><p>let x: P &amp; Q &amp; R<br>instead of<br>let x: Any&lt;P, Q, R&gt;<br></p><p>let x: Collection<br>instead of<br>let x: Any&lt;Collection&gt;<br></p><p><br>This would avoid the confusion of Any&lt;T1, T2&gt; being something completely different than a generic type (i.e. order of T1, T2 does not matter whereas for generic types it is essential).<br></p><p><br>-Thorsten<br></p><p><br></p><p>&gt; Am 26.05.2016 um 20:11 schrieb Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Something like type&lt;…&gt; was considered at the very start of the whole discussion (in this thread &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html&gt;), but it does not solve the meaning of an existential type and also might lead to even more confusion. <br>&gt; <br>&gt; From my perspective I wouldn’t use parentheses here because it looks more like an init without any label Type.init(…) or Type(…). I could live with Any[…] but this doesn’t look shiny and Swifty to me. Thats only my personal view. ;)<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 26. Mai 2016 bei 19:48:04, Vladimir.S via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt; <br>&gt;&gt; Don&#39;t think {} is better here, as they also have &quot;established meaning in <br>&gt;&gt; Swift today&quot;.<br>&gt;&gt; <br>&gt;&gt; How about just Type(P1 &amp; P2 | P3) - as IMO we can think of such <br>&gt;&gt; construction as &quot;creation&quot; of new type and `P1 &amp; P2 | P3` could be treated <br>&gt;&gt; as parameters to initializer.<br>&gt;&gt; <br>&gt;&gt; func f(t: Type(P1 &amp; P2 | P3)) {..}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On 26.05.2016 20:32, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt; &gt; How about something like Type{P1 &amp; P2 | P3} the point being that &quot;&lt;...&gt;&quot; has an established meaning in Swift today which is not what is expressed in the &quot;&lt;P1,P2,P3&gt;&quot; contained inside Any&lt;P1, P2,P3&gt;.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt;&gt; &gt;&gt;&gt; confusion?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt;&gt; &gt;&gt; force into the official lexicon of Swift. I think “Any&lt;...&gt;” is much<br>&gt;&gt; &gt;&gt; more conceptually accessible.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt;&gt; &gt;&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt;&gt; &gt;&gt;&gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt;&gt; &gt;&gt;&gt; want to use any class requirement existential directly? If second, we<br>&gt;&gt; &gt;&gt;&gt; will need to allow direct existential usage on protocols (right now we<br>&gt;&gt; &gt;&gt;&gt; only can use typealiases as a worksround).<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; --<br>&gt;&gt; &gt;&gt; Dave<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/2ea9ebf9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 27, 2016 at 12:00:00pm</p></header><div class="content"><p>It seem to me we are debating the how of a what that has not been defined. The root question behind all these alternatives seems to be to decide if the existential-ness should be carried by a &#39;container&#39; that is then refined internally, or derived from the presence of the free-floating refinements. This is the question that splits the possible syntaxes into these 2 groups:<br></p><p>Any&lt;&gt; Any[]<br>Type&lt;&gt; Type&lt;&gt; <br>Existential&lt;&gt;<br></p><p>and the (these are all straw man representations that should not limit the thinking)<br></p><p>P &amp; Q<br>@P and @Q<br>is P , Q<br>P &amp; Q typed<br></p><p>If the answer is to use a &#39;container&#39; then the next question is to see its relationship to the other existing containers: is it the result of a transformation, is it a superset, or a super type; it is obviously lossy, but not entirely if the solution follows in some of Brent&#39;s past suggestion to make some existential types instantiate-able (which opens a very similar problem to what java faced for several years when trying to identify a universal collection literal syntax).<br>That will narrow down the field of possible matches... until one syntax emerges as conveying the meaning that is reflected by the answers to each question.<br></p><p>&gt; On May 27, 2016, at 10:55 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; We could just write<br>&gt; <br>&gt; let x: P &amp; Q<br>&gt; instead of<br>&gt; let x: Any&lt;P, Q&gt;<br>&gt; <br>&gt; let x: Collection where .Element: P<br>&gt; instead of<br>&gt; let x: Any&lt;Collection where .Element: P&gt;<br>&gt; <br>&gt; let x: P &amp; Q where P.T == Q.T<br>&gt; instead of<br>&gt; let x: Any&lt;P, Q where P.T == Q.T&gt;<br>&gt; <br>&gt; let x: P &amp; Q &amp; R<br>&gt; instead of<br>&gt; let x: Any&lt;P, Q, R&gt;<br>&gt; <br>&gt; let x: Collection<br>&gt; instead of<br>&gt; let x: Any&lt;Collection&gt;<br>&gt; <br>&gt; <br>&gt; This would avoid the confusion of Any&lt;T1, T2&gt; being something completely different than a generic type (i.e. order of T1, T2 does not matter whereas for generic types it is essential).<br>&gt; <br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Am 26.05.2016 um 20:11 schrieb Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; Something like type&lt;…&gt; was considered at the very start of the whole discussion (in this thread), but it does not solve the meaning of an existential type and also might lead to even more confusion. <br>&gt;&gt; <br>&gt;&gt; From my perspective I wouldn’t use parentheses here because it looks more like an init without any label Type.init(…) or Type(…). I could live with Any[…] but this doesn’t look shiny and Swifty to me. Thats only my personal view. ;)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; Am 26. Mai 2016 bei 19:48:04, Vladimir.S via swift-evolution (swift-evolution at swift.org) schrieb:<br>&gt;&gt; <br>&gt;&gt;&gt; Don&#39;t think {} is better here, as they also have &quot;established meaning in <br>&gt;&gt;&gt; Swift today&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How about just Type(P1 &amp; P2 | P3) - as IMO we can think of such <br>&gt;&gt;&gt; construction as &quot;creation&quot; of new type and `P1 &amp; P2 | P3` could be treated <br>&gt;&gt;&gt; as parameters to initializer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func f(t: Type(P1 &amp; P2 | P3)) {..}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 26.05.2016 20:32, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt; &gt; How about something like Type{P1 &amp; P2 | P3} the point being that &quot;&lt;...&gt;&quot; has an established meaning in Swift today which is not what is expressed in the &quot;&lt;P1,P2,P3&gt;&quot; contained inside Any&lt;P1, P2,P3&gt;.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt;&gt;&gt; &gt;&gt;&gt; confusion?<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt;&gt;&gt; &gt;&gt; force into the official lexicon of Swift. I think “Any&lt;...&gt;” is much<br>&gt;&gt;&gt; &gt;&gt; more conceptually accessible.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt;&gt;&gt; &gt;&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt;&gt;&gt; &gt;&gt;&gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt;&gt;&gt; &gt;&gt;&gt; want to use any class requirement existential directly? If second, we<br>&gt;&gt;&gt; &gt;&gt;&gt; will need to allow direct existential usage on protocols (right now we<br>&gt;&gt;&gt; &gt;&gt;&gt; only can use typealiases as a worksround).<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; --<br>&gt;&gt;&gt; &gt;&gt; Dave<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/6722d7fe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 27, 2016 at 02:00:00pm</p></header><div class="content"><p>From the point of view of the type system `P &amp; Q` is an anonymous supertype of `P` and `Q`.<br>This would be just the same if the syntax was `Any&lt;P, Q&gt;`. I don’t see a semantic difference here.<br></p><p>Whether that is a &quot;container“ or not seems to be an implementation detail to me but should have nothing to do with the type system.<br>In what way should it be &quot;lossy“?<br></p><p>Am I missing something?<br></p><p>-Thorsten<br></p><p><br>&gt; Am 27.05.2016 um 12:30 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt; <br>&gt; It seem to me we are debating the how of a what that has not been defined. The root question behind all these alternatives seems to be to decide if the existential-ness should be carried by a &#39;container&#39; that is then refined internally, or derived from the presence of the free-floating refinements. This is the question that splits the possible syntaxes into these 2 groups:<br>&gt; <br>&gt; Any&lt;&gt; Any[]<br>&gt; Type&lt;&gt; Type&lt;&gt; <br>&gt; Existential&lt;&gt;<br>&gt; <br>&gt; and the (these are all straw man representations that should not limit the thinking)<br>&gt; <br>&gt; P &amp; Q<br>&gt; @P and @Q<br>&gt; is P , Q<br>&gt; P &amp; Q typed<br>&gt; <br>&gt; If the answer is to use a &#39;container&#39; then the next question is to see its relationship to the other existing containers: is it the result of a transformation, is it a superset, or a super type; it is obviously lossy, but not entirely if the solution follows in some of Brent&#39;s past suggestion to make some existential types instantiate-able (which opens a very similar problem to what java faced for several years when trying to identify a universal collection literal syntax).<br>&gt; That will narrow down the field of possible matches... until one syntax emerges as conveying the meaning that is reflected by the answers to each question.<br>&gt; <br>&gt; On May 27, 2016, at 10:55 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; We could just write<br>&gt;&gt; <br>&gt;&gt; let x: P &amp; Q<br>&gt;&gt; instead of<br>&gt;&gt; let x: Any&lt;P, Q&gt;<br>&gt;&gt; <br>&gt;&gt; let x: Collection where .Element: P<br>&gt;&gt; instead of<br>&gt;&gt; let x: Any&lt;Collection where .Element: P&gt;<br>&gt;&gt; <br>&gt;&gt; let x: P &amp; Q where P.T == Q.T<br>&gt;&gt; instead of<br>&gt;&gt; let x: Any&lt;P, Q where P.T == Q.T&gt;<br>&gt;&gt; <br>&gt;&gt; let x: P &amp; Q &amp; R<br>&gt;&gt; instead of<br>&gt;&gt; let x: Any&lt;P, Q, R&gt;<br>&gt;&gt; <br>&gt;&gt; let x: Collection<br>&gt;&gt; instead of<br>&gt;&gt; let x: Any&lt;Collection&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This would avoid the confusion of Any&lt;T1, T2&gt; being something completely different than a generic type (i.e. order of T1, T2 does not matter whereas for generic types it is essential).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 26.05.2016 um 20:11 schrieb Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Something like type&lt;…&gt; was considered at the very start of the whole discussion (in this thread &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html&gt;), but it does not solve the meaning of an existential type and also might lead to even more confusion. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From my perspective I wouldn’t use parentheses here because it looks more like an init without any label Type.init(…) or Type(…). I could live with Any[…] but this doesn’t look shiny and Swifty to me. Thats only my personal view. ;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 26. Mai 2016 bei 19:48:04, Vladimir.S via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Don&#39;t think {} is better here, as they also have &quot;established meaning in <br>&gt;&gt;&gt;&gt; Swift today&quot;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How about just Type(P1 &amp; P2 | P3) - as IMO we can think of such <br>&gt;&gt;&gt;&gt; construction as &quot;creation&quot; of new type and `P1 &amp; P2 | P3` could be treated <br>&gt;&gt;&gt;&gt; as parameters to initializer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func f(t: Type(P1 &amp; P2 | P3)) {..}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 26.05.2016 20:32, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; &gt; How about something like Type{P1 &amp; P2 | P3} the point being that &quot;&lt;...&gt;&quot; has an established meaning in Swift today which is not what is expressed in the &quot;&lt;P1,P2,P3&gt;&quot; contained inside Any&lt;P1, P2,P3&gt;.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; confusion?<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt;&gt;&gt;&gt; &gt;&gt; force into the official lexicon of Swift. I think “Any&lt;...&gt;” is much<br>&gt;&gt;&gt;&gt; &gt;&gt; more conceptually accessible.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; want to use any class requirement existential directly? If second, we<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; will need to allow direct existential usage on protocols (right now we<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; only can use typealiases as a worksround).<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; --<br>&gt;&gt;&gt;&gt; &gt;&gt; Dave<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/7d38d8f2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 27, 2016, at 7:20 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; From the point of view of the type system `P &amp; Q` is an anonymous supertype of `P` and `Q`.<br>&gt; This would be just the same if the syntax was `Any&lt;P, Q&gt;`. I don’t see a semantic difference here.<br>&gt; <br>&gt; Whether that is a &quot;container“ or not seems to be an implementation detail to me but should have nothing to do with the type system.<br>&gt; In what way should it be &quot;lossy“?<br>&gt; <br>&gt; Am I missing something?<br></p><p>I was a bit confused as well and had to read this several times.  I think this is talking about a syntactic “container” - i.e. brackets of some kind (as opposed to a “free floating” syntax).  I don’t think it is talking about a semantic difference of any kind.  But maybe I am still confused an not understanding what was intended...<br></p><p>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; Am 27.05.2016 um 12:30 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; It seem to me we are debating the how of a what that has not been defined. The root question behind all these alternatives seems to be to decide if the existential-ness should be carried by a &#39;container&#39; that is then refined internally, or derived from the presence of the free-floating refinements. This is the question that splits the possible syntaxes into these 2 groups:<br>&gt;&gt; <br>&gt;&gt; Any&lt;&gt; Any[]<br>&gt;&gt; Type&lt;&gt; Type&lt;&gt; <br>&gt;&gt; Existential&lt;&gt;<br>&gt;&gt; <br>&gt;&gt; and the (these are all straw man representations that should not limit the thinking)<br>&gt;&gt; <br>&gt;&gt; P &amp; Q<br>&gt;&gt; @P and @Q<br>&gt;&gt; is P , Q<br>&gt;&gt; P &amp; Q typed<br>&gt;&gt; <br>&gt;&gt; If the answer is to use a &#39;container&#39; then the next question is to see its relationship to the other existing containers: is it the result of a transformation, is it a superset, or a super type; it is obviously lossy, but not entirely if the solution follows in some of Brent&#39;s past suggestion to make some existential types instantiate-able (which opens a very similar problem to what java faced for several years when trying to identify a universal collection literal syntax).<br>&gt;&gt; That will narrow down the field of possible matches... until one syntax emerges as conveying the meaning that is reflected by the answers to each question.<br>&gt;&gt; <br>&gt;&gt; On May 27, 2016, at 10:55 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; We could just write<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x: P &amp; Q<br>&gt;&gt;&gt; instead of<br>&gt;&gt;&gt; let x: Any&lt;P, Q&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x: Collection where .Element: P<br>&gt;&gt;&gt; instead of<br>&gt;&gt;&gt; let x: Any&lt;Collection where .Element: P&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x: P &amp; Q where P.T == Q.T<br>&gt;&gt;&gt; instead of<br>&gt;&gt;&gt; let x: Any&lt;P, Q where P.T == Q.T&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x: P &amp; Q &amp; R<br>&gt;&gt;&gt; instead of<br>&gt;&gt;&gt; let x: Any&lt;P, Q, R&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x: Collection<br>&gt;&gt;&gt; instead of<br>&gt;&gt;&gt; let x: Any&lt;Collection&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would avoid the confusion of Any&lt;T1, T2&gt; being something completely different than a generic type (i.e. order of T1, T2 does not matter whereas for generic types it is essential).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 26.05.2016 um 20:11 schrieb Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Something like type&lt;…&gt; was considered at the very start of the whole discussion (in this thread &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html&gt;), but it does not solve the meaning of an existential type and also might lead to even more confusion. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; From my perspective I wouldn’t use parentheses here because it looks more like an init without any label Type.init(…) or Type(…). I could live with Any[…] but this doesn’t look shiny and Swifty to me. Thats only my personal view. ;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 26. Mai 2016 bei 19:48:04, Vladimir.S via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Don&#39;t think {} is better here, as they also have &quot;established meaning in <br>&gt;&gt;&gt;&gt;&gt; Swift today&quot;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; How about just Type(P1 &amp; P2 | P3) - as IMO we can think of such <br>&gt;&gt;&gt;&gt;&gt; construction as &quot;creation&quot; of new type and `P1 &amp; P2 | P3` could be treated <br>&gt;&gt;&gt;&gt;&gt; as parameters to initializer.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func f(t: Type(P1 &amp; P2 | P3)) {..}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 26.05.2016 20:32, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt; How about something like Type{P1 &amp; P2 | P3} the point being that &quot;&lt;...&gt;&quot; has an established meaning in Swift today which is not what is expressed in the &quot;&lt;P1,P2,P3&gt;&quot; contained inside Any&lt;P1, P2,P3&gt;.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; confusion?<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; force into the official lexicon of Swift. I think “Any&lt;...&gt;” is much<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; more conceptually accessible.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; want to use any class requirement existential directly? If second, we<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; will need to allow direct existential usage on protocols (right now we<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; only can use typealiases as a worksround).<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/7a748190/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 27, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 4:52 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 27, 2016, at 7:20 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; From the point of view of the type system `P &amp; Q` is an anonymous supertype of `P` and `Q`.<br>&gt;&gt; This would be just the same if the syntax was `Any&lt;P, Q&gt;`. I don’t see a semantic difference here.<br>&gt;&gt; <br>&gt;&gt; Whether that is a &quot;container“ or not seems to be an implementation detail to me but should have nothing to do with the type system.<br>&gt;&gt; In what way should it be &quot;lossy“?<br></p><p>what is by definition lossy, is the relationship between a type and an existential type that can represent it. Comes from the fact that there is no way to go back to the type we started from once all we hold is the existential (i.e.  means it is a one —&gt; n mapping relationship, not a 1 —&gt; 1). Not the notation.<br>right?<br></p><p>&gt;&gt; <br>&gt;&gt; Am I missing something?<br>&gt; <br>&gt; I was a bit confused as well and had to read this several times.  I think this is talking about a syntactic “container” - i.e. brackets of some kind (as opposed to a “free floating” syntax).  I don’t think it is talking about a semantic difference of any kind.  But maybe I am still confused an not understanding what was intended...<br></p><p><br>given the semantic we wish to express (combination of conformance declarations), what possible ways do we have to express it. It come down to 2 families of syntax: the ‘container’ form, of which I gave a few examples, versus the non-container form (or free-floating conformance list) of which the straight list is the most obvious, but not the only one. <br></p><p>Joe Groff was reminding us that the second group of syntax also exists.<br></p><p>Compilers love Any&lt;P...Q&gt; , people’s brains love  P &amp; Q<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 27.05.2016 um 12:30 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seem to me we are debating the how of a what that has not been defined. The root question behind all these alternatives seems to be to decide if the existential-ness should be carried by a &#39;container&#39; that is then refined internally, or derived from the presence of the free-floating refinements. This is the question that splits the possible syntaxes into these 2 groups:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any&lt;&gt; Any[]<br>&gt;&gt;&gt; Type&lt;&gt; Type&lt;&gt; <br></p><p>this was meant to read <br>Type&lt;…&gt;  Type { …. }   Type[ … ]<br></p><p>&gt;&gt;&gt; Existential&lt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and the (these are all straw man representations that should not limit the thinking)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; P &amp; Q<br>&gt;&gt;&gt; @P and @Q<br>&gt;&gt;&gt; is P , Q<br>&gt;&gt;&gt; P &amp; Q typed<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If the answer is to use a &#39;container&#39; then the next question is to see its relationship to the other existing containers: is it the result of a transformation, is it a superset, or a super type; it is obviously lossy, but not entirely if the solution follows in some of Brent&#39;s past suggestion to make some existential types instantiate-able (which opens a very similar problem to what java faced for several years when trying to identify a universal collection literal syntax).<br>&gt;&gt;&gt; That will narrow down the field of possible matches... until one syntax emerges as conveying the meaning that is reflected by the answers to each question.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 27, 2016, at 10:55 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We could just write<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let x: P &amp; Q<br>&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt; let x: Any&lt;P, Q&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let x: Collection where .Element: P<br>&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt; let x: Any&lt;Collection where .Element: P&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let x: P &amp; Q where P.T == Q.T<br>&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt; let x: Any&lt;P, Q where P.T == Q.T&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let x: P &amp; Q &amp; R<br>&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt; let x: Any&lt;P, Q, R&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let x: Collection<br>&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt; let x: Any&lt;Collection&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This would avoid the confusion of Any&lt;T1, T2&gt; being something completely different than a generic type (i.e. order of T1, T2 does not matter whereas for generic types it is essential).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 26.05.2016 um 20:11 schrieb Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Something like type&lt;…&gt; was considered at the very start of the whole discussion (in this thread &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html&gt;), but it does not solve the meaning of an existential type and also might lead to even more confusion. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; From my perspective I wouldn’t use parentheses here because it looks more like an init without any label Type.init(…) or Type(…). I could live with Any[…] but this doesn’t look shiny and Swifty to me. Thats only my personal view. ;)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 26. Mai 2016 bei 19:48:04, Vladimir.S via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Don&#39;t think {} is better here, as they also have &quot;established meaning in <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift today&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; How about just Type(P1 &amp; P2 | P3) - as IMO we can think of such <br>&gt;&gt;&gt;&gt;&gt;&gt; construction as &quot;creation&quot; of new type and `P1 &amp; P2 | P3` could be treated <br>&gt;&gt;&gt;&gt;&gt;&gt; as parameters to initializer.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func f(t: Type(P1 &amp; P2 | P3)) {..}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 26.05.2016 20:32, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; How about something like Type{P1 &amp; P2 | P3} the point being that &quot;&lt;...&gt;&quot; has an established meaning in Swift today which is not what is expressed in the &quot;&lt;P1,P2,P3&gt;&quot; contained inside Any&lt;P1, P2,P3&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; confusion?<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; force into the official lexicon of Swift. I think “Any&lt;...&gt;” is much<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; more conceptually accessible.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; want to use any class requirement existential directly? If second, we<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; will need to allow direct existential usage on protocols (right now we<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; only can use typealiases as a worksround).<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/958e09c3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 27, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 27.05.2016 um 17:15 schrieb L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On May 27, 2016, at 4:52 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 27, 2016, at 7:20 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From the point of view of the type system `P &amp; Q` is an anonymous supertype of `P` and `Q`.<br>&gt;&gt;&gt; This would be just the same if the syntax was `Any&lt;P, Q&gt;`. I don’t see a semantic difference here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Whether that is a &quot;container“ or not seems to be an implementation detail to me but should have nothing to do with the type system.<br>&gt;&gt;&gt; In what way should it be &quot;lossy“?<br>&gt; <br>&gt; what is by definition lossy, is the relationship between a type and an existential type that can represent it. Comes from the fact that there is no way to go back to the type we started from once all we hold is the existential (i.e.  means it is a one —&gt; n mapping relationship, not a 1 —&gt; 1). Not the notation.<br>&gt; right?<br></p><p>Right. A protocol with associated types is more like a type family than a type.<br></p><p>protocol P {<br>	associatedtype T<br></p><p>	var a: T<br>	func f(_ value: T) -&gt; Int<br>}<br></p><p>any&lt;P&gt; represents the whole type family with unbound T, i.e. a set of types with one element for each possible value of T<br>any&lt;P where T: Equatable&gt; represents a subset of the whole type family, i.e. all elements where T conforms to Equatable <br>any&lt;P where T == Int&gt; represents a concrete type, i.e. one element of the whole type family<br></p><p>So, like you say, the semantics are clear and are independent of the notation.<br></p><p><br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am I missing something?<br>&gt;&gt; <br>&gt;&gt; I was a bit confused as well and had to read this several times.  I think this is talking about a syntactic “container” - i.e. brackets of some kind (as opposed to a “free floating” syntax).  I don’t think it is talking about a semantic difference of any kind.  But maybe I am still confused an not understanding what was intended...<br>&gt; <br>&gt; <br>&gt; given the semantic we wish to express (combination of conformance declarations), what possible ways do we have to express it. It come down to 2 families of syntax: the ‘container’ form, of which I gave a few examples, versus the non-container form (or free-floating conformance list) of which the straight list is the most obvious, but not the only one. <br></p><p>Ok, so you meant the syntactical form of `any&lt;…&gt;` with &quot;container“. Agreed.<br></p><p><br>&gt; Joe Groff was reminding us that the second group of syntax also exists.<br>&gt; <br>&gt; Compilers love Any&lt;P...Q&gt; , people’s brains love  P &amp; Q<br></p><p>Yes, at least mine :-)<br></p><p>-Thorsten<br></p><p><br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 27.05.2016 um 12:30 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seem to me we are debating the how of a what that has not been defined. The root question behind all these alternatives seems to be to decide if the existential-ness should be carried by a &#39;container&#39; that is then refined internally, or derived from the presence of the free-floating refinements. This is the question that splits the possible syntaxes into these 2 groups:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Any&lt;&gt; Any[]<br>&gt;&gt;&gt;&gt; Type&lt;&gt; Type&lt;&gt; <br>&gt; <br>&gt; this was meant to read <br>&gt; Type&lt;…&gt;  Type { …. }   Type[ … ]<br>&gt; <br>&gt;&gt;&gt;&gt; Existential&lt;&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; and the (these are all straw man representations that should not limit the thinking)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; P &amp; Q<br>&gt;&gt;&gt;&gt; @P and @Q<br>&gt;&gt;&gt;&gt; is P , Q<br>&gt;&gt;&gt;&gt; P &amp; Q typed<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If the answer is to use a &#39;container&#39; then the next question is to see its relationship to the other existing containers: is it the result of a transformation, is it a superset, or a super type; it is obviously lossy, but not entirely if the solution follows in some of Brent&#39;s past suggestion to make some existential types instantiate-able (which opens a very similar problem to what java faced for several years when trying to identify a universal collection literal syntax).<br>&gt;&gt;&gt;&gt; That will narrow down the field of possible matches... until one syntax emerges as conveying the meaning that is reflected by the answers to each question.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 27, 2016, at 10:55 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We could just write<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q<br>&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let x: Collection where .Element: P<br>&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt; let x: Any&lt;Collection where .Element: P&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q where P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q where P.T == Q.T&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q &amp; R<br>&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q, R&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let x: Collection<br>&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt; let x: Any&lt;Collection&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This would avoid the confusion of Any&lt;T1, T2&gt; being something completely different than a generic type (i.e. order of T1, T2 does not matter whereas for generic types it is essential).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 26.05.2016 um 20:11 schrieb Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Something like type&lt;…&gt; was considered at the very start of the whole discussion (in this thread &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html&gt;), but it does not solve the meaning of an existential type and also might lead to even more confusion. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; From my perspective I wouldn’t use parentheses here because it looks more like an init without any label Type.init(…) or Type(…). I could live with Any[…] but this doesn’t look shiny and Swifty to me. Thats only my personal view. ;)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 26. Mai 2016 bei 19:48:04, Vladimir.S via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Don&#39;t think {} is better here, as they also have &quot;established meaning in <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift today&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; How about just Type(P1 &amp; P2 | P3) - as IMO we can think of such <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; construction as &quot;creation&quot; of new type and `P1 &amp; P2 | P3` could be treated <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; as parameters to initializer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func f(t: Type(P1 &amp; P2 | P3)) {..}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 26.05.2016 20:32, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; How about something like Type{P1 &amp; P2 | P3} the point being that &quot;&lt;...&gt;&quot; has an established meaning in Swift today which is not what is expressed in the &quot;&lt;P1,P2,P3&gt;&quot; contained inside Any&lt;P1, P2,P3&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; confusion?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; force into the official lexicon of Swift. I think “Any&lt;...&gt;” is much<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; more conceptually accessible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; want to use any class requirement existential directly? If second, we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; will need to allow direct existential usage on protocols (right now we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; only can use typealiases as a worksround).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/2301256f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 27, 2016 at 03:00:00pm</p></header><div class="content"><p>Btw, in case we have `where` keyword in syntax related to types/protocols <br>(when defining constrains. and not some symbol like &#39;&gt;&gt;&#39;.. don&#39;t know, for <br>example), why we can&#39;t have &#39;and&#39; keyword also when discuss the syntax of <br>type/protocol conjunction?<br>I.e.<br></p><p>let x: P and Q<br>let x: P and Q where P.T == Q.T<br>let x: P and Q and R<br></p><p>or, for consistency, as I understand it, we should have<br>let x: P &amp; Q &gt;&gt; P.T == Q.T<br></p><p>On 27.05.2016 11:55, Thorsten Seitz via swift-evolution wrote:<br>&gt; We could just write<br>&gt;<br>&gt; let x: P &amp; Q<br>&gt; instead of<br>&gt; let x: Any&lt;P, Q&gt;<br>&gt;<br>&gt; let x: Collection where .Element: P<br>&gt; instead of<br>&gt; let x: Any&lt;Collection where .Element: P&gt;<br>&gt;<br>&gt; let x: P &amp; Q where P.T == Q.T<br>&gt; instead of<br>&gt; let x: Any&lt;P, Q where P.T == Q.T&gt;<br>&gt;<br>&gt; let x: P &amp; Q &amp; R<br>&gt; instead of<br>&gt; let x: Any&lt;P, Q, R&gt;<br>&gt;<br>&gt; let x: Collection<br>&gt; instead of<br>&gt; let x: Any&lt;Collection&gt;<br>&gt;<br>&gt;<br>&gt; This would avoid the confusion of Any&lt;T1, T2&gt; being something completely<br>&gt; different than a generic type (i.e. order of T1, T2 does not matter whereas<br>&gt; for generic types it is essential).<br>&gt;<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; Am 26.05.2016 um 20:11 schrieb Adrian Zubarev via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;<br>&gt;&gt; Something like |type&lt;…&gt;| was considered at the very start of the whole<br>&gt;&gt; discussion (in this thread<br>&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html&gt;),<br>&gt;&gt; but it does not solve the meaning of an existential type and also might<br>&gt;&gt; lead to even more confusion.<br>&gt;&gt;<br>&gt;&gt; From my perspective I wouldn’t use parentheses here because it looks more<br>&gt;&gt; like an init without any label |Type.init(…)| or |Type(…)|. I could live<br>&gt;&gt; with |Any[…]| but this doesn’t look shiny and Swifty to me. Thats only my<br>&gt;&gt; personal view. ;)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt;<br>&gt;&gt; Am 26. Mai 2016 bei 19:48:04, Vladimir.S via swift-evolution<br>&gt;&gt; (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt;&gt;<br>&gt;&gt;&gt; Don&#39;t think {} is better here, as they also have &quot;established meaning in<br>&gt;&gt;&gt; Swift today&quot;.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; How about just Type(P1 &amp; P2 | P3) - as IMO we can think of such<br>&gt;&gt;&gt; construction as &quot;creation&quot; of new type and `P1 &amp; P2 | P3` could be treated<br>&gt;&gt;&gt; as parameters to initializer.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func f(t: Type(P1 &amp; P2 | P3)) {..}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 26.05.2016 20:32, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt; &gt; How about something like Type{P1 &amp; P2 | P3} the point being that &quot;&lt;...&gt;&quot; has an established meaning in Swift today which is not what is expressed in the &quot;&lt;P1,P2,P3&gt;&quot; contained inside Any&lt;P1, P2,P3&gt;.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt;&gt;&gt; &gt;&gt;&gt; confusion?<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt;&gt;&gt; &gt;&gt; force into the official lexicon of Swift. I think “Any&lt;...&gt;” is much<br>&gt;&gt;&gt; &gt;&gt; more conceptually accessible.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt;&gt;&gt; &gt;&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt;&gt;&gt; &gt;&gt;&gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt;&gt;&gt; &gt;&gt;&gt; want to use any class requirement existential directly? If second, we<br>&gt;&gt;&gt; &gt;&gt;&gt; will need to allow direct existential usage on protocols (right now we<br>&gt;&gt;&gt; &gt;&gt;&gt; only can use typealiases as a worksround).<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; --<br>&gt;&gt;&gt; &gt;&gt; Dave<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 27, 2016 at 03:00:00pm</p></header><div class="content"><p>Personally I think `&amp;` is more lightweight (and it is established in other languages like Ceylon and Typescript) and `where` is more expressive (and established in Swift for introducing constraints), so I would stay with these.<br></p><p>-Thorsten<br></p><p><br>&gt; Am 27.05.2016 um 14:34 schrieb Vladimir.S &lt;svabox at gmail.com&gt;:<br>&gt; <br>&gt; Btw, in case we have `where` keyword in syntax related to types/protocols (when defining constrains. and not some symbol like &#39;&gt;&gt;&#39;.. don&#39;t know, for example), why we can&#39;t have &#39;and&#39; keyword also when discuss the syntax of type/protocol conjunction?<br>&gt; I.e.<br>&gt; <br>&gt; let x: P and Q<br>&gt; let x: P and Q where P.T == Q.T<br>&gt; let x: P and Q and R<br>&gt; <br>&gt; or, for consistency, as I understand it, we should have<br>&gt; let x: P &amp; Q &gt;&gt; P.T == Q.T<br>&gt; <br>&gt; On 27.05.2016 11:55, Thorsten Seitz via swift-evolution wrote:<br>&gt;&gt; We could just write<br>&gt;&gt; <br>&gt;&gt; let x: P &amp; Q<br>&gt;&gt; instead of<br>&gt;&gt; let x: Any&lt;P, Q&gt;<br>&gt;&gt; <br>&gt;&gt; let x: Collection where .Element: P<br>&gt;&gt; instead of<br>&gt;&gt; let x: Any&lt;Collection where .Element: P&gt;<br>&gt;&gt; <br>&gt;&gt; let x: P &amp; Q where P.T == Q.T<br>&gt;&gt; instead of<br>&gt;&gt; let x: Any&lt;P, Q where P.T == Q.T&gt;<br>&gt;&gt; <br>&gt;&gt; let x: P &amp; Q &amp; R<br>&gt;&gt; instead of<br>&gt;&gt; let x: Any&lt;P, Q, R&gt;<br>&gt;&gt; <br>&gt;&gt; let x: Collection<br>&gt;&gt; instead of<br>&gt;&gt; let x: Any&lt;Collection&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This would avoid the confusion of Any&lt;T1, T2&gt; being something completely<br>&gt;&gt; different than a generic type (i.e. order of T1, T2 does not matter whereas<br>&gt;&gt; for generic types it is essential).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 26.05.2016 um 20:11 schrieb Adrian Zubarev via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Something like |type&lt;…&gt;| was considered at the very start of the whole<br>&gt;&gt;&gt; discussion (in this thread<br>&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html&gt;&gt;),<br>&gt;&gt;&gt; but it does not solve the meaning of an existential type and also might<br>&gt;&gt;&gt; lead to even more confusion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From my perspective I wouldn’t use parentheses here because it looks more<br>&gt;&gt;&gt; like an init without any label |Type.init(…)| or |Type(…)|. I could live<br>&gt;&gt;&gt; with |Any[…]| but this doesn’t look shiny and Swifty to me. Thats only my<br>&gt;&gt;&gt; personal view. ;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 26. Mai 2016 bei 19:48:04, Vladimir.S via swift-evolution<br>&gt;&gt;&gt; (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;) schrieb:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Don&#39;t think {} is better here, as they also have &quot;established meaning in<br>&gt;&gt;&gt;&gt; Swift today&quot;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How about just Type(P1 &amp; P2 | P3) - as IMO we can think of such<br>&gt;&gt;&gt;&gt; construction as &quot;creation&quot; of new type and `P1 &amp; P2 | P3` could be treated<br>&gt;&gt;&gt;&gt; as parameters to initializer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func f(t: Type(P1 &amp; P2 | P3)) {..}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 26.05.2016 20:32, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; &gt; How about something like Type{P1 &amp; P2 | P3} the point being that &quot;&lt;...&gt;&quot; has an established meaning in Swift today which is not what is expressed in the &quot;&lt;P1,P2,P3&gt;&quot; contained inside Any&lt;P1, P2,P3&gt;.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; confusion?<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt;&gt;&gt;&gt; &gt;&gt; force into the official lexicon of Swift. I think “Any&lt;...&gt;” is much<br>&gt;&gt;&gt;&gt; &gt;&gt; more conceptually accessible.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; want to use any class requirement existential directly? If second, we<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; will need to allow direct existential usage on protocols (right now we<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; only can use typealiases as a worksround).<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; --<br>&gt;&gt;&gt;&gt; &gt;&gt; Dave<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/5866b712/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 27, 2016, at 8:18 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Personally I think `&amp;` is more lightweight (and it is established in other languages like Ceylon and Typescript) and `where` is more expressive (and established in Swift for introducing constraints), so I would stay with these.<br></p><p>I agree.  If we can make `&amp;` with `where` work syntactically it would be nice to go in this lighter weight direction.  If we decide to do that the question then becomes what to do with `protocol`.  Would it be feasible to replace it with `&amp;` in Swift 3 if we decide on that direction?<br></p><p>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; Am 27.05.2016 um 14:34 schrieb Vladimir.S &lt;svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; Btw, in case we have `where` keyword in syntax related to types/protocols (when defining constrains. and not some symbol like &#39;&gt;&gt;&#39;.. don&#39;t know, for example), why we can&#39;t have &#39;and&#39; keyword also when discuss the syntax of type/protocol conjunction?<br>&gt;&gt; I.e.<br>&gt;&gt; <br>&gt;&gt; let x: P and Q<br>&gt;&gt; let x: P and Q where P.T == Q.T<br>&gt;&gt; let x: P and Q and R<br>&gt;&gt; <br>&gt;&gt; or, for consistency, as I understand it, we should have<br>&gt;&gt; let x: P &amp; Q &gt;&gt; P.T == Q.T<br>&gt;&gt; <br>&gt;&gt; On 27.05.2016 11:55, Thorsten Seitz via swift-evolution wrote:<br>&gt;&gt;&gt; We could just write<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x: P &amp; Q<br>&gt;&gt;&gt; instead of<br>&gt;&gt;&gt; let x: Any&lt;P, Q&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x: Collection where .Element: P<br>&gt;&gt;&gt; instead of<br>&gt;&gt;&gt; let x: Any&lt;Collection where .Element: P&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x: P &amp; Q where P.T == Q.T<br>&gt;&gt;&gt; instead of<br>&gt;&gt;&gt; let x: Any&lt;P, Q where P.T == Q.T&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x: P &amp; Q &amp; R<br>&gt;&gt;&gt; instead of<br>&gt;&gt;&gt; let x: Any&lt;P, Q, R&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x: Collection<br>&gt;&gt;&gt; instead of<br>&gt;&gt;&gt; let x: Any&lt;Collection&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would avoid the confusion of Any&lt;T1, T2&gt; being something completely<br>&gt;&gt;&gt; different than a generic type (i.e. order of T1, T2 does not matter whereas<br>&gt;&gt;&gt; for generic types it is essential).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 26.05.2016 um 20:11 schrieb Adrian Zubarev via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Something like |type&lt;…&gt;| was considered at the very start of the whole<br>&gt;&gt;&gt;&gt; discussion (in this thread<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html&gt;&gt;),<br>&gt;&gt;&gt;&gt; but it does not solve the meaning of an existential type and also might<br>&gt;&gt;&gt;&gt; lead to even more confusion.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; From my perspective I wouldn’t use parentheses here because it looks more<br>&gt;&gt;&gt;&gt; like an init without any label |Type.init(…)| or |Type(…)|. I could live<br>&gt;&gt;&gt;&gt; with |Any[…]| but this doesn’t look shiny and Swifty to me. Thats only my<br>&gt;&gt;&gt;&gt; personal view. ;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 26. Mai 2016 bei 19:48:04, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt; (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;) schrieb:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Don&#39;t think {} is better here, as they also have &quot;established meaning in<br>&gt;&gt;&gt;&gt;&gt; Swift today&quot;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; How about just Type(P1 &amp; P2 | P3) - as IMO we can think of such<br>&gt;&gt;&gt;&gt;&gt; construction as &quot;creation&quot; of new type and `P1 &amp; P2 | P3` could be treated<br>&gt;&gt;&gt;&gt;&gt; as parameters to initializer.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func f(t: Type(P1 &amp; P2 | P3)) {..}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 26.05.2016 20:32, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt; How about something like Type{P1 &amp; P2 | P3} the point being that &quot;&lt;...&gt;&quot; has an established meaning in Swift today which is not what is expressed in the &quot;&lt;P1,P2,P3&gt;&quot; contained inside Any&lt;P1, P2,P3&gt;.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; confusion?<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; force into the official lexicon of Swift. I think “Any&lt;...&gt;” is much<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; more conceptually accessible.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; want to use any class requirement existential directly? If second, we<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; will need to allow direct existential usage on protocols (right now we<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; only can use typealiases as a worksround).<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/e6e58b54/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 27, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 27.05.2016 um 16:54 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 27, 2016, at 8:18 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Personally I think `&amp;` is more lightweight (and it is established in other languages like Ceylon and Typescript) and `where` is more expressive (and established in Swift for introducing constraints), so I would stay with these.<br>&gt; <br>&gt; I agree.  If we can make `&amp;` with `where` work syntactically it would be nice to go in this lighter weight direction.  If we decide to do that the question then becomes what to do with `protocol`.  Would it be feasible to replace it with `&amp;` in Swift 3 if we decide on that direction?<br></p><p>Yep. `protocol` should be replaced with `&amp;` in that case.<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 27.05.2016 um 14:34 schrieb Vladimir.S &lt;svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Btw, in case we have `where` keyword in syntax related to types/protocols (when defining constrains. and not some symbol like &#39;&gt;&gt;&#39;.. don&#39;t know, for example), why we can&#39;t have &#39;and&#39; keyword also when discuss the syntax of type/protocol conjunction?<br>&gt;&gt;&gt; I.e.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x: P and Q<br>&gt;&gt;&gt; let x: P and Q where P.T == Q.T<br>&gt;&gt;&gt; let x: P and Q and R<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or, for consistency, as I understand it, we should have<br>&gt;&gt;&gt; let x: P &amp; Q &gt;&gt; P.T == Q.T<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 27.05.2016 11:55, Thorsten Seitz via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; We could just write<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let x: P &amp; Q<br>&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt; let x: Any&lt;P, Q&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let x: Collection where .Element: P<br>&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt; let x: Any&lt;Collection where .Element: P&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let x: P &amp; Q where P.T == Q.T<br>&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt; let x: Any&lt;P, Q where P.T == Q.T&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let x: P &amp; Q &amp; R<br>&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt; let x: Any&lt;P, Q, R&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let x: Collection<br>&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt; let x: Any&lt;Collection&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This would avoid the confusion of Any&lt;T1, T2&gt; being something completely<br>&gt;&gt;&gt;&gt; different than a generic type (i.e. order of T1, T2 does not matter whereas<br>&gt;&gt;&gt;&gt; for generic types it is essential).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 26.05.2016 um 20:11 schrieb Adrian Zubarev via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Something like |type&lt;…&gt;| was considered at the very start of the whole<br>&gt;&gt;&gt;&gt;&gt; discussion (in this thread<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html&gt;&gt;),<br>&gt;&gt;&gt;&gt;&gt; but it does not solve the meaning of an existential type and also might<br>&gt;&gt;&gt;&gt;&gt; lead to even more confusion.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; From my perspective I wouldn’t use parentheses here because it looks more<br>&gt;&gt;&gt;&gt;&gt; like an init without any label |Type.init(…)| or |Type(…)|. I could live<br>&gt;&gt;&gt;&gt;&gt; with |Any[…]| but this doesn’t look shiny and Swifty to me. Thats only my<br>&gt;&gt;&gt;&gt;&gt; personal view. ;)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 26. Mai 2016 bei 19:48:04, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;) schrieb:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Don&#39;t think {} is better here, as they also have &quot;established meaning in<br>&gt;&gt;&gt;&gt;&gt;&gt; Swift today&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; How about just Type(P1 &amp; P2 | P3) - as IMO we can think of such<br>&gt;&gt;&gt;&gt;&gt;&gt; construction as &quot;creation&quot; of new type and `P1 &amp; P2 | P3` could be treated<br>&gt;&gt;&gt;&gt;&gt;&gt; as parameters to initializer.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func f(t: Type(P1 &amp; P2 | P3)) {..}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 26.05.2016 20:32, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; How about something like Type{P1 &amp; P2 | P3} the point being that &quot;&lt;...&gt;&quot; has an established meaning in Swift today which is not what is expressed in the &quot;&lt;P1,P2,P3&gt;&quot; contained inside Any&lt;P1, P2,P3&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; confusion?<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; force into the official lexicon of Swift. I think “Any&lt;...&gt;” is much<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; more conceptually accessible.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; want to use any class requirement existential directly? If second, we<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; will need to allow direct existential usage on protocols (right now we<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; only can use typealiases as a worksround).<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/0d996d2e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 11:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 27, 2016, at 11:07 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; Am 27.05.2016 um 16:54 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 27, 2016, at 8:18 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally I think `&amp;` is more lightweight (and it is established in other languages like Ceylon and Typescript) and `where` is more expressive (and established in Swift for introducing constraints), so I would stay with these.<br>&gt;&gt; <br>&gt;&gt; I agree.  If we can make `&amp;` with `where` work syntactically it would be nice to go in this lighter weight direction.  If we decide to do that the question then becomes what to do with `protocol`.  Would it be feasible to replace it with `&amp;` in Swift 3 if we decide on that direction?<br>&gt; <br>&gt; Yep. `protocol` should be replaced with `&amp;` in that case.<br></p><p>Right, but it&#39;s a much larger syntax change.  If we decide on that direction and it&#39;s not feasible for Swift 3 I suppose we would just leave &#39;protocol&#39; alone until Swift 3.x or 4.<br></p><p>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 27.05.2016 um 14:34 schrieb Vladimir.S &lt;svabox at gmail.com&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Btw, in case we have `where` keyword in syntax related to types/protocols (when defining constrains. and not some symbol like &#39;&gt;&gt;&#39;.. don&#39;t know, for example), why we can&#39;t have &#39;and&#39; keyword also when discuss the syntax of type/protocol conjunction?<br>&gt;&gt;&gt;&gt; I.e.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let x: P and Q<br>&gt;&gt;&gt;&gt; let x: P and Q where P.T == Q.T<br>&gt;&gt;&gt;&gt; let x: P and Q and R<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; or, for consistency, as I understand it, we should have<br>&gt;&gt;&gt;&gt; let x: P &amp; Q &gt;&gt; P.T == Q.T<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 27.05.2016 11:55, Thorsten Seitz via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt; We could just write<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q<br>&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let x: Collection where .Element: P<br>&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt; let x: Any&lt;Collection where .Element: P&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q where P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q where P.T == Q.T&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q &amp; R<br>&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q, R&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let x: Collection<br>&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt; let x: Any&lt;Collection&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This would avoid the confusion of Any&lt;T1, T2&gt; being something completely<br>&gt;&gt;&gt;&gt;&gt; different than a generic type (i.e. order of T1, T2 does not matter whereas<br>&gt;&gt;&gt;&gt;&gt; for generic types it is essential).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 26.05.2016 um 20:11 schrieb Adrian Zubarev via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Something like |type&lt;…&gt;| was considered at the very start of the whole<br>&gt;&gt;&gt;&gt;&gt;&gt; discussion (in this thread<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html&gt;),<br>&gt;&gt;&gt;&gt;&gt;&gt; but it does not solve the meaning of an existential type and also might<br>&gt;&gt;&gt;&gt;&gt;&gt; lead to even more confusion.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; From my perspective I wouldn’t use parentheses here because it looks more<br>&gt;&gt;&gt;&gt;&gt;&gt; like an init without any label |Type.init(…)| or |Type(…)|. I could live<br>&gt;&gt;&gt;&gt;&gt;&gt; with |Any[…]| but this doesn’t look shiny and Swifty to me. Thats only my<br>&gt;&gt;&gt;&gt;&gt;&gt; personal view. ;)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 26. Mai 2016 bei 19:48:04, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Don&#39;t think {} is better here, as they also have &quot;established meaning in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift today&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; How about just Type(P1 &amp; P2 | P3) - as IMO we can think of such<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; construction as &quot;creation&quot; of new type and `P1 &amp; P2 | P3` could be treated<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; as parameters to initializer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func f(t: Type(P1 &amp; P2 | P3)) {..}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 26.05.2016 20:32, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; How about something like Type{P1 &amp; P2 | P3} the point being that &quot;&lt;...&gt;&quot; has an established meaning in Swift today which is not what is expressed in the &quot;&lt;P1,P2,P3&gt;&quot; contained inside Any&lt;P1, P2,P3&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; confusion?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; force into the official lexicon of Swift. I think “Any&lt;...&gt;” is much<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; more conceptually accessible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; want to use any class requirement existential directly? If second, we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; will need to allow direct existential usage on protocols (right now we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; only can use typealiases as a worksround).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/bc585043/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 27, 2016 at 09:00:00am</p></header><div class="content"><p>Here&#39;s a strawman idea.<br></p><p>What if we go with &#39;&amp;&#39; and &#39;where&#39;, but we enclose the whole thing in parentheses?<br></p><p>(class &amp; Protocol1 &amp; Protocol2 where .Foo == Int, .Bar : Baz)<br></p><p>There are a couple of reasons I propose this syntax:<br></p><p>- It makes it very clear where the definition of the type begins and ends. I understand people really despise angle brackets, but I really want some way to visually delineate the boundaries of the type. Plus, I imagine it makes syntax a little easier to parse and preemptively forbids some ambiguities.<br></p><p>- It&#39;s a structural, not nominal, type, like a tuple, so it uses parens as well. This reserves &quot;&lt;&quot; and &quot;&gt;&quot; for generic types.<br></p><p>- The &#39;&amp;&#39; is easily understood - &quot;Protocol1&quot; *and* &quot;Protocol2&quot;. It&#39;s also a signal that order doesn&#39;t matter - just like how order matters with things that use commas, like argument lists, tuples, and array members, order doesn&#39;t generally matter with bitwise or logical &#39;and&#39; operators.<br></p><p>- If we ever decide to have union types, we have a very elegant third form of nominal type syntax that naturally falls out: (MyClass1 | MyClass2 | MyClass3).<br></p><p>Thoughts?<br></p><p>Austin<br></p><p><br>&gt; On May 27, 2016, at 9:07 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 27.05.2016 um 16:54 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 27, 2016, at 8:18 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally I think `&amp;` is more lightweight (and it is established in other languages like Ceylon and Typescript) and `where` is more expressive (and established in Swift for introducing constraints), so I would stay with these.<br>&gt;&gt; <br>&gt;&gt; I agree.  If we can make `&amp;` with `where` work syntactically it would be nice to go in this lighter weight direction.  If we decide to do that the question then becomes what to do with `protocol`.  Would it be feasible to replace it with `&amp;` in Swift 3 if we decide on that direction?<br>&gt; <br>&gt; Yep. `protocol` should be replaced with `&amp;` in that case.<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 27.05.2016 um 14:34 schrieb Vladimir.S &lt;svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Btw, in case we have `where` keyword in syntax related to types/protocols (when defining constrains. and not some symbol like &#39;&gt;&gt;&#39;.. don&#39;t know, for example), why we can&#39;t have &#39;and&#39; keyword also when discuss the syntax of type/protocol conjunction?<br>&gt;&gt;&gt;&gt; I.e.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let x: P and Q<br>&gt;&gt;&gt;&gt; let x: P and Q where P.T == Q.T<br>&gt;&gt;&gt;&gt; let x: P and Q and R<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; or, for consistency, as I understand it, we should have<br>&gt;&gt;&gt;&gt; let x: P &amp; Q &gt;&gt; P.T == Q.T<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 27.05.2016 11:55, Thorsten Seitz via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt; We could just write<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q<br>&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let x: Collection where .Element: P<br>&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt; let x: Any&lt;Collection where .Element: P&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q where P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q where P.T == Q.T&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q &amp; R<br>&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q, R&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let x: Collection<br>&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt; let x: Any&lt;Collection&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This would avoid the confusion of Any&lt;T1, T2&gt; being something completely<br>&gt;&gt;&gt;&gt;&gt; different than a generic type (i.e. order of T1, T2 does not matter whereas<br>&gt;&gt;&gt;&gt;&gt; for generic types it is essential).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 26.05.2016 um 20:11 schrieb Adrian Zubarev via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Something like |type&lt;…&gt;| was considered at the very start of the whole<br>&gt;&gt;&gt;&gt;&gt;&gt; discussion (in this thread<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html&gt;&gt;),<br>&gt;&gt;&gt;&gt;&gt;&gt; but it does not solve the meaning of an existential type and also might<br>&gt;&gt;&gt;&gt;&gt;&gt; lead to even more confusion.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; From my perspective I wouldn’t use parentheses here because it looks more<br>&gt;&gt;&gt;&gt;&gt;&gt; like an init without any label |Type.init(…)| or |Type(…)|. I could live<br>&gt;&gt;&gt;&gt;&gt;&gt; with |Any[…]| but this doesn’t look shiny and Swifty to me. Thats only my<br>&gt;&gt;&gt;&gt;&gt;&gt; personal view. ;)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 26. Mai 2016 bei 19:48:04, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;) schrieb:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Don&#39;t think {} is better here, as they also have &quot;established meaning in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift today&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; How about just Type(P1 &amp; P2 | P3) - as IMO we can think of such<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; construction as &quot;creation&quot; of new type and `P1 &amp; P2 | P3` could be treated<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; as parameters to initializer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func f(t: Type(P1 &amp; P2 | P3)) {..}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 26.05.2016 20:32, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; How about something like Type{P1 &amp; P2 | P3} the point being that &quot;&lt;...&gt;&quot; has an established meaning in Swift today which is not what is expressed in the &quot;&lt;P1,P2,P3&gt;&quot; contained inside Any&lt;P1, P2,P3&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; confusion?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; force into the official lexicon of Swift. I think “Any&lt;...&gt;” is much<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; more conceptually accessible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; want to use any class requirement existential directly? If second, we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; will need to allow direct existential usage on protocols (right now we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; only can use typealiases as a worksround).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/b8f959f2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 11:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 27, 2016, at 11:18 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Here&#39;s a strawman idea.<br>&gt; <br>&gt; What if we go with &#39;&amp;&#39; and &#39;where&#39;, but we enclose the whole thing in parentheses?<br>&gt; <br>&gt; (class &amp; Protocol1 &amp; Protocol2 where .Foo == Int, .Bar : Baz)<br>&gt; <br>&gt; There are a couple of reasons I propose this syntax:<br>&gt; <br>&gt; - It makes it very clear where the definition of the type begins and ends. I understand people really despise angle brackets, but I really want some way to visually delineate the boundaries of the type. Plus, I imagine it makes syntax a little easier to parse and preemptively forbids some ambiguities.<br>&gt; <br>&gt; - It&#39;s a structural, not nominal, type, like a tuple, so it uses parens as well. This reserves &quot;&lt;&quot; and &quot;&gt;&quot; for generic types.<br>&gt; <br>&gt; - The &#39;&amp;&#39; is easily understood - &quot;Protocol1&quot; *and* &quot;Protocol2&quot;. It&#39;s also a signal that order doesn&#39;t matter - just like how order matters with things that use commas, like argument lists, tuples, and array members, order doesn&#39;t generally matter with bitwise or logical &#39;and&#39; operators.<br>&gt; <br>&gt; - If we ever decide to have union types, we have a very elegant third form of nominal type syntax that naturally falls out: (MyClass1 | MyClass2 | MyClass3).<br>&gt; <br>&gt; Thoughts?<br></p><p>Generally in favor.  But I would not require the parentheses.  I believe they would be allowed optionally automatically, just as (Int) is the same as Int (because single element tuples don&#39;t exist and the underlying type is used directly instead).  It seems better to leave parentheses up to a matter of style.<br></p><p><br>&gt; <br>&gt; Austin<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On May 27, 2016, at 9:07 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 27.05.2016 um 16:54 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 27, 2016, at 8:18 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Personally I think `&amp;` is more lightweight (and it is established in other languages like Ceylon and Typescript) and `where` is more expressive (and established in Swift for introducing constraints), so I would stay with these.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree.  If we can make `&amp;` with `where` work syntactically it would be nice to go in this lighter weight direction.  If we decide to do that the question then becomes what to do with `protocol`.  Would it be feasible to replace it with `&amp;` in Swift 3 if we decide on that direction?<br>&gt;&gt; <br>&gt;&gt; Yep. `protocol` should be replaced with `&amp;` in that case.<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 27.05.2016 um 14:34 schrieb Vladimir.S &lt;svabox at gmail.com&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Btw, in case we have `where` keyword in syntax related to types/protocols (when defining constrains. and not some symbol like &#39;&gt;&gt;&#39;.. don&#39;t know, for example), why we can&#39;t have &#39;and&#39; keyword also when discuss the syntax of type/protocol conjunction?<br>&gt;&gt;&gt;&gt;&gt; I.e.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let x: P and Q<br>&gt;&gt;&gt;&gt;&gt; let x: P and Q where P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt; let x: P and Q and R<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; or, for consistency, as I understand it, we should have<br>&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q &gt;&gt; P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 27.05.2016 11:55, Thorsten Seitz via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; We could just write<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q<br>&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let x: Collection where .Element: P<br>&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;Collection where .Element: P&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q where P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q where P.T == Q.T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q &amp; R<br>&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q, R&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let x: Collection<br>&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;Collection&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This would avoid the confusion of Any&lt;T1, T2&gt; being something completely<br>&gt;&gt;&gt;&gt;&gt;&gt; different than a generic type (i.e. order of T1, T2 does not matter whereas<br>&gt;&gt;&gt;&gt;&gt;&gt; for generic types it is essential).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 26.05.2016 um 20:11 schrieb Adrian Zubarev via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Something like |type&lt;…&gt;| was considered at the very start of the whole<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; discussion (in this thread<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html&gt;),<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; but it does not solve the meaning of an existential type and also might<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; lead to even more confusion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; From my perspective I wouldn’t use parentheses here because it looks more<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; like an init without any label |Type.init(…)| or |Type(…)|. I could live<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; with |Any[…]| but this doesn’t look shiny and Swifty to me. Thats only my<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; personal view. ;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 26. Mai 2016 bei 19:48:04, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Don&#39;t think {} is better here, as they also have &quot;established meaning in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift today&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; How about just Type(P1 &amp; P2 | P3) - as IMO we can think of such<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; construction as &quot;creation&quot; of new type and `P1 &amp; P2 | P3` could be treated<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; as parameters to initializer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func f(t: Type(P1 &amp; P2 | P3)) {..}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 26.05.2016 20:32, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; How about something like Type{P1 &amp; P2 | P3} the point being that &quot;&lt;...&gt;&quot; has an established meaning in Swift today which is not what is expressed in the &quot;&lt;P1,P2,P3&gt;&quot; contained inside Any&lt;P1, P2,P3&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; confusion?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; force into the official lexicon of Swift. I think “Any&lt;...&gt;” is much<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; more conceptually accessible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; want to use any class requirement existential directly? If second, we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; will need to allow direct existential usage on protocols (right now we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; only can use typealiases as a worksround).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/47c34822/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 27, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 27.05.2016 um 18:28 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 27, 2016, at 11:18 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Here&#39;s a strawman idea.<br>&gt;&gt; <br>&gt;&gt; What if we go with &#39;&amp;&#39; and &#39;where&#39;, but we enclose the whole thing in parentheses?<br>&gt;&gt; <br>&gt;&gt; (class &amp; Protocol1 &amp; Protocol2 where .Foo == Int, .Bar : Baz)<br>&gt;&gt; <br>&gt;&gt; There are a couple of reasons I propose this syntax:<br>&gt;&gt; <br>&gt;&gt; - It makes it very clear where the definition of the type begins and ends. I understand people really despise angle brackets, but I really want some way to visually delineate the boundaries of the type. Plus, I imagine it makes syntax a little easier to parse and preemptively forbids some ambiguities.<br>&gt;&gt; <br>&gt;&gt; - It&#39;s a structural, not nominal, type, like a tuple, so it uses parens as well. This reserves &quot;&lt;&quot; and &quot;&gt;&quot; for generic types.<br>&gt;&gt; <br>&gt;&gt; - The &#39;&amp;&#39; is easily understood - &quot;Protocol1&quot; *and* &quot;Protocol2&quot;. It&#39;s also a signal that order doesn&#39;t matter - just like how order matters with things that use commas, like argument lists, tuples, and array members, order doesn&#39;t generally matter with bitwise or logical &#39;and&#39; operators.<br>&gt;&gt; <br>&gt;&gt; - If we ever decide to have union types, we have a very elegant third form of nominal type syntax that naturally falls out: (MyClass1 | MyClass2 | MyClass3).<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt; <br>&gt; Generally in favor.  But I would not require the parentheses.  I believe they would be allowed optionally automatically, just as (Int) is the same as Int (because single element tuples don&#39;t exist and the underlying type is used directly instead).  It seems better to leave parentheses up to a matter of style.<br></p><p>Totally agree. Parentheses should only be required to resolve ambiguities.<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 27, 2016, at 9:07 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 27.05.2016 um 16:54 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 27, 2016, at 8:18 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Personally I think `&amp;` is more lightweight (and it is established in other languages like Ceylon and Typescript) and `where` is more expressive (and established in Swift for introducing constraints), so I would stay with these.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree.  If we can make `&amp;` with `where` work syntactically it would be nice to go in this lighter weight direction.  If we decide to do that the question then becomes what to do with `protocol`.  Would it be feasible to replace it with `&amp;` in Swift 3 if we decide on that direction?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yep. `protocol` should be replaced with `&amp;` in that case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 27.05.2016 um 14:34 schrieb Vladimir.S &lt;svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Btw, in case we have `where` keyword in syntax related to types/protocols (when defining constrains. and not some symbol like &#39;&gt;&gt;&#39;.. don&#39;t know, for example), why we can&#39;t have &#39;and&#39; keyword also when discuss the syntax of type/protocol conjunction?<br>&gt;&gt;&gt;&gt;&gt;&gt; I.e.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q<br>&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q where P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q and R<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; or, for consistency, as I understand it, we should have<br>&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q &gt;&gt; P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 27.05.2016 11:55, Thorsten Seitz via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; We could just write<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Collection where .Element: P<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;Collection where .Element: P&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q where P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q where P.T == Q.T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q &amp; R<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q, R&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;Collection&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This would avoid the confusion of Any&lt;T1, T2&gt; being something completely<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; different than a generic type (i.e. order of T1, T2 does not matter whereas<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for generic types it is essential).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 26.05.2016 um 20:11 schrieb Adrian Zubarev via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Something like |type&lt;…&gt;| was considered at the very start of the whole<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; discussion (in this thread<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html&gt;&gt;),<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but it does not solve the meaning of an existential type and also might<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; lead to even more confusion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; From my perspective I wouldn’t use parentheses here because it looks more<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; like an init without any label |Type.init(…)| or |Type(…)|. I could live<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with |Any[…]| but this doesn’t look shiny and Swifty to me. Thats only my<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; personal view. ;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 26. Mai 2016 bei 19:48:04, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;) schrieb:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Don&#39;t think {} is better here, as they also have &quot;established meaning in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift today&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; How about just Type(P1 &amp; P2 | P3) - as IMO we can think of such<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; construction as &quot;creation&quot; of new type and `P1 &amp; P2 | P3` could be treated<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; as parameters to initializer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func f(t: Type(P1 &amp; P2 | P3)) {..}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 26.05.2016 20:32, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; How about something like Type{P1 &amp; P2 | P3} the point being that &quot;&lt;...&gt;&quot; has an established meaning in Swift today which is not what is expressed in the &quot;&lt;P1,P2,P3&gt;&quot; contained inside Any&lt;P1, P2,P3&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; confusion?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; force into the official lexicon of Swift. I think “Any&lt;...&gt;” is much<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; more conceptually accessible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; want to use any class requirement existential directly? If second, we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; will need to allow direct existential usage on protocols (right now we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; only can use typealiases as a worksround).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/a40d97df/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 27, 2016 at 09:00:00am</p></header><div class="content"><p>I think the parentheses are the fundamental aspect of the suggestion :).<br></p><p>Let me turn the question around. If tuples were declared like this:<br></p><p>let myTuple : Int, String, Bool = (10, &quot;hello&quot;, false)<br></p><p>would the type be more or less readable? I find it a lot more difficult to immediately parse than:<br></p><p>let myTuple : (Int, String, Bool) = (10, &quot;hello&quot;, false)<br></p><p>At the same time, nobody&#39;s complained about tuple type parentheses getting in the way. <br></p><p>We&#39;re trying to establish a syntax that will hopefully be used for things significantly more complicated than tuple definitions, which are just a list of types. I think readability is a major concern. Typealiases should be supported, but they shouldn&#39;t be required to make the feature useable.<br></p><p>Finally, wouldn&#39;t we need some delimiter for nested existential definitions anyways? Now you have the confusing situation where the outside definition has no delimiters, but the inside ones do:<br></p><p>// Why does the inner existential look fundamentally different than the outer one?<br>// Not to mention, visually parsing the boundaries of this type when you look at it in a function signature<br>let x : Protocol1, Protocol2, (Protocol 3 where .Foo == Int) where Protocol2.Bar : Baz<br></p><p>I hope that explains my reasoning.<br></p><p>Best,<br>Austin<br></p><p><br>&gt; On May 27, 2016, at 9:28 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 27, 2016, at 11:18 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Here&#39;s a strawman idea.<br>&gt;&gt; <br>&gt;&gt; What if we go with &#39;&amp;&#39; and &#39;where&#39;, but we enclose the whole thing in parentheses?<br>&gt;&gt; <br>&gt;&gt; (class &amp; Protocol1 &amp; Protocol2 where .Foo == Int, .Bar : Baz)<br>&gt;&gt; <br>&gt;&gt; There are a couple of reasons I propose this syntax:<br>&gt;&gt; <br>&gt;&gt; - It makes it very clear where the definition of the type begins and ends. I understand people really despise angle brackets, but I really want some way to visually delineate the boundaries of the type. Plus, I imagine it makes syntax a little easier to parse and preemptively forbids some ambiguities.<br>&gt;&gt; <br>&gt;&gt; - It&#39;s a structural, not nominal, type, like a tuple, so it uses parens as well. This reserves &quot;&lt;&quot; and &quot;&gt;&quot; for generic types.<br>&gt;&gt; <br>&gt;&gt; - The &#39;&amp;&#39; is easily understood - &quot;Protocol1&quot; *and* &quot;Protocol2&quot;. It&#39;s also a signal that order doesn&#39;t matter - just like how order matters with things that use commas, like argument lists, tuples, and array members, order doesn&#39;t generally matter with bitwise or logical &#39;and&#39; operators.<br>&gt;&gt; <br>&gt;&gt; - If we ever decide to have union types, we have a very elegant third form of nominal type syntax that naturally falls out: (MyClass1 | MyClass2 | MyClass3).<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt; <br>&gt; Generally in favor.  But I would not require the parentheses.  I believe they would be allowed optionally automatically, just as (Int) is the same as Int (because single element tuples don&#39;t exist and the underlying type is used directly instead).  It seems better to leave parentheses up to a matter of style.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 27, 2016, at 9:07 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 27.05.2016 um 16:54 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 27, 2016, at 8:18 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Personally I think `&amp;` is more lightweight (and it is established in other languages like Ceylon and Typescript) and `where` is more expressive (and established in Swift for introducing constraints), so I would stay with these.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree.  If we can make `&amp;` with `where` work syntactically it would be nice to go in this lighter weight direction.  If we decide to do that the question then becomes what to do with `protocol`.  Would it be feasible to replace it with `&amp;` in Swift 3 if we decide on that direction?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yep. `protocol` should be replaced with `&amp;` in that case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 27.05.2016 um 14:34 schrieb Vladimir.S &lt;svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Btw, in case we have `where` keyword in syntax related to types/protocols (when defining constrains. and not some symbol like &#39;&gt;&gt;&#39;.. don&#39;t know, for example), why we can&#39;t have &#39;and&#39; keyword also when discuss the syntax of type/protocol conjunction?<br>&gt;&gt;&gt;&gt;&gt;&gt; I.e.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q<br>&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q where P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q and R<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; or, for consistency, as I understand it, we should have<br>&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q &gt;&gt; P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 27.05.2016 11:55, Thorsten Seitz via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; We could just write<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Collection where .Element: P<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;Collection where .Element: P&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q where P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q where P.T == Q.T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q &amp; R<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q, R&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;Collection&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This would avoid the confusion of Any&lt;T1, T2&gt; being something completely<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; different than a generic type (i.e. order of T1, T2 does not matter whereas<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for generic types it is essential).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 26.05.2016 um 20:11 schrieb Adrian Zubarev via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Something like |type&lt;…&gt;| was considered at the very start of the whole<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; discussion (in this thread<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html&gt;&gt;),<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but it does not solve the meaning of an existential type and also might<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; lead to even more confusion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; From my perspective I wouldn’t use parentheses here because it looks more<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; like an init without any label |Type.init(…)| or |Type(…)|. I could live<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with |Any[…]| but this doesn’t look shiny and Swifty to me. Thats only my<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; personal view. ;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 26. Mai 2016 bei 19:48:04, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;) schrieb:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Don&#39;t think {} is better here, as they also have &quot;established meaning in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift today&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; How about just Type(P1 &amp; P2 | P3) - as IMO we can think of such<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; construction as &quot;creation&quot; of new type and `P1 &amp; P2 | P3` could be treated<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; as parameters to initializer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func f(t: Type(P1 &amp; P2 | P3)) {..}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 26.05.2016 20:32, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; How about something like Type{P1 &amp; P2 | P3} the point being that &quot;&lt;...&gt;&quot; has an established meaning in Swift today which is not what is expressed in the &quot;&lt;P1,P2,P3&gt;&quot; contained inside Any&lt;P1, P2,P3&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; confusion?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; force into the official lexicon of Swift. I think “Any&lt;...&gt;” is much<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; more conceptually accessible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; want to use any class requirement existential directly? If second, we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; will need to allow direct existential usage on protocols (right now we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; only can use typealiases as a worksround).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/95e78977/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 27, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Am 27.05.2016 um 18:36 schrieb Austin Zheng &lt;austinzheng at gmail.com&gt;:<br>&gt; <br>&gt; I think the parentheses are the fundamental aspect of the suggestion :).<br>&gt; <br>&gt; Let me turn the question around. If tuples were declared like this:<br>&gt; <br>&gt; let myTuple : Int, String, Bool = (10, &quot;hello&quot;, false)<br>&gt; <br>&gt; would the type be more or less readable? I find it a lot more difficult to immediately parse than:<br>&gt; <br>&gt; let myTuple : (Int, String, Bool) = (10, &quot;hello&quot;, false)<br>&gt; <br>&gt; At the same time, nobody&#39;s complained about tuple type parentheses getting in the way. <br></p><p>Parentheses are the hallmark of tuples, so its natural to expect them around the tuple type as well :-)<br></p><p><br>&gt; <br>&gt; We&#39;re trying to establish a syntax that will hopefully be used for things significantly more complicated than tuple definitions, which are just a list of types. I think readability is a major concern. Typealiases should be supported, but they shouldn&#39;t be required to make the feature useable.<br>&gt; <br>&gt; Finally, wouldn&#39;t we need some delimiter for nested existential definitions anyways? Now you have the confusing situation where the outside definition has no delimiters, but the inside ones do:<br></p><p>Why is this confusing? The expression `2 * (3 + 1)` also has parentheses only around the part which needs them. <br>Probably no one would require having to write `(2 * (3 + 1))` for consistency.<br></p><p> <br>&gt; <br>&gt; // Why does the inner existential look fundamentally different than the outer one?<br>&gt; // Not to mention, visually parsing the boundaries of this type when you look at it in a function signature<br>&gt; let x : Protocol1, Protocol2, (Protocol 3 where .Foo == Int) where Protocol2.Bar : Baz<br></p><p>Using `&amp;` instead of `,` will make it look better, too, IMHO:<br></p><p>let x: Protocol1 &amp; Protocol2 &amp; (Protocol3 where .Foo == Int) where Protocol2.Bar: Baz<br></p><p>or better (removing the asymmetry):<br></p><p>let x: Protocol1 &amp; (Protocol2 where .Bar : Baz) &amp; (Protocol3 where .Foo == Int)<br></p><p>or putting all constraints in the where clause for the whole expression:<br></p><p>let x: Protocol1 &amp; Protocol2 &amp; Protocol3 where Protocol2.Bar: Baz, Protocol3.Foo == Int<br></p><p><br>-Thorsten<br></p><p><br>&gt; <br>&gt; I hope that explains my reasoning.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; <br>&gt;&gt; On May 27, 2016, at 9:28 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On May 27, 2016, at 11:18 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Here&#39;s a strawman idea.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What if we go with &#39;&amp;&#39; and &#39;where&#39;, but we enclose the whole thing in parentheses?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (class &amp; Protocol1 &amp; Protocol2 where .Foo == Int, .Bar : Baz)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are a couple of reasons I propose this syntax:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - It makes it very clear where the definition of the type begins and ends. I understand people really despise angle brackets, but I really want some way to visually delineate the boundaries of the type. Plus, I imagine it makes syntax a little easier to parse and preemptively forbids some ambiguities.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - It&#39;s a structural, not nominal, type, like a tuple, so it uses parens as well. This reserves &quot;&lt;&quot; and &quot;&gt;&quot; for generic types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - The &#39;&amp;&#39; is easily understood - &quot;Protocol1&quot; *and* &quot;Protocol2&quot;. It&#39;s also a signal that order doesn&#39;t matter - just like how order matters with things that use commas, like argument lists, tuples, and array members, order doesn&#39;t generally matter with bitwise or logical &#39;and&#39; operators.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - If we ever decide to have union types, we have a very elegant third form of nominal type syntax that naturally falls out: (MyClass1 | MyClass2 | MyClass3).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; Generally in favor.  But I would not require the parentheses.  I believe they would be allowed optionally automatically, just as (Int) is the same as Int (because single element tuples don&#39;t exist and the underlying type is used directly instead).  It seems better to leave parentheses up to a matter of style.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 27, 2016, at 9:07 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 27.05.2016 um 16:54 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 27, 2016, at 8:18 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Personally I think `&amp;` is more lightweight (and it is established in other languages like Ceylon and Typescript) and `where` is more expressive (and established in Swift for introducing constraints), so I would stay with these.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree.  If we can make `&amp;` with `where` work syntactically it would be nice to go in this lighter weight direction.  If we decide to do that the question then becomes what to do with `protocol`.  Would it be feasible to replace it with `&amp;` in Swift 3 if we decide on that direction?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yep. `protocol` should be replaced with `&amp;` in that case.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 27.05.2016 um 14:34 schrieb Vladimir.S &lt;svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Btw, in case we have `where` keyword in syntax related to types/protocols (when defining constrains. and not some symbol like &#39;&gt;&gt;&#39;.. don&#39;t know, for example), why we can&#39;t have &#39;and&#39; keyword also when discuss the syntax of type/protocol conjunction?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I.e.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q where P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q and R<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; or, for consistency, as I understand it, we should have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q &gt;&gt; P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 27.05.2016 11:55, Thorsten Seitz via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We could just write<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Collection where .Element: P<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;Collection where .Element: P&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q where P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q where P.T == Q.T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q &amp; R<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q, R&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;Collection&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This would avoid the confusion of Any&lt;T1, T2&gt; being something completely<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; different than a generic type (i.e. order of T1, T2 does not matter whereas<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for generic types it is essential).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 26.05.2016 um 20:11 schrieb Adrian Zubarev via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Something like |type&lt;…&gt;| was considered at the very start of the whole<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; discussion (in this thread<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html&gt;&gt;),<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but it does not solve the meaning of an existential type and also might<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; lead to even more confusion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; From my perspective I wouldn’t use parentheses here because it looks more<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; like an init without any label |Type.init(…)| or |Type(…)|. I could live<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with |Any[…]| but this doesn’t look shiny and Swifty to me. Thats only my<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; personal view. ;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 26. Mai 2016 bei 19:48:04, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;) schrieb:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Don&#39;t think {} is better here, as they also have &quot;established meaning in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift today&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; How about just Type(P1 &amp; P2 | P3) - as IMO we can think of such<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; construction as &quot;creation&quot; of new type and `P1 &amp; P2 | P3` could be treated<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; as parameters to initializer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func f(t: Type(P1 &amp; P2 | P3)) {..}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 26.05.2016 20:32, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; How about something like Type{P1 &amp; P2 | P3} the point being that &quot;&lt;...&gt;&quot; has an established meaning in Swift today which is not what is expressed in the &quot;&lt;P1,P2,P3&gt;&quot; contained inside Any&lt;P1, P2,P3&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; confusion?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; force into the official lexicon of Swift. I think “Any&lt;...&gt;” is much<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; more conceptually accessible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; want to use any class requirement existential directly? If second, we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; will need to allow direct existential usage on protocols (right now we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; only can use typealiases as a worksround).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/7fae35fd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 27, 2016 at 11:00:00am</p></header><div class="content"><p>(inline)<br></p><p>On Fri, May 27, 2016 at 10:09 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; Am 27.05.2016 um 18:36 schrieb Austin Zheng &lt;austinzheng at gmail.com&gt;:<br>&gt;<br>&gt; I think the parentheses are the fundamental aspect of the suggestion :).<br>&gt;<br>&gt; Let me turn the question around. If tuples were declared like this:<br>&gt;<br>&gt; let myTuple : Int, String, Bool = (10, &quot;hello&quot;, false)<br>&gt;<br>&gt; would the type be more or less readable? I find it a lot more difficult to<br>&gt; immediately parse than:<br>&gt;<br>&gt; let myTuple : (Int, String, Bool) = (10, &quot;hello&quot;, false)<br>&gt;<br>&gt; At the same time, nobody&#39;s complained about tuple type parentheses getting<br>&gt; in the way.<br>&gt;<br>&gt;<br>&gt; Parentheses are the hallmark of tuples, so its natural to expect them<br>&gt; around the tuple type as well :-)<br>&gt;<br></p><p>But this is a circular definition. Why can&#39;t parentheses be the hallmark of<br>structural types, not just tuples? After all, one of the big complaints<br>against the Any&lt;&gt; and protocol&lt;&gt; syntaxes has been that angle brackets<br>belong to generics already.<br></p><p><br>&gt;<br>&gt;<br>&gt;<br>&gt; We&#39;re trying to establish a syntax that will hopefully be used for things<br>&gt; significantly more complicated than tuple definitions, which are just a<br>&gt; list of types. I think readability is a major concern. Typealiases should<br>&gt; be supported, but they shouldn&#39;t be required to make the feature useable.<br>&gt;<br>&gt; Finally, wouldn&#39;t we need some delimiter for nested existential<br>&gt; definitions anyways? Now you have the confusing situation where the outside<br>&gt; definition has no delimiters, but the inside ones do:<br>&gt;<br>&gt;<br>&gt; Why is this confusing? The expression `2 * (3 + 1)` also has parentheses<br>&gt; only around the part which needs them.<br>&gt; Probably no one would require having to write `(2 * (3 + 1))` for<br>&gt; consistency.<br>&gt;<br></p><p>You can make the same argument about tuples.<br></p><p><br>&gt;<br>&gt;<br>&gt;<br>&gt; // Why does the inner existential look fundamentally different than the<br>&gt; outer one?<br>&gt; // Not to mention, visually parsing the boundaries of this type when you<br>&gt; look at it in a function signature<br>&gt; let x : Protocol1, Protocol2, (Protocol 3 where .Foo == Int) where<br>&gt; Protocol2.Bar : Baz<br>&gt;<br>&gt;<br>&gt; Using `&amp;` instead of `,` will make it look better, too, IMHO:<br>&gt;<br>&gt; let x: Protocol1 &amp; Protocol2 &amp; (Protocol3 where .Foo == Int) where<br>&gt; Protocol2.Bar: Baz<br>&gt;<br></p><p>I agree that &#39;&amp;&#39; is better - my mistake. I still submit my concerns about<br>legibility.<br></p><p><br>&gt;<br>&gt; or better (removing the asymmetry):<br>&gt;<br>&gt; let x: Protocol1 &amp; (Protocol2 where .Bar : Baz) &amp; (Protocol3 where .Foo ==<br>&gt; Int)<br>&gt;<br>&gt; or putting all constraints in the where clause for the whole expression:<br>&gt;<br>&gt; let x: Protocol1 &amp; Protocol2 &amp; Protocol3 where Protocol2.Bar: Baz,<br>&gt; Protocol3.Foo == Int<br>&gt;<br></p><p>I would much rather have parentheses enclosing the outside type than force<br>people to structure their requirements a certain way.<br></p><p><br>&gt;<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt;<br>&gt; I hope that explains my reasoning.<br>&gt;<br>&gt; Best,<br>&gt; Austin<br>&gt;<br>&gt;<br>&gt; On May 27, 2016, at 9:28 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On May 27, 2016, at 11:18 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;<br>&gt; Here&#39;s a strawman idea.<br>&gt;<br>&gt; What if we go with &#39;&amp;&#39; and &#39;where&#39;, but we enclose the whole thing in<br>&gt; parentheses?<br>&gt;<br>&gt; (class &amp; Protocol1 &amp; Protocol2 where .Foo == Int, .Bar : Baz)<br>&gt;<br>&gt; There are a couple of reasons I propose this syntax:<br>&gt;<br>&gt; - It makes it very clear where the definition of the type begins and ends.<br>&gt; I understand people really despise angle brackets, but I really want some<br>&gt; way to visually delineate the boundaries of the type. Plus, I imagine it<br>&gt; makes syntax a little easier to parse and preemptively forbids some<br>&gt; ambiguities.<br>&gt;<br>&gt; - It&#39;s a structural, not nominal, type, like a tuple, so it uses parens as<br>&gt; well. This reserves &quot;&lt;&quot; and &quot;&gt;&quot; for generic types.<br>&gt;<br>&gt; - The &#39;&amp;&#39; is easily understood - &quot;Protocol1&quot; *and* &quot;Protocol2&quot;. It&#39;s also<br>&gt; a signal that order doesn&#39;t matter - just like how order matters with<br>&gt; things that use commas, like argument lists, tuples, and array members,<br>&gt; order doesn&#39;t generally matter with bitwise or logical &#39;and&#39; operators.<br>&gt;<br>&gt; - If we ever decide to have union types, we have a very elegant third form<br>&gt; of nominal type syntax that naturally falls out: (MyClass1 | MyClass2 |<br>&gt; MyClass3).<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt;<br>&gt; Generally in favor.  But I would not require the parentheses.  I believe<br>&gt; they would be allowed optionally automatically, just as (Int) is the same<br>&gt; as Int (because single element tuples don&#39;t exist and the underlying type<br>&gt; is used directly instead).  It seems better to leave parentheses up to a<br>&gt; matter of style.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt;<br>&gt; On May 27, 2016, at 9:07 AM, Thorsten Seitz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Am 27.05.2016 um 16:54 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt;<br>&gt;<br>&gt; On May 27, 2016, at 8:18 AM, Thorsten Seitz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Personally I think `&amp;` is more lightweight (and it is established in other<br>&gt; languages like Ceylon and Typescript) and `where` is more expressive (and<br>&gt; established in Swift for introducing constraints), so I would stay with<br>&gt; these.<br>&gt;<br>&gt;<br>&gt; I agree.  If we can make `&amp;` with `where` work syntactically it would be<br>&gt; nice to go in this lighter weight direction.  If we decide to do that the<br>&gt; question then becomes what to do with `protocol`.  Would it be feasible to<br>&gt; replace it with `&amp;` in Swift 3 if we decide on that direction?<br>&gt;<br>&gt;<br>&gt; Yep. `protocol` should be replaced with `&amp;` in that case.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt; Am 27.05.2016 um 14:34 schrieb Vladimir.S &lt;svabox at gmail.com&gt;:<br>&gt;<br>&gt; Btw, in case we have `where` keyword in syntax related to types/protocols<br>&gt; (when defining constrains. and not some symbol like &#39;&gt;&gt;&#39;.. don&#39;t know, for<br>&gt; example), why we can&#39;t have &#39;and&#39; keyword also when discuss the syntax of<br>&gt; type/protocol conjunction?<br>&gt; I.e.<br>&gt;<br>&gt; let x: P and Q<br>&gt; let x: P and Q where P.T == Q.T<br>&gt; let x: P and Q and R<br>&gt;<br>&gt; or, for consistency, as I understand it, we should have<br>&gt; let x: P &amp; Q &gt;&gt; P.T == Q.T<br>&gt;<br>&gt; On 27.05.2016 11:55, Thorsten Seitz via swift-evolution wrote:<br>&gt;<br>&gt; We could just write<br>&gt;<br>&gt; let x: P &amp; Q<br>&gt; instead of<br>&gt; let x: Any&lt;P, Q&gt;<br>&gt;<br>&gt; let x: Collection where .Element: P<br>&gt; instead of<br>&gt; let x: Any&lt;Collection where .Element: P&gt;<br>&gt;<br>&gt; let x: P &amp; Q where P.T == Q.T<br>&gt; instead of<br>&gt; let x: Any&lt;P, Q where P.T == Q.T&gt;<br>&gt;<br>&gt; let x: P &amp; Q &amp; R<br>&gt; instead of<br>&gt; let x: Any&lt;P, Q, R&gt;<br>&gt;<br>&gt; let x: Collection<br>&gt; instead of<br>&gt; let x: Any&lt;Collection&gt;<br>&gt;<br>&gt;<br>&gt; This would avoid the confusion of Any&lt;T1, T2&gt; being something completely<br>&gt; different than a generic type (i.e. order of T1, T2 does not matter whereas<br>&gt; for generic types it is essential).<br>&gt;<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt;<br>&gt; Am 26.05.2016 um 20:11 schrieb Adrian Zubarev via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt; &lt;swift-evolution at swift.org&gt;&gt;&gt;:<br>&gt;<br>&gt; Something like |type&lt;…&gt;| was considered at the very start of the whole<br>&gt; discussion (in this thread<br>&gt; &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html<br>&gt; &gt;),<br>&gt; but it does not solve the meaning of an existential type and also might<br>&gt; lead to even more confusion.<br>&gt;<br>&gt; From my perspective I wouldn’t use parentheses here because it looks more<br>&gt; like an init without any label |Type.init(…)| or |Type(…)|. I could live<br>&gt; with |Any[…]| but this doesn’t look shiny and Swifty to me. Thats only my<br>&gt; personal view. ;)<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 26. Mai 2016 bei 19:48:04, Vladimir.S via swift-evolution<br>&gt; (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt; &lt;swift-evolution at swift.org&gt;&gt;) schrieb:<br>&gt;<br>&gt; Don&#39;t think {} is better here, as they also have &quot;established meaning in<br>&gt; Swift today&quot;.<br>&gt;<br>&gt; How about just Type(P1 &amp; P2 | P3) - as IMO we can think of such<br>&gt; construction as &quot;creation&quot; of new type and `P1 &amp; P2 | P3` could be treated<br>&gt; as parameters to initializer.<br>&gt;<br>&gt; func f(t: Type(P1 &amp; P2 | P3)) {..}<br>&gt;<br>&gt;<br>&gt; On 26.05.2016 20:32, L. Mihalkovic via swift-evolution wrote:<br>&gt; &gt; How about something like Type{P1 &amp; P2 | P3} the point being that &quot;&lt;...&gt;&quot;<br>&gt; has an established meaning in Swift today which is not what is expressed in<br>&gt; the &quot;&lt;P1,P2,P3&gt;&quot; contained inside Any&lt;P1, P2,P3&gt;.<br>&gt; &gt;<br>&gt; &gt;&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt; &lt;swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org &lt;<br>&gt; mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; There is great feedback going on here. I&#39;d like to consider a few<br>&gt; things here:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt; &gt;&gt;&gt; confusion?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt; &gt;&gt; force into the official lexicon of Swift. I think “Any&lt;...&gt;” is much<br>&gt; &gt;&gt; more conceptually accessible.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt; &gt;&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt; &gt;&gt;&gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt; &gt;&gt;&gt; want to use any class requirement existential directly? If second, we<br>&gt; &gt;&gt;&gt; will need to allow direct existential usage on protocols (right now we<br>&gt; &gt;&gt;&gt; only can use typealiases as a worksround).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; Dave<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt; &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt; &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt; &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt; &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/7a420690/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 1:36 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; (inline)<br>&gt; <br>&gt; On Fri, May 27, 2016 at 10:09 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Am 27.05.2016 um 18:36 schrieb Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; I think the parentheses are the fundamental aspect of the suggestion :).<br>&gt;&gt; <br>&gt;&gt; Let me turn the question around. If tuples were declared like this:<br>&gt;&gt; <br>&gt;&gt; let myTuple : Int, String, Bool = (10, &quot;hello&quot;, false)<br>&gt;&gt; <br>&gt;&gt; would the type be more or less readable? I find it a lot more difficult to immediately parse than:<br>&gt;&gt; <br>&gt;&gt; let myTuple : (Int, String, Bool) = (10, &quot;hello&quot;, false)<br>&gt;&gt; <br>&gt;&gt; At the same time, nobody&#39;s complained about tuple type parentheses getting in the way. <br>&gt; <br>&gt; Parentheses are the hallmark of tuples, so its natural to expect them around the tuple type as well :-)<br>&gt; <br>&gt; But this is a circular definition. Why can&#39;t parentheses be the hallmark of structural types, not just tuples? After all, one of the big complaints against the Any&lt;&gt; and protocol&lt;&gt; syntaxes has been that angle brackets belong to generics already.<br></p><p>They are not a hallmark of function types.  We write `(Int) -&gt; (Int) -&gt; (Int) -&gt; Int`, not `((Int) -&gt; (Int) -&gt; (Int) -&gt; Int)`.<br></p><p>&gt;  <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; We&#39;re trying to establish a syntax that will hopefully be used for things significantly more complicated than tuple definitions, which are just a list of types. I think readability is a major concern. Typealiases should be supported, but they shouldn&#39;t be required to make the feature useable.<br>&gt;&gt; <br>&gt;&gt; Finally, wouldn&#39;t we need some delimiter for nested existential definitions anyways? Now you have the confusing situation where the outside definition has no delimiters, but the inside ones do:<br>&gt; <br>&gt; Why is this confusing? The expression `2 * (3 + 1)` also has parentheses only around the part which needs them. <br>&gt; Probably no one would require having to write `(2 * (3 + 1))` for consistency.<br>&gt; <br>&gt; You can make the same argument about tuples.<br>&gt;  <br>&gt;  <br>&gt;&gt; <br>&gt;&gt; // Why does the inner existential look fundamentally different than the outer one?<br>&gt;&gt; // Not to mention, visually parsing the boundaries of this type when you look at it in a function signature<br>&gt;&gt; let x : Protocol1, Protocol2, (Protocol 3 where .Foo == Int) where Protocol2.Bar : Baz<br>&gt; <br>&gt; Using `&amp;` instead of `,` will make it look better, too, IMHO:<br>&gt; <br>&gt; let x: Protocol1 &amp; Protocol2 &amp; (Protocol3 where .Foo == Int) where Protocol2.Bar: Baz<br>&gt; <br>&gt; I agree that &#39;&amp;&#39; is better - my mistake. I still submit my concerns about legibility.<br>&gt;  <br>&gt; <br>&gt; or better (removing the asymmetry):<br>&gt; <br>&gt; let x: Protocol1 &amp; (Protocol2 where .Bar : Baz) &amp; (Protocol3 where .Foo == Int)<br>&gt; <br>&gt; or putting all constraints in the where clause for the whole expression:<br>&gt; <br>&gt; let x: Protocol1 &amp; Protocol2 &amp; Protocol3 where Protocol2.Bar: Baz, Protocol3.Foo == Int<br>&gt; <br>&gt; I would much rather have parentheses enclosing the outside type than force people to structure their requirements a certain way.<br></p><p>That’s not a fair statement.  To be clear, nobody is asking to have anyone *forced* to do anything here except you.  We want parentheses to be *optional* (use them if you find them an aid to clarity and readability).  You’re arguing that the language *forces* all of us to use parentheses for *every* existential type *everywhere*.<br></p><p>I have no objection to you *preferring* the style of always using the outer parentheses.  The community might even come to the conclusion that this is the best practice.  But I don’t see a good reason to *require* them in the formal syntax of the language.<br></p><p>&gt;  <br>&gt; <br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; I hope that explains my reasoning.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 27, 2016, at 9:28 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 27, 2016, at 11:18 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here&#39;s a strawman idea.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What if we go with &#39;&amp;&#39; and &#39;where&#39;, but we enclose the whole thing in parentheses?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (class &amp; Protocol1 &amp; Protocol2 where .Foo == Int, .Bar : Baz)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are a couple of reasons I propose this syntax:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - It makes it very clear where the definition of the type begins and ends. I understand people really despise angle brackets, but I really want some way to visually delineate the boundaries of the type. Plus, I imagine it makes syntax a little easier to parse and preemptively forbids some ambiguities.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - It&#39;s a structural, not nominal, type, like a tuple, so it uses parens as well. This reserves &quot;&lt;&quot; and &quot;&gt;&quot; for generic types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - The &#39;&amp;&#39; is easily understood - &quot;Protocol1&quot; *and* &quot;Protocol2&quot;. It&#39;s also a signal that order doesn&#39;t matter - just like how order matters with things that use commas, like argument lists, tuples, and array members, order doesn&#39;t generally matter with bitwise or logical &#39;and&#39; operators.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - If we ever decide to have union types, we have a very elegant third form of nominal type syntax that naturally falls out: (MyClass1 | MyClass2 | MyClass3).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Generally in favor.  But I would not require the parentheses.  I believe they would be allowed optionally automatically, just as (Int) is the same as Int (because single element tuples don&#39;t exist and the underlying type is used directly instead).  It seems better to leave parentheses up to a matter of style.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 27, 2016, at 9:07 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 27.05.2016 um 16:54 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 27, 2016, at 8:18 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Personally I think `&amp;` is more lightweight (and it is established in other languages like Ceylon and Typescript) and `where` is more expressive (and established in Swift for introducing constraints), so I would stay with these.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I agree.  If we can make `&amp;` with `where` work syntactically it would be nice to go in this lighter weight direction.  If we decide to do that the question then becomes what to do with `protocol`.  Would it be feasible to replace it with `&amp;` in Swift 3 if we decide on that direction?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yep. `protocol` should be replaced with `&amp;` in that case.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 27.05.2016 um 14:34 schrieb Vladimir.S &lt;svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Btw, in case we have `where` keyword in syntax related to types/protocols (when defining constrains. and not some symbol like &#39;&gt;&gt;&#39;.. don&#39;t know, for example), why we can&#39;t have &#39;and&#39; keyword also when discuss the syntax of type/protocol conjunction?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I.e.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q where P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q and R<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or, for consistency, as I understand it, we should have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q &gt;&gt; P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 27.05.2016 11:55, Thorsten Seitz via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We could just write<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Collection where .Element: P<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;Collection where .Element: P&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q where P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q where P.T == Q.T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q &amp; R<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q, R&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;Collection&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This would avoid the confusion of Any&lt;T1, T2&gt; being something completely<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; different than a generic type (i.e. order of T1, T2 does not matter whereas<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for generic types it is essential).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 26.05.2016 um 20:11 schrieb Adrian Zubarev via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Something like |type&lt;…&gt;| was considered at the very start of the whole<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; discussion (in this thread<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html&gt;&gt;),<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but it does not solve the meaning of an existential type and also might<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; lead to even more confusion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; From my perspective I wouldn’t use parentheses here because it looks more<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; like an init without any label |Type.init(…)| or |Type(…)|. I could live<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with |Any[…]| but this doesn’t look shiny and Swifty to me. Thats only my<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; personal view. ;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 26. Mai 2016 bei 19:48:04, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;) schrieb:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Don&#39;t think {} is better here, as they also have &quot;established meaning in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift today&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; How about just Type(P1 &amp; P2 | P3) - as IMO we can think of such<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; construction as &quot;creation&quot; of new type and `P1 &amp; P2 | P3` could be treated<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; as parameters to initializer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func f(t: Type(P1 &amp; P2 | P3)) {..}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 26.05.2016 20:32, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; How about something like Type{P1 &amp; P2 | P3} the point being that &quot;&lt;...&gt;&quot; has an established meaning in Swift today which is not what is expressed in the &quot;&lt;P1,P2,P3&gt;&quot; contained inside Any&lt;P1, P2,P3&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; confusion?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; force into the official lexicon of Swift. I think “Any&lt;...&gt;” is much<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; more conceptually accessible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; want to use any class requirement existential directly? If second, we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; will need to allow direct existential usage on protocols (right now we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; only can use typealiases as a worksround).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/2da98ca7/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 27, 2016 at 08:00:00pm</p></header><div class="content"><p>For me requiring parentheses for this &#39;feature&#39; will confuse in most cases <br>as looks similar to tuple definition:<br></p><p>let x : (Int, String, Bool) = oneThing<br>let y : (MyProto &amp; Hashable) = anotherThing<br></p><p>but below looks IMO more clean and I instantly(don&#39;t need to parse first <br>open parenthesis) see that this is a &#39;conjunction&#39; of protocols not tuple :<br></p><p>let y : MyProto &amp; Hashable = anotherThing<br></p><p>Bur +1 for optional parentheses<br></p><p>On 27.05.2016 19:36, Austin Zheng via swift-evolution wrote:<br>&gt; I think the parentheses are the fundamental aspect of the suggestion :).<br>&gt;<br>&gt; Let me turn the question around. If tuples were declared like this:<br>&gt;<br>&gt; let myTuple : Int, String, Bool = (10, &quot;hello&quot;, false)<br>&gt;<br>&gt; would the type be more or less readable? I find it a lot more difficult to<br>&gt; immediately parse than:<br>&gt;<br>&gt; let myTuple : (Int, String, Bool) = (10, &quot;hello&quot;, false)<br>&gt;<br>&gt; At the same time, nobody&#39;s complained about tuple type parentheses getting<br>&gt; in the way.<br>&gt;<br>&gt; We&#39;re trying to establish a syntax that will hopefully be used for things<br>&gt; significantly more complicated than tuple definitions, which are just a<br>&gt; list of types. I think readability is a major concern. Typealiases should<br>&gt; be supported, but they shouldn&#39;t be required to make the feature useable.<br>&gt;<br>&gt; Finally, wouldn&#39;t we need some delimiter for nested existential definitions<br>&gt; anyways? Now you have the confusing situation where the outside definition<br>&gt; has no delimiters, but the inside ones do:<br>&gt;<br>&gt; // Why does the inner existential look fundamentally different than the<br>&gt; outer one?<br>&gt; // Not to mention, visually parsing the boundaries of this type when you<br>&gt; look at it in a function signature<br>&gt; let x : Protocol1, Protocol2, (Protocol 3 where .Foo == Int) where<br>&gt; Protocol2.Bar : Baz<br>&gt;<br>&gt; I hope that explains my reasoning.<br>&gt;<br>&gt; Best,<br>&gt; Austin<br>&gt;<br>&gt;<br>&gt;&gt; On May 27, 2016, at 9:28 AM, Matthew Johnson &lt;matthew at anandabits.com<br>&gt;&gt; &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On May 27, 2016, at 11:18 AM, Austin Zheng &lt;austinzheng at gmail.com<br>&gt;&gt; &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Here&#39;s a strawman idea.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What if we go with &#39;&amp;&#39; and &#39;where&#39;, but we enclose the whole thing in<br>&gt;&gt;&gt; parentheses?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (class &amp; Protocol1 &amp; Protocol2 where .Foo == Int, .Bar : Baz)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There are a couple of reasons I propose this syntax:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - It makes it very clear where the definition of the type begins and<br>&gt;&gt;&gt; ends. I understand people really despise angle brackets, but I really<br>&gt;&gt;&gt; want some way to visually delineate the boundaries of the type. Plus, I<br>&gt;&gt;&gt; imagine it makes syntax a little easier to parse and preemptively<br>&gt;&gt;&gt; forbids some ambiguities.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - It&#39;s a structural, not nominal, type, like a tuple, so it uses parens<br>&gt;&gt;&gt; as well. This reserves &quot;&lt;&quot; and &quot;&gt;&quot; for generic types.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - The &#39;&amp;&#39; is easily understood - &quot;Protocol1&quot; *and* &quot;Protocol2&quot;. It&#39;s<br>&gt;&gt;&gt; also a signal that order doesn&#39;t matter - just like how order matters<br>&gt;&gt;&gt; with things that use commas, like argument lists, tuples, and array<br>&gt;&gt;&gt; members, order doesn&#39;t generally matter with bitwise or logical &#39;and&#39;<br>&gt;&gt;&gt; operators.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - If we ever decide to have union types, we have a very elegant third<br>&gt;&gt;&gt; form of nominal type syntax that naturally falls out: (MyClass1 |<br>&gt;&gt;&gt; MyClass2 | MyClass3).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt;<br>&gt;&gt; Generally in favor.  But I would not require the parentheses.  I believe<br>&gt;&gt; they would be allowed optionally automatically, just as (Int) is the same<br>&gt;&gt; as Int (because single element tuples don&#39;t exist and the underlying type<br>&gt;&gt; is used directly instead).  It seems better to leave parentheses up to a<br>&gt;&gt; matter of style.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On May 27, 2016, at 9:07 AM, Thorsten Seitz via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Am 27.05.2016 um 16:54 schrieb Matthew Johnson &lt;matthew at anandabits.com<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On May 27, 2016, at 8:18 AM, Thorsten Seitz via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Personally I think `&amp;` is more lightweight (and it is established in<br>&gt;&gt;&gt;&gt;&gt;&gt; other languages like Ceylon and Typescript) and `where` is more<br>&gt;&gt;&gt;&gt;&gt;&gt; expressive (and established in Swift for introducing constraints), so<br>&gt;&gt;&gt;&gt;&gt;&gt; I would stay with these.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I agree.  If we can make `&amp;` with `where` work syntactically it would<br>&gt;&gt;&gt;&gt;&gt; be nice to go in this lighter weight direction.  If we decide to do<br>&gt;&gt;&gt;&gt;&gt; that the question then becomes what to do with `protocol`.  Would it<br>&gt;&gt;&gt;&gt;&gt; be feasible to replace it with `&amp;` in Swift 3 if we decide on that<br>&gt;&gt;&gt;&gt;&gt; direction?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Yep. `protocol` should be replaced with `&amp;` in that case.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 27.05.2016 um 14:34 schrieb Vladimir.S &lt;svabox at gmail.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:svabox at gmail.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Btw, in case we have `where` keyword in syntax related to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; types/protocols (when defining constrains. and not some symbol like<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &#39;&gt;&gt;&#39;.. don&#39;t know, for example), why we can&#39;t have &#39;and&#39; keyword<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; also when discuss the syntax of type/protocol conjunction?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I.e.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q where P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q and R<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; or, for consistency, as I understand it, we should have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q &gt;&gt; P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 27.05.2016 11:55, Thorsten Seitz via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We could just write<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Collection where .Element: P<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;Collection where .Element: P&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q where P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q where P.T == Q.T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q &amp; R<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q, R&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;Collection&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This would avoid the confusion of Any&lt;T1, T2&gt; being something<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; completely<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; different than a generic type (i.e. order of T1, T2 does not matter<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; whereas<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for generic types it is essential).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 26.05.2016 um 20:11 schrieb Adrian Zubarev via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Something like |type&lt;…&gt;| was considered at the very start of the whole<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; discussion (in this thread<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html&gt;),<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but it does not solve the meaning of an existential type and also<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; might<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; lead to even more confusion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; From my perspective I wouldn’t use parentheses here because it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; looks more<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; like an init without any label |Type.init(…)| or |Type(…)|. I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; could live<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with |Any[…]| but this doesn’t look shiny and Swifty to me. Thats<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; only my<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; personal view. ;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 26. Mai 2016 bei 19:48:04, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org&gt;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; schrieb:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Don&#39;t think {} is better here, as they also have &quot;established<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; meaning in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift today&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; How about just Type(P1 &amp; P2 | P3) - as IMO we can think of such<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; construction as &quot;creation&quot; of new type and `P1 &amp; P2 | P3` could<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be treated<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; as parameters to initializer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func f(t: Type(P1 &amp; P2 | P3)) {..}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 26.05.2016 20:32, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; How about something like Type{P1 &amp; P2 | P3} the point being<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that &quot;&lt;...&gt;&quot; has an established meaning in Swift today which is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not what is expressed in the &quot;&lt;P1,P2,P3&gt;&quot; contained inside<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any&lt;P1, P2,P3&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; There is great feedback going on here. I&#39;d like to consider a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; few things here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; confusion?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Some of us believe that “existential” is way too theoretical a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; word to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; force into the official lexicon of Swift. I think “Any&lt;...&gt;”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is much<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; more conceptually accessible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or do we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; want to use any class requirement existential directly? If<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; second, we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; will need to allow direct existential usage on protocols<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (right now we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; only can use typealiases as a worksround).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 11:36 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; I think the parentheses are the fundamental aspect of the suggestion :).<br></p><p>Yes I know.  I guess we disagree on this point.  It seems like a matter of style to me, not something to require.<br></p><p>&gt; <br>&gt; Let me turn the question around. If tuples were declared like this:<br>&gt; <br>&gt; let myTuple : Int, String, Bool = (10, &quot;hello&quot;, false)<br>&gt; <br>&gt; would the type be more or less readable? I find it a lot more difficult to immediately parse than:<br>&gt; <br>&gt; let myTuple : (Int, String, Bool) = (10, &quot;hello&quot;, false)<br>&gt; <br>&gt; At the same time, nobody&#39;s complained about tuple type parentheses getting in the way. <br></p><p>I do think these questions are important to consider but remain unconvinced thus far.<br></p><p>In the case of tuples the type syntax matches the usage syntax which is important.  That doesn’t apply for existentials. <br></p><p>Turning it around, we don’t have to put parentheses around function types and nobody complains about it being problematic even for higher-order functions with several steps before the final result.<br></p><p>Does anyone know if users of Ceylon or other languages with the unparenthesized syntax find it problematic?  How would they feel about being required to use parentheses?<br></p><p>&gt; <br>&gt; We&#39;re trying to establish a syntax that will hopefully be used for things significantly more complicated than tuple definitions, which are just a list of types. I think readability is a major concern. Typealiases should be supported, but they shouldn&#39;t be required to make the feature useable.<br></p><p>I agree, but I don’t think they would be required to make the feature useable just because parentheses are not required.  If a developer or team thinks they are required for clarity / readability, etc they are free to use them.  This is a style issue that should be addressed by a linter, not the formal syntax of the language.<br></p><p>&gt; <br>&gt; Finally, wouldn&#39;t we need some delimiter for nested existential definitions anyways? Now you have the confusing situation where the outside definition has no delimiters, but the inside ones do:<br>&gt; <br>&gt; // Why does the inner existential look fundamentally different than the outer one?<br>&gt; // Not to mention, visually parsing the boundaries of this type when you look at it in a function signature<br>&gt; let x : Protocol1, Protocol2, (Protocol 3 where .Foo == Int) where Protocol2.Bar : Baz<br></p><p>Nested existentials are supported not because it would ever be a good idea to actually write them.  They are supported to allow composition of existentials:<br></p><p>typealias P3Int = Protocol 3 where .Foo == Int<br>let x : Protocol1, Protocol2, P3Int where Protocol2.Bar : Baz<br></p><p>If you are writing the entire type in a single location I expect the conventional style to be like this:<br></p><p>let x : Protocol1, Protocol2, Protocol 3 where Protocol2.Bar : Baz, Protocol3.Foo == Int<br></p><p>With all associated types constraints in a single `where` clause as we other places they are written in Swift.<br></p><p>Maybe I am wrong about that and a different conventional style would emerge (for example, where clauses clustered with the related protocol).  <br></p><p>But *requiring* parentheses is really orthogonal to the style issue of where and when it is considered *advisable* to use them.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; I hope that explains my reasoning.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; <br>&gt;&gt; On May 27, 2016, at 9:28 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On May 27, 2016, at 11:18 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Here&#39;s a strawman idea.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What if we go with &#39;&amp;&#39; and &#39;where&#39;, but we enclose the whole thing in parentheses?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (class &amp; Protocol1 &amp; Protocol2 where .Foo == Int, .Bar : Baz)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are a couple of reasons I propose this syntax:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - It makes it very clear where the definition of the type begins and ends. I understand people really despise angle brackets, but I really want some way to visually delineate the boundaries of the type. Plus, I imagine it makes syntax a little easier to parse and preemptively forbids some ambiguities.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - It&#39;s a structural, not nominal, type, like a tuple, so it uses parens as well. This reserves &quot;&lt;&quot; and &quot;&gt;&quot; for generic types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - The &#39;&amp;&#39; is easily understood - &quot;Protocol1&quot; *and* &quot;Protocol2&quot;. It&#39;s also a signal that order doesn&#39;t matter - just like how order matters with things that use commas, like argument lists, tuples, and array members, order doesn&#39;t generally matter with bitwise or logical &#39;and&#39; operators.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - If we ever decide to have union types, we have a very elegant third form of nominal type syntax that naturally falls out: (MyClass1 | MyClass2 | MyClass3).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; Generally in favor.  But I would not require the parentheses.  I believe they would be allowed optionally automatically, just as (Int) is the same as Int (because single element tuples don&#39;t exist and the underlying type is used directly instead).  It seems better to leave parentheses up to a matter of style.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 27, 2016, at 9:07 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 27.05.2016 um 16:54 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 27, 2016, at 8:18 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Personally I think `&amp;` is more lightweight (and it is established in other languages like Ceylon and Typescript) and `where` is more expressive (and established in Swift for introducing constraints), so I would stay with these.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree.  If we can make `&amp;` with `where` work syntactically it would be nice to go in this lighter weight direction.  If we decide to do that the question then becomes what to do with `protocol`.  Would it be feasible to replace it with `&amp;` in Swift 3 if we decide on that direction?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yep. `protocol` should be replaced with `&amp;` in that case.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 27.05.2016 um 14:34 schrieb Vladimir.S &lt;svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Btw, in case we have `where` keyword in syntax related to types/protocols (when defining constrains. and not some symbol like &#39;&gt;&gt;&#39;.. don&#39;t know, for example), why we can&#39;t have &#39;and&#39; keyword also when discuss the syntax of type/protocol conjunction?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I.e.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q where P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q and R<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; or, for consistency, as I understand it, we should have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q &gt;&gt; P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 27.05.2016 11:55, Thorsten Seitz via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We could just write<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Collection where .Element: P<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;Collection where .Element: P&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q where P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q where P.T == Q.T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q &amp; R<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q, R&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;Collection&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This would avoid the confusion of Any&lt;T1, T2&gt; being something completely<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; different than a generic type (i.e. order of T1, T2 does not matter whereas<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for generic types it is essential).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 26.05.2016 um 20:11 schrieb Adrian Zubarev via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Something like |type&lt;…&gt;| was considered at the very start of the whole<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; discussion (in this thread<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html&gt;&gt;),<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but it does not solve the meaning of an existential type and also might<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; lead to even more confusion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; From my perspective I wouldn’t use parentheses here because it looks more<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; like an init without any label |Type.init(…)| or |Type(…)|. I could live<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with |Any[…]| but this doesn’t look shiny and Swifty to me. Thats only my<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; personal view. ;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 26. Mai 2016 bei 19:48:04, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;) schrieb:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Don&#39;t think {} is better here, as they also have &quot;established meaning in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift today&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; How about just Type(P1 &amp; P2 | P3) - as IMO we can think of such<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; construction as &quot;creation&quot; of new type and `P1 &amp; P2 | P3` could be treated<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; as parameters to initializer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func f(t: Type(P1 &amp; P2 | P3)) {..}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 26.05.2016 20:32, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; How about something like Type{P1 &amp; P2 | P3} the point being that &quot;&lt;...&gt;&quot; has an established meaning in Swift today which is not what is expressed in the &quot;&lt;P1,P2,P3&gt;&quot; contained inside Any&lt;P1, P2,P3&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; confusion?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; force into the official lexicon of Swift. I think “Any&lt;...&gt;” is much<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; more conceptually accessible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; want to use any class requirement existential directly? If second, we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; will need to allow direct existential usage on protocols (right now we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; only can use typealiases as a worksround).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/f5859cd2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 27, 2016 at 12:00:00pm</p></header><div class="content"><p>Thanks for all your thoughtful replies.<br></p><p>I&#39;m not really invested in arguing this much further, as it&#39;s mainly a<br>stylistic thing that I could live with and also probably a hopeless battle<br>(given how everyone else disagrees). But I would like to address a few<br>final points.<br></p><p>(inline)<br></p><p>On Fri, May 27, 2016 at 12:06 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Turning it around, we don’t have to put parentheses around function types<br>&gt; and nobody complains about it being problematic even for higher-order<br>&gt; functions with several steps before the final result.<br>&gt;<br></p><p>Function types have a very regular syntax, especially now that 0066 was<br>accepted (which, I admit, was very controversal itself):<br></p><p>( &lt;one or more types&gt; ) -&gt; (tuple)<br>or<br>( &lt;one or more types&gt; ) -&gt; SingleTypeWithNoSpaces<br>or<br>( &lt;one or more types&gt; ) -&gt; GenericType&lt;All, Spaces, Are, Inside, The,<br>Brackets&gt;<br></p><p>A function type is very easy to visually parse: combine the argument<br>parens, arrow thing, and the single type that it returns. That being said,<br>complex function types are probably the most difficult types to read in a<br>function declaration today, even with this regular structure.<br></p><p>The proposed syntax, which allows arbitrary whitespace outside the context<br>of a delimiter, would require the user to scan the string comprising the<br>existential type expression for a very common sigil in order to locate the<br>endpoint: &#39;=&#39; for variable declarations (which admittedly isn&#39;t that bad)<br>or &#39;,&#39; for functions (which is a lot worse). Not to mention the point Joe<br>Groff brought up about a generic function with a generic where clause<br>returning an existential and having everything devolve into a<br>undifferentiated soup of identifiers.<br></p><p><br>&gt;<br>&gt; Does anyone know if users of Ceylon or other languages with the<br>&gt; unparenthesized syntax find it problematic?  How would they feel about<br>&gt; being required to use parentheses?<br>&gt;<br>&gt;<br>&gt; We&#39;re trying to establish a syntax that will hopefully be used for things<br>&gt; significantly more complicated than tuple definitions, which are just a<br>&gt; list of types. I think readability is a major concern. Typealiases should<br>&gt; be supported, but they shouldn&#39;t be required to make the feature useable.<br>&gt;<br>&gt;<br>&gt; I agree, but I don’t think they would be required to make the feature<br>&gt; useable just because parentheses are not required.  If a developer or team<br>&gt; thinks they are required for clarity / readability, etc they are free to<br>&gt; use them.  This is a style issue that should be addressed by a linter, not<br>&gt; the formal syntax of the language.<br>&gt;<br></p><p>It is a style issue, but so is (Int) -&gt; T versus Int -&gt; T and a lot of<br>other language details like trailing commas in argument lists, of which the<br>core team seems to feel pretty strongly about.<br></p><p><br>&gt;<br>&gt;<br>&gt; Finally, wouldn&#39;t we need some delimiter for nested existential<br>&gt; definitions anyways? Now you have the confusing situation where the outside<br>&gt; definition has no delimiters, but the inside ones do:<br>&gt;<br>&gt; // Why does the inner existential look fundamentally different than the<br>&gt; outer one?<br>&gt; // Not to mention, visually parsing the boundaries of this type when you<br>&gt; look at it in a function signature<br>&gt; let x : Protocol1, Protocol2, (Protocol 3 where .Foo == Int) where<br>&gt; Protocol2.Bar : Baz<br>&gt;<br>&gt;<br>&gt; Nested existentials are supported not because it would ever be a good idea<br>&gt; to actually write them.  They are supported to allow composition of<br>&gt; existentials:<br>&gt;<br>&gt;<br>Perhaps then we should only allow existentials to be nested if a typealias<br>is used. Swift is, after all, an opinionated language. If a feature is in<br>the language, it should either be usable directly in an ergonomic way, or<br>it shouldn&#39;t be there at all. Having a self-admittedly &quot;bad&quot; way to nest<br>literal existential expressions just for consistency when typealiases are<br>the preferred use case is very unlike Swift.<br></p><p><br>&gt; typealias P3Int = Protocol 3 where .Foo == Int<br>&gt; let x : Protocol1, Protocol2, P3Int where Protocol2.Bar : Baz<br>&gt;<br>&gt; If you are writing the entire type in a single location I expect the<br>&gt; conventional style to be like this:<br>&gt;<br>&gt; let x : Protocol1, Protocol2, Protocol 3 where Protocol2.Bar : Baz,<br>&gt; Protocol3.Foo == Int<br>&gt;<br>&gt; With all associated types constraints in a single `where` clause as we<br>&gt; other places they are written in Swift.<br>&gt;<br>&gt; Maybe I am wrong about that and a different conventional style would<br>&gt; emerge (for example, where clauses clustered with the related protocol).<br>&gt;<br>&gt; But *requiring* parentheses is really orthogonal to the style issue of<br>&gt; where and when it is considered *advisable* to use them.<br>&gt;<br>&gt; -Matthew<br>&gt;<br>&gt;<br>&gt; I hope that explains my reasoning.<br>&gt;<br>&gt; Best,<br>&gt; Austin<br>&gt;<br>&gt;<br>&gt; On May 27, 2016, at 9:28 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On May 27, 2016, at 11:18 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;<br>&gt; Here&#39;s a strawman idea.<br>&gt;<br>&gt; What if we go with &#39;&amp;&#39; and &#39;where&#39;, but we enclose the whole thing in<br>&gt; parentheses?<br>&gt;<br>&gt; (class &amp; Protocol1 &amp; Protocol2 where .Foo == Int, .Bar : Baz)<br>&gt;<br>&gt; There are a couple of reasons I propose this syntax:<br>&gt;<br>&gt; - It makes it very clear where the definition of the type begins and ends.<br>&gt; I understand people really despise angle brackets, but I really want some<br>&gt; way to visually delineate the boundaries of the type. Plus, I imagine it<br>&gt; makes syntax a little easier to parse and preemptively forbids some<br>&gt; ambiguities.<br>&gt;<br>&gt; - It&#39;s a structural, not nominal, type, like a tuple, so it uses parens as<br>&gt; well. This reserves &quot;&lt;&quot; and &quot;&gt;&quot; for generic types.<br>&gt;<br>&gt; - The &#39;&amp;&#39; is easily understood - &quot;Protocol1&quot; *and* &quot;Protocol2&quot;. It&#39;s also<br>&gt; a signal that order doesn&#39;t matter - just like how order matters with<br>&gt; things that use commas, like argument lists, tuples, and array members,<br>&gt; order doesn&#39;t generally matter with bitwise or logical &#39;and&#39; operators.<br>&gt;<br>&gt; - If we ever decide to have union types, we have a very elegant third form<br>&gt; of nominal type syntax that naturally falls out: (MyClass1 | MyClass2 |<br>&gt; MyClass3).<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt;<br>&gt; Generally in favor.  But I would not require the parentheses.  I believe<br>&gt; they would be allowed optionally automatically, just as (Int) is the same<br>&gt; as Int (because single element tuples don&#39;t exist and the underlying type<br>&gt; is used directly instead).  It seems better to leave parentheses up to a<br>&gt; matter of style.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt;<br>&gt; On May 27, 2016, at 9:07 AM, Thorsten Seitz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Am 27.05.2016 um 16:54 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt;<br>&gt;<br>&gt; On May 27, 2016, at 8:18 AM, Thorsten Seitz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Personally I think `&amp;` is more lightweight (and it is established in other<br>&gt; languages like Ceylon and Typescript) and `where` is more expressive (and<br>&gt; established in Swift for introducing constraints), so I would stay with<br>&gt; these.<br>&gt;<br>&gt;<br>&gt; I agree.  If we can make `&amp;` with `where` work syntactically it would be<br>&gt; nice to go in this lighter weight direction.  If we decide to do that the<br>&gt; question then becomes what to do with `protocol`.  Would it be feasible to<br>&gt; replace it with `&amp;` in Swift 3 if we decide on that direction?<br>&gt;<br>&gt;<br>&gt; Yep. `protocol` should be replaced with `&amp;` in that case.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt; Am 27.05.2016 um 14:34 schrieb Vladimir.S &lt;svabox at gmail.com&gt;:<br>&gt;<br>&gt; Btw, in case we have `where` keyword in syntax related to types/protocols<br>&gt; (when defining constrains. and not some symbol like &#39;&gt;&gt;&#39;.. don&#39;t know, for<br>&gt; example), why we can&#39;t have &#39;and&#39; keyword also when discuss the syntax of<br>&gt; type/protocol conjunction?<br>&gt; I.e.<br>&gt;<br>&gt; let x: P and Q<br>&gt; let x: P and Q where P.T == Q.T<br>&gt; let x: P and Q and R<br>&gt;<br>&gt; or, for consistency, as I understand it, we should have<br>&gt; let x: P &amp; Q &gt;&gt; P.T == Q.T<br>&gt;<br>&gt; On 27.05.2016 11:55, Thorsten Seitz via swift-evolution wrote:<br>&gt;<br>&gt; We could just write<br>&gt;<br>&gt; let x: P &amp; Q<br>&gt; instead of<br>&gt; let x: Any&lt;P, Q&gt;<br>&gt;<br>&gt; let x: Collection where .Element: P<br>&gt; instead of<br>&gt; let x: Any&lt;Collection where .Element: P&gt;<br>&gt;<br>&gt; let x: P &amp; Q where P.T == Q.T<br>&gt; instead of<br>&gt; let x: Any&lt;P, Q where P.T == Q.T&gt;<br>&gt;<br>&gt; let x: P &amp; Q &amp; R<br>&gt; instead of<br>&gt; let x: Any&lt;P, Q, R&gt;<br>&gt;<br>&gt; let x: Collection<br>&gt; instead of<br>&gt; let x: Any&lt;Collection&gt;<br>&gt;<br>&gt;<br>&gt; This would avoid the confusion of Any&lt;T1, T2&gt; being something completely<br>&gt; different than a generic type (i.e. order of T1, T2 does not matter whereas<br>&gt; for generic types it is essential).<br>&gt;<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt;<br>&gt; Am 26.05.2016 um 20:11 schrieb Adrian Zubarev via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt; &lt;swift-evolution at swift.org&gt;&gt;&gt;:<br>&gt;<br>&gt; Something like |type&lt;…&gt;| was considered at the very start of the whole<br>&gt; discussion (in this thread<br>&gt; &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html<br>&gt; &gt;),<br>&gt; but it does not solve the meaning of an existential type and also might<br>&gt; lead to even more confusion.<br>&gt;<br>&gt; From my perspective I wouldn’t use parentheses here because it looks more<br>&gt; like an init without any label |Type.init(…)| or |Type(…)|. I could live<br>&gt; with |Any[…]| but this doesn’t look shiny and Swifty to me. Thats only my<br>&gt; personal view. ;)<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 26. Mai 2016 bei 19:48:04, Vladimir.S via swift-evolution<br>&gt; (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt; &lt;swift-evolution at swift.org&gt;&gt;) schrieb:<br>&gt;<br>&gt; Don&#39;t think {} is better here, as they also have &quot;established meaning in<br>&gt; Swift today&quot;.<br>&gt;<br>&gt; How about just Type(P1 &amp; P2 | P3) - as IMO we can think of such<br>&gt; construction as &quot;creation&quot; of new type and `P1 &amp; P2 | P3` could be treated<br>&gt; as parameters to initializer.<br>&gt;<br>&gt; func f(t: Type(P1 &amp; P2 | P3)) {..}<br>&gt;<br>&gt;<br>&gt; On 26.05.2016 20:32, L. Mihalkovic via swift-evolution wrote:<br>&gt; &gt; How about something like Type{P1 &amp; P2 | P3} the point being that &quot;&lt;...&gt;&quot;<br>&gt; has an established meaning in Swift today which is not what is expressed in<br>&gt; the &quot;&lt;P1,P2,P3&gt;&quot; contained inside Any&lt;P1, P2,P3&gt;.<br>&gt; &gt;<br>&gt; &gt;&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt; &lt;swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org &lt;<br>&gt; mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; There is great feedback going on here. I&#39;d like to consider a few<br>&gt; things here:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt; &gt;&gt;&gt; confusion?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt; &gt;&gt; force into the official lexicon of Swift. I think “Any&lt;...&gt;” is much<br>&gt; &gt;&gt; more conceptually accessible.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt; &gt;&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt; &gt;&gt;&gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt; &gt;&gt;&gt; want to use any class requirement existential directly? If second, we<br>&gt; &gt;&gt;&gt; will need to allow direct existential usage on protocols (right now we<br>&gt; &gt;&gt;&gt; only can use typealiases as a worksround).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; Dave<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt; &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt; &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt; &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt; &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/cb23f759/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 2:26 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Thanks for all your thoughtful replies.<br>&gt; <br>&gt; I&#39;m not really invested in arguing this much further, as it&#39;s mainly a stylistic thing that I could live with and also probably a hopeless battle (given how everyone else disagrees).<br></p><p>I’ve been in the same place with some of the other stylistic battles.  :-)<br></p><p>&gt; But I would like to address a few final points.<br>&gt; <br>&gt; (inline)<br>&gt; <br>&gt; On Fri, May 27, 2016 at 12:06 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Turning it around, we don’t have to put parentheses around function types and nobody complains about it being problematic even for higher-order functions with several steps before the final result.<br>&gt; <br>&gt; Function types have a very regular syntax, especially now that 0066 was accepted (which, I admit, was very controversal itself):<br>&gt; <br>&gt; ( &lt;one or more types&gt; ) -&gt; (tuple)<br>&gt; or<br>&gt; ( &lt;one or more types&gt; ) -&gt; SingleTypeWithNoSpaces<br>&gt; or<br>&gt; ( &lt;one or more types&gt; ) -&gt; GenericType&lt;All, Spaces, Are, Inside, The, Brackets&gt;<br>&gt; <br>&gt; A function type is very easy to visually parse: combine the argument parens, arrow thing, and the single type that it returns. That being said, complex function types are probably the most difficult types to read in a function declaration today, even with this regular structure.<br>&gt; <br>&gt; The proposed syntax, which allows arbitrary whitespace outside the context of a delimiter, would require the user to scan the string comprising the existential type expression for a very common sigil in order to locate the endpoint: &#39;=&#39; for variable declarations (which admittedly isn&#39;t that bad) or &#39;,&#39; for functions (which is a lot worse). Not to mention the point Joe Groff brought up about a generic function with a generic where clause returning an existential and having everything devolve into a undifferentiated soup of identifiers.<br>&gt;  <br>&gt; <br>&gt; Does anyone know if users of Ceylon or other languages with the unparenthesized syntax find it problematic?  How would they feel about being required to use parentheses?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; We&#39;re trying to establish a syntax that will hopefully be used for things significantly more complicated than tuple definitions, which are just a list of types. I think readability is a major concern. Typealiases should be supported, but they shouldn&#39;t be required to make the feature useable.<br>&gt; <br>&gt; I agree, but I don’t think they would be required to make the feature useable just because parentheses are not required.  If a developer or team thinks they are required for clarity / readability, etc they are free to use them.  This is a style issue that should be addressed by a linter, not the formal syntax of the language.<br>&gt; <br>&gt; It is a style issue, but so is (Int) -&gt; T versus Int -&gt; T and a lot of other language details like trailing commas in argument lists, of which the core team seems to feel pretty strongly about.<br></p><p>Fair enough! :-)<br></p><p>&gt;  <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Finally, wouldn&#39;t we need some delimiter for nested existential definitions anyways? Now you have the confusing situation where the outside definition has no delimiters, but the inside ones do:<br>&gt;&gt; <br>&gt;&gt; // Why does the inner existential look fundamentally different than the outer one?<br>&gt;&gt; // Not to mention, visually parsing the boundaries of this type when you look at it in a function signature<br>&gt;&gt; let x : Protocol1, Protocol2, (Protocol 3 where .Foo == Int) where Protocol2.Bar : Baz<br>&gt; <br>&gt; Nested existentials are supported not because it would ever be a good idea to actually write them.  They are supported to allow composition of existentials:<br>&gt; <br>&gt; <br>&gt; Perhaps then we should only allow existentials to be nested if a typealias is used. Swift is, after all, an opinionated language. If a feature is in the language, it should either be usable directly in an ergonomic way, or it shouldn&#39;t be there at all. Having a self-admittedly &quot;bad&quot; way to nest literal existential expressions just for consistency when typealiases are the preferred use case is very unlike Swift.<br></p><p>I think self-admittedly “bad” is a bit of a stretch.  I do *think* the conventional style would be to match the rest of Swift.  But I’m not *certain* of that.  I could see the style Thorsten posted being conventional and useful in some cases:<br></p><p>let x : Protocol1 &amp; (Protocol2 where .Bar : Baz) &amp; (Protocol 3 where .Foo == Int)<br></p><p>I think direct `&amp;` syntax will be most useful when combining two (or maybe three) protocols with no associated types:  `Protocol1 &amp; Protocol2` (whether or not we require parens).  <br></p><p>Generally I hope we will use type aliases for existentials that are this complex just as we usually bind names to parts of expressions rather than writing large one-liners.<br></p><p>One issue I’m not sure we have addressed is the case of an existential for a single protocol with an associated type constraint `Protocol where .Foo = Int`.  Before we settle on a syntax we should be sure that this doesn’t introduce any ambiguity.<br></p><p>-Matthew<br></p><p>&gt;  <br>&gt; typealias P3Int = Protocol 3 where .Foo == Int<br>&gt; let x : Protocol1, Protocol2, P3Int where Protocol2.Bar : Baz<br>&gt; <br>&gt; If you are writing the entire type in a single location I expect the conventional style to be like this:<br>&gt; <br>&gt; let x : Protocol1, Protocol2, Protocol 3 where Protocol2.Bar : Baz, Protocol3.Foo == Int<br>&gt; <br>&gt; With all associated types constraints in a single `where` clause as we other places they are written in Swift.<br>&gt; <br>&gt; Maybe I am wrong about that and a different conventional style would emerge (for example, where clauses clustered with the related protocol).  <br>&gt; <br>&gt; But *requiring* parentheses is really orthogonal to the style issue of where and when it is considered *advisable* to use them.<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I hope that explains my reasoning.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 27, 2016, at 9:28 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 27, 2016, at 11:18 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here&#39;s a strawman idea.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What if we go with &#39;&amp;&#39; and &#39;where&#39;, but we enclose the whole thing in parentheses?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (class &amp; Protocol1 &amp; Protocol2 where .Foo == Int, .Bar : Baz)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are a couple of reasons I propose this syntax:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - It makes it very clear where the definition of the type begins and ends. I understand people really despise angle brackets, but I really want some way to visually delineate the boundaries of the type. Plus, I imagine it makes syntax a little easier to parse and preemptively forbids some ambiguities.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - It&#39;s a structural, not nominal, type, like a tuple, so it uses parens as well. This reserves &quot;&lt;&quot; and &quot;&gt;&quot; for generic types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - The &#39;&amp;&#39; is easily understood - &quot;Protocol1&quot; *and* &quot;Protocol2&quot;. It&#39;s also a signal that order doesn&#39;t matter - just like how order matters with things that use commas, like argument lists, tuples, and array members, order doesn&#39;t generally matter with bitwise or logical &#39;and&#39; operators.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - If we ever decide to have union types, we have a very elegant third form of nominal type syntax that naturally falls out: (MyClass1 | MyClass2 | MyClass3).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Generally in favor.  But I would not require the parentheses.  I believe they would be allowed optionally automatically, just as (Int) is the same as Int (because single element tuples don&#39;t exist and the underlying type is used directly instead).  It seems better to leave parentheses up to a matter of style.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 27, 2016, at 9:07 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 27.05.2016 um 16:54 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 27, 2016, at 8:18 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Personally I think `&amp;` is more lightweight (and it is established in other languages like Ceylon and Typescript) and `where` is more expressive (and established in Swift for introducing constraints), so I would stay with these.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I agree.  If we can make `&amp;` with `where` work syntactically it would be nice to go in this lighter weight direction.  If we decide to do that the question then becomes what to do with `protocol`.  Would it be feasible to replace it with `&amp;` in Swift 3 if we decide on that direction?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yep. `protocol` should be replaced with `&amp;` in that case.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 27.05.2016 um 14:34 schrieb Vladimir.S &lt;svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Btw, in case we have `where` keyword in syntax related to types/protocols (when defining constrains. and not some symbol like &#39;&gt;&gt;&#39;.. don&#39;t know, for example), why we can&#39;t have &#39;and&#39; keyword also when discuss the syntax of type/protocol conjunction?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I.e.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q where P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q and R<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or, for consistency, as I understand it, we should have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q &gt;&gt; P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 27.05.2016 11:55, Thorsten Seitz via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We could just write<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Collection where .Element: P<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;Collection where .Element: P&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q where P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q where P.T == Q.T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q &amp; R<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q, R&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;Collection&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This would avoid the confusion of Any&lt;T1, T2&gt; being something completely<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; different than a generic type (i.e. order of T1, T2 does not matter whereas<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for generic types it is essential).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 26.05.2016 um 20:11 schrieb Adrian Zubarev via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Something like |type&lt;…&gt;| was considered at the very start of the whole<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; discussion (in this thread<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html&gt;&gt;),<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but it does not solve the meaning of an existential type and also might<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; lead to even more confusion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; From my perspective I wouldn’t use parentheses here because it looks more<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; like an init without any label |Type.init(…)| or |Type(…)|. I could live<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with |Any[…]| but this doesn’t look shiny and Swifty to me. Thats only my<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; personal view. ;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 26. Mai 2016 bei 19:48:04, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;) schrieb:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Don&#39;t think {} is better here, as they also have &quot;established meaning in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift today&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; How about just Type(P1 &amp; P2 | P3) - as IMO we can think of such<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; construction as &quot;creation&quot; of new type and `P1 &amp; P2 | P3` could be treated<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; as parameters to initializer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func f(t: Type(P1 &amp; P2 | P3)) {..}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 26.05.2016 20:32, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; How about something like Type{P1 &amp; P2 | P3} the point being that &quot;&lt;...&gt;&quot; has an established meaning in Swift today which is not what is expressed in the &quot;&lt;P1,P2,P3&gt;&quot; contained inside Any&lt;P1, P2,P3&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; confusion?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; force into the official lexicon of Swift. I think “Any&lt;...&gt;” is much<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; more conceptually accessible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; want to use any class requirement existential directly? If second, we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; will need to allow direct existential usage on protocols (right now we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; only can use typealiases as a worksround).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/55f11ec0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 28, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Am 27.05.2016 um 21:41 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On May 27, 2016, at 2:26 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks for all your thoughtful replies.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not really invested in arguing this much further, as it&#39;s mainly a stylistic thing that I could live with and also probably a hopeless battle (given how everyone else disagrees).<br>&gt; <br>&gt; I’ve been in the same place with some of the other stylistic battles.  :-)<br>&gt; <br>&gt;&gt; But I would like to address a few final points.<br>&gt;&gt; <br>&gt;&gt; (inline)<br>&gt;&gt; <br>&gt;&gt; On Fri, May 27, 2016 at 12:06 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Turning it around, we don’t have to put parentheses around function types and nobody complains about it being problematic even for higher-order functions with several steps before the final result.<br>&gt;&gt; <br>&gt;&gt; Function types have a very regular syntax, especially now that 0066 was accepted (which, I admit, was very controversal itself):<br>&gt;&gt; <br>&gt;&gt; ( &lt;one or more types&gt; ) -&gt; (tuple)<br>&gt;&gt; or<br>&gt;&gt; ( &lt;one or more types&gt; ) -&gt; SingleTypeWithNoSpaces<br>&gt;&gt; or<br>&gt;&gt; ( &lt;one or more types&gt; ) -&gt; GenericType&lt;All, Spaces, Are, Inside, The, Brackets&gt;<br>&gt;&gt; <br>&gt;&gt; A function type is very easy to visually parse: combine the argument parens, arrow thing, and the single type that it returns. That being said, complex function types are probably the most difficult types to read in a function declaration today, even with this regular structure.<br>&gt;&gt; <br>&gt;&gt; The proposed syntax, which allows arbitrary whitespace outside the context of a delimiter, would require the user to scan the string comprising the existential type expression for a very common sigil in order to locate the endpoint: &#39;=&#39; for variable declarations (which admittedly isn&#39;t that bad) or &#39;,&#39; for functions (which is a lot worse). Not to mention the point Joe Groff brought up about a generic function with a generic where clause returning an existential and having everything devolve into a undifferentiated soup of identifiers.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; Does anyone know if users of Ceylon or other languages with the unparenthesized syntax find it problematic?  How would they feel about being required to use parentheses?<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We&#39;re trying to establish a syntax that will hopefully be used for things significantly more complicated than tuple definitions, which are just a list of types. I think readability is a major concern. Typealiases should be supported, but they shouldn&#39;t be required to make the feature useable.<br>&gt;&gt; <br>&gt;&gt; I agree, but I don’t think they would be required to make the feature useable just because parentheses are not required.  If a developer or team thinks they are required for clarity / readability, etc they are free to use them.  This is a style issue that should be addressed by a linter, not the formal syntax of the language.<br>&gt;&gt; <br>&gt;&gt; It is a style issue, but so is (Int) -&gt; T versus Int -&gt; T and a lot of other language details like trailing commas in argument lists, of which the core team seems to feel pretty strongly about.<br>&gt; <br>&gt; Fair enough! :-)<br>&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Finally, wouldn&#39;t we need some delimiter for nested existential definitions anyways? Now you have the confusing situation where the outside definition has no delimiters, but the inside ones do:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Why does the inner existential look fundamentally different than the outer one?<br>&gt;&gt;&gt; // Not to mention, visually parsing the boundaries of this type when you look at it in a function signature<br>&gt;&gt;&gt; let x : Protocol1, Protocol2, (Protocol 3 where .Foo == Int) where Protocol2.Bar : Baz<br>&gt;&gt; <br>&gt;&gt; Nested existentials are supported not because it would ever be a good idea to actually write them.  They are supported to allow composition of existentials:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Perhaps then we should only allow existentials to be nested if a typealias is used. Swift is, after all, an opinionated language. If a feature is in the language, it should either be usable directly in an ergonomic way, or it shouldn&#39;t be there at all. Having a self-admittedly &quot;bad&quot; way to nest literal existential expressions just for consistency when typealiases are the preferred use case is very unlike Swift.<br>&gt; <br>&gt; I think self-admittedly “bad” is a bit of a stretch.  I do *think* the conventional style would be to match the rest of Swift.  But I’m not *certain* of that.  I could see the style Thorsten posted being conventional and useful in some cases:<br>&gt; <br>&gt; let x : Protocol1 &amp; (Protocol2 where .Bar : Baz) &amp; (Protocol 3 where .Foo == Int)<br>&gt; <br>&gt; I think direct `&amp;` syntax will be most useful when combining two (or maybe three) protocols with no associated types:  `Protocol1 &amp; Protocol2` (whether or not we require parens).  <br>&gt; <br>&gt; Generally I hope we will use type aliases for existentials that are this complex just as we usually bind names to parts of expressions rather than writing large one-liners.<br>&gt; <br>&gt; One issue I’m not sure we have addressed is the case of an existential for a single protocol with an associated type constraint `Protocol where .Foo = Int`.  Before we settle on a syntax we should be sure that this doesn’t introduce any ambiguity.<br></p><p>Austin raised the point (or reminded of Joe’s raising the point) of possible problems when returning constrained existentials from generic functions:<br></p><p>func foo&lt;P, Q&gt;(p: P, q: Q) -&gt; any&lt;Collection where .Element == P&gt; where P: Equatable { … }<br></p><p>would require parentheses when using `&amp;` instead of any&lt;&gt;<br></p><p>func foo&lt;P, Q&gt;(p: P, q: Q) -&gt; (Collection where .Element == P) where P: Equatable { … }<br></p><p>This would even be the case if there was no constraint on P:<br></p><p>func foo&lt;P, Q&gt;(p: P, q: Q) -&gt; (Collection where .Element == P) { … }<br></p><p><br>An alternative would be to use `with` for existentials instead of `where`:<br></p><p>func foo&lt;P, Q&gt;(p: P, q: Q) -&gt; Collection with .Element == P where P: Equatable { … }<br> <br>But even then this would be more readable either with parentheses (now just as a matter of style) or a line break:<br></p><p>func foo&lt;P, Q&gt;(p: P, q: Q) -&gt; Collection with .Element == P <br>	where P: Equatable { … }<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt;&gt;  <br>&gt;&gt; typealias P3Int = Protocol 3 where .Foo == Int<br>&gt;&gt; let x : Protocol1, Protocol2, P3Int where Protocol2.Bar : Baz<br>&gt;&gt; <br>&gt;&gt; If you are writing the entire type in a single location I expect the conventional style to be like this:<br>&gt;&gt; <br>&gt;&gt; let x : Protocol1, Protocol2, Protocol 3 where Protocol2.Bar : Baz, Protocol3.Foo == Int<br>&gt;&gt; <br>&gt;&gt; With all associated types constraints in a single `where` clause as we other places they are written in Swift.<br>&gt;&gt; <br>&gt;&gt; Maybe I am wrong about that and a different conventional style would emerge (for example, where clauses clustered with the related protocol).  <br>&gt;&gt; <br>&gt;&gt; But *requiring* parentheses is really orthogonal to the style issue of where and when it is considered *advisable* to use them.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I hope that explains my reasoning.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 27, 2016, at 9:28 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 27, 2016, at 11:18 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Here&#39;s a strawman idea.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What if we go with &#39;&amp;&#39; and &#39;where&#39;, but we enclose the whole thing in parentheses?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (class &amp; Protocol1 &amp; Protocol2 where .Foo == Int, .Bar : Baz)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There are a couple of reasons I propose this syntax:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - It makes it very clear where the definition of the type begins and ends. I understand people really despise angle brackets, but I really want some way to visually delineate the boundaries of the type. Plus, I imagine it makes syntax a little easier to parse and preemptively forbids some ambiguities.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - It&#39;s a structural, not nominal, type, like a tuple, so it uses parens as well. This reserves &quot;&lt;&quot; and &quot;&gt;&quot; for generic types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - The &#39;&amp;&#39; is easily understood - &quot;Protocol1&quot; *and* &quot;Protocol2&quot;. It&#39;s also a signal that order doesn&#39;t matter - just like how order matters with things that use commas, like argument lists, tuples, and array members, order doesn&#39;t generally matter with bitwise or logical &#39;and&#39; operators.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - If we ever decide to have union types, we have a very elegant third form of nominal type syntax that naturally falls out: (MyClass1 | MyClass2 | MyClass3).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Generally in favor.  But I would not require the parentheses.  I believe they would be allowed optionally automatically, just as (Int) is the same as Int (because single element tuples don&#39;t exist and the underlying type is used directly instead).  It seems better to leave parentheses up to a matter of style.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 27, 2016, at 9:07 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 27.05.2016 um 16:54 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 27, 2016, at 8:18 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Personally I think `&amp;` is more lightweight (and it is established in other languages like Ceylon and Typescript) and `where` is more expressive (and established in Swift for introducing constraints), so I would stay with these.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I agree.  If we can make `&amp;` with `where` work syntactically it would be nice to go in this lighter weight direction.  If we decide to do that the question then becomes what to do with `protocol`.  Would it be feasible to replace it with `&amp;` in Swift 3 if we decide on that direction?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yep. `protocol` should be replaced with `&amp;` in that case.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 27.05.2016 um 14:34 schrieb Vladimir.S &lt;svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Btw, in case we have `where` keyword in syntax related to types/protocols (when defining constrains. and not some symbol like &#39;&gt;&gt;&#39;.. don&#39;t know, for example), why we can&#39;t have &#39;and&#39; keyword also when discuss the syntax of type/protocol conjunction?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I.e.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q where P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q and R<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or, for consistency, as I understand it, we should have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q &gt;&gt; P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 27.05.2016 11:55, Thorsten Seitz via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We could just write<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Collection where .Element: P<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;Collection where .Element: P&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q where P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q where P.T == Q.T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q &amp; R<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q, R&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;Collection&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This would avoid the confusion of Any&lt;T1, T2&gt; being something completely<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; different than a generic type (i.e. order of T1, T2 does not matter whereas<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for generic types it is essential).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 26.05.2016 um 20:11 schrieb Adrian Zubarev via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Something like |type&lt;…&gt;| was considered at the very start of the whole<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; discussion (in this thread<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html&gt;&gt;),<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but it does not solve the meaning of an existential type and also might<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; lead to even more confusion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; From my perspective I wouldn’t use parentheses here because it looks more<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; like an init without any label |Type.init(…)| or |Type(…)|. I could live<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with |Any[…]| but this doesn’t look shiny and Swifty to me. Thats only my<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; personal view. ;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 26. Mai 2016 bei 19:48:04, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;) schrieb:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Don&#39;t think {} is better here, as they also have &quot;established meaning in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift today&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; How about just Type(P1 &amp; P2 | P3) - as IMO we can think of such<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; construction as &quot;creation&quot; of new type and `P1 &amp; P2 | P3` could be treated<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; as parameters to initializer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func f(t: Type(P1 &amp; P2 | P3)) {..}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 26.05.2016 20:32, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; How about something like Type{P1 &amp; P2 | P3} the point being that &quot;&lt;...&gt;&quot; has an established meaning in Swift today which is not what is expressed in the &quot;&lt;P1,P2,P3&gt;&quot; contained inside Any&lt;P1, P2,P3&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; confusion?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; force into the official lexicon of Swift. I think “Any&lt;...&gt;” is much<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; more conceptually accessible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; want to use any class requirement existential directly? If second, we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; will need to allow direct existential usage on protocols (right now we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; only can use typealiases as a worksround).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/aa94b07b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 28, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 28, 2016, at 10:26 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; Austin raised the point (or reminded of Joe’s raising the point) of possible problems when returning constrained existentials from generic functions:<br>&gt; <br>&gt; func foo&lt;P, Q&gt;(p: P, q: Q) -&gt; any&lt;Collection where .Element == P&gt; where P: Equatable { … }<br>&gt; <br>&gt; would require parentheses when using `&amp;` instead of any&lt;&gt;<br>&gt; <br>&gt; func foo&lt;P, Q&gt;(p: P, q: Q) -&gt; (Collection where .Element == P) where P: Equatable { … }<br>&gt; <br>&gt; This would even be the case if there was no constraint on P:<br>&gt; <br>&gt; func foo&lt;P, Q&gt;(p: P, q: Q) -&gt; (Collection where .Element == P) { … }<br>&gt; <br>&gt; <br>&gt; An alternative would be to use `with` for existentials instead of `where`:<br>&gt; <br>&gt; func foo&lt;P, Q&gt;(p: P, q: Q) -&gt; Collection with .Element == P where P: Equatable { … }<br>&gt;  <br>&gt; But even then this would be more readable either with parentheses (now just as a matter of style) or a line break:<br>&gt; <br>&gt; func foo&lt;P, Q&gt;(p: P, q: Q) -&gt; Collection with .Element == P <br>&gt; 	where P: Equatable { … }<br>&gt; <br>&gt; -Thorsten<br></p><p>We could make parentheses optional in the general case, and just have them mandatory in the following situations:<br></p><p>- You want to nest an existential literal inside another existential literal:<br>let a : Protocol1, (Protocol2 where .Blah == Int), Protocol3 = foo()<br></p><p>- You want to return an existential with more than one term and/or a where clause from a function that has a generic where clause<br>func foo&lt;P, Q&gt;(p: P, q: Q) -&gt; (Collection with .Element == P) where P : Equatable { ... }<br></p><p>- You want to use an existential as a function argument, and that existential has more than one term and/or a where clause<br>func foo(x: Protocol1, y: (Protocol2 where .Blah == Int), z: Protocol3) { ... }<br></p><p>Would that be a reasonable compromise?<br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; typealias P3Int = Protocol 3 where .Foo == Int<br>&gt;&gt;&gt; let x : Protocol1, Protocol2, P3Int where Protocol2.Bar : Baz<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you are writing the entire type in a single location I expect the conventional style to be like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x : Protocol1, Protocol2, Protocol 3 where Protocol2.Bar : Baz, Protocol3.Foo == Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With all associated types constraints in a single `where` clause as we other places they are written in Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe I am wrong about that and a different conventional style would emerge (for example, where clauses clustered with the related protocol).  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But *requiring* parentheses is really orthogonal to the style issue of where and when it is considered *advisable* to use them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I hope that explains my reasoning.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 27, 2016, at 9:28 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 27, 2016, at 11:18 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Here&#39;s a strawman idea.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What if we go with &#39;&amp;&#39; and &#39;where&#39;, but we enclose the whole thing in parentheses?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; (class &amp; Protocol1 &amp; Protocol2 where .Foo == Int, .Bar : Baz)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There are a couple of reasons I propose this syntax:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - It makes it very clear where the definition of the type begins and ends. I understand people really despise angle brackets, but I really want some way to visually delineate the boundaries of the type. Plus, I imagine it makes syntax a little easier to parse and preemptively forbids some ambiguities.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - It&#39;s a structural, not nominal, type, like a tuple, so it uses parens as well. This reserves &quot;&lt;&quot; and &quot;&gt;&quot; for generic types.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - The &#39;&amp;&#39; is easily understood - &quot;Protocol1&quot; *and* &quot;Protocol2&quot;. It&#39;s also a signal that order doesn&#39;t matter - just like how order matters with things that use commas, like argument lists, tuples, and array members, order doesn&#39;t generally matter with bitwise or logical &#39;and&#39; operators.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - If we ever decide to have union types, we have a very elegant third form of nominal type syntax that naturally falls out: (MyClass1 | MyClass2 | MyClass3).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Generally in favor.  But I would not require the parentheses.  I believe they would be allowed optionally automatically, just as (Int) is the same as Int (because single element tuples don&#39;t exist and the underlying type is used directly instead).  It seems better to leave parentheses up to a matter of style.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 27, 2016, at 9:07 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 27.05.2016 um 16:54 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 27, 2016, at 8:18 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Personally I think `&amp;` is more lightweight (and it is established in other languages like Ceylon and Typescript) and `where` is more expressive (and established in Swift for introducing constraints), so I would stay with these.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I agree.  If we can make `&amp;` with `where` work syntactically it would be nice to go in this lighter weight direction.  If we decide to do that the question then becomes what to do with `protocol`.  Would it be feasible to replace it with `&amp;` in Swift 3 if we decide on that direction?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yep. `protocol` should be replaced with `&amp;` in that case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 27.05.2016 um 14:34 schrieb Vladimir.S &lt;svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Btw, in case we have `where` keyword in syntax related to types/protocols (when defining constrains. and not some symbol like &#39;&gt;&gt;&#39;.. don&#39;t know, for example), why we can&#39;t have &#39;and&#39; keyword also when discuss the syntax of type/protocol conjunction?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I.e.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q where P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P and Q and R<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or, for consistency, as I understand it, we should have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q &gt;&gt; P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 27.05.2016 11:55, Thorsten Seitz via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We could just write<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Collection where .Element: P<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;Collection where .Element: P&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q where P.T == Q.T<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q where P.T == Q.T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: P &amp; Q &amp; R<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;P, Q, R&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x: Any&lt;Collection&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This would avoid the confusion of Any&lt;T1, T2&gt; being something completely<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; different than a generic type (i.e. order of T1, T2 does not matter whereas<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for generic types it is essential).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 26.05.2016 um 20:11 schrieb Adrian Zubarev via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Something like |type&lt;…&gt;| was considered at the very start of the whole<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; discussion (in this thread<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016523.html&gt;&gt;),<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but it does not solve the meaning of an existential type and also might<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; lead to even more confusion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; From my perspective I wouldn’t use parentheses here because it looks more<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; like an init without any label |Type.init(…)| or |Type(…)|. I could live<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with |Any[…]| but this doesn’t look shiny and Swifty to me. Thats only my<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; personal view. ;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 26. Mai 2016 bei 19:48:04, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;) schrieb:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Don&#39;t think {} is better here, as they also have &quot;established meaning in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift today&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; How about just Type(P1 &amp; P2 | P3) - as IMO we can think of such<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; construction as &quot;creation&quot; of new type and `P1 &amp; P2 | P3` could be treated<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; as parameters to initializer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func f(t: Type(P1 &amp; P2 | P3)) {..}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 26.05.2016 20:32, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; How about something like Type{P1 &amp; P2 | P3} the point being that &quot;&lt;...&gt;&quot; has an established meaning in Swift today which is not what is expressed in the &quot;&lt;P1,P2,P3&gt;&quot; contained inside Any&lt;P1, P2,P3&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On May 26, 2016, at 7:11 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; on Thu May 26 2016, Adrian Zubarev &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; There is great feedback going on here. I&#39;d like to consider a few things here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; * What if we name the whole thing `Existential&lt;&gt;` to sort out all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; confusion?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Some of us believe that “existential” is way too theoretical a word to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; force into the official lexicon of Swift. I think “Any&lt;...&gt;” is much<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; more conceptually accessible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; This would allow `typealias Any = Existential&lt;&gt;`. * Should<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; `protocol A: Any&lt;class&gt;` replace `protocol A: class`? Or at least<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; deprecate it. * Do we need `typealias AnyClass = Any&lt;class&gt;` or do we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; want to use any class requirement existential directly? If second, we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; will need to allow direct existential usage on protocols (right now we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; only can use typealiases as a worksround).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/33a5e019/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 28, 2016 at 10:00:00am</p></header><div class="content"><p>Sorry, &#39;with&#39; in the second example should be &#39;where&#39;. My personal preference is to keep &#39;where&#39; for both uses, since they are serving the same purpose.<br></p><p>&gt; On May 28, 2016, at 10:33 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt; <br>&gt; We could make parentheses optional in the general case, and just have them mandatory in the following situations:<br>&gt; <br>&gt; - You want to nest an existential literal inside another existential literal:<br>&gt; let a : Protocol1, (Protocol2 where .Blah == Int), Protocol3 = foo()<br>&gt; <br>&gt; - You want to return an existential with more than one term and/or a where clause from a function that has a generic where clause<br>&gt; func foo&lt;P, Q&gt;(p: P, q: Q) -&gt; (Collection with .Element == P) where P : Equatable { ... }<br>&gt; <br>&gt; - You want to use an existential as a function argument, and that existential has more than one term and/or a where clause<br>&gt; func foo(x: Protocol1, y: (Protocol2 where .Blah == Int), z: Protocol3) { ... }<br>&gt; <br>&gt; Would that be a reasonable compromise?<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/c0ec3cc2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 28, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Am 28.05.2016 um 19:35 schrieb Austin Zheng &lt;austinzheng at gmail.com&gt;:<br>&gt; <br>&gt; Sorry, &#39;with&#39; in the second example should be &#39;where&#39;. My personal preference is to keep &#39;where&#39; for both uses, since they are serving the same purpose.<br>&gt; <br>&gt;&gt; On May 28, 2016, at 10:33 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; We could make parentheses optional in the general case, and just have them mandatory in the following situations:<br>&gt;&gt; <br>&gt;&gt; - You want to nest an existential literal inside another existential literal:<br>&gt;&gt; let a : Protocol1, (Protocol2 where .Blah == Int), Protocol3 = foo()<br></p><p>When using `&amp;` instead of `,` this would not be required (not even for readability IMO).<br></p><p><br>&gt;&gt; <br>&gt;&gt; - You want to return an existential with more than one term and/or a where clause from a function that has a generic where clause<br>&gt;&gt; func foo&lt;P, Q&gt;(p: P, q: Q) -&gt; (Collection with .Element == P) where P : Equatable { … }<br></p><p>For return types (if staying with `where` instead of `with`) the parentheses would be required iff only one `where` is present.<br>They would not be strictly required if two `where` clauses would be present, but I would be ok if they would be mandatory in that case.<br></p><p><br>&gt;&gt; <br>&gt;&gt; - You want to use an existential as a function argument, and that existential has more than one term and/or a where clause<br>&gt;&gt; func foo(x: Protocol1, y: (Protocol2 where .Blah == Int), z: Protocol3) { … }<br></p><p>I wouldn’t require them here. For one the function does not look too bad without the parentheses:<br></p><p>func foo(x: Protocol1, y: Protocol2 where .Blah == Int, z: Protocol3) { … }<br></p><p>But even more important: when formatting this function across multiple lines (which I might rather do to improve readability instead of adding parentheses) I would definitely *not* want to have to use parentheses:<br></p><p>func foo(<br>	x: Protocol1, <br>	y: Protocol2 where .Blah == Int, <br>	z: Protocol3) <br>{ … }<br></p><p><br>-Thorsten<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/de32add3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 28, 2016 at 02:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 28, 2016, at 12:50 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 28.05.2016 um 19:35 schrieb Austin Zheng &lt;austinzheng at gmail.com&gt;:<br>&gt;&gt; <br>&gt;&gt; Sorry, &#39;with&#39; in the second example should be &#39;where&#39;. My personal preference is to keep &#39;where&#39; for both uses, since they are serving the same purpose.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 28, 2016, at 10:33 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We could make parentheses optional in the general case, and just have them mandatory in the following situations:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - You want to nest an existential literal inside another existential literal:<br>&gt;&gt;&gt; let a : Protocol1, (Protocol2 where .Blah == Int), Protocol3 = foo()<br>&gt; <br>&gt; When using `&amp;` instead of `,` this would not be required (not even for readability IMO).<br>&gt; <br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - You want to return an existential with more than one term and/or a where clause from a function that has a generic where clause<br>&gt;&gt;&gt; func foo&lt;P, Q&gt;(p: P, q: Q) -&gt; (Collection with .Element == P) where P : Equatable { … }<br>&gt; <br>&gt; For return types (if staying with `where` instead of `with`) the parentheses would be required iff only one `where` is present.<br>&gt; They would not be strictly required if two `where` clauses would be present, but I would be ok if they would be mandatory in that case.<br>&gt; <br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - You want to use an existential as a function argument, and that existential has more than one term and/or a where clause<br>&gt;&gt;&gt; func foo(x: Protocol1, y: (Protocol2 where .Blah == Int), z: Protocol3) { … }<br>&gt; <br>&gt; I wouldn’t require them here. For one the function does not look too bad without the parentheses:<br>&gt; <br>&gt; func foo(x: Protocol1, y: Protocol2 where .Blah == Int, z: Protocol3) { … }<br>&gt; <br>&gt; But even more important: when formatting this function across multiple lines (which I might rather do to improve readability instead of adding parentheses) I would definitely *not* want to have to use parentheses:<br>&gt; <br>&gt; func foo(<br>&gt; 	x: Protocol1, <br>&gt; 	y: Protocol2 where .Blah == Int, <br>&gt; 	z: Protocol3) <br>&gt; { … }<br>&gt; <br></p><p>I agree with everything Thorsten said.  Parents are used to resolve ambiguity.  If we need to go a bit further than is strictly necessary for that purpose in order to make return types feel a bit more consistent that is ok.  I don&#39;t mind requiring them for a return type with a where clause, but that&#39;s as far as I&#39;d go.<br></p><p>&gt; <br>&gt; -Thorsten<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/28943046/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
