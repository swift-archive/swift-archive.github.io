<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8da0cba30fa0e47cf4fb26ebb968e552?s=50"></div><header><strong>Equality of enum with payload</strong> from <string>Jérôme Duquennoy</string> &lt;jerome+swift at duquennoy.fr&gt;<p>December 11, 2015 at 04:00:00pm</p></header><div class="content"><p>Hi everyone,<br></p><p>In swift, enums are much much more powerful than they used to be in c, c++ or objective-c.<br>One of their great feature is to be able to carry a payload.<br>Sadly, even a simple payload makes comparison much more complicated.<br></p><p>Consider this code :<br>----------------------------------------------------------------------<br>enum MyEnum {<br>  case One<br>  case Two<br>}<br></p><p>let const1 = MyEnum.One<br>let const1bis = MyEnum.One<br></p><p>const1 == const1bis // -&gt; true<br>----------------------------------------------------------------------<br></p><p>It compiles fine, and is pretty concise.<br></p><p>Let’s add a payload to the enum<br>----------------------------------------------------------------------<br>enum MyEnumWithPayload {<br>  case One(payload: String)<br>  case Two(payload: String)<br>}<br></p><p>let simplePayload = &quot;test&quot;<br></p><p>let const1 = MyEnumWithPayload.One(payload: simplePayload)<br>let const1bis = MyEnumWithPayload.One(payload: simplePayload)<br></p><p>const1 == const1bis // error : Binary operator &#39;==&#39; cannot be applied to two MyEnumWithPayload operand<br>----------------------------------------------------------------------<br></p><p>This does not compile.<br>An equality operator is needed to handle that case :<br>---------------------------------------------------------------------- <br>func ==(leftToken: MyEnumWithPayload, rightToken: MyEnumWithPayload) -&gt; Bool {<br>  var result: Bool = false;<br>  <br>  switch(leftToken, rightToken) {<br>  case (let .One(leftPayload), let .One(rightPayload)):<br>    result = (leftPayload == rightPayload)<br>  case (let .Two(leftPayload), let .Two(rightPayload)):<br>    result = (leftPayload == rightPayload)<br>  default:<br>    result = false;<br>  }<br>  <br>  return result;<br>}<br>---------------------------------------------------------------------- <br></p><p>I have two concerns with that :<br>- the added code is much bigger than the declaration of the enum, and the added code is not that simple to read. It is pretty simple to understand, but I find it complex to read.<br>- we have to use a default, otherwise, the compiler complains that the enum is not exhaustive (my compiler is configured to treat warnings as errors). So if we add a new value to the enum, we will not get a compiler warning reminding us that we should deal with equality for the new case.<br></p><p>It would be great to have a default equality operator for enums with a payload, as we have for the simple enum.<br>The logic of it would be : if the case is the same, and the payload(s) of each operand are equal, then the two operands are equal.<br></p><p>Of course, an equality operator has to be defined for the types of the payloads.<br></p><p>Jerome<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/14a4c22d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Equality of enum with payload</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 11, 2015 at 05:00:00pm</p></header><div class="content"><p>It&#39;s a similar discussion with simple structs which could automatically be<br>equatable.<br>And for Hashable.<br>It&#39;s difficult to draw a line where that makes sense and where not.<br></p><p>In any case I&#39;d prefer to not have recursive equality automatically.<br></p><p>   - It can easily lead to unexpected behavior when you forget to implement<br>   an own equality operator in order to remove variables from the equation<br>   which do not affect the equality.<br>   - You could add another variable to an existing enum (or struct) which<br>   is now automatically compared for equality without you noticing and which<br>   might be wrong.<br>   - You cannot opt out of that behavior.<br></p><p>But I agree that the current implementations of the equality operator for<br>enums are awful.<br>Maybe we can make the enum (or struct) conform to a special protocol which<br>allows it to automatically generate the equality operator (and even default<br>hashValue).<br></p><p>Something like this:<br></p><p>protocol DefaultEquatable: Equatable {}<br>protocol DefaultHashable: Hashable {}<br></p><p>enum MyEnumWithPayload: DefaultEquatable, DefaultHashable {<br>    case One(payload: String)<br>    case Two(payload: String)<br>}<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/fa200624/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Equality of enum with payload</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>December 11, 2015 at 08:00:00am</p></header><div class="content"><p>This could be implemented by extending the derived conformance logic in Sema. Right now it only derives Equatable for enums without payload cases, but it would be relatively straightforward to synthesize the obvious Equatable conformance if all payloads are themselves Equatable, or tuples of Equatable types. You would then just write<br></p><p>extension MyEnumWithPayload : Equatable {}<br></p><p>Ditto for Hashable.<br></p><p>Slava<br></p><p>&gt; On Dec 11, 2015, at 8:15 AM, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It&#39;s a similar discussion with simple structs which could automatically be equatable.<br>&gt; And for Hashable.<br>&gt; It&#39;s difficult to draw a line where that makes sense and where not.<br>&gt; <br>&gt; In any case I&#39;d prefer to not have recursive equality automatically.<br>&gt; It can easily lead to unexpected behavior when you forget to implement an own equality operator in order to remove variables from the equation which do not affect the equality.<br>&gt; You could add another variable to an existing enum (or struct) which is now automatically compared for equality without you noticing and which might be wrong.<br>&gt; You cannot opt out of that behavior.<br>&gt; But I agree that the current implementations of the equality operator for enums are awful.<br>&gt; Maybe we can make the enum (or struct) conform to a special protocol which allows it to automatically generate the equality operator (and even default hashValue).<br>&gt; <br>&gt; Something like this:<br>&gt; <br>&gt; protocol DefaultEquatable: Equatable {}<br>&gt; protocol DefaultHashable: Hashable {}<br>&gt; <br>&gt; enum MyEnumWithPayload: DefaultEquatable, DefaultHashable {<br>&gt;     case One(payload: String)<br>&gt;     case Two(payload: String)<br>&gt; }<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/335a9dde/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/61411a09f1846dd6533e84dca60232aa?s=50"></div><header><strong>Equality of enum with payload</strong> from <string>Jonathan Hise Kaldma</string> &lt;info at hisekaldma.com&gt;<p>December 11, 2015 at 06:00:00pm</p></header><div class="content"><p>+1<br></p><p>Would love to see this.<br></p><p>/Jonathan<br></p><p>&gt; 11 dec. 2015 kl. 17:37 skrev Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; This could be implemented by extending the derived conformance logic in Sema. Right now it only derives Equatable for enums without payload cases, but it would be relatively straightforward to synthesize the obvious Equatable conformance if all payloads are themselves Equatable, or tuples of Equatable types. You would then just write<br>&gt; <br>&gt; extension MyEnumWithPayload : Equatable {}<br>&gt; <br>&gt; Ditto for Hashable.<br>&gt; <br>&gt; Slava<br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 8:15 AM, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It&#39;s a similar discussion with simple structs which could automatically be equatable.<br>&gt;&gt; And for Hashable.<br>&gt;&gt; It&#39;s difficult to draw a line where that makes sense and where not.<br>&gt;&gt; <br>&gt;&gt; In any case I&#39;d prefer to not have recursive equality automatically.<br>&gt;&gt; It can easily lead to unexpected behavior when you forget to implement an own equality operator in order to remove variables from the equation which do not affect the equality.<br>&gt;&gt; You could add another variable to an existing enum (or struct) which is now automatically compared for equality without you noticing and which might be wrong.<br>&gt;&gt; You cannot opt out of that behavior.<br>&gt;&gt; But I agree that the current implementations of the equality operator for enums are awful.<br>&gt;&gt; Maybe we can make the enum (or struct) conform to a special protocol which allows it to automatically generate the equality operator (and even default hashValue).<br>&gt;&gt; <br>&gt;&gt; Something like this:<br>&gt;&gt; <br>&gt;&gt; protocol DefaultEquatable: Equatable {}<br>&gt;&gt; protocol DefaultHashable: Hashable {}<br>&gt;&gt; <br>&gt;&gt; enum MyEnumWithPayload: DefaultEquatable, DefaultHashable {<br>&gt;&gt;     case One(payload: String)<br>&gt;&gt;     case Two(payload: String)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/6394aa95/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Equality of enum with payload</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 11, 2015 at 10:00:00pm</p></header><div class="content"><p>Just stumbled upon the question whether enums/structs should automatically<br>conform to Equatable when the conformance is declared indirectly through<br>another protocol. This can be unexpected for the developer when declaring<br>conformance to a protocol of another developer.<br></p><p>protocol YourProtocol: Equatable {}<br></p><p><br>// implicitly declares conformance to Equatable - should equality operator<br>be generated or not?<br>enum MyEnum: YourProtocol {}<br></p><p>// better require explicit declaration to automatically create equality<br>operator and avoid unexpected behavior<br>enum MyEnum: Equatable, YourProtocol {}<br></p><p><br>// same for Hashable<br>enum MyEnum: Hashable {} // should raise a error since Equatable isn&#39;t<br>satisfied<br></p><p>// must also be explicit to automatically create equality operator<br>enum MyEnum: Equatable, Hashable {}<br></p><p>On Fri, Dec 11, 2015 at 6:09 PM, Jonathan Hise Kaldma via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1<br>&gt;<br>&gt; Would love to see this.<br>&gt;<br>&gt; /Jonathan<br>&gt;<br>&gt; 11 dec. 2015 kl. 17:37 skrev Slava Pestov via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; This could be implemented by extending the derived conformance logic in<br>&gt; Sema. Right now it only derives Equatable for enums without payload cases,<br>&gt; but it would be relatively straightforward to synthesize the obvious<br>&gt; Equatable conformance if all payloads are themselves Equatable, or tuples<br>&gt; of Equatable types. You would then just write<br>&gt;<br>&gt; extension MyEnumWithPayload : Equatable {}<br>&gt;<br>&gt; Ditto for Hashable.<br>&gt;<br>&gt; Slava<br>&gt;<br>&gt; On Dec 11, 2015, at 8:15 AM, Marc Knaup via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; It&#39;s a similar discussion with simple structs which could automatically be<br>&gt; equatable.<br>&gt; And for Hashable.<br>&gt; It&#39;s difficult to draw a line where that makes sense and where not.<br>&gt;<br>&gt; In any case I&#39;d prefer to not have recursive equality automatically.<br>&gt;<br>&gt;    - It can easily lead to unexpected behavior when you forget to<br>&gt;    implement an own equality operator in order to remove variables from the<br>&gt;    equation which do not affect the equality.<br>&gt;    - You could add another variable to an existing enum (or struct) which<br>&gt;    is now automatically compared for equality without you noticing and which<br>&gt;    might be wrong.<br>&gt;    - You cannot opt out of that behavior.<br>&gt;<br>&gt; But I agree that the current implementations of the equality operator for<br>&gt; enums are awful.<br>&gt; Maybe we can make the enum (or struct) conform to a special protocol which<br>&gt; allows it to automatically generate the equality operator (and even default<br>&gt; hashValue).<br>&gt;<br>&gt; Something like this:<br>&gt;<br>&gt; protocol DefaultEquatable: Equatable {}<br>&gt; protocol DefaultHashable: Hashable {}<br>&gt;<br>&gt; enum MyEnumWithPayload: DefaultEquatable, DefaultHashable {<br>&gt;     case One(payload: String)<br>&gt;     case Two(payload: String)<br>&gt; }<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/b9c25a5b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8da0cba30fa0e47cf4fb26ebb968e552?s=50"></div><header><strong>Equality of enum with payload</strong> from <string>Jérôme Duquennoy</string> &lt;jerome+swift at duquennoy.fr&gt;<p>December 15, 2015 at 12:00:00pm</p></header><div class="content"><p>So to sum up all that, there would be three possibilities :<br></p><p>1 - have an equality operator automatically generated for enum with payloads<br>That would work only if all types used in the payload have equality operators themselves.<br>If a custom equality operator is defined, it should not be overridden by a generated version.<br>That might also end up allowing equality operator for tuples. I have not checked in the code if a payload with multiple variables is considered as a tuple, if so, it would certainly be more coherent to have the same behaviour for both.<br>The hashValue method should have a similar behaviour (that is, being automatically generated), as there are coherency rules to enforce between this method and the equality operator (same hasValue for equal values)<br></p><p>2 - have a generated equality operator generated if the enum conforms to the Equatable protocol<br>That would be opt-in, and thus provide more control / more visibility to the developer.<br>That would work only if all types used in the payload have equality operator themselves.<br>That would not work for tuples, as a tuple cannot conform to a protocol.<br>The hashValue method should have a similar behaviour, that is being generated automatically only if the enum conforms to the Hashable protocol.<br></p><p>3 - don’t do anything automatic<br>IE reject that proposal :-).<br>The developer is in control, but he (or she) might have to write equality method even for standard behaviour.<br></p><p>What do you think gentlemen, can you vote for one one of those ?<br>If solution 1 or 2 gets most votes, i’ll write an official proposal and open a pull request.<br></p><p>Thanks !<br></p><p>Jérôme<br></p><p><br>&gt; On 11 Dec 2015, at 22:03, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Just stumbled upon the question whether enums/structs should automatically conform to Equatable when the conformance is declared indirectly through another protocol. This can be unexpected for the developer when declaring conformance to a protocol of another developer.<br>&gt; <br>&gt; protocol YourProtocol: Equatable {}<br>&gt; <br>&gt; <br>&gt; // implicitly declares conformance to Equatable - should equality operator be generated or not?<br>&gt; enum MyEnum: YourProtocol {}<br>&gt; <br>&gt; // better require explicit declaration to automatically create equality operator and avoid unexpected behavior<br>&gt; enum MyEnum: Equatable, YourProtocol {}<br>&gt; <br>&gt; <br>&gt; // same for Hashable<br>&gt; enum MyEnum: Hashable {} // should raise a error since Equatable isn&#39;t satisfied<br>&gt; <br>&gt; // must also be explicit to automatically create equality operator<br>&gt; enum MyEnum: Equatable, Hashable {}<br>&gt; <br>&gt; On Fri, Dec 11, 2015 at 6:09 PM, Jonathan Hise Kaldma via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; +1<br>&gt; <br>&gt; Would love to see this.<br>&gt; <br>&gt; /Jonathan<br>&gt; <br>&gt; 11 dec. 2015 kl. 17:37 skrev Slava Pestov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; This could be implemented by extending the derived conformance logic in Sema. Right now it only derives Equatable for enums without payload cases, but it would be relatively straightforward to synthesize the obvious Equatable conformance if all payloads are themselves Equatable, or tuples of Equatable types. You would then just write<br>&gt;&gt; <br>&gt;&gt; extension MyEnumWithPayload : Equatable {}<br>&gt;&gt; <br>&gt;&gt; Ditto for Hashable.<br>&gt;&gt; <br>&gt;&gt; Slava<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 11, 2015, at 8:15 AM, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s a similar discussion with simple structs which could automatically be equatable.<br>&gt;&gt;&gt; And for Hashable.<br>&gt;&gt;&gt; It&#39;s difficult to draw a line where that makes sense and where not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In any case I&#39;d prefer to not have recursive equality automatically.<br>&gt;&gt;&gt; It can easily lead to unexpected behavior when you forget to implement an own equality operator in order to remove variables from the equation which do not affect the equality.<br>&gt;&gt;&gt; You could add another variable to an existing enum (or struct) which is now automatically compared for equality without you noticing and which might be wrong.<br>&gt;&gt;&gt; You cannot opt out of that behavior.<br>&gt;&gt;&gt; But I agree that the current implementations of the equality operator for enums are awful.<br>&gt;&gt;&gt; Maybe we can make the enum (or struct) conform to a special protocol which allows it to automatically generate the equality operator (and even default hashValue).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol DefaultEquatable: Equatable {}<br>&gt;&gt;&gt; protocol DefaultHashable: Hashable {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum MyEnumWithPayload: DefaultEquatable, DefaultHashable {<br>&gt;&gt;&gt;     case One(payload: String)<br>&gt;&gt;&gt;     case Two(payload: String)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/cf6545fb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Equality of enum with payload</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>December 15, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 3:36 AM, Jérôme Duquennoy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; So to sum up all that, there would be three possibilities :<br>&gt; <br>&gt; 1 - have an equality operator automatically generated for enum with payloads<br>&gt; That would work only if all types used in the payload have equality operators themselves.<br>&gt; If a custom equality operator is defined, it should not be overridden by a generated version.<br>&gt; That might also end up allowing equality operator for tuples. I have not checked in the code if a payload with multiple variables is considered as a tuple, if so, it would certainly be more coherent to have the same behaviour for both.<br>&gt; The hashValue method should have a similar behaviour (that is, being automatically generated), as there are coherency rules to enforce between this method and the equality operator (same hasValue for equal values)<br>&gt; <br>&gt; 2 - have a generated equality operator generated if the enum conforms to the Equatable protocol<br></p><p>This would be my preferred approach.<br></p><p>&gt; That would be opt-in, and thus provide more control / more visibility to the developer.<br>&gt; That would work only if all types used in the payload have equality operator themselves.<br>&gt; That would not work for tuples, as a tuple cannot conform to a protocol.<br></p><p>The logic to derive the Equatable conformance for the enum type could special-case enum payloads by comparing them element-wise.<br></p><p>&gt; The hashValue method should have a similar behaviour, that is being generated automatically only if the enum conforms to the Hashable protocol.<br>&gt; <br>&gt; 3 - don’t do anything automatic<br>&gt; IE reject that proposal :-).<br>&gt; The developer is in control, but he (or she) might have to write equality method even for standard behaviour.<br>&gt; <br>&gt; What do you think gentlemen, can you vote for one one of those ?<br>&gt; If solution 1 or 2 gets most votes, i’ll write an official proposal and open a pull request.<br>&gt; <br>&gt; Thanks !<br>&gt; <br>&gt; Jérôme<br>&gt; <br>&gt; <br>&gt;&gt; On 11 Dec 2015, at 22:03, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Just stumbled upon the question whether enums/structs should automatically conform to Equatable when the conformance is declared indirectly through another protocol. This can be unexpected for the developer when declaring conformance to a protocol of another developer.<br>&gt;&gt; <br>&gt;&gt; protocol YourProtocol: Equatable {}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // implicitly declares conformance to Equatable - should equality operator be generated or not?<br>&gt;&gt; enum MyEnum: YourProtocol {}<br>&gt;&gt; <br>&gt;&gt; // better require explicit declaration to automatically create equality operator and avoid unexpected behavior<br>&gt;&gt; enum MyEnum: Equatable, YourProtocol {}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // same for Hashable<br>&gt;&gt; enum MyEnum: Hashable {} // should raise a error since Equatable isn&#39;t satisfied<br>&gt;&gt; <br>&gt;&gt; // must also be explicit to automatically create equality operator<br>&gt;&gt; enum MyEnum: Equatable, Hashable {}<br>&gt;&gt; <br>&gt;&gt; On Fri, Dec 11, 2015 at 6:09 PM, Jonathan Hise Kaldma via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; +1<br>&gt;&gt; <br>&gt;&gt; Would love to see this.<br>&gt;&gt; <br>&gt;&gt; /Jonathan<br>&gt;&gt; <br>&gt;&gt; 11 dec. 2015 kl. 17:37 skrev Slava Pestov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; This could be implemented by extending the derived conformance logic in Sema. Right now it only derives Equatable for enums without payload cases, but it would be relatively straightforward to synthesize the obvious Equatable conformance if all payloads are themselves Equatable, or tuples of Equatable types. You would then just write<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension MyEnumWithPayload : Equatable {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ditto for Hashable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Slava<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 11, 2015, at 8:15 AM, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s a similar discussion with simple structs which could automatically be equatable.<br>&gt;&gt;&gt;&gt; And for Hashable.<br>&gt;&gt;&gt;&gt; It&#39;s difficult to draw a line where that makes sense and where not.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In any case I&#39;d prefer to not have recursive equality automatically.<br>&gt;&gt;&gt;&gt; It can easily lead to unexpected behavior when you forget to implement an own equality operator in order to remove variables from the equation which do not affect the equality.<br>&gt;&gt;&gt;&gt; You could add another variable to an existing enum (or struct) which is now automatically compared for equality without you noticing and which might be wrong.<br>&gt;&gt;&gt;&gt; You cannot opt out of that behavior.<br>&gt;&gt;&gt;&gt; But I agree that the current implementations of the equality operator for enums are awful.<br>&gt;&gt;&gt;&gt; Maybe we can make the enum (or struct) conform to a special protocol which allows it to automatically generate the equality operator (and even default hashValue).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Something like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol DefaultEquatable: Equatable {}<br>&gt;&gt;&gt;&gt; protocol DefaultHashable: Hashable {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum MyEnumWithPayload: DefaultEquatable, DefaultHashable {<br>&gt;&gt;&gt;&gt;     case One(payload: String)<br>&gt;&gt;&gt;&gt;     case Two(payload: String)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/53b67b63/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
