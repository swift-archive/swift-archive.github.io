<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0078: Implement a rotate algorithm, equivalent to std::rotate() in C++</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May  3, 2016 at 08:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;SE-0078: Implement a rotate algorithm, equivalent to std::rotate() in C++&quot; begins now and runs through May 9. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0078-rotate-algorithm.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0078: Implement a rotate algorithm, equivalent to std::rotate() in C++</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  4, 2016 at 08:00:00am</p></header><div class="content"><p>&gt;    * What is your evaluation of the proposal?<br></p><p>+1.  I&#39;m pleased to see an important foundational algorithm added to the standard library.<br></p><p>&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.  We should have a standard, shared implementation of as many generally useful algorithms as possible, especially those whose implementation is no trivial.<br></p><p>&gt;    * Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes<br></p><p>&gt;    * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>As noted in the proposal, it is inspired by STL, which is a very good source of inspiration for generic algorithms.<br></p><p>&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Quick read of the specific details of the proposal, informed by general familiarity with generic programming and the rotate algorithm.<br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Review] SE-0078: Implement a rotate algorithm, equivalent to std::rotate() in C++</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>May  5, 2016 at 04:00:00pm</p></header><div class="content"><p>On Tue, May 3, 2016 at 8:57 PM, Chris Lattner via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;SE-0078: Implement a rotate algorithm, equivalent to std::rotate() in C++&quot; begins now and runs through May 9.<br></p><p>Hi,<br></p><p>I&#39;m posting this feedback on behalf of Dave Abrahams, Max Moiseev and<br>myself.  We met and discussed the proposal in great detail.<br></p><p>First of all, we want to thank Nate and Sergey for proposing this API,<br>which is an important and useful algorithm.  We are generally in favor<br>of the proposal, but we would like to request a few changes.<br></p><p>Could you make &#39;func rotate&#39; a requirement in the MutableCollection<br>protocol?  This allows selecting the best implementation for a given<br>concrete type, even when calling from generic code.<br></p><p>Could you explain why do we need a special implementation of<br>&#39;reverse()&#39; for RandomAccessCollection?  We couldn&#39;t think of a<br>performance reason for this.<br></p><p>Could you add complexity clauses to all new documentation comments?<br></p><p>We have discussed the names for these functions at length.  We felt<br>like the argument in &#39;rotate(firstFrom:)&#39; does not convey the<br>argument&#39;s role well.  Our suggestion is to use<br>&#39;rotate(shiftingToStart:)&#39; and &#39;rotated(shiftingToStart:)&#39;.  These<br>names emphasize that methods operate on the whole collection, shifting<br>all elements.  The argument is the index of the element that is moved<br>to the start index, and we tried to convey that by using the word<br>&#39;start&#39; instead of &#39;first&#39;.  In the standard library, &#39;first&#39; refers<br>to the element itself, not the index.  Indices use &#39;startIndex&#39; and<br>&#39;endIndex&#39;.<br></p><p>We have considered a lot of alternative names, including<br>&#39;swapSubranges(boundedBy:)&#39;, &#39;rewind&#39;, &#39;splitAndSwap&#39;, &#39;swapHalves&#39;<br>and others, but they were not as good.  The problems are:<br></p><p>- &#39;swapSubranges&#39; is mostly good, but &#39;subranges&#39; does not imply that<br>the two subranges cover the whole collection.  The user might<br>reasonably expect to pass two subranges that will be swapped.<br></p><p>- &#39;Half&#39; implies that two parts make a whole, but it also implies that<br>two parts are of equal size, which is not the case for this API.<br></p><p>- &#39;splitAndSwap&#39; implies that we are operating on the whole, but feels<br>a very roundabout way to describe the operation.<br></p><p>For a non-mutating rotation we suggest defining separate types,<br>RotatedCollection, RotatedBidirectionalCollection, and<br>RotatedRandomAccessCollection, instead of returning a<br>FlattenCollection.  This has a few advantages.<br></p><p>- We can change the non-mutating &#39;rotated()&#39; to just return the<br>collection instead of returning tuples of the collection and the<br>index.  The index of the former first element can be stored inside the<br>RotatedCollection in a property.  This change allows easier chaining<br>on &#39;.rotated()&#39;, and goes in line with the return value of the<br>mutating &#39;rotate()&#39; being discardable.<br></p><p>- Using an array in the return type of &#39;rotated()&#39;<br>(FlattenCollection&lt;[Self.SubSequence]&gt;) would be less efficient than<br>it could be (extra allocation), and also feels like exposing too many<br>implementation details that we might want to change in future (for<br>example, if we get a CollectionOfTwo type).<br></p><p>- In future, when we have conditional protocol conformances in the<br>language, we would fold the three RotatedCollection types into one<br>type that conditionally conforms to collection protocols based on the<br>capabilities of the underlying collection.  We won&#39;t be able to do<br>that if some overloads return a FlattenCollection.<br></p><p>For lazy &#39;rotated()&#39;, just like for non-mutating &#39;rotated()&#39;, we<br>recommend returning only one value, a LazyCollection that wraps an<br>appropriate RotatedCollection.  The RotatedCollection will store the<br>index of the former first element in a property.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>[Review] SE-0078: Implement a rotate algorithm, equivalent to std::rotate() in C++</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>May  5, 2016 at 07:00:00pm</p></header><div class="content"><p>Thanks for the feedback, Dmitri &amp;co, this all looks excellent! I&#39;ll work on updating the proposal.<br></p><p>&gt; On May 5, 2016, at 6:13 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Tue, May 3, 2016 at 8:57 PM, Chris Lattner via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;SE-0078: Implement a rotate algorithm, equivalent to std::rotate() in C++&quot; begins now and runs through May 9.<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; I&#39;m posting this feedback on behalf of Dave Abrahams, Max Moiseev and<br>&gt; myself.  We met and discussed the proposal in great detail.<br>&gt; <br>&gt; First of all, we want to thank Nate and Sergey for proposing this API,<br>&gt; which is an important and useful algorithm.  We are generally in favor<br>&gt; of the proposal, but we would like to request a few changes.<br>&gt; <br>&gt; Could you make &#39;func rotate&#39; a requirement in the MutableCollection<br>&gt; protocol?  This allows selecting the best implementation for a given<br>&gt; concrete type, even when calling from generic code.<br>&gt; <br>&gt; Could you explain why do we need a special implementation of<br>&gt; &#39;reverse()&#39; for RandomAccessCollection?  We couldn&#39;t think of a<br>&gt; performance reason for this.<br></p><p>With a bidirectional collection, you have to compare the high and low index at each iteration, stopping when low &gt;= high (before indices were Comparable, this required two equality comparisons per iteration). With a random-access collection, you can optimize the loop to use a fixed number of iterations, which should be more efficient.<br></p><p>&gt; Could you add complexity clauses to all new documentation comments?<br>&gt; <br>&gt; We have discussed the names for these functions at length.  We felt<br>&gt; like the argument in &#39;rotate(firstFrom:)&#39; does not convey the<br>&gt; argument&#39;s role well.  Our suggestion is to use<br>&gt; &#39;rotate(shiftingToStart:)&#39; and &#39;rotated(shiftingToStart:)&#39;.  These<br>&gt; names emphasize that methods operate on the whole collection, shifting<br>&gt; all elements.  The argument is the index of the element that is moved<br>&gt; to the start index, and we tried to convey that by using the word<br>&gt; &#39;start&#39; instead of &#39;first&#39;.  In the standard library, &#39;first&#39; refers<br>&gt; to the element itself, not the index.  Indices use &#39;startIndex&#39; and<br>&gt; &#39;endIndex&#39;.<br>&gt; <br>&gt; We have considered a lot of alternative names, including<br>&gt; &#39;swapSubranges(boundedBy:)&#39;, &#39;rewind&#39;, &#39;splitAndSwap&#39;, &#39;swapHalves&#39;<br>&gt; and others, but they were not as good.  The problems are:<br>&gt; <br>&gt; - &#39;swapSubranges&#39; is mostly good, but &#39;subranges&#39; does not imply that<br>&gt; the two subranges cover the whole collection.  The user might<br>&gt; reasonably expect to pass two subranges that will be swapped.<br>&gt; <br>&gt; - &#39;Half&#39; implies that two parts make a whole, but it also implies that<br>&gt; two parts are of equal size, which is not the case for this API.<br>&gt; <br>&gt; - &#39;splitAndSwap&#39; implies that we are operating on the whole, but feels<br>&gt; a very roundabout way to describe the operation.<br></p><p>Agreed on all of this. The rotate name is hard to beat!<br></p><p>&gt; For a non-mutating rotation we suggest defining separate types,<br>&gt; RotatedCollection, RotatedBidirectionalCollection, and<br>&gt; RotatedRandomAccessCollection, instead of returning a<br>&gt; FlattenCollection.  This has a few advantages.<br>&gt; <br>&gt; - We can change the non-mutating &#39;rotated()&#39; to just return the<br>&gt; collection instead of returning tuples of the collection and the<br>&gt; index.  The index of the former first element can be stored inside the<br>&gt; RotatedCollection in a property.  This change allows easier chaining<br>&gt; on &#39;.rotated()&#39;, and goes in line with the return value of the<br>&gt; mutating &#39;rotate()&#39; being discardable.<br>&gt; <br>&gt; - Using an array in the return type of &#39;rotated()&#39;<br>&gt; (FlattenCollection&lt;[Self.SubSequence]&gt;) would be less efficient than<br>&gt; it could be (extra allocation), and also feels like exposing too many<br>&gt; implementation details that we might want to change in future (for<br>&gt; example, if we get a CollectionOfTwo type).<br>&gt; <br>&gt; - In future, when we have conditional protocol conformances in the<br>&gt; language, we would fold the three RotatedCollection types into one<br>&gt; type that conditionally conforms to collection protocols based on the<br>&gt; capabilities of the underlying collection.  We won&#39;t be able to do<br>&gt; that if some overloads return a FlattenCollection.<br>&gt; <br>&gt; For lazy &#39;rotated()&#39;, just like for non-mutating &#39;rotated()&#39;, we<br>&gt; recommend returning only one value, a LazyCollection that wraps an<br>&gt; appropriate RotatedCollection.  The RotatedCollection will store the<br>&gt; index of the former first element in a property.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Review] SE-0078: Implement a rotate algorithm, equivalent to std::rotate() in C++</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>May  5, 2016 at 10:00:00pm</p></header><div class="content"><p>On Thu, May 5, 2016 at 5:11 PM, Nate Cook &lt;natecook at gmail.com&gt; wrote:<br>&gt; Thanks for the feedback, Dmitri &amp;co, this all looks excellent! I&#39;ll work on updating the proposal.<br>&gt;<br>&gt;&gt; On May 5, 2016, at 6:13 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Tue, May 3, 2016 at 8:57 PM, Chris Lattner via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The review of &quot;SE-0078: Implement a rotate algorithm, equivalent to std::rotate() in C++&quot; begins now and runs through May 9.<br>&gt;&gt;<br>&gt;&gt; Hi,<br>&gt;&gt;<br>&gt;&gt; I&#39;m posting this feedback on behalf of Dave Abrahams, Max Moiseev and<br>&gt;&gt; myself.  We met and discussed the proposal in great detail.<br>&gt;&gt;<br>&gt;&gt; First of all, we want to thank Nate and Sergey for proposing this API,<br>&gt;&gt; which is an important and useful algorithm.  We are generally in favor<br>&gt;&gt; of the proposal, but we would like to request a few changes.<br>&gt;&gt;<br>&gt;&gt; Could you make &#39;func rotate&#39; a requirement in the MutableCollection<br>&gt;&gt; protocol?  This allows selecting the best implementation for a given<br>&gt;&gt; concrete type, even when calling from generic code.<br>&gt;&gt;<br>&gt;&gt; Could you explain why do we need a special implementation of<br>&gt;&gt; &#39;reverse()&#39; for RandomAccessCollection?  We couldn&#39;t think of a<br>&gt;&gt; performance reason for this.<br>&gt;<br>&gt; With a bidirectional collection, you have to compare the high and low index at each iteration, stopping when low &gt;= high (before indices were Comparable, this required two equality comparisons per iteration). With a random-access collection, you can optimize the loop to use a fixed number of iterations, which should be more efficient.<br></p><p>Good point!  In that case, &#39;reverse()&#39; should also be a protocol<br>requirement, to allow dispatch to the most efficient version.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>[Review] SE-0078: Implement a rotate algorithm, equivalent to std::rotate() in C++</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>May  6, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; On May 6, 2016, at 12:35 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Thu, May 5, 2016 at 5:11 PM, Nate Cook &lt;natecook at gmail.com &lt;mailto:natecook at gmail.com&gt;&gt; wrote:<br>&gt;&gt; Thanks for the feedback, Dmitri &amp;co, this all looks excellent! I&#39;ll work on updating the proposal.<br>&gt;&gt; <br>&gt;&gt;&gt; On May 5, 2016, at 6:13 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 3, 2016 at 8:57 PM, Chris Lattner via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The review of &quot;SE-0078: Implement a rotate algorithm, equivalent to std::rotate() in C++&quot; begins now and runs through May 9.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m posting this feedback on behalf of Dave Abrahams, Max Moiseev and<br>&gt;&gt;&gt; myself.  We met and discussed the proposal in great detail.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; First of all, we want to thank Nate and Sergey for proposing this API,<br>&gt;&gt;&gt; which is an important and useful algorithm.  We are generally in favor<br>&gt;&gt;&gt; of the proposal, but we would like to request a few changes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Could you make &#39;func rotate&#39; a requirement in the MutableCollection<br>&gt;&gt;&gt; protocol?  This allows selecting the best implementation for a given<br>&gt;&gt;&gt; concrete type, even when calling from generic code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Could you explain why do we need a special implementation of<br>&gt;&gt;&gt; &#39;reverse()&#39; for RandomAccessCollection?  We couldn&#39;t think of a<br>&gt;&gt;&gt; performance reason for this.<br>&gt;&gt; <br>&gt;&gt; With a bidirectional collection, you have to compare the high and low index at each iteration, stopping when low &gt;= high (before indices were Comparable, this required two equality comparisons per iteration). With a random-access collection, you can optimize the loop to use a fixed number of iterations, which should be more efficient.<br>&gt; <br>&gt; Good point!  In that case, &#39;reverse()&#39; should also be a protocol<br>&gt; requirement, to allow dispatch to the most efficient version.<br></p><p>That brings up the question of which protocol to add the requirement to? Without a MutableBidirectionalProtocol (which we don&#39;t want, right?), we&#39;d need to add it to MutableCollection. While a mutating reverse() is possible for a forward collection, it has significant space complexity, since it works either by creating an array of the indices or through recursion. We would also have reverse() available on some collections that don&#39;t have reversed(). Does that sound alright?<br></p><p>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160506/22bf0cfd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Review] SE-0078: Implement a rotate algorithm, equivalent to std::rotate() in C++</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>May  6, 2016 at 12:00:00am</p></header><div class="content"><p>On Fri, May 6, 2016 at 12:53 AM, Nate Cook &lt;natecook at gmail.com&gt; wrote:<br>&gt; That brings up the question of which protocol to add the requirement to?<br>&gt; Without a MutableBidirectionalProtocol (which we don&#39;t want, right?), we&#39;d<br>&gt; need to add it to MutableCollection. While a mutating reverse() is possible<br>&gt; for a forward collection, it has significant space complexity, since it<br>&gt; works either by creating an array of the indices or through recursion. We<br>&gt; would also have reverse() available on some collections that don&#39;t have<br>&gt; reversed(). Does that sound alright?<br></p><p>Good question!  I don&#39;t think we should provide reverse() on forward<br>collections.<br></p><p>I think we can play some tricks here.  We can add an underscored<br>_customReverse() requirement to MutableCollection, a default<br>implementation that traps, and two specialized implementations for<br>forward and bidirectional collections.  We would then add a protocol<br>extension (not a requirement) reverse() on MutableCollection where<br>Self : BidirectionalCollection that will call _customReverse().<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
