<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>SE-0138 UnsafeBytes</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>September  1, 2016 at 03:00:00pm</p></header><div class="content"><p>I’m resending this for Review Manager Dave A. because the announce list is dropping his messages...<br></p><p>Hello Swift community,<br></p><p>The review of &quot;UnsafeBytes&quot; begins now and runs through September<br>7th. This late addition to Swift 3 is a follow-up to SE-0107:<br>UnsafeRawPointer. It addresses common use cases for UnsafeRawPointer,<br>allowing developers to continue working with collections of UInt8 values,<br>but now doing so via a type safe API. The UnsafeBytes API will not require <br>direct manipulation of raw pointers or reasoning about binding memory.<br></p><p>The proposal is available here:<br></p><p> &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md&gt;&gt;<br></p><p>Reviews are an important part of the Swift evolution process. All reviews<br>should be sent to the swift-evolution mailing list at<br></p><p> &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br></p><p>or, if you would like to keep your feedback private, directly to the<br>review manager. When replying, please try to keep the proposal link at<br>the top of the message:<br></p><p>Proposal link:<br> &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review<br>through constructive criticism and, eventually, determine the direction of<br>Swift. When writing your review, here are some questions you might want to<br>answer in your review:<br></p><p> * What is your evaluation of the proposal?<br> * Is the problem being addressed significant enough to warrant a<br>   change to Swift?<br> * Does this proposal fit well with the feel and direction of Swift?<br> * If you have used other languages or libraries with a similar<br>   feature, how do you feel that this proposal compares to those?<br> * How much effort did you put into your review? A glance, a quick<br>   reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p> &lt;https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;&gt;<br></p><p>Thank you,<br></p><p>-Dave Abrahams<br>Review Manager<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution-announce/attachments/20160901/49cb7880/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[review extended] SE-0138 UnsafeRawBufferPointer</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>September 10, 2016 at 05:00:00pm</p></header><div class="content"><p>In response to feedback, I&#39;ve revised SE-0138, now named UnsafeRawBufferPointer, and extended the review period by one week, through September 14.<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsaferawbufferpointer.md<br></p><p>-Andy<br></p><p>&gt; On Sep 1, 2016, at 3:18 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; I’m resending this for Review Manager Dave A. because the announce list is dropping his messages...<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;UnsafeBytes&quot; begins now and runs through September<br>&gt; 7th. This late addition to Swift 3 is a follow-up to SE-0107:<br>&gt; UnsafeRawPointer. It addresses common use cases for UnsafeRawPointer,<br>&gt; allowing developers to continue working with collections of UInt8 values,<br>&gt; but now doing so via a type safe API. The UnsafeBytes API will not require <br>&gt; direct manipulation of raw pointers or reasoning about binding memory.<br>&gt; <br>&gt; The proposal is available here:<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md&gt;&gt;<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt;  &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager. When replying, please try to keep the proposal link at<br>&gt; the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt;  &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt; <br>&gt;  * What is your evaluation of the proposal?<br>&gt;  * Is the problem being addressed significant enough to warrant a<br>&gt;    change to Swift?<br>&gt;  * Does this proposal fit well with the feel and direction of Swift?<br>&gt;  * If you have used other languages or libraries with a similar<br>&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;  * How much effort did you put into your review? A glance, a quick<br>&gt;    reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;&gt;<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Dave Abrahams<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution-announce/attachments/20160910/fea749c3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>SE-0138 UnsafeBytes</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>September  1, 2016 at 06:00:00pm</p></header><div class="content"><p>Proposal link:<br> &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>I&#39;m possibly one of the larger users of raw byte stuff in Swift as I maintain an entire client/server network protocol stack in Swift userspace, similar in spirit to one of the examples drawn out a lot longer.  Grepping my code produces over 200 individual uses of unsafe byte accesses.<br></p><p>I definitely agree that the problem is significant enough to warrant a last-minute change.<br></p><p>To a first approximation I agree with all the implementation choices.  The naming, the choice of UInt8, length tracking, and debug-bounds checking are all correct IMO.  We have been using something similar for a long time internally [have you been reading my code? :-) ] so I can speak from experience that the basic plan here is sound.<br></p><p>One thing I would like to see is an (opt-in) release-mode-bounds-check.  Networking is a core use case for this feature, but when you are reading from a socket, production is where you need a guard against out-of-bounds UB the most.  If we can&#39;t solve it for Swift 3, affected users can write a wrapper to implement the boundscheck, but I think we should at very least take it up again for Swift 4.<br></p><p>Drew<br></p><p><br>On September 1, 2016 at 5:19:02 PM, Andrew Trick via swift-evolution (swift-evolution at swift.org) wrote:<br></p><p>I’m resending this for Review Manager Dave A. because the announce list is dropping his messages...<br></p><p>Hello Swift community,<br></p><p>The review of &quot;UnsafeBytes&quot; begins now and runs through September<br>7th. This late addition to Swift 3 is a follow-up to SE-0107:<br>UnsafeRawPointer. It addresses common use cases for UnsafeRawPointer,<br>allowing developers to continue working with collections of UInt8 values,<br>but now doing so via a type safe API. The UnsafeBytes API will not require <br>direct manipulation of raw pointers or reasoning about binding memory.<br></p><p>The proposal is available here:<br></p><p> &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md&gt;<br></p><p>Reviews are an important part of the Swift evolution process. All reviews<br>should be sent to the swift-evolution mailing list at<br></p><p> &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>or, if you would like to keep your feedback private, directly to the<br>review manager. When replying, please try to keep the proposal link at<br>the top of the message:<br></p><p>Proposal link:<br> &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review<br>through constructive criticism and, eventually, determine the direction of<br>Swift. When writing your review, here are some questions you might want to<br>answer in your review:<br></p><p> * What is your evaluation of the proposal?<br> * Is the problem being addressed significant enough to warrant a<br>   change to Swift?<br> * Does this proposal fit well with the feel and direction of Swift?<br> * If you have used other languages or libraries with a similar<br>   feature, how do you feel that this proposal compares to those?<br> * How much effort did you put into your review? A glance, a quick<br>   reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p> &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br></p><p>Thank you,<br></p><p>-Dave Abrahams<br>Review Manager _______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160901/5b95a7c8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>SE-0138 UnsafeBytes</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>September  1, 2016 at 05:00:00pm</p></header><div class="content"><p>The proposal is available here:<br></p><p> &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md&gt;&gt;<br></p><p>&gt; On Sep 1, 2016, at 4:59 PM, Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br>&gt; I&#39;m possibly one of the larger users of raw byte stuff in Swift as I maintain an entire client/server network protocol stack in Swift userspace, similar in spirit to one of the examples drawn out a lot longer.  Grepping my code produces over 200 individual uses of unsafe byte accesses.<br>&gt; <br>&gt; I definitely agree that the problem is significant enough to warrant a last-minute change.<br>&gt; <br>&gt; To a first approximation I agree with all the implementation choices.  The naming, the choice of UInt8, length tracking, and debug-bounds checking are all correct IMO.  We have been using something similar for a long time internally [have you been reading my code? :-) ] so I can speak from experience that the basic plan here is sound.<br>&gt; <br>&gt; One thing I would like to see is an (opt-in) release-mode-bounds-check.  Networking is a core use case for this feature, but when you are reading from a socket, production is where you need a guard against out-of-bounds UB the most.  If we can&#39;t solve it for Swift 3, affected users can write a wrapper to implement the boundscheck, but I think we should at very least take it up again for Swift 4.<br>&gt; <br>&gt; Drew<br></p><p>In my current implementation:<br>https://github.com/atrick/swift/blob/unsafebytes/stdlib/public/core/UnsafeBytes.swift.gyb &lt;https://github.com/atrick/swift/blob/unsafebytes/stdlib/public/core/UnsafeBytes.swift.gyb&gt;<br></p><p>The bounds checks in `copyBytes(from:)` are release mode preconditions.<br></p><p>The bounds checks for `subscript`, `load(as:)`, and `storeBytes(of:as:)` are debug only because it’s likely they occur in some loop that could be covered by a single bounds check. By extension, the sequence iterator is only bounds checked in debug mode.<br></p><p>One possibility would be different names for the bounds checked forms of those methods: getByte(atOffset:), setByte(atOffset:), load(fromCheckedOffset:as:), storeBytes(of:toCheckedOffset:as:). Along with some kind of bounds checked Iterator.<br></p><p>I don’t think makes a lot of sense as generic Collection though. Alternatively, we just have an UnsafeBoundsCheckedBytes wrapper.<br></p><p>This would a good thing to experiment with in your project. We may be able to follow-up with a Swift 4 proposal. The important thing now is to determine whether the proposed Swift 3 design will make that wrapper difficult in any way.<br></p><p>-Andy<br>&gt; On September 1, 2016 at 5:19:02 PM, Andrew Trick via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) wrote:<br>&gt; <br>&gt;&gt; I’m resending this for Review Manager Dave A. because the announce list is dropping his messages...<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;UnsafeBytes&quot; begins now and runs through September<br>&gt;&gt; 7th. This late addition to Swift 3 is a follow-up to SE-0107:<br>&gt;&gt; UnsafeRawPointer. It addresses common use cases for UnsafeRawPointer,<br>&gt;&gt; allowing developers to continue working with collections of UInt8 values,<br>&gt;&gt; but now doing so via a type safe API. The UnsafeBytes API will not require <br>&gt;&gt; direct manipulation of raw pointers or reasoning about binding memory.<br>&gt;&gt; <br>&gt;&gt; The proposal is available here:<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt;  &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt; review manager. When replying, please try to keep the proposal link at<br>&gt;&gt; the top of the message:<br>&gt;&gt; <br>&gt;&gt; Proposal link:<br>&gt;&gt;  &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt; through constructive criticism and, eventually, determine the direction of<br>&gt;&gt; Swift. When writing your review, here are some questions you might want to<br>&gt;&gt; answer in your review:<br>&gt;&gt; <br>&gt;&gt;  * What is your evaluation of the proposal?<br>&gt;&gt;  * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;    change to Swift?<br>&gt;&gt;  * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;  * If you have used other languages or libraries with a similar<br>&gt;&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;&gt;  * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;    reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Dave Abrahams<br>&gt;&gt; Review Manager _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160901/52935d65/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>SE-0138 UnsafeBytes</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>September  2, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Sep 1, 2016, at 5:37 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; The proposal is available here:<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md&gt;&gt;<br>&gt; <br>&gt;&gt; On Sep 1, 2016, at 4:59 PM, Drew Crawford &lt;drew at sealedabstract.com &lt;mailto:drew at sealedabstract.com&gt;&gt; wrote:<br>&gt;&gt; I&#39;m possibly one of the larger users of raw byte stuff in Swift as I maintain an entire client/server network protocol stack in Swift userspace, similar in spirit to one of the examples drawn out a lot longer.  Grepping my code produces over 200 individual uses of unsafe byte accesses.<br>&gt;&gt; <br>&gt;&gt; I definitely agree that the problem is significant enough to warrant a last-minute change.<br>&gt;&gt; <br>&gt;&gt; To a first approximation I agree with all the implementation choices.  The naming, the choice of UInt8, length tracking, and debug-bounds checking are all correct IMO.  We have been using something similar for a long time internally [have you been reading my code? :-) ] so I can speak from experience that the basic plan here is sound.<br>&gt;&gt; <br>&gt;&gt; One thing I would like to see is an (opt-in) release-mode-bounds-check.  Networking is a core use case for this feature, but when you are reading from a socket, production is where you need a guard against out-of-bounds UB the most.  If we can&#39;t solve it for Swift 3, affected users can write a wrapper to implement the boundscheck, but I think we should at very least take it up again for Swift 4.<br>&gt;&gt; <br>&gt;&gt; Drew<br>&gt; <br>&gt; In my current implementation:<br>&gt; https://github.com/atrick/swift/blob/unsafebytes/stdlib/public/core/UnsafeBytes.swift.gyb &lt;https://github.com/atrick/swift/blob/unsafebytes/stdlib/public/core/UnsafeBytes.swift.gyb&gt;<br>&gt; <br>&gt; The bounds checks in `copyBytes(from:)` are release mode preconditions.<br>&gt; <br>&gt; The bounds checks for `subscript`, `load(as:)`, and `storeBytes(of:as:)` are debug only because it’s likely they occur in some loop that could be covered by a single bounds check. By extension, the sequence iterator is only bounds checked in debug mode.<br>&gt; <br>&gt; One possibility would be different names for the bounds checked forms of those methods: getByte(atOffset:), setByte(atOffset:), load(fromCheckedOffset:as:), storeBytes(of:toCheckedOffset:as:). Along with some kind of bounds checked Iterator.<br>&gt; <br>&gt; I don’t think makes a lot of sense as generic Collection though. Alternatively, we just have an UnsafeBoundsCheckedBytes wrapper.<br>&gt; <br>&gt; This would a good thing to experiment with in your project. We may be able to follow-up with a Swift 4 proposal. The important thing now is to determine whether the proposed Swift 3 design will make that wrapper difficult in any way.<br></p><p>After thinking about this for a moment, I like the approach of extending UnsafeBytes with release-mode bounds checked versions of subscript, load, and storeBytes. It’s not actually meaningful to have a bounds checked iterator for UnsafeBytes. A wrapper would only be useful to guard against accidentally circumventing the bounds checks, but I’m not sure that’s really helpful in practice. It seems that a framework would want to provide more abstract Socket I/O or network message abstractions and those wrappers would just call the bounds checked version of the UnsafeBytes APIs.<br></p><p>-Andy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160902/1cec0628/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>SE-0138 UnsafeBytes</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>September  3, 2016 at 05:00:00pm</p></header><div class="content"><p>On September 2, 2016 at 2:36:43 AM, Andrew Trick (atrick at apple.com) wrote:<br></p><p>After thinking about this for a moment, I like the approach of extending UnsafeBytes with release-mode bounds checked versions of subscript, load, and storeBytes.<br>I agree with this, I think it&#39;s mostly a question of naming and defaults.  My concern here is letting a swift developer accidentally write heartbleed, which we can&#39;t actually prevent, but we can make it harder.<br></p><p>IMO <br></p><p>1.  There should be clear consistency in the checked-ness of the API surface.  Agree that checked iterator makes no sense, but I think the most important thing is to avoid creating a job interview trivia game where `set` is checked but `store` is unchecked, spot the bug in this function.<br></p><p>2.  For consistency with UnsafeBufferPointer it may make the most sense to just ship unchecked or ship an opt-in checked wrapper.  I believe however that the existing precedent is all wrong on this point, and I&#39;d like to see us revisit this question across both interfaces in Swift 4, but I don&#39;t want to lay out a whole case here that should be its own thread.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160903/1aa5ef21/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>SE-0138 UnsafeBytes</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>September  3, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Sep 3, 2016, at 3:36 PM, Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; On September 2, 2016 at 2:36:43 AM, Andrew Trick (atrick at apple.com &lt;mailto:atrick at apple.com&gt;) wrote:<br>&gt; <br>&gt;&gt; After thinking about this for a moment, I like the approach of extending UnsafeBytes with release-mode bounds checked versions of subscript, load, and storeBytes.<br>&gt; <br>&gt; I agree with this, I think it&#39;s mostly a question of naming and defaults.  My concern here is letting a swift developer accidentally write heartbleed, which we can&#39;t actually prevent, but we can make it harder.<br>&gt; <br>&gt; IMO <br>&gt; <br>&gt; 1.  There should be clear consistency in the checked-ness of the API surface.  Agree that checked iterator makes no sense, but I think the most important thing is to avoid creating a job interview trivia game where `set` is checked but `store` is unchecked, spot the bug in this function.<br>&gt; <br>&gt; 2.  For consistency with UnsafeBufferPointer it may make the most sense to just ship unchecked or ship an opt-in checked wrapper.  I believe however that the existing precedent is all wrong on this point, and I&#39;d like to see us revisit this question across both interfaces in Swift 4, but I don&#39;t want to lay out a whole case here that should be its own thread.<br>&gt; <br>I generally agree with what you said. I think the vague plan is later in Swift 4 to ship a bounds-checked variant of both UnsafeBufferPointer and UnsafeBytes (or  UnsafeRawBufferPointer if you prefer).<br></p><p>I don’t want to eliminate the debug-mode checks though. I did try to make it clear in the comments that bounds-checking only applied to debug mode, so developers should not accidentally become too reliant on them.<br></p><p>So, the only question is whether the UnsafeBytes.copyBytes() API should have debug or release-mode checks. My decision to keep the stronger checks here was probabilistic—it seems unlikely to be a performance issue but likely to catch most buffer overruns. But I agree that it is inconsistent, especially if we plan to introduce a release bounds-checked variant later. We don’t want developers to begin relying on that check. I’m leaning toward dropping it down to a debug-mode check.<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160903/12630134/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>SE-0138 UnsafeBytes</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>September  2, 2016 at 07:00:00am</p></header><div class="content"><p>I&#39;m +1 on the proposal. Not a lot to say about it; I don&#39;t expect the community to have a passionate argument either.<br></p><p>Félix<br></p><p>&gt; Le 1 sept. 2016 à 17:37:47, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; The proposal is available here:<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md&gt;&gt;<br>&gt; <br>&gt;&gt; On Sep 1, 2016, at 4:59 PM, Drew Crawford &lt;drew at sealedabstract.com &lt;mailto:drew at sealedabstract.com&gt;&gt; wrote:<br>&gt;&gt; I&#39;m possibly one of the larger users of raw byte stuff in Swift as I maintain an entire client/server network protocol stack in Swift userspace, similar in spirit to one of the examples drawn out a lot longer.  Grepping my code produces over 200 individual uses of unsafe byte accesses.<br>&gt;&gt; <br>&gt;&gt; I definitely agree that the problem is significant enough to warrant a last-minute change.<br>&gt;&gt; <br>&gt;&gt; To a first approximation I agree with all the implementation choices.  The naming, the choice of UInt8, length tracking, and debug-bounds checking are all correct IMO.  We have been using something similar for a long time internally [have you been reading my code? :-) ] so I can speak from experience that the basic plan here is sound.<br>&gt;&gt; <br>&gt;&gt; One thing I would like to see is an (opt-in) release-mode-bounds-check.  Networking is a core use case for this feature, but when you are reading from a socket, production is where you need a guard against out-of-bounds UB the most.  If we can&#39;t solve it for Swift 3, affected users can write a wrapper to implement the boundscheck, but I think we should at very least take it up again for Swift 4.<br>&gt;&gt; <br>&gt;&gt; Drew<br>&gt; <br>&gt; In my current implementation:<br>&gt; https://github.com/atrick/swift/blob/unsafebytes/stdlib/public/core/UnsafeBytes.swift.gyb &lt;https://github.com/atrick/swift/blob/unsafebytes/stdlib/public/core/UnsafeBytes.swift.gyb&gt;<br>&gt; <br>&gt; The bounds checks in `copyBytes(from:)` are release mode preconditions.<br>&gt; <br>&gt; The bounds checks for `subscript`, `load(as:)`, and `storeBytes(of:as:)` are debug only because it’s likely they occur in some loop that could be covered by a single bounds check. By extension, the sequence iterator is only bounds checked in debug mode.<br>&gt; <br>&gt; One possibility would be different names for the bounds checked forms of those methods: getByte(atOffset:), setByte(atOffset:), load(fromCheckedOffset:as:), storeBytes(of:toCheckedOffset:as:). Along with some kind of bounds checked Iterator.<br>&gt; <br>&gt; I don’t think makes a lot of sense as generic Collection though. Alternatively, we just have an UnsafeBoundsCheckedBytes wrapper.<br>&gt; <br>&gt; This would a good thing to experiment with in your project. We may be able to follow-up with a Swift 4 proposal. The important thing now is to determine whether the proposed Swift 3 design will make that wrapper difficult in any way.<br>&gt; <br>&gt; -Andy<br>&gt;&gt; On September 1, 2016 at 5:19:02 PM, Andrew Trick via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I’m resending this for Review Manager Dave A. because the announce list is dropping his messages...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of &quot;UnsafeBytes&quot; begins now and runs through September<br>&gt;&gt;&gt; 7th. This late addition to Swift 3 is a follow-up to SE-0107:<br>&gt;&gt;&gt; UnsafeRawPointer. It addresses common use cases for UnsafeRawPointer,<br>&gt;&gt;&gt; allowing developers to continue working with collections of UInt8 values,<br>&gt;&gt;&gt; but now doing so via a type safe API. The UnsafeBytes API will not require <br>&gt;&gt;&gt; direct manipulation of raw pointers or reasoning about binding memory.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt;&gt; review manager. When replying, please try to keep the proposal link at<br>&gt;&gt;&gt; the top of the message:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal link:<br>&gt;&gt;&gt;  &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt;&gt; through constructive criticism and, eventually, determine the direction of<br>&gt;&gt;&gt; Swift. When writing your review, here are some questions you might want to<br>&gt;&gt;&gt; answer in your review:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  * What is your evaluation of the proposal?<br>&gt;&gt;&gt;  * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt;    change to Swift?<br>&gt;&gt;&gt;  * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;  * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;  * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;    reading, or an in-depth study?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Dave Abrahams<br>&gt;&gt;&gt; Review Manager _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160902/0b1d0526/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>SE-0138 UnsafeBytes</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>September  2, 2016 at 05:00:00pm</p></header><div class="content"><p>Probably the biggest argument is that it will make the migration more palatable.<br>Most (??) apps today use some form of communication, and proving a better pointer solution is a big selling point.<br>I know that my migration would have been faster and more efficient…<br></p><p>Rien.<br></p><p>&gt; On 02 Sep 2016, at 16:45, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m +1 on the proposal. Not a lot to say about it; I don&#39;t expect the community to have a passionate argument either.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 1 sept. 2016 à 17:37:47, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; The proposal is available here:<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 1, 2016, at 4:59 PM, Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br>&gt;&gt;&gt; I&#39;m possibly one of the larger users of raw byte stuff in Swift as I maintain an entire client/server network protocol stack in Swift userspace, similar in spirit to one of the examples drawn out a lot longer.  Grepping my code produces over 200 individual uses of unsafe byte accesses.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I definitely agree that the problem is significant enough to warrant a last-minute change.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To a first approximation I agree with all the implementation choices.  The naming, the choice of UInt8, length tracking, and debug-bounds checking are all correct IMO.  We have been using something similar for a long time internally [have you been reading my code? :-) ] so I can speak from experience that the basic plan here is sound.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One thing I would like to see is an (opt-in) release-mode-bounds-check.  Networking is a core use case for this feature, but when you are reading from a socket, production is where you need a guard against out-of-bounds UB the most.  If we can&#39;t solve it for Swift 3, affected users can write a wrapper to implement the boundscheck, but I think we should at very least take it up again for Swift 4.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Drew<br>&gt;&gt; <br>&gt;&gt; In my current implementation:<br>&gt;&gt; https://github.com/atrick/swift/blob/unsafebytes/stdlib/public/core/UnsafeBytes.swift.gyb<br>&gt;&gt; <br>&gt;&gt; The bounds checks in `copyBytes(from:)` are release mode preconditions.<br>&gt;&gt; <br>&gt;&gt; The bounds checks for `subscript`, `load(as:)`, and `storeBytes(of:as:)` are debug only because it’s likely they occur in some loop that could be covered by a single bounds check. By extension, the sequence iterator is only bounds checked in debug mode.<br>&gt;&gt; <br>&gt;&gt; One possibility would be different names for the bounds checked forms of those methods: getByte(atOffset:), setByte(atOffset:), load(fromCheckedOffset:as:), storeBytes(of:toCheckedOffset:as:). Along with some kind of bounds checked Iterator.<br>&gt;&gt; <br>&gt;&gt; I don’t think makes a lot of sense as generic Collection though. Alternatively, we just have an UnsafeBoundsCheckedBytes wrapper.<br>&gt;&gt; <br>&gt;&gt; This would a good thing to experiment with in your project. We may be able to follow-up with a Swift 4 proposal. The important thing now is to determine whether the proposed Swift 3 design will make that wrapper difficult in any way.<br>&gt;&gt; <br>&gt;&gt; -Andy<br>&gt;&gt;&gt; On September 1, 2016 at 5:19:02 PM, Andrew Trick via swift-evolution (swift-evolution at swift.org) wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m resending this for Review Manager Dave A. because the announce list is dropping his messages...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The review of &quot;UnsafeBytes&quot; begins now and runs through September<br>&gt;&gt;&gt;&gt; 7th. This late addition to Swift 3 is a follow-up to SE-0107:<br>&gt;&gt;&gt;&gt; UnsafeRawPointer. It addresses common use cases for UnsafeRawPointer,<br>&gt;&gt;&gt;&gt; allowing developers to continue working with collections of UInt8 values,<br>&gt;&gt;&gt;&gt; but now doing so via a type safe API. The UnsafeBytes API will not require <br>&gt;&gt;&gt;&gt; direct manipulation of raw pointers or reasoning about binding memory.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The proposal is available here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt;&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt;&gt;&gt; review manager. When replying, please try to keep the proposal link at<br>&gt;&gt;&gt;&gt; the top of the message:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposal link:<br>&gt;&gt;&gt;&gt;  &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt;&gt;&gt; through constructive criticism and, eventually, determine the direction of<br>&gt;&gt;&gt;&gt; Swift. When writing your review, here are some questions you might want to<br>&gt;&gt;&gt;&gt; answer in your review:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;  * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt;&gt;    change to Swift?<br>&gt;&gt;&gt;&gt;  * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;  * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt;&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;  * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt;    reading, or an in-depth study?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Dave Abrahams<br>&gt;&gt;&gt;&gt; Review Manager _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>SE-0138 UnsafeBytes</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>September  2, 2016 at 09:00:00am</p></header><div class="content"><p>Please include this in Swift 3.<br></p><p>I just performed a migration of client/server software from Swift 2.3 to Swift 3 beta in Xcode 8 beta 6. And though I like the UnsafeRawPointer approach, I believe this proposal is more Swift-like and is easier to understand.<br>In fact I used to have my own UInt8 buffer definition that I cleaned out in the migration. Using the proposed solution would have made this process easier.<br></p><p>Rien.<br></p><p>&gt; On 02 Sep 2016, at 00:18, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m resending this for Review Manager Dave A. because the announce list is dropping his messages...<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;UnsafeBytes&quot; begins now and runs through September<br>&gt; 7th. This late addition to Swift 3 is a follow-up to SE-0107:<br>&gt; UnsafeRawPointer. It addresses common use cases for UnsafeRawPointer,<br>&gt; allowing developers to continue working with collections of UInt8 values,<br>&gt; but now doing so via a type safe API. The UnsafeBytes API will not require <br>&gt; direct manipulation of raw pointers or reasoning about binding memory.<br>&gt; <br>&gt; The proposal is available here:<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md&gt;<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt;  &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager. When replying, please try to keep the proposal link at<br>&gt; the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt;  &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt; <br>&gt;  * What is your evaluation of the proposal?<br>&gt;  * Is the problem being addressed significant enough to warrant a<br>&gt;    change to Swift?<br>&gt;  * Does this proposal fit well with the feel and direction of Swift?<br>&gt;  * If you have used other languages or libraries with a similar<br>&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;  * How much effort did you put into your review? A glance, a quick<br>&gt;    reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Dave Abrahams<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>[swift-evolution-announce] SE-0138 UnsafeBytes</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>September  2, 2016 at 09:00:00am</p></header><div class="content"><p>Hi Andy, Dave,<br></p><p>I have two major objections to this proposal.<br></p><p>The first is timing. It is too late for us to evaluate this correctly for Swift 3.<br></p><p>The second is that this API overlaps too much with Foundation’s struct Data. We should be standardizing on a small number of common types, so that developers do not need to find ways to translate one API output into another API’s input.<br></p><p>I think we should instead focus on what needs to be added to struct Data (and other API, like Stream) to fill this role. The proposal touches only touches on this briefly, but in my opinion it is the direction we should pursue — and for Swift 4 or perhaps some Swift 3 update.<br></p><p>- Tony<br></p><p>&gt; On Sep 1, 2016, at 3:18 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; I’m resending this for Review Manager Dave A. because the announce list is dropping his messages...<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;UnsafeBytes&quot; begins now and runs through September<br>&gt; 7th. This late addition to Swift 3 is a follow-up to SE-0107:<br>&gt; UnsafeRawPointer. It addresses common use cases for UnsafeRawPointer,<br>&gt; allowing developers to continue working with collections of UInt8 values,<br>&gt; but now doing so via a type safe API. The UnsafeBytes API will not require <br>&gt; direct manipulation of raw pointers or reasoning about binding memory.<br>&gt; <br>&gt; The proposal is available here:<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md&gt;&gt;<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt;  &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager. When replying, please try to keep the proposal link at<br>&gt; the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt;  &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt; <br>&gt;  * What is your evaluation of the proposal?<br>&gt;  * Is the problem being addressed significant enough to warrant a<br>&gt;    change to Swift?<br>&gt;  * Does this proposal fit well with the feel and direction of Swift?<br>&gt;  * If you have used other languages or libraries with a similar<br>&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;  * How much effort did you put into your review? A glance, a quick<br>&gt;    reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;  &lt;https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;&gt;<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Dave Abrahams<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160902/5eff3442/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[swift-evolution-announce] SE-0138 UnsafeBytes</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>September  2, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Sep 2, 2016, at 9:31 AM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Andy, Dave,<br>&gt; <br>&gt; I have two major objections to this proposal.<br>&gt; <br>&gt; The first is timing. It is too late for us to evaluate this correctly for Swift 3.<br>&gt; <br>&gt; The second is that this API overlaps too much with Foundation’s struct Data. We should be standardizing on a small number of common types, so that developers do not need to find ways to translate one API output into another API’s input.<br>&gt; <br>&gt; I think we should instead focus on what needs to be added to struct Data (and other API, like Stream) to fill this role. The proposal touches only touches on this briefly, but in my opinion it is the direction we should pursue — and for Swift 4 or perhaps some Swift 3 update.<br>&gt; <br>&gt; - Tony<br></p><p>Foundation Data needs an interface to UnsafePointers. UnsafeBytes<br>perfectly fits that need. The same is true of any Stream or<br>BinaryFormat abstraction that we design in the future. In fact,<br>migrating Data itself to the raw pointer changes in Swift 3 is enough<br>motivation to add UnsafeBytes.<br></p><p>It&#39;s really unfortunate that Data&#39;s interface can&#39;t take advantage of<br>UnsafeBytes in Swift 3 because it would help with adoption of<br>Data. There is currently a design flaw whenever a client of Data<br>doesn&#39;t know the memory&#39;s original type. I&#39;m not happy about that, but<br>I think we can live with it for a while.<br></p><p>The issue at hand is the large amount of Swift code out there working<br>with UnsafePointers. We urgently need to provide a migration strategy<br>for that code. Obviously, we don&#39;t have an urgent need to migrate code<br>already using Data, so improving it&#39;s interface can wait until Swift 4.<br></p><p>I&#39;ve seen many attempts to migrate to Swift 3 (this has been my job<br>for the past month). I can claim with certainty that if we don&#39;t<br>give developers a natural way to replace their UnsafePointer&lt;UInt8&gt;,<br>we are going to be left with a lot of incorrect Swift code.<br></p><p>Let me make it clear that there is no overlap between Data and UnsafeBytes.<br></p><p>For public APIs, UnsafeBytes is meant to replace those functions that<br>currently take (UnsafePointer&lt;UInt8&gt;, Int) including Data&#39;s own<br>interfaces. Otherwise, we&#39;re strongly encouraging users to write<br>incorrect code on the client side. Won&#39;t NSStream, for example,<br>continue to to support UnsafePointer for those developers who need it?<br>If the developer does not need UnsafePointers, that&#39;s great, and<br>that&#39;s what we should continue striving for. But when developers are<br>using UnsafePointer, we need a natural way to use it correctly.<br></p><p>For general Swift code, Unsafe means something special and<br>important. The ultimate goal of the standard library and frameworks is<br>that application developers never need to do something Unsafe. If<br>they do, it needs to be explicitly marked Unsafe. If we are promoting<br>Foundation Data as the right way to solve problems for app developers,<br>then it needs to *not* be Unsafe.<br></p><p>UnsafeBytes simply provides a missing bridge between Unsafe pointers<br>and safe APIs like Data. By definition, Data and UnsafeBytes use cases<br>don&#39;t overlap. You either need to use Unsafe pointers because you&#39;re<br>programming at the systems level, or existing (safe) libraries do the<br>job. In practice, there are points at which these worlds meet.<br></p><p>So...<br></p><p>- Today we need UnsafeBytes so that we can migrate existing Swift<br>  code correctly to a well-defined memory model.<br></p><p>- In the future we need UnsafeBytes to safely implement the transitions<br>  between &quot;systems code&quot; and &quot;application code”.<br></p><p>-Andy<br></p><p>&gt; <br>&gt;&gt; On Sep 1, 2016, at 3:18 PM, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’m resending this for Review Manager Dave A. because the announce list is dropping his messages...<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;UnsafeBytes&quot; begins now and runs through September<br>&gt;&gt; 7th. This late addition to Swift 3 is a follow-up to SE-0107:<br>&gt;&gt; UnsafeRawPointer. It addresses common use cases for UnsafeRawPointer,<br>&gt;&gt; allowing developers to continue working with collections of UInt8 values,<br>&gt;&gt; but now doing so via a type safe API. The UnsafeBytes API will not require <br>&gt;&gt; direct manipulation of raw pointers or reasoning about binding memory.<br>&gt;&gt; <br>&gt;&gt; The proposal is available here:<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt;  &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt; review manager. When replying, please try to keep the proposal link at<br>&gt;&gt; the top of the message:<br>&gt;&gt; <br>&gt;&gt; Proposal link:<br>&gt;&gt;  &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt; through constructive criticism and, eventually, determine the direction of<br>&gt;&gt; Swift. When writing your review, here are some questions you might want to<br>&gt;&gt; answer in your review:<br>&gt;&gt; <br>&gt;&gt;  * What is your evaluation of the proposal?<br>&gt;&gt;  * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;    change to Swift?<br>&gt;&gt;  * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;  * If you have used other languages or libraries with a similar<br>&gt;&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;&gt;  * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;    reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Dave Abrahams<br>&gt;&gt; Review Manager<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution-announce mailing list<br>&gt;&gt; swift-evolution-announce at swift.org &lt;mailto:swift-evolution-announce at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce &lt;https://lists.swift.org/mailman/listinfo/swift-evolution-announce&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160902/49866b56/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>[swift-evolution-announce] SE-0138 UnsafeBytes</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>September  2, 2016 at 01:00:00pm</p></header><div class="content"><p>Hi Andy,<br></p><p>&gt; On Sep 2, 2016, at 1:08 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Sep 2, 2016, at 9:31 AM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Andy, Dave,<br>&gt;&gt; <br>&gt;&gt; I have two major objections to this proposal.<br>&gt;&gt; <br>&gt;&gt; The first is timing. It is too late for us to evaluate this correctly for Swift 3.<br>&gt;&gt; <br>&gt;&gt; The second is that this API overlaps too much with Foundation’s struct Data. We should be standardizing on a small number of common types, so that developers do not need to find ways to translate one API output into another API’s input.<br>&gt;&gt; <br>&gt;&gt; I think we should instead focus on what needs to be added to struct Data (and other API, like Stream) to fill this role. The proposal touches only touches on this briefly, but in my opinion it is the direction we should pursue — and for Swift 4 or perhaps some Swift 3 update.<br>&gt;&gt; <br>&gt;&gt; - Tony<br>&gt; <br>&gt; Foundation Data needs an interface to UnsafePointers. UnsafeBytes<br>&gt; perfectly fits that need. The same is true of any Stream or<br>&gt; BinaryFormat abstraction that we design in the future. In fact,<br>&gt; migrating Data itself to the raw pointer changes in Swift 3 is enough<br>&gt; motivation to add UnsafeBytes.<br>&gt; <br>&gt; It&#39;s really unfortunate that Data&#39;s interface can&#39;t take advantage of<br>&gt; UnsafeBytes in Swift 3 because it would help with adoption of<br>&gt; Data. There is currently a design flaw whenever a client of Data<br>&gt; doesn&#39;t know the memory&#39;s original type. I&#39;m not happy about that, but<br>&gt; I think we can live with it for a while.<br>&gt; <br>&gt; The issue at hand is the large amount of Swift code out there working<br>&gt; with UnsafePointers. We urgently need to provide a migration strategy<br>&gt; for that code. Obviously, we don&#39;t have an urgent need to migrate code<br>&gt; already using Data, so improving it&#39;s interface can wait until Swift 4.<br>&gt; <br>&gt; I&#39;ve seen many attempts to migrate to Swift 3 (this has been my job<br>&gt; for the past month). I can claim with certainty that if we don&#39;t<br>&gt; give developers a natural way to replace their UnsafePointer&lt;UInt8&gt;,<br>&gt; we are going to be left with a lot of incorrect Swift code.<br>&gt; <br>&gt; Let me make it clear that there is no overlap between Data and UnsafeBytes.<br>&gt; <br>&gt; For public APIs, UnsafeBytes is meant to replace those functions that<br>&gt; currently take (UnsafePointer&lt;UInt8&gt;, Int) including Data&#39;s own<br>&gt; interfaces. Otherwise, we&#39;re strongly encouraging users to write<br>&gt; incorrect code on the client side. Won&#39;t NSStream, for example,<br>&gt; continue to to support UnsafePointer for those developers who need it?<br>&gt; If the developer does not need UnsafePointers, that&#39;s great, and<br>&gt; that&#39;s what we should continue striving for. But when developers are<br>&gt; using UnsafePointer, we need a natural way to use it correctly.<br>&gt; <br>&gt; For general Swift code, Unsafe means something special and<br>&gt; important. The ultimate goal of the standard library and frameworks is<br>&gt; that application developers never need to do something Unsafe. If<br>&gt; they do, it needs to be explicitly marked Unsafe. If we are promoting<br>&gt; Foundation Data as the right way to solve problems for app developers,<br>&gt; then it needs to *not* be Unsafe.<br>&gt; <br>&gt; UnsafeBytes simply provides a missing bridge between Unsafe pointers<br>&gt; and safe APIs like Data. By definition, Data and UnsafeBytes use cases<br>&gt; don&#39;t overlap. You either need to use Unsafe pointers because you&#39;re<br>&gt; programming at the systems level, or existing (safe) libraries do the<br>&gt; job. In practice, there are points at which these worlds meet.<br>&gt; <br>&gt; So...<br>&gt; <br>&gt; - Today we need UnsafeBytes so that we can migrate existing Swift<br>&gt;   code correctly to a well-defined memory model.<br>&gt; <br>&gt; - In the future we need UnsafeBytes to safely implement the transitions<br>&gt;   between &quot;systems code&quot; and &quot;application code”.<br>&gt; <br>&gt; -Andy<br></p><p>If the goal is to simplify the story for developers, so they can understand the complicated topic of the way that binding memory works in Swift, then introducing a new intermediate type feels to me like working in the opposite direction.<br></p><p>I would instead prefer to look at what we can do with adding API to the existing types to cover this use case. You point out in the proposal that it has become customary to use [UInt8] in API. I would prefer that we work towards a solution that makes it customary to use Data when you want to expose an API that uses Data. The example of migrated code in the proposal illustrates my concern. It suggests that the conversion for handleMessages should end here:<br></p><p>func handleMessages(_ bytes: UnsafeBytes) -&gt; Int<br></p><p>I think instead handleMessages should take a Data argument. The input driver code should be able to use API on Data (or elsewhere, API that returns Data) to populate it with the contents of the file. For example, the existing:<br></p><p>public init(contentsOf url: URL, options: Data.ReadingOptions = []) throws <br></p><p>Or by extending Stream, if necessary.<br></p><p>The JSON example advocates converting the struct Data to an NSData to access the bytes property. We specifically introduced the withUnsafeBytes argument to keep people from doing this. If there is an issue with it, we need to address it in struct Data, not by asking people to create another instance of a new type after bridging to the reference. Furthermore, with the lack of bridging on Linux plus the lack of the autoreleasepool that makes the bytes property safe in the first place, this example won’t even work there. <br></p><p>Arguments of being out of time do not compel me, personally. Introducing a new type is effectively permanent. We just got started with introducing Swift API. I don’t want to accidentally saddle ourselves with additional complexity forever without giving ourselves an adequate opportunity to fully consider what the right long-term solution is. The fact that you’ve already described the mismatch between struct Data and this type as “unfortunate” sounds, to me, like a big problem.<br></p><p>- Tony<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 1, 2016, at 3:18 PM, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m resending this for Review Manager Dave A. because the announce list is dropping his messages...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of &quot;UnsafeBytes&quot; begins now and runs through September<br>&gt;&gt;&gt; 7th. This late addition to Swift 3 is a follow-up to SE-0107:<br>&gt;&gt;&gt; UnsafeRawPointer. It addresses common use cases for UnsafeRawPointer,<br>&gt;&gt;&gt; allowing developers to continue working with collections of UInt8 values,<br>&gt;&gt;&gt; but now doing so via a type safe API. The UnsafeBytes API will not require <br>&gt;&gt;&gt; direct manipulation of raw pointers or reasoning about binding memory.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt;&gt; review manager. When replying, please try to keep the proposal link at<br>&gt;&gt;&gt; the top of the message:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal link:<br>&gt;&gt;&gt;  &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt;&gt; through constructive criticism and, eventually, determine the direction of<br>&gt;&gt;&gt; Swift. When writing your review, here are some questions you might want to<br>&gt;&gt;&gt; answer in your review:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  * What is your evaluation of the proposal?<br>&gt;&gt;&gt;  * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt;    change to Swift?<br>&gt;&gt;&gt;  * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;  * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;  * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;    reading, or an in-depth study?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Dave Abrahams<br>&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution-announce mailing list<br>&gt;&gt;&gt; swift-evolution-announce at swift.org &lt;mailto:swift-evolution-announce at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce &lt;https://lists.swift.org/mailman/listinfo/swift-evolution-announce&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160902/ead2cdf7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[swift-evolution-announce] SE-0138 UnsafeBytes</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>September  2, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Sep 2, 2016, at 1:34 PM, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br>&gt; <br>&gt; Arguments of being out of time do not compel me, personally. Introducing a new type is effectively permanent. We just got started with introducing Swift API. I don’t want to accidentally saddle ourselves with additional complexity forever without giving ourselves an adequate opportunity to fully consider what the right long-term solution is. The fact that you’ve already described the mismatch between struct Data and this type as “unfortunate” sounds, to me, like a big problem.<br></p><p>There is no mismatch between Data and UnsafeBytes. Data requires UnsafeBytes whenever the user is working with UnsafeRawPointers. UnsafeBytes is meant to enable interoperability with Data in these cases.<br></p><p>I included the Framework Interfaces section so that you could see what I think right long term solution is:<br>https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md#framework-interfaces &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md#framework-interfaces&gt;<br></p><p>If you have any concrete concerns about that long-term solution, then that would be good raise.<br></p><p>-Andy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160902/625ad687/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>[swift-evolution-announce] SE-0138 UnsafeBytes</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>September  3, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 02 Sep 2016, at 22:34, Tony Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; I would instead prefer to look at what we can do with adding API to the existing types to cover this use case. You point out in the proposal that it has become customary to use [UInt8] in API. I would prefer that we work towards a solution that makes it customary to use Data when you want to expose an API that uses Data. <br></p><p>I support that sentiment. We should stick with existing solutions and not dilute them without reason.<br></p><p>Having said that, my personal experience with NSData is pretty bad. It never really fits my needs unless I am dealing with amorphous data that stay’s amorphous.<br>As soon as I need to figure out what is in the data, the code gets ugly fast and needs extensive commenting to stay maintainable (and we all know what happens with comments…)<br></p><p>I think Andy is right, and we need to differentiate between byte access and amorphous data blocks.<br></p><p>A minor point: many programmers new to the platform will know what to do with pointers, Data on the other hand is too much of an abstraction to grasp intuitively.<br></p><p>And a minor-minor point: Personally I hate the “Unsafe” part in the name. Seems a bit pedantic to me. I do not need subjective judgements in a language. (Is there really a SW-engineer out there that does not know about the inherent dangers of direct memory access?, does “unsafe” really add value to the language?)<br></p><p>Rien.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[swift-evolution-announce] SE-0138 UnsafeBytes</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>September  3, 2016 at 05:00:00pm</p></header><div class="content"><p>On September 2, 2016 at 3:34:56 PM, Tony Parker via swift-evolution (swift-evolution at swift.org) wrote:<br>I think instead handleMessages should take a Data argument.<br>The core issue here is that the problem solved here is not a &quot;foundation problem&quot;, it is a &quot;stdlib problem&quot;.  They are superficially similar in that both of them involve an array of bytes but the comparison ends there.<br></p><p>The motivation for Data/NSData is we have a logical collection of bytes.  That collection may be contiguous or discontiguous (speaking only of API; I&#39;m unfamiliar with the implementation choice).    It may be created from a file or even a URL, from a base64 representation, it may share the underlying memory with other NSData instance or not.<br></p><p>What we are considering here is a *physical* collection of bytes, e.g. a pointer and a length.  By definition, they do not share memory with each other (unless they overlap, which is you can find out with public API).  By definition, they are contiguous.  <br></p><p>Data is the abstraction to choose when you don&#39;t care how the memory is laid out.  UnsafeBytes is the abstraction to choose when the memory layout is the critical property.  e.g., you are bitshifting between the IEEE754 fields to implement fastinvsqrt, or you are converting between sockaddr and sockaddr_in (same type but different sizes).  <br></p><p>These are not I/O problems or array problems.  They are C pointer problems, where we want to dispense with the traditional Swift abstractions and view the world as C arrays again like it&#39;s 1970.<br></p><p>Like all pointer problems in the language, they aren&#39;t foundation problems and we should not solve them there, whether we are under time pressure or with all the time in the world.  They should be solved where we solve the other pointer problems, which is in the stdlib.<br></p><p>I think instead handleMessages should take a Data argument. The input driver code should be able to use API on Data (or elsewhere, API that returns Data) to populate it with the contents of the file.<br>The core API in my networking project is fairly similar to this example, and in that case, NSData was not the right choice, because it does not support<br></p><p>Uninitialized arrays<br>Explicitly managing zero-cost &quot;views&quot; of the underlying memory by creating instances that refer to the same location and sliding the start and end markers<br>Casting unsafely between arrays of different size<br>Working with memory regions where the size is not known at compile time but is discovered during a read such as pascal strings or msgpack<br>These are totally ridiculous additions to the Data API surface.  Somebody who wants to load a URL should never see this garbage in their autocomplete.  But they are things C programmers frequently do.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160903/2c41a14c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[swift-evolution-announce] SE-0138 UnsafeBytes</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>September  6, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Sep 2, 2016, at 1:08 PM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Sep 2, 2016, at 9:31 AM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Andy, Dave,<br>&gt;&gt; <br>&gt;&gt; I have two major objections to this proposal.<br>&gt;&gt; <br>&gt;&gt; The first is timing. It is too late for us to evaluate this correctly for Swift 3.<br>&gt;&gt; <br>&gt;&gt; The second is that this API overlaps too much with Foundation’s struct Data. We should be standardizing on a small number of common types, so that developers do not need to find ways to translate one API output into another API’s input.<br>&gt;&gt; <br>&gt;&gt; I think we should instead focus on what needs to be added to struct Data (and other API, like Stream) to fill this role. The proposal touches only touches on this briefly, but in my opinion it is the direction we should pursue — and for Swift 4 or perhaps some Swift 3 update.<br>&gt;&gt; <br>&gt;&gt; - Tony<br></p><p>Here&#39;s a quick follow up to the Data vs. UnsafeBytes discussion, merely because I think it&#39;s interesting and will help people understand both types. Some of the immediate concern will be alleviated by renaming UnsafeBytes to UnsafeRawBufferPointer.<br></p><p>Ignoring &#39;bytesNoCopy&#39; for a moment:<br></p><p>- Both are abstractions over raw, untyped memory.<br></p><p>- Both can be viewed as a collection of UInt8 bytes.<br></p><p>- Data has value semantics. UnsafeRawBufferPointer has pointer semantics.<br></p><p>- Data is owned. UnsafeRawBufferPointer is unowned.<br></p><p>- Data is a self-contained object. UnsafeRawBufferPointer is a slice of memory.<br></p><p>- Data is growable.<br></p><p>&#39;init(bytesNoCopy:)&#39; is a special case that allows Data to circumvent normal behavior as an optimization. But getting data in via &#39;bytesNoCopy&#39; requires first obtaining an unowned view of a slice of raw memory, and that is precisely what UnsafeRawBufferPointer is. Taking an unsafe, unowned view of memory should always be explicit in user code, not something that should be hidden behind the Data API. We need the UnsafeRawBufferPointer type in order to make that conversion explicit.<br></p><p>These data types represent distinct and individually important layers of the semantics of raw data. They do not compete for use cases at the same API level. UnsafeRawBufferPointer only supports the basic functionality of interoperating with UnsafePointers and accessing existing raw memory. Data has extensive API surface for constructing a buffer of serialized data and moving that data across library boundaries. Data is the common currency for framework APIs.<br></p><p>-Andy<br></p><p>&gt; Foundation Data needs an interface to UnsafePointers. UnsafeBytes<br>&gt; perfectly fits that need. The same is true of any Stream or<br>&gt; BinaryFormat abstraction that we design in the future. In fact,<br>&gt; migrating Data itself to the raw pointer changes in Swift 3 is enough<br>&gt; motivation to add UnsafeBytes.<br>&gt; <br>&gt; It&#39;s really unfortunate that Data&#39;s interface can&#39;t take advantage of<br>&gt; UnsafeBytes in Swift 3 because it would help with adoption of<br>&gt; Data. There is currently a design flaw whenever a client of Data<br>&gt; doesn&#39;t know the memory&#39;s original type. I&#39;m not happy about that, but<br>&gt; I think we can live with it for a while.<br>&gt; <br>&gt; The issue at hand is the large amount of Swift code out there working<br>&gt; with UnsafePointers. We urgently need to provide a migration strategy<br>&gt; for that code. Obviously, we don&#39;t have an urgent need to migrate code<br>&gt; already using Data, so improving it&#39;s interface can wait until Swift 4.<br>&gt; <br>&gt; I&#39;ve seen many attempts to migrate to Swift 3 (this has been my job<br>&gt; for the past month). I can claim with certainty that if we don&#39;t<br>&gt; give developers a natural way to replace their UnsafePointer&lt;UInt8&gt;,<br>&gt; we are going to be left with a lot of incorrect Swift code.<br>&gt; <br>&gt; Let me make it clear that there is no overlap between Data and UnsafeBytes.<br>&gt; <br>&gt; For public APIs, UnsafeBytes is meant to replace those functions that<br>&gt; currently take (UnsafePointer&lt;UInt8&gt;, Int) including Data&#39;s own<br>&gt; interfaces. Otherwise, we&#39;re strongly encouraging users to write<br>&gt; incorrect code on the client side. Won&#39;t NSStream, for example,<br>&gt; continue to to support UnsafePointer for those developers who need it?<br>&gt; If the developer does not need UnsafePointers, that&#39;s great, and<br>&gt; that&#39;s what we should continue striving for. But when developers are<br>&gt; using UnsafePointer, we need a natural way to use it correctly.<br>&gt; <br>&gt; For general Swift code, Unsafe means something special and<br>&gt; important. The ultimate goal of the standard library and frameworks is<br>&gt; that application developers never need to do something Unsafe. If<br>&gt; they do, it needs to be explicitly marked Unsafe. If we are promoting<br>&gt; Foundation Data as the right way to solve problems for app developers,<br>&gt; then it needs to *not* be Unsafe.<br>&gt; <br>&gt; UnsafeBytes simply provides a missing bridge between Unsafe pointers<br>&gt; and safe APIs like Data. By definition, Data and UnsafeBytes use cases<br>&gt; don&#39;t overlap. You either need to use Unsafe pointers because you&#39;re<br>&gt; programming at the systems level, or existing (safe) libraries do the<br>&gt; job. In practice, there are points at which these worlds meet.<br>&gt; <br>&gt; So...<br>&gt; <br>&gt; - Today we need UnsafeBytes so that we can migrate existing Swift<br>&gt;   code correctly to a well-defined memory model.<br>&gt; <br>&gt; - In the future we need UnsafeBytes to safely implement the transitions<br>&gt;   between &quot;systems code&quot; and &quot;application code”.<br>&gt; <br>&gt; -Andy<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 1, 2016, at 3:18 PM, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m resending this for Review Manager Dave A. because the announce list is dropping his messages...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of &quot;UnsafeBytes&quot; begins now and runs through September<br>&gt;&gt;&gt; 7th. This late addition to Swift 3 is a follow-up to SE-0107:<br>&gt;&gt;&gt; UnsafeRawPointer. It addresses common use cases for UnsafeRawPointer,<br>&gt;&gt;&gt; allowing developers to continue working with collections of UInt8 values,<br>&gt;&gt;&gt; but now doing so via a type safe API. The UnsafeBytes API will not require <br>&gt;&gt;&gt; direct manipulation of raw pointers or reasoning about binding memory.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt;&gt; review manager. When replying, please try to keep the proposal link at<br>&gt;&gt;&gt; the top of the message:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal link:<br>&gt;&gt;&gt;  &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt;&gt; through constructive criticism and, eventually, determine the direction of<br>&gt;&gt;&gt; Swift. When writing your review, here are some questions you might want to<br>&gt;&gt;&gt; answer in your review:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  * What is your evaluation of the proposal?<br>&gt;&gt;&gt;  * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt;    change to Swift?<br>&gt;&gt;&gt;  * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;  * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;  * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;    reading, or an in-depth study?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Dave Abrahams<br>&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution-announce mailing list<br>&gt;&gt;&gt; swift-evolution-announce at swift.org &lt;mailto:swift-evolution-announce at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce &lt;https://lists.swift.org/mailman/listinfo/swift-evolution-announce&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160906/45ea68ae/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
