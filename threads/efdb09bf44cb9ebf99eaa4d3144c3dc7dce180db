<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 15, 2016 at 11:00:00am</p></header><div class="content"><p>While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal.  Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way.  Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused.  It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary.  Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br></p><p>Thoughts?<br></p><p>~Robert Widmann<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 15, 2016 at 01:00:00pm</p></header><div class="content"><p>The scope for a top-level declaration is the file itself.  This means that top-level declarations with `private` and `fileprivate` should have the same behavior.  They should not be uninstantiable or unusable.<br></p><p>-Matthew<br></p><p>&gt; On Jun 15, 2016, at 1:31 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal.  Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way.  Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused.  It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary.  Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 15, 2016 at 11:00:00am</p></header><div class="content"><p>The scope of the *declaration* is not the issue.  The scope of its *members* is.<br></p><p>~Robert Widmann<br></p><p>2016/06/15 11:36、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br></p><p>&gt; The scope for a top-level declaration is the file itself.  This means that top-level declarations with `private` and `fileprivate` should have the same behavior.  They should not be uninstantiable or unusable.<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt;&gt; On Jun 15, 2016, at 1:31 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal.  Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way.  Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused.  It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary.  Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 15, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 15, 2016, at 1:37 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; The scope of the *declaration* is not the issue.  The scope of its *members* is.<br></p><p>Let’s consider an example:<br></p><p>private struct Foo {<br>    var bar: Int<br>}<br></p><p>// elsewhere in the same file:<br>var foo = Foo(bar: 42)<br>foo.bar = 44<br></p><p>`Foo` is declared private.  Private for this declaration is at the file scope.  The `bar` member has no access modifier so it has the same visibility as the struct itself, which is file scope.  This will also be true of the implicitly synthesized memberwise initializer.  <br></p><p>This means that it is possible to initialize `foo` with a newly constructed instance of `Foo` and to modify the `bar` member anywhere else in the same file.<br></p><p>If `bar` was also declared `private` this would not be possible as its visibility would be restricted to the surrounding scope of the initial declaration of `Foo`.  This means `Foo` would need to provide an explicit initializer or factory method with `fileprivate` visibility in order to be usable.<br></p><p>Members with no explicit access modifier should have the same *visibility* as their containing type (with a maximum implicit visibility of internal), not the same *modifier* as their containing type.  The only case where there is a distinction is the new `private` visibility.  Maybe that is what is causing the confusion?<br></p><p>Does this help?<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/06/15 11:36、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt; <br>&gt;&gt; The scope for a top-level declaration is the file itself.  This means that top-level declarations with `private` and `fileprivate` should have the same behavior.  They should not be uninstantiable or unusable.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 15, 2016, at 1:31 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal.  Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way.  Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused.  It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary.  Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 15, 2016 at 01:00:00pm</p></header><div class="content"><p>On Wed, Jun 15, 2016 at 1:47 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jun 15, 2016, at 1:37 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; The scope of the *declaration* is not the issue.  The scope of its<br>&gt; *members* is.<br>&gt;<br>&gt; Let’s consider an example:<br>&gt;<br>&gt; private struct Foo {<br>&gt;     var bar: Int<br>&gt; }<br>&gt;<br>&gt; // elsewhere in the same file:<br>&gt; var foo = Foo(bar: 42)<br>&gt; foo.bar = 44<br>&gt;<br>&gt; `Foo` is declared private.  Private for this declaration is at the file<br>&gt; scope.  The `bar` member has no access modifier so it has the same<br>&gt; visibility as the struct itself, which is file scope.  This will also be<br>&gt; true of the implicitly synthesized memberwise initializer.<br>&gt;<br>&gt; This means that it is possible to initialize `foo` with a newly<br>&gt; constructed instance of `Foo` and to modify the `bar` member anywhere else<br>&gt; in the same file.<br>&gt;<br>&gt; If `bar` was also declared `private` this would not be possible as its<br>&gt; visibility would be restricted to the surrounding scope of the initial<br>&gt; declaration of `Foo`.  This means `Foo` would need to provide an explicit<br>&gt; initializer or factory method with `fileprivate` visibility in order to be<br>&gt; usable.<br>&gt;<br>&gt; Members with no explicit access modifier should have the same *visibility*<br>&gt; as their containing type (with a maximum implicit visibility of internal),<br>&gt; not the same *modifier* as their containing type.  The only case where<br>&gt; there is a distinction is the new `private` visibility.  Maybe that is what<br>&gt; is causing the confusion?<br>&gt;<br>&gt; Does this help?<br>&gt;<br></p><p>Perhaps one solution is to prohibit top-level `private` declarations? If<br>they&#39;re required to be written as `fileprivate`, then the visibility and<br>the modifier used to express it are once again always in sync.<br></p><p><br>&gt;<br>&gt; -Matthew<br>&gt;<br>&gt; &gt;<br>&gt; &gt; ~Robert Widmann<br>&gt; &gt;<br>&gt; &gt; 2016/06/15 11:36、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt; &gt;<br>&gt; &gt;&gt; The scope for a top-level declaration is the file itself.  This means<br>&gt; that top-level declarations with `private` and `fileprivate` should have<br>&gt; the same behavior.  They should not be uninstantiable or unusable.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Matthew<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Jun 15, 2016, at 1:31 PM, Robert Widmann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug<br>&gt; in the proposal.  Under the implementation outlined there, any top-level<br>&gt; structure, class, or enum declared private cannot possibly be instantiated<br>&gt; and so cannot be used in any way.  Because of this, private top-level<br>&gt; declarations are more often than not blown away entirely by the compiler<br>&gt; for being unused.  It seems strange to me to allow a key language feature<br>&gt; to act solely as a hint to the optimizer to reduce the size of your<br>&gt; binary.  Perhaps the restrictions around private needs to be relaxed or the<br>&gt; line between fileprivate and private needs to be investigated again by the<br>&gt; community before inclusion in the language.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Thoughts?<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; ~Robert Widmann<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/0334de0e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 15, 2016 at 11:00:00am</p></header><div class="content"><p>Then it is no different from fileprivate.<br></p><p>~Robert Widmann<br></p><p>2016/06/15 11:47、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br></p><p>&gt; <br>&gt;&gt; On Jun 15, 2016, at 1:37 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The scope of the *declaration* is not the issue.  The scope of its *members* is.<br>&gt; <br>&gt; Let’s consider an example:<br>&gt; <br>&gt; private struct Foo {<br>&gt;    var bar: Int<br>&gt; }<br>&gt; <br>&gt; // elsewhere in the same file:<br>&gt; var foo = Foo(bar: 42)<br>&gt; foo.bar = 44<br>&gt; <br>&gt; `Foo` is declared private.  Private for this declaration is at the file scope.  The `bar` member has no access modifier so it has the same visibility as the struct itself, which is file scope.  This will also be true of the implicitly synthesized memberwise initializer.  <br>&gt; <br>&gt; This means that it is possible to initialize `foo` with a newly constructed instance of `Foo` and to modify the `bar` member anywhere else in the same file.<br>&gt; <br>&gt; If `bar` was also declared `private` this would not be possible as its visibility would be restricted to the surrounding scope of the initial declaration of `Foo`.  This means `Foo` would need to provide an explicit initializer or factory method with `fileprivate` visibility in order to be usable.<br>&gt; <br>&gt; Members with no explicit access modifier should have the same *visibility* as their containing type (with a maximum implicit visibility of internal), not the same *modifier* as their containing type.  The only case where there is a distinction is the new `private` visibility.  Maybe that is what is causing the confusion?<br>&gt; <br>&gt; Does this help?<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/06/15 11:36、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; The scope for a top-level declaration is the file itself.  This means that top-level declarations with `private` and `fileprivate` should have the same behavior.  They should not be uninstantiable or unusable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:31 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal.  Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way.  Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused.  It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary.  Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 15, 2016 at 02:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 15, 2016, at 1:51 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Then it is no different from fileprivate.<br></p><p>Yes, at file scope this is true.  A reasonable argument can be made for prohibiting it at file scope for the sake of clarity, but if it is allowed it should behave the same as fileprivate.<br></p><p>Note that similar issues apply for nests types:<br></p><p>struct S {<br>    private struct T { <br>        var foo: Int<br>    }<br>    // ok - T and foo are visible inside the scope of S<br>    private var t = T(foo: 42)<br>}<br></p><p>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/06/15 11:47、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 15, 2016, at 1:37 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The scope of the *declaration* is not the issue.  The scope of its *members* is.<br>&gt;&gt; <br>&gt;&gt; Let’s consider an example:<br>&gt;&gt; <br>&gt;&gt; private struct Foo {<br>&gt;&gt;   var bar: Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // elsewhere in the same file:<br>&gt;&gt; var foo = Foo(bar: 42)<br>&gt;&gt; foo.bar = 44<br>&gt;&gt; <br>&gt;&gt; `Foo` is declared private.  Private for this declaration is at the file scope.  The `bar` member has no access modifier so it has the same visibility as the struct itself, which is file scope.  This will also be true of the implicitly synthesized memberwise initializer.  <br>&gt;&gt; <br>&gt;&gt; This means that it is possible to initialize `foo` with a newly constructed instance of `Foo` and to modify the `bar` member anywhere else in the same file.<br>&gt;&gt; <br>&gt;&gt; If `bar` was also declared `private` this would not be possible as its visibility would be restricted to the surrounding scope of the initial declaration of `Foo`.  This means `Foo` would need to provide an explicit initializer or factory method with `fileprivate` visibility in order to be usable.<br>&gt;&gt; <br>&gt;&gt; Members with no explicit access modifier should have the same *visibility* as their containing type (with a maximum implicit visibility of internal), not the same *modifier* as their containing type.  The only case where there is a distinction is the new `private` visibility.  Maybe that is what is causing the confusion?<br>&gt;&gt; <br>&gt;&gt; Does this help?<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/06/15 11:36、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The scope for a top-level declaration is the file itself.  This means that top-level declarations with `private` and `fileprivate` should have the same behavior.  They should not be uninstantiable or unusable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:31 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal.  Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way.  Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused.  It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary.  Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 15, 2016 at 09:00:00pm</p></header><div class="content"><p>How about this, it might make more sense and relax the behavior a little:<br></p><p>// 1. file scope (Level 0)<br></p><p>// Level 0 because its declared at file scope<br>private struct A {<br>     <br>    /* implicit private */ init() {} // Level 1<br>}<br></p><p>// Level 0<br>struct B {<br>     <br>    // `A` is visible here and is seen as `fileprivate` because it is accessed<br>    // from a level &gt;= itself (imagine something like a &quot;scope level tree&quot;).  <br>    // also every member of `A` are interpreted as  <br>    // `fileprivate` and everyting is visible again as intended  <br>    var a: A = A()<br>}<br></p><p>// 2. file scope (Level 0)<br></p><p>struct C {<br>     <br>    // `A` is not visible here<br>    // `B` is visible because its `internal` by default<br>}<br>Does this makes sense to you?<br></p><p> ___________<br>| file Root |<br>|___________|<br>   |______________________<br> __|_________________   __|_________________________<br>| struct B (Level 0) | | private struct A (Level 0) |<br>|____________________| |____________________________|<br>   |                      |  <br> __|______________   _____|____________________<br>| var a (Level 1) | | private init() (Level 1) |<br>|_________________| |__________________________|<br></p><p>To check if `a` has visibility to `init` of `A` we need to compare the  <br>visibility level of `B` against `A`. If it is equal than `private` is  <br>handled as `fileprivate` which means that any other member from within  <br>the scope of `A` are also handled as `fileprivate`. We&#39;ve get the same result<br>if `B`s level is greater than `A`s. That means that we&#39;ll get back the  <br>visibility by relaxing `private` in some cases as `fileprivate`.<br>The described behavior is the same for private on higher levels, but we don’t describe it as fileprivate there (or can we do that?):<br></p><p>extension B {<br></p><p>   private func foo() {<br>     <br>        // `boo` should be visible here<br>    }<br>     <br>    private func boo() {<br>         <br>        // `foo` should be visible here<br>    }<br>}<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 15. Juni 2016 um 20:53:21, Robert Widmann via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>Then it is no different from fileprivate.<br></p><p>~Robert Widmann<br></p><p>2016/06/15 11:47、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br></p><p>&gt;  <br>&gt;&gt; On Jun 15, 2016, at 1:37 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;  <br>&gt;&gt; The scope of the *declaration* is not the issue. The scope of its *members* is.<br>&gt;  <br>&gt; Let’s consider an example:<br>&gt;  <br>&gt; private struct Foo {<br>&gt; var bar: Int<br>&gt; }<br>&gt;  <br>&gt; // elsewhere in the same file:<br>&gt; var foo = Foo(bar: 42)<br>&gt; foo.bar = 44<br>&gt;  <br>&gt; `Foo` is declared private. Private for this declaration is at the file scope. The `bar` member has no access modifier so it has the same visibility as the struct itself, which is file scope. This will also be true of the implicitly synthesized memberwise initializer.  <br>&gt;  <br>&gt; This means that it is possible to initialize `foo` with a newly constructed instance of `Foo` and to modify the `bar` member anywhere else in the same file.<br>&gt;  <br>&gt; If `bar` was also declared `private` this would not be possible as its visibility would be restricted to the surrounding scope of the initial declaration of `Foo`. This means `Foo` would need to provide an explicit initializer or factory method with `fileprivate` visibility in order to be usable.<br>&gt;  <br>&gt; Members with no explicit access modifier should have the same *visibility* as their containing type (with a maximum implicit visibility of internal), not the same *modifier* as their containing type. The only case where there is a distinction is the new `private` visibility. Maybe that is what is causing the confusion?<br>&gt;  <br>&gt; Does this help?<br>&gt;  <br>&gt; -Matthew<br>&gt;  <br>&gt;&gt;  <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt;  <br>&gt;&gt; 2016/06/15 11:36、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;  <br>&gt;&gt;&gt; The scope for a top-level declaration is the file itself. This means that top-level declarations with `private` and `fileprivate` should have the same behavior. They should not be uninstantiable or unusable.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:31 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal. Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way. Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused. It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary. Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;  <br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/5f3d1c00/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 15, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 15, 2016, at 2:25 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How about this, it might make more sense and relax the behavior a little:<br>&gt; <br>&gt; // 1. file scope (Level 0)<br>&gt; <br>&gt; // Level 0 because its declared at file scope<br>&gt; private struct A {<br>&gt;      <br>&gt;     /* implicit private */ init() {} // Level 1<br>&gt; }<br>&gt; <br>&gt; // Level 0<br>&gt; struct B {<br>&gt;      <br>&gt;     // `A` is visible here and is seen as `fileprivate` because it is accessed<br>&gt;     // from a level &gt;= itself (imagine something like a &quot;scope level tree&quot;).  <br>&gt;     // also every member of `A` are interpreted as  <br>&gt;     // `fileprivate` and everyting is visible again as intended  <br>&gt;     var a: A = A()<br>&gt; }<br>&gt; <br>&gt; // 2. file scope (Level 0)<br>&gt; <br>&gt; struct C {<br>&gt;      <br>&gt;     // `A` is not visible here<br>&gt;     // `B` is visible because its `internal` by default<br>&gt; }<br>&gt; Does this makes sense to you?<br>&gt; <br>&gt; <br></p><p>This does not make sense to me at all.  In order for this to be consistent with the rest of our access control rules `init` in #1 has the same visibility as `A`.  That is why it is visible inside `B`.  <br></p><p>Your example #2 is just incorrect.  `A` is visible inside the scope of `C`.<br></p><p>Now that we have introduced a scope-dependent access modifier it is an incorrect mental model to consider members with no access modifier as having the exact same access modifier as the containing scope.  This is no longer correct.  They have the same *visibility*, not the same *access modifier*.<br></p><p>&gt;  ___________<br>&gt; | file Root |<br>&gt; |___________|<br>&gt;    |______________________<br>&gt;  __|_________________   __|_________________________<br>&gt; | struct B (Level 0) | | private struct A (Level 0) |<br>&gt; |____________________| |____________________________|<br>&gt;    |                      |  <br>&gt;  __|______________   _____|____________________<br>&gt; | var a (Level 1) | | private init() (Level 1) |<br>&gt; |_________________| |__________________________|<br>&gt; <br>&gt; To check if `a` has visibility to `init` of `A` we need to compare the  <br>&gt; visibility level of `B` against `A`. If it is equal than `private` is  <br>&gt; handled as `fileprivate` which means that any other member from within  <br>&gt; the scope of `A` are also handled as `fileprivate`. We&#39;ve get the same result<br>&gt; if `B`s level is greater than `A`s. That means that we&#39;ll get back the  <br>&gt; visibility by relaxing `private` in some cases as `fileprivate`.<br>&gt; The described behavior is the same for private on higher levels, but we don’t describe it as fileprivate there (or can we do that?):<br>&gt; <br>&gt; extension B {<br>&gt; <br>&gt;    private func foo() {<br>&gt;      <br>&gt;         // `boo` should be visible here<br>&gt;     }<br>&gt;      <br>&gt;     private func boo() {<br>&gt;          <br>&gt;         // `foo` should be visible here<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 15. Juni 2016 um 20:53:21, Robert Widmann via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt; <br>&gt;&gt; Then it is no different from fileprivate.<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/06/15 11:47、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt; &gt; <br>&gt;&gt; &gt;&gt; On Jun 15, 2016, at 1:37 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; The scope of the *declaration* is not the issue. The scope of its *members* is.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Let’s consider an example:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; private struct Foo {<br>&gt;&gt; &gt; var bar: Int<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; // elsewhere in the same file:<br>&gt;&gt; &gt; var foo = Foo(bar: 42)<br>&gt;&gt; &gt; foo.bar = 44<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; `Foo` is declared private. Private for this declaration is at the file scope. The `bar` member has no access modifier so it has the same visibility as the struct itself, which is file scope. This will also be true of the implicitly synthesized memberwise initializer.  <br>&gt;&gt; &gt; <br>&gt;&gt; &gt; This means that it is possible to initialize `foo` with a newly constructed instance of `Foo` and to modify the `bar` member anywhere else in the same file.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; If `bar` was also declared `private` this would not be possible as its visibility would be restricted to the surrounding scope of the initial declaration of `Foo`. This means `Foo` would need to provide an explicit initializer or factory method with `fileprivate` visibility in order to be usable.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Members with no explicit access modifier should have the same *visibility* as their containing type (with a maximum implicit visibility of internal), not the same *modifier* as their containing type. The only case where there is a distinction is the new `private` visibility. Maybe that is what is causing the confusion?<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Does this help?<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; -Matthew<br>&gt;&gt; &gt; <br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; ~Robert Widmann<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; 2016/06/15 11:36、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt;&gt; The scope for a top-level declaration is the file itself. This means that top-level declarations with `private` and `fileprivate` should have the same behavior. They should not be uninstantiable or unusable.<br>&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt; &gt;&gt;&gt; -Matthew<br>&gt;&gt; &gt;&gt;&gt; <br>&gt;&gt; &gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:31 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt; <br>&gt;&gt; &gt;&gt;&gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal. Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way. Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused. It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary. Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt;&gt; &gt;&gt;&gt;&gt; <br>&gt;&gt; &gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt; &gt;&gt;&gt;&gt; <br>&gt;&gt; &gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/0082d293/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 15, 2016 at 12:00:00pm</p></header><div class="content"><p>2016/06/15 11:47、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br></p><p>&gt; <br>&gt;&gt; On Jun 15, 2016, at 1:37 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The scope of the *declaration* is not the issue.  The scope of its *members* is.<br>&gt; <br>&gt; Let’s consider an example:<br>&gt; <br>&gt; private struct Foo {<br>&gt;    var bar: Int<br>&gt; }<br>&gt; <br>&gt; // elsewhere in the same file:<br>&gt; var foo = Foo(bar: 42)<br>&gt; foo.bar = 44<br>&gt; <br>&gt; `Foo` is declared private.  Private for this declaration is at the file scope.  The `bar` member has no access modifier so it has the same visibility as the struct itself, which is file scope.  This will also be true of the implicitly synthesized memberwise initializer.  <br></p><p>No, it is also private.  It does not inherit its parent scope because, following the letter of the proposal, that symbol will only be visible within the current declaration.  We cannot arbitrarily break access control rules because it is convenient in one special case. <br></p><p>&gt; <br>&gt; This means that it is possible to initialize `foo` with a newly constructed instance of `Foo` and to modify the `bar` member anywhere else in the same file.<br></p><p>bar is not visible here.  If it were you could break access control rules.<br></p><p>&gt; <br>&gt; If `bar` was also declared `private` this would not be possible as its visibility would be restricted to the surrounding scope of the initial declaration of `Foo`.  This means `Foo` would need to provide an explicit initializer or factory method with `fileprivate` visibility in order to be usable.<br></p><p>bar is private.  Declarations within Foo cannot decide to raise that access level to make themselves more visible.  If this should be the case, the proposal must be amended as much.<br></p><p>&gt; <br>&gt; Members with no explicit access modifier should have the same *visibility* as their containing type (with a maximum implicit visibility of internal), not the same *modifier* as their containing type.  The only case where there is a distinction is the new `private` visibility.  Maybe that is what is causing the confusion?<br></p><p>That is not what the proposal says.  The proposal says it is invisible outside the current decl, which is the containing structure here.<br></p><p>&gt; <br>&gt; Does this help?<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/06/15 11:36、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; The scope for a top-level declaration is the file itself.  This means that top-level declarations with `private` and `fileprivate` should have the same behavior.  They should not be uninstantiable or unusable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:31 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal.  Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way.  Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused.  It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary.  Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 15, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 15, 2016, at 2:04 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; 2016/06/15 11:47、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 15, 2016, at 1:37 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The scope of the *declaration* is not the issue.  The scope of its *members* is.<br>&gt;&gt; <br>&gt;&gt; Let’s consider an example:<br>&gt;&gt; <br>&gt;&gt; private struct Foo {<br>&gt;&gt;   var bar: Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // elsewhere in the same file:<br>&gt;&gt; var foo = Foo(bar: 42)<br>&gt;&gt; foo.bar = 44<br>&gt;&gt; <br>&gt;&gt; `Foo` is declared private.  Private for this declaration is at the file scope.  The `bar` member has no access modifier so it has the same visibility as the struct itself, which is file scope.  This will also be true of the implicitly synthesized memberwise initializer.  <br>&gt; <br>&gt; No, it is also private.  It does not inherit its parent scope because, following the letter of the proposal, that symbol will only be visible within the current declaration.  We cannot arbitrarily break access control rules because it is convenient in one special case. <br>&gt; <br>&gt;&gt; <br>&gt;&gt; This means that it is possible to initialize `foo` with a newly constructed instance of `Foo` and to modify the `bar` member anywhere else in the same file.<br>&gt; <br>&gt; bar is not visible here.  If it were you could break access control rules.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; If `bar` was also declared `private` this would not be possible as its visibility would be restricted to the surrounding scope of the initial declaration of `Foo`.  This means `Foo` would need to provide an explicit initializer or factory method with `fileprivate` visibility in order to be usable.<br>&gt; <br>&gt; bar is private.  Declarations within Foo cannot decide to raise that access level to make themselves more visible.  If this should be the case, the proposal must be amended as much.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Members with no explicit access modifier should have the same *visibility* as their containing type (with a maximum implicit visibility of internal), not the same *modifier* as their containing type.  The only case where there is a distinction is the new `private` visibility.  Maybe that is what is causing the confusion?<br>&gt; <br>&gt; That is not what the proposal says.  The proposal says it is invisible outside the current decl, which is the containing structure here.<br></p><p>The access modifier is applied to `Foo`, not `bar`.  `Foo` is visible in the scope of the “current declaration” (this is badly worded - it should say current scope, which is the file).  Because `Foo` has a visibility lower than `internal` the default visibility of its members match the visibility of `Foo`, which again is the current scope: the file.  The detailed design section of the proposal is sparse, but it correctly uses the phrase &quot;visible only within that lexical scope” rather than the less precise (in the case of top-level code) “current declaration”.<br></p><p>I didn’t write the proposal but I was very heavily involved in the discussions and IIRC I provided the original suggestion for introducing a scoped access modifier.<br></p><p>If my example was the following:<br></p><p>private struct Foo {<br>  private var bar: Int<br>}<br></p><p>Then what you are saying would be correct.  However, The example I showed did not provide an access modifier for `bar`.<br></p><p>You cannot just apply the same *access modifier* to members of the type that do not contain an access modifier.  You have to apply the same *visibility* (limited to internal).  When a type is marked as `private` in the lexical scope of the file, its unmodified members will be visible in the same lexical scope as the type itself (which is the file in the current example).<br></p><p>-Matthew<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; Does this help?<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/06/15 11:36、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The scope for a top-level declaration is the file itself.  This means that top-level declarations with `private` and `fileprivate` should have the same behavior.  They should not be uninstantiable or unusable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:31 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal.  Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way.  Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused.  It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary.  Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/24e0d799/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 15, 2016 at 12:00:00pm</p></header><div class="content"><p>We have diagnostics specifically to prohibit this case.  You cannot raise the access level of members.<br></p><p>private struct Foo {<br>    internal var x : String = &quot;&quot;<br>}<br></p><p>warning: declaring an internal var for a private struct.<br></p><p>Hence, the highest allowable level of access for x is private and it becomes invisible.<br></p><p>I would not like the compiler to synthesize this in my code, and if it did I would like the proposal to say it will raise access levels of members as you would like it to.<br></p><p>~Robert Widmann<br></p><p>2016/06/15 12:14、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br></p><p>&gt; <br>&gt;&gt; On Jun 15, 2016, at 2:04 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 2016/06/15 11:47、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:37 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The scope of the *declaration* is not the issue.  The scope of its *members* is.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let’s consider an example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;   var bar: Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // elsewhere in the same file:<br>&gt;&gt;&gt; var foo = Foo(bar: 42)<br>&gt;&gt;&gt; foo.bar = 44<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `Foo` is declared private.  Private for this declaration is at the file scope.  The `bar` member has no access modifier so it has the same visibility as the struct itself, which is file scope.  This will also be true of the implicitly synthesized memberwise initializer.  <br>&gt;&gt; <br>&gt;&gt; No, it is also private.  It does not inherit its parent scope because, following the letter of the proposal, that symbol will only be visible within the current declaration.  We cannot arbitrarily break access control rules because it is convenient in one special case. <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This means that it is possible to initialize `foo` with a newly constructed instance of `Foo` and to modify the `bar` member anywhere else in the same file.<br>&gt;&gt; <br>&gt;&gt; bar is not visible here.  If it were you could break access control rules.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If `bar` was also declared `private` this would not be possible as its visibility would be restricted to the surrounding scope of the initial declaration of `Foo`.  This means `Foo` would need to provide an explicit initializer or factory method with `fileprivate` visibility in order to be usable.<br>&gt;&gt; <br>&gt;&gt; bar is private.  Declarations within Foo cannot decide to raise that access level to make themselves more visible.  If this should be the case, the proposal must be amended as much.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Members with no explicit access modifier should have the same *visibility* as their containing type (with a maximum implicit visibility of internal), not the same *modifier* as their containing type.  The only case where there is a distinction is the new `private` visibility.  Maybe that is what is causing the confusion?<br>&gt;&gt; <br>&gt;&gt; That is not what the proposal says.  The proposal says it is invisible outside the current decl, which is the containing structure here.<br>&gt; <br>&gt; The access modifier is applied to `Foo`, not `bar`.  `Foo` is visible in the scope of the “current declaration” (this is badly worded - it should say current scope, which is the file).  Because `Foo` has a visibility lower than `internal` the default visibility of its members match the visibility of `Foo`, which again is the current scope: the file.  The detailed design section of the proposal is sparse, but it correctly uses the phrase &quot;visible only within that lexical scope” rather than the less precise (in the case of top-level code) “current declaration”.<br>&gt; <br>&gt; I didn’t write the proposal but I was very heavily involved in the discussions and IIRC I provided the original suggestion for introducing a scoped access modifier.<br>&gt; <br>&gt; If my example was the following:<br>&gt; <br>&gt; private struct Foo {<br>&gt;   private var bar: Int<br>&gt; }<br>&gt; <br>&gt; Then what you are saying would be correct.  However, The example I showed did not provide an access modifier for `bar`.<br>&gt; <br>&gt; You cannot just apply the same *access modifier* to members of the type that do not contain an access modifier.  You have to apply the same *visibility* (limited to internal).  When a type is marked as `private` in the lexical scope of the file, its unmodified members will be visible in the same lexical scope as the type itself (which is the file in the current example).<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Does this help?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/06/15 11:36、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The scope for a top-level declaration is the file itself.  This means that top-level declarations with `private` and `fileprivate` should have the same behavior.  They should not be uninstantiable or unusable.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:31 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal.  Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way.  Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused.  It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary.  Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/dd745f57/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 15, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 15, 2016, at 2:19 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; We have diagnostics specifically to prohibit this case.  You cannot raise the access level of members.<br>&gt; <br>&gt; private struct Foo {<br>&gt;     internal var x : String = &quot;&quot;<br>&gt; }<br>&gt; <br>&gt; warning: declaring an internal var for a private struct.<br>&gt; <br>&gt; Hence, the highest allowable level of access for x is private and it becomes invisible.<br>&gt; <br>&gt; I would not like the compiler to synthesize this in my code, and if it did I would like the proposal to say it will raise access levels of members as you would like it to.<br></p><p>That diagnostic is a good thing.  I am not suggesting that you to disregard it.<br></p><p>What you are missing is that the meaning of `private` is scope-dependent.  The following example is perfectly valid:<br></p><p>private struct Foo {<br>    fileprivate var x : String = “”<br>}<br></p><p>`fileprivate` inside `Foo` specifies the same visibility as `private` at the top level, thus we are not “raising&quot; the visibility of the member.  If no modifier is provided for `x` it receives the same visibility as its containing type (up to `internal`).<br></p><p>Consider another example:<br></p><p>struct Foo {<br>    private struct Bar {<br>        var x : String = “”<br>    }<br>}<br></p><p>In this example we *cannot* mark `x` as `fileprivate` because that *would* raise the visibility of `x` beyond that of `Bar`.  `Bar` is only visible inside `Foo`, not at file scope.  This means that `x` also has visibility throughout the lexical scope of `Foo`, but not outside of it.<br></p><p>-Matthew<br></p><p><br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/06/15 12:14、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 15, 2016, at 2:04 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/06/15 11:47、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:37 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The scope of the *declaration* is not the issue.  The scope of its *members* is.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let’s consider an example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;   var bar: Int<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // elsewhere in the same file:<br>&gt;&gt;&gt;&gt; var foo = Foo(bar: 42)<br>&gt;&gt;&gt;&gt; foo.bar = 44<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `Foo` is declared private.  Private for this declaration is at the file scope.  The `bar` member has no access modifier so it has the same visibility as the struct itself, which is file scope.  This will also be true of the implicitly synthesized memberwise initializer.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, it is also private.  It does not inherit its parent scope because, following the letter of the proposal, that symbol will only be visible within the current declaration.  We cannot arbitrarily break access control rules because it is convenient in one special case. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This means that it is possible to initialize `foo` with a newly constructed instance of `Foo` and to modify the `bar` member anywhere else in the same file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; bar is not visible here.  If it were you could break access control rules.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If `bar` was also declared `private` this would not be possible as its visibility would be restricted to the surrounding scope of the initial declaration of `Foo`.  This means `Foo` would need to provide an explicit initializer or factory method with `fileprivate` visibility in order to be usable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; bar is private.  Declarations within Foo cannot decide to raise that access level to make themselves more visible.  If this should be the case, the proposal must be amended as much.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Members with no explicit access modifier should have the same *visibility* as their containing type (with a maximum implicit visibility of internal), not the same *modifier* as their containing type.  The only case where there is a distinction is the new `private` visibility.  Maybe that is what is causing the confusion?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is not what the proposal says.  The proposal says it is invisible outside the current decl, which is the containing structure here.<br>&gt;&gt; <br>&gt;&gt; The access modifier is applied to `Foo`, not `bar`.  `Foo` is visible in the scope of the “current declaration” (this is badly worded - it should say current scope, which is the file).  Because `Foo` has a visibility lower than `internal` the default visibility of its members match the visibility of `Foo`, which again is the current scope: the file.  The detailed design section of the proposal is sparse, but it correctly uses the phrase &quot;visible only within that lexical scope” rather than the less precise (in the case of top-level code) “current declaration”.<br>&gt;&gt; <br>&gt;&gt; I didn’t write the proposal but I was very heavily involved in the discussions and IIRC I provided the original suggestion for introducing a scoped access modifier.<br>&gt;&gt; <br>&gt;&gt; If my example was the following:<br>&gt;&gt; <br>&gt;&gt; private struct Foo {<br>&gt;&gt;   private var bar: Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Then what you are saying would be correct.  However, The example I showed did not provide an access modifier for `bar`.<br>&gt;&gt; <br>&gt;&gt; You cannot just apply the same *access modifier* to members of the type that do not contain an access modifier.  You have to apply the same *visibility* (limited to internal).  When a type is marked as `private` in the lexical scope of the file, its unmodified members will be visible in the same lexical scope as the type itself (which is the file in the current example).<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Does this help?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2016/06/15 11:36、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The scope for a top-level declaration is the file itself.  This means that top-level declarations with `private` and `fileprivate` should have the same behavior.  They should not be uninstantiable or unusable.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:31 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal.  Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way.  Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused.  It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary.  Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/5962b5cf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 15, 2016 at 12:00:00pm</p></header><div class="content"><p>The meaning of private according to the proposal is not scope-dependent, it is decl-dependent.  The mental gymnastics we are both going through right now are not in the proposal.  I would like them to be.<br></p><p>~Robert Widmann<br></p><p>2016/06/15 12:26、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br></p><p>&gt; <br>&gt;&gt; On Jun 15, 2016, at 2:19 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; We have diagnostics specifically to prohibit this case.  You cannot raise the access level of members.<br>&gt;&gt; <br>&gt;&gt; private struct Foo {<br>&gt;&gt;     internal var x : String = &quot;&quot;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; warning: declaring an internal var for a private struct.<br>&gt;&gt; <br>&gt;&gt; Hence, the highest allowable level of access for x is private and it becomes invisible.<br>&gt;&gt; <br>&gt;&gt; I would not like the compiler to synthesize this in my code, and if it did I would like the proposal to say it will raise access levels of members as you would like it to.<br>&gt; <br>&gt; That diagnostic is a good thing.  I am not suggesting that you to disregard it.<br>&gt; <br>&gt; What you are missing is that the meaning of `private` is scope-dependent.  The following example is perfectly valid:<br>&gt; <br>&gt; private struct Foo {<br>&gt;     fileprivate var x : String = “”<br>&gt; }<br>&gt; <br>&gt; `fileprivate` inside `Foo` specifies the same visibility as `private` at the top level, thus we are not “raising&quot; the visibility of the member.  If no modifier is provided for `x` it receives the same visibility as its containing type (up to `internal`).<br>&gt; <br>&gt; Consider another example:<br>&gt; <br>&gt; struct Foo {<br>&gt;     private struct Bar {<br>&gt;         var x : String = “”<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; In this example we *cannot* mark `x` as `fileprivate` because that *would* raise the visibility of `x` beyond that of `Bar`.  `Bar` is only visible inside `Foo`, not at file scope.  This means that `x` also has visibility throughout the lexical scope of `Foo`, but not outside of it.<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/06/15 12:14、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:04 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/06/15 11:47、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:37 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The scope of the *declaration* is not the issue.  The scope of its *members* is.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Let’s consider an example:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;   var bar: Int<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // elsewhere in the same file:<br>&gt;&gt;&gt;&gt;&gt; var foo = Foo(bar: 42)<br>&gt;&gt;&gt;&gt;&gt; foo.bar = 44<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; `Foo` is declared private.  Private for this declaration is at the file scope.  The `bar` member has no access modifier so it has the same visibility as the struct itself, which is file scope.  This will also be true of the implicitly synthesized memberwise initializer.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No, it is also private.  It does not inherit its parent scope because, following the letter of the proposal, that symbol will only be visible within the current declaration.  We cannot arbitrarily break access control rules because it is convenient in one special case. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This means that it is possible to initialize `foo` with a newly constructed instance of `Foo` and to modify the `bar` member anywhere else in the same file.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; bar is not visible here.  If it were you could break access control rules.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If `bar` was also declared `private` this would not be possible as its visibility would be restricted to the surrounding scope of the initial declaration of `Foo`.  This means `Foo` would need to provide an explicit initializer or factory method with `fileprivate` visibility in order to be usable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; bar is private.  Declarations within Foo cannot decide to raise that access level to make themselves more visible.  If this should be the case, the proposal must be amended as much.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Members with no explicit access modifier should have the same *visibility* as their containing type (with a maximum implicit visibility of internal), not the same *modifier* as their containing type.  The only case where there is a distinction is the new `private` visibility.  Maybe that is what is causing the confusion?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That is not what the proposal says.  The proposal says it is invisible outside the current decl, which is the containing structure here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The access modifier is applied to `Foo`, not `bar`.  `Foo` is visible in the scope of the “current declaration” (this is badly worded - it should say current scope, which is the file).  Because `Foo` has a visibility lower than `internal` the default visibility of its members match the visibility of `Foo`, which again is the current scope: the file.  The detailed design section of the proposal is sparse, but it correctly uses the phrase &quot;visible only within that lexical scope” rather than the less precise (in the case of top-level code) “current declaration”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I didn’t write the proposal but I was very heavily involved in the discussions and IIRC I provided the original suggestion for introducing a scoped access modifier.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If my example was the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;   private var bar: Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then what you are saying would be correct.  However, The example I showed did not provide an access modifier for `bar`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You cannot just apply the same *access modifier* to members of the type that do not contain an access modifier.  You have to apply the same *visibility* (limited to internal).  When a type is marked as `private` in the lexical scope of the file, its unmodified members will be visible in the same lexical scope as the type itself (which is the file in the current example).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Does this help?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 11:36、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The scope for a top-level declaration is the file itself.  This means that top-level declarations with `private` and `fileprivate` should have the same behavior.  They should not be uninstantiable or unusable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:31 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal.  Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way.  Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused.  It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary.  Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/d7754d1b/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 15, 2016 at 09:00:00pm</p></header><div class="content"><p>Ok I already see side effects in my idea which breaks the entire scoped access level thing :/<br></p><p>class A {<br>   // incrementTwice() is not visible here<br>}<br></p><p>extension A {<br>   private func incrementTwice() {<br></p><p>   }<br>}<br>In my model incrementTwice would be visible in A which it shouldn’t (I agree to that).<br></p><p>That seem like a nasty bug that we missed during review.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 15. Juni 2016 um 21:30:20, Robert Widmann via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>The meaning of private according to the proposal is not scope-dependent, it is decl-dependent.  The mental gymnastics we are both going through right now are not in the proposal.  I would like them to be.<br></p><p>~Robert Widmann<br></p><p>2016/06/15 12:26、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br></p><p><br>On Jun 15, 2016, at 2:19 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br></p><p>We have diagnostics specifically to prohibit this case.  You cannot raise the access level of members.<br></p><p>private struct Foo {<br>    internal var x : String = &quot;&quot;<br>}<br></p><p>warning: declaring an internal var for a private struct.<br></p><p>Hence, the highest allowable level of access for x is private and it becomes invisible.<br></p><p>I would not like the compiler to synthesize this in my code, and if it did I would like the proposal to say it will raise access levels of members as you would like it to.<br></p><p>That diagnostic is a good thing.  I am not suggesting that you to disregard it.<br></p><p>What you are missing is that the meaning of `private` is scope-dependent.  The following example is perfectly valid:<br></p><p>private struct Foo {<br>    fileprivate var x : String = “”<br>}<br></p><p>`fileprivate` inside `Foo` specifies the same visibility as `private` at the top level, thus we are not “raising&quot; the visibility of the member.  If no modifier is provided for `x` it receives the same visibility as its containing type (up to `internal`).<br></p><p>Consider another example:<br></p><p>struct Foo {<br>    private struct Bar {<br>        var x : String = “”<br>    }<br>}<br></p><p>In this example we *cannot* mark `x` as `fileprivate` because that *would* raise the visibility of `x` beyond that of `Bar`.  `Bar` is only visible inside `Foo`, not at file scope.  This means that `x` also has visibility throughout the lexical scope of `Foo`, but not outside of it.<br></p><p>-Matthew<br></p><p><br></p><p>~Robert Widmann<br></p><p>2016/06/15 12:14、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br></p><p><br>On Jun 15, 2016, at 2:04 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br></p><p><br></p><p>2016/06/15 11:47、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br></p><p><br>On Jun 15, 2016, at 1:37 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br></p><p>The scope of the *declaration* is not the issue.  The scope of its *members* is.<br></p><p>Let’s consider an example:<br></p><p>private struct Foo {<br>  var bar: Int<br>}<br></p><p>// elsewhere in the same file:<br>var foo = Foo(bar: 42)<br>foo.bar = 44<br></p><p>`Foo` is declared private.  Private for this declaration is at the file scope.  The `bar` member has no access modifier so it has the same visibility as the struct itself, which is file scope.  This will also be true of the implicitly synthesized memberwise initializer.  <br></p><p>No, it is also private.  It does not inherit its parent scope because, following the letter of the proposal, that symbol will only be visible within the current declaration.  We cannot arbitrarily break access control rules because it is convenient in one special case. <br></p><p><br>This means that it is possible to initialize `foo` with a newly constructed instance of `Foo` and to modify the `bar` member anywhere else in the same file.<br></p><p>bar is not visible here.  If it were you could break access control rules.<br></p><p><br>If `bar` was also declared `private` this would not be possible as its visibility would be restricted to the surrounding scope of the initial declaration of `Foo`.  This means `Foo` would need to provide an explicit initializer or factory method with `fileprivate` visibility in order to be usable.<br></p><p>bar is private.  Declarations within Foo cannot decide to raise that access level to make themselves more visible.  If this should be the case, the proposal must be amended as much.<br></p><p><br>Members with no explicit access modifier should have the same *visibility* as their containing type (with a maximum implicit visibility of internal), not the same *modifier* as their containing type.  The only case where there is a distinction is the new `private` visibility.  Maybe that is what is causing the confusion?<br></p><p>That is not what the proposal says.  The proposal says it is invisible outside the current decl, which is the containing structure here.<br></p><p>The access modifier is applied to `Foo`, not `bar`.  `Foo` is visible in the scope of the “current declaration” (this is badly worded - it should say current scope, which is the file).  Because `Foo` has a visibility lower than `internal` the default visibility of its members match the visibility of `Foo`, which again is the current scope: the file.  The detailed design section of the proposal is sparse, but it correctly uses the phrase &quot;visible only within that lexical scope” rather than the less precise (in the case of top-level code) “current declaration”.<br></p><p>I didn’t write the proposal but I was very heavily involved in the discussions and IIRC I provided the original suggestion for introducing a scoped access modifier.<br></p><p>If my example was the following:<br></p><p>private struct Foo {<br>  private var bar: Int<br>}<br></p><p>Then what you are saying would be correct.  However, The example I showed did not provide an access modifier for `bar`.<br></p><p>You cannot just apply the same *access modifier* to members of the type that do not contain an access modifier.  You have to apply the same *visibility* (limited to internal).  When a type is marked as `private` in the lexical scope of the file, its unmodified members will be visible in the same lexical scope as the type itself (which is the file in the current example).<br></p><p>-Matthew<br></p><p><br></p><p>Does this help?<br></p><p>-Matthew<br></p><p><br>~Robert Widmann<br></p><p>2016/06/15 11:36、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br></p><p>The scope for a top-level declaration is the file itself.  This means that top-level declarations with `private` and `fileprivate` should have the same behavior.  They should not be uninstantiable or unusable.<br></p><p>-Matthew<br></p><p>On Jun 15, 2016, at 1:31 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal.  Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way.  Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused.  It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary.  Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br></p><p>Thoughts?<br></p><p>~Robert Widmann<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/8278ff36/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 15, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 15, 2016, at 2:34 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Ok I already see side effects in my idea which breaks the entire scoped access level thing :/<br>&gt; <br>&gt; class A {<br>&gt;    // incrementTwice() is not visible here<br>&gt; }<br>&gt; <br>&gt; extension A {<br>&gt;    private func incrementTwice() {<br>&gt; <br>&gt;    }<br>&gt; }<br>&gt; In my model incrementTwice would be visible in A which it shouldn’t (I agree to that).<br>&gt; <br>&gt; That seem like a nasty bug that we missed during review.<br>&gt; <br>&gt; <br></p><p>You are correct that `incrementTwice` is not visible inside `class A`.<br></p><p>What seems like a nasty bug missed during review?  I don’t follow you there.<br></p><p>This proposal was specifically designed to follow Swift’s design of a scope-based access control mechanism rather than a type-based access control mechanism that is common in other languages.<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 15. Juni 2016 um 21:30:20, Robert Widmann via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt; <br>&gt;&gt; The meaning of private according to the proposal is not scope-dependent, it is decl-dependent.  The mental gymnastics we are both going through right now are not in the proposal.  I would like them to be.<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/06/15 12:26、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:19 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We have diagnostics specifically to prohibit this case.  You cannot raise the access level of members.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;     internal var x : String = &quot;&quot;<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; warning: declaring an internal var for a private struct.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hence, the highest allowable level of access for x is private and it becomes invisible.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would not like the compiler to synthesize this in my code, and if it did I would like the proposal to say it will raise access levels of members as you would like it to.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That diagnostic is a good thing.  I am not suggesting that you to disregard it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What you are missing is that the meaning of `private` is scope-dependent.  The following example is perfectly valid:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;     fileprivate var x : String = “”<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `fileprivate` inside `Foo` specifies the same visibility as `private` at the top level, thus we are not “raising&quot; the visibility of the member.  If no modifier is provided for `x` it receives the same visibility as its containing type (up to `internal`).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider another example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;     private struct Bar {<br>&gt;&gt;&gt;         var x : String = “”<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this example we *cannot* mark `x` as `fileprivate` because that *would* raise the visibility of `x` beyond that of `Bar`.  `Bar` is only visible inside `Foo`, not at file scope.  This means that `x` also has visibility throughout the lexical scope of `Foo`, but not outside of it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/06/15 12:14、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:04 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 11:47、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:37 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The scope of the *declaration* is not the issue.  The scope of its *members* is.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Let’s consider an example:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   var bar: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // elsewhere in the same file:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var foo = Foo(bar: 42)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; foo.bar = 44<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; `Foo` is declared private.  Private for this declaration is at the file scope.  The `bar` member has no access modifier so it has the same visibility as the struct itself, which is file scope.  This will also be true of the implicitly synthesized memberwise initializer.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; No, it is also private.  It does not inherit its parent scope because, following the letter of the proposal, that symbol will only be visible within the current declaration.  We cannot arbitrarily break access control rules because it is convenient in one special case. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This means that it is possible to initialize `foo` with a newly constructed instance of `Foo` and to modify the `bar` member anywhere else in the same file.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; bar is not visible here.  If it were you could break access control rules.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If `bar` was also declared `private` this would not be possible as its visibility would be restricted to the surrounding scope of the initial declaration of `Foo`.  This means `Foo` would need to provide an explicit initializer or factory method with `fileprivate` visibility in order to be usable.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; bar is private.  Declarations within Foo cannot decide to raise that access level to make themselves more visible.  If this should be the case, the proposal must be amended as much.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Members with no explicit access modifier should have the same *visibility* as their containing type (with a maximum implicit visibility of internal), not the same *modifier* as their containing type.  The only case where there is a distinction is the new `private` visibility.  Maybe that is what is causing the confusion?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That is not what the proposal says.  The proposal says it is invisible outside the current decl, which is the containing structure here.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The access modifier is applied to `Foo`, not `bar`.  `Foo` is visible in the scope of the “current declaration” (this is badly worded - it should say current scope, which is the file).  Because `Foo` has a visibility lower than `internal` the default visibility of its members match the visibility of `Foo`, which again is the current scope: the file.  The detailed design section of the proposal is sparse, but it correctly uses the phrase &quot;visible only within that lexical scope” rather than the less precise (in the case of top-level code) “current declaration”.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I didn’t write the proposal but I was very heavily involved in the discussions and IIRC I provided the original suggestion for introducing a scoped access modifier.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If my example was the following:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;   private var bar: Int<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Then what you are saying would be correct.  However, The example I showed did not provide an access modifier for `bar`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You cannot just apply the same *access modifier* to members of the type that do not contain an access modifier.  You have to apply the same *visibility* (limited to internal).  When a type is marked as `private` in the lexical scope of the file, its unmodified members will be visible in the same lexical scope as the type itself (which is the file in the current example).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Does this help?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 11:36、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The scope for a top-level declaration is the file itself.  This means that top-level declarations with `private` and `fileprivate` should have the same behavior.  They should not be uninstantiable or unusable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:31 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal.  Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way.  Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused.  It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary.  Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/0e37e94f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 15, 2016 at 09:00:00pm</p></header><div class="content"><p>I was referencing to the issue Robert discovered in his implementation.<br></p><p>I do understand what the proposal is all about, but thank you for re-clarifying that to me. :)<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 15. Juni 2016 um 21:40:37, Matthew Johnson (matthew at anandabits.com) schrieb:<br></p><p>What seems like a nasty bug missed during review?  I don’t follow you there.<br></p><p>This proposal was specifically designed to follow Swift’s design of a scope-based access control mechanism rather than a type-based access control mechanism that is common in other languages.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/dfafa0f5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 15, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 15, 2016, at 2:46 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I was referencing to the issue Robert discovered in his implementation. <br>&gt; <br>&gt; I do understand what the proposal is all about, but thank you for re-clarifying that to me. :)<br>&gt; <br>&gt; <br></p><p>I don’t think it’s a bug, but it is definitely something that isn’t as clear as it should have been.<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 15. Juni 2016 um 21:40:37, Matthew Johnson (matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;) schrieb:<br>&gt; <br>&gt;&gt; What seems like a nasty bug missed during review?  I don’t follow you there.<br>&gt;&gt; <br>&gt;&gt; This proposal was specifically designed to follow Swift’s design of a scope-based access control mechanism rather than a type-based access control mechanism that is common in other languages.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/ce798dd8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 15, 2016 at 09:00:00pm</p></header><div class="content"><p>Its my bad habit describing everything as a ‘bug’. Don’t judge me for that. I fully agree with you about the whole issue.<br></p><p>You probably missed // 2. file scope (Level 0), but it’s okay. So my second example was indeed correct. I described ‘levels’ starting from zero for each individual file, because it wouldn’t matter in my (wrong) private vs. fileprivate model.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/bdd4a389/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 15, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 15, 2016, at 2:53 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Its my bad habit describing everything as a ‘bug’. Don’t judge me for that. I fully agree with you about the whole issue.<br>&gt; <br>&gt; <br>No problem. :)<br>&gt; You probably missed // 2. file scope (Level 0), but it’s okay. So my second example was indeed correct. I described ‘levels’ starting from zero for each individual file, because it wouldn’t matter in my (wrong) private vs. fileprivate model.<br>&gt; <br>&gt; <br>Makes sense.<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/4c3144c8/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 15, 2016 at 02:00:00pm</p></header><div class="content"><p>On Wed, Jun 15, 2016 at 2:48 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jun 15, 2016, at 2:46 PM, Adrian Zubarev via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I was referencing to the issue Robert discovered in his implementation.<br>&gt;<br>&gt; I do understand what the proposal is all about, but thank you for<br>&gt; re-clarifying that to me. :)<br>&gt;<br>&gt;<br>&gt; I don’t think it’s a bug, but it is definitely something that isn’t as<br>&gt; clear as it should have been.<br>&gt;<br></p><p>Was it intentional on the part of the proposal, then, that there should be<br>two modifiers meaning the same thing for a top level declaration in a file?<br>Or was it intended that only one or the other be used in that scenario?<br></p><p>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 15. Juni 2016 um 21:40:37, Matthew Johnson (matthew at anandabits.com)<br>&gt; schrieb:<br>&gt;<br>&gt; What seems like a nasty bug missed during review?  I don’t follow you<br>&gt; there.<br>&gt;<br>&gt; This proposal was specifically designed to follow Swift’s design of a<br>&gt; scope-based access control mechanism rather than a type-based access<br>&gt; control mechanism that is common in other languages.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/b18a2049/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 15, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 15, 2016, at 2:55 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 15, 2016 at 2:48 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;wrote:<br>&gt; <br>&gt;&gt; On Jun 15, 2016, at 2:46 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I was referencing to the issue Robert discovered in his implementation. <br>&gt;&gt; <br>&gt;&gt; I do understand what the proposal is all about, but thank you for re-clarifying that to me. :)<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; I don’t think it’s a bug, but it is definitely something that isn’t as clear as it should have been.<br>&gt; <br>&gt; Was it intentional on the part of the proposal, then, that there should be two modifiers meaning the same thing for a top level declaration in a file? Or was it intended that only one or the other be used in that scenario?<br></p><p>I don’t think it was carefully considered, although I think it did come up at some point during discussion in the context of compatibility with existing code (i.e. nothing changes for current top-level `private` declarations).  <br></p><p>It is in some sense a “coincidence” that they mean the same thing at file scope.  The proposal would have had to introduce a specific prohibition to prevent this situation and it did not do so.  That said, I think this kind of issue falls well within the discretion of the core team to make a call without violating the spirit of the proposal.<br></p><p>There are two reasonable options here: <br></p><p>1. Allow both `private` and `fileprivate` at file scope despite the fact that they have the same meaning.  This is more consistent in the sense that we are not introducing a special case that arbitrarily prohibits an otherwise valid access modifier.  It also means that nothing needs to change for top level `private` declarations in existing code.<br></p><p>2. Prohibit `private` at file scope.  Given that it appears as if the behavior of `private` at file scope may not be intuitive and is equivalent to `fileprivate` it might be reasonable to just disallow it.  This would result in more consistent *code* (even if there needs to be a special case in the language).<br></p><p>I don’t have a strong opinion on which option we choose.  But I do feel strongly that the semantics of `private` need to properly respect the scope in which the keyword is written and into which the associated declaration is introduced (rather than the scope *inside* the declaration it is attached to).<br></p><p>-Matthew<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; Am 15. Juni 2016 um 21:40:37, Matthew Johnson (matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;) schrieb:<br>&gt;&gt; <br>&gt;&gt;&gt; What seems like a nasty bug missed during review?  I don’t follow you there.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal was specifically designed to follow Swift’s design of a scope-based access control mechanism rather than a type-based access control mechanism that is common in other languages.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/0b18e95a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 15, 2016 at 04:00:00pm</p></header><div class="content"><p>On Wed, Jun 15, 2016 at 3:09 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jun 15, 2016, at 2:55 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Jun 15, 2016 at 2:48 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 15, 2016, at 2:46 PM, Adrian Zubarev via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I was referencing to the issue Robert discovered in his implementation.<br>&gt;&gt;<br>&gt;&gt; I do understand what the proposal is all about, but thank you for<br>&gt;&gt; re-clarifying that to me. :)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don’t think it’s a bug, but it is definitely something that isn’t as<br>&gt;&gt; clear as it should have been.<br>&gt;&gt;<br>&gt;<br>&gt; Was it intentional on the part of the proposal, then, that there should be<br>&gt; two modifiers meaning the same thing for a top level declaration in a file?<br>&gt; Or was it intended that only one or the other be used in that scenario?<br>&gt;<br>&gt;<br>&gt; I don’t think it was carefully considered, although I think it did come up<br>&gt; at some point during discussion in the context of compatibility with<br>&gt; existing code (i.e. nothing changes for current top-level `private`<br>&gt; declarations).<br>&gt;<br>&gt; It is in some sense a “coincidence” that they mean the same thing at file<br>&gt; scope.  The proposal would have had to introduce a specific prohibition to<br>&gt; prevent this situation and it did not do so.  That said, I think this kind<br>&gt; of issue falls well within the discretion of the core team to make a call<br>&gt; without violating the spirit of the proposal.<br>&gt;<br>&gt; There are two reasonable options here:<br>&gt;<br>&gt; 1. Allow both `private` and `fileprivate` at file scope despite the fact<br>&gt; that they have the same meaning.  This is more consistent in the sense that<br>&gt; we are not introducing a special case that arbitrarily prohibits an<br>&gt; otherwise valid access modifier.  It also means that nothing needs to<br>&gt; change for top level `private` declarations in existing code.<br>&gt;<br>&gt; 2. Prohibit `private` at file scope.  Given that it appears as if the<br>&gt; behavior of `private` at file scope may not be intuitive and is equivalent<br>&gt; to `fileprivate` it might be reasonable to just disallow it.  This would<br>&gt; result in more consistent *code* (even if there needs to be a special case<br>&gt; in the language).<br>&gt;<br>&gt; I don’t have a strong opinion on which option we choose.  But I do feel<br>&gt; strongly that the semantics of `private` need to properly respect the scope<br>&gt; in which the keyword is written and into which the associated declaration<br>&gt; is introduced (rather than the scope *inside* the declaration it is<br>&gt; attached to).<br>&gt;<br></p><p>Right, I think both would be OK. More radically, we might want to<br>re-evaluate the continued utility of a `fileprivate` scope. It seems the<br>use cases for such a scope not adequately served by either `internal` or<br>the new `private` would be exceedingly rare.<br></p><p><br>&gt; -Matthew<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt;<br>&gt;&gt; Am 15. Juni 2016 um 21:40:37, Matthew Johnson (matthew at anandabits.com)<br>&gt;&gt; schrieb:<br>&gt;&gt;<br>&gt;&gt; What seems like a nasty bug missed during review?  I don’t follow you<br>&gt;&gt; there.<br>&gt;&gt;<br>&gt;&gt; This proposal was specifically designed to follow Swift’s design of a<br>&gt;&gt; scope-based access control mechanism rather than a type-based access<br>&gt;&gt; control mechanism that is common in other languages.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/c79e5a67/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 15, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 15, 2016, at 4:08 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 15, 2016 at 3:09 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 15, 2016, at 2:55 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 15, 2016 at 2:48 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 15, 2016, at 2:46 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was referencing to the issue Robert discovered in his implementation. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I do understand what the proposal is all about, but thank you for re-clarifying that to me. :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I don’t think it’s a bug, but it is definitely something that isn’t as clear as it should have been.<br>&gt;&gt; <br>&gt;&gt; Was it intentional on the part of the proposal, then, that there should be two modifiers meaning the same thing for a top level declaration in a file? Or was it intended that only one or the other be used in that scenario?<br>&gt; <br>&gt; I don’t think it was carefully considered, although I think it did come up at some point during discussion in the context of compatibility with existing code (i.e. nothing changes for current top-level `private` declarations).  <br>&gt; <br>&gt; It is in some sense a “coincidence” that they mean the same thing at file scope.  The proposal would have had to introduce a specific prohibition to prevent this situation and it did not do so.  That said, I think this kind of issue falls well within the discretion of the core team to make a call without violating the spirit of the proposal.<br>&gt; <br>&gt; There are two reasonable options here: <br>&gt; <br>&gt; 1. Allow both `private` and `fileprivate` at file scope despite the fact that they have the same meaning.  This is more consistent in the sense that we are not introducing a special case that arbitrarily prohibits an otherwise valid access modifier.  It also means that nothing needs to change for top level `private` declarations in existing code.<br>&gt; <br>&gt; 2. Prohibit `private` at file scope.  Given that it appears as if the behavior of `private` at file scope may not be intuitive and is equivalent to `fileprivate` it might be reasonable to just disallow it.  This would result in more consistent *code* (even if there needs to be a special case in the language).<br>&gt; <br>&gt; I don’t have a strong opinion on which option we choose.  But I do feel strongly that the semantics of `private` need to properly respect the scope in which the keyword is written and into which the associated declaration is introduced (rather than the scope *inside* the declaration it is attached to).<br>&gt; <br>&gt; Right, I think both would be OK. More radically, we might want to re-evaluate the continued utility of a `fileprivate` scope. It seems the use cases for such a scope not adequately served by either `internal` or the new `private` would be exceedingly rare.<br></p><p>I disagree with that.  `fileprivate` is indispensable when you need it.  There are times when you want to keep visibility limited to the current file but the new `private` is too restrictive (for example, you need to access a member of one type in a closely related extension of a different type that lives in the same file).<br></p><p>&gt;  <br>&gt; -Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 15. Juni 2016 um 21:40:37, Matthew Johnson (matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;) schrieb:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What seems like a nasty bug missed during review?  I don’t follow you there.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This proposal was specifically designed to follow Swift’s design of a scope-based access control mechanism rather than a type-based access control mechanism that is common in other languages.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/d978a109/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 15, 2016 at 04:00:00pm</p></header><div class="content"><p>On Wed, Jun 15, 2016 at 4:14 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jun 15, 2016, at 4:08 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Jun 15, 2016 at 3:09 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 15, 2016, at 2:55 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Wed, Jun 15, 2016 at 2:48 PM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jun 15, 2016, at 2:46 PM, Adrian Zubarev via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I was referencing to the issue Robert discovered in his implementation.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I do understand what the proposal is all about, but thank you for<br>&gt;&gt;&gt; re-clarifying that to me. :)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don’t think it’s a bug, but it is definitely something that isn’t as<br>&gt;&gt;&gt; clear as it should have been.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Was it intentional on the part of the proposal, then, that there should<br>&gt;&gt; be two modifiers meaning the same thing for a top level declaration in a<br>&gt;&gt; file? Or was it intended that only one or the other be used in that<br>&gt;&gt; scenario?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don’t think it was carefully considered, although I think it did come<br>&gt;&gt; up at some point during discussion in the context of compatibility with<br>&gt;&gt; existing code (i.e. nothing changes for current top-level `private`<br>&gt;&gt; declarations).<br>&gt;&gt;<br>&gt;&gt; It is in some sense a “coincidence” that they mean the same thing at file<br>&gt;&gt; scope.  The proposal would have had to introduce a specific prohibition to<br>&gt;&gt; prevent this situation and it did not do so.  That said, I think this kind<br>&gt;&gt; of issue falls well within the discretion of the core team to make a call<br>&gt;&gt; without violating the spirit of the proposal.<br>&gt;&gt;<br>&gt;&gt; There are two reasonable options here:<br>&gt;&gt;<br>&gt;&gt; 1. Allow both `private` and `fileprivate` at file scope despite the fact<br>&gt;&gt; that they have the same meaning.  This is more consistent in the sense that<br>&gt;&gt; we are not introducing a special case that arbitrarily prohibits an<br>&gt;&gt; otherwise valid access modifier.  It also means that nothing needs to<br>&gt;&gt; change for top level `private` declarations in existing code.<br>&gt;&gt;<br>&gt;&gt; 2. Prohibit `private` at file scope.  Given that it appears as if the<br>&gt;&gt; behavior of `private` at file scope may not be intuitive and is equivalent<br>&gt;&gt; to `fileprivate` it might be reasonable to just disallow it.  This would<br>&gt;&gt; result in more consistent *code* (even if there needs to be a special case<br>&gt;&gt; in the language).<br>&gt;&gt;<br>&gt;&gt; I don’t have a strong opinion on which option we choose.  But I do feel<br>&gt;&gt; strongly that the semantics of `private` need to properly respect the scope<br>&gt;&gt; in which the keyword is written and into which the associated declaration<br>&gt;&gt; is introduced (rather than the scope *inside* the declaration it is<br>&gt;&gt; attached to).<br>&gt;&gt;<br>&gt;<br>&gt; Right, I think both would be OK. More radically, we might want to<br>&gt; re-evaluate the continued utility of a `fileprivate` scope. It seems the<br>&gt; use cases for such a scope not adequately served by either `internal` or<br>&gt; the new `private` would be exceedingly rare.<br>&gt;<br>&gt;<br>&gt; I disagree with that.  `fileprivate` is indispensable when you need it.<br>&gt; There are times when you want to keep visibility limited to the current<br>&gt; file but the new `private` is too restrictive (for example, you need to<br>&gt; access a member of one type in a closely related extension of a different<br>&gt; type that lives in the same file).<br>&gt;<br></p><p>Sure. This was more of a thought for the future. As we move towards fully<br>embracing a scope-based model for organizing code, modules will no longer<br>need to be strictly &quot;single units of code distribution,&quot; and a move towards<br>supporting submodules could serve your use case without `fileprivate`.<br>That, IMO, would be a logical endpoint of moving from file-based access to<br>scope-based access.<br></p><p><br>&gt;<br>&gt;<br>&gt;&gt; -Matthew<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Am 15. Juni 2016 um 21:40:37, Matthew Johnson (matthew at anandabits.com)<br>&gt;&gt;&gt; schrieb:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What seems like a nasty bug missed during review?  I don’t follow you<br>&gt;&gt;&gt; there.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This proposal was specifically designed to follow Swift’s design of a<br>&gt;&gt;&gt; scope-based access control mechanism rather than a type-based access<br>&gt;&gt;&gt; control mechanism that is common in other languages.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/f6c9e922/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 15, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 15, 2016, at 4:27 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 15, 2016 at 4:14 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 15, 2016, at 4:08 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 15, 2016 at 3:09 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 15, 2016, at 2:55 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jun 15, 2016 at 2:48 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:46 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I was referencing to the issue Robert discovered in his implementation. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I do understand what the proposal is all about, but thank you for re-clarifying that to me. :)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t think it’s a bug, but it is definitely something that isn’t as clear as it should have been.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Was it intentional on the part of the proposal, then, that there should be two modifiers meaning the same thing for a top level declaration in a file? Or was it intended that only one or the other be used in that scenario?<br>&gt;&gt; <br>&gt;&gt; I don’t think it was carefully considered, although I think it did come up at some point during discussion in the context of compatibility with existing code (i.e. nothing changes for current top-level `private` declarations).  <br>&gt;&gt; <br>&gt;&gt; It is in some sense a “coincidence” that they mean the same thing at file scope.  The proposal would have had to introduce a specific prohibition to prevent this situation and it did not do so.  That said, I think this kind of issue falls well within the discretion of the core team to make a call without violating the spirit of the proposal.<br>&gt;&gt; <br>&gt;&gt; There are two reasonable options here: <br>&gt;&gt; <br>&gt;&gt; 1. Allow both `private` and `fileprivate` at file scope despite the fact that they have the same meaning.  This is more consistent in the sense that we are not introducing a special case that arbitrarily prohibits an otherwise valid access modifier.  It also means that nothing needs to change for top level `private` declarations in existing code.<br>&gt;&gt; <br>&gt;&gt; 2. Prohibit `private` at file scope.  Given that it appears as if the behavior of `private` at file scope may not be intuitive and is equivalent to `fileprivate` it might be reasonable to just disallow it.  This would result in more consistent *code* (even if there needs to be a special case in the language).<br>&gt;&gt; <br>&gt;&gt; I don’t have a strong opinion on which option we choose.  But I do feel strongly that the semantics of `private` need to properly respect the scope in which the keyword is written and into which the associated declaration is introduced (rather than the scope *inside* the declaration it is attached to).<br>&gt;&gt; <br>&gt;&gt; Right, I think both would be OK. More radically, we might want to re-evaluate the continued utility of a `fileprivate` scope. It seems the use cases for such a scope not adequately served by either `internal` or the new `private` would be exceedingly rare.<br>&gt; <br>&gt; I disagree with that.  `fileprivate` is indispensable when you need it.  There are times when you want to keep visibility limited to the current file but the new `private` is too restrictive (for example, you need to access a member of one type in a closely related extension of a different type that lives in the same file).<br>&gt; <br>&gt; Sure. This was more of a thought for the future. As we move towards fully embracing a scope-based model for organizing code, modules will no longer need to be strictly &quot;single units of code distribution,&quot; and a move towards supporting submodules could serve your use case without `fileprivate`. That, IMO, would be a logical endpoint of moving from file-based access to scope-based access.<br></p><p>I would really like to see submodules, but I think there would still be valid uses for `fileprivate` even with them.  But of course we would need to know the details of submodules to have a good discussion about that so it’s a topic for the future. :)<br></p><p>&gt; <br>&gt; <br>&gt;&gt;  <br>&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 15. Juni 2016 um 21:40:37, Matthew Johnson (matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;) schrieb:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What seems like a nasty bug missed during review?  I don’t follow you there.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This proposal was specifically designed to follow Swift’s design of a scope-based access control mechanism rather than a type-based access control mechanism that is common in other languages.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/d984d12b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 15, 2016 at 04:00:00pm</p></header><div class="content"><p>On Wed, Jun 15, 2016 at 4:30 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jun 15, 2016, at 4:27 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Jun 15, 2016 at 4:14 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 15, 2016, at 4:08 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Wed, Jun 15, 2016 at 3:09 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt;  wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jun 15, 2016, at 2:55 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Jun 15, 2016 at 2:48 PM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt;wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:46 PM, Adrian Zubarev via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I was referencing to the issue Robert discovered in his implementation.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I do understand what the proposal is all about, but thank you for<br>&gt;&gt;&gt;&gt; re-clarifying that to me. :)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I don’t think it’s a bug, but it is definitely something that isn’t as<br>&gt;&gt;&gt;&gt; clear as it should have been.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Was it intentional on the part of the proposal, then, that there should<br>&gt;&gt;&gt; be two modifiers meaning the same thing for a top level declaration in a<br>&gt;&gt;&gt; file? Or was it intended that only one or the other be used in that<br>&gt;&gt;&gt; scenario?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don’t think it was carefully considered, although I think it did come<br>&gt;&gt;&gt; up at some point during discussion in the context of compatibility with<br>&gt;&gt;&gt; existing code (i.e. nothing changes for current top-level `private`<br>&gt;&gt;&gt; declarations).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It is in some sense a “coincidence” that they mean the same thing at<br>&gt;&gt;&gt; file scope.  The proposal would have had to introduce a specific<br>&gt;&gt;&gt; prohibition to prevent this situation and it did not do so.  That said, I<br>&gt;&gt;&gt; think this kind of issue falls well within the discretion of the core team<br>&gt;&gt;&gt; to make a call without violating the spirit of the proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There are two reasonable options here:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1. Allow both `private` and `fileprivate` at file scope despite the fact<br>&gt;&gt;&gt; that they have the same meaning.  This is more consistent in the sense that<br>&gt;&gt;&gt; we are not introducing a special case that arbitrarily prohibits an<br>&gt;&gt;&gt; otherwise valid access modifier.  It also means that nothing needs to<br>&gt;&gt;&gt; change for top level `private` declarations in existing code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2. Prohibit `private` at file scope.  Given that it appears as if the<br>&gt;&gt;&gt; behavior of `private` at file scope may not be intuitive and is equivalent<br>&gt;&gt;&gt; to `fileprivate` it might be reasonable to just disallow it.  This would<br>&gt;&gt;&gt; result in more consistent *code* (even if there needs to be a special case<br>&gt;&gt;&gt; in the language).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don’t have a strong opinion on which option we choose.  But I do feel<br>&gt;&gt;&gt; strongly that the semantics of `private` need to properly respect the scope<br>&gt;&gt;&gt; in which the keyword is written and into which the associated declaration<br>&gt;&gt;&gt; is introduced (rather than the scope *inside* the declaration it is<br>&gt;&gt;&gt; attached to).<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Right, I think both would be OK. More radically, we might want to<br>&gt;&gt; re-evaluate the continued utility of a `fileprivate` scope. It seems the<br>&gt;&gt; use cases for such a scope not adequately served by either `internal` or<br>&gt;&gt; the new `private` would be exceedingly rare.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I disagree with that.  `fileprivate` is indispensable when you need it.<br>&gt;&gt; There are times when you want to keep visibility limited to the current<br>&gt;&gt; file but the new `private` is too restrictive (for example, you need to<br>&gt;&gt; access a member of one type in a closely related extension of a different<br>&gt;&gt; type that lives in the same file).<br>&gt;&gt;<br>&gt;<br>&gt; Sure. This was more of a thought for the future. As we move towards fully<br>&gt; embracing a scope-based model for organizing code, modules will no longer<br>&gt; need to be strictly &quot;single units of code distribution,&quot; and a move towards<br>&gt; supporting submodules could serve your use case without `fileprivate`.<br>&gt; That, IMO, would be a logical endpoint of moving from file-based access to<br>&gt; scope-based access.<br>&gt;<br>&gt;<br>&gt; I would really like to see submodules, but I think there would still be<br>&gt; valid uses for `fileprivate` even with them.  But of course we would need<br>&gt; to know the details of submodules to have a good discussion about that so<br>&gt; it’s a topic for the future. :)<br>&gt;<br></p><p>I wonder what became of this:<br>https://github.com/apple/swift/blob/master/docs/Modules.rst#id18<br></p><p>&gt;<br>&gt;&gt; -Matthew<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Am 15. Juni 2016 um 21:40:37, Matthew Johnson (matthew at anandabits.com)<br>&gt;&gt;&gt;&gt; schrieb:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; What seems like a nasty bug missed during review?  I don’t follow you<br>&gt;&gt;&gt;&gt; there.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This proposal was specifically designed to follow Swift’s design of a<br>&gt;&gt;&gt;&gt; scope-based access control mechanism rather than a type-based access<br>&gt;&gt;&gt;&gt; control mechanism that is common in other languages.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/d6346834/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Submodules (was: A Problem With SE-0025?)</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 22, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; <br>&gt; I would really like to see submodules, but I think there would still be valid uses for `fileprivate` even with them.  But of course we would need to know the details of submodules to have a good discussion about that so it’s a topic for the future. :)<br>&gt; <br>&gt; I wonder what became of this: https://github.com/apple/swift/blob/master/docs/Modules.rst#id18 &lt;https://github.com/apple/swift/blob/master/docs/Modules.rst#id18&gt;<br>As the author of that document, it became clear (or maybe “it became murky”) that everyone wants different things from submodules, both for compiling their own targets and for importing other people’s targets. I’d almost suggest avoiding the word if you want to propose any of myriad features related to them:<br></p><p>- importing a subset of APIs<br>- having APIs not imported by default with the top-level module<br>- C++ namespacing within a module<br>- C++ namespacing within another module<br>- breaking up compilation units (i.e. not compiling the entire module as one unit)<br>- adding another access level between internal and fileprivate.<br>- adding another access level between fileprivate and private.<br>- something else?<br></p><p>(still catching up on the main thread, but I think Robert and Matthew are both right: we need to explicitly amend the proposal, and the behavior we want is fairly obvious)<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/0b2c749c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Submodules (was: A Problem With SE-0025?)</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>June 22, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 11:59 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I would really like to see submodules, but I think there would still be valid uses for `fileprivate` even with them.  But of course we would need to know the details of submodules to have a good discussion about that so it’s a topic for the future. :)<br>&gt;&gt; <br>&gt;&gt; I wonder what became of this: https://github.com/apple/swift/blob/master/docs/Modules.rst#id18 &lt;https://github.com/apple/swift/blob/master/docs/Modules.rst#id18&gt;<br>&gt; As the author of that document, it became clear (or maybe “it became murky”) that everyone wants different things from submodules, both for compiling their own targets and for importing other people’s targets. I’d almost suggest avoiding the word if you want to propose any of myriad features related to them:<br>&gt; <br>&gt; - importing a subset of APIs<br>&gt; - having APIs not imported by default with the top-level module<br>&gt; - C++ namespacing within a module<br>&gt; - C++ namespacing within another module<br>&gt; - breaking up compilation units (i.e. not compiling the entire module as one unit)<br>&gt; - adding another access level between internal and fileprivate.<br>&gt; - adding another access level between fileprivate and private.<br>&gt; - something else?<br></p><p>Aggregation of first and third party frameworks into a single linkable module might be on that pile, if such aggregation was a path decided on to reduce application startup time.<br></p><p>-DW <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/83205295/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Submodules (was: A Problem With SE-0025?)</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 22, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 12:04, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 22, 2016, at 11:59 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would really like to see submodules, but I think there would still be valid uses for `fileprivate` even with them.  But of course we would need to know the details of submodules to have a good discussion about that so it’s a topic for the future. :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I wonder what became of this: https://github.com/apple/swift/blob/master/docs/Modules.rst#id18 &lt;https://github.com/apple/swift/blob/master/docs/Modules.rst#id18&gt;<br>&gt;&gt; As the author of that document, it became clear (or maybe “it became murky”) that everyone wants different things from submodules, both for compiling their own targets and for importing other people’s targets. I’d almost suggest avoiding the word if you want to propose any of myriad features related to them:<br>&gt;&gt; <br>&gt;&gt; - importing a subset of APIs<br>&gt;&gt; - having APIs not imported by default with the top-level module<br>&gt;&gt; - C++ namespacing within a module<br>&gt;&gt; - C++ namespacing within another module<br>&gt;&gt; - breaking up compilation units (i.e. not compiling the entire module as one unit)<br>&gt;&gt; - adding another access level between internal and fileprivate.<br>&gt;&gt; - adding another access level between fileprivate and private.<br>&gt;&gt; - something else?<br>&gt; <br>&gt; Aggregation of first and third party frameworks into a single linkable module might be on that pile, if such aggregation was a path decided on to reduce application startup time.<br></p><p>I&#39;d consider that an implementation detail of linking and a feature request for Xcode and the package manager rather than a language feature, but yes, I would also not call that &quot;submodules&quot;. :-)<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/c13b5eb2/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Submodules (was: A Problem With SE-0025?)</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 22, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 12:59 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I would really like to see submodules, but I think there would still be valid uses for `fileprivate` even with them.  But of course we would need to know the details of submodules to have a good discussion about that so it’s a topic for the future. :)<br>&gt;&gt; <br>&gt;&gt; I wonder what became of this: https://github.com/apple/swift/blob/master/docs/Modules.rst#id18 &lt;https://github.com/apple/swift/blob/master/docs/Modules.rst#id18&gt;<br>&gt; As the author of that document, it became clear (or maybe “it became murky”) that everyone wants different things from submodules, both for compiling their own targets and for importing other people’s targets. I’d almost suggest avoiding the word if you want to propose any of myriad features related to them:<br></p><p>Interesting.  The reason I like the idea of submodules is because I think they could accomplish several of these goals with a single feature in a more elegant manner and without introducing nearly as much complexity as would likely be present with independent features.  <br></p><p>&gt; <br>&gt; - importing a subset of APIs<br>&gt; - having APIs not imported by default with the top-level module<br></p><p>Aren’t these kind of duals of each other (subsets of APIs being submodules, possibly with some APIs directly in the root module)?<br></p><p>&gt; - C++ namespacing within a module<br></p><p>This is perhaps the most straightforward goal, but I believe it would be better served by a more robust submodule feature rather than being a limited namespace feature (for example, integrating with the subset import mentioned above).<br></p><p>&gt; - C++ namespacing within another module<br></p><p>Can you elaborate?  Do you mean namespaces that are “open to extension” in any module similar to how we can extend types from imported modules, provide retroactive conformances, etc?  If that is what you mean I am not at all convinced there is value in this.<br></p><p>&gt; - breaking up compilation units (i.e. not compiling the entire module as one unit)<br></p><p>This feels like it could be a build setting independent of submodules.  For example, if you want WMO to span all submodules you wouldn’t necessarily want this, but if WMO isn’t important maybe you do.<br></p><p>&gt; - adding another access level between internal and fileprivate.<br></p><p>This obviously makes sense in the context of a submodule (or namespace) feature, but feels (to me) like it would be awkward as an independent feature.  <br></p><p>&gt; - adding another access level between fileprivate and private.<br></p><p>Are you thinking of a file that contains scopes from different submodules?  I’m trying to think of how this would do something that the new `private` wouldn’t already be able to do.<br></p><p>&gt; - something else?<br></p><p>The big ones IMO are API subsets, namespaces, and encapsulation (access control) which feel like they fit very nicely together as a single elegant submodule feature.<br></p><p>&gt; <br>&gt; (still catching up on the main thread, but I think Robert and Matthew are both right: we need to explicitly amend the proposal, and the behavior we want is fairly obvious)<br>&gt; <br>&gt; Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/ef626530/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Submodules (was: A Problem With SE-0025?)</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 22, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 13:05, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 22, 2016, at 12:59 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would really like to see submodules, but I think there would still be valid uses for `fileprivate` even with them.  But of course we would need to know the details of submodules to have a good discussion about that so it’s a topic for the future. :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I wonder what became of this: https://github.com/apple/swift/blob/master/docs/Modules.rst#id18 &lt;https://github.com/apple/swift/blob/master/docs/Modules.rst#id18&gt;<br>&gt;&gt; As the author of that document, it became clear (or maybe “it became murky”) that everyone wants different things from submodules, both for compiling their own targets and for importing other people’s targets. I’d almost suggest avoiding the word if you want to propose any of myriad features related to them:<br>&gt; <br>&gt; Interesting.  The reason I like the idea of submodules is because I think they could accomplish several of these goals with a single feature in a more elegant manner and without introducing nearly as much complexity as would likely be present with independent features.  <br>&gt; <br>&gt;&gt; <br>&gt;&gt; - importing a subset of APIs<br>&gt;&gt; - having APIs not imported by default with the top-level module<br>&gt; <br>&gt; Aren’t these kind of duals of each other (subsets of APIs being submodules, possibly with some APIs directly in the root module)?<br></p><p>Most Clang submodules allow importing a subset of APIs, but still import everything by default with the top-level module. Explicit submodules are the exception rather than the common case.<br></p><p><br>&gt; <br>&gt;&gt; - C++ namespacing within a module<br>&gt; <br>&gt; This is perhaps the most straightforward goal, but I believe it would be better served by a more robust submodule feature rather than being a limited namespace feature (for example, integrating with the subset import mentioned above).<br>&gt; <br>&gt;&gt; - C++ namespacing within another module<br>&gt; <br>&gt; Can you elaborate?  Do you mean namespaces that are “open to extension” in any module similar to how we can extend types from imported modules, provide retroactive conformances, etc?  If that is what you mean I am not at all convinced there is value in this.<br></p><p>import Foo<br>Foo.Bar.baz()<br></p><p>It’s not obvious that a namespace within the main module (the module currently being compiled) shouldn’t be flattened when the module is published—say, if things are only broken up for compilation time purposes. Alternately, it’s not obvious that the namespaces within a module match up to the units you want to be able to import as submodules.<br></p><p><br>&gt; <br>&gt;&gt; - breaking up compilation units (i.e. not compiling the entire module as one unit)<br>&gt; <br>&gt; This feels like it could be a build setting independent of submodules.  For example, if you want WMO to span all submodules you wouldn’t necessarily want this, but if WMO isn’t important maybe you do.<br></p><p>People mostly want this for compile time.<br></p><p>&gt; <br>&gt;&gt; - adding another access level between internal and fileprivate.<br>&gt; <br>&gt; This obviously makes sense in the context of a submodule (or namespace) feature, but feels (to me) like it would be awkward as an independent feature.  <br>&gt; <br>&gt;&gt; - adding another access level between fileprivate and private.<br>&gt; <br>&gt; Are you thinking of a file that contains scopes from different submodules?  I’m trying to think of how this would do something that the new `private` wouldn’t already be able to do.<br></p><p>A few people would prefer to break a file up into (disjoint) groups rather than have groupings across files. I personally think this would not be a good feature, but it goes on the list.<br></p><p><br>&gt; <br>&gt;&gt; - something else?<br>&gt; <br>&gt; The big ones IMO are API subsets, namespaces, and encapsulation (access control) which feel like they fit very nicely together as a single elegant submodule feature.<br></p><p>“80% of the users only need 20% of the features, but everybody uses a different 20%”.<br></p><p>I’d be happy to have one feature that serves multiple purposes; however, in any such proposal I don’t want to take any behavior as obvious, because in the last three years someone has at one point asked for the opposite. :-)<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/ddeea1cf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Submodules (was: A Problem With SE-0025?)</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 22, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 3:14 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 22, 2016, at 13:05, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 22, 2016, at 12:59 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would really like to see submodules, but I think there would still be valid uses for `fileprivate` even with them.  But of course we would need to know the details of submodules to have a good discussion about that so it’s a topic for the future. :)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I wonder what became of this: https://github.com/apple/swift/blob/master/docs/Modules.rst#id18 &lt;https://github.com/apple/swift/blob/master/docs/Modules.rst#id18&gt;<br>&gt;&gt;&gt; As the author of that document, it became clear (or maybe “it became murky”) that everyone wants different things from submodules, both for compiling their own targets and for importing other people’s targets. I’d almost suggest avoiding the word if you want to propose any of myriad features related to them:<br>&gt;&gt; <br>&gt;&gt; Interesting.  The reason I like the idea of submodules is because I think they could accomplish several of these goals with a single feature in a more elegant manner and without introducing nearly as much complexity as would likely be present with independent features.  <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - importing a subset of APIs<br>&gt;&gt;&gt; - having APIs not imported by default with the top-level module<br>&gt;&gt; <br>&gt;&gt; Aren’t these kind of duals of each other (subsets of APIs being submodules, possibly with some APIs directly in the root module)?<br>&gt; <br>&gt; Most Clang submodules allow importing a subset of APIs, but still import everything by default with the top-level module. Explicit submodules are the exception rather than the common case.<br></p><p>That makes sense.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; - C++ namespacing within a module<br>&gt;&gt; <br>&gt;&gt; This is perhaps the most straightforward goal, but I believe it would be better served by a more robust submodule feature rather than being a limited namespace feature (for example, integrating with the subset import mentioned above).<br>&gt;&gt; <br>&gt;&gt;&gt; - C++ namespacing within another module<br>&gt;&gt; <br>&gt;&gt; Can you elaborate?  Do you mean namespaces that are “open to extension” in any module similar to how we can extend types from imported modules, provide retroactive conformances, etc?  If that is what you mean I am not at all convinced there is value in this.<br>&gt; <br>&gt; import Foo<br>&gt; Foo.Bar.baz()<br>&gt; <br>&gt; It’s not obvious that a namespace within the main module (the module currently being compiled) shouldn’t be flattened when the module is published—say, if things are only broken up for compilation time purposes. Alternately, it’s not obvious that the namespaces within a module match up to the units you want to be able to import as submodules.<br></p><p>This is interesting.  I suppose internal namespaces that are flattened could make sense in very large modules.  That is something I hadn’t considered.  It feels orthogonal to submodules to me but is certainly related.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; - breaking up compilation units (i.e. not compiling the entire module as one unit)<br>&gt;&gt; <br>&gt;&gt; This feels like it could be a build setting independent of submodules.  For example, if you want WMO to span all submodules you wouldn’t necessarily want this, but if WMO isn’t important maybe you do.<br>&gt; <br>&gt; People mostly want this for compile time.<br></p><p>Right.  But the ability to make a tradeoff between compile time and runtime performance feels more like a build setting of some kind (to me) rather than semantics of a language feature.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; - adding another access level between internal and fileprivate.<br>&gt;&gt; <br>&gt;&gt; This obviously makes sense in the context of a submodule (or namespace) feature, but feels (to me) like it would be awkward as an independent feature.  <br>&gt;&gt; <br>&gt;&gt;&gt; - adding another access level between fileprivate and private.<br>&gt;&gt; <br>&gt;&gt; Are you thinking of a file that contains scopes from different submodules?  I’m trying to think of how this would do something that the new `private` wouldn’t already be able to do.<br>&gt; <br>&gt; A few people would prefer to break a file up into (disjoint) groups rather than have groupings across files. I personally think this would not be a good feature, but it goes on the list.<br></p><p>Yes, but I don’t understand why the new `private` wouldn’t accomplish the goal access control in this context.  Here’s a strawman example:<br></p><p>submodule Foo {<br>    private func bar() { … }<br>    // bar is only visible inside the scope introduced by `submodule Foo`<br>}<br></p><p>What do you have in mind that wouldn’t be possible given some kind of syntax like that?<br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; - something else?<br>&gt;&gt; <br>&gt;&gt; The big ones IMO are API subsets, namespaces, and encapsulation (access control) which feel like they fit very nicely together as a single elegant submodule feature.<br>&gt; <br>&gt; “80% of the users only need 20% of the features, but everybody uses a different 20%”.<br>&gt; <br>&gt; I’d be happy to have one feature that serves multiple purposes; however, in any such proposal I don’t want to take any behavior as obvious, because in the last three years someone has at one point asked for the opposite. :-)<br></p><p>Sure.  You’ve certainly had a lot more experience exploring and discussing this area than I have!  :)  <br></p><p>I still think it would be worthwhile to have a community discussion on the topic (at the right time of course) and see if we can’t find a balance that is workable.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/53cff83e/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Submodules (was: A Problem With SE-0025?)</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 23, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 7:59 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would really like to see submodules, but I think there would still be valid uses for `fileprivate` even with them.  But of course we would need to know the details of submodules to have a good discussion about that so it’s a topic for the future. :)<br>&gt;&gt; <br>&gt;&gt; I wonder what became of this: https://github.com/apple/swift/blob/master/docs/Modules.rst#id18<br>&gt; <br>&gt; As the author of that document, it became clear (or maybe “it became murky”) that everyone wants different things from submodules, both for compiling their own targets and for importing other people’s targets.<br></p><p>Surveying the larger github swift projects it is clear that people currently struggle to structure code when compared with c++, java, c# or even scala. It may just be that many come directly from objc. It is particularly visible on the server side libs out there where a module sometimes mean a class and a protocol... Without getting sidetracked too much it should be possible to devise a limited improvement on the current situation, maybe even outside of this community to avoid some of the endless meandering i have seen on &#39;hot&#39; topics.<br></p><p><br>&gt; I’d almost suggest avoiding the word if you want to propose any of myriad features related to them:<br>&gt; <br>&gt; - importing a subset of APIs<br>&gt; - having APIs not imported by default with the top-level module<br>&gt; - C++ namespacing within a module<br>&gt; - C++ namespacing within another module<br>&gt; - breaking up compilation units (i.e. not compiling the entire module as one unit)<br>&gt; - adding another access level between internal and fileprivate.<br>&gt; - adding another access level between fileprivate and private.<br>&gt; - something else?<br>&gt; <br>&gt; (still catching up on the main thread, but I think Robert and Matthew are both right: we need to explicitly amend the proposal, and the behavior we want is fairly obvious)<br>&gt; <br>&gt; Jordan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/7182202d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 16, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; On Jun 15, 2016, at 11:27 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Wed, Jun 15, 2016 at 4:14 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 15, 2016, at 4:08 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Jun 15, 2016 at 3:09 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:55 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Jun 15, 2016 at 2:48 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:46 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I was referencing to the issue Robert discovered in his implementation. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I do understand what the proposal is all about, but thank you for re-clarifying that to me. :)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don’t think it’s a bug, but it is definitely something that isn’t as clear as it should have been.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Was it intentional on the part of the proposal, then, that there should be two modifiers meaning the same thing for a top level declaration in a file? Or was it intended that only one or the other be used in that scenario?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t think it was carefully considered, although I think it did come up at some point during discussion in the context of compatibility with existing code (i.e. nothing changes for current top-level `private` declarations).  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It is in some sense a “coincidence” that they mean the same thing at file scope.  The proposal would have had to introduce a specific prohibition to prevent this situation and it did not do so.  That said, I think this kind of issue falls well within the discretion of the core team to make a call without violating the spirit of the proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are two reasonable options here: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Allow both `private` and `fileprivate` at file scope despite the fact that they have the same meaning.  This is more consistent in the sense that we are not introducing a special case that arbitrarily prohibits an otherwise valid access modifier.  It also means that nothing needs to change for top level `private` declarations in existing code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. Prohibit `private` at file scope.  Given that it appears as if the behavior of `private` at file scope may not be intuitive and is equivalent to `fileprivate` it might be reasonable to just disallow it.  This would result in more consistent *code* (even if there needs to be a special case in the language).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t have a strong opinion on which option we choose.  But I do feel strongly that the semantics of `private` need to properly respect the scope in which the keyword is written and into which the associated declaration is introduced (rather than the scope *inside* the declaration it is attached to).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right, I think both would be OK. More radically, we might want to re-evaluate the continued utility of a `fileprivate` scope. It seems the use cases for such a scope not adequately served by either `internal` or the new `private` would be exceedingly rare.<br>&gt;&gt; <br>&gt;&gt; I disagree with that.  `fileprivate` is indispensable when you need it.  There are times when you want to keep visibility limited to the current file but the new `private` is too restrictive (for example, you need to access a member of one type in a closely related extension of a different type that lives in the same file).<br>&gt; <br>&gt; Sure. This was more of a thought for the future. As we move towards fully embracing a scope-based model for organizing code, modules will no longer need to be strictly &quot;single units of code distribution,&quot; and a move towards supporting submodules<br></p><p>Would be interesting to hear the core team on the topic of sub modules, considering how deep the implications would run to open that door (potential compatibility breaking change to the structure of the dylibs). Would be wise for them to say a quick possible/not-in-this-lifetime before people (including me) start to dream too much about them.<br></p><p>&gt; could serve your use case without `fileprivate`. That, IMO, would be a logical endpoint of moving from file-based access to scope-based access.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 15. Juni 2016 um 21:40:37, Matthew Johnson (matthew at anandabits.com) schrieb:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What seems like a nasty bug missed during review?  I don’t follow you there.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This proposal was specifically designed to follow Swift’s design of a scope-based access control mechanism rather than a type-based access control mechanism that is common in other languages.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/e1a33fd1/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 15, 2016 at 09:00:00pm</p></header><div class="content"><p>Shouldn’t a file act like an individual scope? If so why would A be visible in C? Is it because files act not a lexical scopes?<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 15. Juni 2016 um 21:34:23, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Your example #2 is just incorrect.  `A` is visible inside the scope of `C`.<br></p><p>Now that we have introduced a scope-dependent access modifier it is an incorrect mental model to consider members with no access modifier as having the exact same access modifier as the containing scope.  This is no longer correct.  They have the same *visibility*, not the same *access modifier*.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/cca134aa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 15, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 15, 2016, at 2:43 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Shouldn’t a file act like an individual scope? If so why would A be visible in C? Is it because files act not a lexical scopes?<br>&gt; <br>&gt; <br></p><p>Did you mean that `C` is in a different file?  That wasn’t clear to me.  Maybe that is what “1” and “2” indicated (different files)?  If that is what you meant then `A` would not be visible in `C`, nor would the `a` member of `B`.<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 15. Juni 2016 um 21:34:23, Adrian Zubarev (adrian.zubarev at devandartist.com &lt;mailto:adrian.zubarev at devandartist.com&gt;) schrieb:<br>&gt; <br>&gt;&gt; Your example #2 is just incorrect.  `A` is visible inside the scope of `C`.<br>&gt;&gt; <br>&gt;&gt; Now that we have introduced a scope-dependent access modifier it is an incorrect mental model to consider members with no access modifier as having the exact same access modifier as the containing scope.  This is no longer correct.  They have the same *visibility*, not the same *access modifier*.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/29993ef4/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 15, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 15, 2016, at 2:29 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; The meaning of private according to the proposal is not scope-dependent, it is decl-dependent.  The mental gymnastics we are both going through right now are not in the proposal.  I would like them to be.<br></p><p>I agree that the proposal is too sparse on the details and that is the source of the confusion.  <br></p><p>Ilya wanted me to write this proposal and only did it himself because I didn’t have time to do it as quickly as he wanted.  I know what the original intent of the proposal was (I can’t speak for the core team on their mental model of it when they accepted it).<br></p><p>That said, the title of the proposal is “scoped access level” and the detailed design says &quot;visible only within that lexical scope”.  And the entire discussion was always about lexical scope.  I believe the reason the “proposed solution” section says “current declaration” is because *most* lexical scopes are introduced by a declaration.  That is sloppy language that should have been cleaned up prior to review.<br></p><p>I appreciate you working on implementing this.  I also understand if you want to hold off until the core team can chime in on the semantics they intend.  <br></p><p>Matthew<br></p><p>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/06/15 12:26、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 15, 2016, at 2:19 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We have diagnostics specifically to prohibit this case.  You cannot raise the access level of members.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;     internal var x : String = &quot;&quot;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; warning: declaring an internal var for a private struct.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hence, the highest allowable level of access for x is private and it becomes invisible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would not like the compiler to synthesize this in my code, and if it did I would like the proposal to say it will raise access levels of members as you would like it to.<br>&gt;&gt; <br>&gt;&gt; That diagnostic is a good thing.  I am not suggesting that you to disregard it.<br>&gt;&gt; <br>&gt;&gt; What you are missing is that the meaning of `private` is scope-dependent.  The following example is perfectly valid:<br>&gt;&gt; <br>&gt;&gt; private struct Foo {<br>&gt;&gt;     fileprivate var x : String = “”<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; `fileprivate` inside `Foo` specifies the same visibility as `private` at the top level, thus we are not “raising&quot; the visibility of the member.  If no modifier is provided for `x` it receives the same visibility as its containing type (up to `internal`).<br>&gt;&gt; <br>&gt;&gt; Consider another example:<br>&gt;&gt; <br>&gt;&gt; struct Foo {<br>&gt;&gt;     private struct Bar {<br>&gt;&gt;         var x : String = “”<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In this example we *cannot* mark `x` as `fileprivate` because that *would* raise the visibility of `x` beyond that of `Bar`.  `Bar` is only visible inside `Foo`, not at file scope.  This means that `x` also has visibility throughout the lexical scope of `Foo`, but not outside of it.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/06/15 12:14、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:04 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2016/06/15 11:47、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:37 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The scope of the *declaration* is not the issue.  The scope of its *members* is.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Let’s consider an example:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;   var bar: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // elsewhere in the same file:<br>&gt;&gt;&gt;&gt;&gt;&gt; var foo = Foo(bar: 42)<br>&gt;&gt;&gt;&gt;&gt;&gt; foo.bar = 44<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; `Foo` is declared private.  Private for this declaration is at the file scope.  The `bar` member has no access modifier so it has the same visibility as the struct itself, which is file scope.  This will also be true of the implicitly synthesized memberwise initializer.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; No, it is also private.  It does not inherit its parent scope because, following the letter of the proposal, that symbol will only be visible within the current declaration.  We cannot arbitrarily break access control rules because it is convenient in one special case. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This means that it is possible to initialize `foo` with a newly constructed instance of `Foo` and to modify the `bar` member anywhere else in the same file.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; bar is not visible here.  If it were you could break access control rules.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If `bar` was also declared `private` this would not be possible as its visibility would be restricted to the surrounding scope of the initial declaration of `Foo`.  This means `Foo` would need to provide an explicit initializer or factory method with `fileprivate` visibility in order to be usable.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; bar is private.  Declarations within Foo cannot decide to raise that access level to make themselves more visible.  If this should be the case, the proposal must be amended as much.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Members with no explicit access modifier should have the same *visibility* as their containing type (with a maximum implicit visibility of internal), not the same *modifier* as their containing type.  The only case where there is a distinction is the new `private` visibility.  Maybe that is what is causing the confusion?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That is not what the proposal says.  The proposal says it is invisible outside the current decl, which is the containing structure here.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The access modifier is applied to `Foo`, not `bar`.  `Foo` is visible in the scope of the “current declaration” (this is badly worded - it should say current scope, which is the file).  Because `Foo` has a visibility lower than `internal` the default visibility of its members match the visibility of `Foo`, which again is the current scope: the file.  The detailed design section of the proposal is sparse, but it correctly uses the phrase &quot;visible only within that lexical scope” rather than the less precise (in the case of top-level code) “current declaration”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I didn’t write the proposal but I was very heavily involved in the discussions and IIRC I provided the original suggestion for introducing a scoped access modifier.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If my example was the following:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;   private var bar: Int<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Then what you are saying would be correct.  However, The example I showed did not provide an access modifier for `bar`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You cannot just apply the same *access modifier* to members of the type that do not contain an access modifier.  You have to apply the same *visibility* (limited to internal).  When a type is marked as `private` in the lexical scope of the file, its unmodified members will be visible in the same lexical scope as the type itself (which is the file in the current example).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Does this help?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 11:36、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The scope for a top-level declaration is the file itself.  This means that top-level declarations with `private` and `fileprivate` should have the same behavior.  They should not be uninstantiable or unusable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:31 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal.  Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way.  Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused.  It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary.  Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/cf2f159c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 15, 2016 at 03:00:00pm</p></header><div class="content"><p>I await their opinions, but even with that change we still have a problem with the philosophy here.  The motivation behind the fileprivate/private distinction is, as you say in the proposal &quot;[a] reliable way to hide implementation details...&quot;.  Why would you want any members you&#39;re trying to hide to be visible in any scope other than the one you create with the decl (which is, without a doubt, also a lexical scope)?  It is analogous with other access control levels: a public outer decl implies public inner members just as a fileprivate one implies fileprivate inner members.  Is it not antithetical to being able to hide things if they remain visible despite the outer decl declaring itself supposedly being sealed?  In your examples, you declare private members that you do not wish to leak into top level scope because they are, after all, supposedly hidden.  Should the same semantics you have given not also apply to private decls no matter where they lie? <br></p><p>Should this compile:<br></p><p>private struct Outer {<br>    let inner = Inner()<br>}<br></p><p>Outer().inner<br></p><p>If this shouldn&#39;t:<br></p><p>struct Outer {<br>    private let inner = Inner()<br>}<br></p><p>extension Outer {<br>    var inner2 : Inner { return self.inner }<br>}<br></p><p>Visibility being a function of scope, lexical or otherwise, seems too coarse a metric for access control in general without further clarification of what the definition of &quot;hidden&quot; is.<br></p><p>~Robert Widmann<br></p><p>2016/06/15 12:38、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br></p><p>&gt; <br>&gt;&gt; On Jun 15, 2016, at 2:29 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The meaning of private according to the proposal is not scope-dependent, it is decl-dependent.  The mental gymnastics we are both going through right now are not in the proposal.  I would like them to be.<br>&gt; <br>&gt; I agree that the proposal is too sparse on the details and that is the source of the confusion.  <br>&gt; <br>&gt; Ilya wanted me to write this proposal and only did it himself because I didn’t have time to do it as quickly as he wanted.  I know what the original intent of the proposal was (I can’t speak for the core team on their mental model of it when they accepted it).<br>&gt; <br>&gt; That said, the title of the proposal is “scoped access level” and the detailed design says &quot;visible only within that lexical scope”.  And the entire discussion was always about lexical scope.  I believe the reason the “proposed solution” section says “current declaration” is because *most* lexical scopes are introduced by a declaration.  That is sloppy language that should have been cleaned up prior to review.<br>&gt; <br>&gt; I appreciate you working on implementing this.  I also understand if you want to hold off until the core team can chime in on the semantics they intend.  <br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/06/15 12:26、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:19 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We have diagnostics specifically to prohibit this case.  You cannot raise the access level of members.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;     internal var x : String = &quot;&quot;<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; warning: declaring an internal var for a private struct.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hence, the highest allowable level of access for x is private and it becomes invisible.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would not like the compiler to synthesize this in my code, and if it did I would like the proposal to say it will raise access levels of members as you would like it to.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That diagnostic is a good thing.  I am not suggesting that you to disregard it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What you are missing is that the meaning of `private` is scope-dependent.  The following example is perfectly valid:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;     fileprivate var x : String = “”<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `fileprivate` inside `Foo` specifies the same visibility as `private` at the top level, thus we are not “raising&quot; the visibility of the member.  If no modifier is provided for `x` it receives the same visibility as its containing type (up to `internal`).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider another example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;     private struct Bar {<br>&gt;&gt;&gt;         var x : String = “”<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this example we *cannot* mark `x` as `fileprivate` because that *would* raise the visibility of `x` beyond that of `Bar`.  `Bar` is only visible inside `Foo`, not at file scope.  This means that `x` also has visibility throughout the lexical scope of `Foo`, but not outside of it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/06/15 12:14、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:04 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 11:47、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:37 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The scope of the *declaration* is not the issue.  The scope of its *members* is.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Let’s consider an example:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   var bar: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // elsewhere in the same file:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var foo = Foo(bar: 42)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; foo.bar = 44<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; `Foo` is declared private.  Private for this declaration is at the file scope.  The `bar` member has no access modifier so it has the same visibility as the struct itself, which is file scope.  This will also be true of the implicitly synthesized memberwise initializer.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; No, it is also private.  It does not inherit its parent scope because, following the letter of the proposal, that symbol will only be visible within the current declaration.  We cannot arbitrarily break access control rules because it is convenient in one special case. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This means that it is possible to initialize `foo` with a newly constructed instance of `Foo` and to modify the `bar` member anywhere else in the same file.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; bar is not visible here.  If it were you could break access control rules.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If `bar` was also declared `private` this would not be possible as its visibility would be restricted to the surrounding scope of the initial declaration of `Foo`.  This means `Foo` would need to provide an explicit initializer or factory method with `fileprivate` visibility in order to be usable.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; bar is private.  Declarations within Foo cannot decide to raise that access level to make themselves more visible.  If this should be the case, the proposal must be amended as much.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Members with no explicit access modifier should have the same *visibility* as their containing type (with a maximum implicit visibility of internal), not the same *modifier* as their containing type.  The only case where there is a distinction is the new `private` visibility.  Maybe that is what is causing the confusion?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That is not what the proposal says.  The proposal says it is invisible outside the current decl, which is the containing structure here.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The access modifier is applied to `Foo`, not `bar`.  `Foo` is visible in the scope of the “current declaration” (this is badly worded - it should say current scope, which is the file).  Because `Foo` has a visibility lower than `internal` the default visibility of its members match the visibility of `Foo`, which again is the current scope: the file.  The detailed design section of the proposal is sparse, but it correctly uses the phrase &quot;visible only within that lexical scope” rather than the less precise (in the case of top-level code) “current declaration”.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I didn’t write the proposal but I was very heavily involved in the discussions and IIRC I provided the original suggestion for introducing a scoped access modifier.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If my example was the following:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;   private var bar: Int<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Then what you are saying would be correct.  However, The example I showed did not provide an access modifier for `bar`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You cannot just apply the same *access modifier* to members of the type that do not contain an access modifier.  You have to apply the same *visibility* (limited to internal).  When a type is marked as `private` in the lexical scope of the file, its unmodified members will be visible in the same lexical scope as the type itself (which is the file in the current example).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Does this help?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 11:36、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The scope for a top-level declaration is the file itself.  This means that top-level declarations with `private` and `fileprivate` should have the same behavior.  They should not be uninstantiable or unusable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:31 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal.  Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way.  Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused.  It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary.  Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/4c6bcf5e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 15, 2016 at 05:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 15, 2016, at 5:17 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; I await their opinions<br></p><p>I as well.  :)<br></p><p>&gt; , but even with that change we still have a problem with the philosophy here.  The motivation behind the fileprivate/private distinction is, as you say in the proposal &quot;[a] reliable way to hide implementation details...&quot;.  Why would you want any members you&#39;re trying to hide to be visible in any scope other than the one you create with the decl (which is, without a doubt, also a lexical scope)?  <br></p><p>Because you are trying to limit access to the scope that contains the declaration.  Restricting access to a declaration that introduces a scope to *inside* the scope it contains doesn&#39;t make sense and has no precedent in Swift (or any other language that I know of).  *That* is what makes the declaration useless.<br></p><p>&gt; It is analogous with other access control levels: a public outer decl implies public inner members<br></p><p>No it doesn&#39;t.  Nothing is implicitly public in Swift.  <br></p><p>&gt; just as a fileprivate one implies fileprivate inner members.  <br></p><p>This is coincidental because that keyword (and internal) mean the same thing whether they are applied at file scope or inside another scope.  The new &#39;private&#39; modifier *does not* mean the same thing regardless of its containing scope.  That difference is the whole point of introducing it.  It scales to any scope in which it is used.<br></p><p>&gt; Is it not antithetical to being able to hide things if they remain visible despite the outer decl declaring itself supposedly being sealed?  <br></p><p>I&#39;m not sure why you mention &#39;sealed&#39;.  That is something else entirely.<br></p><p>&gt; In your examples, you declare private members that you do not wish to leak into top level scope because they are, after all, supposedly hidden.  Should the same semantics you have given not also apply to private decls no matter where they lie? <br></p><p>The same semantics do apply everywhere.  When members themselves are declared &#39;private&#39; they do not &quot;leak&quot; out of the scope in which they are declared.  They are indeed limited to the scope in which the member is declared.<br></p><p>But when a type / extension is declared &#39;private&#39;, &#39;private&#39; appears within the scope of that declaration (not inside the scope it introduces).  This means the type / extension is visible throughout its containing scope.  Any members that do not have an access modifier simply receive the same visibility as the containing declaration.  <br></p><p>When &#39;private&#39; is used on a type / extension at the top level scope of a file it just happens to have behavior that coincides with the behavior of &#39;fileprivate&#39;.<br></p><p>It seems like you expect &#39;private&#39; to work one way when applied to members (restrict them to the surrounding scope) and another way when applied to types / extensions (restrict the members - and the type / extension itself??? - to the new scope that is introduced).  That is inconsistent and confusing semantics IMO.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; Should this compile:<br>&gt; <br>&gt; private struct Outer {<br>&gt;     let inner = Inner()<br>&gt; }<br>&gt; <br>&gt; Outer().inner<br>&gt; <br>&gt; If this shouldn&#39;t:<br>&gt; <br>&gt; struct Outer {<br>&gt;     private let inner = Inner()<br>&gt; }<br>&gt; <br>&gt; extension Outer {<br>&gt;     var inner2 : Inner { return self.inner }<br>&gt; }<br>&gt; <br>&gt; Visibility being a function of scope, lexical or otherwise, seems too coarse a metric for access control in general without further clarification of what the definition of &quot;hidden&quot; is.<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/06/15 12:38、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 15, 2016, at 2:29 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The meaning of private according to the proposal is not scope-dependent, it is decl-dependent.  The mental gymnastics we are both going through right now are not in the proposal.  I would like them to be.<br>&gt;&gt; <br>&gt;&gt; I agree that the proposal is too sparse on the details and that is the source of the confusion.  <br>&gt;&gt; <br>&gt;&gt; Ilya wanted me to write this proposal and only did it himself because I didn’t have time to do it as quickly as he wanted.  I know what the original intent of the proposal was (I can’t speak for the core team on their mental model of it when they accepted it).<br>&gt;&gt; <br>&gt;&gt; That said, the title of the proposal is “scoped access level” and the detailed design says &quot;visible only within that lexical scope”.  And the entire discussion was always about lexical scope.  I believe the reason the “proposed solution” section says “current declaration” is because *most* lexical scopes are introduced by a declaration.  That is sloppy language that should have been cleaned up prior to review.<br>&gt;&gt; <br>&gt;&gt; I appreciate you working on implementing this.  I also understand if you want to hold off until the core team can chime in on the semantics they intend.  <br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/06/15 12:26、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:19 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We have diagnostics specifically to prohibit this case.  You cannot raise the access level of members.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;     internal var x : String = &quot;&quot;<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; warning: declaring an internal var for a private struct.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hence, the highest allowable level of access for x is private and it becomes invisible.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would not like the compiler to synthesize this in my code, and if it did I would like the proposal to say it will raise access levels of members as you would like it to.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That diagnostic is a good thing.  I am not suggesting that you to disregard it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What you are missing is that the meaning of `private` is scope-dependent.  The following example is perfectly valid:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;     fileprivate var x : String = “”<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `fileprivate` inside `Foo` specifies the same visibility as `private` at the top level, thus we are not “raising&quot; the visibility of the member.  If no modifier is provided for `x` it receives the same visibility as its containing type (up to `internal`).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Consider another example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;&gt;     private struct Bar {<br>&gt;&gt;&gt;&gt;         var x : String = “”<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In this example we *cannot* mark `x` as `fileprivate` because that *would* raise the visibility of `x` beyond that of `Bar`.  `Bar` is only visible inside `Foo`, not at file scope.  This means that `x` also has visibility throughout the lexical scope of `Foo`, but not outside of it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2016/06/15 12:14、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:04 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 11:47、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:37 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The scope of the *declaration* is not the issue.  The scope of its *members* is.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Let’s consider an example:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   var bar: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // elsewhere in the same file:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var foo = Foo(bar: 42)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; foo.bar = 44<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `Foo` is declared private.  Private for this declaration is at the file scope.  The `bar` member has no access modifier so it has the same visibility as the struct itself, which is file scope.  This will also be true of the implicitly synthesized memberwise initializer.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, it is also private.  It does not inherit its parent scope because, following the letter of the proposal, that symbol will only be visible within the current declaration.  We cannot arbitrarily break access control rules because it is convenient in one special case. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This means that it is possible to initialize `foo` with a newly constructed instance of `Foo` and to modify the `bar` member anywhere else in the same file.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; bar is not visible here.  If it were you could break access control rules.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If `bar` was also declared `private` this would not be possible as its visibility would be restricted to the surrounding scope of the initial declaration of `Foo`.  This means `Foo` would need to provide an explicit initializer or factory method with `fileprivate` visibility in order to be usable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; bar is private.  Declarations within Foo cannot decide to raise that access level to make themselves more visible.  If this should be the case, the proposal must be amended as much.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Members with no explicit access modifier should have the same *visibility* as their containing type (with a maximum implicit visibility of internal), not the same *modifier* as their containing type.  The only case where there is a distinction is the new `private` visibility.  Maybe that is what is causing the confusion?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is not what the proposal says.  The proposal says it is invisible outside the current decl, which is the containing structure here.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The access modifier is applied to `Foo`, not `bar`.  `Foo` is visible in the scope of the “current declaration” (this is badly worded - it should say current scope, which is the file).  Because `Foo` has a visibility lower than `internal` the default visibility of its members match the visibility of `Foo`, which again is the current scope: the file.  The detailed design section of the proposal is sparse, but it correctly uses the phrase &quot;visible only within that lexical scope” rather than the less precise (in the case of top-level code) “current declaration”.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I didn’t write the proposal but I was very heavily involved in the discussions and IIRC I provided the original suggestion for introducing a scoped access modifier.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If my example was the following:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;   private var bar: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Then what you are saying would be correct.  However, The example I showed did not provide an access modifier for `bar`.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; You cannot just apply the same *access modifier* to members of the type that do not contain an access modifier.  You have to apply the same *visibility* (limited to internal).  When a type is marked as `private` in the lexical scope of the file, its unmodified members will be visible in the same lexical scope as the type itself (which is the file in the current example).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Does this help?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 11:36、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The scope for a top-level declaration is the file itself.  This means that top-level declarations with `private` and `fileprivate` should have the same behavior.  They should not be uninstantiable or unusable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:31 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal.  Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way.  Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused.  It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary.  Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/fb35bf0a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 15, 2016 at 05:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 15, 2016, at 5:17 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; I await their opinions, but even with that change we still have a problem with the philosophy here.  The motivation behind the fileprivate/private distinction is, as you say in the proposal &quot;[a] reliable way to hide implementation details...&quot;.  Why would you want any members you&#39;re trying to hide to be visible in any scope other than the one you create with the decl (which is, without a doubt, also a lexical scope)?  It is analogous with other access control levels: a public outer decl implies public inner members just as a fileprivate one implies fileprivate inner members.  Is it not antithetical to being able to hide things if they remain visible despite the outer decl declaring itself supposedly being sealed?  In your examples, you declare private members that you do not wish to leak into top level scope because they are, after all, supposedly hidden.  Should the same semantics you have given not also apply to private decls no matter where they lie? <br>&gt; <br></p><p>Sorry, missed the example in my last reply.<br></p><p>&gt; Should this compile:<br>&gt; <br>&gt; private struct Outer {<br>&gt;     let inner = Inner()<br>&gt; }<br>&gt; <br>&gt; Outer().inner<br></p><p>Aside from the fact that you can&#39;t write a standalone statement at the top level of a file and it isn&#39;t clear what &#39;Inner&#39; is, yes.  This would be valid:<br></p><p>private struct Outer {<br>    struct Inner {}<br>    let inner = Inner()<br>}<br></p><p>private let inner = Outer().inner<br></p><p>Note that the top level &#39;inner&#39; must be &#39;private&#39; or &#39;fileprivate&#39; because &#39;Inner&#39; is not visible outside the file.<br></p><p>&gt; <br>&gt; If this shouldn&#39;t:<br>&gt; <br>&gt; struct Outer {<br>&gt;     private let inner = Inner()<br>&gt; }<br>&gt; <br>&gt; extension Outer {<br>&gt;     var inner2 : Inner { return self.inner }<br>&gt; }<br></p><p>The extension introduces a new scope so this is not valid.<br></p><p>&gt; <br>&gt; Visibility being a function of scope, lexical or otherwise, seems too coarse a metric for access control in general without further clarification of what the definition of &quot;hidden&quot; is.<br></p><p>The lexical scope of the declaration itself (not a scope introduced by the declaration) is perfectly clear.  You may not like it or agree that it is desirable but it certainly isn&#39;t ambiguous.<br></p><p>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/06/15 12:38、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 15, 2016, at 2:29 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The meaning of private according to the proposal is not scope-dependent, it is decl-dependent.  The mental gymnastics we are both going through right now are not in the proposal.  I would like them to be.<br>&gt;&gt; <br>&gt;&gt; I agree that the proposal is too sparse on the details and that is the source of the confusion.  <br>&gt;&gt; <br>&gt;&gt; Ilya wanted me to write this proposal and only did it himself because I didn’t have time to do it as quickly as he wanted.  I know what the original intent of the proposal was (I can’t speak for the core team on their mental model of it when they accepted it).<br>&gt;&gt; <br>&gt;&gt; That said, the title of the proposal is “scoped access level” and the detailed design says &quot;visible only within that lexical scope”.  And the entire discussion was always about lexical scope.  I believe the reason the “proposed solution” section says “current declaration” is because *most* lexical scopes are introduced by a declaration.  That is sloppy language that should have been cleaned up prior to review.<br>&gt;&gt; <br>&gt;&gt; I appreciate you working on implementing this.  I also understand if you want to hold off until the core team can chime in on the semantics they intend.  <br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/06/15 12:26、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:19 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We have diagnostics specifically to prohibit this case.  You cannot raise the access level of members.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;     internal var x : String = &quot;&quot;<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; warning: declaring an internal var for a private struct.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hence, the highest allowable level of access for x is private and it becomes invisible.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would not like the compiler to synthesize this in my code, and if it did I would like the proposal to say it will raise access levels of members as you would like it to.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That diagnostic is a good thing.  I am not suggesting that you to disregard it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What you are missing is that the meaning of `private` is scope-dependent.  The following example is perfectly valid:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;     fileprivate var x : String = “”<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `fileprivate` inside `Foo` specifies the same visibility as `private` at the top level, thus we are not “raising&quot; the visibility of the member.  If no modifier is provided for `x` it receives the same visibility as its containing type (up to `internal`).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Consider another example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;&gt;     private struct Bar {<br>&gt;&gt;&gt;&gt;         var x : String = “”<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In this example we *cannot* mark `x` as `fileprivate` because that *would* raise the visibility of `x` beyond that of `Bar`.  `Bar` is only visible inside `Foo`, not at file scope.  This means that `x` also has visibility throughout the lexical scope of `Foo`, but not outside of it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2016/06/15 12:14、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:04 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 11:47、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:37 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The scope of the *declaration* is not the issue.  The scope of its *members* is.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Let’s consider an example:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   var bar: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // elsewhere in the same file:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var foo = Foo(bar: 42)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; foo.bar = 44<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `Foo` is declared private.  Private for this declaration is at the file scope.  The `bar` member has no access modifier so it has the same visibility as the struct itself, which is file scope.  This will also be true of the implicitly synthesized memberwise initializer.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, it is also private.  It does not inherit its parent scope because, following the letter of the proposal, that symbol will only be visible within the current declaration.  We cannot arbitrarily break access control rules because it is convenient in one special case. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This means that it is possible to initialize `foo` with a newly constructed instance of `Foo` and to modify the `bar` member anywhere else in the same file.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; bar is not visible here.  If it were you could break access control rules.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If `bar` was also declared `private` this would not be possible as its visibility would be restricted to the surrounding scope of the initial declaration of `Foo`.  This means `Foo` would need to provide an explicit initializer or factory method with `fileprivate` visibility in order to be usable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; bar is private.  Declarations within Foo cannot decide to raise that access level to make themselves more visible.  If this should be the case, the proposal must be amended as much.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Members with no explicit access modifier should have the same *visibility* as their containing type (with a maximum implicit visibility of internal), not the same *modifier* as their containing type.  The only case where there is a distinction is the new `private` visibility.  Maybe that is what is causing the confusion?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is not what the proposal says.  The proposal says it is invisible outside the current decl, which is the containing structure here.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The access modifier is applied to `Foo`, not `bar`.  `Foo` is visible in the scope of the “current declaration” (this is badly worded - it should say current scope, which is the file).  Because `Foo` has a visibility lower than `internal` the default visibility of its members match the visibility of `Foo`, which again is the current scope: the file.  The detailed design section of the proposal is sparse, but it correctly uses the phrase &quot;visible only within that lexical scope” rather than the less precise (in the case of top-level code) “current declaration”.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I didn’t write the proposal but I was very heavily involved in the discussions and IIRC I provided the original suggestion for introducing a scoped access modifier.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If my example was the following:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;   private var bar: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Then what you are saying would be correct.  However, The example I showed did not provide an access modifier for `bar`.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; You cannot just apply the same *access modifier* to members of the type that do not contain an access modifier.  You have to apply the same *visibility* (limited to internal).  When a type is marked as `private` in the lexical scope of the file, its unmodified members will be visible in the same lexical scope as the type itself (which is the file in the current example).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Does this help?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 11:36、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The scope for a top-level declaration is the file itself.  This means that top-level declarations with `private` and `fileprivate` should have the same behavior.  They should not be uninstantiable or unusable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:31 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal.  Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way.  Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused.  It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary.  Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/a068230c/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June 15, 2016 at 06:00:00pm</p></header><div class="content"><p>I think you guys are making this more complicated than it is. The rules here seem fairly simple:<br></p><p>1. The default access level is “internal”.<br></p><p>2. A type declared “private” at the top level will be visible to the file only.<br></p><p>3. If they are not given an access level, properties declared on the type will get the default “internal” access level, but since their containing type is not visible outside the file, they will not be visible either.<br></p><p>Thus any properties on the type will effectively inherit the access level of that type, unless the type’s access level is broader than “internal”. For the example of a private type at the top level of a file, its properties will effectively be fileprivate.<br></p><p>Charles<br></p><p>&gt; On Jun 15, 2016, at 5:48 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Jun 15, 2016, at 5:17 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I await their opinions, but even with that change we still have a problem with the philosophy here.  The motivation behind the fileprivate/private distinction is, as you say in the proposal &quot;[a] reliable way to hide implementation details...&quot;.  Why would you want any members you&#39;re trying to hide to be visible in any scope other than the one you create with the decl (which is, without a doubt, also a lexical scope)?  It is analogous with other access control levels: a public outer decl implies public inner members just as a fileprivate one implies fileprivate inner members.  Is it not antithetical to being able to hide things if they remain visible despite the outer decl declaring itself supposedly being sealed?  In your examples, you declare private members that you do not wish to leak into top level scope because they are, after all, supposedly hidden.  Should the same semantics you have given not also apply to private decls no matter where they lie? <br>&gt;&gt; <br>&gt; <br>&gt; Sorry, missed the example in my last reply.<br>&gt; <br>&gt;&gt; Should this compile:<br>&gt;&gt; <br>&gt;&gt; private struct Outer {<br>&gt;&gt;     let inner = Inner()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Outer().inner<br>&gt; <br>&gt; Aside from the fact that you can&#39;t write a standalone statement at the top level of a file and it isn&#39;t clear what &#39;Inner&#39; is, yes.  This would be valid:<br>&gt; <br>&gt; private struct Outer {<br>&gt;     struct Inner {}<br>&gt;     let inner = Inner()<br>&gt; }<br>&gt; <br>&gt; private let inner = Outer().inner<br>&gt; <br>&gt; Note that the top level &#39;inner&#39; must be &#39;private&#39; or &#39;fileprivate&#39; because &#39;Inner&#39; is not visible outside the file.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; If this shouldn&#39;t:<br>&gt;&gt; <br>&gt;&gt; struct Outer {<br>&gt;&gt;     private let inner = Inner()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Outer {<br>&gt;&gt;     var inner2 : Inner { return self.inner }<br>&gt;&gt; }<br>&gt; <br>&gt; The extension introduces a new scope so this is not valid.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Visibility being a function of scope, lexical or otherwise, seems too coarse a metric for access control in general without further clarification of what the definition of &quot;hidden&quot; is.<br>&gt; <br>&gt; The lexical scope of the declaration itself (not a scope introduced by the declaration) is perfectly clear.  You may not like it or agree that it is desirable but it certainly isn&#39;t ambiguous.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/06/15 12:38、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:29 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The meaning of private according to the proposal is not scope-dependent, it is decl-dependent.  The mental gymnastics we are both going through right now are not in the proposal.  I would like them to be.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that the proposal is too sparse on the details and that is the source of the confusion.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ilya wanted me to write this proposal and only did it himself because I didn’t have time to do it as quickly as he wanted.  I know what the original intent of the proposal was (I can’t speak for the core team on their mental model of it when they accepted it).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That said, the title of the proposal is “scoped access level” and the detailed design says &quot;visible only within that lexical scope”.  And the entire discussion was always about lexical scope.  I believe the reason the “proposed solution” section says “current declaration” is because *most* lexical scopes are introduced by a declaration.  That is sloppy language that should have been cleaned up prior to review.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I appreciate you working on implementing this.  I also understand if you want to hold off until the core team can chime in on the semantics they intend.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/06/15 12:26、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:19 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; We have diagnostics specifically to prohibit this case.  You cannot raise the access level of members.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;     internal var x : String = &quot;&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; warning: declaring an internal var for a private struct.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hence, the highest allowable level of access for x is private and it becomes invisible.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I would not like the compiler to synthesize this in my code, and if it did I would like the proposal to say it will raise access levels of members as you would like it to.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That diagnostic is a good thing.  I am not suggesting that you to disregard it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What you are missing is that the meaning of `private` is scope-dependent.  The following example is perfectly valid:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;     fileprivate var x : String = “”<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; `fileprivate` inside `Foo` specifies the same visibility as `private` at the top level, thus we are not “raising&quot; the visibility of the member.  If no modifier is provided for `x` it receives the same visibility as its containing type (up to `internal`).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Consider another example:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;&gt;&gt;     private struct Bar {<br>&gt;&gt;&gt;&gt;&gt;         var x : String = “”<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In this example we *cannot* mark `x` as `fileprivate` because that *would* raise the visibility of `x` beyond that of `Bar`.  `Bar` is only visible inside `Foo`, not at file scope.  This means that `x` also has visibility throughout the lexical scope of `Foo`, but not outside of it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 12:14、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:04 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 11:47、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:37 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The scope of the *declaration* is not the issue.  The scope of its *members* is.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Let’s consider an example:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   var bar: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // elsewhere in the same file:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var foo = Foo(bar: 42)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; foo.bar = 44<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `Foo` is declared private.  Private for this declaration is at the file scope.  The `bar` member has no access modifier so it has the same visibility as the struct itself, which is file scope.  This will also be true of the implicitly synthesized memberwise initializer.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, it is also private.  It does not inherit its parent scope because, following the letter of the proposal, that symbol will only be visible within the current declaration.  We cannot arbitrarily break access control rules because it is convenient in one special case. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This means that it is possible to initialize `foo` with a newly constructed instance of `Foo` and to modify the `bar` member anywhere else in the same file.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; bar is not visible here.  If it were you could break access control rules.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If `bar` was also declared `private` this would not be possible as its visibility would be restricted to the surrounding scope of the initial declaration of `Foo`.  This means `Foo` would need to provide an explicit initializer or factory method with `fileprivate` visibility in order to be usable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; bar is private.  Declarations within Foo cannot decide to raise that access level to make themselves more visible.  If this should be the case, the proposal must be amended as much.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Members with no explicit access modifier should have the same *visibility* as their containing type (with a maximum implicit visibility of internal), not the same *modifier* as their containing type.  The only case where there is a distinction is the new `private` visibility.  Maybe that is what is causing the confusion?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is not what the proposal says.  The proposal says it is invisible outside the current decl, which is the containing structure here.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The access modifier is applied to `Foo`, not `bar`.  `Foo` is visible in the scope of the “current declaration” (this is badly worded - it should say current scope, which is the file).  Because `Foo` has a visibility lower than `internal` the default visibility of its members match the visibility of `Foo`, which again is the current scope: the file.  The detailed design section of the proposal is sparse, but it correctly uses the phrase &quot;visible only within that lexical scope” rather than the less precise (in the case of top-level code) “current declaration”.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I didn’t write the proposal but I was very heavily involved in the discussions and IIRC I provided the original suggestion for introducing a scoped access modifier.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If my example was the following:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   private var bar: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Then what you are saying would be correct.  However, The example I showed did not provide an access modifier for `bar`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; You cannot just apply the same *access modifier* to members of the type that do not contain an access modifier.  You have to apply the same *visibility* (limited to internal).  When a type is marked as `private` in the lexical scope of the file, its unmodified members will be visible in the same lexical scope as the type itself (which is the file in the current example).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Does this help?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 11:36、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The scope for a top-level declaration is the file itself.  This means that top-level declarations with `private` and `fileprivate` should have the same behavior.  They should not be uninstantiable or unusable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:31 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal.  Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way.  Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused.  It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary.  Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/d24d6752/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 15, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 15, 2016, at 6:51 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt; I think you guys are making this more complicated than it is. The rules here seem fairly simple:<br>&gt; <br>&gt; 1. The default access level is “internal”.<br>&gt; <br>&gt; 2. A type declared “private” at the top level will be visible to the file only.<br>&gt; <br>&gt; 3. If they are not given an access level, properties declared on the type will get the default “internal” access level, but since their containing type is not visible outside the file, they will not be visible either.<br>&gt; <br>&gt; Thus any properties on the type will effectively inherit the access level of that type, unless the type’s access level is broader than “internal”. For the example of a private type at the top level of a file, its properties will effectively be fileprivate.<br></p><p>Agree.  This is exactly what I have been saying.<br></p><p>&gt; <br>&gt; Charles<br>&gt; <br>&gt;&gt; On Jun 15, 2016, at 5:48 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 15, 2016, at 5:17 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I await their opinions, but even with that change we still have a problem with the philosophy here.  The motivation behind the fileprivate/private distinction is, as you say in the proposal &quot;[a] reliable way to hide implementation details...&quot;.  Why would you want any members you&#39;re trying to hide to be visible in any scope other than the one you create with the decl (which is, without a doubt, also a lexical scope)?  It is analogous with other access control levels: a public outer decl implies public inner members just as a fileprivate one implies fileprivate inner members.  Is it not antithetical to being able to hide things if they remain visible despite the outer decl declaring itself supposedly being sealed?  In your examples, you declare private members that you do not wish to leak into top level scope because they are, after all, supposedly hidden.  Should the same semantics you have given not also apply to private decls no matter where they lie? <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sorry, missed the example in my last reply.<br>&gt;&gt; <br>&gt;&gt;&gt; Should this compile:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private struct Outer {<br>&gt;&gt;&gt;     let inner = Inner()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Outer().inner<br>&gt;&gt; <br>&gt;&gt; Aside from the fact that you can&#39;t write a standalone statement at the top level of a file and it isn&#39;t clear what &#39;Inner&#39; is, yes.  This would be valid:<br>&gt;&gt; <br>&gt;&gt; private struct Outer {<br>&gt;&gt;     struct Inner {}<br>&gt;&gt;     let inner = Inner()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; private let inner = Outer().inner<br>&gt;&gt; <br>&gt;&gt; Note that the top level &#39;inner&#39; must be &#39;private&#39; or &#39;fileprivate&#39; because &#39;Inner&#39; is not visible outside the file.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If this shouldn&#39;t:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Outer {<br>&gt;&gt;&gt;     private let inner = Inner()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Outer {<br>&gt;&gt;&gt;     var inner2 : Inner { return self.inner }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The extension introduces a new scope so this is not valid.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Visibility being a function of scope, lexical or otherwise, seems too coarse a metric for access control in general without further clarification of what the definition of &quot;hidden&quot; is.<br>&gt;&gt; <br>&gt;&gt; The lexical scope of the declaration itself (not a scope introduced by the declaration) is perfectly clear.  You may not like it or agree that it is desirable but it certainly isn&#39;t ambiguous.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/06/15 12:38、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:29 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The meaning of private according to the proposal is not scope-dependent, it is decl-dependent.  The mental gymnastics we are both going through right now are not in the proposal.  I would like them to be.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree that the proposal is too sparse on the details and that is the source of the confusion.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ilya wanted me to write this proposal and only did it himself because I didn’t have time to do it as quickly as he wanted.  I know what the original intent of the proposal was (I can’t speak for the core team on their mental model of it when they accepted it).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That said, the title of the proposal is “scoped access level” and the detailed design says &quot;visible only within that lexical scope”.  And the entire discussion was always about lexical scope.  I believe the reason the “proposed solution” section says “current declaration” is because *most* lexical scopes are introduced by a declaration.  That is sloppy language that should have been cleaned up prior to review.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I appreciate you working on implementing this.  I also understand if you want to hold off until the core team can chime in on the semantics they intend.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2016/06/15 12:26、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:19 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; We have diagnostics specifically to prohibit this case.  You cannot raise the access level of members.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     internal var x : String = &quot;&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; warning: declaring an internal var for a private struct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hence, the highest allowable level of access for x is private and it becomes invisible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would not like the compiler to synthesize this in my code, and if it did I would like the proposal to say it will raise access levels of members as you would like it to.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That diagnostic is a good thing.  I am not suggesting that you to disregard it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What you are missing is that the meaning of `private` is scope-dependent.  The following example is perfectly valid:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;     fileprivate var x : String = “”<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; `fileprivate` inside `Foo` specifies the same visibility as `private` at the top level, thus we are not “raising&quot; the visibility of the member.  If no modifier is provided for `x` it receives the same visibility as its containing type (up to `internal`).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Consider another example:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;     private struct Bar {<br>&gt;&gt;&gt;&gt;&gt;&gt;         var x : String = “”<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In this example we *cannot* mark `x` as `fileprivate` because that *would* raise the visibility of `x` beyond that of `Bar`.  `Bar` is only visible inside `Foo`, not at file scope.  This means that `x` also has visibility throughout the lexical scope of `Foo`, but not outside of it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 12:14、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:04 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 11:47、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:37 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The scope of the *declaration* is not the issue.  The scope of its *members* is.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Let’s consider an example:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   var bar: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // elsewhere in the same file:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var foo = Foo(bar: 42)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; foo.bar = 44<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `Foo` is declared private.  Private for this declaration is at the file scope.  The `bar` member has no access modifier so it has the same visibility as the struct itself, which is file scope.  This will also be true of the implicitly synthesized memberwise initializer.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, it is also private.  It does not inherit its parent scope because, following the letter of the proposal, that symbol will only be visible within the current declaration.  We cannot arbitrarily break access control rules because it is convenient in one special case. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This means that it is possible to initialize `foo` with a newly constructed instance of `Foo` and to modify the `bar` member anywhere else in the same file.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; bar is not visible here.  If it were you could break access control rules.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If `bar` was also declared `private` this would not be possible as its visibility would be restricted to the surrounding scope of the initial declaration of `Foo`.  This means `Foo` would need to provide an explicit initializer or factory method with `fileprivate` visibility in order to be usable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; bar is private.  Declarations within Foo cannot decide to raise that access level to make themselves more visible.  If this should be the case, the proposal must be amended as much.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Members with no explicit access modifier should have the same *visibility* as their containing type (with a maximum implicit visibility of internal), not the same *modifier* as their containing type.  The only case where there is a distinction is the new `private` visibility.  Maybe that is what is causing the confusion?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is not what the proposal says.  The proposal says it is invisible outside the current decl, which is the containing structure here.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The access modifier is applied to `Foo`, not `bar`.  `Foo` is visible in the scope of the “current declaration” (this is badly worded - it should say current scope, which is the file).  Because `Foo` has a visibility lower than `internal` the default visibility of its members match the visibility of `Foo`, which again is the current scope: the file.  The detailed design section of the proposal is sparse, but it correctly uses the phrase &quot;visible only within that lexical scope” rather than the less precise (in the case of top-level code) “current declaration”.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I didn’t write the proposal but I was very heavily involved in the discussions and IIRC I provided the original suggestion for introducing a scoped access modifier.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If my example was the following:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   private var bar: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Then what you are saying would be correct.  However, The example I showed did not provide an access modifier for `bar`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; You cannot just apply the same *access modifier* to members of the type that do not contain an access modifier.  You have to apply the same *visibility* (limited to internal).  When a type is marked as `private` in the lexical scope of the file, its unmodified members will be visible in the same lexical scope as the type itself (which is the file in the current example).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Does this help?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 11:36、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The scope for a top-level declaration is the file itself.  This means that top-level declarations with `private` and `fileprivate` should have the same behavior.  They should not be uninstantiable or unusable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:31 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal.  Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way.  Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused.  It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary.  Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/f8e5baf1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 15, 2016 at 06:00:00pm</p></header><div class="content"><p>Point 3 is *not* how member lookup applies access control levels to unannotated properties of outer structures (see https://github.com/CodaFi/swift/blob/fb9f9536a5760369457d0f9c49599415cbc36e07/lib/Sema/TypeCheckDecl.cpp#L1470) and makes no sense.  They do not default to &quot;internal&quot; when unannotated, they default to the highest possible access level they can get given the decl they&#39;re in.  A private structure will necessarily have private members.  This is the whole point of me raising this issue.  If we were to break containment we would break the very motivation for this proposal.  And if we wish to do this to get this feature right, then the proposal needs to be amended to include that kind of caveat.<br></p><p>This issue will not be resolved by redefining what we think the behavior of the language currently is, it will be fixed by specifying what it will be when this proposal is implemented.<br></p><p>One solution to this would be not to prohibit private on outer decls, but to throw a warning when we see it.  If we wish something more complicated it must be spelled out.<br></p><p>~Robert Widmann<br></p><p>2016/06/15 17:01、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br></p><p>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Jun 15, 2016, at 6:51 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think you guys are making this more complicated than it is. The rules here seem fairly simple:<br>&gt;&gt; <br>&gt;&gt; 1. The default access level is “internal”.<br>&gt;&gt; <br>&gt;&gt; 2. A type declared “private” at the top level will be visible to the file only.<br>&gt;&gt; <br>&gt;&gt; 3. If they are not given an access level, properties declared on the type will get the default “internal” access level, but since their containing type is not visible outside the file, they will not be visible either.<br>&gt;&gt; <br>&gt;&gt; Thus any properties on the type will effectively inherit the access level of that type, unless the type’s access level is broader than “internal”. For the example of a private type at the top level of a file, its properties will effectively be fileprivate.<br>&gt; <br>&gt; Agree.  This is exactly what I have been saying.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 15, 2016, at 5:48 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 15, 2016, at 5:17 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I await their opinions, but even with that change we still have a problem with the philosophy here.  The motivation behind the fileprivate/private distinction is, as you say in the proposal &quot;[a] reliable way to hide implementation details...&quot;.  Why would you want any members you&#39;re trying to hide to be visible in any scope other than the one you create with the decl (which is, without a doubt, also a lexical scope)?  It is analogous with other access control levels: a public outer decl implies public inner members just as a fileprivate one implies fileprivate inner members.  Is it not antithetical to being able to hide things if they remain visible despite the outer decl declaring itself supposedly being sealed?  In your examples, you declare private members that you do not wish to leak into top level scope because they are, after all, supposedly hidden.  Should the same semantics you have given not also apply to private decls no matter where they lie? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, missed the example in my last reply.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Should this compile:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; private struct Outer {<br>&gt;&gt;&gt;&gt;     let inner = Inner()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Outer().inner<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Aside from the fact that you can&#39;t write a standalone statement at the top level of a file and it isn&#39;t clear what &#39;Inner&#39; is, yes.  This would be valid:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private struct Outer {<br>&gt;&gt;&gt;     struct Inner {}<br>&gt;&gt;&gt;     let inner = Inner()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private let inner = Outer().inner<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that the top level &#39;inner&#39; must be &#39;private&#39; or &#39;fileprivate&#39; because &#39;Inner&#39; is not visible outside the file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If this shouldn&#39;t:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Outer {<br>&gt;&gt;&gt;&gt;     private let inner = Inner()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Outer {<br>&gt;&gt;&gt;&gt;     var inner2 : Inner { return self.inner }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The extension introduces a new scope so this is not valid.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Visibility being a function of scope, lexical or otherwise, seems too coarse a metric for access control in general without further clarification of what the definition of &quot;hidden&quot; is.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The lexical scope of the declaration itself (not a scope introduced by the declaration) is perfectly clear.  You may not like it or agree that it is desirable but it certainly isn&#39;t ambiguous.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/06/15 12:38、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:29 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The meaning of private according to the proposal is not scope-dependent, it is decl-dependent.  The mental gymnastics we are both going through right now are not in the proposal.  I would like them to be.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree that the proposal is too sparse on the details and that is the source of the confusion.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Ilya wanted me to write this proposal and only did it himself because I didn’t have time to do it as quickly as he wanted.  I know what the original intent of the proposal was (I can’t speak for the core team on their mental model of it when they accepted it).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That said, the title of the proposal is “scoped access level” and the detailed design says &quot;visible only within that lexical scope”.  And the entire discussion was always about lexical scope.  I believe the reason the “proposed solution” section says “current declaration” is because *most* lexical scopes are introduced by a declaration.  That is sloppy language that should have been cleaned up prior to review.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I appreciate you working on implementing this.  I also understand if you want to hold off until the core team can chime in on the semantics they intend.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 12:26、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:19 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We have diagnostics specifically to prohibit this case.  You cannot raise the access level of members.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     internal var x : String = &quot;&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; warning: declaring an internal var for a private struct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hence, the highest allowable level of access for x is private and it becomes invisible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would not like the compiler to synthesize this in my code, and if it did I would like the proposal to say it will raise access levels of members as you would like it to.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That diagnostic is a good thing.  I am not suggesting that you to disregard it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; What you are missing is that the meaning of `private` is scope-dependent.  The following example is perfectly valid:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     fileprivate var x : String = “”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; `fileprivate` inside `Foo` specifies the same visibility as `private` at the top level, thus we are not “raising&quot; the visibility of the member.  If no modifier is provided for `x` it receives the same visibility as its containing type (up to `internal`).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Consider another example:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     private struct Bar {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         var x : String = “”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In this example we *cannot* mark `x` as `fileprivate` because that *would* raise the visibility of `x` beyond that of `Bar`.  `Bar` is only visible inside `Foo`, not at file scope.  This means that `x` also has visibility throughout the lexical scope of `Foo`, but not outside of it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 12:14、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 2:04 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 11:47、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:37 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The scope of the *declaration* is not the issue.  The scope of its *members* is.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Let’s consider an example:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   var bar: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // elsewhere in the same file:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var foo = Foo(bar: 42)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; foo.bar = 44<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `Foo` is declared private.  Private for this declaration is at the file scope.  The `bar` member has no access modifier so it has the same visibility as the struct itself, which is file scope.  This will also be true of the implicitly synthesized memberwise initializer.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, it is also private.  It does not inherit its parent scope because, following the letter of the proposal, that symbol will only be visible within the current declaration.  We cannot arbitrarily break access control rules because it is convenient in one special case. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This means that it is possible to initialize `foo` with a newly constructed instance of `Foo` and to modify the `bar` member anywhere else in the same file.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; bar is not visible here.  If it were you could break access control rules.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If `bar` was also declared `private` this would not be possible as its visibility would be restricted to the surrounding scope of the initial declaration of `Foo`.  This means `Foo` would need to provide an explicit initializer or factory method with `fileprivate` visibility in order to be usable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; bar is private.  Declarations within Foo cannot decide to raise that access level to make themselves more visible.  If this should be the case, the proposal must be amended as much.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Members with no explicit access modifier should have the same *visibility* as their containing type (with a maximum implicit visibility of internal), not the same *modifier* as their containing type.  The only case where there is a distinction is the new `private` visibility.  Maybe that is what is causing the confusion?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is not what the proposal says.  The proposal says it is invisible outside the current decl, which is the containing structure here.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The access modifier is applied to `Foo`, not `bar`.  `Foo` is visible in the scope of the “current declaration” (this is badly worded - it should say current scope, which is the file).  Because `Foo` has a visibility lower than `internal` the default visibility of its members match the visibility of `Foo`, which again is the current scope: the file.  The detailed design section of the proposal is sparse, but it correctly uses the phrase &quot;visible only within that lexical scope” rather than the less precise (in the case of top-level code) “current declaration”.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I didn’t write the proposal but I was very heavily involved in the discussions and IIRC I provided the original suggestion for introducing a scoped access modifier.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If my example was the following:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; private struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   private var bar: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Then what you are saying would be correct.  However, The example I showed did not provide an access modifier for `bar`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; You cannot just apply the same *access modifier* to members of the type that do not contain an access modifier.  You have to apply the same *visibility* (limited to internal).  When a type is marked as `private` in the lexical scope of the file, its unmodified members will be visible in the same lexical scope as the type itself (which is the file in the current example).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Does this help?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/15 11:36、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The scope for a top-level declaration is the file itself.  This means that top-level declarations with `private` and `fileprivate` should have the same behavior.  They should not be uninstantiable or unusable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 15, 2016, at 1:31 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal.  Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way.  Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused.  It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary.  Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/927f9325/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June 15, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jun 15, 2016, at 8:36 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Point 3 is *not* how member lookup applies access control levels to unannotated properties of outer structures (see https://github.com/CodaFi/swift/blob/fb9f9536a5760369457d0f9c49599415cbc36e07/lib/Sema/TypeCheckDecl.cpp#L1470 &lt;https://github.com/CodaFi/swift/blob/fb9f9536a5760369457d0f9c49599415cbc36e07/lib/Sema/TypeCheckDecl.cpp#L1470&gt;) and makes no sense.  They do not default to &quot;internal&quot; when unannotated, they default to the highest possible access level they can get given the decl they&#39;re in.  A private structure will necessarily have private members.  This is the whole point of me raising this issue.  If we were to break containment we would break the very motivation for this proposal.  And if we wish to do this to get this feature right, then the proposal needs to be amended to include that kind of caveat.<br></p><p>This isn’t correct. If the outer type is marked “public”, and its properties are not annotated, those properties will be internal, *not* public, and you will not be able to see them outside of the module.<br></p><p>The rule can basically be summed up as “internal by default, unless we can’t because our enclosing type is more restrictive than internal. Then, be as visible as the enclosing type is.&quot;<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/7f24c888/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 15, 2016 at 08:00:00pm</p></header><div class="content"><p>That is a different discussion entirely.  Once you fall below internal then we do not default to internal, we default to the maximum access level of the outer decl.  Read that linked part of the type checker if you don&#39;t believe me.  I also had to fix several hundred lines of SwiftPM and corelibs code that was failing to build because of this exact access control schema in apple/swift#3000.  You&#39;ll notice I effectively changed two lines in Sema and this was the fallout.  I did nothing special to change our existing access control mechanism, it&#39;s just how it has always worked.  Try declaring this explicitly and see the diagnostic we emit, then it&#39;ll be easier to see why this is a problem:<br></p><p>private struct X {<br>   internal var x : String = &quot;&quot; // expected-warning<br>}<br></p><p>~Robert Widmann<br></p><p>2016/06/15 18:47、Charles Srstka &lt;cocoadev at charlessoft.com&gt; のメッセージ:<br></p><p>&gt;&gt; On Jun 15, 2016, at 8:36 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Point 3 is *not* how member lookup applies access control levels to unannotated properties of outer structures (see https://github.com/CodaFi/swift/blob/fb9f9536a5760369457d0f9c49599415cbc36e07/lib/Sema/TypeCheckDecl.cpp#L1470) and makes no sense.  They do not default to &quot;internal&quot; when unannotated, they default to the highest possible access level they can get given the decl they&#39;re in.  A private structure will necessarily have private members.  This is the whole point of me raising this issue.  If we were to break containment we would break the very motivation for this proposal.  And if we wish to do this to get this feature right, then the proposal needs to be amended to include that kind of caveat.<br>&gt; <br>&gt; This isn’t correct. If the outer type is marked “public”, and its properties are not annotated, those properties will be internal, *not* public, and you will not be able to see them outside of the module.<br>&gt; <br>&gt; The rule can basically be summed up as “internal by default, unless we can’t because our enclosing type is more restrictive than internal. Then, be as visible as the enclosing type is.&quot;<br>&gt; <br>&gt; Charles<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/f2930693/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 15, 2016 at 08:00:00pm</p></header><div class="content"><p>Also consider what would happen if we did allow access control to escalate here: Suppose that code did not emit a diagnostic, then the member is still private because you cannot reference the class outside of file scope.  You see, even if we did escalate access control for unannotated members, even if we did that (which we don&#39;t) you wouldn&#39;t even be able to reap the benefits.  It makes no sense.<br></p><p>~Robert Widmann<br></p><p>2016/06/15 18:47、Charles Srstka &lt;cocoadev at charlessoft.com&gt; のメッセージ:<br></p><p>&gt;&gt; On Jun 15, 2016, at 8:36 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Point 3 is *not* how member lookup applies access control levels to unannotated properties of outer structures (see https://github.com/CodaFi/swift/blob/fb9f9536a5760369457d0f9c49599415cbc36e07/lib/Sema/TypeCheckDecl.cpp#L1470) and makes no sense.  They do not default to &quot;internal&quot; when unannotated, they default to the highest possible access level they can get given the decl they&#39;re in.  A private structure will necessarily have private members.  This is the whole point of me raising this issue.  If we were to break containment we would break the very motivation for this proposal.  And if we wish to do this to get this feature right, then the proposal needs to be amended to include that kind of caveat.<br>&gt; <br>&gt; This isn’t correct. If the outer type is marked “public”, and its properties are not annotated, those properties will be internal, *not* public, and you will not be able to see them outside of the module.<br>&gt; <br>&gt; The rule can basically be summed up as “internal by default, unless we can’t because our enclosing type is more restrictive than internal. Then, be as visible as the enclosing type is.&quot;<br>&gt; <br>&gt; Charles<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/570b9cfc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June 15, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jun 15, 2016, at 10:46 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; That is a different discussion entirely.  Once you fall below internal then we do not default to internal, we default to the maximum access level of the outer decl.  Read that linked part of the type checker if you don&#39;t believe me.  I also had to fix several hundred lines of SwiftPM and corelibs code that was failing to build because of this exact access control schema in apple/swift#3000.  You&#39;ll notice I effectively changed two lines in Sema and this was the fallout.  I did nothing special to change our existing access control mechanism, it&#39;s just how it has always worked.  Try declaring this explicitly and see the diagnostic we emit, then it&#39;ll be easier to see why this is a problem:<br>&gt; <br>&gt; private struct X {<br>&gt;    internal var x : String = &quot;&quot; // expected-warning<br>&gt; }<br>&gt; <br>&gt; ~Robert Widmann<br></p><p>The statement was that &quot;They do not default to ‘internal&#39; when unannotated, they default to the highest possible access level they can get given the decl they&#39;re in.” This is demonstrably untrue, since if the type they’re in is public, the highest possible access level they could get would be public, and unannotated properties in a public type are *not* public. They are internal.<br></p><p>&gt; On Jun 15, 2016, at 10:49 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Also consider what would happen if we did allow access control to escalate here: Suppose that code did not emit a diagnostic, then the member is still private because you cannot reference the class outside of file scope.<br></p><p>Which is… exactly what we want.<br></p><p>&gt; You see, even if we did escalate access control for unannotated members, even if we did that (which we don&#39;t) you wouldn&#39;t even be able to reap the benefits.  It makes no sense.<br></p><p><br>A good way to think of it is in terms of what permissions are *removed* by the access modifiers, rather than *added*. Then, everything makes perfect sense:<br></p><p>Public removes nothing.<br>Internal removes access outside a module.<br>Fileprivate removes access outside a file.<br>Private removes access outside a declaration.<br></p><p>If you have an internal property within a public type, the “public” modifier removes nothing, and the “internal” modifier then removes access from outside that module. The result is access from only within the module.<br></p><p>If you have an internal property within an internal type, the “internal” modifier on the type removes access from outside the module, and then the “internal” modifier on the property would remove access from outside the module, except that such access is already removed. Result is access from only within the module.<br></p><p>With an internal property inside a private type within another type, the “private” modifier on the type removes access from outside its parent type, and the “internal” modifier removes access from outside the module—but since no entities outside the type’s parent type currently have access, and since the parent type is in the current module anyway, this once again has no effect. Result is that the property is only accessible from inside its parent type.<br></p><p>With an internal property inside a private type that’s at the top of the file’s scope, the “private” modifier on the type removes access from outside the file, and the “internal” modifier removes access from outside the module—but since no entities outside the file currently have access, and since the file is in the current module, this once again has no effect. Result is that the property is only accessible from inside the current file.<br></p><p>And etc.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/1cb080bb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 15, 2016 at 09:00:00pm</p></header><div class="content"><p>Charles we&#39;ve diverged from the actual issue at hand to nitpick my English.  Read the code (that std::min tho!).  We have a problem here and no obvious solution that doesn&#39;t involve special-casing parts of this proposal.  Do you have a solution or shall we take this offline?  I can provide you my iMessage information in a person email if you wish to discuss this with me or any other members of the team, but the list is not the most productive place for this.<br></p><p>Thanks,<br></p><p>~Robert Widmann<br></p><p>2016/06/15 21:04、Charles Srstka &lt;cocoadev at charlessoft.com&gt; のメッセージ:<br></p><p>&gt;&gt; On Jun 15, 2016, at 10:46 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; That is a different discussion entirely.  Once you fall below internal then we do not default to internal, we default to the maximum access level of the outer decl.  Read that linked part of the type checker if you don&#39;t believe me.  I also had to fix several hundred lines of SwiftPM and corelibs code that was failing to build because of this exact access control schema in apple/swift#3000.  You&#39;ll notice I effectively changed two lines in Sema and this was the fallout.  I did nothing special to change our existing access control mechanism, it&#39;s just how it has always worked.  Try declaring this explicitly and see the diagnostic we emit, then it&#39;ll be easier to see why this is a problem:<br>&gt;&gt; <br>&gt;&gt; private struct X {<br>&gt;&gt;    internal var x : String = &quot;&quot; // expected-warning<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt; <br>&gt; The statement was that &quot;They do not default to ‘internal&#39; when unannotated, they default to the highest possible access level they can get given the decl they&#39;re in.” This is demonstrably untrue, since if the type they’re in is public, the highest possible access level they could get would be public, and unannotated properties in a public type are *not* public. They are internal.<br>&gt; <br>&gt;&gt; On Jun 15, 2016, at 10:49 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Also consider what would happen if we did allow access control to escalate here: Suppose that code did not emit a diagnostic, then the member is still private because you cannot reference the class outside of file scope.<br>&gt; <br>&gt; Which is… exactly what we want.<br>&gt; <br>&gt;&gt; You see, even if we did escalate access control for unannotated members, even if we did that (which we don&#39;t) you wouldn&#39;t even be able to reap the benefits.  It makes no sense.<br>&gt; <br>&gt; <br>&gt; A good way to think of it is in terms of what permissions are *removed* by the access modifiers, rather than *added*. Then, everything makes perfect sense:<br>&gt; <br>&gt; Public removes nothing.<br>&gt; Internal removes access outside a module.<br>&gt; Fileprivate removes access outside a file.<br>&gt; Private removes access outside a declaration.<br>&gt; <br>&gt; If you have an internal property within a public type, the “public” modifier removes nothing, and the “internal” modifier then removes access from outside that module. The result is access from only within the module.<br>&gt; <br>&gt; If you have an internal property within an internal type, the “internal” modifier on the type removes access from outside the module, and then the “internal” modifier on the property would remove access from outside the module, except that such access is already removed. Result is access from only within the module.<br>&gt; <br>&gt; With an internal property inside a private type within another type, the “private” modifier on the type removes access from outside its parent type, and the “internal” modifier removes access from outside the module―but since no entities outside the type’s parent type currently have access, and since the parent type is in the current module anyway, this once again has no effect. Result is that the property is only accessible from inside its parent type.<br>&gt; <br>&gt; With an internal property inside a private type that’s at the top of the file’s scope, the “private” modifier on the type removes access from outside the file, and the “internal” modifier removes access from outside the module―but since no entities outside the file currently have access, and since the file is in the current module, this once again has no effect. Result is that the property is only accessible from inside the current file.<br>&gt; <br>&gt; And etc.<br>&gt; <br>&gt; Charles<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/fc47a2fb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 16, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; Charles we&#39;ve diverged from the actual issue at hand to nitpick my English.  Read the code (that std::min tho!).  We have a problem here and no obvious solution that doesn&#39;t involve special-casing parts of this proposal.<br></p><p>I think it might be more helpful to think of it this way:<br></p><p>1. The mental model has generally been that, absent a specific access control keyword, a member is as visible as the enclosing type, except that it is never automatically `public`.<br></p><p>2. Because of the way the old public/internal/private access control model was defined, this was equivalent to applying the enclosing type&#39;s access control keyword to the member. Therefore, that was the implementation model chosen by the compiler.<br></p><p>3. However, now that we have a scope-dependent access control level, these two models provide divergent behavior, and we must use a different implementation model. (We know that the old implementation model is not an accurate match for the mental model because scoped `private` provides sensical behavior in the mental model, but nonsensical behavior in the implementation model.)<br></p><p>4. We understand what the effect of this new implementation model *should* be: The members of the private type should be as visible as the private type, unless they are themselves marked private.<br></p><p>5. However, we&#39;re not exactly sure how this new model should be implemented, and core team guidance is probably necessary. In particular, these children of `private` types have a somewhat mysterious new property: their visibility cannot be accurately described by any existing access control keyword. It&#39;s not clear how to cope with that. (The easiest solution―add a new access control level which is basically &quot;private to me and my parent&quot;―won&#39;t do the trick: members of nested types, like `z` in `private struct X { struct Y { var z: Int } }`, should be visible two levels up. The visibility of these members is genuinely complicated and context-specific.)<br></p><p>6. With the core team tied up at WWDC, you may want to temporarily forbid the use of `private` on a type and revisit the matter when people are less busy; if necessary, we could even ship Swift 3 that way. Or you may want to consider making a guess as to a good implementation model to apply. Two suggestions for alternate implementation models:<br></p><p>a. Introduce a `parent` access level, meaning &quot;visible in scopes within this file where the parent is visible&quot;, which is between `fileprivate` and `private`. Just as `internal` is the maximum inherited access level, `parent` is the minimum, so the members of a `private` type would inherit `parent` visibility. `parent` might be an entirely compiler-internal concept, with no utterable access control keyword.<br></p><p>b. Instead of inheriting an access control modifier&#39;s visibility, always set unspecified ones to `internal`, but make sure they stay effectively invisible in scopes where their parent is not visible. Introduce a warning or error for *explicitly* specifying a modifier that exceeds the parent&#39;s visibility, but don&#39;t emit it for implicit `internal`s.<br></p><p>c. Combine the two: `parent` means &quot;visible wherever the parent is, whether within this file or not, except not public&quot;, and is *always* the default access level if nothing else is specified. (`parent` doesn&#39;t fit neatly into the access control hierarchy, but on the other hand, it&#39;s the closest match to the mental model.)<br></p><p>A final note: I usually try not to complain about accepted proposals, but I&#39;ll make an exception this time. I pointed out during the discussion and review that this proposal was unclear and that scoped `private` was quite different from our existing access control behaviors. I won&#39;t claim that I predicted this problem, but I&#39;m not surprised to find that we&#39;re running into it.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 16, 2016 at 12:00:00am</p></header><div class="content"><p>I agree with the mental model, and the proposed solutions are interesting.  I believe a diagnostic is the appropriate middle ground and I&#39;ll be pushing that in part two of the implementation after we merge through the corelibs access control changes.  That could change depending on how core responds, but it works for now.<br></p><p>~Robert Widmann<br></p><p>2016/06/16 0:09、Brent Royal-Gordon &lt;brent at architechies.com&gt; のメッセージ:<br></p><p>&gt;&gt; Charles we&#39;ve diverged from the actual issue at hand to nitpick my English.  Read the code (that std::min tho!).  We have a problem here and no obvious solution that doesn&#39;t involve special-casing parts of this proposal.<br>&gt; <br>&gt; I think it might be more helpful to think of it this way:<br>&gt; <br>&gt; 1. The mental model has generally been that, absent a specific access control keyword, a member is as visible as the enclosing type, except that it is never automatically `public`.<br>&gt; <br>&gt; 2. Because of the way the old public/internal/private access control model was defined, this was equivalent to applying the enclosing type&#39;s access control keyword to the member. Therefore, that was the implementation model chosen by the compiler.<br>&gt; <br>&gt; 3. However, now that we have a scope-dependent access control level, these two models provide divergent behavior, and we must use a different implementation model. (We know that the old implementation model is not an accurate match for the mental model because scoped `private` provides sensical behavior in the mental model, but nonsensical behavior in the implementation model.)<br>&gt; <br>&gt; 4. We understand what the effect of this new implementation model *should* be: The members of the private type should be as visible as the private type, unless they are themselves marked private.<br>&gt; <br>&gt; 5. However, we&#39;re not exactly sure how this new model should be implemented, and core team guidance is probably necessary. In particular, these children of `private` types have a somewhat mysterious new property: their visibility cannot be accurately described by any existing access control keyword. It&#39;s not clear how to cope with that. (The easiest solution―add a new access control level which is basically &quot;private to me and my parent&quot;―won&#39;t do the trick: members of nested types, like `z` in `private struct X { struct Y { var z: Int } }`, should be visible two levels up. The visibility of these members is genuinely complicated and context-specific.)<br>&gt; <br>&gt; 6. With the core team tied up at WWDC, you may want to temporarily forbid the use of `private` on a type and revisit the matter when people are less busy; if necessary, we could even ship Swift 3 that way. Or you may want to consider making a guess as to a good implementation model to apply. Two suggestions for alternate implementation models:<br>&gt; <br>&gt; a. Introduce a `parent` access level, meaning &quot;visible in scopes within this file where the parent is visible&quot;, which is between `fileprivate` and `private`. Just as `internal` is the maximum inherited access level, `parent` is the minimum, so the members of a `private` type would inherit `parent` visibility. `parent` might be an entirely compiler-internal concept, with no utterable access control keyword.<br>&gt; <br>&gt; b. Instead of inheriting an access control modifier&#39;s visibility, always set unspecified ones to `internal`, but make sure they stay effectively invisible in scopes where their parent is not visible. Introduce a warning or error for *explicitly* specifying a modifier that exceeds the parent&#39;s visibility, but don&#39;t emit it for implicit `internal`s.<br>&gt; <br>&gt; c. Combine the two: `parent` means &quot;visible wherever the parent is, whether within this file or not, except not public&quot;, and is *always* the default access level if nothing else is specified. (`parent` doesn&#39;t fit neatly into the access control hierarchy, but on the other hand, it&#39;s the closest match to the mental model.)<br>&gt; <br>&gt; A final note: I usually try not to complain about accepted proposals, but I&#39;ll make an exception this time. I pointed out during the discussion and review that this proposal was unclear and that scoped `private` was quite different from our existing access control behaviors. I won&#39;t claim that I predicted this problem, but I&#39;m not surprised to find that we&#39;re running into it.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 16, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; 6. With the core team tied up at WWDC, you may want to temporarily forbid the use of `private` on a type and revisit the matter when people are less busy; if necessary, we could even ship Swift 3 that way. Or you may want to consider making a guess as to a good implementation model to apply. Two suggestions for alternate implementation models:<br>&gt; <br>&gt; a. Introduce a `parent` access level, meaning &quot;visible in scopes within this file where the parent is visible&quot;, which is between `fileprivate` and `private`. Just as `internal` is the maximum inherited access level, `parent` is the minimum, so the members of a `private` type would inherit `parent` visibility. `parent` might be an entirely compiler-internal concept, with no utterable access control keyword.<br></p><p>Thinking about this more, I notice that `fileprivate` as currently defined doesn&#39;t actually make any sense to say inside a `private` type: if your parent type has less-than-file-wide visibility, nothing in the file that&#39;s outside its scope can see you anyway. Therefore, we could redefine `fileprivate` thusly:<br></p><p>	1. A member with `fileprivate` visibility is visible within the scope in which the nearest containing `private` type is visible.<br>	2. If there are no containing `private` types, it is visible within the file containing it.<br>	3. Just as the members of a `public` type are `internal`, so the members of a `private` type are `fileprivate`.<br></p><p>This kind of suggests that we ought to rename `fileprivate` to something that, y&#39;know, doesn&#39;t say &quot;file&quot; in it. However, I can scarcely imagine the results of a round of bikeshedding without parental supervision from the core team, so I don&#39;t dare make any suggestions.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 16, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>On Jun 16, 2016, at 5:20 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; 6. With the core team tied up at WWDC, you may want to temporarily forbid the use of `private` on a type and revisit the matter when people are less busy; if necessary, we could even ship Swift 3 that way. Or you may want to consider making a guess as to a good implementation model to apply. Two suggestions for alternate implementation models:<br>&gt;&gt; <br>&gt;&gt; a. Introduce a `parent` access level, meaning &quot;visible in scopes within this file where the parent is visible&quot;, which is between `fileprivate` and `private`. Just as `internal` is the maximum inherited access level, `parent` is the minimum, so the members of a `private` type would inherit `parent` visibility. `parent` might be an entirely compiler-internal concept, with no utterable access control keyword.<br>&gt; <br>&gt; Thinking about this more, I notice that `fileprivate` as currently defined doesn&#39;t actually make any sense to say inside a `private` type: if your parent type has less-than-file-wide visibility, nothing in the file that&#39;s outside its scope can see you anyway. Therefore, we could redefine `fileprivate` thusly:<br>&gt; <br>&gt;    1. A member with `fileprivate` visibility is visible within the scope in which the nearest containing `private` type is visible.<br>&gt;    2. If there are no containing `private` types, it is visible within the file containing it.<br>&gt;    3. Just as the members of a `public` type are `internal`, so the members of a `private` type are `fileprivate`.<br>&gt; <br>&gt; This kind of suggests that we ought to rename `fileprivate` to something that, y&#39;know, doesn&#39;t say &quot;file&quot; in it. However, I can scarcely imagine the results of a round of bikeshedding without parental supervision from the core team, so I don&#39;t dare make any suggestions.<br></p><p>I am not convinced this is necessary.  If there *is* a containing &#39;private&#39; scope you can just leave the member unannotated to get this behavior.  If there isn&#39;t you can use &#39;fileprivate&#39; as it is already defined.  Why is that not sufficient?<br></p><p>If you really want a second, more nuanced and complex scope-dependent access control mechanism I think you&#39;ll need to submit a proposal for it.  A simple renaming to &#39;fileprivate&#39; is what has been accepted thus far.  <br></p><p>The main argument for what you suggest is that it would provide a way to ensure visibility of the member is*never* more than the file, but is as visible as possible within the file, while being less sensitive to changes in visibility of surrounding scopes.  IMO we need to get some experience with SE-0025 in real code before we know whether this is a problem that needs solving or not.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 16, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; I am not convinced this is necessary.  If there *is* a containing &#39;private&#39; scope you can just leave the member unannotated to get this behavior.  If there isn&#39;t you can use &#39;fileprivate&#39; as it is already defined.  Why is that not sufficient?<br></p><p>Here&#39;s what&#39;s making me think about this: In our current generated interfaces, we mark every symbol with an access modifier (except for protocol requirements, which cannot take access modifiers). This is because every kind of visibility *has* an associated access modifier. They are all utterable, and this makes everything clearer, because when you want to be explicit you can always write it out.<br></p><p>I don&#39;t like the idea of introducing unutterable access control levels, or marking things with confusingly broad-seeming access modifiers, or complicating the access control model with artificial levels. On those axes, I would score the various options as:<br></p><p>	Worst: Having an extra, unutterable access modifier that floats relative to the other access levels.<br></p><p>	Awful: Having an extra access modifiers that floats relative to the other access levels, but has a name (like `default`).<br></p><p>	Bad: Having an extra, unutterable access modifier between `fileprivate` and `private`.<br></p><p>	Okay: Using `internal` whenever there&#39;s no access modifier, and not warning if the effective scope is smaller.<br></p><p>	Good: Having an extra access modifier between `fileprivate` and `private`, but which has a name (like `inheritprivate`) <br></p><p>	Better: Changing the definition of `fileprivate` to be within the surrounding private type if there is one, without changing the keyword.<br></p><p>	Best: Changing the definition of `fileprivate` to be within the surrounding private type if there is one, and changing the keyword to match.<br></p><p>If I were implementing it, I think what I would do at this point is:<br></p><p>	1. Implement the feature with support for private types artificially disabled. At this point, you have provided a strict subset of what the proposal specifies; if the implementation is good enough, that ought to be mergeable.<br></p><p>	2. Create a new branch from that commit which implements the change to `fileprivate`&#39;s semantics I described. This is a highly plausible way to fill the gap in the proposal, and exploring it seems like a sensible option.<br></p><p>	3. Leave the keyword alone; that&#39;s up to the core team to change.<br></p><p>Of course, I&#39;m *not* implementing it; Robert Widmann is. So I think that for step 2 he should implement whichever solution he thinks is best, or if he&#39;s worried about wasting work, simply pause at that point and wait for core team input.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 16, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 16, 2016, at 8:27 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; I am not convinced this is necessary.  If there *is* a containing &#39;private&#39; scope you can just leave the member unannotated to get this behavior.  If there isn&#39;t you can use &#39;fileprivate&#39; as it is already defined.  Why is that not sufficient?<br>&gt; <br>&gt; Here&#39;s what&#39;s making me think about this: In our current generated interfaces, we mark every symbol with an access modifier (except for protocol requirements, which cannot take access modifiers). This is because every kind of visibility *has* an associated access modifier. They are all utterable, and this makes everything clearer, because when you want to be explicit you can always write it out.<br>&gt; <br>&gt; I don&#39;t like the idea of introducing unutterable access control levels, or marking things with confusingly broad-seeming access modifiers, or complicating the access control model with artificial levels. On those axes, I would score the various options as:<br>&gt; <br>&gt; 	Worst: Having an extra, unutterable access modifier that floats relative to the other access levels.<br>&gt; <br>&gt; 	Awful: Having an extra access modifiers that floats relative to the other access levels, but has a name (like `default`).<br>&gt; <br>&gt; 	Bad: Having an extra, unutterable access modifier between `fileprivate` and `private`.<br>&gt; <br>&gt; 	Okay: Using `internal` whenever there&#39;s no access modifier, and not warning if the effective scope is smaller.<br>&gt; <br>&gt; 	Good: Having an extra access modifier between `fileprivate` and `private`, but which has a name (like `inheritprivate`) <br>&gt; <br>&gt; 	Better: Changing the definition of `fileprivate` to be within the surrounding private type if there is one, without changing the keyword.<br>&gt; <br>&gt; 	Best: Changing the definition of `fileprivate` to be within the surrounding private type if there is one, and changing the keyword to match.<br></p><p>Thanks, this makes your argument more clear.  To summarize, you believe there should be an utterable access modifier corresponding to all possible levels of visibility (and you prefer to do that without introducing a 5th access modifier), correct?<br></p><p>This requires changing semantics of `fileprivate` (or introducing a new access modifier) which is not in scope for SE-0025.  It is not just a rename of the old `private` which was in scope for SE-0025.  I believe this means it would require a new proposal (of course the core team is the final arbiter of that).  <br></p><p>The community should have a discussion and review regarding whether to adopt your suggested semantic change or not.  Do you disagree?<br></p><p>&gt; <br>&gt; If I were implementing it, I think what I would do at this point is:<br>&gt; <br>&gt; 	1. Implement the feature with support for private types artificially disabled. At this point, you have provided a strict subset of what the proposal specifies; if the implementation is good enough, that ought to be mergeable.<br>&gt; <br>&gt; 	2. Create a new branch from that commit which implements the change to `fileprivate`&#39;s semantics I described. This is a highly plausible way to fill the gap in the proposal, and exploring it seems like a sensible option.<br>&gt; <br>&gt; 	3. Leave the keyword alone; that&#39;s up to the core team to change.<br>&gt; <br>&gt; Of course, I&#39;m *not* implementing it; Robert Widmann is. So I think that for step 2 he should implement whichever solution he thinks is best, or if he&#39;s worried about wasting work, simply pause at that point and wait for core team input.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 16, 2016 at 07:00:00am</p></header><div class="content"><p>Go checkout my branch!  And see the discussion there for how your proposal has impacted corelibs.<br></p><p>~Robert Widmann<br></p><p>2016/06/16 5:50、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br></p><p>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Jun 16, 2016, at 5:20 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; 6. With the core team tied up at WWDC, you may want to temporarily forbid the use of `private` on a type and revisit the matter when people are less busy; if necessary, we could even ship Swift 3 that way. Or you may want to consider making a guess as to a good implementation model to apply. Two suggestions for alternate implementation models:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; a. Introduce a `parent` access level, meaning &quot;visible in scopes within this file where the parent is visible&quot;, which is between `fileprivate` and `private`. Just as `internal` is the maximum inherited access level, `parent` is the minimum, so the members of a `private` type would inherit `parent` visibility. `parent` might be an entirely compiler-internal concept, with no utterable access control keyword.<br>&gt;&gt; <br>&gt;&gt; Thinking about this more, I notice that `fileprivate` as currently defined doesn&#39;t actually make any sense to say inside a `private` type: if your parent type has less-than-file-wide visibility, nothing in the file that&#39;s outside its scope can see you anyway. Therefore, we could redefine `fileprivate` thusly:<br>&gt;&gt; <br>&gt;&gt;   1. A member with `fileprivate` visibility is visible within the scope in which the nearest containing `private` type is visible.<br>&gt;&gt;   2. If there are no containing `private` types, it is visible within the file containing it.<br>&gt;&gt;   3. Just as the members of a `public` type are `internal`, so the members of a `private` type are `fileprivate`.<br>&gt;&gt; <br>&gt;&gt; This kind of suggests that we ought to rename `fileprivate` to something that, y&#39;know, doesn&#39;t say &quot;file&quot; in it. However, I can scarcely imagine the results of a round of bikeshedding without parental supervision from the core team, so I don&#39;t dare make any suggestions.<br>&gt; <br>&gt; I am not convinced this is necessary.  If there *is* a containing &#39;private&#39; scope you can just leave the member unannotated to get this behavior.  If there isn&#39;t you can use &#39;fileprivate&#39; as it is already defined.  Why is that not sufficient?<br>&gt; <br>&gt; If you really want a second, more nuanced and complex scope-dependent access control mechanism I think you&#39;ll need to submit a proposal for it.  A simple renaming to &#39;fileprivate&#39; is what has been accepted thus far.  <br>&gt; <br>&gt; The main argument for what you suggest is that it would provide a way to ensure visibility of the member is*never* more than the file, but is as visible as possible within the file, while being less sensitive to changes in visibility of surrounding scopes.  IMO we need to get some experience with SE-0025 in real code before we know whether this is a problem that needs solving or not.<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 16, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 16, 2016, at 9:23 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Go checkout my branch!  And see the discussion there for how your proposal has impacted corelibs.<br></p><p>I’ll be happy to.  Can you please provide a link to the branch and discussion?<br></p><p>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/06/16 5:50、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On Jun 16, 2016, at 5:20 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; 6. With the core team tied up at WWDC, you may want to temporarily forbid the use of `private` on a type and revisit the matter when people are less busy; if necessary, we could even ship Swift 3 that way. Or you may want to consider making a guess as to a good implementation model to apply. Two suggestions for alternate implementation models:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; a. Introduce a `parent` access level, meaning &quot;visible in scopes within this file where the parent is visible&quot;, which is between `fileprivate` and `private`. Just as `internal` is the maximum inherited access level, `parent` is the minimum, so the members of a `private` type would inherit `parent` visibility. `parent` might be an entirely compiler-internal concept, with no utterable access control keyword.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thinking about this more, I notice that `fileprivate` as currently defined doesn&#39;t actually make any sense to say inside a `private` type: if your parent type has less-than-file-wide visibility, nothing in the file that&#39;s outside its scope can see you anyway. Therefore, we could redefine `fileprivate` thusly:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  1. A member with `fileprivate` visibility is visible within the scope in which the nearest containing `private` type is visible.<br>&gt;&gt;&gt;  2. If there are no containing `private` types, it is visible within the file containing it.<br>&gt;&gt;&gt;  3. Just as the members of a `public` type are `internal`, so the members of a `private` type are `fileprivate`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This kind of suggests that we ought to rename `fileprivate` to something that, y&#39;know, doesn&#39;t say &quot;file&quot; in it. However, I can scarcely imagine the results of a round of bikeshedding without parental supervision from the core team, so I don&#39;t dare make any suggestions.<br>&gt;&gt; <br>&gt;&gt; I am not convinced this is necessary.  If there *is* a containing &#39;private&#39; scope you can just leave the member unannotated to get this behavior.  If there isn&#39;t you can use &#39;fileprivate&#39; as it is already defined.  Why is that not sufficient?<br>&gt;&gt; <br>&gt;&gt; If you really want a second, more nuanced and complex scope-dependent access control mechanism I think you&#39;ll need to submit a proposal for it.  A simple renaming to &#39;fileprivate&#39; is what has been accepted thus far.  <br>&gt;&gt; <br>&gt;&gt; The main argument for what you suggest is that it would provide a way to ensure visibility of the member is*never* more than the file, but is as visible as possible within the file, while being less sensitive to changes in visibility of surrounding scopes.  IMO we need to get some experience with SE-0025 in real code before we know whether this is a problem that needs solving or not.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 16, 2016 at 07:00:00am</p></header><div class="content"><p>Find it under our own pull requests on apple/swift#3000<br></p><p>~Robert Widmann<br></p><p>2016/06/16 7:28、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br></p><p>&gt; <br>&gt;&gt; On Jun 16, 2016, at 9:23 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Go checkout my branch!  And see the discussion there for how your proposal has impacted corelibs.<br>&gt; <br>&gt; I’ll be happy to.  Can you please provide a link to the branch and discussion?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/06/16 5:50、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 16, 2016, at 5:20 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 6. With the core team tied up at WWDC, you may want to temporarily forbid the use of `private` on a type and revisit the matter when people are less busy; if necessary, we could even ship Swift 3 that way. Or you may want to consider making a guess as to a good implementation model to apply. Two suggestions for alternate implementation models:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; a. Introduce a `parent` access level, meaning &quot;visible in scopes within this file where the parent is visible&quot;, which is between `fileprivate` and `private`. Just as `internal` is the maximum inherited access level, `parent` is the minimum, so the members of a `private` type would inherit `parent` visibility. `parent` might be an entirely compiler-internal concept, with no utterable access control keyword.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thinking about this more, I notice that `fileprivate` as currently defined doesn&#39;t actually make any sense to say inside a `private` type: if your parent type has less-than-file-wide visibility, nothing in the file that&#39;s outside its scope can see you anyway. Therefore, we could redefine `fileprivate` thusly:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. A member with `fileprivate` visibility is visible within the scope in which the nearest containing `private` type is visible.<br>&gt;&gt;&gt;&gt; 2. If there are no containing `private` types, it is visible within the file containing it.<br>&gt;&gt;&gt;&gt; 3. Just as the members of a `public` type are `internal`, so the members of a `private` type are `fileprivate`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This kind of suggests that we ought to rename `fileprivate` to something that, y&#39;know, doesn&#39;t say &quot;file&quot; in it. However, I can scarcely imagine the results of a round of bikeshedding without parental supervision from the core team, so I don&#39;t dare make any suggestions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am not convinced this is necessary.  If there *is* a containing &#39;private&#39; scope you can just leave the member unannotated to get this behavior.  If there isn&#39;t you can use &#39;fileprivate&#39; as it is already defined.  Why is that not sufficient?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you really want a second, more nuanced and complex scope-dependent access control mechanism I think you&#39;ll need to submit a proposal for it.  A simple renaming to &#39;fileprivate&#39; is what has been accepted thus far.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The main argument for what you suggest is that it would provide a way to ensure visibility of the member is*never* more than the file, but is as visible as possible within the file, while being less sensitive to changes in visibility of surrounding scopes.  IMO we need to get some experience with SE-0025 in real code before we know whether this is a problem that needs solving or not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 16, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 16, 2016, at 9:30 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Find it under our own pull requests on apple/swift#3000<br></p><p>You mean this one: https://github.com/apple/swift/pull/3000 &lt;https://github.com/apple/swift/pull/3000&gt; right?<br></p><p>What specifically did you want me to look at here?  Of course this proposal is going to require a lot of changes to existing code (changing `private` to `fileprivate`).  That was vetted and accepted during the review process.  I don’t see how this is relevant to the current thread.  Is there some other part of the discussion I am not seeing?<br></p><p>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/06/16 7:28、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 16, 2016, at 9:23 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Go checkout my branch!  And see the discussion there for how your proposal has impacted corelibs.<br>&gt;&gt; <br>&gt;&gt; I’ll be happy to.  Can you please provide a link to the branch and discussion?<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/06/16 5:50、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 16, 2016, at 5:20 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 6. With the core team tied up at WWDC, you may want to temporarily forbid the use of `private` on a type and revisit the matter when people are less busy; if necessary, we could even ship Swift 3 that way. Or you may want to consider making a guess as to a good implementation model to apply. Two suggestions for alternate implementation models:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; a. Introduce a `parent` access level, meaning &quot;visible in scopes within this file where the parent is visible&quot;, which is between `fileprivate` and `private`. Just as `internal` is the maximum inherited access level, `parent` is the minimum, so the members of a `private` type would inherit `parent` visibility. `parent` might be an entirely compiler-internal concept, with no utterable access control keyword.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thinking about this more, I notice that `fileprivate` as currently defined doesn&#39;t actually make any sense to say inside a `private` type: if your parent type has less-than-file-wide visibility, nothing in the file that&#39;s outside its scope can see you anyway. Therefore, we could redefine `fileprivate` thusly:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. A member with `fileprivate` visibility is visible within the scope in which the nearest containing `private` type is visible.<br>&gt;&gt;&gt;&gt;&gt; 2. If there are no containing `private` types, it is visible within the file containing it.<br>&gt;&gt;&gt;&gt;&gt; 3. Just as the members of a `public` type are `internal`, so the members of a `private` type are `fileprivate`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This kind of suggests that we ought to rename `fileprivate` to something that, y&#39;know, doesn&#39;t say &quot;file&quot; in it. However, I can scarcely imagine the results of a round of bikeshedding without parental supervision from the core team, so I don&#39;t dare make any suggestions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I am not convinced this is necessary.  If there *is* a containing &#39;private&#39; scope you can just leave the member unannotated to get this behavior.  If there isn&#39;t you can use &#39;fileprivate&#39; as it is already defined.  Why is that not sufficient?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you really want a second, more nuanced and complex scope-dependent access control mechanism I think you&#39;ll need to submit a proposal for it.  A simple renaming to &#39;fileprivate&#39; is what has been accepted thus far.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The main argument for what you suggest is that it would provide a way to ensure visibility of the member is*never* more than the file, but is as visible as possible within the file, while being less sensitive to changes in visibility of surrounding scopes.  IMO we need to get some experience with SE-0025 in real code before we know whether this is a problem that needs solving or not.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/8bf84b6b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 16, 2016 at 07:00:00am</p></header><div class="content"><p>Can you not see the links to the rest of the corelibs changes in the discussion?  Then I&#39;ll reproduce them here<br></p><p>- SwiftPM<br></p><p>https://github.com/apple/swift-package-manager/pull/410<br></p><p>- XCTest<br></p><p>https://github.com/apple/swift-corelibs-xctest/pull/124<br></p><p>- Foundation<br></p><p>https://github.com/apple/swift-corelibs-foundation/pull/413<br></p><p><br>~Robert Widmann<br></p><p>2016/06/16 7:35、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br></p><p>&gt; <br>&gt;&gt; On Jun 16, 2016, at 9:30 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Find it under our own pull requests on apple/swift#3000<br>&gt; <br>&gt; You mean this one: https://github.com/apple/swift/pull/3000 right?<br>&gt; <br>&gt; What specifically did you want me to look at here?  Of course this proposal is going to require a lot of changes to existing code (changing `private` to `fileprivate`).  That was vetted and accepted during the review process.  I don’t see how this is relevant to the current thread.  Is there some other part of the discussion I am not seeing?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/06/16 7:28、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 16, 2016, at 9:23 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Go checkout my branch!  And see the discussion there for how your proposal has impacted corelibs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ll be happy to.  Can you please provide a link to the branch and discussion?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/06/16 5:50、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 16, 2016, at 5:20 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 6. With the core team tied up at WWDC, you may want to temporarily forbid the use of `private` on a type and revisit the matter when people are less busy; if necessary, we could even ship Swift 3 that way. Or you may want to consider making a guess as to a good implementation model to apply. Two suggestions for alternate implementation models:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a. Introduce a `parent` access level, meaning &quot;visible in scopes within this file where the parent is visible&quot;, which is between `fileprivate` and `private`. Just as `internal` is the maximum inherited access level, `parent` is the minimum, so the members of a `private` type would inherit `parent` visibility. `parent` might be an entirely compiler-internal concept, with no utterable access control keyword.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thinking about this more, I notice that `fileprivate` as currently defined doesn&#39;t actually make any sense to say inside a `private` type: if your parent type has less-than-file-wide visibility, nothing in the file that&#39;s outside its scope can see you anyway. Therefore, we could redefine `fileprivate` thusly:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1. A member with `fileprivate` visibility is visible within the scope in which the nearest containing `private` type is visible.<br>&gt;&gt;&gt;&gt;&gt;&gt; 2. If there are no containing `private` types, it is visible within the file containing it.<br>&gt;&gt;&gt;&gt;&gt;&gt; 3. Just as the members of a `public` type are `internal`, so the members of a `private` type are `fileprivate`.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This kind of suggests that we ought to rename `fileprivate` to something that, y&#39;know, doesn&#39;t say &quot;file&quot; in it. However, I can scarcely imagine the results of a round of bikeshedding without parental supervision from the core team, so I don&#39;t dare make any suggestions.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I am not convinced this is necessary.  If there *is* a containing &#39;private&#39; scope you can just leave the member unannotated to get this behavior.  If there isn&#39;t you can use &#39;fileprivate&#39; as it is already defined.  Why is that not sufficient?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If you really want a second, more nuanced and complex scope-dependent access control mechanism I think you&#39;ll need to submit a proposal for it.  A simple renaming to &#39;fileprivate&#39; is what has been accepted thus far.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The main argument for what you suggest is that it would provide a way to ensure visibility of the member is*never* more than the file, but is as visible as possible within the file, while being less sensitive to changes in visibility of surrounding scopes.  IMO we need to get some experience with SE-0025 in real code before we know whether this is a problem that needs solving or not.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/d68e713b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 16, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 16, 2016, at 9:49 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Can you not see the links to the rest of the corelibs changes in the discussion?  Then I&#39;ll reproduce them here<br></p><p>Thanks.  I don’t see anything unexpected here.  The Swift PM case is one where the team wishes to take advantage of SE-0025 to tighten visibility and express their intent more explicitly.  <br></p><p>The automated find / replace migration you applied is correct, but maybe they want to slow down and review the changes so the results match the semantics they desire.  That seems reasonable to me.<br></p><p><br>&gt; <br>&gt; - SwiftPM<br>&gt; <br>&gt; https://github.com/apple/swift-package-manager/pull/410 &lt;https://github.com/apple/swift-package-manager/pull/410&gt;<br>&gt; <br>&gt; - XCTest<br>&gt; <br>&gt; https://github.com/apple/swift-corelibs-xctest/pull/124 &lt;https://github.com/apple/swift-corelibs-xctest/pull/124&gt;<br>&gt; <br>&gt; - Foundation<br>&gt; <br>&gt; https://github.com/apple/swift-corelibs-foundation/pull/413 &lt;https://github.com/apple/swift-corelibs-foundation/pull/413&gt;<br>&gt; <br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/06/16 7:35、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 16, 2016, at 9:30 AM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Find it under our own pull requests on apple/swift#3000<br>&gt;&gt; <br>&gt;&gt; You mean this one: https://github.com/apple/swift/pull/3000 &lt;https://github.com/apple/swift/pull/3000&gt; right?<br>&gt;&gt; <br>&gt;&gt; What specifically did you want me to look at here?  Of course this proposal is going to require a lot of changes to existing code (changing `private` to `fileprivate`).  That was vetted and accepted during the review process.  I don’t see how this is relevant to the current thread.  Is there some other part of the discussion I am not seeing?<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/06/16 7:28、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 16, 2016, at 9:23 AM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Go checkout my branch!  And see the discussion there for how your proposal has impacted corelibs.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’ll be happy to.  Can you please provide a link to the branch and discussion?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2016/06/16 5:50、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 16, 2016, at 5:20 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 6. With the core team tied up at WWDC, you may want to temporarily forbid the use of `private` on a type and revisit the matter when people are less busy; if necessary, we could even ship Swift 3 that way. Or you may want to consider making a guess as to a good implementation model to apply. Two suggestions for alternate implementation models:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a. Introduce a `parent` access level, meaning &quot;visible in scopes within this file where the parent is visible&quot;, which is between `fileprivate` and `private`. Just as `internal` is the maximum inherited access level, `parent` is the minimum, so the members of a `private` type would inherit `parent` visibility. `parent` might be an entirely compiler-internal concept, with no utterable access control keyword.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thinking about this more, I notice that `fileprivate` as currently defined doesn&#39;t actually make any sense to say inside a `private` type: if your parent type has less-than-file-wide visibility, nothing in the file that&#39;s outside its scope can see you anyway. Therefore, we could redefine `fileprivate` thusly:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. A member with `fileprivate` visibility is visible within the scope in which the nearest containing `private` type is visible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. If there are no containing `private` types, it is visible within the file containing it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3. Just as the members of a `public` type are `internal`, so the members of a `private` type are `fileprivate`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This kind of suggests that we ought to rename `fileprivate` to something that, y&#39;know, doesn&#39;t say &quot;file&quot; in it. However, I can scarcely imagine the results of a round of bikeshedding without parental supervision from the core team, so I don&#39;t dare make any suggestions.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I am not convinced this is necessary.  If there *is* a containing &#39;private&#39; scope you can just leave the member unannotated to get this behavior.  If there isn&#39;t you can use &#39;fileprivate&#39; as it is already defined.  Why is that not sufficient?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If you really want a second, more nuanced and complex scope-dependent access control mechanism I think you&#39;ll need to submit a proposal for it.  A simple renaming to &#39;fileprivate&#39; is what has been accepted thus far.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The main argument for what you suggest is that it would provide a way to ensure visibility of the member is*never* more than the file, but is as visible as possible within the file, while being less sensitive to changes in visibility of surrounding scopes.  IMO we need to get some experience with SE-0025 in real code before we know whether this is a problem that needs solving or not.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/7a1eb51a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 16, 2016 at 08:00:00am</p></header><div class="content"><p>The Swift PM case is actually the one that causes me to sound the alarm bells ;) I migrated that one by hand as did @modocache for XCTest.<br></p><p>~Robert Widmann<br></p><p>2016/06/16 8:04、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br></p><p>&gt; <br>&gt;&gt; On Jun 16, 2016, at 9:49 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Can you not see the links to the rest of the corelibs changes in the discussion?  Then I&#39;ll reproduce them here<br>&gt; <br>&gt; Thanks.  I don’t see anything unexpected here.  The Swift PM case is one where the team wishes to take advantage of SE-0025 to tighten visibility and express their intent more explicitly.  <br>&gt; <br>&gt; The automated find / replace migration you applied is correct, but maybe they want to slow down and review the changes so the results match the semantics they desire.  That seems reasonable to me.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; - SwiftPM<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-package-manager/pull/410<br>&gt;&gt; <br>&gt;&gt; - XCTest<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-corelibs-xctest/pull/124<br>&gt;&gt; <br>&gt;&gt; - Foundation<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-corelibs-foundation/pull/413<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/06/16 7:35、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 16, 2016, at 9:30 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Find it under our own pull requests on apple/swift#3000<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You mean this one: https://github.com/apple/swift/pull/3000 right?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What specifically did you want me to look at here?  Of course this proposal is going to require a lot of changes to existing code (changing `private` to `fileprivate`).  That was vetted and accepted during the review process.  I don’t see how this is relevant to the current thread.  Is there some other part of the discussion I am not seeing?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/06/16 7:28、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 16, 2016, at 9:23 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Go checkout my branch!  And see the discussion there for how your proposal has impacted corelibs.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’ll be happy to.  Can you please provide a link to the branch and discussion?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/16 5:50、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 16, 2016, at 5:20 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 6. With the core team tied up at WWDC, you may want to temporarily forbid the use of `private` on a type and revisit the matter when people are less busy; if necessary, we could even ship Swift 3 that way. Or you may want to consider making a guess as to a good implementation model to apply. Two suggestions for alternate implementation models:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a. Introduce a `parent` access level, meaning &quot;visible in scopes within this file where the parent is visible&quot;, which is between `fileprivate` and `private`. Just as `internal` is the maximum inherited access level, `parent` is the minimum, so the members of a `private` type would inherit `parent` visibility. `parent` might be an entirely compiler-internal concept, with no utterable access control keyword.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thinking about this more, I notice that `fileprivate` as currently defined doesn&#39;t actually make any sense to say inside a `private` type: if your parent type has less-than-file-wide visibility, nothing in the file that&#39;s outside its scope can see you anyway. Therefore, we could redefine `fileprivate` thusly:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. A member with `fileprivate` visibility is visible within the scope in which the nearest containing `private` type is visible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. If there are no containing `private` types, it is visible within the file containing it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3. Just as the members of a `public` type are `internal`, so the members of a `private` type are `fileprivate`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This kind of suggests that we ought to rename `fileprivate` to something that, y&#39;know, doesn&#39;t say &quot;file&quot; in it. However, I can scarcely imagine the results of a round of bikeshedding without parental supervision from the core team, so I don&#39;t dare make any suggestions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I am not convinced this is necessary.  If there *is* a containing &#39;private&#39; scope you can just leave the member unannotated to get this behavior.  If there isn&#39;t you can use &#39;fileprivate&#39; as it is already defined.  Why is that not sufficient?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you really want a second, more nuanced and complex scope-dependent access control mechanism I think you&#39;ll need to submit a proposal for it.  A simple renaming to &#39;fileprivate&#39; is what has been accepted thus far.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The main argument for what you suggest is that it would provide a way to ensure visibility of the member is*never* more than the file, but is as visible as possible within the file, while being less sensitive to changes in visibility of surrounding scopes.  IMO we need to get some experience with SE-0025 in real code before we know whether this is a problem that needs solving or not.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/de4fb484/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 16, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 16, 2016, at 10:12 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; The Swift PM case is actually the one that causes me to sound the alarm bells ;) I migrated that one by hand as did @modocache for XCTest.<br></p><p>What I mean is that you just applied the semantic-preserving transformation of replacing `private` with `fileprivate` rather than reviewing whether the new `private` might be more appropriate given the intent of a specific piece of code.  That is reasonable for moving the implementation forward.<br></p><p>However, the discussion on the PR is because the Swift PM team wants to take advantage of the new semantics of `private` rather than just preserving the existing semantics which were looser than desired.  That is also reasonable.<br></p><p>I understand that this discussion is what prompted the realization that the proposal is not explicit enough and therefore requires clarification from the core team.  Hopefully Doug (review manager for the proposal) will have a chance to chime in after WWDC wraps up.<br></p><p>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/06/16 8:04、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 16, 2016, at 9:49 AM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can you not see the links to the rest of the corelibs changes in the discussion?  Then I&#39;ll reproduce them here<br>&gt;&gt; <br>&gt;&gt; Thanks.  I don’t see anything unexpected here.  The Swift PM case is one where the team wishes to take advantage of SE-0025 to tighten visibility and express their intent more explicitly.  <br>&gt;&gt; <br>&gt;&gt; The automated find / replace migration you applied is correct, but maybe they want to slow down and review the changes so the results match the semantics they desire.  That seems reasonable to me.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - SwiftPM<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-package-manager/pull/410 &lt;https://github.com/apple/swift-package-manager/pull/410&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - XCTest<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-corelibs-xctest/pull/124 &lt;https://github.com/apple/swift-corelibs-xctest/pull/124&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Foundation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-corelibs-foundation/pull/413 &lt;https://github.com/apple/swift-corelibs-foundation/pull/413&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/06/16 7:35、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 16, 2016, at 9:30 AM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Find it under our own pull requests on apple/swift#3000<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You mean this one: https://github.com/apple/swift/pull/3000 &lt;https://github.com/apple/swift/pull/3000&gt; right?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What specifically did you want me to look at here?  Of course this proposal is going to require a lot of changes to existing code (changing `private` to `fileprivate`).  That was vetted and accepted during the review process.  I don’t see how this is relevant to the current thread.  Is there some other part of the discussion I am not seeing?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2016/06/16 7:28、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 16, 2016, at 9:23 AM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Go checkout my branch!  And see the discussion there for how your proposal has impacted corelibs.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’ll be happy to.  Can you please provide a link to the branch and discussion?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/16 5:50、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 16, 2016, at 5:20 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 6. With the core team tied up at WWDC, you may want to temporarily forbid the use of `private` on a type and revisit the matter when people are less busy; if necessary, we could even ship Swift 3 that way. Or you may want to consider making a guess as to a good implementation model to apply. Two suggestions for alternate implementation models:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a. Introduce a `parent` access level, meaning &quot;visible in scopes within this file where the parent is visible&quot;, which is between `fileprivate` and `private`. Just as `internal` is the maximum inherited access level, `parent` is the minimum, so the members of a `private` type would inherit `parent` visibility. `parent` might be an entirely compiler-internal concept, with no utterable access control keyword.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thinking about this more, I notice that `fileprivate` as currently defined doesn&#39;t actually make any sense to say inside a `private` type: if your parent type has less-than-file-wide visibility, nothing in the file that&#39;s outside its scope can see you anyway. Therefore, we could redefine `fileprivate` thusly:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. A member with `fileprivate` visibility is visible within the scope in which the nearest containing `private` type is visible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. If there are no containing `private` types, it is visible within the file containing it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3. Just as the members of a `public` type are `internal`, so the members of a `private` type are `fileprivate`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This kind of suggests that we ought to rename `fileprivate` to something that, y&#39;know, doesn&#39;t say &quot;file&quot; in it. However, I can scarcely imagine the results of a round of bikeshedding without parental supervision from the core team, so I don&#39;t dare make any suggestions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I am not convinced this is necessary.  If there *is* a containing &#39;private&#39; scope you can just leave the member unannotated to get this behavior.  If there isn&#39;t you can use &#39;fileprivate&#39; as it is already defined.  Why is that not sufficient?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you really want a second, more nuanced and complex scope-dependent access control mechanism I think you&#39;ll need to submit a proposal for it.  A simple renaming to &#39;fileprivate&#39; is what has been accepted thus far.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The main argument for what you suggest is that it would provide a way to ensure visibility of the member is*never* more than the file, but is as visible as possible within the file, while being less sensitive to changes in visibility of surrounding scopes.  IMO we need to get some experience with SE-0025 in real code before we know whether this is a problem that needs solving or not.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/e9c164c4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 16, 2016 at 08:00:00am</p></header><div class="content"><p>~Robert Widmann<br></p><p>2016/06/16 8:18、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br></p><p>&gt; <br>&gt;&gt; On Jun 16, 2016, at 10:12 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The Swift PM case is actually the one that causes me to sound the alarm bells ;) I migrated that one by hand as did @modocache for XCTest.<br>&gt; <br>&gt; What I mean is that you just applied the semantic-preserving transformation of replacing `private` with `fileprivate` rather than reviewing whether the new `private` might be more appropriate given the intent of a specific piece of code.  That is reasonable for moving the implementation forward.<br></p><p>No, I actually sat for 4 hours and hand-migrated individual failing test cases across 3 repositories over the weekend.  This was no simple sed job!<br></p><p>&gt; <br>&gt; However, the discussion on the PR is because the Swift PM team wants to take advantage of the new semantics of `private` rather than just preserving the existing semantics which were looser than desired.  That is also reasonable.<br>&gt; <br>&gt; I understand that this discussion is what prompted the realization that the proposal is not explicit enough and therefore requires clarification from the core team.  Hopefully Doug (review manager for the proposal) will have a chance to chime in after WWDC wraps up.<br></p><p>Cheers.  I&#39;m at WWDC along with them staffing the Swift labs today if anybody wants to come find me and talk about this!<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/06/16 8:04、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 16, 2016, at 9:49 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Can you not see the links to the rest of the corelibs changes in the discussion?  Then I&#39;ll reproduce them here<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks.  I don’t see anything unexpected here.  The Swift PM case is one where the team wishes to take advantage of SE-0025 to tighten visibility and express their intent more explicitly.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The automated find / replace migration you applied is correct, but maybe they want to slow down and review the changes so the results match the semantics they desire.  That seems reasonable to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - SwiftPM<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-package-manager/pull/410<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - XCTest<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-corelibs-xctest/pull/124<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Foundation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-corelibs-foundation/pull/413<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/06/16 7:35、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 16, 2016, at 9:30 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Find it under our own pull requests on apple/swift#3000<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You mean this one: https://github.com/apple/swift/pull/3000 right?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What specifically did you want me to look at here?  Of course this proposal is going to require a lot of changes to existing code (changing `private` to `fileprivate`).  That was vetted and accepted during the review process.  I don’t see how this is relevant to the current thread.  Is there some other part of the discussion I am not seeing?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/16 7:28、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 16, 2016, at 9:23 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Go checkout my branch!  And see the discussion there for how your proposal has impacted corelibs.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’ll be happy to.  Can you please provide a link to the branch and discussion?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/16 5:50、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 16, 2016, at 5:20 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 6. With the core team tied up at WWDC, you may want to temporarily forbid the use of `private` on a type and revisit the matter when people are less busy; if necessary, we could even ship Swift 3 that way. Or you may want to consider making a guess as to a good implementation model to apply. Two suggestions for alternate implementation models:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a. Introduce a `parent` access level, meaning &quot;visible in scopes within this file where the parent is visible&quot;, which is between `fileprivate` and `private`. Just as `internal` is the maximum inherited access level, `parent` is the minimum, so the members of a `private` type would inherit `parent` visibility. `parent` might be an entirely compiler-internal concept, with no utterable access control keyword.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thinking about this more, I notice that `fileprivate` as currently defined doesn&#39;t actually make any sense to say inside a `private` type: if your parent type has less-than-file-wide visibility, nothing in the file that&#39;s outside its scope can see you anyway. Therefore, we could redefine `fileprivate` thusly:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. A member with `fileprivate` visibility is visible within the scope in which the nearest containing `private` type is visible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. If there are no containing `private` types, it is visible within the file containing it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3. Just as the members of a `public` type are `internal`, so the members of a `private` type are `fileprivate`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This kind of suggests that we ought to rename `fileprivate` to something that, y&#39;know, doesn&#39;t say &quot;file&quot; in it. However, I can scarcely imagine the results of a round of bikeshedding without parental supervision from the core team, so I don&#39;t dare make any suggestions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I am not convinced this is necessary.  If there *is* a containing &#39;private&#39; scope you can just leave the member unannotated to get this behavior.  If there isn&#39;t you can use &#39;fileprivate&#39; as it is already defined.  Why is that not sufficient?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you really want a second, more nuanced and complex scope-dependent access control mechanism I think you&#39;ll need to submit a proposal for it.  A simple renaming to &#39;fileprivate&#39; is what has been accepted thus far.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The main argument for what you suggest is that it would provide a way to ensure visibility of the member is*never* more than the file, but is as visible as possible within the file, while being less sensitive to changes in visibility of surrounding scopes.  IMO we need to get some experience with SE-0025 in real code before we know whether this is a problem that needs solving or not.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/d4c20c6d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 16, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 16, 2016, at 10:20 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/06/16 8:18、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 16, 2016, at 10:12 AM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The Swift PM case is actually the one that causes me to sound the alarm bells ;) I migrated that one by hand as did @modocache for XCTest.<br>&gt;&gt; <br>&gt;&gt; What I mean is that you just applied the semantic-preserving transformation of replacing `private` with `fileprivate` rather than reviewing whether the new `private` might be more appropriate given the intent of a specific piece of code.  That is reasonable for moving the implementation forward.<br>&gt; <br>&gt; No, I actually sat for 4 hours and hand-migrated individual failing test cases across 3 repositories over the weekend.  This was no simple sed job!<br></p><p>I certainly appreciate the effort you applied here!  So you did leave some things as `private` when they were not required to be more visible then?  I apologize if I misunderstood.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; However, the discussion on the PR is because the Swift PM team wants to take advantage of the new semantics of `private` rather than just preserving the existing semantics which were looser than desired.  That is also reasonable.<br>&gt;&gt; <br>&gt;&gt; I understand that this discussion is what prompted the realization that the proposal is not explicit enough and therefore requires clarification from the core team.  Hopefully Doug (review manager for the proposal) will have a chance to chime in after WWDC wraps up.<br>&gt; <br>&gt; Cheers.  I&#39;m at WWDC along with them staffing the Swift labs today if anybody wants to come find me and talk about this!<br></p><p>I would love to, but unfortunately didn’t get a ticket.  If you have a chance to discuss with Doug or other core team members please report back to the list!<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/06/16 8:04、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 16, 2016, at 9:49 AM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Can you not see the links to the rest of the corelibs changes in the discussion?  Then I&#39;ll reproduce them here<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks.  I don’t see anything unexpected here.  The Swift PM case is one where the team wishes to take advantage of SE-0025 to tighten visibility and express their intent more explicitly.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The automated find / replace migration you applied is correct, but maybe they want to slow down and review the changes so the results match the semantics they desire.  That seems reasonable to me.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - SwiftPM<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-package-manager/pull/410 &lt;https://github.com/apple/swift-package-manager/pull/410&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - XCTest<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-corelibs-xctest/pull/124 &lt;https://github.com/apple/swift-corelibs-xctest/pull/124&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Foundation<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-corelibs-foundation/pull/413 &lt;https://github.com/apple/swift-corelibs-foundation/pull/413&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2016/06/16 7:35、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 16, 2016, at 9:30 AM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Find it under our own pull requests on apple/swift#3000<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; You mean this one: https://github.com/apple/swift/pull/3000 &lt;https://github.com/apple/swift/pull/3000&gt; right?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What specifically did you want me to look at here?  Of course this proposal is going to require a lot of changes to existing code (changing `private` to `fileprivate`).  That was vetted and accepted during the review process.  I don’t see how this is relevant to the current thread.  Is there some other part of the discussion I am not seeing?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/16 7:28、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 16, 2016, at 9:23 AM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Go checkout my branch!  And see the discussion there for how your proposal has impacted corelibs.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’ll be happy to.  Can you please provide a link to the branch and discussion?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/16 5:50、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 16, 2016, at 5:20 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 6. With the core team tied up at WWDC, you may want to temporarily forbid the use of `private` on a type and revisit the matter when people are less busy; if necessary, we could even ship Swift 3 that way. Or you may want to consider making a guess as to a good implementation model to apply. Two suggestions for alternate implementation models:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a. Introduce a `parent` access level, meaning &quot;visible in scopes within this file where the parent is visible&quot;, which is between `fileprivate` and `private`. Just as `internal` is the maximum inherited access level, `parent` is the minimum, so the members of a `private` type would inherit `parent` visibility. `parent` might be an entirely compiler-internal concept, with no utterable access control keyword.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thinking about this more, I notice that `fileprivate` as currently defined doesn&#39;t actually make any sense to say inside a `private` type: if your parent type has less-than-file-wide visibility, nothing in the file that&#39;s outside its scope can see you anyway. Therefore, we could redefine `fileprivate` thusly:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. A member with `fileprivate` visibility is visible within the scope in which the nearest containing `private` type is visible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. If there are no containing `private` types, it is visible within the file containing it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3. Just as the members of a `public` type are `internal`, so the members of a `private` type are `fileprivate`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This kind of suggests that we ought to rename `fileprivate` to something that, y&#39;know, doesn&#39;t say &quot;file&quot; in it. However, I can scarcely imagine the results of a round of bikeshedding without parental supervision from the core team, so I don&#39;t dare make any suggestions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I am not convinced this is necessary.  If there *is* a containing &#39;private&#39; scope you can just leave the member unannotated to get this behavior.  If there isn&#39;t you can use &#39;fileprivate&#39; as it is already defined.  Why is that not sufficient?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you really want a second, more nuanced and complex scope-dependent access control mechanism I think you&#39;ll need to submit a proposal for it.  A simple renaming to &#39;fileprivate&#39; is what has been accepted thus far.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The main argument for what you suggest is that it would provide a way to ensure visibility of the member is*never* more than the file, but is as visible as possible within the file, while being less sensitive to changes in visibility of surrounding scopes.  IMO we need to get some experience with SE-0025 in real code before we know whether this is a problem that needs solving or not.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/9c91d5f2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 16, 2016 at 08:00:00am</p></header><div class="content"><p>The changes in that patch were the minimum required to get it to build.  There are definitely refinements to be had here, but I believe this gets us 90% of the way there (except corelibs-foundation which I will try to audit today after a rebase).  I was only able to leave explicitly marked private members alone, but SPM more often than not couples outer and inner types together by declaring the inner classes private which made them wholly inaccessible.  For enums there&#39;s nothing I could do because you can&#39;t re-apply access control to individual cases, those all had to be fileprivate.  typealiases and globals at the top level could generally stay private consistently.  <br></p><p>One of the reasons I brought this up in the first place was I noticed about 4 (not sure if some are the same) new crashes in and around SILGen because we were blowing away full-private types inside SwiftPM and causing problems down the rest of the optimization passes into codegen.<br></p><p>~Robert Widmann<br></p><p>2016/06/16 8:24、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br></p><p>&gt; <br>&gt;&gt; On Jun 16, 2016, at 10:20 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/06/16 8:18、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 16, 2016, at 10:12 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The Swift PM case is actually the one that causes me to sound the alarm bells ;) I migrated that one by hand as did @modocache for XCTest.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What I mean is that you just applied the semantic-preserving transformation of replacing `private` with `fileprivate` rather than reviewing whether the new `private` might be more appropriate given the intent of a specific piece of code.  That is reasonable for moving the implementation forward.<br>&gt;&gt; <br>&gt;&gt; No, I actually sat for 4 hours and hand-migrated individual failing test cases across 3 repositories over the weekend.  This was no simple sed job!<br>&gt; <br>&gt; I certainly appreciate the effort you applied here!  So you did leave some things as `private` when they were not required to be more visible then?  I apologize if I misunderstood.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, the discussion on the PR is because the Swift PM team wants to take advantage of the new semantics of `private` rather than just preserving the existing semantics which were looser than desired.  That is also reasonable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I understand that this discussion is what prompted the realization that the proposal is not explicit enough and therefore requires clarification from the core team.  Hopefully Doug (review manager for the proposal) will have a chance to chime in after WWDC wraps up.<br>&gt;&gt; <br>&gt;&gt; Cheers.  I&#39;m at WWDC along with them staffing the Swift labs today if anybody wants to come find me and talk about this!<br>&gt; <br>&gt; I would love to, but unfortunately didn’t get a ticket.  If you have a chance to discuss with Doug or other core team members please report back to the list!<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/06/16 8:04、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 16, 2016, at 9:49 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Can you not see the links to the rest of the corelibs changes in the discussion?  Then I&#39;ll reproduce them here<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks.  I don’t see anything unexpected here.  The Swift PM case is one where the team wishes to take advantage of SE-0025 to tighten visibility and express their intent more explicitly.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The automated find / replace migration you applied is correct, but maybe they want to slow down and review the changes so the results match the semantics they desire.  That seems reasonable to me.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - SwiftPM<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-package-manager/pull/410<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - XCTest<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-corelibs-xctest/pull/124<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Foundation<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-corelibs-foundation/pull/413<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/16 7:35、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 16, 2016, at 9:30 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Find it under our own pull requests on apple/swift#3000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; You mean this one: https://github.com/apple/swift/pull/3000 right?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; What specifically did you want me to look at here?  Of course this proposal is going to require a lot of changes to existing code (changing `private` to `fileprivate`).  That was vetted and accepted during the review process.  I don’t see how this is relevant to the current thread.  Is there some other part of the discussion I am not seeing?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/16 7:28、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 16, 2016, at 9:23 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Go checkout my branch!  And see the discussion there for how your proposal has impacted corelibs.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’ll be happy to.  Can you please provide a link to the branch and discussion?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/06/16 5:50、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 16, 2016, at 5:20 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 6. With the core team tied up at WWDC, you may want to temporarily forbid the use of `private` on a type and revisit the matter when people are less busy; if necessary, we could even ship Swift 3 that way. Or you may want to consider making a guess as to a good implementation model to apply. Two suggestions for alternate implementation models:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a. Introduce a `parent` access level, meaning &quot;visible in scopes within this file where the parent is visible&quot;, which is between `fileprivate` and `private`. Just as `internal` is the maximum inherited access level, `parent` is the minimum, so the members of a `private` type would inherit `parent` visibility. `parent` might be an entirely compiler-internal concept, with no utterable access control keyword.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thinking about this more, I notice that `fileprivate` as currently defined doesn&#39;t actually make any sense to say inside a `private` type: if your parent type has less-than-file-wide visibility, nothing in the file that&#39;s outside its scope can see you anyway. Therefore, we could redefine `fileprivate` thusly:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. A member with `fileprivate` visibility is visible within the scope in which the nearest containing `private` type is visible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. If there are no containing `private` types, it is visible within the file containing it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3. Just as the members of a `public` type are `internal`, so the members of a `private` type are `fileprivate`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This kind of suggests that we ought to rename `fileprivate` to something that, y&#39;know, doesn&#39;t say &quot;file&quot; in it. However, I can scarcely imagine the results of a round of bikeshedding without parental supervision from the core team, so I don&#39;t dare make any suggestions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I am not convinced this is necessary.  If there *is* a containing &#39;private&#39; scope you can just leave the member unannotated to get this behavior.  If there isn&#39;t you can use &#39;fileprivate&#39; as it is already defined.  Why is that not sufficient?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you really want a second, more nuanced and complex scope-dependent access control mechanism I think you&#39;ll need to submit a proposal for it.  A simple renaming to &#39;fileprivate&#39; is what has been accepted thus far.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The main argument for what you suggest is that it would provide a way to ensure visibility of the member is*never* more than the file, but is as visible as possible within the file, while being less sensitive to changes in visibility of surrounding scopes.  IMO we need to get some experience with SE-0025 in real code before we know whether this is a problem that needs solving or not.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/b241b998/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June 16, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; On Jun 15, 2016, at 11:16 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Charles we&#39;ve diverged from the actual issue at hand to nitpick my English.  Read the code (that std::min tho!).  We have a problem here and no obvious solution that doesn&#39;t involve special-casing parts of this proposal.  Do you have a solution or shall we take this offline?  I can provide you my iMessage information in a person email if you wish to discuss this with me or any other members of the team, but the list is not the most productive place for this.<br>&gt; <br>&gt; Thanks,<br>&gt; <br>&gt; ~Robert Widmann<br></p><p>I am not sure why you think I am nitpicking your English (unless if you are possibly referring to the post where I corrected my own typo, but that was my English, not yours). What I am trying to express is that I do not believe there is an issue with the syntax as proposed. If there is no access modifier on a declaration, there is no reason that that declaration should be less visible than its container, except in the case that the container’s visibility is greater than the default level of internal—i.e. it is public.<br></p><p>Furthermore, I do not see the need for an access modifier that says to give something the same visibility as its parent, since for all access levels other than public (and of course, for public APIs, you want to declare those explicitly anyway), you get that already by default, so an access modifier seems somewhat redundant.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/8ee32d78/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 16, 2016 at 01:00:00am</p></header><div class="content"><p>~Robert Widmann<br></p><p>2016/06/16 0:44、Charles Srstka &lt;cocoadev at charlessoft.com&gt; のメッセージ:<br></p><p>&gt;&gt; On Jun 15, 2016, at 11:16 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Charles we&#39;ve diverged from the actual issue at hand to nitpick my English.  Read the code (that std::min tho!).  We have a problem here and no obvious solution that doesn&#39;t involve special-casing parts of this proposal.  Do you have a solution or shall we take this offline?  I can provide you my iMessage information in a person email if you wish to discuss this with me or any other members of the team, but the list is not the most productive place for this.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt; <br>&gt; I am not sure why you think I am nitpicking your English (unless if you are possibly referring to the post where I corrected my own typo, but that was my English, not yours). What I am trying to express is that I do not believe there is an issue with the syntax as proposed. If there is no access modifier on a declaration, there is no reason that that declaration should be less visible than its container, except in the case that the container’s visibility is greater than the default level of internal―i.e. it is public.<br>&gt; <br></p><p>We agree on the latter half, but the former is suspect.  You may have gleaned that from the spirit of this proposal, but its letter says nothing of the sort.  Access and visibility are one and the same in the compiler.  We use access to determine (for lack of a better word) the &quot;lookup-ability&quot; of a symbol (hence its visibility) during Sema.  To divorce or tie the two any further is not specified and should have been originally.  If you honestly believe that we should break containment because that is the right thing to do then I need the proposal to match that belief.  Otherwise, the implementation I have is subject to the issue in root.<br></p><p>If you read the very example given in that proposal, you will see that the author intended private members to be scoped by their containing declaration.  There is precisely zero mention of top-level semantics.  If that was an honest mistake or an ambiguity that didn&#39;t get removed, then we need to address it here and now before we merge a proper implementation.<br></p><p>&gt; Furthermore, I do not see the need for an access modifier that says to give something the same visibility as its parent, since for all access levels other than public (and of course, for public APIs, you want to declare those explicitly anyway), you get that already by default, so an access modifier seems somewhat redundant.<br></p><p>Precisely.<br></p><p>&gt; <br>&gt; Charles<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/255da9c7/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June 15, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jun 15, 2016, at 11:04 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Result is that the property is only accessible from inside its parent type.<br></p><p>*inside the type’s parent type<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/41650d12/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 15, 2016 at 09:00:00pm</p></header><div class="content"><p>Yes, we agree.  Can we please discuss what to do about SE-0025?<br></p><p>~Robert Widmann<br></p><p>2016/06/15 21:18、Charles Srstka &lt;cocoadev at charlessoft.com&gt; のメッセージ:<br></p><p>&gt;&gt; On Jun 15, 2016, at 11:04 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Result is that the property is only accessible from inside its parent type.<br>&gt; <br>&gt; *inside the type’s parent type<br>&gt; <br>&gt; Charles<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/327ea6e0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 16, 2016 at 07:00:00am</p></header><div class="content"><p>Wouldn&#39;t this get solved by ditching fileprivate (which would be /is right now/ the default behavior for private) and introduce a more private level instead, e.g. &quot;declaration&quot; or &quot;scope&quot;<br></p><p>/// File A<br></p><p>public struct MyStruct {<br>	declaration var x: Int<br>	private var y: Int<br>	internal var z: Int<br></p><p>	init() {<br>		x = 0<br>		y = 1<br>		z = 2<br>	}<br>}<br></p><p>/// Within the same file<br>let str = MyStruct()<br>str.x // Error<br>str.y // OK<br>str.z // OK<br></p><p>/// File B<br></p><p>/// Another file<br>let str = MyStruct()<br>str.x // Error<br>str.y // Error<br>str.z // OK<br></p><p>I know that this goes in the other direction than the original proposal, but it would solve all these issues, while fully preserving backward compatibility. Am I missing something?<br></p><p><br>&gt; On Jun 16, 2016, at 6:30 AM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yes, we agree.  Can we please discuss what to do about SE-0025?<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/06/15 21:18、Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt;&gt; On Jun 15, 2016, at 11:04 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Result is that the property is only accessible from inside its parent type.<br>&gt;&gt; <br>&gt;&gt; *inside the type’s parent type<br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/09cc2e8a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 15, 2016 at 10:00:00pm</p></header><div class="content"><p>I think this was the original intent of SE-0025, but it is subject to the issue I raised in the root: If the entire decl is declaration-private, then it cannot be constructed because its members are also declaration-private.  We can forbid it at the top level but that doesn&#39;t solve the problem for inner classes and we&#39;d have to needlessly special-case the grammar.  We could solve it with a diagnostic for top-level declaration-private aggregates but is that really a good solution?   Then again, we could raise the access level of declaration-private members with no access modifier but then we&#39;d break containment and we&#39;re back to square one because declaration-private now just effectively means fileprivate for this one huge use case.<br></p><p>~Robert Widmann<br></p><p>2016/06/15 22:02、Charlie Monroe &lt;charlie at charliemonroe.net&gt; のメッセージ:<br></p><p>&gt; Wouldn&#39;t this get solved by ditching fileprivate (which would be /is right now/ the default behavior for private) and introduce a more private level instead, e.g. &quot;declaration&quot; or &quot;scope&quot;<br>&gt; <br>&gt; /// File A<br>&gt; <br>&gt; public struct MyStruct {<br>&gt; 	declaration var x: Int<br>&gt; 	private var y: Int<br>&gt; 	internal var z: Int<br>&gt; <br>&gt; 	init() {<br>&gt; 		x = 0<br>&gt; 		y = 1<br>&gt; 		z = 2<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; /// Within the same file<br>&gt; let str = MyStruct()<br>&gt; str.x // Error<br>&gt; str.y // OK<br>&gt; str.z // OK<br>&gt; <br>&gt; /// File B<br>&gt; <br>&gt; /// Another file<br>&gt; let str = MyStruct()<br>&gt; str.x // Error<br>&gt; str.y // Error<br>&gt; str.z // OK<br>&gt; <br>&gt; I know that this goes in the other direction than the original proposal, but it would solve all these issues, while fully preserving backward compatibility. Am I missing something?<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 16, 2016, at 6:30 AM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yes, we agree.  Can we please discuss what to do about SE-0025?<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/06/15 21:18、Charles Srstka &lt;cocoadev at charlessoft.com&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 15, 2016, at 11:04 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Result is that the property is only accessible from inside its parent type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; *inside the type’s parent type<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Charles<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/75b43a14/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 23, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jun 15, 2016, at 18:47, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 15, 2016, at 8:36 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Point 3 is *not* how member lookup applies access control levels to unannotated properties of outer structures (see https://github.com/CodaFi/swift/blob/fb9f9536a5760369457d0f9c49599415cbc36e07/lib/Sema/TypeCheckDecl.cpp#L1470 &lt;https://github.com/CodaFi/swift/blob/fb9f9536a5760369457d0f9c49599415cbc36e07/lib/Sema/TypeCheckDecl.cpp#L1470&gt;) and makes no sense.  They do not default to &quot;internal&quot; when unannotated, they default to the highest possible access level they can get given the decl they&#39;re in.  A private structure will necessarily have private members.  This is the whole point of me raising this issue.  If we were to break containment we would break the very motivation for this proposal.  And if we wish to do this to get this feature right, then the proposal needs to be amended to include that kind of caveat.<br>&gt; <br>&gt; This isn’t correct. If the outer type is marked “public”, and its properties are not annotated, those properties will be internal, *not* public, and you will not be able to see them outside of the module.<br>&gt; <br>&gt; The rule can basically be summed up as “internal by default, unless we can’t because our enclosing type is more restrictive than internal. Then, be as visible as the enclosing type is.”<br></p><p>Robert is correct in the current interpretation: the default access level of a members is the access level of the enclosing type, except that nothing is ever public by default, and so you get ‘internal’ if the type is public. This suggests a rule that the access level of a member is never greater than the access level for a type, and the compiler will warn if you break this rule.<br></p><p>(Citation: I wrote both the implementation and the original proposal &lt;https://github.com/apple/swift/blob/master/docs/AccessControl.rst&gt; for Swift access control. Please let’s not continue talking about the current (pre-SE-0025) behavior or its intent.)<br></p><p>—<br></p><p>As everyone has pointed out, this does not produce desirable behavior in the presence of the new ‘private’.<br></p><p>Here is my understanding of the problem:<br></p><p>- Blindly applying the current rules, the members of a ‘private&#39; type default to being ‘private&#39;.<br>- Blindly applying the current rules, the members of a ‘private&#39; type cannot be marked as anything but ‘private’ or the compiler will warn.<br></p><p>(Thank you Robert for explaining the problem to me in person.)<br></p><p>—<br></p><p>I think Brent has done a great job of summing up the options with regard to ‘private’ on types:<br></p><p>&gt; 1. Having an extra, unutterable access modifier that floats relative to the other access levels.<br>&gt; <br>&gt; 2. Having an extra access modifiers that floats relative to the other access levels, but has a name (like `default`).<br>&gt; <br>&gt; 3. Having an extra, unutterable access modifier between `fileprivate` and `private`.<br>&gt; <br>&gt; 4. Using `internal` whenever there&#39;s no access modifier, and not warning if the effective scope is smaller.<br>&gt; <br>&gt; 5. Having an extra access modifier between `fileprivate` and `private`, but which has a name (like `inheritprivate`) <br>&gt; <br>&gt; 6. Changing the definition of `fileprivate` to be within the surrounding private type if there is one, without changing the keyword.<br>&gt; <br>&gt; 7. Changing the definition of `fileprivate` to be within the surrounding private type if there is one, and changing the keyword to match.<br></p><p><br>(The order is Brent’s preferred order, with higher numbers being more preferred.)<br></p><p>If the discussion on SE-0025 is any indication, it’s that Naming Is Hard and that I really don’t want to come up with a new name at this point. Therefore, my preferred solution is (6), followed by (4). The concrete change to the rules I outlined above would be as follows:<br></p><p>- The default level of members is ‘fileprivate’ for a private or fileprivate type, and ‘internal’ for an internal or public type.<br>- Any rule where something must be “as visible as the type” (such as minimum access for required initializers) must be ‘fileprivate’ for a private type (rather than private).<br>- As a consequence, the compiler will warn when the access level of a member is “too high”; that is, where the next level down wouldn’t change anything.<br></p><p>Note that there don’t actually need to be any changes to access rules to make this work; when a type is private, there won’t be any uses of it outside of the enclosing scope, and so nobody elsewhere in the file will be able to call one of those fileprivate members.<br></p><p>—<br></p><p>Ilya hasn’t been active on swift-evolution lately, so if no one has serious objections to (6) besides “I don’t like the name” Robert and I will write up an official amendment to SE-0025 and take it to Doug or Chris. If they think this is not a good idea to just move forward with, I’ll ask them whether they’d prefer a partial implementation that disallows ‘private’ on nominal types, or whether they want to kick the whole proposal back for review (and possibly slipping out of Swift 3).<br></p><p>I am not core team, but I do sit near them and have been able to convince them of things. :-) Hopefully we can get this resolved soon. Thanks again to Robert for bringing it up and everyone else for bringing their minds to bear on the problem!<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/a75e39ab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 23, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 6:03 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Jun 15, 2016, at 18:47, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 15, 2016, at 8:36 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Point 3 is *not* how member lookup applies access control levels to unannotated properties of outer structures (see https://github.com/CodaFi/swift/blob/fb9f9536a5760369457d0f9c49599415cbc36e07/lib/Sema/TypeCheckDecl.cpp#L1470 &lt;https://github.com/CodaFi/swift/blob/fb9f9536a5760369457d0f9c49599415cbc36e07/lib/Sema/TypeCheckDecl.cpp#L1470&gt;) and makes no sense.  They do not default to &quot;internal&quot; when unannotated, they default to the highest possible access level they can get given the decl they&#39;re in.  A private structure will necessarily have private members.  This is the whole point of me raising this issue.  If we were to break containment we would break the very motivation for this proposal.  And if we wish to do this to get this feature right, then the proposal needs to be amended to include that kind of caveat.<br>&gt;&gt; <br>&gt;&gt; This isn’t correct. If the outer type is marked “public”, and its properties are not annotated, those properties will be internal, *not* public, and you will not be able to see them outside of the module.<br>&gt;&gt; <br>&gt;&gt; The rule can basically be summed up as “internal by default, unless we can’t because our enclosing type is more restrictive than internal. Then, be as visible as the enclosing type is.”<br>&gt; <br>&gt; Robert is correct in the current interpretation: the default access level of a members is the access level of the enclosing type, except that nothing is ever public by default, and so you get ‘internal’ if the type is public. This suggests a rule that the access level of a member is never greater than the access level for a type, and the compiler will warn if you break this rule.<br>&gt; <br>&gt; (Citation: I wrote both the implementation and the original proposal &lt;https://github.com/apple/swift/blob/master/docs/AccessControl.rst&gt; for Swift access control. Please let’s not continue talking about the current (pre-SE-0025) behavior or its intent.)<br>&gt; <br>&gt; —<br>&gt; <br>&gt; As everyone has pointed out, this does not produce desirable behavior in the presence of the new ‘private’.<br>&gt; <br>&gt; Here is my understanding of the problem:<br>&gt; <br>&gt; - Blindly applying the current rules, the members of a ‘private&#39; type default to being ‘private&#39;.<br>&gt; - Blindly applying the current rules, the members of a ‘private&#39; type cannot be marked as anything but ‘private’ or the compiler will warn.<br>&gt; <br>&gt; (Thank you Robert for explaining the problem to me in person.)<br>&gt; <br>&gt; —<br></p><p>Right.  I think the basic problem is that a rule mandating things by lexical nesting cannot interwork successfully with an access level that is also based on lexical nesting.<br></p><p>&gt; I think Brent has done a great job of summing up the options with regard to ‘private’ on types:<br>&gt; <br>&gt;&gt; 1. Having an extra, unutterable access modifier that floats relative to the other access levels.<br>&gt;&gt; <br>&gt;&gt; 2. Having an extra access modifiers that floats relative to the other access levels, but has a name (like `default`).<br>&gt;&gt; <br>&gt;&gt; 3. Having an extra, unutterable access modifier between `fileprivate` and `private`.<br>&gt;&gt; <br>&gt;&gt; 4. Using `internal` whenever there&#39;s no access modifier, and not warning if the effective scope is smaller.<br>&gt;&gt; <br>&gt;&gt; 5. Having an extra access modifier between `fileprivate` and `private`, but which has a name (like `inheritprivate`) <br>&gt;&gt; <br>&gt;&gt; 6. Changing the definition of `fileprivate` to be within the surrounding private type if there is one, without changing the keyword.<br>&gt;&gt; <br>&gt;&gt; 7. Changing the definition of `fileprivate` to be within the surrounding private type if there is one, and changing the keyword to match.<br>&gt; <br>&gt; <br>&gt; (The order is Brent’s preferred order, with higher numbers being more preferred.)<br></p><p>Have you considered just removing this no-greater-access rule?  It seems kind of low-value to me, certainly a worthy check for a linter or maybe a warning but an unnecessarily pedantic check to be a hard error.  Just let the actual visibility of a member be limited by the visibility of its context; you might think that would regress diagnostics, but QoI here is pretty easy, e.g. &quot;cannot access member of a private extension from a different file&quot; instead of &quot;cannot access private member from a different file&quot;.  As it is, you can&#39;t just drop the visibility of a type without fixing all of its members.<br></p><p>Otherwise I agree that 6 and 4 are reasonable ways of talking about it.<br></p><p>John.<br></p><p>&gt; <br>&gt; If the discussion on SE-0025 is any indication, it’s that Naming Is Hard and that I really don’t want to come up with a new name at this point. Therefore, my preferred solution is (6), followed by (4). The concrete change to the rules I outlined above would be as follows:<br>&gt; <br>&gt; - The default level of members is ‘fileprivate’ for a private or fileprivate type, and ‘internal’ for an internal or public type.<br>&gt; - Any rule where something must be “as visible as the type” (such as minimum access for required initializers) must be ‘fileprivate’ for a private type (rather than private).<br>&gt; - As a consequence, the compiler will warn when the access level of a member is “too high”; that is, where the next level down wouldn’t change anything.<br>&gt; <br>&gt; Note that there don’t actually need to be any changes to access rules to make this work; when a type is private, there won’t be any uses of it outside of the enclosing scope, and so nobody elsewhere in the file will be able to call one of those fileprivate members.<br>&gt; <br>&gt; —<br>&gt; <br>&gt; Ilya hasn’t been active on swift-evolution lately, so if no one has serious objections to (6) besides “I don’t like the name” Robert and I will write up an official amendment to SE-0025 and take it to Doug or Chris. If they think this is not a good idea to just move forward with, I’ll ask them whether they’d prefer a partial implementation that disallows ‘private’ on nominal types, or whether they want to kick the whole proposal back for review (and possibly slipping out of Swift 3).<br>&gt; <br>&gt; I am not core team, but I do sit near them and have been able to convince them of things. :-) Hopefully we can get this resolved soon. Thanks again to Robert for bringing it up and everyone else for bringing their minds to bear on the problem!<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/c0dc0f48/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 23, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 20:40, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 6:03 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; On Jun 15, 2016, at 18:47, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 15, 2016, at 8:36 PM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Point 3 is *not* how member lookup applies access control levels to unannotated properties of outer structures (see https://github.com/CodaFi/swift/blob/fb9f9536a5760369457d0f9c49599415cbc36e07/lib/Sema/TypeCheckDecl.cpp#L1470 &lt;https://github.com/CodaFi/swift/blob/fb9f9536a5760369457d0f9c49599415cbc36e07/lib/Sema/TypeCheckDecl.cpp#L1470&gt;) and makes no sense.  They do not default to &quot;internal&quot; when unannotated, they default to the highest possible access level they can get given the decl they&#39;re in.  A private structure will necessarily have private members.  This is the whole point of me raising this issue.  If we were to break containment we would break the very motivation for this proposal.  And if we wish to do this to get this feature right, then the proposal needs to be amended to include that kind of caveat.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This isn’t correct. If the outer type is marked “public”, and its properties are not annotated, those properties will be internal, *not* public, and you will not be able to see them outside of the module.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The rule can basically be summed up as “internal by default, unless we can’t because our enclosing type is more restrictive than internal. Then, be as visible as the enclosing type is.”<br>&gt;&gt; <br>&gt;&gt; Robert is correct in the current interpretation: the default access level of a members is the access level of the enclosing type, except that nothing is ever public by default, and so you get ‘internal’ if the type is public. This suggests a rule that the access level of a member is never greater than the access level for a type, and the compiler will warn if you break this rule.<br>&gt;&gt; <br>&gt;&gt; (Citation: I wrote both the implementation and the original proposal &lt;https://github.com/apple/swift/blob/master/docs/AccessControl.rst&gt; for Swift access control. Please let’s not continue talking about the current (pre-SE-0025) behavior or its intent.)<br>&gt;&gt; <br>&gt;&gt; —<br>&gt;&gt; <br>&gt;&gt; As everyone has pointed out, this does not produce desirable behavior in the presence of the new ‘private’.<br>&gt;&gt; <br>&gt;&gt; Here is my understanding of the problem:<br>&gt;&gt; <br>&gt;&gt; - Blindly applying the current rules, the members of a ‘private&#39; type default to being ‘private&#39;.<br>&gt;&gt; - Blindly applying the current rules, the members of a ‘private&#39; type cannot be marked as anything but ‘private’ or the compiler will warn.<br>&gt;&gt; <br>&gt;&gt; (Thank you Robert for explaining the problem to me in person.)<br>&gt;&gt; <br>&gt;&gt; —<br>&gt; <br>&gt; Right.  I think the basic problem is that a rule mandating things by lexical nesting cannot interwork successfully with an access level that is also based on lexical nesting.<br>&gt; <br>&gt;&gt; I think Brent has done a great job of summing up the options with regard to ‘private’ on types:<br>&gt;&gt; <br>&gt;&gt;&gt; 1. Having an extra, unutterable access modifier that floats relative to the other access levels.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Having an extra access modifiers that floats relative to the other access levels, but has a name (like `default`).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. Having an extra, unutterable access modifier between `fileprivate` and `private`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 4. Using `internal` whenever there&#39;s no access modifier, and not warning if the effective scope is smaller.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 5. Having an extra access modifier between `fileprivate` and `private`, but which has a name (like `inheritprivate`) <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 6. Changing the definition of `fileprivate` to be within the surrounding private type if there is one, without changing the keyword.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 7. Changing the definition of `fileprivate` to be within the surrounding private type if there is one, and changing the keyword to match.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; (The order is Brent’s preferred order, with higher numbers being more preferred.)<br>&gt; <br>&gt; Have you considered just removing this no-greater-access rule?  It seems kind of low-value to me, certainly a worthy check for a linter or maybe a warning but an unnecessarily pedantic check to be a hard error.  Just let the actual visibility of a member be limited by the visibility of its context; you might think that would regress diagnostics, but QoI here is pretty easy, e.g. &quot;cannot access member of a private extension from a different file&quot; instead of &quot;cannot access private member from a different file&quot;.  As it is, you can&#39;t just drop the visibility of a type without fixing all of its members.<br></p><p>It is just a warning already, but I think it’s a useful one: &quot;you marked this thing public but the type isn’t, did you make a mistake?” Even with what little coding I get to do in Swift I’ve hit this, though usually the mistake is “I meant to mark the type public too.”<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/ab20d8da/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 27, 2016 at 04:00:00pm</p></header><div class="content"><p>Robert and I wrote up the changes in the form of an amendment to SE-0025: https://github.com/apple/swift-evolution/pull/383 &lt;https://github.com/apple/swift-evolution/pull/383&gt;. Please let me know if we missed anything!<br></p><p>I talked briefly to Chris and he said the core team will decide whether it needs a full review period, or whether it counts as the “obvious” semantics and can thus be accepted without a formal review.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/8a523dc2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 27, 2016 at 07:00:00pm</p></header><div class="content"><p>This looks like good solution that will provide the intended behavior.  Thanks Jordan!<br></p><p>Sent from my iPad<br></p><p>&gt; On Jun 27, 2016, at 6:19 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; Robert and I wrote up the changes in the form of an amendment to SE-0025: https://github.com/apple/swift-evolution/pull/383. Please let me know if we missed anything!<br>&gt; <br>&gt; I talked briefly to Chris and he said the core team will decide whether it needs a full review period, or whether it counts as the “obvious” semantics and can thus be accepted without a formal review.<br>&gt; <br>&gt; Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/c250658c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 28, 2016 at 10:00:00am</p></header><div class="content"><p>Hello everybody,<br></p><p>I tried using the access rules defined in SE-0025 in some code of mine to see what effect it would have. I came out of the experiment more disappointed than I thought. Here are several reasons:<br></p><p>1) The new rules make `private` more prominent compared to `fileprivate` (the latter has a somewhat worse name). But at the same time, the Swift community has developed a style of coding where a type is defined through a set of extensions. To hide members from other types, but have access to them inside the type extensions, we have often used `private` and placed the type and its extensions in the same file. Because `private` is scoped, we are forced into using `fileprivate` pervasively (which is uglier), using `internal` instead (which is less safe) or moving the extension code into the type&#39;s scope (which is against the way Swift code is being written today). All of these options look worse to be than before SE-0025.<br></p><p>2) The new amended rules look complicated to me. I think they have the risk of being confusing in practice, but we’ll have to see.<br></p><p>More generally, I think that the scoping rules of `fileprivate` may have an in insidious effect that favour moving code back into the type’s scope instead of preferring the cleaner style of putting it into extensions.<br></p><p>Potential solution:<br></p><p>What is `private` members were also visible to all extensions of the type in the same module?<br></p><p>David.<br></p><p>&gt; On 28 Jun 2016, at 01:19, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Robert and I wrote up the changes in the form of an amendment to SE-0025: https://github.com/apple/swift-evolution/pull/383 &lt;https://github.com/apple/swift-evolution/pull/383&gt;. Please let me know if we missed anything!<br>&gt; <br>&gt; I talked briefly to Chris and he said the core team will decide whether it needs a full review period, or whether it counts as the “obvious” semantics and can thus be accepted without a formal review.<br>&gt; <br>&gt; Jordan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/54747dc8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 28, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 28 Jun 2016, at 10:14, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What is `private` members were also visible to all extensions of the type in the same module?<br></p><p>PS: That solution would not allow operators to access private members until they stay in the global scope. But if operators do get brought back into the type’s scope, we’re all set.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/33a50592/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 28, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 01:14, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; Hello everybody,<br>&gt; <br>&gt; I tried using the access rules defined in SE-0025 in some code of mine to see what effect it would have. I came out of the experiment more disappointed than I thought. Here are several reasons:<br>&gt; <br>&gt; 1) The new rules make `private` more prominent compared to `fileprivate` (the latter has a somewhat worse name). But at the same time, the Swift community has developed a style of coding where a type is defined through a set of extensions. To hide members from other types, but have access to them inside the type extensions, we have often used `private` and placed the type and its extensions in the same file. Because `private` is scoped, we are forced into using `fileprivate` pervasively (which is uglier), using `internal` instead (which is less safe) or moving the extension code into the type&#39;s scope (which is against the way Swift code is being written today). All of these options look worse to be than before SE-0025.<br>&gt; <br>&gt; 2) The new amended rules look complicated to me. I think they have the risk of being confusing in practice, but we’ll have to see.<br>&gt; <br>&gt; More generally, I think that the scoping rules of `fileprivate` may have an in insidious effect that favour moving code back into the type’s scope instead of preferring the cleaner style of putting it into extensions.<br>&gt; <br>&gt; Potential solution:<br>&gt; <br>&gt; What is `private` members were also visible to all extensions of the type in the same module?<br></p><p>I am strongly against this. Swift uses scope-based privacy; the new ‘private’ is still scope-based. Type-based privacy encourages extensions where none are needed and the right answer was ‘fileprivate’.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/3dee0e03/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 28, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 9:16 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt; On Jun 28, 2016, at 01:14, David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello everybody,<br>&gt;&gt; <br>&gt;&gt; I tried using the access rules defined in SE-0025 in some code of mine to see what effect it would have. I came out of the experiment more disappointed than I thought. Here are several reasons:<br>&gt;&gt; <br>&gt;&gt; 1) The new rules make `private` more prominent compared to `fileprivate` (the latter has a somewhat worse name). But at the same time, the Swift community has developed a style of coding where a type is defined through a set of extensions. To hide members from other types, but have access to them inside the type extensions, we have often used `private` and placed the type and its extensions in the same file. Because `private` is scoped, we are forced into using `fileprivate` pervasively (which is uglier), using `internal` instead (which is less safe) or moving the extension code into the type&#39;s scope (which is against the way Swift code is being written today). All of these options look worse to be than before SE-0025.<br>&gt;&gt; <br>&gt;&gt; 2) The new amended rules look complicated to me. I think they have the risk of being confusing in practice, but we’ll have to see.<br>&gt;&gt; <br>&gt;&gt; More generally, I think that the scoping rules of `fileprivate` may have an in insidious effect that favour moving code back into the type’s scope instead of preferring the cleaner style of putting it into extensions.<br>&gt;&gt; <br>&gt;&gt; Potential solution:<br>&gt;&gt; <br>&gt;&gt; What is `private` members were also visible to all extensions of the type in the same module?<br>&gt; <br>&gt; I am strongly against this. Swift uses scope-based privacy; the new ‘private’ is still scope-based. Type-based privacy encourages extensions where none are needed and the right answer was ‘fileprivate’.<br></p><p>I agree.  This argument seems to be 90% &quot;I feel that fileprivate is an ugly keyword and don&#39;t want to use it&quot;.  The appropriate language evolution response to that is to propose changing the keyword, not to propose new features that aren&#39;t what you actually want.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/6be2d049/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ece55ca3fe50dca9c70bcd914acb48a5?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Judge</string> &lt;matthew.judge at gmail.com&gt;<p>June 28, 2016 at 10:00:00pm</p></header><div class="content"><p>Comments inline.<br></p><p>&gt; On Jun 28, 2016, at 04:14, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello everybody,<br>&gt; <br>&gt; I tried using the access rules defined in SE-0025 in some code of mine to see what effect it would have. I came out of the experiment more disappointed than I thought. Here are several reasons:<br>&gt; <br>&gt; 1) The new rules make `private` more prominent compared to `fileprivate` (the latter has a somewhat worse name). But at the same time, the Swift community has developed a style of coding where a type is defined through a set of extensions. To hide members from other types, but have access to them inside the type extensions, we have often used `private` and placed the type and its extensions in the same file. Because `private` is scoped, we are forced into using `fileprivate` pervasively (which is uglier), using `internal` instead (which is less safe) or moving the extension code into the type&#39;s scope (which is against the way Swift code is being written today). All of these options look worse to be than before SE-0025.<br></p><p>If I understand SE-0025 (even with the amendment) you can still spell the access modifier to types as &#39;private&#39; and get the same characteristics as the pre-SE-0025 meaning or private, so I&#39;m not sure I understand the concern here. However (continued below)<br>&gt; <br>&gt; 2) The new amended rules look complicated to me. I think they have the risk of being confusing in practice, but we’ll have to see.<br>&gt; <br></p><p>I definitely agree that the amended rules look complicated. It seems to me that the amended set of rules is favoring simplifying the implementation over simplifying the mental model.<br></p><p>My impression of what SE-0025 decided was that &#39;private&#39; meant private to the enclosing scope. If the access modifying &#39;private&#39; was applied to a type at the file scope, then it was synonymous with fileprivate and the default access of members of that type should be fileprivate.<br></p><p>If a inner type was declared private, than the default access of members of that inner type should be private to the Outer type, not fileprivate. There is currently no way of expressing this access explicitly, but it does not seem like an especially useful thing to need to spell.<br></p><p>Said in code, my impression of SE-0025 is that <br></p><p>private class Outer { // exactly equivalent to fileprivate<br>    var myVar = 0 // default: fileprivate<br>    private class Inner { // private to Outer<br>        var hiddenVar = 0 // default: private to Outer<br>        private var reallyHiddenVar = 0 // default private to Inner<br>    }<br>}<br></p><p>&gt; More generally, I think that the scoping rules of `fileprivate` may have an in insidious effect that favour moving code back into the type’s scope instead of preferring the cleaner style of putting it into extensions.<br>&gt; <br>&gt; Potential solution:<br>&gt; <br>&gt; What is `private` members were also visible to all extensions of the type in the same module?<br></p><p>Disagree with this solution... It seems like a complete rework of the mental model for access modifiers. None of the existing access modifiers work on types.<br></p><p>&gt; <br>&gt; David.<br>&gt; <br>&gt;&gt; On 28 Jun 2016, at 01:19, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Robert and I wrote up the changes in the form of an amendment to SE-0025: https://github.com/apple/swift-evolution/pull/383. Please let me know if we missed anything!<br>&gt;&gt; <br>&gt;&gt; I talked briefly to Chris and he said the core team will decide whether it needs a full review period, or whether it counts as the “obvious” semantics and can thus be accepted without a formal review.<br>&gt;&gt; <br></p><p>My apologies for getting a bit long winded so far, hopefully I&#39;m not just rehashing the previous arguments.<br></p><p>In regards to Alternative 2 for &quot;the private type issue&quot; and creating an access modifier named &#39;parent&#39; or leaving that access level as without a way to express it: I believe it is acceptable not to add the term. I would expect the most likely situation for this needing to be spelled would be a type accessable to the module with a member only visible to the file. This can already be expressed by fileprivate. <br></p><p>&gt;&gt; Jordan<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/f6b92a30/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 28, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 19:03, Matthew Judge &lt;matthew.judge at gmail.com&gt; wrote:<br>&gt; <br>&gt; Comments inline.<br>&gt; <br>&gt; On Jun 28, 2016, at 04:14, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Hello everybody,<br>&gt;&gt; <br>&gt;&gt; I tried using the access rules defined in SE-0025 in some code of mine to see what effect it would have. I came out of the experiment more disappointed than I thought. Here are several reasons:<br>&gt;&gt; <br>&gt;&gt; 1) The new rules make `private` more prominent compared to `fileprivate` (the latter has a somewhat worse name). But at the same time, the Swift community has developed a style of coding where a type is defined through a set of extensions. To hide members from other types, but have access to them inside the type extensions, we have often used `private` and placed the type and its extensions in the same file. Because `private` is scoped, we are forced into using `fileprivate` pervasively (which is uglier), using `internal` instead (which is less safe) or moving the extension code into the type&#39;s scope (which is against the way Swift code is being written today). All of these options look worse to be than before SE-0025.<br>&gt; <br>&gt; If I understand SE-0025 (even with the amendment) you can still spell the access modifier to types as &#39;private&#39; and get the same characteristics as the pre-SE-0025 meaning or private, so I&#39;m not sure I understand the concern here. However (continued below)<br>&gt;&gt; <br>&gt;&gt; 2) The new amended rules look complicated to me. I think they have the risk of being confusing in practice, but we’ll have to see.<br>&gt;&gt; <br>&gt; <br>&gt; I definitely agree that the amended rules look complicated. It seems to me that the amended set of rules is favoring simplifying the implementation over simplifying the mental model.<br>&gt; <br>&gt; My impression of what SE-0025 decided was that &#39;private&#39; meant private to the enclosing scope. If the access modifying &#39;private&#39; was applied to a type at the file scope, then it was synonymous with fileprivate and the default access of members of that type should be fileprivate.<br>&gt; <br>&gt; If a inner type was declared private, than the default access of members of that inner type should be private to the Outer type, not fileprivate. There is currently no way of expressing this access explicitly, but it does not seem like an especially useful thing to need to spell.<br>&gt; <br>&gt; Said in code, my impression of SE-0025 is that <br>&gt; <br>&gt; private class Outer { // exactly equivalent to fileprivate<br>&gt;     var myVar = 0 // default: fileprivate<br>&gt;     private class Inner { // private to Outer<br>&gt;         var hiddenVar = 0 // default: private to Outer<br>&gt;         private var reallyHiddenVar = 0 // default private to Inner<br>&gt;     }<br>&gt; }<br></p><p>This is definitely one of the considered alternatives. Both Brent and I didn’t like the idea of an access level that you couldn’t actually spell, and even if we got past that, we’d still need a way to refer to it in documentation and diagnostics. I would count that as a larger change than just allowing ‘fileprivate’ in places that previously would have been called redundant.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/c234688b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 28, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 9:06 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 28, 2016, at 19:03, Matthew Judge &lt;matthew.judge at gmail.com &lt;mailto:matthew.judge at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Comments inline.<br>&gt;&gt; <br>&gt;&gt; On Jun 28, 2016, at 04:14, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Hello everybody,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I tried using the access rules defined in SE-0025 in some code of mine to see what effect it would have. I came out of the experiment more disappointed than I thought. Here are several reasons:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) The new rules make `private` more prominent compared to `fileprivate` (the latter has a somewhat worse name). But at the same time, the Swift community has developed a style of coding where a type is defined through a set of extensions. To hide members from other types, but have access to them inside the type extensions, we have often used `private` and placed the type and its extensions in the same file. Because `private` is scoped, we are forced into using `fileprivate` pervasively (which is uglier), using `internal` instead (which is less safe) or moving the extension code into the type&#39;s scope (which is against the way Swift code is being written today). All of these options look worse to be than before SE-0025.<br>&gt;&gt; <br>&gt;&gt; If I understand SE-0025 (even with the amendment) you can still spell the access modifier to types as &#39;private&#39; and get the same characteristics as the pre-SE-0025 meaning or private, so I&#39;m not sure I understand the concern here. However (continued below)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2) The new amended rules look complicated to me. I think they have the risk of being confusing in practice, but we’ll have to see.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I definitely agree that the amended rules look complicated. It seems to me that the amended set of rules is favoring simplifying the implementation over simplifying the mental model.<br>&gt;&gt; <br>&gt;&gt; My impression of what SE-0025 decided was that &#39;private&#39; meant private to the enclosing scope. If the access modifying &#39;private&#39; was applied to a type at the file scope, then it was synonymous with fileprivate and the default access of members of that type should be fileprivate.<br>&gt;&gt; <br>&gt;&gt; If a inner type was declared private, than the default access of members of that inner type should be private to the Outer type, not fileprivate. There is currently no way of expressing this access explicitly, but it does not seem like an especially useful thing to need to spell.<br>&gt;&gt; <br>&gt;&gt; Said in code, my impression of SE-0025 is that <br>&gt;&gt; <br>&gt;&gt; private class Outer { // exactly equivalent to fileprivate<br>&gt;&gt;     var myVar = 0 // default: fileprivate<br>&gt;&gt;     private class Inner { // private to Outer<br>&gt;&gt;         var hiddenVar = 0 // default: private to Outer<br>&gt;&gt;         private var reallyHiddenVar = 0 // default private to Inner<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; <br>&gt; This is definitely one of the considered alternatives. Both Brent and I didn’t like the idea of an access level that you couldn’t actually spell, and even if we got past that, we’d still need a way to refer to it in documentation and diagnostics. I would count that as a larger change than just allowing ‘fileprivate’ in places that previously would have been called redundant.<br></p><p>This was really the fact that didn’t receive adequate attention during discussion and review - that the semantics everyone understood it to have implied visibility for members that you cannot state explicitly.  It didn’t bother me initially, but the diagnostics point Jordan makes is pretty important (I think we could handle it ok in documentation).  Good diagnostics are extremely important and they must be both clear and concise.  In order to have good diagnostics we need a name for the visibility that everyone knows so it may as well be part of the language.<br></p><p>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/45cf1aa8/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ece55ca3fe50dca9c70bcd914acb48a5?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Judge</string> &lt;matthew.judge at gmail.com&gt;<p>June 28, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 22:16, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jun 28, 2016, at 9:06 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 28, 2016, at 19:03, Matthew Judge &lt;matthew.judge at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Comments inline.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 28, 2016, at 04:14, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello everybody,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I tried using the access rules defined in SE-0025 in some code of mine to see what effect it would have. I came out of the experiment more disappointed than I thought. Here are several reasons:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) The new rules make `private` more prominent compared to `fileprivate` (the latter has a somewhat worse name). But at the same time, the Swift community has developed a style of coding where a type is defined through a set of extensions. To hide members from other types, but have access to them inside the type extensions, we have often used `private` and placed the type and its extensions in the same file. Because `private` is scoped, we are forced into using `fileprivate` pervasively (which is uglier), using `internal` instead (which is less safe) or moving the extension code into the type&#39;s scope (which is against the way Swift code is being written today). All of these options look worse to be than before SE-0025.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If I understand SE-0025 (even with the amendment) you can still spell the access modifier to types as &#39;private&#39; and get the same characteristics as the pre-SE-0025 meaning or private, so I&#39;m not sure I understand the concern here. However (continued below)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2) The new amended rules look complicated to me. I think they have the risk of being confusing in practice, but we’ll have to see.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I definitely agree that the amended rules look complicated. It seems to me that the amended set of rules is favoring simplifying the implementation over simplifying the mental model.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My impression of what SE-0025 decided was that &#39;private&#39; meant private to the enclosing scope. If the access modifying &#39;private&#39; was applied to a type at the file scope, then it was synonymous with fileprivate and the default access of members of that type should be fileprivate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If a inner type was declared private, than the default access of members of that inner type should be private to the Outer type, not fileprivate. There is currently no way of expressing this access explicitly, but it does not seem like an especially useful thing to need to spell.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Said in code, my impression of SE-0025 is that <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private class Outer { // exactly equivalent to fileprivate<br>&gt;&gt;&gt;     var myVar = 0 // default: fileprivate<br>&gt;&gt;&gt;     private class Inner { // private to Outer<br>&gt;&gt;&gt;         var hiddenVar = 0 // default: private to Outer<br>&gt;&gt;&gt;         private var reallyHiddenVar = 0 // default private to Inner<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This is definitely one of the considered alternatives. Both Brent and I didn’t like the idea of an access level that you couldn’t actually spell, and even if we got past that, we’d still need a way to refer to it in documentation and diagnostics. I would count that as a larger change than just allowing ‘fileprivate’ in places that previously would have been called redundant.<br>&gt; <br>&gt; This was really the fact that didn’t receive adequate attention during discussion and review - that the semantics everyone understood it to have implied visibility for members that you cannot state explicitly.  It didn’t bother me initially, but the diagnostics point Jordan makes is pretty important (I think we could handle it ok in documentation).  Good diagnostics are extremely important and they must be both clear and concise.  In order to have good diagnostics we need a name for the visibility that everyone knows so it may as well be part of the language.<br>&gt; <br></p><p>I don&#39;t want to reopen the bike shedding, but this issue was one of the main reasons I was in favor of the &#39;private(file)&#39; spelling. &#39;private(Outer)&#39;, &#39;private(Inner)&#39;, etc. fall out as fairly obvious spellings for these cases in my mind.  (The only big negative I see to those spellings is the potential for confusion for anyone too used to type-based access modifiers: that something marked &#39;private(Outer)&#39; would not be visible in &#39;extension Outer {}&#39;)<br></p><p>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/c29faa89/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 10:00:00am</p></header><div class="content"><p>On Tue, Jun 28, 2016 at 9:06 PM, Jordan Rose via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jun 28, 2016, at 19:03, Matthew Judge &lt;matthew.judge at gmail.com&gt; wrote:<br>&gt;<br>&gt; Comments inline.<br>&gt;<br>&gt; On Jun 28, 2016, at 04:14, David Hart via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hello everybody,<br>&gt;<br>&gt; I tried using the access rules defined in SE-0025 in some code of mine to<br>&gt; see what effect it would have. I came out of the experiment more<br>&gt; disappointed than I thought. Here are several reasons:<br>&gt;<br>&gt; 1) The new rules make `private` more prominent compared to `fileprivate`<br>&gt; (the latter has a somewhat worse name). But at the same time, the Swift<br>&gt; community has developed a style of coding where a type is defined through a<br>&gt; set of extensions. To hide members from other types, but have access to<br>&gt; them inside the type extensions, we have often used `private` and placed<br>&gt; the type and its extensions in the same file. Because `private` is scoped,<br>&gt; we are forced into using `fileprivate` pervasively (which is uglier), using<br>&gt; `internal` instead (which is less safe) or moving the extension code into<br>&gt; the type&#39;s scope (which is against the way Swift code is being written<br>&gt; today). All of these options look worse to be than before SE-0025.<br>&gt;<br>&gt;<br>&gt; If I understand SE-0025 (even with the amendment) you can still spell the<br>&gt; access modifier to types as &#39;private&#39; and get the same characteristics as<br>&gt; the pre-SE-0025 meaning or private, so I&#39;m not sure I understand the<br>&gt; concern here. However (continued below)<br>&gt;<br>&gt;<br>&gt; 2) The new amended rules look complicated to me. I think they have the<br>&gt; risk of being confusing in practice, but we’ll have to see.<br>&gt;<br>&gt;<br>&gt; I definitely agree that the amended rules look complicated. It seems to me<br>&gt; that the amended set of rules is favoring simplifying the implementation<br>&gt; over simplifying the mental model.<br>&gt;<br>&gt; My impression of what SE-0025 decided was that &#39;private&#39; meant private to<br>&gt; the enclosing scope. If the access modifying &#39;private&#39; was applied to a<br>&gt; type at the file scope, then it was synonymous with fileprivate and the<br>&gt; default access of members of that type should be fileprivate.<br>&gt;<br>&gt; If a inner type was declared private, than the default access of members<br>&gt; of that inner type should be private to the Outer type, not fileprivate.<br>&gt; There is currently no way of expressing this access explicitly, but it does<br>&gt; not seem like an especially useful thing to need to spell.<br>&gt;<br>&gt; Said in code, my impression of SE-0025 is that<br>&gt;<br>&gt; private class Outer { // exactly equivalent to fileprivate<br>&gt;     var myVar = 0 // default: fileprivate<br>&gt;     private class Inner { // private to Outer<br>&gt;         var hiddenVar = 0 // default: private to Outer<br>&gt;         private var reallyHiddenVar = 0 // default private to Inner<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; This is definitely one of the considered alternatives. Both Brent and I<br>&gt; didn’t like the idea of an access level that you couldn’t actually spell,<br>&gt; and even if we got past that, we’d still need a way to refer to it in<br>&gt; documentation and diagnostics. I would count that as a larger change than<br>&gt; just allowing ‘fileprivate’ in places that previously would have been<br>&gt; called redundant.<br>&gt;<br></p><p>I&#39;m late to the party here, but I share the feeling that perhaps the<br>amendment introduces a complicated mental model. But a lightbulb went off<br>reading the amendment, specifically this parenthetical statement:<br></p><p>&quot;(The members [defaulting to fileprivate inside a private type] still<br>cannot be accessed outside the enclosing lexical scope because the type<br>itself is still private, i.e. outside code will never encounter a value of<br>that type.)&quot;<br></p><p>Given that this is the case, wouldn&#39;t the same problem be entirely obviated<br>by the following change to the formal rules:<br>The default level of access control within any type (public, internal,<br>fileprivate, or private) is `internal`.<br></p><p>In the case of fileprivate or private types, the `internal` members still<br>cannot be accessed where the containing type cannot be accessed.<br></p><p><br></p><p>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/28dfb0f6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 29, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 08:49, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Tue, Jun 28, 2016 at 9:06 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 28, 2016, at 19:03, Matthew Judge &lt;matthew.judge at gmail.com &lt;mailto:matthew.judge at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Comments inline.<br>&gt;&gt; <br>&gt;&gt; On Jun 28, 2016, at 04:14, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Hello everybody,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I tried using the access rules defined in SE-0025 in some code of mine to see what effect it would have. I came out of the experiment more disappointed than I thought. Here are several reasons:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) The new rules make `private` more prominent compared to `fileprivate` (the latter has a somewhat worse name). But at the same time, the Swift community has developed a style of coding where a type is defined through a set of extensions. To hide members from other types, but have access to them inside the type extensions, we have often used `private` and placed the type and its extensions in the same file. Because `private` is scoped, we are forced into using `fileprivate` pervasively (which is uglier), using `internal` instead (which is less safe) or moving the extension code into the type&#39;s scope (which is against the way Swift code is being written today). All of these options look worse to be than before SE-0025.<br>&gt;&gt; <br>&gt;&gt; If I understand SE-0025 (even with the amendment) you can still spell the access modifier to types as &#39;private&#39; and get the same characteristics as the pre-SE-0025 meaning or private, so I&#39;m not sure I understand the concern here. However (continued below)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2) The new amended rules look complicated to me. I think they have the risk of being confusing in practice, but we’ll have to see.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I definitely agree that the amended rules look complicated. It seems to me that the amended set of rules is favoring simplifying the implementation over simplifying the mental model.<br>&gt;&gt; <br>&gt;&gt; My impression of what SE-0025 decided was that &#39;private&#39; meant private to the enclosing scope. If the access modifying &#39;private&#39; was applied to a type at the file scope, then it was synonymous with fileprivate and the default access of members of that type should be fileprivate.<br>&gt;&gt; <br>&gt;&gt; If a inner type was declared private, than the default access of members of that inner type should be private to the Outer type, not fileprivate. There is currently no way of expressing this access explicitly, but it does not seem like an especially useful thing to need to spell.<br>&gt;&gt; <br>&gt;&gt; Said in code, my impression of SE-0025 is that <br>&gt;&gt; <br>&gt;&gt; private class Outer { // exactly equivalent to fileprivate<br>&gt;&gt;     var myVar = 0 // default: fileprivate<br>&gt;&gt;     private class Inner { // private to Outer<br>&gt;&gt;         var hiddenVar = 0 // default: private to Outer<br>&gt;&gt;         private var reallyHiddenVar = 0 // default private to Inner<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; <br>&gt; This is definitely one of the considered alternatives. Both Brent and I didn’t like the idea of an access level that you couldn’t actually spell, and even if we got past that, we’d still need a way to refer to it in documentation and diagnostics. I would count that as a larger change than just allowing ‘fileprivate’ in places that previously would have been called redundant.<br>&gt; <br>&gt; I&#39;m late to the party here, but I share the feeling that perhaps the amendment introduces a complicated mental model. But a lightbulb went off reading the amendment, specifically this parenthetical statement:<br>&gt; <br>&gt; &quot;(The members [defaulting to fileprivate inside a private type] still cannot be accessed outside the enclosing lexical scope because the type itself is still private, i.e. outside code will never encounter a value of that type.)&quot;<br>&gt; <br>&gt; Given that this is the case, wouldn&#39;t the same problem be entirely obviated by the following change to the formal rules:<br>&gt; The default level of access control within any type (public, internal, fileprivate, or private) is `internal`.<br>&gt; <br>&gt; In the case of fileprivate or private types, the `internal` members still cannot be accessed where the containing type cannot be accessed.<br></p><p>That does seem simpler at first, but it doesn’t remove any of the later, more complicated rules about minimum access, and when you can use a less accessible type in a (formally but not in practice) more-accessible declaration. Once those are in place, it seems better to use fileprivate, as the next level up, so that we can still warn about mistaken uses of ‘internal’, and so that we don’t have to special-case code later on in the pipeline that uses visibility to optimize.<br></p><p>(Alternately, I don’t think that’s the part of the mental model people are having trouble with.)<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/81ada421/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 11:00:00am</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 11:31 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jun 29, 2016, at 08:49, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Tue, Jun 28, 2016 at 9:06 PM, Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 28, 2016, at 19:03, Matthew Judge &lt;matthew.judge at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Comments inline.<br>&gt;&gt;<br>&gt;&gt; On Jun 28, 2016, at 04:14, David Hart via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hello everybody,<br>&gt;&gt;<br>&gt;&gt; I tried using the access rules defined in SE-0025 in some code of mine to<br>&gt;&gt; see what effect it would have. I came out of the experiment more<br>&gt;&gt; disappointed than I thought. Here are several reasons:<br>&gt;&gt;<br>&gt;&gt; 1) The new rules make `private` more prominent compared to `fileprivate`<br>&gt;&gt; (the latter has a somewhat worse name). But at the same time, the Swift<br>&gt;&gt; community has developed a style of coding where a type is defined through a<br>&gt;&gt; set of extensions. To hide members from other types, but have access to<br>&gt;&gt; them inside the type extensions, we have often used `private` and placed<br>&gt;&gt; the type and its extensions in the same file. Because `private` is scoped,<br>&gt;&gt; we are forced into using `fileprivate` pervasively (which is uglier), using<br>&gt;&gt; `internal` instead (which is less safe) or moving the extension code into<br>&gt;&gt; the type&#39;s scope (which is against the way Swift code is being written<br>&gt;&gt; today). All of these options look worse to be than before SE-0025.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If I understand SE-0025 (even with the amendment) you can still spell the<br>&gt;&gt; access modifier to types as &#39;private&#39; and get the same characteristics as<br>&gt;&gt; the pre-SE-0025 meaning or private, so I&#39;m not sure I understand the<br>&gt;&gt; concern here. However (continued below)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; 2) The new amended rules look complicated to me. I think they have the<br>&gt;&gt; risk of being confusing in practice, but we’ll have to see.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I definitely agree that the amended rules look complicated. It seems to<br>&gt;&gt; me that the amended set of rules is favoring simplifying the implementation<br>&gt;&gt; over simplifying the mental model.<br>&gt;&gt;<br>&gt;&gt; My impression of what SE-0025 decided was that &#39;private&#39; meant private to<br>&gt;&gt; the enclosing scope. If the access modifying &#39;private&#39; was applied to a<br>&gt;&gt; type at the file scope, then it was synonymous with fileprivate and the<br>&gt;&gt; default access of members of that type should be fileprivate.<br>&gt;&gt;<br>&gt;&gt; If a inner type was declared private, than the default access of members<br>&gt;&gt; of that inner type should be private to the Outer type, not fileprivate.<br>&gt;&gt; There is currently no way of expressing this access explicitly, but it does<br>&gt;&gt; not seem like an especially useful thing to need to spell.<br>&gt;&gt;<br>&gt;&gt; Said in code, my impression of SE-0025 is that<br>&gt;&gt;<br>&gt;&gt; private class Outer { // exactly equivalent to fileprivate<br>&gt;&gt;     var myVar = 0 // default: fileprivate<br>&gt;&gt;     private class Inner { // private to Outer<br>&gt;&gt;         var hiddenVar = 0 // default: private to Outer<br>&gt;&gt;         private var reallyHiddenVar = 0 // default private to Inner<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This is definitely one of the considered alternatives. Both Brent and I<br>&gt;&gt; didn’t like the idea of an access level that you couldn’t actually spell,<br>&gt;&gt; and even if we got past that, we’d still need a way to refer to it in<br>&gt;&gt; documentation and diagnostics. I would count that as a larger change than<br>&gt;&gt; just allowing ‘fileprivate’ in places that previously would have been<br>&gt;&gt; called redundant.<br>&gt;&gt;<br>&gt;<br>&gt; I&#39;m late to the party here, but I share the feeling that perhaps the<br>&gt; amendment introduces a complicated mental model. But a lightbulb went off<br>&gt; reading the amendment, specifically this parenthetical statement:<br>&gt;<br>&gt; &quot;(The members [defaulting to fileprivate inside a private type] still<br>&gt; cannot be accessed outside the enclosing lexical scope because the type<br>&gt; itself is still private, i.e. outside code will never encounter a value of<br>&gt; that type.)&quot;<br>&gt;<br>&gt; Given that this is the case, wouldn&#39;t the same problem be entirely<br>&gt; obviated by the following change to the formal rules:<br>&gt; The default level of access control within any type (public, internal,<br>&gt; fileprivate, or private) is `internal`.<br>&gt;<br>&gt; In the case of fileprivate or private types, the `internal` members still<br>&gt; cannot be accessed where the containing type cannot be accessed.<br>&gt;<br>&gt;<br>&gt; That does seem simpler at first, but it doesn’t remove any of the later,<br>&gt; more complicated rules about *minimum* access, and when you can use a<br>&gt; less accessible type in a (formally but not in practice) more-accessible<br>&gt; declaration.<br>&gt;<br></p><p>Your second rule as written is straight-up ungrammatical, so I can&#39;t say if<br>it makes any sense or becomes any more or less complicated (&quot;a member...may<br>have `private` type&quot;--huh?).<br></p><p>The rule about minimum access is needlessly complicated: `private` can<br>never satisfy a protocol requirement or be used for a required initializer<br>because of the very fact that it is private. We needn&#39;t say that<br>`fileprivate` is the minimum access required since there&#39;s nothing about<br>`fileprivate` that makes it the minimum. Thought experiment: if another<br>access level were to be introduced between `private` and `fileprivate`,<br>that could become the minimum access required. However, no matter what, it<br>is inherent to the SE-0025 definition of `private` that it can never<br>satisfy a requirement.<br></p><p>The rule about members inside extensions with access modifiers is<br>consistent with existing rules and doesn&#39;t need to be called out. That<br>said, does a `private extension` make sense at all?<br></p><p>Once those are in place, it seems better to use fileprivate, as the next<br>&gt; level up, so that we can still warn about mistaken uses of ‘internal’, and<br>&gt; so that we don’t have to special-case code later on in the pipeline that<br>&gt; uses visibility to optimize.<br>&gt;<br></p><p>Mistaken explicit use of `internal` can still be warned on. In your<br>proposal, `fileprivate` inside `private` still leaves room for optimization<br>that would require special-casing, no? In my proposed formulation,<br>`internal` simply takes on the practical meaning of &quot;as visible to the<br>module as can be given what it&#39;s contained in&quot;, which seems like a<br>principled take that could be optimized without regarding it as<br>&quot;special-casing&quot;.<br></p><p><br>&gt;<br>&gt; (Alternately, I don’t think that’s the part of the mental model people are<br>&gt; having trouble with.)<br>&gt;<br></p><p>Maybe it&#39;s just me, but that&#39;s the first part of the mental model that&#39;s<br>exploding my mind.<br></p><p><br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/387c92e8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 29, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 09:59, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 29, 2016 at 11:31 AM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 08:49, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Tue, Jun 28, 2016 at 9:06 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 28, 2016, at 19:03, Matthew Judge &lt;matthew.judge at gmail.com &lt;mailto:matthew.judge at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Comments inline.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 28, 2016, at 04:14, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello everybody,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I tried using the access rules defined in SE-0025 in some code of mine to see what effect it would have. I came out of the experiment more disappointed than I thought. Here are several reasons:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) The new rules make `private` more prominent compared to `fileprivate` (the latter has a somewhat worse name). But at the same time, the Swift community has developed a style of coding where a type is defined through a set of extensions. To hide members from other types, but have access to them inside the type extensions, we have often used `private` and placed the type and its extensions in the same file. Because `private` is scoped, we are forced into using `fileprivate` pervasively (which is uglier), using `internal` instead (which is less safe) or moving the extension code into the type&#39;s scope (which is against the way Swift code is being written today). All of these options look worse to be than before SE-0025.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If I understand SE-0025 (even with the amendment) you can still spell the access modifier to types as &#39;private&#39; and get the same characteristics as the pre-SE-0025 meaning or private, so I&#39;m not sure I understand the concern here. However (continued below)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2) The new amended rules look complicated to me. I think they have the risk of being confusing in practice, but we’ll have to see.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I definitely agree that the amended rules look complicated. It seems to me that the amended set of rules is favoring simplifying the implementation over simplifying the mental model.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My impression of what SE-0025 decided was that &#39;private&#39; meant private to the enclosing scope. If the access modifying &#39;private&#39; was applied to a type at the file scope, then it was synonymous with fileprivate and the default access of members of that type should be fileprivate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If a inner type was declared private, than the default access of members of that inner type should be private to the Outer type, not fileprivate. There is currently no way of expressing this access explicitly, but it does not seem like an especially useful thing to need to spell.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Said in code, my impression of SE-0025 is that <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private class Outer { // exactly equivalent to fileprivate<br>&gt;&gt;&gt;     var myVar = 0 // default: fileprivate<br>&gt;&gt;&gt;     private class Inner { // private to Outer<br>&gt;&gt;&gt;         var hiddenVar = 0 // default: private to Outer<br>&gt;&gt;&gt;         private var reallyHiddenVar = 0 // default private to Inner<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This is definitely one of the considered alternatives. Both Brent and I didn’t like the idea of an access level that you couldn’t actually spell, and even if we got past that, we’d still need a way to refer to it in documentation and diagnostics. I would count that as a larger change than just allowing ‘fileprivate’ in places that previously would have been called redundant.<br>&gt;&gt; <br>&gt;&gt; I&#39;m late to the party here, but I share the feeling that perhaps the amendment introduces a complicated mental model. But a lightbulb went off reading the amendment, specifically this parenthetical statement:<br>&gt;&gt; <br>&gt;&gt; &quot;(The members [defaulting to fileprivate inside a private type] still cannot be accessed outside the enclosing lexical scope because the type itself is still private, i.e. outside code will never encounter a value of that type.)&quot;<br>&gt;&gt; <br>&gt;&gt; Given that this is the case, wouldn&#39;t the same problem be entirely obviated by the following change to the formal rules:<br>&gt;&gt; The default level of access control within any type (public, internal, fileprivate, or private) is `internal`.<br>&gt;&gt; <br>&gt;&gt; In the case of fileprivate or private types, the `internal` members still cannot be accessed where the containing type cannot be accessed.<br>&gt; <br>&gt; That does seem simpler at first, but it doesn’t remove any of the later, more complicated rules about minimum access, and when you can use a less accessible type in a (formally but not in practice) more-accessible declaration.<br>&gt; <br>&gt; Your second rule as written is straight-up ungrammatical, so I can&#39;t say if it makes any sense or becomes any more or less complicated (&quot;a member...may have `private` type&quot;--huh?).<br></p><p>It’s…compiler-grammar? We say something “has pointer type” fairly often within the compiler group. I’ll change it.<br></p><p>“A method, initializer, subscript, property, or typealias with `fileprivate` access may have a type that references `private` declarations if (1) the declaration with `fileprivate` access is a member of a private type, and (2) all referenced `private` declarations are defined within an enclosing lexical scope. That is, it is legal for a `fileprivate` member within a `private` type to have a type that is formally `private` if it would be legal for a `private` declaration in the parent scope to have that type.”<br></p><p>Is this clear, or still senseless?<br></p><p>This rule is intended to allow this case:<br></p><p>struct Outer {<br>  private typealias Value = Int<br>  private struct Inner {<br>    /*fileprivate*/ var value: Value<br>  }<br>}<br></p><p>while disallowing this case:<br></p><p>struct Outer {<br>  private struct Inner {<br>    private typealias Value = Int<br>    fileprivate var value: Value = 0<br>  }<br>}<br></p><p>Do you think that should appear in the proposal text?<br></p><p><br>&gt; <br>&gt; The rule about minimum access is needlessly complicated: `private` can never satisfy a protocol requirement or be used for a required initializer because of the very fact that it is private. We needn&#39;t say that `fileprivate` is the minimum access required since there&#39;s nothing about `fileprivate` that makes it the minimum. Thought experiment: if another access level were to be introduced between `private` and `fileprivate`, that could become the minimum access required. However, no matter what, it is inherent to the SE-0025 definition of `private` that it can never satisfy a requirement.<br></p><p>I admit that I don’t think most people understand what the rules are for minimum access to satisfy a requirement: the minimum of the type’s access and the protocol’s access. But maybe it’s good enough to say “A private member may never satisfy a protocol requirement. Required initializers may not be private.” and not give further justification; the previous changes already allow that. (I already ducked out of justification by saying “to satisfy the spirit of existing requirements”, so this wouldn’t really be any worse.)<br></p><p><br>&gt; The rule about members inside extensions with access modifiers is consistent with existing rules and doesn&#39;t need to be called out. That said, does a `private extension` make sense at all?<br></p><p>I was inclined to write it explicitly after Adrian Z’s proposal to change the behavior of extensions, which implied to me that the current behavior was non-obvious. Since extensions just set the default access level, I could see someone doing this to enforce that access to all of their non-helper API was called out explicitly. I’m not a fan, but it doesn’t seem to hurt anything.<br></p><p><br>&gt; <br>&gt; Once those are in place, it seems better to use fileprivate, as the next level up, so that we can still warn about mistaken uses of ‘internal’, and so that we don’t have to special-case code later on in the pipeline that uses visibility to optimize.<br>&gt; <br>&gt; Mistaken explicit use of `internal` can still be warned on. In your proposal, `fileprivate` inside `private` still leaves room for optimization that would require special-casing, no? In my proposed formulation, `internal` simply takes on the practical meaning of &quot;as visible to the module as can be given what it&#39;s contained in&quot;, which seems like a principled take that could be optimized without regarding it as &quot;special-casing”.<br></p><p>I don’t think there are any cases of ‘fileprivate&#39; that can meaningfully be “optimized” down to ‘private’. Just because no one’s using something outside of the type now doesn’t mean it isn’t used at all. Maybe it’s being used on the other side of a #if branch.<br></p><p><br>&gt;  <br>&gt; <br>&gt; (Alternately, I don’t think that’s the part of the mental model people are having trouble with.)<br>&gt; <br>&gt; Maybe it&#39;s just me, but that&#39;s the first part of the mental model that&#39;s exploding my mind. <br></p><p>Hm. I really didn’t expect this—to me, it’s just “fileprivate is allowed inside private types” and then “fix all the fallout so that the compiler only shouts at you when necessary”. Can you say what the model change is to you?<br></p><p>Thanks for all the feedback.<br>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/7b7c20a8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June 29, 2016 at 07:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>Maybe I&#39;m wrong but as I understood the semantics of the visibility modifiers as this:<br>1) each declaration X has a certain scope S<br>2) sub-declarations of X have the same scope S unless the scope is explicitly stated with a keyword (but rule #8 (about `public` access) is stronger.)<br>3) a sub-declaration can explicitly state its scope, but only if this wouldn&#39;t result in it having a larger scope than its parent-declaration.<br>4) it follows: if X is `internal`, sub-declarations of X are `internal` too. (without proof)<br>5) it follows that: if X is `fileprivate`, sub-declarations are `fileprivate` too. (without proof)<br>6) it DOES NOT follow that: if X is `private`, sub-declarations of X are `private` too. (no proof, but code examples below)<br></p><p>// ***<br></p><p>// Example: ACME/Happy.swift (should compile)<br>private class C {<br>    var foo: Int = 0<br>}<br></p><p>// C is visible here.<br>// C.foo has the same scope as C, so it is visible here too.<br></p><p>func jaa() {<br>    let c = C()<br>    c.foo = 4<br>}<br></p><p>// ***<br></p><p>// Example: ACME/Coyote.swift (should compile too)<br>private class F {<br>    fileprivate func haa() {<br>        print(&quot;haa.&quot;)<br>    }<br>}<br></p><p>// F is visible here.<br>// F.haa is visible here because F.haa is fileprivate.<br>// Since Scope(F) == Scope(F.haa) and therefore Scope(F) &gt;= Scope(F.haa), this is valid.<br>// (with &quot;&gt;&quot; I mean &quot;is strict superset of&quot;, &quot;&gt;=&quot; means &quot;is superset of or equal to&quot;)<br>// (But I do admit that it looks ugly.)<br></p><p>func ha() {<br>    let f = F()<br>    f.haa()<br></p><p>    // This is okay too. jaa is internal<br>    jaa()<br>}<br></p><p>// ***<br></p><p>// Example: ACME/Shy.swift (does not compile)<br>private class S {<br>    private func sayHello() {<br>        print(&quot;Hello?&quot;)<br>    }<br>    // sayHello() is visible here<br>    // C and F are NOT visible here<br>    // ha and jaa are visible here<br>}<br></p><p>// S is visible here<br>// S.sayHello is not visible here<br>// The Scope(S) &gt; Scope(S.sayHello) even though both are private<br>// (with &quot;&gt;&quot; I mean &quot;is strict superset of&quot;)<br></p><p>func noo() {<br>    let s = S() // this works<br>    s.sayHello() // compile error. sayHello() not visible here<br>}<br></p><p>// ***<br></p><p>Isn&#39;t this what `fileprivate` should mean?<br></p><p>For `public`, we add the following set of rules we applied the above rules (which should have higher priority than the rules above):<br>7) A top level declaration is implicitly internal unless specified otherwise.<br>8) A sub-declaration of a declaration with public scope is implicitly internal unless specified otherwise.<br></p><p>-Michael<br></p><p>&gt; Am 29.06.2016 um 19:20 schrieb Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 09:59, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 29, 2016 at 11:31 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 08:49, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Jun 28, 2016 at 9:06 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 28, 2016, at 19:03, Matthew Judge &lt;matthew.judge at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Comments inline.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 28, 2016, at 04:14, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello everybody,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I tried using the access rules defined in SE-0025 in some code of mine to see what effect it would have. I came out of the experiment more disappointed than I thought. Here are several reasons:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1) The new rules make `private` more prominent compared to `fileprivate` (the latter has a somewhat worse name). But at the same time, the Swift community has developed a style of coding where a type is defined through a set of extensions. To hide members from other types, but have access to them inside the type extensions, we have often used `private` and placed the type and its extensions in the same file. Because `private` is scoped, we are forced into using `fileprivate` pervasively (which is uglier), using `internal` instead (which is less safe) or moving the extension code into the type&#39;s scope (which is against the way Swift code is being written today). All of these options look worse to be than before SE-0025.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If I understand SE-0025 (even with the amendment) you can still spell the access modifier to types as &#39;private&#39; and get the same characteristics as the pre-SE-0025 meaning or private, so I&#39;m not sure I understand the concern here. However (continued below)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2) The new amended rules look complicated to me. I think they have the risk of being confusing in practice, but we’ll have to see.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I definitely agree that the amended rules look complicated. It seems to me that the amended set of rules is favoring simplifying the implementation over simplifying the mental model.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My impression of what SE-0025 decided was that &#39;private&#39; meant private to the enclosing scope. If the access modifying &#39;private&#39; was applied to a type at the file scope, then it was synonymous with fileprivate and the default access of members of that type should be fileprivate.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If a inner type was declared private, than the default access of members of that inner type should be private to the Outer type, not fileprivate. There is currently no way of expressing this access explicitly, but it does not seem like an especially useful thing to need to spell.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Said in code, my impression of SE-0025 is that <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; private class Outer { // exactly equivalent to fileprivate<br>&gt;&gt;&gt;&gt;     var myVar = 0 // default: fileprivate<br>&gt;&gt;&gt;&gt;     private class Inner { // private to Outer<br>&gt;&gt;&gt;&gt;         var hiddenVar = 0 // default: private to Outer<br>&gt;&gt;&gt;&gt;         private var reallyHiddenVar = 0 // default private to Inner<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is definitely one of the considered alternatives. Both Brent and I didn’t like the idea of an access level that you couldn’t actually spell, and even if we got past that, we’d still need a way to refer to it in documentation and diagnostics. I would count that as a larger change than just allowing ‘fileprivate’ in places that previously would have been called redundant.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m late to the party here, but I share the feeling that perhaps the amendment introduces a complicated mental model. But a lightbulb went off reading the amendment, specifically this parenthetical statement:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;(The members [defaulting to fileprivate inside a private type] still cannot be accessed outside the enclosing lexical scope because the type itself is still private, i.e. outside code will never encounter a value of that type.)&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given that this is the case, wouldn&#39;t the same problem be entirely obviated by the following change to the formal rules:<br>&gt;&gt;&gt; The default level of access control within any type (public, internal, fileprivate, or private) is `internal`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the case of fileprivate or private types, the `internal` members still cannot be accessed where the containing type cannot be accessed.<br>&gt;&gt; <br>&gt;&gt; That does seem simpler at first, but it doesn’t remove any of the later, more complicated rules about minimum access, and when you can use a less accessible type in a (formally but not in practice) more-accessible declaration.<br>&gt;&gt; <br>&gt;&gt; Your second rule as written is straight-up ungrammatical, so I can&#39;t say if it makes any sense or becomes any more or less complicated (&quot;a member...may have `private` type&quot;--huh?).<br>&gt; <br>&gt; It’s…compiler-grammar? We say something “has pointer type” fairly often within the compiler group. I’ll change it.<br>&gt; <br>&gt; “A method, initializer, subscript, property, or typealias with `fileprivate` access may have a type that references `private` declarations if (1) the declaration with `fileprivate` access is a member of a private type, and (2) all referenced `private` declarations are defined within an enclosing lexical scope. That is, it is legal for a `fileprivate` member within a `private` type to have a type that is formally `private` if it would be legal for a `private` declaration in the parent scope to have that type.”<br>&gt; <br>&gt; Is this clear, or still senseless?<br>&gt; <br>&gt; This rule is intended to allow this case:<br>&gt; <br>&gt; struct Outer {<br>&gt;   private typealias Value = Int<br>&gt;   private struct Inner {<br>&gt;     /*fileprivate*/ var value: Value<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; while disallowing this case:<br>&gt; <br>&gt; struct Outer {<br>&gt;   private struct Inner {<br>&gt;     private typealias Value = Int<br>&gt;     fileprivate var value: Value = 0<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Do you think that should appear in the proposal text?<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; The rule about minimum access is needlessly complicated: `private` can never satisfy a protocol requirement or be used for a required initializer because of the very fact that it is private. We needn&#39;t say that `fileprivate` is the minimum access required since there&#39;s nothing about `fileprivate` that makes it the minimum. Thought experiment: if another access level were to be introduced between `private` and `fileprivate`, that could become the minimum access required. However, no matter what, it is inherent to the SE-0025 definition of `private` that it can never satisfy a requirement.<br>&gt; <br>&gt; I admit that I don’t think most people understand what the rules are for minimum access to satisfy a requirement: the minimum of the type’s access and the protocol’s access. But maybe it’s good enough to say “A private member may never satisfy a protocol requirement. Required initializers may not be private.” and not give further justification; the previous changes already allow that. (I already ducked out of justification by saying “to satisfy the spirit of existing requirements”, so this wouldn’t really be any worse.)<br>&gt; <br>&gt; <br>&gt;&gt; The rule about members inside extensions with access modifiers is consistent with existing rules and doesn&#39;t need to be called out. That said, does a `private extension` make sense at all?<br>&gt; <br>&gt; I was inclined to write it explicitly after Adrian Z’s proposal to change the behavior of extensions, which implied to me that the current behavior was non-obvious. Since extensions just set the default access level, I could see someone doing this to enforce that access to all of their non-helper API was called out explicitly. I’m not a fan, but it doesn’t seem to hurt anything.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Once those are in place, it seems better to use fileprivate, as the next level up, so that we can still warn about mistaken uses of ‘internal’, and so that we don’t have to special-case code later on in the pipeline that uses visibility to optimize.<br>&gt;&gt; <br>&gt;&gt; Mistaken explicit use of `internal` can still be warned on. In your proposal, `fileprivate` inside `private` still leaves room for optimization that would require special-casing, no? In my proposed formulation, `internal` simply takes on the practical meaning of &quot;as visible to the module as can be given what it&#39;s contained in&quot;, which seems like a principled take that could be optimized without regarding it as &quot;special-casing”.<br>&gt; <br>&gt; I don’t think there are any cases of ‘fileprivate&#39; that can meaningfully be “optimized” down to ‘private’. Just because no one’s using something outside of the type now doesn’t mean it isn’t used at all. Maybe it’s being used on the other side of a #if branch.<br>&gt; <br>&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; (Alternately, I don’t think that’s the part of the mental model people are having trouble with.)<br>&gt;&gt; <br>&gt;&gt; Maybe it&#39;s just me, but that&#39;s the first part of the mental model that&#39;s exploding my mind. <br>&gt; <br>&gt; Hm. I really didn’t expect this—to me, it’s just “fileprivate is allowed inside private types” and then “fix all the fallout so that the compiler only shouts at you when necessary”. Can you say what the model change is to you?<br>&gt; <br>&gt; Thanks for all the feedback.<br>&gt; Jordan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 29, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 10:51, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; Maybe I&#39;m wrong but as I understood the semantics of the visibility modifiers as this:<br>&gt; 1) each declaration X has a certain scope S<br>&gt; 2) sub-declarations of X have the same scope S unless the scope is explicitly stated with a keyword (but rule #8 (about `public` access) is stronger.)<br>&gt; 3) a sub-declaration can explicitly state its scope, but only if this wouldn&#39;t result in it having a larger scope than its parent-declaration.<br>&gt; 4) it follows: if X is `internal`, sub-declarations of X are `internal` too. (without proof)<br>&gt; 5) it follows that: if X is `fileprivate`, sub-declarations are `fileprivate` too. (without proof)<br>&gt; 6) it DOES NOT follow that: if X is `private`, sub-declarations of X are `private` too. (no proof, but code examples below)<br>&gt; <br>&gt; // ***<br>&gt; <br>&gt; // Example: ACME/Happy.swift (should compile)<br>&gt; private class C {<br>&gt;    var foo: Int = 0<br>&gt; }<br>&gt; <br>&gt; // C is visible here.<br>&gt; // C.foo has the same scope as C, so it is visible here too.<br>&gt; <br>&gt; func jaa() {<br>&gt;    let c = C()<br>&gt;    c.foo = 4<br>&gt; }<br>&gt; <br>&gt; // ***<br>&gt; <br>&gt; // Example: ACME/Coyote.swift (should compile too)<br>&gt; private class F {<br>&gt;    fileprivate func haa() {<br>&gt;        print(&quot;haa.&quot;)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; // F is visible here.<br>&gt; // F.haa is visible here because F.haa is fileprivate.<br>&gt; // Since Scope(F) == Scope(F.haa) and therefore Scope(F) &gt;= Scope(F.haa), this is valid.<br>&gt; // (with &quot;&gt;&quot; I mean &quot;is strict superset of&quot;, &quot;&gt;=&quot; means &quot;is superset of or equal to&quot;)<br>&gt; // (But I do admit that it looks ugly.)<br>&gt; <br>&gt; func ha() {<br>&gt;    let f = F()<br>&gt;    f.haa()<br>&gt; <br>&gt;    // This is okay too. jaa is internal<br>&gt;    jaa()<br>&gt; }<br>&gt; <br>&gt; // ***<br>&gt; <br>&gt; // Example: ACME/Shy.swift (does not compile)<br>&gt; private class S {<br>&gt;    private func sayHello() {<br>&gt;        print(&quot;Hello?&quot;)<br>&gt;    }<br>&gt;    // sayHello() is visible here<br>&gt;    // C and F are NOT visible here<br>&gt;    // ha and jaa are visible here<br>&gt; }<br>&gt; <br>&gt; // S is visible here<br>&gt; // S.sayHello is not visible here<br>&gt; // The Scope(S) &gt; Scope(S.sayHello) even though both are private<br>&gt; // (with &quot;&gt;&quot; I mean &quot;is strict superset of&quot;)<br>&gt; <br>&gt; func noo() {<br>&gt;    let s = S() // this works<br>&gt;    s.sayHello() // compile error. sayHello() not visible here<br>&gt; }<br>&gt; <br>&gt; // ***<br>&gt; <br>&gt; Isn&#39;t this what `fileprivate` should mean?<br>&gt; <br>&gt; For `public`, we add the following set of rules we applied the above rules (which should have higher priority than the rules above):<br>&gt; 7) A top level declaration is implicitly internal unless specified otherwise.<br>&gt; 8) A sub-declaration of a declaration with public scope is implicitly internal unless specified otherwise.<br></p><p>These might be the rules you want, but they are not the rules in the compiler and they are not mentioned in SE-0025. Again, we weren’t happy with the idea of a “parent&quot; access level that you can’t spell but that still has to show up in diagnostics. If that’s the direction we want to go in, we probably need a full review.<br></p><p>Jordan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June 29, 2016 at 09:00:00pm</p></header><div class="content"><p>Trying to follow the discussion in this thread, but can&#39;t understand what<br>is the main problem with SE-0025 proposal? Could someone describe briefly ?<br>I believe this will help also for others who missed the main point to join<br>the discussion.<br></p><p>As I understand the proposal link is:<br>https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md<br></p><p>I also find `fileprivate` keyword odd/ugly and think we need better name. <br>Was &#39;local&#39; mentioned as alternative?<br></p><p>After reading the proposal, I have a question: do we need to allow <br>`private` access modifier for top-level type? I.e. it seems like any <br>top-level type of function can be only `public`, `internal`(default) or <br>`fileprivate`. It seems for me that `private` for top-lever type just has <br>no sense given the new definition of `private` :  &quot;Properties, functions, <br>and nested types marked this way would be completely hidden outside the <br>class or class extension definition.&quot;<br></p><p>Sorry if I missed something important and all of this was already discussed.<br></p><p>On 29.06.2016 20:53, Jordan Rose via swift-evolution wrote:<br>&gt;<br>&gt;&gt; On Jun 29, 2016, at 10:51, Michael Peternell<br>&gt;&gt; &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi,<br>&gt;&gt;<br>&gt;&gt; Maybe I&#39;m wrong but as I understood the semantics of the visibility<br>&gt;&gt; modifiers as this: 1) each declaration X has a certain scope S 2)<br>&gt;&gt; sub-declarations of X have the same scope S unless the scope is<br>&gt;&gt; explicitly stated with a keyword (but rule #8 (about `public` access)<br>&gt;&gt; is stronger.) 3) a sub-declaration can explicitly state its scope, but<br>&gt;&gt; only if this wouldn&#39;t result in it having a larger scope than its<br>&gt;&gt; parent-declaration. 4) it follows: if X is `internal`,<br>&gt;&gt; sub-declarations of X are `internal` too. (without proof) 5) it<br>&gt;&gt; follows that: if X is `fileprivate`, sub-declarations are<br>&gt;&gt; `fileprivate` too. (without proof) 6) it DOES NOT follow that: if X is<br>&gt;&gt; `private`, sub-declarations of X are `private` too. (no proof, but<br>&gt;&gt; code examples below)<br>&gt;&gt;<br>&gt;&gt; // ***<br>&gt;&gt;<br>&gt;&gt; // Example: ACME/Happy.swift (should compile) private class C { var<br>&gt;&gt; foo: Int = 0 }<br>&gt;&gt;<br>&gt;&gt; // C is visible here. // C.foo has the same scope as C, so it is<br>&gt;&gt; visible here too.<br>&gt;&gt;<br>&gt;&gt; func jaa() { let c = C() c.foo = 4 }<br>&gt;&gt;<br>&gt;&gt; // ***<br>&gt;&gt;<br>&gt;&gt; // Example: ACME/Coyote.swift (should compile too) private class F {<br>&gt;&gt; fileprivate func haa() { print(&quot;haa.&quot;) } }<br>&gt;&gt;<br>&gt;&gt; // F is visible here. // F.haa is visible here because F.haa is<br>&gt;&gt; fileprivate. // Since Scope(F) == Scope(F.haa) and therefore Scope(F)<br>&gt;&gt; &gt;= Scope(F.haa), this is valid. // (with &quot;&gt;&quot; I mean &quot;is strict<br>&gt;&gt; superset of&quot;, &quot;&gt;=&quot; means &quot;is superset of or equal to&quot;) // (But I do<br>&gt;&gt; admit that it looks ugly.)<br>&gt;&gt;<br>&gt;&gt; func ha() { let f = F() f.haa()<br>&gt;&gt;<br>&gt;&gt; // This is okay too. jaa is internal jaa() }<br>&gt;&gt;<br>&gt;&gt; // ***<br>&gt;&gt;<br>&gt;&gt; // Example: ACME/Shy.swift (does not compile) private class S {<br>&gt;&gt; private func sayHello() { print(&quot;Hello?&quot;) } // sayHello() is visible<br>&gt;&gt; here // C and F are NOT visible here // ha and jaa are visible here }<br>&gt;&gt;<br>&gt;&gt; // S is visible here // S.sayHello is not visible here // The Scope(S)<br>&gt;&gt; &gt; Scope(S.sayHello) even though both are private // (with &quot;&gt;&quot; I mean<br>&gt;&gt; &quot;is strict superset of&quot;)<br>&gt;&gt;<br>&gt;&gt; func noo() { let s = S() // this works s.sayHello() // compile error.<br>&gt;&gt; sayHello() not visible here }<br>&gt;&gt;<br>&gt;&gt; // ***<br>&gt;&gt;<br>&gt;&gt; Isn&#39;t this what `fileprivate` should mean?<br>&gt;&gt;<br>&gt;&gt; For `public`, we add the following set of rules we applied the above<br>&gt;&gt; rules (which should have higher priority than the rules above): 7) A<br>&gt;&gt; top level declaration is implicitly internal unless specified<br>&gt;&gt; otherwise. 8) A sub-declaration of a declaration with public scope is<br>&gt;&gt; implicitly internal unless specified otherwise.<br>&gt;<br>&gt; These might be the rules you want, but they are not the rules in the<br>&gt; compiler and they are not mentioned in SE-0025. Again, we weren’t happy<br>&gt; with the idea of a “parent&quot; access level that you can’t spell but that<br>&gt; still has to show up in diagnostics. If that’s the direction we want to<br>&gt; go in, we probably need a full review.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt; _______________________________________________ swift-evolution mailing<br>&gt; list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 12:00:00pm</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 12:20 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jun 29, 2016, at 09:59, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Jun 29, 2016 at 11:31 AM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 29, 2016, at 08:49, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Tue, Jun 28, 2016 at 9:06 PM, Jordan Rose via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jun 28, 2016, at 19:03, Matthew Judge &lt;matthew.judge at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Comments inline.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jun 28, 2016, at 04:14, David Hart via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hello everybody,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I tried using the access rules defined in SE-0025 in some code of mine<br>&gt;&gt;&gt; to see what effect it would have. I came out of the experiment more<br>&gt;&gt;&gt; disappointed than I thought. Here are several reasons:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1) The new rules make `private` more prominent compared to `fileprivate`<br>&gt;&gt;&gt; (the latter has a somewhat worse name). But at the same time, the Swift<br>&gt;&gt;&gt; community has developed a style of coding where a type is defined through a<br>&gt;&gt;&gt; set of extensions. To hide members from other types, but have access to<br>&gt;&gt;&gt; them inside the type extensions, we have often used `private` and placed<br>&gt;&gt;&gt; the type and its extensions in the same file. Because `private` is scoped,<br>&gt;&gt;&gt; we are forced into using `fileprivate` pervasively (which is uglier), using<br>&gt;&gt;&gt; `internal` instead (which is less safe) or moving the extension code into<br>&gt;&gt;&gt; the type&#39;s scope (which is against the way Swift code is being written<br>&gt;&gt;&gt; today). All of these options look worse to be than before SE-0025.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If I understand SE-0025 (even with the amendment) you can still spell<br>&gt;&gt;&gt; the access modifier to types as &#39;private&#39; and get the same characteristics<br>&gt;&gt;&gt; as the pre-SE-0025 meaning or private, so I&#39;m not sure I understand the<br>&gt;&gt;&gt; concern here. However (continued below)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2) The new amended rules look complicated to me. I think they have the<br>&gt;&gt;&gt; risk of being confusing in practice, but we’ll have to see.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I definitely agree that the amended rules look complicated. It seems to<br>&gt;&gt;&gt; me that the amended set of rules is favoring simplifying the implementation<br>&gt;&gt;&gt; over simplifying the mental model.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; My impression of what SE-0025 decided was that &#39;private&#39; meant private<br>&gt;&gt;&gt; to the enclosing scope. If the access modifying &#39;private&#39; was applied to a<br>&gt;&gt;&gt; type at the file scope, then it was synonymous with fileprivate and the<br>&gt;&gt;&gt; default access of members of that type should be fileprivate.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If a inner type was declared private, than the default access of members<br>&gt;&gt;&gt; of that inner type should be private to the Outer type, not fileprivate.<br>&gt;&gt;&gt; There is currently no way of expressing this access explicitly, but it does<br>&gt;&gt;&gt; not seem like an especially useful thing to need to spell.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Said in code, my impression of SE-0025 is that<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; private class Outer { // exactly equivalent to fileprivate<br>&gt;&gt;&gt;     var myVar = 0 // default: fileprivate<br>&gt;&gt;&gt;     private class Inner { // private to Outer<br>&gt;&gt;&gt;         var hiddenVar = 0 // default: private to Outer<br>&gt;&gt;&gt;         private var reallyHiddenVar = 0 // default private to Inner<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is definitely one of the considered alternatives. Both Brent and I<br>&gt;&gt;&gt; didn’t like the idea of an access level that you couldn’t actually spell,<br>&gt;&gt;&gt; and even if we got past that, we’d still need a way to refer to it in<br>&gt;&gt;&gt; documentation and diagnostics. I would count that as a larger change than<br>&gt;&gt;&gt; just allowing ‘fileprivate’ in places that previously would have been<br>&gt;&gt;&gt; called redundant.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;m late to the party here, but I share the feeling that perhaps the<br>&gt;&gt; amendment introduces a complicated mental model. But a lightbulb went off<br>&gt;&gt; reading the amendment, specifically this parenthetical statement:<br>&gt;&gt;<br>&gt;&gt; &quot;(The members [defaulting to fileprivate inside a private type] still<br>&gt;&gt; cannot be accessed outside the enclosing lexical scope because the type<br>&gt;&gt; itself is still private, i.e. outside code will never encounter a value of<br>&gt;&gt; that type.)&quot;<br>&gt;&gt;<br>&gt;&gt; Given that this is the case, wouldn&#39;t the same problem be entirely<br>&gt;&gt; obviated by the following change to the formal rules:<br>&gt;&gt; The default level of access control within any type (public, internal,<br>&gt;&gt; fileprivate, or private) is `internal`.<br>&gt;&gt;<br>&gt;&gt; In the case of fileprivate or private types, the `internal` members still<br>&gt;&gt; cannot be accessed where the containing type cannot be accessed.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That does seem simpler at first, but it doesn’t remove any of the later,<br>&gt;&gt; more complicated rules about *minimum* access, and when you can use a<br>&gt;&gt; less accessible type in a (formally but not in practice) more-accessible<br>&gt;&gt; declaration.<br>&gt;&gt;<br>&gt;<br>&gt; Your second rule as written is straight-up ungrammatical, so I can&#39;t say<br>&gt; if it makes any sense or becomes any more or less complicated (&quot;a<br>&gt; member...may have `private` type&quot;--huh?).<br>&gt;<br>&gt;<br>&gt; It’s…compiler-grammar? We say something “has pointer type” fairly often<br>&gt; within the compiler group. I’ll change it.<br>&gt;<br>&gt; “A method, initializer, subscript, property, or typealias<br>&gt; with `fileprivate` access may have a type that references `private`<br>&gt; declarations if (1) the declaration with `fileprivate` access is a member<br>&gt; of a private type, and (2) all referenced `private` declarations are<br>&gt; defined within an enclosing lexical scope. That is, it is legal for<br>&gt; a `fileprivate` member within a `private` type to have a type that is<br>&gt; formally `private` if it would be legal for a `private` declaration in the<br>&gt; parent scope to have that type.”<br>&gt;<br>&gt; Is this clear, or still senseless?<br>&gt;<br></p><p>That&#39;s very clear now.<br></p><p>Independent of the issue of the written text, though, the idea you are<br>expressing is very complicated and a special case for a generalizable<br>principle. That is, if you loosen the requirement so that a method, etc.,<br>can have an access level formally broader than that of its containing type<br>(in your example below, `Inner`), it should still be permissible for that<br>method to make use of a type with more restrictive access if that<br>restrictive access is at least as broad as that of the containing type.<br></p><p><br>&gt;<br>&gt; This rule is intended to allow this case:<br>&gt;<br>&gt; struct Outer {<br>&gt;   private typealias Value = Int<br>&gt;   private struct Inner {<br>&gt;     /*fileprivate*/ var value: Value<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; while disallowing this case:<br>&gt;<br>&gt; struct Outer {<br>&gt;   private struct Inner {<br>&gt;     private typealias Value = Int<br>&gt;     fileprivate var value: Value = 0<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Do you think that should appear in the proposal text?<br>&gt;<br></p><p>I think that would help.<br></p><p><br>&gt;<br>&gt;<br>&gt;<br>&gt; The rule about minimum access is needlessly complicated: `private` can<br>&gt; never satisfy a protocol requirement or be used for a required initializer<br>&gt; because of the very fact that it is private. We needn&#39;t say that<br>&gt; `fileprivate` is the minimum access required since there&#39;s nothing about<br>&gt; `fileprivate` that makes it the minimum. Thought experiment: if another<br>&gt; access level were to be introduced between `private` and `fileprivate`,<br>&gt; that could become the minimum access required. However, no matter what, it<br>&gt; is inherent to the SE-0025 definition of `private` that it can never<br>&gt; satisfy a requirement.<br>&gt;<br>&gt;<br>&gt; I admit that I don’t think most people understand what the rules are for<br>&gt; minimum access to satisfy a requirement: the minimum of the type’s access<br>&gt; and the protocol’s access. But maybe it’s good enough to say “A private<br>&gt; member may never satisfy a protocol requirement. Required initializers may<br>&gt; not be private.” and not give further justification; the previous changes<br>&gt; already allow that. (I already ducked out of justification by saying “to<br>&gt; satisfy the spirit of existing requirements”, so this wouldn’t really be<br>&gt; any worse.)<br>&gt;<br>&gt;<br>&gt; The rule about members inside extensions with access modifiers is<br>&gt; consistent with existing rules and doesn&#39;t need to be called out. That<br>&gt; said, does a `private extension` make sense at all?<br>&gt;<br>&gt;<br>&gt; I was inclined to write it explicitly after Adrian Z’s proposal to change<br>&gt; the behavior of extensions, which implied to me that the current behavior<br>&gt; was non-obvious. Since extensions just set the default access level, I<br>&gt; could see *someone* doing this to enforce that access to all of their<br>&gt; non-helper API was called out explicitly. I’m not a fan, but it doesn’t<br>&gt; seem to hurt anything.<br>&gt;<br></p><p>It raises a question. Is `foo` inside `private extension { func foo... }`<br>supposed to be exactly the same as that inside `extension { private func<br>foo... }` (i.e. not visible outside the extension)? That seems useless and<br>counterintuitive. However, if not, then `private extension { func foo... }`<br>is equivalent to `fileprivate extension { func foo... }`, which is both<br>confusing and redundant.<br></p><p><br>&gt;<br>&gt;<br>&gt; Once those are in place, it seems better to use fileprivate, as the next<br>&gt;&gt; level up, so that we can still warn about mistaken uses of ‘internal’, and<br>&gt;&gt; so that we don’t have to special-case code later on in the pipeline that<br>&gt;&gt; uses visibility to optimize.<br>&gt;&gt;<br>&gt;<br>&gt; Mistaken explicit use of `internal` can still be warned on. In your<br>&gt; proposal, `fileprivate` inside `private` still leaves room for optimization<br>&gt; that would require special-casing, no? In my proposed formulation,<br>&gt; `internal` simply takes on the practical meaning of &quot;as visible to the<br>&gt; module as can be given what it&#39;s contained in&quot;, which seems like a<br>&gt; principled take that could be optimized without regarding it as<br>&gt; &quot;special-casing”.<br>&gt;<br>&gt;<br>&gt; I don’t think there are any cases of ‘fileprivate&#39; that can meaningfully<br>&gt; be “optimized” down to ‘private’. Just because no one’s using something<br>&gt; outside of the type *now* doesn’t mean it isn’t used at all. Maybe it’s<br>&gt; being used on the other side of a #if branch.<br>&gt;<br></p><p>Sorry, that&#39;s not what I meant. And since I don&#39;t have the best words, it<br>may take me a while to express my point.<br></p><p><br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; (Alternately, I don’t think that’s the part of the mental model people<br>&gt;&gt; are having trouble with.)<br>&gt;&gt;<br>&gt;<br>&gt; Maybe it&#39;s just me, but that&#39;s the first part of the mental model that&#39;s<br>&gt; exploding my mind.<br>&gt;<br>&gt;<br>&gt; Hm. I really didn’t expect this—to me, it’s just “fileprivate is allowed<br>&gt; inside private types” and then “fix all the fallout so that the compiler<br>&gt; only shouts at you when necessary”. Can you say what the model change is to<br>&gt; you?<br>&gt;<br></p><p>With respect to this particular rule, it&#39;s already been pointed out that<br>things are already complicated (public types have default internal members,<br>but internal types have default internal members and fileprivate types have<br>default fileprivate members). Granted, there is a very good rationale for<br>the behavior. However, add yet another subrule and you may has well just<br>have a table, because a general rule that applies to two things with two<br>different exceptions for two other things is essentially no general rule at<br>all. Since the point you&#39;re making is that we have to relax the rules about<br>access levels nested inside types anyway, the most consistent rule I can<br>think of is &quot;the default access level is always internal&quot;. And I think it<br>would actually be workable.<br></p><p>Thanks for all the feedback.<br>&gt; Jordan<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/dfba93cc/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>June 29, 2016 at 01:00:00pm</p></header><div class="content"><p>I know this might be have been brought up before but <br></p><p>why not just disallow the “private&quot; keyword for top level types, extensions etc. <br></p><p>A fixit could change top level `private` to `fileprivate`. <br></p><p>I think this is a little less confusing since effectively this is what is happening in the background. <br></p><p><br>&gt; On Jun 29, 2016, at 10:20 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 09:59, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 29, 2016 at 11:31 AM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 08:49, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Jun 28, 2016 at 9:06 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 28, 2016, at 19:03, Matthew Judge &lt;matthew.judge at gmail.com &lt;mailto:matthew.judge at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Comments inline.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 28, 2016, at 04:14, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello everybody,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I tried using the access rules defined in SE-0025 in some code of mine to see what effect it would have. I came out of the experiment more disappointed than I thought. Here are several reasons:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1) The new rules make `private` more prominent compared to `fileprivate` (the latter has a somewhat worse name). But at the same time, the Swift community has developed a style of coding where a type is defined through a set of extensions. To hide members from other types, but have access to them inside the type extensions, we have often used `private` and placed the type and its extensions in the same file. Because `private` is scoped, we are forced into using `fileprivate` pervasively (which is uglier), using `internal` instead (which is less safe) or moving the extension code into the type&#39;s scope (which is against the way Swift code is being written today). All of these options look worse to be than before SE-0025.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If I understand SE-0025 (even with the amendment) you can still spell the access modifier to types as &#39;private&#39; and get the same characteristics as the pre-SE-0025 meaning or private, so I&#39;m not sure I understand the concern here. However (continued below)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2) The new amended rules look complicated to me. I think they have the risk of being confusing in practice, but we’ll have to see.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I definitely agree that the amended rules look complicated. It seems to me that the amended set of rules is favoring simplifying the implementation over simplifying the mental model.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My impression of what SE-0025 decided was that &#39;private&#39; meant private to the enclosing scope. If the access modifying &#39;private&#39; was applied to a type at the file scope, then it was synonymous with fileprivate and the default access of members of that type should be fileprivate.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If a inner type was declared private, than the default access of members of that inner type should be private to the Outer type, not fileprivate. There is currently no way of expressing this access explicitly, but it does not seem like an especially useful thing to need to spell.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Said in code, my impression of SE-0025 is that <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; private class Outer { // exactly equivalent to fileprivate<br>&gt;&gt;&gt;&gt;     var myVar = 0 // default: fileprivate<br>&gt;&gt;&gt;&gt;     private class Inner { // private to Outer<br>&gt;&gt;&gt;&gt;         var hiddenVar = 0 // default: private to Outer<br>&gt;&gt;&gt;&gt;         private var reallyHiddenVar = 0 // default private to Inner<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is definitely one of the considered alternatives. Both Brent and I didn’t like the idea of an access level that you couldn’t actually spell, and even if we got past that, we’d still need a way to refer to it in documentation and diagnostics. I would count that as a larger change than just allowing ‘fileprivate’ in places that previously would have been called redundant.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m late to the party here, but I share the feeling that perhaps the amendment introduces a complicated mental model. But a lightbulb went off reading the amendment, specifically this parenthetical statement:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;(The members [defaulting to fileprivate inside a private type] still cannot be accessed outside the enclosing lexical scope because the type itself is still private, i.e. outside code will never encounter a value of that type.)&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given that this is the case, wouldn&#39;t the same problem be entirely obviated by the following change to the formal rules:<br>&gt;&gt;&gt; The default level of access control within any type (public, internal, fileprivate, or private) is `internal`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the case of fileprivate or private types, the `internal` members still cannot be accessed where the containing type cannot be accessed.<br>&gt;&gt; <br>&gt;&gt; That does seem simpler at first, but it doesn’t remove any of the later, more complicated rules about minimum access, and when you can use a less accessible type in a (formally but not in practice) more-accessible declaration.<br>&gt;&gt; <br>&gt;&gt; Your second rule as written is straight-up ungrammatical, so I can&#39;t say if it makes any sense or becomes any more or less complicated (&quot;a member...may have `private` type&quot;--huh?).<br>&gt; <br>&gt; It’s…compiler-grammar? We say something “has pointer type” fairly often within the compiler group. I’ll change it.<br>&gt; <br>&gt; “A method, initializer, subscript, property, or typealias with `fileprivate` access may have a type that references `private` declarations if (1) the declaration with `fileprivate` access is a member of a private type, and (2) all referenced `private` declarations are defined within an enclosing lexical scope. That is, it is legal for a `fileprivate` member within a `private` type to have a type that is formally `private` if it would be legal for a `private` declaration in the parent scope to have that type.”<br>&gt; <br>&gt; Is this clear, or still senseless?<br>&gt; <br>&gt; This rule is intended to allow this case:<br>&gt; <br>&gt; struct Outer {<br>&gt;   private typealias Value = Int<br>&gt;   private struct Inner {<br>&gt;     /*fileprivate*/ var value: Value<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; while disallowing this case:<br>&gt; <br>&gt; struct Outer {<br>&gt;   private struct Inner {<br>&gt;     private typealias Value = Int<br>&gt;     fileprivate var value: Value = 0<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Do you think that should appear in the proposal text?<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; The rule about minimum access is needlessly complicated: `private` can never satisfy a protocol requirement or be used for a required initializer because of the very fact that it is private. We needn&#39;t say that `fileprivate` is the minimum access required since there&#39;s nothing about `fileprivate` that makes it the minimum. Thought experiment: if another access level were to be introduced between `private` and `fileprivate`, that could become the minimum access required. However, no matter what, it is inherent to the SE-0025 definition of `private` that it can never satisfy a requirement.<br>&gt; <br>&gt; I admit that I don’t think most people understand what the rules are for minimum access to satisfy a requirement: the minimum of the type’s access and the protocol’s access. But maybe it’s good enough to say “A private member may never satisfy a protocol requirement. Required initializers may not be private.” and not give further justification; the previous changes already allow that. (I already ducked out of justification by saying “to satisfy the spirit of existing requirements”, so this wouldn’t really be any worse.)<br>&gt; <br>&gt; <br>&gt;&gt; The rule about members inside extensions with access modifiers is consistent with existing rules and doesn&#39;t need to be called out. That said, does a `private extension` make sense at all?<br>&gt; <br>&gt; I was inclined to write it explicitly after Adrian Z’s proposal to change the behavior of extensions, which implied to me that the current behavior was non-obvious. Since extensions just set the default access level, I could see someone doing this to enforce that access to all of their non-helper API was called out explicitly. I’m not a fan, but it doesn’t seem to hurt anything.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Once those are in place, it seems better to use fileprivate, as the next level up, so that we can still warn about mistaken uses of ‘internal’, and so that we don’t have to special-case code later on in the pipeline that uses visibility to optimize.<br>&gt;&gt; <br>&gt;&gt; Mistaken explicit use of `internal` can still be warned on. In your proposal, `fileprivate` inside `private` still leaves room for optimization that would require special-casing, no? In my proposed formulation, `internal` simply takes on the practical meaning of &quot;as visible to the module as can be given what it&#39;s contained in&quot;, which seems like a principled take that could be optimized without regarding it as &quot;special-casing”.<br>&gt; <br>&gt; I don’t think there are any cases of ‘fileprivate&#39; that can meaningfully be “optimized” down to ‘private’. Just because no one’s using something outside of the type now doesn’t mean it isn’t used at all. Maybe it’s being used on the other side of a #if branch.<br>&gt; <br>&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; (Alternately, I don’t think that’s the part of the mental model people are having trouble with.)<br>&gt;&gt; <br>&gt;&gt; Maybe it&#39;s just me, but that&#39;s the first part of the mental model that&#39;s exploding my mind. <br>&gt; <br>&gt; Hm. I really didn’t expect this—to me, it’s just “fileprivate is allowed inside private types” and then “fix all the fallout so that the compiler only shouts at you when necessary”. Can you say what the model change is to you?<br>&gt; <br>&gt; Thanks for all the feedback.<br>&gt; Jordan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/620dd138/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 29, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com&gt; wrote:<br>&gt; <br>&gt; I know this might be have been brought up before but <br>&gt; <br>&gt; why not just disallow the “private&quot; keyword for top level types, extensions etc. <br>&gt; <br>&gt; A fixit could change top level `private` to `fileprivate`. <br>&gt; <br>&gt; I think this is a little less confusing since effectively this is what is happening in the background. <br></p><p>That doesn’t fix anything for inner types, so it’s a lot less important than the rest of the amendment.<br></p><p>There actually is an answer to this, which is that the core team expects &#39;private&#39; to be the common keyword, and therefore it’s better if you can use it at the top level and ignore ‘fileprivate’ altogether in most programs.<br></p><p>Jordan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 04:00:00pm</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I know this might be have been brought up before but<br>&gt; &gt;<br>&gt; &gt; why not just disallow the “private&quot; keyword for top level types,<br>&gt; extensions etc.<br>&gt; &gt;<br>&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt; &gt;<br>&gt; &gt; I think this is a little less confusing since effectively this is what<br>&gt; is happening in the background.<br>&gt;<br>&gt; That doesn’t fix anything for inner types, so it’s a lot less important<br>&gt; than the rest of the amendment.<br>&gt;<br>&gt; There actually is an answer to this, which is that the core team expects<br>&gt; &#39;private&#39; to be the common keyword, and therefore it’s better if you can<br>&gt; use it at the top level and ignore ‘fileprivate’ altogether in most<br>&gt; programs.<br>&gt;<br></p><p>On second thought, wouldn&#39;t all of this be inapplicable if `private`<br>literally meant visibility *only* within the current declaration, and<br>neither outside it nor inside any nested types, etc.?<br></p><p><br>&gt;<br>&gt; Jordan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/6b23ade9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 29, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com &lt;mailto:cheyo at masters3d.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I know this might be have been brought up before but<br>&gt; &gt;<br>&gt; &gt; why not just disallow the “private&quot; keyword for top level types, extensions etc.<br>&gt; &gt;<br>&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt; &gt;<br>&gt; &gt; I think this is a little less confusing since effectively this is what is happening in the background.<br>&gt; <br>&gt; That doesn’t fix anything for inner types, so it’s a lot less important than the rest of the amendment.<br>&gt; <br>&gt; There actually is an answer to this, which is that the core team expects &#39;private&#39; to be the common keyword, and therefore it’s better if you can use it at the top level and ignore ‘fileprivate’ altogether in most programs.<br>&gt; <br>&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private` literally meant visibility *only* within the current declaration, and neither outside it nor inside any nested types, etc.?<br></p><p>Yes, but that&#39;s not very useful:<br></p><p>public struct Foo {<br>  private var value: Int = 0<br>  public func test() {<br>    print(value) // error<br>  }<br>}<br></p><p>I suppose you could say that nested types are different from nested functions, but then we start getting complexity in a different direction. And it still doesn&#39;t fix the default access within a private type.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/481367db/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 04:00:00pm</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 4:07 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types,<br>&gt;&gt; extensions etc.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I think this is a little less confusing since effectively this is what<br>&gt;&gt; is happening in the background.<br>&gt;&gt;<br>&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less important<br>&gt;&gt; than the rest of the amendment.<br>&gt;&gt;<br>&gt;&gt; There actually is an answer to this, which is that the core team expects<br>&gt;&gt; &#39;private&#39; to be the common keyword, and therefore it’s better if you can<br>&gt;&gt; use it at the top level and ignore ‘fileprivate’ altogether in most<br>&gt;&gt; programs.<br>&gt;&gt;<br>&gt;<br>&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private`<br>&gt; literally meant visibility *only* within the current declaration, and<br>&gt; neither outside it nor inside any nested types, etc.?<br>&gt;<br>&gt;<br>&gt; Yes, but that&#39;s not very useful:<br>&gt;<br>&gt; public struct Foo {<br>&gt;   private var value: Int = 0<br>&gt;   public func test() {<br>&gt;     print(value) // error<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; I suppose you could say that nested *types* are different from nested<br>&gt; *functions,* but then we start getting complexity in a different<br>&gt; direction. And it still doesn&#39;t fix the default access within a private<br>&gt; type.<br>&gt;<br></p><p>Let me offer a principled rule: if I write `private var foo`, then `foo` is<br>invisible at such places within the declaration where writing `private var<br>bar` at the same place would cause `bar` to be visible where `foo` is not<br>or vice versa.<br></p><p><br>&gt; Jordan<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/e37e0bd9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 29, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 14:12, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 29, 2016 at 4:07 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com &lt;mailto:cheyo at masters3d.com&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types, extensions etc.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I think this is a little less confusing since effectively this is what is happening in the background.<br>&gt;&gt; <br>&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less important than the rest of the amendment.<br>&gt;&gt; <br>&gt;&gt; There actually is an answer to this, which is that the core team expects &#39;private&#39; to be the common keyword, and therefore it’s better if you can use it at the top level and ignore ‘fileprivate’ altogether in most programs.<br>&gt;&gt; <br>&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private` literally meant visibility *only* within the current declaration, and neither outside it nor inside any nested types, etc.?<br>&gt; <br>&gt; Yes, but that&#39;s not very useful:<br>&gt; <br>&gt; public struct Foo {<br>&gt;   private var value: Int = 0<br>&gt;   public func test() {<br>&gt;     print(value) // error<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; I suppose you could say that nested types are different from nested functions, but then we start getting complexity in a different direction. And it still doesn&#39;t fix the default access within a private type.<br>&gt; <br>&gt; Let me offer a principled rule: if I write `private var foo`, then `foo` is invisible at such places within the declaration where writing `private var bar` at the same place would cause `bar` to be visible where `foo` is not or vice versa.<br></p><p>I’m sorry, I don’t understand. <br></p><p>Stepping back, though, this part of the proposal was discussed back when it was first going through, and it was settled (after some disagreement and discussion) that pure lexical scoping was the best choice.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/3611581a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 04:00:00pm</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 4:15 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jun 29, 2016, at 14:12, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Jun 29, 2016 at 4:07 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types,<br>&gt;&gt;&gt; extensions etc.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I think this is a little less confusing since effectively this is what<br>&gt;&gt;&gt; is happening in the background.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less important<br>&gt;&gt;&gt; than the rest of the amendment.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There actually is an answer to this, which is that the core team expects<br>&gt;&gt;&gt; &#39;private&#39; to be the common keyword, and therefore it’s better if you can<br>&gt;&gt;&gt; use it at the top level and ignore ‘fileprivate’ altogether in most<br>&gt;&gt;&gt; programs.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private`<br>&gt;&gt; literally meant visibility *only* within the current declaration, and<br>&gt;&gt; neither outside it nor inside any nested types, etc.?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes, but that&#39;s not very useful:<br>&gt;&gt;<br>&gt;&gt; public struct Foo {<br>&gt;&gt;   private var value: Int = 0<br>&gt;&gt;   public func test() {<br>&gt;&gt;     print(value) // error<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I suppose you could say that nested *types* are different from nested<br>&gt;&gt; *functions,* but then we start getting complexity in a different<br>&gt;&gt; direction. And it still doesn&#39;t fix the default access within a private<br>&gt;&gt; type.<br>&gt;&gt;<br>&gt;<br>&gt; Let me offer a principled rule: if I write `private var foo`, then `foo`<br>&gt; is invisible at such places within the declaration where writing `private<br>&gt; var bar` at the same place would cause `bar` to be visible where `foo` is<br>&gt; not or vice versa.<br>&gt;<br>&gt;<br>&gt; I’m sorry, I don’t understand.<br>&gt;<br>&gt; Stepping back, though, this part of the proposal *was* discussed back<br>&gt; when it was first going through, and it was settled (after some<br>&gt; disagreement and discussion) that pure lexical scoping was the best choice.<br>&gt;<br></p><p>I entirely misunderstood that part of the debate. I had thought the gist of<br>the discussion was that SE-0025 itself was an explicit break from purely<br>lexical scoping, that the proponents of pure lexical scoping were arguing<br>against its adoption, and that its acceptance by the core team was a move<br>away from purely lexical scoping.<br></p><p>Let me see if I can rephrase the difficulty as I perceive it. I had thought<br>that this was an equivalent formulation of the problem that you are<br>addressing with the amendment. The interpretation of `private` as a purely<br>lexical scope results in the scenario as follows:<br></p><p>1. I declare `private var foo`<br>2. There are places in code where `foo` is visible but where its access<br>level cannot be uttered (e.g., within a nested type, `foo` is not private<br>to that nested type, but it is more narrow in scope than fileprivate,<br>internal, or public)<br></p><p>Your proposal is to allow `fileprivate` to be used in place of the<br>unutterable access level. This seems like a hack. The necessity for it<br>would go away if we stipulated `private` to exclude all places in code<br>where `foo` is visible but where its access level cannot be uttered.<br></p><p><br></p><p>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/3415d6ff/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 4:30 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 29, 2016 at 4:15 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 14:12, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 29, 2016 at 4:07 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com &lt;mailto:cheyo at masters3d.com&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types, extensions etc.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I think this is a little less confusing since effectively this is what is happening in the background.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less important than the rest of the amendment.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There actually is an answer to this, which is that the core team expects &#39;private&#39; to be the common keyword, and therefore it’s better if you can use it at the top level and ignore ‘fileprivate’ altogether in most programs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private` literally meant visibility *only* within the current declaration, and neither outside it nor inside any nested types, etc.?<br>&gt;&gt; <br>&gt;&gt; Yes, but that&#39;s not very useful:<br>&gt;&gt; <br>&gt;&gt; public struct Foo {<br>&gt;&gt;   private var value: Int = 0<br>&gt;&gt;   public func test() {<br>&gt;&gt;     print(value) // error<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I suppose you could say that nested types are different from nested functions, but then we start getting complexity in a different direction. And it still doesn&#39;t fix the default access within a private type.<br>&gt;&gt; <br>&gt;&gt; Let me offer a principled rule: if I write `private var foo`, then `foo` is invisible at such places within the declaration where writing `private var bar` at the same place would cause `bar` to be visible where `foo` is not or vice versa.<br>&gt; <br>&gt; I’m sorry, I don’t understand. <br>&gt; <br>&gt; Stepping back, though, this part of the proposal was discussed back when it was first going through, and it was settled (after some disagreement and discussion) that pure lexical scoping was the best choice.<br>&gt; <br>&gt; I entirely misunderstood that part of the debate. I had thought the gist of the discussion was that SE-0025 itself was an explicit break from purely lexical scoping, that the proponents of pure lexical scoping were arguing against its adoption, and that its acceptance by the core team was a move away from purely lexical scoping.<br>&gt; <br>&gt; Let me see if I can rephrase the difficulty as I perceive it. I had thought that this was an equivalent formulation of the problem that you are addressing with the amendment. The interpretation of `private` as a purely lexical scope results in the scenario as follows:<br>&gt; <br>&gt; 1. I declare `private var foo`<br>&gt; 2. There are places in code where `foo` is visible but where its access level cannot be uttered (e.g., within a nested type, `foo` is not private to that nested type, but it is more narrow in scope than fileprivate, internal, or public)<br>&gt; <br>&gt; Your proposal is to allow `fileprivate` to be used in place of the unutterable access level. This seems like a hack. The necessity for it would go away if we stipulated `private` to exclude all places in code where `foo` is visible but where its access level cannot be uttered.<br></p><p>You have this wrong.  It is not that you declare `private var foo` and then in specific places it is visible but you can’t utter its access control.  <br></p><p>The problem is when you use `private` on any construct which introduces a scope that contains further declarations.  You cannot utter the default access control for the members of that scope.  Here are examples:<br></p><p>private struct S {<br>    var foo: Int<br>}<br>private class C {<br>    var foo: Int<br>}<br>private enum E {<br>    var foo: Int { return 42 }<br>}<br>private extension S {<br>    func bar() {}<br>}<br> <br>In all of these examples `foo` and `bar` are visible within the top level scope, but not outside the file.  In this case that happens to correspond to `fileprivate` which is probably why Jordan selected that keyword.  In cases where these are not top level declarations, but nested within a scope these will be visible within that scope, but not at the top level of the file.  In *no* case does the unutterable access level correspond to *internal* which is probably why Jordan did not suggest using that.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt;  <br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/bd115fc5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 05:00:00pm</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 5:25 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jun 29, 2016, at 4:30 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Wed, Jun 29, 2016 at 4:15 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 29, 2016, at 14:12, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Wed, Jun 29, 2016 at 4:07 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types,<br>&gt;&gt;&gt;&gt; extensions etc.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I think this is a little less confusing since effectively this is<br>&gt;&gt;&gt;&gt; what is happening in the background.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less important<br>&gt;&gt;&gt;&gt; than the rest of the amendment.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; There actually is an answer to this, which is that the core team<br>&gt;&gt;&gt;&gt; expects &#39;private&#39; to be the common keyword, and therefore it’s better if<br>&gt;&gt;&gt;&gt; you can use it at the top level and ignore ‘fileprivate’ altogether in most<br>&gt;&gt;&gt;&gt; programs.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private`<br>&gt;&gt;&gt; literally meant visibility *only* within the current declaration, and<br>&gt;&gt;&gt; neither outside it nor inside any nested types, etc.?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes, but that&#39;s not very useful:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public struct Foo {<br>&gt;&gt;&gt;   private var value: Int = 0<br>&gt;&gt;&gt;   public func test() {<br>&gt;&gt;&gt;     print(value) // error<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I suppose you could say that nested *types* are different from nested<br>&gt;&gt;&gt; *functions,* but then we start getting complexity in a different<br>&gt;&gt;&gt; direction. And it still doesn&#39;t fix the default access within a private<br>&gt;&gt;&gt; type.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Let me offer a principled rule: if I write `private var foo`, then `foo`<br>&gt;&gt; is invisible at such places within the declaration where writing `private<br>&gt;&gt; var bar` at the same place would cause `bar` to be visible where `foo` is<br>&gt;&gt; not or vice versa.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I’m sorry, I don’t understand.<br>&gt;&gt;<br>&gt;&gt; Stepping back, though, this part of the proposal *was* discussed back<br>&gt;&gt; when it was first going through, and it was settled (after some<br>&gt;&gt; disagreement and discussion) that pure lexical scoping was the best choice.<br>&gt;&gt;<br>&gt;<br>&gt; I entirely misunderstood that part of the debate. I had thought the gist<br>&gt; of the discussion was that SE-0025 itself was an explicit break from purely<br>&gt; lexical scoping, that the proponents of pure lexical scoping were arguing<br>&gt; against its adoption, and that its acceptance by the core team was a move<br>&gt; away from purely lexical scoping.<br>&gt;<br>&gt; Let me see if I can rephrase the difficulty as I perceive it. I had<br>&gt; thought that this was an equivalent formulation of the problem that you are<br>&gt; addressing with the amendment. The interpretation of `private` as a purely<br>&gt; lexical scope results in the scenario as follows:<br>&gt;<br>&gt; 1. I declare `private var foo`<br>&gt; 2. There are places in code where `foo` is visible but where its access<br>&gt; level cannot be uttered (e.g., within a nested type, `foo` is not private<br>&gt; to that nested type, but it is more narrow in scope than fileprivate,<br>&gt; internal, or public)<br>&gt;<br>&gt; Your proposal is to allow `fileprivate` to be used in place of the<br>&gt; unutterable access level. This seems like a hack. The necessity for it<br>&gt; would go away if we stipulated `private` to exclude all places in code<br>&gt; where `foo` is visible but where its access level cannot be uttered.<br>&gt;<br>&gt;<br>&gt; You have this wrong.  It is not that you declare `private var foo` and<br>&gt; then in specific places it is visible but you can’t utter its access<br>&gt; control.<br>&gt;<br>&gt; The problem is when you use `private` on any construct which introduces a<br>&gt; scope that contains further declarations.  You cannot utter the default<br>&gt; access control for the members of that scope.  Here are examples:<br>&gt;<br>&gt; private struct S {<br>&gt;     var foo: Int<br>&gt; }<br>&gt; private class C {<br>&gt;     var foo: Int<br>&gt; }<br>&gt; private enum E {<br>&gt;     var foo: Int { return 42 }<br>&gt; }<br>&gt; private extension S {<br>&gt;     func bar() {}<br>&gt; }<br>&gt;<br>&gt; In all of these examples `foo` and `bar` are visible within the top level<br>&gt; scope, but not outside the file.<br>&gt;<br></p><p>Sorry, yes, that is one problem. The related problem I was trying to<br>describe was this:<br></p><p>```<br>public struct A {<br>  private var foo: Int<br>  internal struct B {<br>    // I cannot utter the access control for `foo` here<br>    // and there is nothing I can declare here to be visible<br>    // exactly where `foo` is visible<br>  }<br>}<br>```<br></p><p><br>&gt; In this case that happens to correspond to `fileprivate` which is probably<br>&gt; why Jordan selected that keyword.  In cases where these are not top level<br>&gt; declarations, but nested within a scope these will be visible within that<br>&gt; scope, but not at the top level of the file.  In *no* case does the<br>&gt; unutterable access level correspond to *internal* which is probably why<br>&gt; Jordan did not suggest using that.<br>&gt;<br>&gt; -Matthew<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/a34989cf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 5:30 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 29, 2016 at 5:25 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 4:30 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 29, 2016 at 4:15 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 14:12, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:07 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com &lt;mailto:cheyo at masters3d.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types, extensions etc.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I think this is a little less confusing since effectively this is what is happening in the background.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less important than the rest of the amendment.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There actually is an answer to this, which is that the core team expects &#39;private&#39; to be the common keyword, and therefore it’s better if you can use it at the top level and ignore ‘fileprivate’ altogether in most programs.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private` literally meant visibility *only* within the current declaration, and neither outside it nor inside any nested types, etc.?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, but that&#39;s not very useful:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public struct Foo {<br>&gt;&gt;&gt;   private var value: Int = 0<br>&gt;&gt;&gt;   public func test() {<br>&gt;&gt;&gt;     print(value) // error<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I suppose you could say that nested types are different from nested functions, but then we start getting complexity in a different direction. And it still doesn&#39;t fix the default access within a private type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let me offer a principled rule: if I write `private var foo`, then `foo` is invisible at such places within the declaration where writing `private var bar` at the same place would cause `bar` to be visible where `foo` is not or vice versa.<br>&gt;&gt; <br>&gt;&gt; I’m sorry, I don’t understand. <br>&gt;&gt; <br>&gt;&gt; Stepping back, though, this part of the proposal was discussed back when it was first going through, and it was settled (after some disagreement and discussion) that pure lexical scoping was the best choice.<br>&gt;&gt; <br>&gt;&gt; I entirely misunderstood that part of the debate. I had thought the gist of the discussion was that SE-0025 itself was an explicit break from purely lexical scoping, that the proponents of pure lexical scoping were arguing against its adoption, and that its acceptance by the core team was a move away from purely lexical scoping.<br>&gt;&gt; <br>&gt;&gt; Let me see if I can rephrase the difficulty as I perceive it. I had thought that this was an equivalent formulation of the problem that you are addressing with the amendment. The interpretation of `private` as a purely lexical scope results in the scenario as follows:<br>&gt;&gt; <br>&gt;&gt; 1. I declare `private var foo`<br>&gt;&gt; 2. There are places in code where `foo` is visible but where its access level cannot be uttered (e.g., within a nested type, `foo` is not private to that nested type, but it is more narrow in scope than fileprivate, internal, or public)<br>&gt;&gt; <br>&gt;&gt; Your proposal is to allow `fileprivate` to be used in place of the unutterable access level. This seems like a hack. The necessity for it would go away if we stipulated `private` to exclude all places in code where `foo` is visible but where its access level cannot be uttered.<br>&gt; <br>&gt; You have this wrong.  It is not that you declare `private var foo` and then in specific places it is visible but you can’t utter its access control.  <br>&gt; <br>&gt; The problem is when you use `private` on any construct which introduces a scope that contains further declarations.  You cannot utter the default access control for the members of that scope.  Here are examples:<br>&gt; <br>&gt; private struct S {<br>&gt;     var foo: Int<br>&gt; }<br>&gt; private class C {<br>&gt;     var foo: Int<br>&gt; }<br>&gt; private enum E {<br>&gt;     var foo: Int { return 42 }<br>&gt; }<br>&gt; private extension S {<br>&gt;     func bar() {}<br>&gt; }<br>&gt;  <br>&gt; In all of these examples `foo` and `bar` are visible within the top level scope, but not outside the file.<br>&gt; <br>&gt; Sorry, yes, that is one problem. The related problem I was trying to describe was this:<br>&gt; <br>&gt; ```<br>&gt; public struct A {<br>&gt;   private var foo: Int<br>&gt;   internal struct B {<br>&gt;     // I cannot utter the access control for `foo` here<br>&gt;     // and there is nothing I can declare here to be visible<br>&gt;     // exactly where `foo` is visible<br>&gt;   }<br>&gt; }<br>&gt; ```<br></p><p>Access control is never uttered at *usage* sites.  It is uttered at *declaration* sites.  By definition of scope-base access control you are not going to be able to utter the precise visibility level of some visible declarations at the *usage* sites.  I don’t see why this is a problem.  It is utterability at *declaration* sites that is important.<br></p><p>&gt;  <br>&gt; In this case that happens to correspond to `fileprivate` which is probably why Jordan selected that keyword.  In cases where these are not top level declarations, but nested within a scope these will be visible within that scope, but not at the top level of the file.  In *no* case does the unutterable access level correspond to *internal* which is probably why Jordan did not suggest using that.<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/77337ba9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 05:00:00pm</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 5:41 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jun 29, 2016, at 5:30 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Jun 29, 2016 at 5:25 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 29, 2016, at 4:30 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Wed, Jun 29, 2016 at 4:15 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jun 29, 2016, at 14:12, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:07 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types,<br>&gt;&gt;&gt;&gt;&gt; extensions etc.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I think this is a little less confusing since effectively this is<br>&gt;&gt;&gt;&gt;&gt; what is happening in the background.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less<br>&gt;&gt;&gt;&gt;&gt; important than the rest of the amendment.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; There actually is an answer to this, which is that the core team<br>&gt;&gt;&gt;&gt;&gt; expects &#39;private&#39; to be the common keyword, and therefore it’s better if<br>&gt;&gt;&gt;&gt;&gt; you can use it at the top level and ignore ‘fileprivate’ altogether in most<br>&gt;&gt;&gt;&gt;&gt; programs.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private`<br>&gt;&gt;&gt;&gt; literally meant visibility *only* within the current declaration, and<br>&gt;&gt;&gt;&gt; neither outside it nor inside any nested types, etc.?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Yes, but that&#39;s not very useful:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; public struct Foo {<br>&gt;&gt;&gt;&gt;   private var value: Int = 0<br>&gt;&gt;&gt;&gt;   public func test() {<br>&gt;&gt;&gt;&gt;     print(value) // error<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I suppose you could say that nested *types* are different from nested<br>&gt;&gt;&gt;&gt; *functions,* but then we start getting complexity in a different<br>&gt;&gt;&gt;&gt; direction. And it still doesn&#39;t fix the default access within a private<br>&gt;&gt;&gt;&gt; type.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Let me offer a principled rule: if I write `private var foo`, then `foo`<br>&gt;&gt;&gt; is invisible at such places within the declaration where writing `private<br>&gt;&gt;&gt; var bar` at the same place would cause `bar` to be visible where `foo` is<br>&gt;&gt;&gt; not or vice versa.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’m sorry, I don’t understand.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Stepping back, though, this part of the proposal *was* discussed back<br>&gt;&gt;&gt; when it was first going through, and it was settled (after some<br>&gt;&gt;&gt; disagreement and discussion) that pure lexical scoping was the best choice.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I entirely misunderstood that part of the debate. I had thought the gist<br>&gt;&gt; of the discussion was that SE-0025 itself was an explicit break from purely<br>&gt;&gt; lexical scoping, that the proponents of pure lexical scoping were arguing<br>&gt;&gt; against its adoption, and that its acceptance by the core team was a move<br>&gt;&gt; away from purely lexical scoping.<br>&gt;&gt;<br>&gt;&gt; Let me see if I can rephrase the difficulty as I perceive it. I had<br>&gt;&gt; thought that this was an equivalent formulation of the problem that you are<br>&gt;&gt; addressing with the amendment. The interpretation of `private` as a purely<br>&gt;&gt; lexical scope results in the scenario as follows:<br>&gt;&gt;<br>&gt;&gt; 1. I declare `private var foo`<br>&gt;&gt; 2. There are places in code where `foo` is visible but where its access<br>&gt;&gt; level cannot be uttered (e.g., within a nested type, `foo` is not private<br>&gt;&gt; to that nested type, but it is more narrow in scope than fileprivate,<br>&gt;&gt; internal, or public)<br>&gt;&gt;<br>&gt;&gt; Your proposal is to allow `fileprivate` to be used in place of the<br>&gt;&gt; unutterable access level. This seems like a hack. The necessity for it<br>&gt;&gt; would go away if we stipulated `private` to exclude all places in code<br>&gt;&gt; where `foo` is visible but where its access level cannot be uttered.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; You have this wrong.  It is not that you declare `private var foo` and<br>&gt;&gt; then in specific places it is visible but you can’t utter its access<br>&gt;&gt; control.<br>&gt;&gt;<br>&gt;&gt; The problem is when you use `private` on any construct which introduces a<br>&gt;&gt; scope that contains further declarations.  You cannot utter the default<br>&gt;&gt; access control for the members of that scope.  Here are examples:<br>&gt;&gt;<br>&gt;&gt; private struct S {<br>&gt;&gt;     var foo: Int<br>&gt;&gt; }<br>&gt;&gt; private class C {<br>&gt;&gt;     var foo: Int<br>&gt;&gt; }<br>&gt;&gt; private enum E {<br>&gt;&gt;     var foo: Int { return 42 }<br>&gt;&gt; }<br>&gt;&gt; private extension S {<br>&gt;&gt;     func bar() {}<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; In all of these examples `foo` and `bar` are visible within the top level<br>&gt;&gt; scope, but not outside the file.<br>&gt;&gt;<br>&gt;<br>&gt; Sorry, yes, that is one problem. The related problem I was trying to<br>&gt; describe was this:<br>&gt;<br>&gt; ```<br>&gt; public struct A {<br>&gt;   private var foo: Int<br>&gt;   internal struct B {<br>&gt;     // I cannot utter the access control for `foo` here<br>&gt;     // and there is nothing I can declare here to be visible<br>&gt;     // exactly where `foo` is visible<br>&gt;   }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt;<br>&gt; Access control is never uttered at *usage* sites.  It is uttered at<br>&gt; *declaration* sites.  By definition of scope-base access control you are<br>&gt; not going to be able to utter the precise visibility level of some visible<br>&gt; declarations at the *usage* sites.  I don’t see why this is a problem.  It<br>&gt; is utterability at *declaration* sites that is important.<br>&gt;<br></p><p>Sorry, I&#39;m being sloppy here. Inside struct B, I intend to declare things.<br>Substitute `typealias Foo` for `var foo` and declarations inside struct B<br>will have trouble with `A.Foo` because of restrictions concerning minimum<br>visibility.<br></p><p><br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; In this case that happens to correspond to `fileprivate` which is<br>&gt;&gt; probably why Jordan selected that keyword.  In cases where these are not<br>&gt;&gt; top level declarations, but nested within a scope these will be visible<br>&gt;&gt; within that scope, but not at the top level of the file.  In *no* case does<br>&gt;&gt; the unutterable access level correspond to *internal* which is probably why<br>&gt;&gt; Jordan did not suggest using that.<br>&gt;&gt;<br>&gt;&gt; -Matthew<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/caef74fc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 5:44 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 29, 2016 at 5:41 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 5:30 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 29, 2016 at 5:25 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 4:30 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:15 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 14:12, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:07 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com &lt;mailto:cheyo at masters3d.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types, extensions etc.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I think this is a little less confusing since effectively this is what is happening in the background.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less important than the rest of the amendment.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There actually is an answer to this, which is that the core team expects &#39;private&#39; to be the common keyword, and therefore it’s better if you can use it at the top level and ignore ‘fileprivate’ altogether in most programs.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private` literally meant visibility *only* within the current declaration, and neither outside it nor inside any nested types, etc.?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, but that&#39;s not very useful:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public struct Foo {<br>&gt;&gt;&gt;&gt;   private var value: Int = 0<br>&gt;&gt;&gt;&gt;   public func test() {<br>&gt;&gt;&gt;&gt;     print(value) // error<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I suppose you could say that nested types are different from nested functions, but then we start getting complexity in a different direction. And it still doesn&#39;t fix the default access within a private type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let me offer a principled rule: if I write `private var foo`, then `foo` is invisible at such places within the declaration where writing `private var bar` at the same place would cause `bar` to be visible where `foo` is not or vice versa.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m sorry, I don’t understand. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Stepping back, though, this part of the proposal was discussed back when it was first going through, and it was settled (after some disagreement and discussion) that pure lexical scoping was the best choice.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I entirely misunderstood that part of the debate. I had thought the gist of the discussion was that SE-0025 itself was an explicit break from purely lexical scoping, that the proponents of pure lexical scoping were arguing against its adoption, and that its acceptance by the core team was a move away from purely lexical scoping.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let me see if I can rephrase the difficulty as I perceive it. I had thought that this was an equivalent formulation of the problem that you are addressing with the amendment. The interpretation of `private` as a purely lexical scope results in the scenario as follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. I declare `private var foo`<br>&gt;&gt;&gt; 2. There are places in code where `foo` is visible but where its access level cannot be uttered (e.g., within a nested type, `foo` is not private to that nested type, but it is more narrow in scope than fileprivate, internal, or public)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Your proposal is to allow `fileprivate` to be used in place of the unutterable access level. This seems like a hack. The necessity for it would go away if we stipulated `private` to exclude all places in code where `foo` is visible but where its access level cannot be uttered.<br>&gt;&gt; <br>&gt;&gt; You have this wrong.  It is not that you declare `private var foo` and then in specific places it is visible but you can’t utter its access control.  <br>&gt;&gt; <br>&gt;&gt; The problem is when you use `private` on any construct which introduces a scope that contains further declarations.  You cannot utter the default access control for the members of that scope.  Here are examples:<br>&gt;&gt; <br>&gt;&gt; private struct S {<br>&gt;&gt;     var foo: Int<br>&gt;&gt; }<br>&gt;&gt; private class C {<br>&gt;&gt;     var foo: Int<br>&gt;&gt; }<br>&gt;&gt; private enum E {<br>&gt;&gt;     var foo: Int { return 42 }<br>&gt;&gt; }<br>&gt;&gt; private extension S {<br>&gt;&gt;     func bar() {}<br>&gt;&gt; }<br>&gt;&gt;  <br>&gt;&gt; In all of these examples `foo` and `bar` are visible within the top level scope, but not outside the file.<br>&gt;&gt; <br>&gt;&gt; Sorry, yes, that is one problem. The related problem I was trying to describe was this:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; public struct A {<br>&gt;&gt;   private var foo: Int<br>&gt;&gt;   internal struct B {<br>&gt;&gt;     // I cannot utter the access control for `foo` here<br>&gt;&gt;     // and there is nothing I can declare here to be visible<br>&gt;&gt;     // exactly where `foo` is visible<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt; <br>&gt; Access control is never uttered at *usage* sites.  It is uttered at *declaration* sites.  By definition of scope-base access control you are not going to be able to utter the precise visibility level of some visible declarations at the *usage* sites.  I don’t see why this is a problem.  It is utterability at *declaration* sites that is important.<br>&gt; <br>&gt; Sorry, I&#39;m being sloppy here. Inside struct B, I intend to declare things. Substitute `typealias Foo` for `var foo` and declarations inside struct B will have trouble with `A.Foo` because of restrictions concerning minimum visibility.<br></p><p>I don’t understand why you say this.  Considering the typealias example, you can use `Foo` in the signature of any member of `B` that is `private` and with Jordan’s amendment `fileprivate`.  You just can’t use it in members with `internal` or `public` visibility.  <br></p><p>This is no different from Swift 2 because in Swift 2 `Foo` would behave the same as `fileprivate` in Swift 3 which is less than `public` and `internal`.<br></p><p>&gt;  <br>&gt; <br>&gt;&gt;  <br>&gt;&gt; In this case that happens to correspond to `fileprivate` which is probably why Jordan selected that keyword.  In cases where these are not top level declarations, but nested within a scope these will be visible within that scope, but not at the top level of the file.  In *no* case does the unutterable access level correspond to *internal* which is probably why Jordan did not suggest using that.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/61bcdd6e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 06:00:00pm</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 6:00 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jun 29, 2016, at 5:44 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Jun 29, 2016 at 5:41 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 29, 2016, at 5:30 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Wed, Jun 29, 2016 at 5:25 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt;  wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jun 29, 2016, at 4:30 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:15 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 14:12, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:07 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types,<br>&gt;&gt;&gt;&gt;&gt;&gt; extensions etc.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; I think this is a little less confusing since effectively this is<br>&gt;&gt;&gt;&gt;&gt;&gt; what is happening in the background.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less<br>&gt;&gt;&gt;&gt;&gt;&gt; important than the rest of the amendment.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; There actually is an answer to this, which is that the core team<br>&gt;&gt;&gt;&gt;&gt;&gt; expects &#39;private&#39; to be the common keyword, and therefore it’s better if<br>&gt;&gt;&gt;&gt;&gt;&gt; you can use it at the top level and ignore ‘fileprivate’ altogether in most<br>&gt;&gt;&gt;&gt;&gt;&gt; programs.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private`<br>&gt;&gt;&gt;&gt;&gt; literally meant visibility *only* within the current declaration, and<br>&gt;&gt;&gt;&gt;&gt; neither outside it nor inside any nested types, etc.?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Yes, but that&#39;s not very useful:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; public struct Foo {<br>&gt;&gt;&gt;&gt;&gt;   private var value: Int = 0<br>&gt;&gt;&gt;&gt;&gt;   public func test() {<br>&gt;&gt;&gt;&gt;&gt;     print(value) // error<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I suppose you could say that nested *types* are different from nested<br>&gt;&gt;&gt;&gt;&gt; *functions,* but then we start getting complexity in a different<br>&gt;&gt;&gt;&gt;&gt; direction. And it still doesn&#39;t fix the default access within a private<br>&gt;&gt;&gt;&gt;&gt; type.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Let me offer a principled rule: if I write `private var foo`, then<br>&gt;&gt;&gt;&gt; `foo` is invisible at such places within the declaration where writing<br>&gt;&gt;&gt;&gt; `private var bar` at the same place would cause `bar` to be visible where<br>&gt;&gt;&gt;&gt; `foo` is not or vice versa.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I’m sorry, I don’t understand.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Stepping back, though, this part of the proposal *was* discussed back<br>&gt;&gt;&gt;&gt; when it was first going through, and it was settled (after some<br>&gt;&gt;&gt;&gt; disagreement and discussion) that pure lexical scoping was the best choice.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I entirely misunderstood that part of the debate. I had thought the gist<br>&gt;&gt;&gt; of the discussion was that SE-0025 itself was an explicit break from purely<br>&gt;&gt;&gt; lexical scoping, that the proponents of pure lexical scoping were arguing<br>&gt;&gt;&gt; against its adoption, and that its acceptance by the core team was a move<br>&gt;&gt;&gt; away from purely lexical scoping.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Let me see if I can rephrase the difficulty as I perceive it. I had<br>&gt;&gt;&gt; thought that this was an equivalent formulation of the problem that you are<br>&gt;&gt;&gt; addressing with the amendment. The interpretation of `private` as a purely<br>&gt;&gt;&gt; lexical scope results in the scenario as follows:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1. I declare `private var foo`<br>&gt;&gt;&gt; 2. There are places in code where `foo` is visible but where its access<br>&gt;&gt;&gt; level cannot be uttered (e.g., within a nested type, `foo` is not private<br>&gt;&gt;&gt; to that nested type, but it is more narrow in scope than fileprivate,<br>&gt;&gt;&gt; internal, or public)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Your proposal is to allow `fileprivate` to be used in place of the<br>&gt;&gt;&gt; unutterable access level. This seems like a hack. The necessity for it<br>&gt;&gt;&gt; would go away if we stipulated `private` to exclude all places in code<br>&gt;&gt;&gt; where `foo` is visible but where its access level cannot be uttered.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; You have this wrong.  It is not that you declare `private var foo` and<br>&gt;&gt;&gt; then in specific places it is visible but you can’t utter its access<br>&gt;&gt;&gt; control.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The problem is when you use `private` on any construct which introduces<br>&gt;&gt;&gt; a scope that contains further declarations.  You cannot utter the default<br>&gt;&gt;&gt; access control for the members of that scope.  Here are examples:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; private struct S {<br>&gt;&gt;&gt;     var foo: Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; private class C {<br>&gt;&gt;&gt;     var foo: Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; private enum E {<br>&gt;&gt;&gt;     var foo: Int { return 42 }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; private extension S {<br>&gt;&gt;&gt;     func bar() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In all of these examples `foo` and `bar` are visible within the top<br>&gt;&gt;&gt; level scope, but not outside the file.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sorry, yes, that is one problem. The related problem I was trying to<br>&gt;&gt; describe was this:<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; public struct A {<br>&gt;&gt;   private var foo: Int<br>&gt;&gt;   internal struct B {<br>&gt;&gt;     // I cannot utter the access control for `foo` here<br>&gt;&gt;     // and there is nothing I can declare here to be visible<br>&gt;&gt;     // exactly where `foo` is visible<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Access control is never uttered at *usage* sites.  It is uttered at<br>&gt;&gt; *declaration* sites.  By definition of scope-base access control you are<br>&gt;&gt; not going to be able to utter the precise visibility level of some visible<br>&gt;&gt; declarations at the *usage* sites.  I don’t see why this is a problem.  It<br>&gt;&gt; is utterability at *declaration* sites that is important.<br>&gt;&gt;<br>&gt;<br>&gt; Sorry, I&#39;m being sloppy here. Inside struct B, I intend to declare things.<br>&gt; Substitute `typealias Foo` for `var foo` and declarations inside struct B<br>&gt; will have trouble with `A.Foo` because of restrictions concerning minimum<br>&gt; visibility.<br>&gt;<br>&gt;<br>&gt; I don’t understand why you say this.  Considering the typealias example,<br>&gt; you can use `Foo` in the signature of any member of `B` that is `private`<br>&gt; and with Jordan’s amendment `fileprivate`.  You just can’t use it in<br>&gt; members with `internal` or `public` visibility.<br>&gt;<br>&gt; This is no different from Swift 2 because in Swift 2 `Foo` would behave<br>&gt; the same as `fileprivate` in Swift 3 which is less than `public` and<br>&gt; `internal`.<br>&gt;<br></p><p>You&#39;re right. This was a failed attempt at an example :)<br></p><p><br>&gt;&gt;<br>&gt;&gt;&gt; In this case that happens to correspond to `fileprivate` which is<br>&gt;&gt;&gt; probably why Jordan selected that keyword.  In cases where these are not<br>&gt;&gt;&gt; top level declarations, but nested within a scope these will be visible<br>&gt;&gt;&gt; within that scope, but not at the top level of the file.  In *no* case does<br>&gt;&gt;&gt; the unutterable access level correspond to *internal* which is probably why<br>&gt;&gt;&gt; Jordan did not suggest using that.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/1d8edfe2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 6:04 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Wed, Jun 29, 2016 at 6:00 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 5:44 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 29, 2016 at 5:41 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 5:30 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jun 29, 2016 at 5:25 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 4:30 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:15 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 14:12, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:07 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com &lt;mailto:cheyo at masters3d.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types, extensions etc.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; I think this is a little less confusing since effectively this is what is happening in the background.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less important than the rest of the amendment.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There actually is an answer to this, which is that the core team expects &#39;private&#39; to be the common keyword, and therefore it’s better if you can use it at the top level and ignore ‘fileprivate’ altogether in most programs.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private` literally meant visibility *only* within the current declaration, and neither outside it nor inside any nested types, etc.?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, but that&#39;s not very useful:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; public struct Foo {<br>&gt;&gt;&gt;&gt;&gt;   private var value: Int = 0<br>&gt;&gt;&gt;&gt;&gt;   public func test() {<br>&gt;&gt;&gt;&gt;&gt;     print(value) // error<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I suppose you could say that nested types are different from nested functions, but then we start getting complexity in a different direction. And it still doesn&#39;t fix the default access within a private type.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Let me offer a principled rule: if I write `private var foo`, then `foo` is invisible at such places within the declaration where writing `private var bar` at the same place would cause `bar` to be visible where `foo` is not or vice versa.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m sorry, I don’t understand. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Stepping back, though, this part of the proposal was discussed back when it was first going through, and it was settled (after some disagreement and discussion) that pure lexical scoping was the best choice.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I entirely misunderstood that part of the debate. I had thought the gist of the discussion was that SE-0025 itself was an explicit break from purely lexical scoping, that the proponents of pure lexical scoping were arguing against its adoption, and that its acceptance by the core team was a move away from purely lexical scoping.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let me see if I can rephrase the difficulty as I perceive it. I had thought that this was an equivalent formulation of the problem that you are addressing with the amendment. The interpretation of `private` as a purely lexical scope results in the scenario as follows:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. I declare `private var foo`<br>&gt;&gt;&gt;&gt; 2. There are places in code where `foo` is visible but where its access level cannot be uttered (e.g., within a nested type, `foo` is not private to that nested type, but it is more narrow in scope than fileprivate, internal, or public)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Your proposal is to allow `fileprivate` to be used in place of the unutterable access level. This seems like a hack. The necessity for it would go away if we stipulated `private` to exclude all places in code where `foo` is visible but where its access level cannot be uttered.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You have this wrong.  It is not that you declare `private var foo` and then in specific places it is visible but you can’t utter its access control.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The problem is when you use `private` on any construct which introduces a scope that contains further declarations.  You cannot utter the default access control for the members of that scope.  Here are examples:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private struct S {<br>&gt;&gt;&gt;     var foo: Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; private class C {<br>&gt;&gt;&gt;     var foo: Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; private enum E {<br>&gt;&gt;&gt;     var foo: Int { return 42 }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; private extension S {<br>&gt;&gt;&gt;     func bar() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; In all of these examples `foo` and `bar` are visible within the top level scope, but not outside the file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, yes, that is one problem. The related problem I was trying to describe was this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; public struct A {<br>&gt;&gt;&gt;   private var foo: Int<br>&gt;&gt;&gt;   internal struct B {<br>&gt;&gt;&gt;     // I cannot utter the access control for `foo` here<br>&gt;&gt;&gt;     // and there is nothing I can declare here to be visible<br>&gt;&gt;&gt;     // exactly where `foo` is visible<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Access control is never uttered at *usage* sites.  It is uttered at *declaration* sites.  By definition of scope-base access control you are not going to be able to utter the precise visibility level of some visible declarations at the *usage* sites.  I don’t see why this is a problem.  It is utterability at *declaration* sites that is important.<br>&gt;&gt; <br>&gt;&gt; Sorry, I&#39;m being sloppy here. Inside struct B, I intend to declare things. Substitute `typealias Foo` for `var foo` and declarations inside struct B will have trouble with `A.Foo` because of restrictions concerning minimum visibility.<br>&gt; <br>&gt; I don’t understand why you say this.  Considering the typealias example, you can use `Foo` in the signature of any member of `B` that is `private` and with Jordan’s amendment `fileprivate`.  You just can’t use it in members with `internal` or `public` visibility.  <br>&gt; <br>&gt; This is no different from Swift 2 because in Swift 2 `Foo` would behave the same as `fileprivate` in Swift 3 which is less than `public` and `internal`.<br>&gt; <br>&gt; You&#39;re right. This was a failed attempt at an example :)<br></p><p>Sometimes talking through concrete examples is the best way to get on the same page! :)<br></p><p>&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; In this case that happens to correspond to `fileprivate` which is probably why Jordan selected that keyword.  In cases where these are not top level declarations, but nested within a scope these will be visible within that scope, but not at the top level of the file.  In *no* case does the unutterable access level correspond to *internal* which is probably why Jordan did not suggest using that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/af3f0036/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 4:12 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 29, 2016 at 4:07 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com &lt;mailto:cheyo at masters3d.com&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types, extensions etc.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I think this is a little less confusing since effectively this is what is happening in the background.<br>&gt;&gt; <br>&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less important than the rest of the amendment.<br>&gt;&gt; <br>&gt;&gt; There actually is an answer to this, which is that the core team expects &#39;private&#39; to be the common keyword, and therefore it’s better if you can use it at the top level and ignore ‘fileprivate’ altogether in most programs.<br>&gt;&gt; <br>&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private` literally meant visibility *only* within the current declaration, and neither outside it nor inside any nested types, etc.?<br>&gt; <br>&gt; Yes, but that&#39;s not very useful:<br>&gt; <br>&gt; public struct Foo {<br>&gt;   private var value: Int = 0<br>&gt;   public func test() {<br>&gt;     print(value) // error<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; I suppose you could say that nested types are different from nested functions, but then we start getting complexity in a different direction. And it still doesn&#39;t fix the default access within a private type.<br>&gt; <br>&gt; Let me offer a principled rule: if I write `private var foo`, then `foo` is invisible at such places within the declaration where writing `private var bar` at the same place would cause `bar` to be visible where `foo` is not or vice versa.<br></p><p>This violates the principle behind all of Swift’s access control rules.  That principle is that access control is strictly based on a hierarchy of lexical scopes.  This is a really great principle and is what makes Swift’s access control better than any other I know of (IMO of course).<br></p><p>&gt;  <br>&gt; Jordan<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/341066b2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 04:00:00pm</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 4:16 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jun 29, 2016, at 4:12 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Wed, Jun 29, 2016 at 4:07 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types,<br>&gt;&gt;&gt; extensions etc.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I think this is a little less confusing since effectively this is what<br>&gt;&gt;&gt; is happening in the background.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less important<br>&gt;&gt;&gt; than the rest of the amendment.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There actually is an answer to this, which is that the core team expects<br>&gt;&gt;&gt; &#39;private&#39; to be the common keyword, and therefore it’s better if you can<br>&gt;&gt;&gt; use it at the top level and ignore ‘fileprivate’ altogether in most<br>&gt;&gt;&gt; programs.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private`<br>&gt;&gt; literally meant visibility *only* within the current declaration, and<br>&gt;&gt; neither outside it nor inside any nested types, etc.?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes, but that&#39;s not very useful:<br>&gt;&gt;<br>&gt;&gt; public struct Foo {<br>&gt;&gt;   private var value: Int = 0<br>&gt;&gt;   public func test() {<br>&gt;&gt;     print(value) // error<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I suppose you could say that nested *types* are different from nested<br>&gt;&gt; *functions,* but then we start getting complexity in a different<br>&gt;&gt; direction. And it still doesn&#39;t fix the default access within a private<br>&gt;&gt; type.<br>&gt;&gt;<br>&gt;<br>&gt; Let me offer a principled rule: if I write `private var foo`, then `foo`<br>&gt; is invisible at such places within the declaration where writing `private<br>&gt; var bar` at the same place would cause `bar` to be visible where `foo` is<br>&gt; not or vice versa.<br>&gt;<br>&gt;<br>&gt; This violates the principle behind all of Swift’s access control rules.<br>&gt; That principle is that access control is strictly based on a hierarchy of<br>&gt; lexical scopes.  This is a really great principle and is what makes Swift’s<br>&gt; access control better than any other I know of (IMO of course).<br>&gt;<br></p><p>But however you slice it, some principle of Swift&#39;s access control rules is<br>violated by `private`. If `foo` is visible in a place where I cannot write<br>`private var bar` to mean the same visibility, then the access level of<br>`foo` is unutterable in that location, which is unprecedented as well.<br></p><p><br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/d7acf6aa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 4:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 29, 2016 at 4:16 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 4:12 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 29, 2016 at 4:07 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com &lt;mailto:cheyo at masters3d.com&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types, extensions etc.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I think this is a little less confusing since effectively this is what is happening in the background.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less important than the rest of the amendment.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There actually is an answer to this, which is that the core team expects &#39;private&#39; to be the common keyword, and therefore it’s better if you can use it at the top level and ignore ‘fileprivate’ altogether in most programs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private` literally meant visibility *only* within the current declaration, and neither outside it nor inside any nested types, etc.?<br>&gt;&gt; <br>&gt;&gt; Yes, but that&#39;s not very useful:<br>&gt;&gt; <br>&gt;&gt; public struct Foo {<br>&gt;&gt;   private var value: Int = 0<br>&gt;&gt;   public func test() {<br>&gt;&gt;     print(value) // error<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I suppose you could say that nested types are different from nested functions, but then we start getting complexity in a different direction. And it still doesn&#39;t fix the default access within a private type.<br>&gt;&gt; <br>&gt;&gt; Let me offer a principled rule: if I write `private var foo`, then `foo` is invisible at such places within the declaration where writing `private var bar` at the same place would cause `bar` to be visible where `foo` is not or vice versa.<br>&gt; <br>&gt; This violates the principle behind all of Swift’s access control rules.  That principle is that access control is strictly based on a hierarchy of lexical scopes.  This is a really great principle and is what makes Swift’s access control better than any other I know of (IMO of course).<br>&gt; <br>&gt; But however you slice it, some principle of Swift&#39;s access control rules is violated by `private`. If `foo` is visible in a place where I cannot write `private var bar` to mean the same visibility, then the access level of `foo` is unutterable in that location, which is unprecedented as well.<br></p><p>I don’t think utterability was a conscious principle to the degree that scope based access control was.  If that was the case the issue would surely have been identified during review.  It wasn’t until Robert started the implementation that anyone (AFAIK) notices that the proposal introduces unutterable visibility in some cases.  Utterability just isn’t something people were thinking about until then.<br></p><p>But you are right that unutterability is unprecedented and I think everyone agrees that it poses problems which is why Jordan and Robert have amended the proposal to make the visibility members of private types without explicit access control utterable.<br></p><p>The solution we want is to preserve *both* of these principles, not change which one were violating. :)<br></p><p>&gt;  <br>&gt; <br>&gt;&gt;  <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/a0473241/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 04:00:00pm</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 4:46 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jun 29, 2016, at 4:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Jun 29, 2016 at 4:16 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 29, 2016, at 4:12 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Wed, Jun 29, 2016 at 4:07 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt;wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types,<br>&gt;&gt;&gt;&gt; extensions etc.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I think this is a little less confusing since effectively this is<br>&gt;&gt;&gt;&gt; what is happening in the background.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less important<br>&gt;&gt;&gt;&gt; than the rest of the amendment.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; There actually is an answer to this, which is that the core team<br>&gt;&gt;&gt;&gt; expects &#39;private&#39; to be the common keyword, and therefore it’s better if<br>&gt;&gt;&gt;&gt; you can use it at the top level and ignore ‘fileprivate’ altogether in most<br>&gt;&gt;&gt;&gt; programs.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private`<br>&gt;&gt;&gt; literally meant visibility *only* within the current declaration, and<br>&gt;&gt;&gt; neither outside it nor inside any nested types, etc.?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes, but that&#39;s not very useful:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public struct Foo {<br>&gt;&gt;&gt;   private var value: Int = 0<br>&gt;&gt;&gt;   public func test() {<br>&gt;&gt;&gt;     print(value) // error<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I suppose you could say that nested *types* are different from nested<br>&gt;&gt;&gt; *functions,* but then we start getting complexity in a different<br>&gt;&gt;&gt; direction. And it still doesn&#39;t fix the default access within a private<br>&gt;&gt;&gt; type.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Let me offer a principled rule: if I write `private var foo`, then `foo`<br>&gt;&gt; is invisible at such places within the declaration where writing `private<br>&gt;&gt; var bar` at the same place would cause `bar` to be visible where `foo` is<br>&gt;&gt; not or vice versa.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This violates the principle behind all of Swift’s access control rules.<br>&gt;&gt; That principle is that access control is strictly based on a hierarchy of<br>&gt;&gt; lexical scopes.  This is a really great principle and is what makes Swift’s<br>&gt;&gt; access control better than any other I know of (IMO of course).<br>&gt;&gt;<br>&gt;<br>&gt; But however you slice it, some principle of Swift&#39;s access control rules<br>&gt; is violated by `private`. If `foo` is visible in a place where I cannot<br>&gt; write `private var bar` to mean the same visibility, then the access level<br>&gt; of `foo` is unutterable in that location, which is unprecedented as well.<br>&gt;<br>&gt;<br>&gt; I don’t think utterability was a conscious principle to the degree that<br>&gt; scope based access control was.  If that was the case the issue would<br>&gt; surely have been identified during review.  It wasn’t until Robert started<br>&gt; the implementation that anyone (AFAIK) notices that the proposal introduces<br>&gt; unutterable visibility in some cases.  Utterability just isn’t something<br>&gt; people were thinking about until then.<br>&gt;<br>&gt; But you are right that unutterability is unprecedented and I think<br>&gt; everyone agrees that it poses problems which is why Jordan and Robert have<br>&gt; amended the proposal to make the visibility members of private types<br>&gt; without explicit access control utterable.<br>&gt;<br>&gt; The solution we want is to preserve *both* of these principles, not change<br>&gt; which one were violating. :)<br>&gt;<br></p><p>If a private member must be visible within a nested type, then that access<br>level necessarily becomes unutterable within the nested type unless we<br>introduce another keyword, which is out of scope without a new proposal.<br>There is no squaring the circle to be had. The amendment, to my<br>understanding, simply hacks around this issue to make `private` nonetheless<br>useful by allowing `fileprivate` things inside `private` things, but in so<br>doing we&#39;re enshrining which of these principles we&#39;re violating, not<br>finding a solution that avoids violating them.<br></p><p><br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/6cd68cb6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 05:00:00pm</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 4:57 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; On Wed, Jun 29, 2016 at 4:46 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 29, 2016, at 4:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Wed, Jun 29, 2016 at 4:16 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jun 29, 2016, at 4:12 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:07 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt;wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types,<br>&gt;&gt;&gt;&gt;&gt; extensions etc.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I think this is a little less confusing since effectively this is<br>&gt;&gt;&gt;&gt;&gt; what is happening in the background.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less<br>&gt;&gt;&gt;&gt;&gt; important than the rest of the amendment.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; There actually is an answer to this, which is that the core team<br>&gt;&gt;&gt;&gt;&gt; expects &#39;private&#39; to be the common keyword, and therefore it’s better if<br>&gt;&gt;&gt;&gt;&gt; you can use it at the top level and ignore ‘fileprivate’ altogether in most<br>&gt;&gt;&gt;&gt;&gt; programs.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private`<br>&gt;&gt;&gt;&gt; literally meant visibility *only* within the current declaration, and<br>&gt;&gt;&gt;&gt; neither outside it nor inside any nested types, etc.?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Yes, but that&#39;s not very useful:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; public struct Foo {<br>&gt;&gt;&gt;&gt;   private var value: Int = 0<br>&gt;&gt;&gt;&gt;   public func test() {<br>&gt;&gt;&gt;&gt;     print(value) // error<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I suppose you could say that nested *types* are different from nested<br>&gt;&gt;&gt;&gt; *functions,* but then we start getting complexity in a different<br>&gt;&gt;&gt;&gt; direction. And it still doesn&#39;t fix the default access within a private<br>&gt;&gt;&gt;&gt; type.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Let me offer a principled rule: if I write `private var foo`, then `foo`<br>&gt;&gt;&gt; is invisible at such places within the declaration where writing `private<br>&gt;&gt;&gt; var bar` at the same place would cause `bar` to be visible where `foo` is<br>&gt;&gt;&gt; not or vice versa.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This violates the principle behind all of Swift’s access control rules.<br>&gt;&gt;&gt; That principle is that access control is strictly based on a hierarchy of<br>&gt;&gt;&gt; lexical scopes.  This is a really great principle and is what makes Swift’s<br>&gt;&gt;&gt; access control better than any other I know of (IMO of course).<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; But however you slice it, some principle of Swift&#39;s access control rules<br>&gt;&gt; is violated by `private`. If `foo` is visible in a place where I cannot<br>&gt;&gt; write `private var bar` to mean the same visibility, then the access level<br>&gt;&gt; of `foo` is unutterable in that location, which is unprecedented as well.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don’t think utterability was a conscious principle to the degree that<br>&gt;&gt; scope based access control was.  If that was the case the issue would<br>&gt;&gt; surely have been identified during review.  It wasn’t until Robert started<br>&gt;&gt; the implementation that anyone (AFAIK) notices that the proposal introduces<br>&gt;&gt; unutterable visibility in some cases.  Utterability just isn’t something<br>&gt;&gt; people were thinking about until then.<br>&gt;&gt;<br>&gt;&gt; But you are right that unutterability is unprecedented and I think<br>&gt;&gt; everyone agrees that it poses problems which is why Jordan and Robert have<br>&gt;&gt; amended the proposal to make the visibility members of private types<br>&gt;&gt; without explicit access control utterable.<br>&gt;&gt;<br>&gt;&gt; The solution we want is to preserve *both* of these principles, not<br>&gt;&gt; change which one were violating. :)<br>&gt;&gt;<br>&gt;<br>&gt; If a private member must be visible within a nested type, then that access<br>&gt; level necessarily becomes unutterable within the nested type unless we<br>&gt; introduce another keyword, which is out of scope without a new proposal.<br>&gt; There is no squaring the circle to be had. The amendment, to my<br>&gt; understanding, simply hacks around this issue to make `private` nonetheless<br>&gt; useful by allowing `fileprivate` things inside `private` things, but in so<br>&gt; doing we&#39;re enshrining which of these principles we&#39;re violating, not<br>&gt; finding a solution that avoids violating them.<br>&gt;<br>&gt;<br></p><p>Humble suggestion: if `private` were left unimplemented with respect to<br>types, all motivating reasons and examples given in SE-0025 could still be<br>delivered for Swift 3. A follow-on proposal could tackle these challenges<br>explicitly rather than amending an existing proposal without re-review. Any<br>such changes could be punted until after Swift 3 because they would be<br>strictly additive.<br></p><p>&gt; Jordan<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/1cda507d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June 30, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; Am 29.06.2016 um 23:57 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; On Wed, Jun 29, 2016 at 4:46 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 4:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 29, 2016 at 4:16 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 4:12 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:07 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt;wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types, extensions etc.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I think this is a little less confusing since effectively this is what is happening in the background.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less important than the rest of the amendment.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There actually is an answer to this, which is that the core team expects &#39;private&#39; to be the common keyword, and therefore it’s better if you can use it at the top level and ignore ‘fileprivate’ altogether in most programs.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private` literally meant visibility *only* within the current declaration, and neither outside it nor inside any nested types, etc.?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, but that&#39;s not very useful:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public struct Foo {<br>&gt;&gt;&gt;   private var value: Int = 0<br>&gt;&gt;&gt;   public func test() {<br>&gt;&gt;&gt;     print(value) // error<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I suppose you could say that nested types are different from nested functions, but then we start getting complexity in a different direction. And it still doesn&#39;t fix the default access within a private type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let me offer a principled rule: if I write `private var foo`, then `foo` is invisible at such places within the declaration where writing `private var bar` at the same place would cause `bar` to be visible where `foo` is not or vice versa.<br>&gt;&gt; <br>&gt;&gt; This violates the principle behind all of Swift’s access control rules.  That principle is that access control is strictly based on a hierarchy of lexical scopes.  This is a really great principle and is what makes Swift’s access control better than any other I know of (IMO of course).<br>&gt;&gt; <br>&gt;&gt; But however you slice it, some principle of Swift&#39;s access control rules is violated by `private`. If `foo` is visible in a place where I cannot write `private var bar` to mean the same visibility, then the access level of `foo` is unutterable in that location, which is unprecedented as well.<br>&gt; <br>&gt; I don’t think utterability was a conscious principle to the degree that scope based access control was.  If that was the case the issue would surely have been identified during review.  It wasn’t until Robert started the implementation that anyone (AFAIK) notices that the proposal introduces unutterable visibility in some cases.  Utterability just isn’t something people were thinking about until then.<br>&gt; <br>&gt; But you are right that unutterability is unprecedented and I think everyone agrees that it poses problems which is why Jordan and Robert have amended the proposal to make the visibility members of private types without explicit access control utterable.<br>&gt; <br>&gt; The solution we want is to preserve *both* of these principles, not change which one were violating. :)<br>&gt; <br>&gt; If a private member must be visible within a nested type, then that access level necessarily becomes unutterable within the nested type unless we introduce another keyword, which is out of scope without a new proposal. There is no squaring the circle to be had. The amendment, to my understanding, simply hacks around this issue to make `private` nonetheless useful by allowing `fileprivate` things inside `private` things, but in so doing we&#39;re enshrining which of these principles we&#39;re violating, not finding a solution that avoids violating them.<br></p><p>So, the problem is that there are access levels that cannot be specified explicitly? We can either accept that or reject the proposal completely. Or am I missing something? Are there any other solutions that are even worth considering?<br></p><p>I don&#39;t see a problem with unutterable access levels. I also don&#39;t see a problem with unprecedented unutterable access levels. In Swift 2 all access levels where utterable. In Swift 3 we lose that ability. Is the loss significant? Maybe it&#39;s hard to implement into the compiler, I don&#39;t know, but as a language user its easy to understand what is going on IMO.<br></p><p>-Michael<br></p><p>&gt;  <br>&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 05:00:00pm</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 5:13 PM, Michael Peternell &lt;michael.peternell at gmx.at<br>&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; Am 29.06.2016 um 23:57 schrieb Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;<br>&gt; &gt; On Wed, Jun 29, 2016 at 4:46 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On Jun 29, 2016, at 4:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Wed, Jun 29, 2016 at 4:16 PM, Matthew Johnson &lt;<br>&gt; matthew at anandabits.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Jun 29, 2016, at 4:12 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:07 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt; &gt;&gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types,<br>&gt; extensions etc.<br>&gt; &gt;&gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt; &gt;&gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt;&gt; &gt; I think this is a little less confusing since effectively this is<br>&gt; what is happening in the background.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less<br>&gt; important than the rest of the amendment.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; There actually is an answer to this, which is that the core team<br>&gt; expects &#39;private&#39; to be the common keyword, and therefore it’s better if<br>&gt; you can use it at the top level and ignore ‘fileprivate’ altogether in most<br>&gt; programs.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private`<br>&gt; literally meant visibility *only* within the current declaration, and<br>&gt; neither outside it nor inside any nested types, etc.?<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Yes, but that&#39;s not very useful:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; public struct Foo {<br>&gt; &gt;&gt;&gt;   private var value: Int = 0<br>&gt; &gt;&gt;&gt;   public func test() {<br>&gt; &gt;&gt;&gt;     print(value) // error<br>&gt; &gt;&gt;&gt;   }<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I suppose you could say that nested types are different from nested<br>&gt; functions, but then we start getting complexity in a different direction.<br>&gt; And it still doesn&#39;t fix the default access within a private type.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Let me offer a principled rule: if I write `private var foo`, then<br>&gt; `foo` is invisible at such places within the declaration where writing<br>&gt; `private var bar` at the same place would cause `bar` to be visible where<br>&gt; `foo` is not or vice versa.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This violates the principle behind all of Swift’s access control<br>&gt; rules.  That principle is that access control is strictly based on a<br>&gt; hierarchy of lexical scopes.  This is a really great principle and is what<br>&gt; makes Swift’s access control better than any other I know of (IMO of<br>&gt; course).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; But however you slice it, some principle of Swift&#39;s access control<br>&gt; rules is violated by `private`. If `foo` is visible in a place where I<br>&gt; cannot write `private var bar` to mean the same visibility, then the access<br>&gt; level of `foo` is unutterable in that location, which is unprecedented as<br>&gt; well.<br>&gt; &gt;<br>&gt; &gt; I don’t think utterability was a conscious principle to the degree that<br>&gt; scope based access control was.  If that was the case the issue would<br>&gt; surely have been identified during review.  It wasn’t until Robert started<br>&gt; the implementation that anyone (AFAIK) notices that the proposal introduces<br>&gt; unutterable visibility in some cases.  Utterability just isn’t something<br>&gt; people were thinking about until then.<br>&gt; &gt;<br>&gt; &gt; But you are right that unutterability is unprecedented and I think<br>&gt; everyone agrees that it poses problems which is why Jordan and Robert have<br>&gt; amended the proposal to make the visibility members of private types<br>&gt; without explicit access control utterable.<br>&gt; &gt;<br>&gt; &gt; The solution we want is to preserve *both* of these principles, not<br>&gt; change which one were violating. :)<br>&gt; &gt;<br>&gt; &gt; If a private member must be visible within a nested type, then that<br>&gt; access level necessarily becomes unutterable within the nested type unless<br>&gt; we introduce another keyword, which is out of scope without a new proposal.<br>&gt; There is no squaring the circle to be had. The amendment, to my<br>&gt; understanding, simply hacks around this issue to make `private` nonetheless<br>&gt; useful by allowing `fileprivate` things inside `private` things, but in so<br>&gt; doing we&#39;re enshrining which of these principles we&#39;re violating, not<br>&gt; finding a solution that avoids violating them.<br>&gt;<br>&gt; So, the problem is that there are access levels that cannot be specified<br>&gt; explicitly? We can either accept that or reject the proposal completely. Or<br>&gt; am I missing something? Are there any other solutions that are even worth<br>&gt; considering?<br>&gt;<br>&gt; I don&#39;t see a problem with unutterable access levels. I also don&#39;t see a<br>&gt; problem with unprecedented unutterable access levels. In Swift 2 all access<br>&gt; levels where utterable. In Swift 3 we lose that ability. Is the loss<br>&gt; significant? Maybe it&#39;s hard to implement into the compiler, I don&#39;t know,<br>&gt; but as a language user its easy to understand what is going on IMO.<br>&gt;<br></p><p>Here is the problem:<br></p><p>```<br>private struct Foo {<br>  /* private */ struct Bar {<br>    // it doesn&#39;t matter what you write in here, you&#39;ll never see it in<br>`Foo`<br>  }<br>}<br>```<br></p><p><br>&gt;<br>&gt; -Michael<br>&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Jordan<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/403e2592/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June 30, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; Am 30.06.2016 um 00:17 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Here is the problem:<br>&gt; <br>&gt; ```<br>&gt; private struct Foo {<br>&gt;   /* private */ struct Bar {<br>&gt;     // it doesn&#39;t matter what you write in here, you&#39;ll never see it in `Foo`<br>&gt;   }<br>&gt; }<br>&gt; ```<br>&gt;  <br></p><p>So this is not a practical design for this feature then. Following the ideas I presented a few hours earlier this should lead to:<br></p><p>private struct Foo {<br>    struct Bar {<br>        var strawberryBar: [String]<br>    }<br>    // Scope(Bar) = Scope(Foo), because the scope of Bar is unspecified<br>    // Scope(Bar.strawBerryBar) = Scope(Bar) = Scope(Foo), for the same reason<br>    // Foo is visible here =&gt; Bar.strawberryBar is visible too<br></p><p>    func hello() {<br>        let s = Bar(strawberryBar: [&quot;yummi&quot;]<br>        print(&quot;mjam: \(s.strawberryBar)&quot;)<br>    }<br>    // everything compiles...<br>}<br></p><p>Making Bar implicitly private doesn&#39;t make sense at all. Bar should have the same scope as Foo. `private` on Bar has a completely different meaning than `private` on Foo so this is not the same access level. The implicit access level of Bar is unutterable here.<br></p><p>Anyways... I&#39;m out. I think there *is* a possible design that works. As long as no one provides another (possibly better) solution or argues with my why my design can not work I see no point (for me) in continuing this discussion.<br></p><p>-Michael<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 05:00:00pm</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 5:33 PM, Michael Peternell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; Am 30.06.2016 um 00:17 schrieb Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;<br>&gt; &gt; Here is the problem:<br>&gt; &gt;<br>&gt; &gt; ```<br>&gt; &gt; private struct Foo {<br>&gt; &gt;   /* private */ struct Bar {<br>&gt; &gt;     // it doesn&#39;t matter what you write in here, you&#39;ll never see it in<br>&gt; `Foo`<br>&gt; &gt;   }<br>&gt; &gt; }<br>&gt; &gt; ```<br>&gt; &gt;<br>&gt;<br>&gt; So this is not a practical design for this feature then. Following the<br>&gt; ideas I presented a few hours earlier this should lead to:<br>&gt;<br>&gt; private struct Foo {<br>&gt;     struct Bar {<br>&gt;         var strawberryBar: [String]<br>&gt;     }<br>&gt;     // Scope(Bar) = Scope(Foo), because the scope of Bar is unspecified<br>&gt;     // Scope(Bar.strawBerryBar) = Scope(Bar) = Scope(Foo), for the same<br>&gt; reason<br>&gt;     // Foo is visible here =&gt; Bar.strawberryBar is visible too<br>&gt;<br>&gt;     func hello() {<br>&gt;         let s = Bar(strawberryBar: [&quot;yummi&quot;]<br>&gt;         print(&quot;mjam: \(s.strawberryBar)&quot;)<br>&gt;     }<br>&gt;     // everything compiles...<br>&gt; }<br>&gt;<br>&gt; Making Bar implicitly private doesn&#39;t make sense at all. Bar should have<br>&gt; the same scope as Foo. `private` on Bar has a completely different meaning<br>&gt; than `private` on Foo so this is not the same access level. The implicit<br>&gt; access level of Bar is unutterable here.<br>&gt;<br>&gt; Anyways... I&#39;m out. I think there *is* a possible design that works. As<br>&gt; long as no one provides another (possibly better) solution or argues with<br>&gt; my why my design can not work I see no point (for me) in continuing this<br>&gt; discussion.<br>&gt;<br></p><p>Yes, I think that would work; but it sounds like the core team has rejected<br>this suggestion, so I&#39;m suggesting others.<br></p><p><br>&gt;<br>&gt; -Michael<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/30ad6f1b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 5:33 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 30.06.2016 um 00:17 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; Here is the problem:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; private struct Foo {<br>&gt;&gt;  /* private */ struct Bar {<br>&gt;&gt;    // it doesn&#39;t matter what you write in here, you&#39;ll never see it in `Foo`<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt; <br>&gt; So this is not a practical design for this feature then. Following the ideas I presented a few hours earlier this should lead to:<br>&gt; <br>&gt; private struct Foo {<br>&gt;    struct Bar {<br>&gt;        var strawberryBar: [String]<br>&gt;    }<br>&gt;    // Scope(Bar) = Scope(Foo), because the scope of Bar is unspecified<br>&gt;    // Scope(Bar.strawBerryBar) = Scope(Bar) = Scope(Foo), for the same reason<br>&gt;    // Foo is visible here =&gt; Bar.strawberryBar is visible too<br>&gt; <br>&gt;    func hello() {<br>&gt;        let s = Bar(strawberryBar: [&quot;yummi&quot;]<br>&gt;        print(&quot;mjam: \(s.strawberryBar)&quot;)<br>&gt;    }<br>&gt;    // everything compiles...<br>&gt; }<br>&gt; <br>&gt; Making Bar implicitly private doesn&#39;t make sense at all. Bar should have the same scope as Foo. `private` on Bar has a completely different meaning than `private` on Foo so this is not the same access level. The implicit access level of Bar is unutterable here.<br>&gt; <br>&gt; Anyways... I&#39;m out. I think there *is* a possible design that works. As long as no one provides another (possibly better) solution or argues with my why my design can not work I see no point (for me) in continuing this discussion.<br></p><p>What you expect here is exactly what is intended by SE-0025 and provided by Jordan’s amendment.  I think some there is some confusion around access modifiers vs visibility.  In Swift 2 these always happened to correspond.  That correspondence allowed you to simple copy and paste any access modifier present on a parent scope into a nested declaration and it wouldn’t ever lower the visibility of the member (although it could raise it in the case of `public`).  Further, anywhere an access modifier appeared it referred to the same level of visibility.  <br></p><p>In Swift 3 with the scope-based `private` this is no longer the case - if you copy and paste `private` from a parent scope into a nested declaration it lowers the visibility because `private` is applied in a narrower scope.  The meaning of the access modifier and therefor the visibility level it references depend on the context (scope) in which the modifier appears.  This has caused some confusion.  The fact that the visibility is unutterable exacerbates the confusion.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; -Michael<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 5:17 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Wed, Jun 29, 2016 at 5:13 PM, Michael Peternell &lt;michael.peternell at gmx.at &lt;mailto:michael.peternell at gmx.at&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; Am 29.06.2016 um 23:57 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; &gt;<br>&gt; &gt; On Wed, Jun 29, 2016 at 4:46 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On Jun 29, 2016, at 4:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Wed, Jun 29, 2016 at 4:16 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Jun 29, 2016, at 4:12 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:07 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com &lt;mailto:cheyo at masters3d.com&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt; &gt;&gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types, extensions etc.<br>&gt; &gt;&gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt; &gt;&gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt;&gt; &gt; I think this is a little less confusing since effectively this is what is happening in the background.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less important than the rest of the amendment.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; There actually is an answer to this, which is that the core team expects &#39;private&#39; to be the common keyword, and therefore it’s better if you can use it at the top level and ignore ‘fileprivate’ altogether in most programs.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private` literally meant visibility *only* within the current declaration, and neither outside it nor inside any nested types, etc.?<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Yes, but that&#39;s not very useful:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; public struct Foo {<br>&gt; &gt;&gt;&gt;   private var value: Int = 0<br>&gt; &gt;&gt;&gt;   public func test() {<br>&gt; &gt;&gt;&gt;     print(value) // error<br>&gt; &gt;&gt;&gt;   }<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I suppose you could say that nested types are different from nested functions, but then we start getting complexity in a different direction. And it still doesn&#39;t fix the default access within a private type.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Let me offer a principled rule: if I write `private var foo`, then `foo` is invisible at such places within the declaration where writing `private var bar` at the same place would cause `bar` to be visible where `foo` is not or vice versa.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This violates the principle behind all of Swift’s access control rules.  That principle is that access control is strictly based on a hierarchy of lexical scopes.  This is a really great principle and is what makes Swift’s access control better than any other I know of (IMO of course).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; But however you slice it, some principle of Swift&#39;s access control rules is violated by `private`. If `foo` is visible in a place where I cannot write `private var bar` to mean the same visibility, then the access level of `foo` is unutterable in that location, which is unprecedented as well.<br>&gt; &gt;<br>&gt; &gt; I don’t think utterability was a conscious principle to the degree that scope based access control was.  If that was the case the issue would surely have been identified during review.  It wasn’t until Robert started the implementation that anyone (AFAIK) notices that the proposal introduces unutterable visibility in some cases.  Utterability just isn’t something people were thinking about until then.<br>&gt; &gt;<br>&gt; &gt; But you are right that unutterability is unprecedented and I think everyone agrees that it poses problems which is why Jordan and Robert have amended the proposal to make the visibility members of private types without explicit access control utterable.<br>&gt; &gt;<br>&gt; &gt; The solution we want is to preserve *both* of these principles, not change which one were violating. :)<br>&gt; &gt;<br>&gt; &gt; If a private member must be visible within a nested type, then that access level necessarily becomes unutterable within the nested type unless we introduce another keyword, which is out of scope without a new proposal. There is no squaring the circle to be had. The amendment, to my understanding, simply hacks around this issue to make `private` nonetheless useful by allowing `fileprivate` things inside `private` things, but in so doing we&#39;re enshrining which of these principles we&#39;re violating, not finding a solution that avoids violating them.<br>&gt; <br>&gt; So, the problem is that there are access levels that cannot be specified explicitly? We can either accept that or reject the proposal completely. Or am I missing something? Are there any other solutions that are even worth considering?<br>&gt; <br>&gt; I don&#39;t see a problem with unutterable access levels. I also don&#39;t see a problem with unprecedented unutterable access levels. In Swift 2 all access levels where utterable. In Swift 3 we lose that ability. Is the loss significant? Maybe it&#39;s hard to implement into the compiler, I don&#39;t know, but as a language user its easy to understand what is going on IMO.<br>&gt; <br>&gt; Here is the problem:<br>&gt; <br>&gt; ```<br>&gt; private struct Foo {<br>&gt;   /* private */ struct Bar {<br>&gt;     // it doesn&#39;t matter what you write in here, you&#39;ll never see it in `Foo`<br>&gt;   }<br>&gt; }<br>&gt; ```<br></p><p>This is *not* true of the semantics intended by SE-0025 and provided by Jordan’s amendment.  `Bar` is visible everywhere `Foo` is visible and so are the members of `Bar` that do not have explicit access control.<br></p><p>&gt;  <br>&gt; <br>&gt; -Michael<br>&gt; <br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Jordan<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/70c35471/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 4:57 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 29, 2016 at 4:46 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 4:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 29, 2016 at 4:16 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 4:12 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:07 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com &lt;mailto:cheyo at masters3d.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types, extensions etc.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I think this is a little less confusing since effectively this is what is happening in the background.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less important than the rest of the amendment.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There actually is an answer to this, which is that the core team expects &#39;private&#39; to be the common keyword, and therefore it’s better if you can use it at the top level and ignore ‘fileprivate’ altogether in most programs.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private` literally meant visibility *only* within the current declaration, and neither outside it nor inside any nested types, etc.?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, but that&#39;s not very useful:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public struct Foo {<br>&gt;&gt;&gt;   private var value: Int = 0<br>&gt;&gt;&gt;   public func test() {<br>&gt;&gt;&gt;     print(value) // error<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I suppose you could say that nested types are different from nested functions, but then we start getting complexity in a different direction. And it still doesn&#39;t fix the default access within a private type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let me offer a principled rule: if I write `private var foo`, then `foo` is invisible at such places within the declaration where writing `private var bar` at the same place would cause `bar` to be visible where `foo` is not or vice versa.<br>&gt;&gt; <br>&gt;&gt; This violates the principle behind all of Swift’s access control rules.  That principle is that access control is strictly based on a hierarchy of lexical scopes.  This is a really great principle and is what makes Swift’s access control better than any other I know of (IMO of course).<br>&gt;&gt; <br>&gt;&gt; But however you slice it, some principle of Swift&#39;s access control rules is violated by `private`. If `foo` is visible in a place where I cannot write `private var bar` to mean the same visibility, then the access level of `foo` is unutterable in that location, which is unprecedented as well.<br>&gt; <br>&gt; I don’t think utterability was a conscious principle to the degree that scope based access control was.  If that was the case the issue would surely have been identified during review.  It wasn’t until Robert started the implementation that anyone (AFAIK) notices that the proposal introduces unutterable visibility in some cases.  Utterability just isn’t something people were thinking about until then.<br>&gt; <br>&gt; But you are right that unutterability is unprecedented and I think everyone agrees that it poses problems which is why Jordan and Robert have amended the proposal to make the visibility members of private types without explicit access control utterable.<br>&gt; <br>&gt; The solution we want is to preserve *both* of these principles, not change which one were violating. :)<br>&gt; <br>&gt; If a private member must be visible within a nested type, then that access level necessarily becomes unutterable within the nested type unless we introduce another keyword, which is out of scope without a new proposal. There is no squaring the circle to be had. The amendment, to my understanding, simply hacks around this issue to make `private` nonetheless useful by allowing `fileprivate` things inside `private` things, but in so doing we&#39;re enshrining which of these principles we&#39;re violating, not finding a solution that avoids violating them.<br></p><p>Do you mean a third principle which says something like “a member shall not have a higher access level than its parent”.  If so, you are correct that Jordan’s amendment does violate that and another proposal would be necessary to give it a name that does not exist today.  I don’ think that&#39;s going to happen for Swift 3.  <br></p><p>&gt;  <br>&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/ab49db4f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 05:00:00pm</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 5:36 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jun 29, 2016, at 4:57 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Jun 29, 2016 at 4:46 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 29, 2016, at 4:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Wed, Jun 29, 2016 at 4:16 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jun 29, 2016, at 4:12 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:07 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt;wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types,<br>&gt;&gt;&gt;&gt;&gt; extensions etc.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I think this is a little less confusing since effectively this is<br>&gt;&gt;&gt;&gt;&gt; what is happening in the background.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less<br>&gt;&gt;&gt;&gt;&gt; important than the rest of the amendment.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; There actually is an answer to this, which is that the core team<br>&gt;&gt;&gt;&gt;&gt; expects &#39;private&#39; to be the common keyword, and therefore it’s better if<br>&gt;&gt;&gt;&gt;&gt; you can use it at the top level and ignore ‘fileprivate’ altogether in most<br>&gt;&gt;&gt;&gt;&gt; programs.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private`<br>&gt;&gt;&gt;&gt; literally meant visibility *only* within the current declaration, and<br>&gt;&gt;&gt;&gt; neither outside it nor inside any nested types, etc.?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Yes, but that&#39;s not very useful:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; public struct Foo {<br>&gt;&gt;&gt;&gt;   private var value: Int = 0<br>&gt;&gt;&gt;&gt;   public func test() {<br>&gt;&gt;&gt;&gt;     print(value) // error<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I suppose you could say that nested *types* are different from nested<br>&gt;&gt;&gt;&gt; *functions,* but then we start getting complexity in a different<br>&gt;&gt;&gt;&gt; direction. And it still doesn&#39;t fix the default access within a private<br>&gt;&gt;&gt;&gt; type.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Let me offer a principled rule: if I write `private var foo`, then `foo`<br>&gt;&gt;&gt; is invisible at such places within the declaration where writing `private<br>&gt;&gt;&gt; var bar` at the same place would cause `bar` to be visible where `foo` is<br>&gt;&gt;&gt; not or vice versa.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This violates the principle behind all of Swift’s access control rules.<br>&gt;&gt;&gt; That principle is that access control is strictly based on a hierarchy of<br>&gt;&gt;&gt; lexical scopes.  This is a really great principle and is what makes Swift’s<br>&gt;&gt;&gt; access control better than any other I know of (IMO of course).<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; But however you slice it, some principle of Swift&#39;s access control rules<br>&gt;&gt; is violated by `private`. If `foo` is visible in a place where I cannot<br>&gt;&gt; write `private var bar` to mean the same visibility, then the access level<br>&gt;&gt; of `foo` is unutterable in that location, which is unprecedented as well.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don’t think utterability was a conscious principle to the degree that<br>&gt;&gt; scope based access control was.  If that was the case the issue would<br>&gt;&gt; surely have been identified during review.  It wasn’t until Robert started<br>&gt;&gt; the implementation that anyone (AFAIK) notices that the proposal introduces<br>&gt;&gt; unutterable visibility in some cases.  Utterability just isn’t something<br>&gt;&gt; people were thinking about until then.<br>&gt;&gt;<br>&gt;&gt; But you are right that unutterability is unprecedented and I think<br>&gt;&gt; everyone agrees that it poses problems which is why Jordan and Robert have<br>&gt;&gt; amended the proposal to make the visibility members of private types<br>&gt;&gt; without explicit access control utterable.<br>&gt;&gt;<br>&gt;&gt; The solution we want is to preserve *both* of these principles, not<br>&gt;&gt; change which one were violating. :)<br>&gt;&gt;<br>&gt;<br>&gt; If a private member must be visible within a nested type, then that access<br>&gt; level necessarily becomes unutterable within the nested type unless we<br>&gt; introduce another keyword, which is out of scope without a new proposal.<br>&gt; There is no squaring the circle to be had. The amendment, to my<br>&gt; understanding, simply hacks around this issue to make `private` nonetheless<br>&gt; useful by allowing `fileprivate` things inside `private` things, but in so<br>&gt; doing we&#39;re enshrining which of these principles we&#39;re violating, not<br>&gt; finding a solution that avoids violating them.<br>&gt;<br>&gt;<br>&gt; Do you mean a third principle which says something like “a member shall<br>&gt; not have a higher access level than its parent”.  If so, you are correct<br>&gt; that Jordan’s amendment does violate that and another proposal would be<br>&gt; necessary to give it a name that does not exist today.  I don’ think that&#39;s<br>&gt; going to happen for Swift 3.<br>&gt;<br></p><p>No, not exactly what I mean, but that is a concern. Jordan&#39;s proposal<br>introduces a dichotomy between the actual access level (i.e. the answer to<br>the question, which code can see this member?) and the access modifier<br>which is used in conjunction with the member (which would become<br>`fileprivate`). So yes, I can utter something, but it doesn&#39;t change the<br>fact that the question &quot;which code can actually see this member?&quot; still has<br>no utterable answer.<br></p><p><br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/a6b1d5cb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 05:00:00pm</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 5:41 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; On Wed, Jun 29, 2016 at 5:36 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 29, 2016, at 4:57 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Wed, Jun 29, 2016 at 4:46 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jun 29, 2016, at 4:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:16 PM, Matthew Johnson &lt;matthew at anandabits.com<br>&gt;&gt;&gt; &gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 4:12 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:07 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types,<br>&gt;&gt;&gt;&gt;&gt;&gt; extensions etc.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; I think this is a little less confusing since effectively this is<br>&gt;&gt;&gt;&gt;&gt;&gt; what is happening in the background.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less<br>&gt;&gt;&gt;&gt;&gt;&gt; important than the rest of the amendment.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; There actually is an answer to this, which is that the core team<br>&gt;&gt;&gt;&gt;&gt;&gt; expects &#39;private&#39; to be the common keyword, and therefore it’s better if<br>&gt;&gt;&gt;&gt;&gt;&gt; you can use it at the top level and ignore ‘fileprivate’ altogether in most<br>&gt;&gt;&gt;&gt;&gt;&gt; programs.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private`<br>&gt;&gt;&gt;&gt;&gt; literally meant visibility *only* within the current declaration, and<br>&gt;&gt;&gt;&gt;&gt; neither outside it nor inside any nested types, etc.?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Yes, but that&#39;s not very useful:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; public struct Foo {<br>&gt;&gt;&gt;&gt;&gt;   private var value: Int = 0<br>&gt;&gt;&gt;&gt;&gt;   public func test() {<br>&gt;&gt;&gt;&gt;&gt;     print(value) // error<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I suppose you could say that nested *types* are different from nested<br>&gt;&gt;&gt;&gt;&gt; *functions,* but then we start getting complexity in a different<br>&gt;&gt;&gt;&gt;&gt; direction. And it still doesn&#39;t fix the default access within a private<br>&gt;&gt;&gt;&gt;&gt; type.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Let me offer a principled rule: if I write `private var foo`, then<br>&gt;&gt;&gt;&gt; `foo` is invisible at such places within the declaration where writing<br>&gt;&gt;&gt;&gt; `private var bar` at the same place would cause `bar` to be visible where<br>&gt;&gt;&gt;&gt; `foo` is not or vice versa.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This violates the principle behind all of Swift’s access control<br>&gt;&gt;&gt;&gt; rules.  That principle is that access control is strictly based on a<br>&gt;&gt;&gt;&gt; hierarchy of lexical scopes.  This is a really great principle and is what<br>&gt;&gt;&gt;&gt; makes Swift’s access control better than any other I know of (IMO of<br>&gt;&gt;&gt;&gt; course).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But however you slice it, some principle of Swift&#39;s access control rules<br>&gt;&gt;&gt; is violated by `private`. If `foo` is visible in a place where I cannot<br>&gt;&gt;&gt; write `private var bar` to mean the same visibility, then the access level<br>&gt;&gt;&gt; of `foo` is unutterable in that location, which is unprecedented as well.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don’t think utterability was a conscious principle to the degree that<br>&gt;&gt;&gt; scope based access control was.  If that was the case the issue would<br>&gt;&gt;&gt; surely have been identified during review.  It wasn’t until Robert started<br>&gt;&gt;&gt; the implementation that anyone (AFAIK) notices that the proposal introduces<br>&gt;&gt;&gt; unutterable visibility in some cases.  Utterability just isn’t something<br>&gt;&gt;&gt; people were thinking about until then.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But you are right that unutterability is unprecedented and I think<br>&gt;&gt;&gt; everyone agrees that it poses problems which is why Jordan and Robert have<br>&gt;&gt;&gt; amended the proposal to make the visibility members of private types<br>&gt;&gt;&gt; without explicit access control utterable.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The solution we want is to preserve *both* of these principles, not<br>&gt;&gt;&gt; change which one were violating. :)<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If a private member must be visible within a nested type, then that<br>&gt;&gt; access level necessarily becomes unutterable within the nested type unless<br>&gt;&gt; we introduce another keyword, which is out of scope without a new proposal.<br>&gt;&gt; There is no squaring the circle to be had. The amendment, to my<br>&gt;&gt; understanding, simply hacks around this issue to make `private` nonetheless<br>&gt;&gt; useful by allowing `fileprivate` things inside `private` things, but in so<br>&gt;&gt; doing we&#39;re enshrining which of these principles we&#39;re violating, not<br>&gt;&gt; finding a solution that avoids violating them.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Do you mean a third principle which says something like “a member shall<br>&gt;&gt; not have a higher access level than its parent”.  If so, you are correct<br>&gt;&gt; that Jordan’s amendment does violate that and another proposal would be<br>&gt;&gt; necessary to give it a name that does not exist today.  I don’ think that&#39;s<br>&gt;&gt; going to happen for Swift 3.<br>&gt;&gt;<br>&gt;<br>&gt; No, not exactly what I mean, but that is a concern. Jordan&#39;s proposal<br>&gt; introduces a dichotomy between the actual access level (i.e. the answer to<br>&gt; the question, which code can see this member?) and the access modifier<br>&gt; which is used in conjunction with the member (which would become<br>&gt; `fileprivate`). So yes, I can utter something, but it doesn&#39;t change the<br>&gt; fact that the question &quot;which code can actually see this member?&quot; still has<br>&gt; no utterable answer.<br>&gt;<br></p><p><br>!!!<br>This just hit me like a ton of bricks. Jordan&#39;s proposal is repurposing<br>`fileprivate` to mean this previously unutterable scope and divorcing it<br>from meaning &quot;private to file&quot;.<br></p><p><br>&gt;<br>&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/833a8a06/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 5:51 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 29, 2016 at 5:41 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt; On Wed, Jun 29, 2016 at 5:36 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 4:57 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 29, 2016 at 4:46 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 4:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:16 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 4:12 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:07 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com &lt;mailto:cheyo at masters3d.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types, extensions etc.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I think this is a little less confusing since effectively this is what is happening in the background.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less important than the rest of the amendment.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There actually is an answer to this, which is that the core team expects &#39;private&#39; to be the common keyword, and therefore it’s better if you can use it at the top level and ignore ‘fileprivate’ altogether in most programs.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private` literally meant visibility *only* within the current declaration, and neither outside it nor inside any nested types, etc.?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, but that&#39;s not very useful:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public struct Foo {<br>&gt;&gt;&gt;&gt;   private var value: Int = 0<br>&gt;&gt;&gt;&gt;   public func test() {<br>&gt;&gt;&gt;&gt;     print(value) // error<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I suppose you could say that nested types are different from nested functions, but then we start getting complexity in a different direction. And it still doesn&#39;t fix the default access within a private type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let me offer a principled rule: if I write `private var foo`, then `foo` is invisible at such places within the declaration where writing `private var bar` at the same place would cause `bar` to be visible where `foo` is not or vice versa.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This violates the principle behind all of Swift’s access control rules.  That principle is that access control is strictly based on a hierarchy of lexical scopes.  This is a really great principle and is what makes Swift’s access control better than any other I know of (IMO of course).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But however you slice it, some principle of Swift&#39;s access control rules is violated by `private`. If `foo` is visible in a place where I cannot write `private var bar` to mean the same visibility, then the access level of `foo` is unutterable in that location, which is unprecedented as well.<br>&gt;&gt; <br>&gt;&gt; I don’t think utterability was a conscious principle to the degree that scope based access control was.  If that was the case the issue would surely have been identified during review.  It wasn’t until Robert started the implementation that anyone (AFAIK) notices that the proposal introduces unutterable visibility in some cases.  Utterability just isn’t something people were thinking about until then.<br>&gt;&gt; <br>&gt;&gt; But you are right that unutterability is unprecedented and I think everyone agrees that it poses problems which is why Jordan and Robert have amended the proposal to make the visibility members of private types without explicit access control utterable.<br>&gt;&gt; <br>&gt;&gt; The solution we want is to preserve *both* of these principles, not change which one were violating. :)<br>&gt;&gt; <br>&gt;&gt; If a private member must be visible within a nested type, then that access level necessarily becomes unutterable within the nested type unless we introduce another keyword, which is out of scope without a new proposal. There is no squaring the circle to be had. The amendment, to my understanding, simply hacks around this issue to make `private` nonetheless useful by allowing `fileprivate` things inside `private` things, but in so doing we&#39;re enshrining which of these principles we&#39;re violating, not finding a solution that avoids violating them.<br>&gt; <br>&gt; Do you mean a third principle which says something like “a member shall not have a higher access level than its parent”.  If so, you are correct that Jordan’s amendment does violate that and another proposal would be necessary to give it a name that does not exist today.  I don’ think that&#39;s going to happen for Swift 3.<br>&gt; <br>&gt; No, not exactly what I mean, but that is a concern. Jordan&#39;s proposal introduces a dichotomy between the actual access level (i.e. the answer to the question, which code can see this member?) and the access modifier which is used in conjunction with the member (which would become `fileprivate`). So yes, I can utter something, but it doesn&#39;t change the fact that the question &quot;which code can actually see this member?&quot; still has no utterable answer.<br>&gt; <br>&gt; <br>&gt; !!!<br>&gt; This just hit me like a ton of bricks. Jordan&#39;s proposal is repurposing `fileprivate` to mean this previously unutterable scope and divorcing it from meaning &quot;private to file”.<br></p><p>Yes, with Jordan’s amendment it basically means “private to the first ancestor scope which is marked private, or the file if there are no private ancestor scopes”. <br></p><p>&gt;  <br>&gt; <br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/b12ccf8c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 5:41 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 29, 2016 at 5:36 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 4:57 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 29, 2016 at 4:46 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 4:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:16 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 4:12 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:07 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com &lt;mailto:cheyo at masters3d.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types, extensions etc.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I think this is a little less confusing since effectively this is what is happening in the background.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less important than the rest of the amendment.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There actually is an answer to this, which is that the core team expects &#39;private&#39; to be the common keyword, and therefore it’s better if you can use it at the top level and ignore ‘fileprivate’ altogether in most programs.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private` literally meant visibility *only* within the current declaration, and neither outside it nor inside any nested types, etc.?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, but that&#39;s not very useful:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public struct Foo {<br>&gt;&gt;&gt;&gt;   private var value: Int = 0<br>&gt;&gt;&gt;&gt;   public func test() {<br>&gt;&gt;&gt;&gt;     print(value) // error<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I suppose you could say that nested types are different from nested functions, but then we start getting complexity in a different direction. And it still doesn&#39;t fix the default access within a private type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let me offer a principled rule: if I write `private var foo`, then `foo` is invisible at such places within the declaration where writing `private var bar` at the same place would cause `bar` to be visible where `foo` is not or vice versa.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This violates the principle behind all of Swift’s access control rules.  That principle is that access control is strictly based on a hierarchy of lexical scopes.  This is a really great principle and is what makes Swift’s access control better than any other I know of (IMO of course).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But however you slice it, some principle of Swift&#39;s access control rules is violated by `private`. If `foo` is visible in a place where I cannot write `private var bar` to mean the same visibility, then the access level of `foo` is unutterable in that location, which is unprecedented as well.<br>&gt;&gt; <br>&gt;&gt; I don’t think utterability was a conscious principle to the degree that scope based access control was.  If that was the case the issue would surely have been identified during review.  It wasn’t until Robert started the implementation that anyone (AFAIK) notices that the proposal introduces unutterable visibility in some cases.  Utterability just isn’t something people were thinking about until then.<br>&gt;&gt; <br>&gt;&gt; But you are right that unutterability is unprecedented and I think everyone agrees that it poses problems which is why Jordan and Robert have amended the proposal to make the visibility members of private types without explicit access control utterable.<br>&gt;&gt; <br>&gt;&gt; The solution we want is to preserve *both* of these principles, not change which one were violating. :)<br>&gt;&gt; <br>&gt;&gt; If a private member must be visible within a nested type, then that access level necessarily becomes unutterable within the nested type unless we introduce another keyword, which is out of scope without a new proposal. There is no squaring the circle to be had. The amendment, to my understanding, simply hacks around this issue to make `private` nonetheless useful by allowing `fileprivate` things inside `private` things, but in so doing we&#39;re enshrining which of these principles we&#39;re violating, not finding a solution that avoids violating them.<br>&gt; <br>&gt; Do you mean a third principle which says something like “a member shall not have a higher access level than its parent”.  If so, you are correct that Jordan’s amendment does violate that and another proposal would be necessary to give it a name that does not exist today.  I don’ think that&#39;s going to happen for Swift 3.<br>&gt; <br>&gt; No, not exactly what I mean, but that is a concern. Jordan&#39;s proposal introduces a dichotomy between the actual access level (i.e. the answer to the question, which code can see this member?) and the access modifier which is used in conjunction with the member (which would become `fileprivate`). So yes, I can utter something, but it doesn&#39;t change the fact that the question &quot;which code can actually see this member?&quot; still has no utterable answer.<br></p><p>The dichotomy is already implied by the semantics of SE-0025, it just left the visibility unutterable.  Jordan’s amendment makes `fileprivate` have context / scope sensitive semantics which makes the answer utterable.<br></p><p>The only way I can think of to make a scope-dependent visibility level *precisely* utterable everywhere within the relevant scope would be to introduce modifiers like `private(Foo)` where `Foo` is a parent scope.  If you want it to be *precisely* utterable you could consider proposing something along these lines after Swift 3 is out.  Any proposal along these lines would need to consider how to handle extensions since those don’t have names and would also need to handle degenerate cases such as `Foo` within `Foo` within `Foo`.<br></p><p>&gt;  <br>&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/0712d143/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 05:00:00pm</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 5:55 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jun 29, 2016, at 5:41 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Jun 29, 2016 at 5:36 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 29, 2016, at 4:57 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Wed, Jun 29, 2016 at 4:46 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt;  wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jun 29, 2016, at 4:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:16 PM, Matthew Johnson &lt;matthew at anandabits.com<br>&gt;&gt;&gt; &gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 4:12 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:07 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types,<br>&gt;&gt;&gt;&gt;&gt;&gt; extensions etc.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; I think this is a little less confusing since effectively this is<br>&gt;&gt;&gt;&gt;&gt;&gt; what is happening in the background.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less<br>&gt;&gt;&gt;&gt;&gt;&gt; important than the rest of the amendment.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; There actually is an answer to this, which is that the core team<br>&gt;&gt;&gt;&gt;&gt;&gt; expects &#39;private&#39; to be the common keyword, and therefore it’s better if<br>&gt;&gt;&gt;&gt;&gt;&gt; you can use it at the top level and ignore ‘fileprivate’ altogether in most<br>&gt;&gt;&gt;&gt;&gt;&gt; programs.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private`<br>&gt;&gt;&gt;&gt;&gt; literally meant visibility *only* within the current declaration, and<br>&gt;&gt;&gt;&gt;&gt; neither outside it nor inside any nested types, etc.?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Yes, but that&#39;s not very useful:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; public struct Foo {<br>&gt;&gt;&gt;&gt;&gt;   private var value: Int = 0<br>&gt;&gt;&gt;&gt;&gt;   public func test() {<br>&gt;&gt;&gt;&gt;&gt;     print(value) // error<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I suppose you could say that nested *types* are different from nested<br>&gt;&gt;&gt;&gt;&gt; *functions,* but then we start getting complexity in a different<br>&gt;&gt;&gt;&gt;&gt; direction. And it still doesn&#39;t fix the default access within a private<br>&gt;&gt;&gt;&gt;&gt; type.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Let me offer a principled rule: if I write `private var foo`, then<br>&gt;&gt;&gt;&gt; `foo` is invisible at such places within the declaration where writing<br>&gt;&gt;&gt;&gt; `private var bar` at the same place would cause `bar` to be visible where<br>&gt;&gt;&gt;&gt; `foo` is not or vice versa.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This violates the principle behind all of Swift’s access control<br>&gt;&gt;&gt;&gt; rules.  That principle is that access control is strictly based on a<br>&gt;&gt;&gt;&gt; hierarchy of lexical scopes.  This is a really great principle and is what<br>&gt;&gt;&gt;&gt; makes Swift’s access control better than any other I know of (IMO of<br>&gt;&gt;&gt;&gt; course).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But however you slice it, some principle of Swift&#39;s access control rules<br>&gt;&gt;&gt; is violated by `private`. If `foo` is visible in a place where I cannot<br>&gt;&gt;&gt; write `private var bar` to mean the same visibility, then the access level<br>&gt;&gt;&gt; of `foo` is unutterable in that location, which is unprecedented as well.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don’t think utterability was a conscious principle to the degree that<br>&gt;&gt;&gt; scope based access control was.  If that was the case the issue would<br>&gt;&gt;&gt; surely have been identified during review.  It wasn’t until Robert started<br>&gt;&gt;&gt; the implementation that anyone (AFAIK) notices that the proposal introduces<br>&gt;&gt;&gt; unutterable visibility in some cases.  Utterability just isn’t something<br>&gt;&gt;&gt; people were thinking about until then.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But you are right that unutterability is unprecedented and I think<br>&gt;&gt;&gt; everyone agrees that it poses problems which is why Jordan and Robert have<br>&gt;&gt;&gt; amended the proposal to make the visibility members of private types<br>&gt;&gt;&gt; without explicit access control utterable.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The solution we want is to preserve *both* of these principles, not<br>&gt;&gt;&gt; change which one were violating. :)<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If a private member must be visible within a nested type, then that<br>&gt;&gt; access level necessarily becomes unutterable within the nested type unless<br>&gt;&gt; we introduce another keyword, which is out of scope without a new proposal.<br>&gt;&gt; There is no squaring the circle to be had. The amendment, to my<br>&gt;&gt; understanding, simply hacks around this issue to make `private` nonetheless<br>&gt;&gt; useful by allowing `fileprivate` things inside `private` things, but in so<br>&gt;&gt; doing we&#39;re enshrining which of these principles we&#39;re violating, not<br>&gt;&gt; finding a solution that avoids violating them.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Do you mean a third principle which says something like “a member shall<br>&gt;&gt; not have a higher access level than its parent”.  If so, you are correct<br>&gt;&gt; that Jordan’s amendment does violate that and another proposal would be<br>&gt;&gt; necessary to give it a name that does not exist today.  I don’ think that&#39;s<br>&gt;&gt; going to happen for Swift 3.<br>&gt;&gt;<br>&gt;<br>&gt; No, not exactly what I mean, but that is a concern. Jordan&#39;s proposal<br>&gt; introduces a dichotomy between the actual access level (i.e. the answer to<br>&gt; the question, which code can see this member?) and the access modifier<br>&gt; which is used in conjunction with the member (which would become<br>&gt; `fileprivate`). So yes, I can utter something, but it doesn&#39;t change the<br>&gt; fact that the question &quot;which code can actually see this member?&quot; still has<br>&gt; no utterable answer.<br>&gt;<br>&gt;<br>&gt; The dichotomy is already implied by the semantics of SE-0025, it just left<br>&gt; the visibility unutterable.  Jordan’s amendment makes `fileprivate` have<br>&gt; context / scope sensitive semantics which makes the answer utterable.<br>&gt;<br></p><p>Yes, I see your point now. It took me this long to understand what was<br>being proposed because the name &quot;fileprivate&quot; explicitly disavows<br>context-sensitive semantics. With this amendment, `fileprivate` will<br>definitely need a renaming because it will neither be private nor scoped to<br>file.<br></p><p>The only way I can think of to make a scope-dependent visibility level<br>&gt; *precisely* utterable everywhere within the relevant scope would be to<br>&gt; introduce modifiers like `private(Foo)` where `Foo` is a parent scope.  If<br>&gt; you want it to be *precisely* utterable you could consider proposing<br>&gt; something along these lines after Swift 3 is out.  Any proposal along these<br>&gt; lines would need to consider how to handle extensions since those don’t<br>&gt; have names and would also need to handle degenerate cases such as `Foo`<br>&gt; within `Foo` within `Foo`.<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/61cd692b/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 5:59 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 29, 2016 at 5:55 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 5:41 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 29, 2016 at 5:36 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 4:57 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:46 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 4:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:16 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 4:12 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:07 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com &lt;mailto:cheyo at masters3d.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types, extensions etc.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; I think this is a little less confusing since effectively this is what is happening in the background.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less important than the rest of the amendment.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There actually is an answer to this, which is that the core team expects &#39;private&#39; to be the common keyword, and therefore it’s better if you can use it at the top level and ignore ‘fileprivate’ altogether in most programs.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private` literally meant visibility *only* within the current declaration, and neither outside it nor inside any nested types, etc.?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, but that&#39;s not very useful:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; public struct Foo {<br>&gt;&gt;&gt;&gt;&gt;   private var value: Int = 0<br>&gt;&gt;&gt;&gt;&gt;   public func test() {<br>&gt;&gt;&gt;&gt;&gt;     print(value) // error<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I suppose you could say that nested types are different from nested functions, but then we start getting complexity in a different direction. And it still doesn&#39;t fix the default access within a private type.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Let me offer a principled rule: if I write `private var foo`, then `foo` is invisible at such places within the declaration where writing `private var bar` at the same place would cause `bar` to be visible where `foo` is not or vice versa.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This violates the principle behind all of Swift’s access control rules.  That principle is that access control is strictly based on a hierarchy of lexical scopes.  This is a really great principle and is what makes Swift’s access control better than any other I know of (IMO of course).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But however you slice it, some principle of Swift&#39;s access control rules is violated by `private`. If `foo` is visible in a place where I cannot write `private var bar` to mean the same visibility, then the access level of `foo` is unutterable in that location, which is unprecedented as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t think utterability was a conscious principle to the degree that scope based access control was.  If that was the case the issue would surely have been identified during review.  It wasn’t until Robert started the implementation that anyone (AFAIK) notices that the proposal introduces unutterable visibility in some cases.  Utterability just isn’t something people were thinking about until then.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But you are right that unutterability is unprecedented and I think everyone agrees that it poses problems which is why Jordan and Robert have amended the proposal to make the visibility members of private types without explicit access control utterable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The solution we want is to preserve *both* of these principles, not change which one were violating. :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If a private member must be visible within a nested type, then that access level necessarily becomes unutterable within the nested type unless we introduce another keyword, which is out of scope without a new proposal. There is no squaring the circle to be had. The amendment, to my understanding, simply hacks around this issue to make `private` nonetheless useful by allowing `fileprivate` things inside `private` things, but in so doing we&#39;re enshrining which of these principles we&#39;re violating, not finding a solution that avoids violating them.<br>&gt;&gt; <br>&gt;&gt; Do you mean a third principle which says something like “a member shall not have a higher access level than its parent”.  If so, you are correct that Jordan’s amendment does violate that and another proposal would be necessary to give it a name that does not exist today.  I don’ think that&#39;s going to happen for Swift 3.<br>&gt;&gt; <br>&gt;&gt; No, not exactly what I mean, but that is a concern. Jordan&#39;s proposal introduces a dichotomy between the actual access level (i.e. the answer to the question, which code can see this member?) and the access modifier which is used in conjunction with the member (which would become `fileprivate`). So yes, I can utter something, but it doesn&#39;t change the fact that the question &quot;which code can actually see this member?&quot; still has no utterable answer.<br>&gt; <br>&gt; The dichotomy is already implied by the semantics of SE-0025, it just left the visibility unutterable.  Jordan’s amendment makes `fileprivate` have context / scope sensitive semantics which makes the answer utterable.<br>&gt; <br>&gt; Yes, I see your point now. It took me this long to understand what was being proposed because the name &quot;fileprivate&quot; explicitly disavows context-sensitive semantics. With this amendment, `fileprivate` will definitely need a renaming because it will neither be private nor scoped to file.<br></p><p>I think Jordan suggested it could be renamed after Swift 3 is out if we find a compellingly better name, it will just require a cycle of deprecation and then removal for `fileprivate`.<br></p><p>&gt; <br>&gt; The only way I can think of to make a scope-dependent visibility level *precisely* utterable everywhere within the relevant scope would be to introduce modifiers like `private(Foo)` where `Foo` is a parent scope.  If you want it to be *precisely* utterable you could consider proposing something along these lines after Swift 3 is out.  Any proposal along these lines would need to consider how to handle extensions since those don’t have names and would also need to handle degenerate cases such as `Foo` within `Foo` within `Foo`.<br>&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/b2b9d947/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 06:00:00pm</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 6:02 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jun 29, 2016, at 5:59 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Jun 29, 2016 at 5:55 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 29, 2016, at 5:41 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Wed, Jun 29, 2016 at 5:36 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt;  wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jun 29, 2016, at 4:57 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:46 PM, Matthew Johnson &lt;matthew at anandabits.com<br>&gt;&gt;&gt; &gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 4:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:16 PM, Matthew Johnson &lt;<br>&gt;&gt;&gt;&gt; matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 4:12 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 4:07 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extensions etc.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I think this is a little less confusing since effectively this is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; what is happening in the background.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; important than the rest of the amendment.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There actually is an answer to this, which is that the core team<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; expects &#39;private&#39; to be the common keyword, and therefore it’s better if<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; you can use it at the top level and ignore ‘fileprivate’ altogether in most<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; programs.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private`<br>&gt;&gt;&gt;&gt;&gt;&gt; literally meant visibility *only* within the current declaration, and<br>&gt;&gt;&gt;&gt;&gt;&gt; neither outside it nor inside any nested types, etc.?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, but that&#39;s not very useful:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; public struct Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;   private var value: Int = 0<br>&gt;&gt;&gt;&gt;&gt;&gt;   public func test() {<br>&gt;&gt;&gt;&gt;&gt;&gt;     print(value) // error<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I suppose you could say that nested *types* are different from nested<br>&gt;&gt;&gt;&gt;&gt;&gt;  *functions,* but then we start getting complexity in a different<br>&gt;&gt;&gt;&gt;&gt;&gt; direction. And it still doesn&#39;t fix the default access within a private<br>&gt;&gt;&gt;&gt;&gt;&gt; type.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Let me offer a principled rule: if I write `private var foo`, then<br>&gt;&gt;&gt;&gt;&gt; `foo` is invisible at such places within the declaration where writing<br>&gt;&gt;&gt;&gt;&gt; `private var bar` at the same place would cause `bar` to be visible where<br>&gt;&gt;&gt;&gt;&gt; `foo` is not or vice versa.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; This violates the principle behind all of Swift’s access control<br>&gt;&gt;&gt;&gt;&gt; rules.  That principle is that access control is strictly based on a<br>&gt;&gt;&gt;&gt;&gt; hierarchy of lexical scopes.  This is a really great principle and is what<br>&gt;&gt;&gt;&gt;&gt; makes Swift’s access control better than any other I know of (IMO of<br>&gt;&gt;&gt;&gt;&gt; course).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; But however you slice it, some principle of Swift&#39;s access control<br>&gt;&gt;&gt;&gt; rules is violated by `private`. If `foo` is visible in a place where I<br>&gt;&gt;&gt;&gt; cannot write `private var bar` to mean the same visibility, then the access<br>&gt;&gt;&gt;&gt; level of `foo` is unutterable in that location, which is unprecedented as<br>&gt;&gt;&gt;&gt; well.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I don’t think utterability was a conscious principle to the degree that<br>&gt;&gt;&gt;&gt; scope based access control was.  If that was the case the issue would<br>&gt;&gt;&gt;&gt; surely have been identified during review.  It wasn’t until Robert started<br>&gt;&gt;&gt;&gt; the implementation that anyone (AFAIK) notices that the proposal introduces<br>&gt;&gt;&gt;&gt; unutterable visibility in some cases.  Utterability just isn’t something<br>&gt;&gt;&gt;&gt; people were thinking about until then.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; But you are right that unutterability is unprecedented and I think<br>&gt;&gt;&gt;&gt; everyone agrees that it poses problems which is why Jordan and Robert have<br>&gt;&gt;&gt;&gt; amended the proposal to make the visibility members of private types<br>&gt;&gt;&gt;&gt; without explicit access control utterable.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The solution we want is to preserve *both* of these principles, not<br>&gt;&gt;&gt;&gt; change which one were violating. :)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If a private member must be visible within a nested type, then that<br>&gt;&gt;&gt; access level necessarily becomes unutterable within the nested type unless<br>&gt;&gt;&gt; we introduce another keyword, which is out of scope without a new proposal.<br>&gt;&gt;&gt; There is no squaring the circle to be had. The amendment, to my<br>&gt;&gt;&gt; understanding, simply hacks around this issue to make `private` nonetheless<br>&gt;&gt;&gt; useful by allowing `fileprivate` things inside `private` things, but in so<br>&gt;&gt;&gt; doing we&#39;re enshrining which of these principles we&#39;re violating, not<br>&gt;&gt;&gt; finding a solution that avoids violating them.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Do you mean a third principle which says something like “a member shall<br>&gt;&gt;&gt; not have a higher access level than its parent”.  If so, you are correct<br>&gt;&gt;&gt; that Jordan’s amendment does violate that and another proposal would be<br>&gt;&gt;&gt; necessary to give it a name that does not exist today.  I don’ think that&#39;s<br>&gt;&gt;&gt; going to happen for Swift 3.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; No, not exactly what I mean, but that is a concern. Jordan&#39;s proposal<br>&gt;&gt; introduces a dichotomy between the actual access level (i.e. the answer to<br>&gt;&gt; the question, which code can see this member?) and the access modifier<br>&gt;&gt; which is used in conjunction with the member (which would become<br>&gt;&gt; `fileprivate`). So yes, I can utter something, but it doesn&#39;t change the<br>&gt;&gt; fact that the question &quot;which code can actually see this member?&quot; still has<br>&gt;&gt; no utterable answer.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The dichotomy is already implied by the semantics of SE-0025, it just<br>&gt;&gt; left the visibility unutterable.  Jordan’s amendment makes `fileprivate`<br>&gt;&gt; have context / scope sensitive semantics which makes the answer utterable.<br>&gt;&gt;<br>&gt;<br>&gt; Yes, I see your point now. It took me this long to understand what was<br>&gt; being proposed because the name &quot;fileprivate&quot; explicitly disavows<br>&gt; context-sensitive semantics. With this amendment, `fileprivate` will<br>&gt; definitely need a renaming because it will neither be private nor scoped to<br>&gt; file.<br>&gt;<br>&gt;<br>&gt; I think Jordan suggested it could be renamed after Swift 3 is out if we<br>&gt; find a compellingly better name, it will just require a cycle of<br>&gt; deprecation and then removal for `fileprivate`.<br>&gt;<br></p><p>I&#39;m not approaching this from the standpoint of `fileprivate` being<br>ugly/awkward/etc. and better off with a renaming on that basis (though I<br>think that it wouldn&#39;t be a bad idea).<br></p><p>The point I&#39;m trying to make here is that, under the guise of doing things<br>that don&#39;t need re-review, Jordan&#39;s amendment changes the meaning of<br>`fileprivate` in a fundamental way. This is detrimental to user<br>understanding (as `fileprivate` was chosen to be self-explanatory for a<br>particular access level that will be amended). Because the amendment does<br>as much to change the meaning of `fileprivate` as SE-0025 does to change<br>the meaning of `private`, a new review is probably appropriate, with a<br>renaming or no.<br></p><p>The only way I can think of to make a scope-dependent visibility level<br>&gt;&gt; *precisely* utterable everywhere within the relevant scope would be to<br>&gt;&gt; introduce modifiers like `private(Foo)` where `Foo` is a parent scope.  If<br>&gt;&gt; you want it to be *precisely* utterable you could consider proposing<br>&gt;&gt; something along these lines after Swift 3 is out.  Any proposal along these<br>&gt;&gt; lines would need to consider how to handle extensions since those don’t<br>&gt;&gt; have names and would also need to handle degenerate cases such as `Foo`<br>&gt;&gt; within `Foo` within `Foo`.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/cb29a81e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 4:07 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com &lt;mailto:cheyo at masters3d.com&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types, extensions etc.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I think this is a little less confusing since effectively this is what is happening in the background.<br>&gt;&gt; <br>&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less important than the rest of the amendment.<br>&gt;&gt; <br>&gt;&gt; There actually is an answer to this, which is that the core team expects &#39;private&#39; to be the common keyword, and therefore it’s better if you can use it at the top level and ignore ‘fileprivate’ altogether in most programs.<br>&gt;&gt; <br>&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private` literally meant visibility *only* within the current declaration, and neither outside it nor inside any nested types, etc.?<br>&gt; <br>&gt; Yes, but that&#39;s not very useful:<br>&gt; <br>&gt; public struct Foo {<br>&gt;   private var value: Int = 0<br>&gt;   public func test() {<br>&gt;     print(value) // error<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; I suppose you could say that nested types are different from nested functions, but then we start getting complexity in a different direction. And it still doesn&#39;t fix the default access within a private type.<br></p><p>And some of us wouldn’t like that direction which means we may not end up with a solution that makes more people happy anyway at which point we’re back where we started.<br></p><p>&gt; <br>&gt; Jordan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/bac054cb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 04:00:00pm</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 4:15 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jun 29, 2016, at 4:07 PM, Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types,<br>&gt;&gt; extensions etc.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I think this is a little less confusing since effectively this is what<br>&gt;&gt; is happening in the background.<br>&gt;&gt;<br>&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less important<br>&gt;&gt; than the rest of the amendment.<br>&gt;&gt;<br>&gt;&gt; There actually is an answer to this, which is that the core team expects<br>&gt;&gt; &#39;private&#39; to be the common keyword, and therefore it’s better if you can<br>&gt;&gt; use it at the top level and ignore ‘fileprivate’ altogether in most<br>&gt;&gt; programs.<br>&gt;&gt;<br>&gt;<br>&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private`<br>&gt; literally meant visibility *only* within the current declaration, and<br>&gt; neither outside it nor inside any nested types, etc.?<br>&gt;<br>&gt;<br>&gt; Yes, but that&#39;s not very useful:<br>&gt;<br>&gt; public struct Foo {<br>&gt;   private var value: Int = 0<br>&gt;   public func test() {<br>&gt;     print(value) // error<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; I suppose you could say that nested *types* are different from nested<br>&gt; *functions,* but then we start getting complexity in a different<br>&gt; direction. And it still doesn&#39;t fix the default access within a private<br>&gt; type.<br>&gt;<br>&gt;<br>&gt; And some of us wouldn’t like that direction which means we may not end up<br>&gt; with a solution that makes more people happy anyway at which point we’re<br>&gt; back where we started.<br>&gt;<br></p><p>Looking back on SE-0025, the problem is that the proposal itself has no<br>details that even come close to resolving any of these differences. The<br>only thing that came up for discussion and was agreed to was that `private`<br>should mean something &quot;visible only within that lexical scope.&quot; None of<br>this is close to settled and we&#39;re probably better off actually debating<br>this in a real proposal.<br></p><p><br>&gt;<br>&gt;<br>&gt; Jordan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/7bd157d1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 29, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 14:17, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 29, 2016 at 4:15 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 4:07 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 14:03, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com &lt;mailto:cheyo at masters3d.com&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types, extensions etc.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I think this is a little less confusing since effectively this is what is happening in the background.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less important than the rest of the amendment.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There actually is an answer to this, which is that the core team expects &#39;private&#39; to be the common keyword, and therefore it’s better if you can use it at the top level and ignore ‘fileprivate’ altogether in most programs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On second thought, wouldn&#39;t all of this be inapplicable if `private` literally meant visibility *only* within the current declaration, and neither outside it nor inside any nested types, etc.?<br>&gt;&gt; <br>&gt;&gt; Yes, but that&#39;s not very useful:<br>&gt;&gt; <br>&gt;&gt; public struct Foo {<br>&gt;&gt;   private var value: Int = 0<br>&gt;&gt;   public func test() {<br>&gt;&gt;     print(value) // error<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I suppose you could say that nested types are different from nested functions, but then we start getting complexity in a different direction. And it still doesn&#39;t fix the default access within a private type.<br>&gt; <br>&gt; And some of us wouldn’t like that direction which means we may not end up with a solution that makes more people happy anyway at which point we’re back where we started.<br>&gt; <br>&gt; Looking back on SE-0025, the problem is that the proposal itself has no details that even come close to resolving any of these differences. The only thing that came up for discussion and was agreed to was that `private` should mean something &quot;visible only within that lexical scope.&quot; None of this is close to settled and we&#39;re probably better off actually debating this in a real proposal.<br></p><p>&quot;Lexical scope&quot; includes both nested types and nested functions.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/123d8d63/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 04:00:00pm</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I know this might be have been brought up before but<br>&gt; &gt;<br>&gt; &gt; why not just disallow the “private&quot; keyword for top level types,<br>&gt; extensions etc.<br>&gt; &gt;<br>&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt; &gt;<br>&gt; &gt; I think this is a little less confusing since effectively this is what<br>&gt; is happening in the background.<br>&gt;<br>&gt; That doesn’t fix anything for inner types, so it’s a lot less important<br>&gt; than the rest of the amendment.<br>&gt;<br>&gt; There actually is an answer to this, which is that the core team expects<br>&gt; &#39;private&#39; to be the common keyword, and therefore it’s better if you can<br>&gt; use it at the top level and ignore ‘fileprivate’ altogether in most<br>&gt; programs.<br>&gt;<br></p><p>FWIW, the text of SE-0025 itself makes no proposal about `private` as an<br>access level for types (only, strangely, nested types).<br></p><p><br>&gt;<br>&gt; Jordan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/562cfc44/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 4:43 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com &lt;mailto:cheyo at masters3d.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I know this might be have been brought up before but<br>&gt; &gt;<br>&gt; &gt; why not just disallow the “private&quot; keyword for top level types, extensions etc.<br>&gt; &gt;<br>&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt; &gt;<br>&gt; &gt; I think this is a little less confusing since effectively this is what is happening in the background.<br>&gt; <br>&gt; That doesn’t fix anything for inner types, so it’s a lot less important than the rest of the amendment.<br>&gt; <br>&gt; There actually is an answer to this, which is that the core team expects &#39;private&#39; to be the common keyword, and therefore it’s better if you can use it at the top level and ignore ‘fileprivate’ altogether in most programs.<br>&gt; <br>&gt; FWIW, the text of SE-0025 itself makes no proposal about `private` as an access level for types (only, strangely, nested types).<br></p><p>It proposed introducing a general access level.  If any kind of limitation regarding which declarations it applied to was intended that would have been stated explicitly.  Omission of a specific class of declaration from the list of examples should not be interpreted as an intention to make `private` inapplicable to those declarations.<br></p><p>&gt;  <br>&gt; <br>&gt; Jordan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/93d353c8/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 04:00:00pm</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 4:48 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jun 29, 2016, at 4:43 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types,<br>&gt;&gt; extensions etc.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I think this is a little less confusing since effectively this is what<br>&gt;&gt; is happening in the background.<br>&gt;&gt;<br>&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less important<br>&gt;&gt; than the rest of the amendment.<br>&gt;&gt;<br>&gt;&gt; There actually is an answer to this, which is that the core team expects<br>&gt;&gt; &#39;private&#39; to be the common keyword, and therefore it’s better if you can<br>&gt;&gt; use it at the top level and ignore ‘fileprivate’ altogether in most<br>&gt;&gt; programs.<br>&gt;&gt;<br>&gt;<br>&gt; FWIW, the text of SE-0025 itself makes no proposal about `private` as an<br>&gt; access level for types (only, strangely, nested types).<br>&gt;<br>&gt;<br>&gt; It proposed introducing a general access level.  If any kind of limitation<br>&gt; regarding which declarations it applied to was intended that would have<br>&gt; been stated explicitly.  Omission of a specific class of declaration from<br>&gt; the list of examples should not be interpreted as an intention to make<br>&gt; `private` inapplicable to those declarations.<br>&gt;<br></p><p>I don&#39;t doubt that the intent was a general access level. However, in<br>failing to mention top-level declarations of any sort as well as types, the<br>proposal itself fails to present a vision for two critical issues being<br>discussed here: (1) the issue of utterability; and (2) what to do when<br>`private` and `fileprivate` are equivalent in meaning. Both of these<br>scenarios are unprecedented because the three existing access levels do not<br>have these issues. If we had a fuller vision of the design challenges<br>during the initial proposal and review, these might have been resolved to<br>more general satisfaction before implementation was attempted.<br></p><p><br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; Jordan<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/5b5ee375/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 4:52 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 29, 2016 at 4:48 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 4:43 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 29, 2016 at 3:15 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; On Jun 29, 2016, at 13:13, Jose Cheyo Jimenez &lt;cheyo at masters3d.com &lt;mailto:cheyo at masters3d.com&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I know this might be have been brought up before but<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; why not just disallow the “private&quot; keyword for top level types, extensions etc.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; A fixit could change top level `private` to `fileprivate`.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I think this is a little less confusing since effectively this is what is happening in the background.<br>&gt;&gt; <br>&gt;&gt; That doesn’t fix anything for inner types, so it’s a lot less important than the rest of the amendment.<br>&gt;&gt; <br>&gt;&gt; There actually is an answer to this, which is that the core team expects &#39;private&#39; to be the common keyword, and therefore it’s better if you can use it at the top level and ignore ‘fileprivate’ altogether in most programs.<br>&gt;&gt; <br>&gt;&gt; FWIW, the text of SE-0025 itself makes no proposal about `private` as an access level for types (only, strangely, nested types).<br>&gt; <br>&gt; It proposed introducing a general access level.  If any kind of limitation regarding which declarations it applied to was intended that would have been stated explicitly.  Omission of a specific class of declaration from the list of examples should not be interpreted as an intention to make `private` inapplicable to those declarations.<br>&gt; <br>&gt; I don&#39;t doubt that the intent was a general access level. However, in failing to mention top-level declarations of any sort as well as types, the proposal itself fails to present a vision for two critical issues being discussed here: (1) the issue of utterability; and (2) what to do when `private` and `fileprivate` are equivalent in meaning. Both of these scenarios are unprecedented because the three existing access levels do not have these issues. If we had a fuller vision of the design challenges during the initial proposal and review, these might have been resolved to more general satisfaction before implementation was attempted.<br></p><p>Actually there was plenty of discussion about top level types, specifically point #2.  This was considered acceptable.  The recommendation is to just use private here, although that isn’t required.  <br></p><p>Unutterability is the only thing that wasn’t discussed.  Maybe that would have been discovered and discussed had the proposal been written better but that is water under the bridge now.  <br></p><p>&gt;  <br>&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/2fd95396/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 30, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On 29 Jun 2016, at 22:15, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There actually is an answer to this, which is that the core team expects &#39;private&#39; to be the common keyword, and therefore it’s better if you can use it at the top level and ignore ‘fileprivate’ altogether in most programs.<br></p><p>This makes no sense to me for two reasons:<br></p><p>1) As I previously said, I don&#39;t expect `private` to be the common keyword if people keep writing types as a main declaration and a set of extensions. With that style, we&#39;ll be using `fileprivate` heavily for properties in the main declaration.<br></p><p>2) If private means only visible to its lexical scope, I would have expected private top level declarations to be visible to the global scope, which is equivalent to `internal` for me, no `fileprivate`.<br></p><p>I&#39;m getting more and more confused about SE-0025.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 6:07 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 29 Jun 2016, at 22:15, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There actually is an answer to this, which is that the core team expects &#39;private&#39; to be the common keyword, and therefore it’s better if you can use it at the top level and ignore ‘fileprivate’ altogether in most programs.<br>&gt; <br>&gt; This makes no sense to me for two reasons:<br>&gt; <br>&gt; 1) As I previously said, I don&#39;t expect `private` to be the common keyword if people keep writing types as a main declaration and a set of extensions. With that style, we&#39;ll be using `fileprivate` heavily for properties in the main declaration.<br></p><p>It’s clear that *some* people are writing Swift this way.  But I don’t think it is the most common style.  I think it’s more common to put “core” members inside the type declaration.  With that style the need for `fileprivate` is minimized.<br></p><p>&gt; <br>&gt; 2) If private means only visible to its lexical scope, I would have expected private top level declarations to be visible to the global scope, which is equivalent to `internal` for me, no `fileprivate`.<br></p><p>Files introduce a scope in the same sense that modules do.  <br></p><p>&gt; <br>&gt; I&#39;m getting more and more confused about SE-0025.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 29, 2016 at 04:00:00pm</p></header><div class="content"><p>I just attended a core team meeting where this whole thing was discussed, and will update our amendment &lt;https://github.com/apple/swift-evolution/pull/383&gt; tonight. But in short:<br></p><p>- The default access level will be &#39;internal&#39; everywhere*. The compiler will not warn if the access-as-written is broader than necessary. Motivation: it should be possible to design a type&#39;s API as if it had more access than it currently does.<br></p><p>* except in extensions, see below<br></p><p>- The complicated &quot;rule 2&quot; from the amendment stands, but possibly in a form that isn&#39;t specific to &#39;fileprivate&#39;:<br></p><p>&gt; A non-private method, initializer, subscript, property, or typealias may still have a type that references `private` declarations if (1) the non-private declaration is a member of a private type, and (2) all referenced `private` declarations are defined within an enclosing lexical scope. That is, it is legal for a non-private member within a `private` type to have a type that is formally `private` if it would be legal for a `private` declaration in the parent scope to have that type.<br></p><p><br>As Xiaodi pointed out, this could be even broader, to say that an internal member may reference a fileprivate type if the member is itself defined within a fileprivate type, because it&#39;s still safe. That would look like this:<br></p><p>&gt; A member may not have a type that references any declarations that aren&#39;t accessible wherever the member is accessible.<br></p><p>I&#39;m concerned about that being too permissive, though. I still want this to be considered an error:<br></p><p>fileprivate struct Foo {<br>  fileprivate typealias Bar = Int<br>  internal func baz() -&gt; Bar { … }<br>}<br></p><p>- An access modifier on an extension has been ruled to indicate the desired scope, not the desired access. Therefore, members within a `private extension` will be `fileprivate`. (We&#39;re only really getting away with this because we don&#39;t allow extensions anywhere but at the top level, though if we had nested extensions we&#39;d probably consider them scoped anyway.)<br></p><p>- We are not looking at renaming either &#39;fileprivate&#39; or &#39;private&#39; for Swift 3.<br></p><p>- All this has been ruled not to need a formal review.<br></p><p>Thanks everyone for getting us to this point. It&#39;s definitely different from what I would have come up with on my own or just collaborating with Robert, so you can all count yourselves as contributors to this one. :-)<br></p><p>Jordan<br></p><p>P.S. If you see further issues here I&#39;d still like to hear them; if you&#39;re unclear on any points after I&#39;ve updated the pull request &lt;https://github.com/apple/swift-evolution/pull/383&gt;, I&#39;m happy to go over them again.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/a5eb3a77/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 29, 2016, at 6:51 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; I just attended a core team meeting where this whole thing was discussed, and will update our amendment tonight. But in short:<br>&gt; <br>&gt; - The default access level will be &#39;internal&#39; everywhere*. The compiler will not warn if the access-as-written is broader than necessary. Motivation: it should be possible to design a type&#39;s API as if it had more access than it currently does.<br>&gt; <br>&gt; * except in extensions, see below<br>&gt; <br>&gt; - The complicated &quot;rule 2&quot; from the amendment stands, but possibly in a form that isn&#39;t specific to &#39;fileprivate&#39;:<br>&gt; <br>&gt;&gt; A non-private method, initializer, subscript, property, or typealias may still have a type that references `private` declarations if (1) the non-private declaration is a member of a private type, and (2) all referenced `private` declarations are defined within an enclosing lexical scope. That is, it is legal for a non-private member within a `private` type to have a type that is formally `private` if it would be legal for a `private` declaration in the parent scope to have that type.<br>&gt; <br>&gt; <br>&gt; As Xiaodi pointed out, this could be even broader, to say that an internal member may reference a fileprivate type if the member is itself defined within a fileprivate type, because it&#39;s still safe. That would look like this:<br>&gt; <br>&gt;&gt; A member may not have a type that references any declarations that aren&#39;t accessible wherever the member is accessible.<br>&gt; <br>&gt; I&#39;m concerned about that being too permissive, though. I still want this to be considered an error:<br>&gt; <br>&gt; fileprivate struct Foo {<br>&gt;   fileprivate typealias Bar = Int<br>&gt;   internal func baz() -&gt; Bar { … }<br>&gt; }<br>&gt; <br>&gt; - An access modifier on an extension has been ruled to indicate the desired scope, not the desired access. Therefore, members within a `private extension` will be `fileprivate`. (We&#39;re only really getting away with this because we don&#39;t allow extensions anywhere but at the top level, though if we had nested extensions we&#39;d probably consider them scoped anyway.)<br>&gt; <br>&gt; - We are not looking at renaming either &#39;fileprivate&#39; or &#39;private&#39; for Swift 3.<br>&gt; <br>&gt; - All this has been ruled not to need a formal review.<br>&gt; <br>&gt; Thanks everyone for getting us to this point. It&#39;s definitely different from what I would have come up with on my own or just collaborating with Robert, so you can all count yourselves as contributors to this one. :-)<br></p><p>Thanks for your persistence on this Jordan!<br></p><p>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; P.S. If you see further issues here I&#39;d still like to hear them; if you&#39;re unclear on any points after I&#39;ve updated the pull request, I&#39;m happy to go over them again.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/5f92e22a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 29, 2016 at 06:00:00pm</p></header><div class="content"><p>Updated in https://github.com/apple/swift-evolution/pull/396 &lt;https://github.com/apple/swift-evolution/pull/396&gt;. Thanks again, everyone!<br></p><p>Jordan<br></p><p>&gt; On Jun 29, 2016, at 16:51, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; I just attended a core team meeting where this whole thing was discussed, and will update our amendment &lt;https://github.com/apple/swift-evolution/pull/383&gt; tonight. But in short:<br>&gt; <br>&gt; - The default access level will be &#39;internal&#39; everywhere*. The compiler will not warn if the access-as-written is broader than necessary. Motivation: it should be possible to design a type&#39;s API as if it had more access than it currently does.<br>&gt; <br>&gt; * except in extensions, see below<br>&gt; <br>&gt; - The complicated &quot;rule 2&quot; from the amendment stands, but possibly in a form that isn&#39;t specific to &#39;fileprivate&#39;:<br>&gt; <br>&gt;&gt; A non-private method, initializer, subscript, property, or typealias may still have a type that references `private` declarations if (1) the non-private declaration is a member of a private type, and (2) all referenced `private` declarations are defined within an enclosing lexical scope. That is, it is legal for a non-private member within a `private` type to have a type that is formally `private` if it would be legal for a `private` declaration in the parent scope to have that type.<br>&gt; <br>&gt; <br>&gt; As Xiaodi pointed out, this could be even broader, to say that an internal member may reference a fileprivate type if the member is itself defined within a fileprivate type, because it&#39;s still safe. That would look like this:<br>&gt; <br>&gt;&gt; A member may not have a type that references any declarations that aren&#39;t accessible wherever the member is accessible.<br>&gt; <br>&gt; I&#39;m concerned about that being too permissive, though. I still want this to be considered an error:<br>&gt; <br>&gt; fileprivate struct Foo {<br>&gt;   fileprivate typealias Bar = Int<br>&gt;   internal func baz() -&gt; Bar { … }<br>&gt; }<br>&gt; <br>&gt; - An access modifier on an extension has been ruled to indicate the desired scope, not the desired access. Therefore, members within a `private extension` will be `fileprivate`. (We&#39;re only really getting away with this because we don&#39;t allow extensions anywhere but at the top level, though if we had nested extensions we&#39;d probably consider them scoped anyway.)<br>&gt; <br>&gt; - We are not looking at renaming either &#39;fileprivate&#39; or &#39;private&#39; for Swift 3.<br>&gt; <br>&gt; - All this has been ruled not to need a formal review.<br>&gt; <br>&gt; Thanks everyone for getting us to this point. It&#39;s definitely different from what I would have come up with on my own or just collaborating with Robert, so you can all count yourselves as contributors to this one. :-)<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; P.S. If you see further issues here I&#39;d still like to hear them; if you&#39;re unclear on any points after I&#39;ve updated the pull request &lt;https://github.com/apple/swift-evolution/pull/383&gt;, I&#39;m happy to go over them again.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/5eb5774e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 09:00:00pm</p></header><div class="content"><p>[Resending with fewer recipients]<br></p><p>On Wed, Jun 29, 2016 at 8:55 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; Updated in https://github.com/apple/swift-evolution/pull/396. Thanks<br>&gt; again, everyone!<br>&gt;<br></p><p>As usual, a thoughtful result from the core team. Curious, though, where<br>does the following statement come into play?<br></p><p>&quot;The access level of a conformance concerning a `private` type or protocol<br>is considered to be `fileprivate` rather than `private`.&quot;<br></p><p><br>&gt; Jordan<br>&gt;<br>&gt; On Jun 29, 2016, at 16:51, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;<br>&gt; I just attended a core team meeting where this whole thing was discussed,<br>&gt; and will update our amendment<br>&gt; &lt;https://github.com/apple/swift-evolution/pull/383&gt; tonight. But in short:<br>&gt;<br>&gt; - The default access level will be &#39;internal&#39; everywhere*. The compiler<br>&gt; will not warn if the access-as-written is broader than necessary. *Motivation:<br>&gt; it should be possible to design a type&#39;s API as if it had more access than<br>&gt; it currently does.*<br>&gt;<br>&gt; * except in extensions, see below<br>&gt;<br>&gt; - The complicated &quot;rule 2&quot; from the amendment stands, but possibly in a<br>&gt; form that isn&#39;t specific to &#39;fileprivate&#39;:<br>&gt;<br>&gt; A non-private method, initializer, subscript, property, or typealias may<br>&gt; still have a type that references `private` declarations if (1) the<br>&gt; non-private declaration is a member of a private type, and (2) all<br>&gt; referenced `private` declarations are defined within an enclosing lexical<br>&gt; scope. That is, it is legal for a non-private member within a `private`<br>&gt; type to have a type that is formally `private` if it would be legal for a<br>&gt; `private` declaration in the parent scope to have that type.<br>&gt;<br>&gt;<br>&gt; As Xiaodi pointed out, this could be even broader, to say that an internal<br>&gt; member may reference a fileprivate type if the member is itself defined<br>&gt; within a fileprivate type, because it&#39;s still safe. That would look like<br>&gt; this:<br>&gt;<br>&gt; A member may not have a type that references any declarations that aren&#39;t<br>&gt; accessible wherever the member is accessible.<br>&gt;<br>&gt;<br>&gt; I&#39;m concerned about that being *too* permissive, though. I still want<br>&gt; this to be considered an error:<br>&gt;<br>&gt; fileprivate struct Foo {<br>&gt;   fileprivate typealias Bar = Int<br>&gt;   internal func baz() -&gt; Bar { … }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; - An access modifier on an extension has been ruled to indicate the<br>&gt; desired *scope,* not the desired *access.* Therefore, members within a<br>&gt; `private extension` will be `fileprivate`. (We&#39;re only really getting away<br>&gt; with this because we don&#39;t allow extensions anywhere but at the top level,<br>&gt; though if we had nested extensions we&#39;d probably consider them scoped<br>&gt; anyway.)<br>&gt;<br>&gt; - We are not looking at renaming either &#39;fileprivate&#39; or &#39;private&#39; for<br>&gt; Swift 3.<br>&gt;<br>&gt; - All this has been ruled not to need a formal review.<br>&gt;<br>&gt; Thanks everyone for getting us to this point. It&#39;s definitely different<br>&gt; from what I would have come up with on my own or just collaborating with<br>&gt; Robert, so you can all count yourselves as contributors to this one. :-)<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt; P.S. If you see further issues here I&#39;d still like to hear them; if you&#39;re<br>&gt; unclear on any points after I&#39;ve updated the pull request<br>&gt; &lt;https://github.com/apple/swift-evolution/pull/383&gt;, I&#39;m happy to go over<br>&gt; them again.<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/ba4a15bb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 29, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 7:07 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; [Resending with fewer recipients]<br>&gt; <br>&gt; On Wed, Jun 29, 2016 at 8:55 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt; Updated in https://github.com/apple/swift-evolution/pull/396 &lt;https://github.com/apple/swift-evolution/pull/396&gt;. Thanks again, everyone!<br>&gt;  <br>&gt; As usual, a thoughtful result from the core team. Curious, though, where does the following statement come into play?<br>&gt; <br>&gt; &quot;The access level of a conformance concerning a `private` type or protocol is considered to be `fileprivate` rather than `private`.&quot;<br></p><p>I think the internal representation may be leaking out.  I believe this is the right basic approach for formalizing the language rules here:<br></p><p>1. A scope S has access to a declaration D if S has access to the scope S_D in which D is declared and:<br>  - if D is explicitly declared &#39;private&#39;, S is equal to S_D or lexically nested within S_D,<br>  - if D is explicitly declared &#39;fileprivate&#39;, S appears within the same file as S_D,<br>  - if D is explicitly declared &#39;internal&#39;, S appears within the same module as S_D, or<br>  - if D lacks an explicit access specifier, S appears within the same module as S_D or S_D is a public extension (*).<br>(*) I believe this special case rule about public extensions is correct for the current model.  I&#39;m not sure it&#39;s a good idea, though.<br></p><p>2. A scope S has access to a scope T if:<br>  - S is equal to T or is lexically nested within it,<br>  - T is a declaration D and S has access to D, or<br>  - T is a file scope.<br></p><p>3. A declaration D shall not use in its signature any declaration D_sig for which there potentially exists a scope S such that S has access to D but not D_sig.  The signature of a declaration includes:<br>  - the explicit type of a function, initializer, variable, or constant declaration; or its inferred type (fully &quot;desugared&quot;, e.g. ignoring all type aliases) if an explicit type is not given<br>  - the underlying type of a typealias or associatedtype declaration<br>  - the superclass type of a class declaration<br>  - the conformance list of a class, struct, enum, protocol, or extension declaration<br>  - the generic parameters and constraints of a generic declaration<br>  - etc.<br></p><p>Formally, there&#39;s no need to decide the &quot;real&quot; or &quot;effective&quot; access modifier for a declaration.  Conveniently (and not coincidentally), these rules do end up being equivalent to computing an effective access level by just merging information down from the lexical container, but that&#39;s emergent, not fundamental, so don&#39;t put too much energy into whether the emergent access level &quot;makes sense&quot; as a description.<br></p><p>John.<br></p><p>&gt;  <br>&gt; Jordan<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 16:51, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I just attended a core team meeting where this whole thing was discussed, and will update our amendment &lt;https://github.com/apple/swift-evolution/pull/383&gt; tonight. But in short:<br>&gt;&gt; <br>&gt;&gt; - The default access level will be &#39;internal&#39; everywhere*. The compiler will not warn if the access-as-written is broader than necessary. Motivation: it should be possible to design a type&#39;s API as if it had more access than it currently does.<br>&gt;&gt; <br>&gt;&gt; * except in extensions, see below<br>&gt;&gt; <br>&gt;&gt; - The complicated &quot;rule 2&quot; from the amendment stands, but possibly in a form that isn&#39;t specific to &#39;fileprivate&#39;:<br>&gt;&gt; <br>&gt;&gt;&gt; A non-private method, initializer, subscript, property, or typealias may still have a type that references `private` declarations if (1) the non-private declaration is a member of a private type, and (2) all referenced `private` declarations are defined within an enclosing lexical scope. That is, it is legal for a non-private member within a `private` type to have a type that is formally `private` if it would be legal for a `private` declaration in the parent scope to have that type.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; As Xiaodi pointed out, this could be even broader, to say that an internal member may reference a fileprivate type if the member is itself defined within a fileprivate type, because it&#39;s still safe. That would look like this:<br>&gt;&gt; <br>&gt;&gt;&gt; A member may not have a type that references any declarations that aren&#39;t accessible wherever the member is accessible.<br>&gt;&gt; <br>&gt;&gt; I&#39;m concerned about that being too permissive, though. I still want this to be considered an error:<br>&gt;&gt; <br>&gt;&gt; fileprivate struct Foo {<br>&gt;&gt;   fileprivate typealias Bar = Int<br>&gt;&gt;   internal func baz() -&gt; Bar { … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; - An access modifier on an extension has been ruled to indicate the desired scope, not the desired access. Therefore, members within a `private extension` will be `fileprivate`. (We&#39;re only really getting away with this because we don&#39;t allow extensions anywhere but at the top level, though if we had nested extensions we&#39;d probably consider them scoped anyway.)<br>&gt;&gt; <br>&gt;&gt; - We are not looking at renaming either &#39;fileprivate&#39; or &#39;private&#39; for Swift 3.<br>&gt;&gt; <br>&gt;&gt; - All this has been ruled not to need a formal review.<br>&gt;&gt; <br>&gt;&gt; Thanks everyone for getting us to this point. It&#39;s definitely different from what I would have come up with on my own or just collaborating with Robert, so you can all count yourselves as contributors to this one. :-)<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; P.S. If you see further issues here I&#39;d still like to hear them; if you&#39;re unclear on any points after I&#39;ve updated the pull request &lt;https://github.com/apple/swift-evolution/pull/383&gt;, I&#39;m happy to go over them again.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/360af2e6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 30, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 23:34, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 7:07 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; [Resending with fewer recipients]<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 29, 2016 at 8:55 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; Updated in https://github.com/apple/swift-evolution/pull/396 &lt;https://github.com/apple/swift-evolution/pull/396&gt;. Thanks again, everyone!<br>&gt;&gt;  <br>&gt;&gt; As usual, a thoughtful result from the core team. Curious, though, where does the following statement come into play?<br>&gt;&gt; <br>&gt;&gt; &quot;The access level of a conformance concerning a `private` type or protocol is considered to be `fileprivate` rather than `private`.&quot;<br>&gt; <br>&gt; I think the internal representation may be leaking out.  I believe this is the right basic approach for formalizing the language rules here:<br>&gt; <br>&gt; 1. A scope S has access to a declaration D if S has access to the scope S_D in which D is declared and:<br>&gt;   - if D is explicitly declared &#39;private&#39;, S is equal to S_D or lexically nested within S_D,<br>&gt;   - if D is explicitly declared &#39;fileprivate&#39;, S appears within the same file as S_D,<br>&gt;   - if D is explicitly declared &#39;internal&#39;, S appears within the same module as S_D, or<br>&gt;   - if D lacks an explicit access specifier, S appears within the same module as S_D or S_D is a public extension (*).<br>&gt; (*) I believe this special case rule about public extensions is correct for the current model.  I&#39;m not sure it&#39;s a good idea, though.<br>&gt; <br>&gt; 2. A scope S has access to a scope T if:<br>&gt;   - S is equal to T or is lexically nested within it,<br>&gt;   - T is a declaration D and S has access to D, or<br>&gt;   - T is a file scope.<br></p><p>…and S is in the same file?<br></p><p>(We never formalized “scope”. Mostly it’s “curly braces, ish”. Not quite 1-1 with “DeclContext”.)<br></p><p>&gt; <br>&gt; 3. A declaration D shall not use in its signature any declaration D_sig for which there potentially exists a scope S such that S has access to D but not D_sig.  The signature of a declaration includes:<br>&gt;   - the explicit type of a function, initializer, variable, or constant declaration; or its inferred type (fully &quot;desugared&quot;, e.g. ignoring all type aliases) if an explicit type is not given<br>&gt;   - the underlying type of a typealias or associatedtype declaration<br>&gt;   - the superclass type of a class declaration<br>&gt;   - the conformance list of a class, struct, enum, protocol, or extension declaration<br>&gt;   - the generic parameters and constraints of a generic declaration<br>&gt;   - etc.<br>&gt; <br>&gt; Formally, there&#39;s no need to decide the &quot;real&quot; or &quot;effective&quot; access modifier for a declaration.  Conveniently (and not coincidentally), these rules do end up being equivalent to computing an effective access level by just merging information down from the lexical container, but that&#39;s emergent, not fundamental, so don&#39;t put too much energy into whether the emergent access level &quot;makes sense&quot; as a description.<br></p><p>Right. “Effective access” is a query in the compiler to determine the AST’s notion of symbol visibility; it’s not a term we want to use in the language spec.<br></p><p>These rules seem correct, but they’re not complete—they’re missing the restriction on witnesses for protocol requirements.<br></p><p>To Xiaodi’s original question, the notion of an access level for conformances is groundwork for a world where you can have conformances with less access than the type or protocol. We’re not in such a world, though, so I should just remove it. (I was reminded of it when rereading the original Access Control writeup, https://github.com/apple/swift/blob/master/docs/AccessControl.rst &lt;https://github.com/apple/swift/blob/master/docs/AccessControl.rst&gt;.)<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/55055085/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 30, 2016 at 04:00:00pm</p></header><div class="content"><p>Cool. FWIW, even in such a world, I wonder if the conformance needs to be<br>regarded as `fileprivate`:<br></p><p>In all cases where a private protocol is visible and conformance can be<br>declared, the protocol&#39;s access level would be--<br></p><p>- effectively fileprivate (if both protocol and conformance are declared<br>top-level)<br>- and/or private (if both protocol and conformance are declared in the same<br>scope)<br>- or unutterably less than fileprivate but more than private (if the<br>protocol is not declared top-level and the conformance is declared in a<br>nested scope).<br></p><p>In that last case, private is a less accessible level and all other<br>modifiers are more accessible, so the hypothetical feature of declaring<br>conformance with less access remains usable even if the default unutterable<br>access level stays unutterable.<br>On Thu, Jun 30, 2016 at 11:19 AM Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; On Jun 29, 2016, at 23:34, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;<br>&gt; On Jun 29, 2016, at 7:07 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; [Resending with fewer recipients]<br>&gt;<br>&gt; On Wed, Jun 29, 2016 at 8:55 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Updated in https://github.com/apple/swift-evolution/pull/396. Thanks<br>&gt;&gt; again, everyone!<br>&gt;&gt;<br>&gt;<br>&gt; As usual, a thoughtful result from the core team. Curious, though, where<br>&gt; does the following statement come into play?<br>&gt;<br>&gt; &quot;The access level of a conformance concerning a `private` type or protocol<br>&gt; is considered to be `fileprivate` rather than `private`.&quot;<br>&gt;<br>&gt;<br>&gt; I think the internal representation may be leaking out.  I believe this is<br>&gt; the right basic approach for formalizing the language rules here:<br>&gt;<br>&gt; 1. A scope S has access to a declaration D if S has access to the scope<br>&gt; S_D in which D is declared and:<br>&gt;   - if D is explicitly declared &#39;private&#39;, S is equal to S_D or lexically<br>&gt; nested within S_D,<br>&gt;   - if D is explicitly declared &#39;fileprivate&#39;, S appears within the same<br>&gt; file as S_D,<br>&gt;   - if D is explicitly declared &#39;internal&#39;, S appears within the same<br>&gt; module as S_D, or<br>&gt;   - if D lacks an explicit access specifier, S appears within the same<br>&gt; module as S_D or S_D is a public extension (*).<br>&gt; (*) I believe this special case rule about public extensions is correct<br>&gt; for the current model.  I&#39;m not sure it&#39;s a good idea, though.<br>&gt;<br>&gt; 2. A scope S has access to a scope T if:<br>&gt;   - S is equal to T or is lexically nested within it,<br>&gt;   - T is a declaration D and S has access to D, or<br>&gt;   - T is a file scope.<br>&gt;<br>&gt;<br>&gt; …and S is in the same file?<br>&gt;<br>&gt; (We never formalized “scope”. Mostly it’s “curly braces, ish”. Not quite<br>&gt; 1-1 with “DeclContext”.)<br>&gt;<br>&gt;<br>&gt; 3. A declaration D shall not use in its signature any declaration D_sig<br>&gt; for which there potentially exists a scope S such that S has access to D<br>&gt; but not D_sig.  The signature of a declaration includes:<br>&gt;   - the explicit type of a function, initializer, variable, or constant<br>&gt; declaration; or its inferred type (fully &quot;desugared&quot;, e.g. ignoring all<br>&gt; type aliases) if an explicit type is not given<br>&gt;   - the underlying type of a typealias or associatedtype declaration<br>&gt;   - the superclass type of a class declaration<br>&gt;   - the conformance list of a class, struct, enum, protocol, or extension<br>&gt; declaration<br>&gt;   - the generic parameters and constraints of a generic declaration<br>&gt;   - etc.<br>&gt;<br>&gt; Formally, there&#39;s no need to decide the &quot;real&quot; or &quot;effective&quot; access<br>&gt; modifier for a declaration.  Conveniently (and not coincidentally), these<br>&gt; rules do end up being equivalent to computing an effective access level by<br>&gt; just merging information down from the lexical container, but that&#39;s<br>&gt; emergent, not fundamental, so don&#39;t put too much energy into whether the<br>&gt; emergent access level &quot;makes sense&quot; as a description.<br>&gt;<br>&gt;<br>&gt; Right. “Effective access” is a query in the compiler to determine the<br>&gt; AST’s notion of symbol visibility; it’s not a term we want to use in the<br>&gt; language spec.<br>&gt;<br>&gt; These rules seem correct, but they’re not complete—they’re missing the<br>&gt; restriction on witnesses for protocol requirements.<br>&gt;<br>&gt; To Xiaodi’s original question, the notion of an access level for<br>&gt; conformances is groundwork for a world where you can have conformances with<br>&gt; less access than the type or protocol. We’re not in such a world, though,<br>&gt; so I should just remove it. (I was reminded of it when rereading the<br>&gt; original Access Control writeup,<br>&gt; https://github.com/apple/swift/blob/master/docs/AccessControl.rst.)<br>&gt;<br>&gt; Jordan<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/b3b11db4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 30, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 9:48, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Cool. FWIW, even in such a world, I wonder if the conformance needs to be regarded as `fileprivate`:<br>&gt; <br>&gt; In all cases where a private protocol is visible and conformance can be declared, the protocol&#39;s access level would be--<br>&gt; <br>&gt; - effectively fileprivate (if both protocol and conformance are declared top-level)<br>&gt; - and/or private (if both protocol and conformance are declared in the same scope)<br>&gt; - or unutterably less than fileprivate but more than private (if the protocol is not declared top-level and the conformance is declared in a nested scope).<br>&gt; <br>&gt; In that last case, private is a less accessible level and all other modifiers are more accessible, so the hypothetical feature of declaring conformance with less access remains usable even if the default unutterable access level stays unutterable.<br></p><p>Ah, this is probably true. The conformance always has access less than or equal to the type and less than or equal to the protocol, and you have to be able to see both the type and the protocol to do anything static with it anyway. I guess we&#39;re good without it.<br></p><p>Jordan<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 30, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 9:19 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt; On Jun 29, 2016, at 23:34, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 7:07 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [Resending with fewer recipients]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jun 29, 2016 at 8:55 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; Updated in https://github.com/apple/swift-evolution/pull/396 &lt;https://github.com/apple/swift-evolution/pull/396&gt;. Thanks again, everyone!<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; As usual, a thoughtful result from the core team. Curious, though, where does the following statement come into play?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;The access level of a conformance concerning a `private` type or protocol is considered to be `fileprivate` rather than `private`.&quot;<br>&gt;&gt; <br>&gt;&gt; I think the internal representation may be leaking out.  I believe this is the right basic approach for formalizing the language rules here:<br>&gt;&gt; <br>&gt;&gt; 1. A scope S has access to a declaration D if S has access to the scope S_D in which D is declared and:<br>&gt;&gt;   - if D is explicitly declared &#39;private&#39;, S is equal to S_D or lexically nested within S_D,<br>&gt;&gt;   - if D is explicitly declared &#39;fileprivate&#39;, S appears within the same file as S_D,<br>&gt;&gt;   - if D is explicitly declared &#39;internal&#39;, S appears within the same module as S_D, or<br>&gt;&gt;   - if D lacks an explicit access specifier, S appears within the same module as S_D or S_D is a public extension (*).<br>&gt;&gt; (*) I believe this special case rule about public extensions is correct for the current model.  I&#39;m not sure it&#39;s a good idea, though.<br>&gt;&gt; <br>&gt;&gt; 2. A scope S has access to a scope T if:<br>&gt;&gt;   - S is equal to T or is lexically nested within it,<br>&gt;&gt;   - T is a declaration D and S has access to D, or<br>&gt;&gt;   - T is a file scope.<br>&gt; <br>&gt; …and S is in the same file?<br></p><p>That would forbid all cross-file accesses.  Remember that this is and&#39;ed with the access to the actual declaration.<br></p><p>&gt; (We never formalized “scope”. Mostly it’s “curly braces, ish”. Not quite 1-1 with “DeclContext”.)<br></p><p>We technically didn&#39;t define &quot;lexically nested&quot;, either. :)  A formalization of the lookup rules would formalize scope; but yeah, the basic intuition is &quot;curly braces, ish&quot;.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; 3. A declaration D shall not use in its signature any declaration D_sig for which there potentially exists a scope S such that S has access to D but not D_sig.  The signature of a declaration includes:<br>&gt;&gt;   - the explicit type of a function, initializer, variable, or constant declaration; or its inferred type (fully &quot;desugared&quot;, e.g. ignoring all type aliases) if an explicit type is not given<br>&gt;&gt;   - the underlying type of a typealias or associatedtype declaration<br>&gt;&gt;   - the superclass type of a class declaration<br>&gt;&gt;   - the conformance list of a class, struct, enum, protocol, or extension declaration<br>&gt;&gt;   - the generic parameters and constraints of a generic declaration<br>&gt;&gt;   - etc.<br>&gt;&gt; <br>&gt;&gt; Formally, there&#39;s no need to decide the &quot;real&quot; or &quot;effective&quot; access modifier for a declaration.  Conveniently (and not coincidentally), these rules do end up being equivalent to computing an effective access level by just merging information down from the lexical container, but that&#39;s emergent, not fundamental, so don&#39;t put too much energy into whether the emergent access level &quot;makes sense&quot; as a description.<br>&gt; <br>&gt; Right. “Effective access” is a query in the compiler to determine the AST’s notion of symbol visibility; it’s not a term we want to use in the language spec.<br>&gt; <br>&gt; These rules seem correct, but they’re not complete—they’re missing the restriction on witnesses for protocol requirements.<br></p><p>Ah, right.  IIRC those rules are basically along the lines of &quot;there&#39;s no potential scope that can access the declaration of the conformance but not the declaration of one of its requirements&quot;.<br></p><p>John.<br></p><p>&gt; To Xiaodi’s original question, the notion of an access level for conformances is groundwork for a world where you can have conformances with less access than the type or protocol. We’re not in such a world, though, so I should just remove it. (I was reminded of it when rereading the original Access Control writeup, https://github.com/apple/swift/blob/master/docs/AccessControl.rst &lt;https://github.com/apple/swift/blob/master/docs/AccessControl.rst&gt;.)<br>&gt; <br>&gt; Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/c40c4614/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>June 30, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; Le 30 juin 2016 à 01:10, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 6:07 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 29 Jun 2016, at 22:15, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There actually is an answer to this, which is that the core team expects &#39;private&#39; to be the common keyword, and therefore it’s better if you can use it at the top level and ignore ‘fileprivate’ altogether in most programs.<br>&gt;&gt; <br>&gt;&gt; This makes no sense to me for two reasons:<br>&gt;&gt; <br>&gt;&gt; 1) As I previously said, I don&#39;t expect `private` to be the common keyword if people keep writing types as a main declaration and a set of extensions. With that style, we&#39;ll be using `fileprivate` heavily for properties in the main declaration.<br>&gt; <br>&gt; It’s clear that *some* people are writing Swift this way.  But I don’t think it is the most common style.  I think it’s more common to put “core” members inside the type declaration.  With that style the need for `fileprivate` is minimized.<br>&gt; <br></p><p>All sample code encourage writing extension for protocol, and when writing an application, a lot of classes implements delegate protocol. For what I can see in my own code, there is a lot of places where I will have to change to fileprivate instead of private to make it compile.<br></p><p>&gt;&gt; <br>&gt;&gt; 2) If private means only visible to its lexical scope, I would have expected private top level declarations to be visible to the global scope, which is equivalent to `internal` for me, no `fileprivate`.<br>&gt; <br>&gt; Files introduce a scope in the same sense that modules do.  <br>&gt; <br>&gt;&gt; <br>&gt;&gt; I&#39;m getting more and more confused about SE-0025.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 30, 2016 at 06:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 30, 2016, at 1:26 AM, Jean-Daniel Dupas &lt;mailing at xenonium.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Le 30 juin 2016 à 01:10, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 6:07 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 29 Jun 2016, at 22:15, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There actually is an answer to this, which is that the core team expects &#39;private&#39; to be the common keyword, and therefore it’s better if you can use it at the top level and ignore ‘fileprivate’ altogether in most programs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This makes no sense to me for two reasons:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) As I previously said, I don&#39;t expect `private` to be the common keyword if people keep writing types as a main declaration and a set of extensions. With that style, we&#39;ll be using `fileprivate` heavily for properties in the main declaration.<br>&gt;&gt; <br>&gt;&gt; It’s clear that *some* people are writing Swift this way.  But I don’t think it is the most common style.  I think it’s more common to put “core” members inside the type declaration.  With that style the need for `fileprivate` is minimized.<br>&gt; <br>&gt; All sample code encourage writing extension for protocol, and when writing an application, a lot of classes implements delegate protocol. For what I can see in my own code, there is a lot of places where I will have to change to fileprivate instead of private to make it compile.<br></p><p>I did say minimized, not eliminated.  If you use extensions for conformances and the conformance needs access to members that are not visible publicly then of course you will need fileprivate in that case.<br></p><p>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2) If private means only visible to its lexical scope, I would have expected private top level declarations to be visible to the global scope, which is equivalent to `internal` for me, no `fileprivate`.<br>&gt;&gt; <br>&gt;&gt; Files introduce a scope in the same sense that modules do.  <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m getting more and more confused about SE-0025.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>June 29, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 4:07 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 29 Jun 2016, at 22:15, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There actually is an answer to this, which is that the core team expects &#39;private&#39; to be the common keyword, and therefore it’s better if you can use it at the top level and ignore ‘fileprivate’ altogether in most programs.<br>&gt; <br>&gt; This makes no sense to me for two reasons:<br>&gt; <br>&gt; 1) As I previously said, I don&#39;t expect `private` to be the common keyword if people keep writing types as a main declaration and a set of extensions. With that style, we&#39;ll be using `fileprivate` heavily for properties in the main declaration.<br>&gt; <br>&gt; 2) If private means only visible to its lexical scope, I would have expected private top level declarations to be visible to the global scope, which is equivalent to `internal` for me, no `fileprivate`.<br>&gt; <br>&gt; I&#39;m getting more and more confused about SE-0025.<br></p><p>&quot;In the degenerate case of a top level declaration, “private” and “fileprivate” are the same thing, <br>since the scope that “private” refers to is the whole file. “ -Chris Lattner <br></p><p>http://article.gmane.org/gmane.comp.lang.swift.evolution/13282/ &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/13282/&gt;<br></p><p>Since private at the top level means fileprivate, <br>it makes sense that the nested declarations of top level fileprivate default to fileprivate.<br></p><p>The only thing that was a little confusing for me was to allow top level private (since it is the same thing as fileprivate)<br> but I think it is something once you learn it then it will make sense. (Maybe just hard to explain though)<br></p><p>+1 I am on board. I do not think this needs full review. <br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/3a356f79/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 29, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 29 Jun 2016, at 04:03, Matthew Judge &lt;matthew.judge at gmail.com&gt; wrote:<br>&gt; <br>&gt; If I understand SE-0025 (even with the amendment) you can still spell the access modifier to types as &#39;private&#39; and get the same characteristics as the pre-SE-0025 meaning or private, so I&#39;m not sure I understand the concern here. However (continued below)<br></p><p>The characteristic I will be missing is for the following style of writing:<br></p><p>class MyViewController : UIViewController {<br>    private var privateInfo: String?<br>}<br></p><p>//MARK: Public<br></p><p>public extension MyViewController {<br>    func publicFunction() {<br>        // CAN’T ACCESS privateInfo<br>    }<br>}<br></p><p>//MARK: UITableViewDataSource<br></p><p>private extension MyViewController : UITableViewDataSource {<br>    func numberOfRowsInSection(_ section: Int) -&gt; Int<br>        // CAN’T ACCESS privateInfo<br>    }<br>}<br></p><p>//MARK: Private<br></p><p>private extension MyViewController {<br>    func implementationFunction() {<br>        // CAN’T ACCESS privateInfo<br>    }<br>}<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/599db5a1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 08:00:00am</p></header><div class="content"><p>There is nothing preventing you from using fileprivate if you want to write your code in this style.  At most you can complain that you don&#39;t like the new keyword.  But you&#39;re not losing any functionality so I don&#39;t understand why you say you are &quot;missing&quot; something.<br></p><p>Sent from my iPad<br></p><p>&gt; On Jun 29, 2016, at 1:25 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 29 Jun 2016, at 04:03, Matthew Judge &lt;matthew.judge at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If I understand SE-0025 (even with the amendment) you can still spell the access modifier to types as &#39;private&#39; and get the same characteristics as the pre-SE-0025 meaning or private, so I&#39;m not sure I understand the concern here. However (continued below)<br>&gt; <br>&gt; The characteristic I will be missing is for the following style of writing:<br>&gt; <br>&gt; class MyViewController : UIViewController {<br>&gt;     private var privateInfo: String?<br>&gt; }<br>&gt; <br>&gt; //MARK: Public<br>&gt; <br>&gt; public extension MyViewController {<br>&gt;     func publicFunction() {<br>&gt;         // CAN’T ACCESS privateInfo<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; //MARK: UITableViewDataSource<br>&gt; <br>&gt; private extension MyViewController : UITableViewDataSource {<br>&gt;     func numberOfRowsInSection(_ section: Int) -&gt; Int<br>&gt;         // CAN’T ACCESS privateInfo<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; //MARK: Private<br>&gt; <br>&gt; private extension MyViewController {<br>&gt;     func implementationFunction() {<br>&gt;         // CAN’T ACCESS privateInfo<br>&gt;     }<br>&gt; }<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/91c7d903/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 29, 2016 at 05:00:00pm</p></header><div class="content"><p>Sorry if I wasn’t expressing myself well enough. In my original email, I said that:<br></p><p>&gt; The new rules make `private` more prominent compared to `fileprivate` (the latter has a somewhat worse name).<br></p><p>So I agree that my issue is more with the naming than the functionality. I’m mainly complaining that because of its name, `fileprivate` feels like more of a special corner case of `private`. But in the style of writing types through extensions, `fileprivate` will become much more prevalent than `private`, which feels slightly backwards.<br></p><p>But I don’t want to dabble too much about it. If its the way it’s going to be, so be it.<br></p><p>&gt; On 29 Jun 2016, at 15:11, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; There is nothing preventing you from using fileprivate if you want to write your code in this style.  At most you can complain that you don&#39;t like the new keyword.  But you&#39;re not losing any functionality so I don&#39;t understand why you say you are &quot;missing&quot; something.<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Jun 29, 2016, at 1:25 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 29 Jun 2016, at 04:03, Matthew Judge &lt;matthew.judge at gmail.com &lt;mailto:matthew.judge at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If I understand SE-0025 (even with the amendment) you can still spell the access modifier to types as &#39;private&#39; and get the same characteristics as the pre-SE-0025 meaning or private, so I&#39;m not sure I understand the concern here. However (continued below)<br>&gt;&gt; <br>&gt;&gt; The characteristic I will be missing is for the following style of writing:<br>&gt;&gt; <br>&gt;&gt; class MyViewController : UIViewController {<br>&gt;&gt;     private var privateInfo: String?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; //MARK: Public<br>&gt;&gt; <br>&gt;&gt; public extension MyViewController {<br>&gt;&gt;     func publicFunction() {<br>&gt;&gt;         // CAN’T ACCESS privateInfo<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; //MARK: UITableViewDataSource<br>&gt;&gt; <br>&gt;&gt; private extension MyViewController : UITableViewDataSource {<br>&gt;&gt;     func numberOfRowsInSection(_ section: Int) -&gt; Int<br>&gt;&gt;         // CAN’T ACCESS privateInfo<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; //MARK: Private<br>&gt;&gt; <br>&gt;&gt; private extension MyViewController {<br>&gt;&gt;     func implementationFunction() {<br>&gt;&gt;         // CAN’T ACCESS privateInfo<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/9b9f56a6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 10:08 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; Sorry if I wasn’t expressing myself well enough. In my original email, I said that:<br>&gt; <br>&gt; &gt; The new rules make `private` more prominent compared to `fileprivate` (the latter has a somewhat worse name).<br>&gt; <br>&gt; So I agree that my issue is more with the naming than the functionality. I’m mainly complaining that because of its name, `fileprivate` feels like more of a special corner case of `private`. But in the style of writing types through extensions, `fileprivate` will become much more prevalent than `private`, which feels slightly backwards.<br></p><p>I don’t view it as more of a special corner case at all, but I can see why you feel that way since it has an unprecedented (AFAIK) and more verbose name.  <br></p><p>The proposal originally left `private` alone and used a new name for the new access level.  We weren’t able to find a name that didn’t have problems which led to the idea of renaming the existing `private`.<br></p><p>My perspective is that it’s just the best name we could come up with for the concept in the context of the various access levels we want to support.  The name isn’t intended to discourage use in any way.  <br></p><p>&gt; <br>&gt; But I don’t want to dabble too much about it. If its the way it’s going to be, so be it.<br>&gt; <br>&gt;&gt; On 29 Jun 2016, at 15:11, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There is nothing preventing you from using fileprivate if you want to write your code in this style.  At most you can complain that you don&#39;t like the new keyword.  But you&#39;re not losing any functionality so I don&#39;t understand why you say you are &quot;missing&quot; something.<br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On Jun 29, 2016, at 1:25 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 29 Jun 2016, at 04:03, Matthew Judge &lt;matthew.judge at gmail.com &lt;mailto:matthew.judge at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If I understand SE-0025 (even with the amendment) you can still spell the access modifier to types as &#39;private&#39; and get the same characteristics as the pre-SE-0025 meaning or private, so I&#39;m not sure I understand the concern here. However (continued below)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The characteristic I will be missing is for the following style of writing:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class MyViewController : UIViewController {<br>&gt;&gt;&gt;     private var privateInfo: String?<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //MARK: Public<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public extension MyViewController {<br>&gt;&gt;&gt;     func publicFunction() {<br>&gt;&gt;&gt;         // CAN’T ACCESS privateInfo<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //MARK: UITableViewDataSource<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private extension MyViewController : UITableViewDataSource {<br>&gt;&gt;&gt;     func numberOfRowsInSection(_ section: Int) -&gt; Int<br>&gt;&gt;&gt;         // CAN’T ACCESS privateInfo<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //MARK: Private<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private extension MyViewController {<br>&gt;&gt;&gt;     func implementationFunction() {<br>&gt;&gt;&gt;         // CAN’T ACCESS privateInfo<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/606d826e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June 29, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 10:22 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 10:08 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sorry if I wasn’t expressing myself well enough. In my original email, I said that:<br>&gt;&gt; <br>&gt;&gt; &gt; The new rules make `private` more prominent compared to `fileprivate` (the latter has a somewhat worse name).<br>&gt;&gt; <br>&gt;&gt; So I agree that my issue is more with the naming than the functionality. I’m mainly complaining that because of its name, `fileprivate` feels like more of a special corner case of `private`. But in the style of writing types through extensions, `fileprivate` will become much more prevalent than `private`, which feels slightly backwards.<br>&gt; <br>&gt; I don’t view it as more of a special corner case at all, but I can see why you feel that way since it has an unprecedented (AFAIK) and more verbose name.  <br>&gt; <br>&gt; The proposal originally left `private` alone and used a new name for the new access level.  We weren’t able to find a name that didn’t have problems which led to the idea of renaming the existing `private`.<br>&gt; <br>&gt; My perspective is that it’s just the best name we could come up with for the concept in the context of the various access levels we want to support.  The name isn’t intended to discourage use in any way.  <br></p><p>It may not be intended, but that doesn’t mean it won’t, though. :P<br></p><p>I can’t say exactly *why*, but I feel similar to David here in that “fileprivate” is such an… odd… name that I’m inclined to just not use it and let things default to “internal” instead. In fact, I have *already* caught myself doing this. I don’t know if that’s *bad* exactly (would more things being internal actually aid the compiler/optimizer?), but I think this is a valid concern. The issue here is rooted in psychology, not technology. :/<br></p><p>l8r<br>Sean<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 10:46 AM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 29, 2016, at 10:22 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 10:08 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry if I wasn’t expressing myself well enough. In my original email, I said that:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The new rules make `private` more prominent compared to `fileprivate` (the latter has a somewhat worse name).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So I agree that my issue is more with the naming than the functionality. I’m mainly complaining that because of its name, `fileprivate` feels like more of a special corner case of `private`. But in the style of writing types through extensions, `fileprivate` will become much more prevalent than `private`, which feels slightly backwards.<br>&gt;&gt; <br>&gt;&gt; I don’t view it as more of a special corner case at all, but I can see why you feel that way since it has an unprecedented (AFAIK) and more verbose name.  <br>&gt;&gt; <br>&gt;&gt; The proposal originally left `private` alone and used a new name for the new access level.  We weren’t able to find a name that didn’t have problems which led to the idea of renaming the existing `private`.<br>&gt;&gt; <br>&gt;&gt; My perspective is that it’s just the best name we could come up with for the concept in the context of the various access levels we want to support.  The name isn’t intended to discourage use in any way.  <br>&gt; <br>&gt; It may not be intended, but that doesn’t mean it won’t, though. :P<br>&gt; <br>&gt; I can’t say exactly *why*, but I feel similar to David here in that “fileprivate” is such an… odd… name that I’m inclined to just not use it and let things default to “internal” instead. In fact, I have *already* caught myself doing this. I don’t know if that’s *bad* exactly (would more things being internal actually aid the compiler/optimizer?),<br></p><p>I’m pretty sure more things being internal will not help the optimizer.  In fact, if you are not compiling with WMO turned on it could prevent optimizations.<br></p><p>&gt; but I think this is a valid concern. The issue here is rooted in psychology, not technology. :/<br></p><p>That’s a fair perspective.  But a *significant* amount of time was spent bike shedding this.  I’m not sure whether you and David participated or not, but that was the time to have the naming discussion.<br></p><p>IMO the value of having more control over visibility far outweighs a slightly awkward name for file level visibility.  I don’t think it’s anywhere near awkward enough to avoid, but I suppose YMMV.<br></p><p>&gt; <br>&gt; l8r<br>&gt; Sean<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/b436ee94/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 10:00:00am</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 10:52 AM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jun 29, 2016, at 10:46 AM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jun 29, 2016, at 10:22 AM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jun 29, 2016, at 10:08 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;<br>&gt; Sorry if I wasn’t expressing myself well enough. In my original email, I<br>&gt; said that:<br>&gt;<br>&gt; The new rules make `private` more prominent compared to `fileprivate` (the<br>&gt; latter has a somewhat worse name).<br>&gt;<br>&gt;<br>&gt; So I agree that my issue is more with the naming than the functionality.<br>&gt; I’m mainly complaining that because of its name, `fileprivate` feels like<br>&gt; more of a special corner case of `private`. But in the style of writing<br>&gt; types through extensions, `fileprivate` will become much more prevalent<br>&gt; than `private`, which feels slightly backwards.<br>&gt;<br>&gt;<br>&gt; I don’t view it as more of a special corner case at all, but I can see why<br>&gt; you feel that way since it has an unprecedented (AFAIK) and more verbose<br>&gt; name.<br>&gt;<br>&gt; The proposal originally left `private` alone and used a new name for the<br>&gt; new access level.  We weren’t able to find a name that didn’t have problems<br>&gt; which led to the idea of renaming the existing `private`.<br>&gt;<br>&gt; My perspective is that it’s just the best name we could come up with for<br>&gt; the concept in the context of the various access levels we want to<br>&gt; support.  The name isn’t intended to discourage use in any way.<br>&gt;<br>&gt;<br>&gt; It may not be intended, but that doesn’t mean it won’t, though. :P<br>&gt;<br>&gt; I can’t say exactly *why*, but I feel similar to David here in that<br>&gt; “fileprivate” is such an… odd… name that I’m inclined to just not use it<br>&gt; and let things default to “internal” instead. In fact, I have *already*<br>&gt; caught myself doing this. I don’t know if that’s *bad* exactly (would more<br>&gt; things being internal actually aid the compiler/optimizer?),<br>&gt;<br>&gt;<br>&gt; I’m pretty sure more things being internal will not help the optimizer.<br>&gt; In fact, if you are not compiling with WMO turned on it could prevent<br>&gt; optimizations.<br>&gt;<br>&gt; but I think this is a valid concern. The issue here is rooted in<br>&gt; psychology, not technology. :/<br>&gt;<br>&gt;<br>&gt; That’s a fair perspective.  But a *significant* amount of time was spent<br>&gt; bike shedding this.  I’m not sure whether you and David participated or<br>&gt; not, but that was the time to have the naming discussion.<br>&gt;<br></p><p>I think the case being made here is that `fileprivate` was settled on when<br>it was thought that it would be rarely used. With what&#39;s emerged in this<br>discussion, it turns out that `fileprivate` might be more useful than<br>previously thought, and the awkwardness of the name therefore is more<br>troublesome than when the naming discussion first took place.<br></p><p><br>&gt; IMO the value of having more control over visibility far outweighs a<br>&gt; slightly awkward name for file level visibility.  I don’t think it’s<br>&gt; anywhere near awkward enough to avoid, but I suppose YMMV.<br>&gt;<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/5812d9f6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 10:55 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 29, 2016 at 10:52 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;wrote:<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 10:46 AM, Sean Heber &lt;sean at fifthace.com &lt;mailto:sean at fifthace.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 10:22 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 10:08 AM, David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sorry if I wasn’t expressing myself well enough. In my original email, I said that:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The new rules make `private` more prominent compared to `fileprivate` (the latter has a somewhat worse name).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So I agree that my issue is more with the naming than the functionality. I’m mainly complaining that because of its name, `fileprivate` feels like more of a special corner case of `private`. But in the style of writing types through extensions, `fileprivate` will become much more prevalent than `private`, which feels slightly backwards.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t view it as more of a special corner case at all, but I can see why you feel that way since it has an unprecedented (AFAIK) and more verbose name.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal originally left `private` alone and used a new name for the new access level.  We weren’t able to find a name that didn’t have problems which led to the idea of renaming the existing `private`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My perspective is that it’s just the best name we could come up with for the concept in the context of the various access levels we want to support.  The name isn’t intended to discourage use in any way.  <br>&gt;&gt; <br>&gt;&gt; It may not be intended, but that doesn’t mean it won’t, though. :P<br>&gt;&gt; <br>&gt;&gt; I can’t say exactly *why*, but I feel similar to David here in that “fileprivate” is such an… odd… name that I’m inclined to just not use it and let things default to “internal” instead. In fact, I have *already* caught myself doing this. I don’t know if that’s *bad* exactly (would more things being internal actually aid the compiler/optimizer?), <br>&gt; <br>&gt; I’m pretty sure more things being internal will not help the optimizer.  In fact, if you are not compiling with WMO turned on it could prevent optimizations.<br>&gt; <br>&gt;&gt; but I think this is a valid concern. The issue here is rooted in psychology, not technology. :/<br>&gt; <br>&gt; That’s a fair perspective.  But a *significant* amount of time was spent bike shedding this.  I’m not sure whether you and David participated or not, but that was the time to have the naming discussion.<br>&gt; <br>&gt; I think the case being made here is that `fileprivate` was settled on when it was thought that it would be rarely used. With what&#39;s emerged in this discussion, it turns out that `fileprivate` might be more useful than previously thought, and the awkwardness of the name therefore is more troublesome than when the naming discussion first took place.<br></p><p>The example in this thread (placing data members in the type declaration and methods in extensions) is one that received ample discussion during the earlier threads and the review.<br></p><p>I don’t know that `fileprivate` will be used in code more commonly than previously thought.  The issue is about the default access level of members inside a `private` type (i.e. when access is *not* directly specified).  With Jordan’s proposed solution, `fileprivate` will be used to describe these members in documentation and diagnostics.  <br></p><p>It will also be possible to state this default explicitly, but I don’t think that will be too common.  This is the only change in what is possible to do *in code* from the original proposal.<br></p><p>&gt; <br>&gt; <br>&gt; IMO the value of having more control over visibility far outweighs a slightly awkward name for file level visibility.  I don’t think it’s anywhere near awkward enough to avoid, but I suppose YMMV.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/4d66e836/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 11:00:00am</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 11:03 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jun 29, 2016, at 10:55 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Jun 29, 2016 at 10:52 AM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 29, 2016, at 10:46 AM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 29, 2016, at 10:22 AM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 29, 2016, at 10:08 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Sorry if I wasn’t expressing myself well enough. In my original email, I<br>&gt;&gt; said that:<br>&gt;&gt;<br>&gt;&gt; The new rules make `private` more prominent compared to `fileprivate`<br>&gt;&gt; (the latter has a somewhat worse name).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; So I agree that my issue is more with the naming than the functionality.<br>&gt;&gt; I’m mainly complaining that because of its name, `fileprivate` feels like<br>&gt;&gt; more of a special corner case of `private`. But in the style of writing<br>&gt;&gt; types through extensions, `fileprivate` will become much more prevalent<br>&gt;&gt; than `private`, which feels slightly backwards.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don’t view it as more of a special corner case at all, but I can see<br>&gt;&gt; why you feel that way since it has an unprecedented (AFAIK) and more<br>&gt;&gt; verbose name.<br>&gt;&gt;<br>&gt;&gt; The proposal originally left `private` alone and used a new name for the<br>&gt;&gt; new access level.  We weren’t able to find a name that didn’t have problems<br>&gt;&gt; which led to the idea of renaming the existing `private`.<br>&gt;&gt;<br>&gt;&gt; My perspective is that it’s just the best name we could come up with for<br>&gt;&gt; the concept in the context of the various access levels we want to<br>&gt;&gt; support.  The name isn’t intended to discourage use in any way.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It may not be intended, but that doesn’t mean it won’t, though. :P<br>&gt;&gt;<br>&gt;&gt; I can’t say exactly *why*, but I feel similar to David here in that<br>&gt;&gt; “fileprivate” is such an… odd… name that I’m inclined to just not use it<br>&gt;&gt; and let things default to “internal” instead. In fact, I have *already*<br>&gt;&gt; caught myself doing this. I don’t know if that’s *bad* exactly (would more<br>&gt;&gt; things being internal actually aid the compiler/optimizer?),<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I’m pretty sure more things being internal will not help the optimizer.<br>&gt;&gt; In fact, if you are not compiling with WMO turned on it could prevent<br>&gt;&gt; optimizations.<br>&gt;&gt;<br>&gt;&gt; but I think this is a valid concern. The issue here is rooted in<br>&gt;&gt; psychology, not technology. :/<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That’s a fair perspective.  But a *significant* amount of time was spent<br>&gt;&gt; bike shedding this.  I’m not sure whether you and David participated or<br>&gt;&gt; not, but that was the time to have the naming discussion.<br>&gt;&gt;<br>&gt;<br>&gt; I think the case being made here is that `fileprivate` was settled on when<br>&gt; it was thought that it would be rarely used. With what&#39;s emerged in this<br>&gt; discussion, it turns out that `fileprivate` might be more useful than<br>&gt; previously thought, and the awkwardness of the name therefore is more<br>&gt; troublesome than when the naming discussion first took place.<br>&gt;<br>&gt;<br>&gt; The example in this thread (placing data members in the type declaration<br>&gt; and methods in extensions) is one that received ample discussion during the<br>&gt; earlier threads and the review.<br>&gt;<br>&gt; I don’t know that `fileprivate` will be used in code more commonly than<br>&gt; previously thought.  The issue is about the default access level of members<br>&gt; inside a `private` type (i.e. when access is *not* directly specified).<br>&gt; With Jordan’s proposed solution, `fileprivate` will be used to describe<br>&gt; these members in documentation and diagnostics.<br>&gt;<br>&gt; It will also be possible to state this default explicitly, but I don’t<br>&gt; think that will be too common.  This is the only change in what is possible<br>&gt; to do *in code* from the original proposal.<br>&gt;<br></p><p>You&#39;re adding words to my argument that I didn&#39;t put there. I didn&#39;t<br>specify &quot;in code&quot;. Awkward is awkward, in code or in documentation.<br></p><p><br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; IMO the value of having more control over visibility far outweighs a<br>&gt;&gt; slightly awkward name for file level visibility.  I don’t think it’s<br>&gt;&gt; anywhere near awkward enough to avoid, but I suppose YMMV.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/69371f91/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 11:06 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 29, 2016 at 11:03 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 10:55 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 29, 2016 at 10:52 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 10:46 AM, Sean Heber &lt;sean at fifthace.com &lt;mailto:sean at fifthace.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 10:22 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 10:08 AM, David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sorry if I wasn’t expressing myself well enough. In my original email, I said that:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The new rules make `private` more prominent compared to `fileprivate` (the latter has a somewhat worse name).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So I agree that my issue is more with the naming than the functionality. I’m mainly complaining that because of its name, `fileprivate` feels like more of a special corner case of `private`. But in the style of writing types through extensions, `fileprivate` will become much more prevalent than `private`, which feels slightly backwards.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t view it as more of a special corner case at all, but I can see why you feel that way since it has an unprecedented (AFAIK) and more verbose name.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The proposal originally left `private` alone and used a new name for the new access level.  We weren’t able to find a name that didn’t have problems which led to the idea of renaming the existing `private`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My perspective is that it’s just the best name we could come up with for the concept in the context of the various access levels we want to support.  The name isn’t intended to discourage use in any way.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It may not be intended, but that doesn’t mean it won’t, though. :P<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can’t say exactly *why*, but I feel similar to David here in that “fileprivate” is such an… odd… name that I’m inclined to just not use it and let things default to “internal” instead. In fact, I have *already* caught myself doing this. I don’t know if that’s *bad* exactly (would more things being internal actually aid the compiler/optimizer?), <br>&gt;&gt; <br>&gt;&gt; I’m pretty sure more things being internal will not help the optimizer.  In fact, if you are not compiling with WMO turned on it could prevent optimizations.<br>&gt;&gt; <br>&gt;&gt;&gt; but I think this is a valid concern. The issue here is rooted in psychology, not technology. :/<br>&gt;&gt; <br>&gt;&gt; That’s a fair perspective.  But a *significant* amount of time was spent bike shedding this.  I’m not sure whether you and David participated or not, but that was the time to have the naming discussion.<br>&gt;&gt; <br>&gt;&gt; I think the case being made here is that `fileprivate` was settled on when it was thought that it would be rarely used. With what&#39;s emerged in this discussion, it turns out that `fileprivate` might be more useful than previously thought, and the awkwardness of the name therefore is more troublesome than when the naming discussion first took place.<br>&gt; <br>&gt; The example in this thread (placing data members in the type declaration and methods in extensions) is one that received ample discussion during the earlier threads and the review.<br>&gt; <br>&gt; I don’t know that `fileprivate` will be used in code more commonly than previously thought.  The issue is about the default access level of members inside a `private` type (i.e. when access is *not* directly specified).  With Jordan’s proposed solution, `fileprivate` will be used to describe these members in documentation and diagnostics.  <br>&gt; <br>&gt; It will also be possible to state this default explicitly, but I don’t think that will be too common.  This is the only change in what is possible to do *in code* from the original proposal.<br>&gt; <br>&gt; You&#39;re adding words to my argument that I didn&#39;t put there. I didn&#39;t specify &quot;in code&quot;. Awkward is awkward, in code or in documentation.<br></p><p>That wasn’t intentional, sorry.  I misunderstood and thought you meant it would be used more frequently in code than previously thought.  Thanks for clarifying.<br></p><p>I certainly don’t oppose a better name if anyone can suggest one that is clearly better.  But I am skeptical that this is possible given the amount of bike shedding that has already happened.<br></p><p>&gt;  <br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; IMO the value of having more control over visibility far outweighs a slightly awkward name for file level visibility.  I don’t think it’s anywhere near awkward enough to avoid, but I suppose YMMV.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; l8r<br>&gt;&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/fe6777d8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 29, 2016 at 09:00:00am</p></header><div class="content"><p>I just want a name that is:<br></p><p>- a single English language word<br>- whose common meaning has something to do with privacy, access,<br>permissions, or a similar grouping concept that the other three keywords<br>fits into<br>- and intuitively describes the intensity of the behavior relative to the<br>other three keywords<br></p><p>I&#39;m not sure if this is something we want to reopen, though, or what the<br>right process would be.<br></p><p>Austin<br></p><p>On Wed, Jun 29, 2016 at 9:10 AM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jun 29, 2016, at 11:06 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Jun 29, 2016 at 11:03 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 29, 2016, at 10:55 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Wed, Jun 29, 2016 at 10:52 AM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jun 29, 2016, at 10:46 AM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jun 29, 2016, at 10:22 AM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jun 29, 2016, at 10:08 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sorry if I wasn’t expressing myself well enough. In my original email, I<br>&gt;&gt;&gt; said that:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The new rules make `private` more prominent compared to `fileprivate`<br>&gt;&gt;&gt; (the latter has a somewhat worse name).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So I agree that my issue is more with the naming than the functionality.<br>&gt;&gt;&gt; I’m mainly complaining that because of its name, `fileprivate` feels like<br>&gt;&gt;&gt; more of a special corner case of `private`. But in the style of writing<br>&gt;&gt;&gt; types through extensions, `fileprivate` will become much more prevalent<br>&gt;&gt;&gt; than `private`, which feels slightly backwards.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don’t view it as more of a special corner case at all, but I can see<br>&gt;&gt;&gt; why you feel that way since it has an unprecedented (AFAIK) and more<br>&gt;&gt;&gt; verbose name.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The proposal originally left `private` alone and used a new name for the<br>&gt;&gt;&gt; new access level.  We weren’t able to find a name that didn’t have problems<br>&gt;&gt;&gt; which led to the idea of renaming the existing `private`.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; My perspective is that it’s just the best name we could come up with for<br>&gt;&gt;&gt; the concept in the context of the various access levels we want to<br>&gt;&gt;&gt; support.  The name isn’t intended to discourage use in any way.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It may not be intended, but that doesn’t mean it won’t, though. :P<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I can’t say exactly *why*, but I feel similar to David here in that<br>&gt;&gt;&gt; “fileprivate” is such an… odd… name that I’m inclined to just not use it<br>&gt;&gt;&gt; and let things default to “internal” instead. In fact, I have *already*<br>&gt;&gt;&gt; caught myself doing this. I don’t know if that’s *bad* exactly (would more<br>&gt;&gt;&gt; things being internal actually aid the compiler/optimizer?),<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’m pretty sure more things being internal will not help the optimizer.<br>&gt;&gt;&gt; In fact, if you are not compiling with WMO turned on it could prevent<br>&gt;&gt;&gt; optimizations.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; but I think this is a valid concern. The issue here is rooted in<br>&gt;&gt;&gt; psychology, not technology. :/<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That’s a fair perspective.  But a *significant* amount of time was spent<br>&gt;&gt;&gt; bike shedding this.  I’m not sure whether you and David participated or<br>&gt;&gt;&gt; not, but that was the time to have the naming discussion.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I think the case being made here is that `fileprivate` was settled on<br>&gt;&gt; when it was thought that it would be rarely used. With what&#39;s emerged in<br>&gt;&gt; this discussion, it turns out that `fileprivate` might be more useful than<br>&gt;&gt; previously thought, and the awkwardness of the name therefore is more<br>&gt;&gt; troublesome than when the naming discussion first took place.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The example in this thread (placing data members in the type declaration<br>&gt;&gt; and methods in extensions) is one that received ample discussion during the<br>&gt;&gt; earlier threads and the review.<br>&gt;&gt;<br>&gt;&gt; I don’t know that `fileprivate` will be used in code more commonly than<br>&gt;&gt; previously thought.  The issue is about the default access level of members<br>&gt;&gt; inside a `private` type (i.e. when access is *not* directly specified).<br>&gt;&gt; With Jordan’s proposed solution, `fileprivate` will be used to describe<br>&gt;&gt; these members in documentation and diagnostics.<br>&gt;&gt;<br>&gt;&gt; It will also be possible to state this default explicitly, but I don’t<br>&gt;&gt; think that will be too common.  This is the only change in what is possible<br>&gt;&gt; to do *in code* from the original proposal.<br>&gt;&gt;<br>&gt;<br>&gt; You&#39;re adding words to my argument that I didn&#39;t put there. I didn&#39;t<br>&gt; specify &quot;in code&quot;. Awkward is awkward, in code or in documentation.<br>&gt;<br>&gt;<br>&gt; That wasn’t intentional, sorry.  I misunderstood and thought you meant it<br>&gt; would be used more frequently in code than previously thought.  Thanks for<br>&gt; clarifying.<br>&gt;<br>&gt; I certainly don’t oppose a better name if anyone can suggest one that is<br>&gt; clearly better.  But I am skeptical that this is possible given the amount<br>&gt; of bike shedding that has already happened.<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; IMO the value of having more control over visibility far outweighs a<br>&gt;&gt;&gt; slightly awkward name for file level visibility.  I don’t think it’s<br>&gt;&gt;&gt; anywhere near awkward enough to avoid, but I suppose YMMV.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; l8r<br>&gt;&gt;&gt; Sean<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/f020127c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 11:00:00am</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 11:14 AM, Austin Zheng &lt;austinzheng at gmail.com&gt;<br>wrote:<br></p><p>&gt; I just want a name that is:<br>&gt;<br>&gt; - a single English language word<br>&gt; - whose common meaning has something to do with privacy, access,<br>&gt; permissions, or a similar grouping concept that the other three keywords<br>&gt; fits into<br>&gt; - and intuitively describes the intensity of the behavior relative to the<br>&gt; other three keywords<br>&gt;<br>&gt; I&#39;m not sure if this is something we want to reopen, though, or what the<br>&gt; right process would be.<br>&gt;<br></p><p>Right. I agree with your criteria and your doubts about how to reopen the<br>topic. I&#39;d offer that what&#39;s definitely not the right process is continuing<br>in this thread :)<br></p><p><br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Wed, Jun 29, 2016 at 9:10 AM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 29, 2016, at 11:06 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Wed, Jun 29, 2016 at 11:03 AM, Matthew Johnson &lt;matthew at anandabits.com<br>&gt;&gt; &gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jun 29, 2016, at 10:55 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Jun 29, 2016 at 10:52 AM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt;wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 10:46 AM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 10:22 AM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 10:08 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Sorry if I wasn’t expressing myself well enough. In my original email,<br>&gt;&gt;&gt;&gt; I said that:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The new rules make `private` more prominent compared to `fileprivate`<br>&gt;&gt;&gt;&gt; (the latter has a somewhat worse name).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; So I agree that my issue is more with the naming than the<br>&gt;&gt;&gt;&gt; functionality. I’m mainly complaining that because of its name,<br>&gt;&gt;&gt;&gt; `fileprivate` feels like more of a special corner case of `private`. But in<br>&gt;&gt;&gt;&gt; the style of writing types through extensions, `fileprivate` will become<br>&gt;&gt;&gt;&gt; much more prevalent than `private`, which feels slightly backwards.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I don’t view it as more of a special corner case at all, but I can see<br>&gt;&gt;&gt;&gt; why you feel that way since it has an unprecedented (AFAIK) and more<br>&gt;&gt;&gt;&gt; verbose name.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The proposal originally left `private` alone and used a new name for<br>&gt;&gt;&gt;&gt; the new access level.  We weren’t able to find a name that didn’t have<br>&gt;&gt;&gt;&gt; problems which led to the idea of renaming the existing `private`.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; My perspective is that it’s just the best name we could come up with<br>&gt;&gt;&gt;&gt; for the concept in the context of the various access levels we want to<br>&gt;&gt;&gt;&gt; support.  The name isn’t intended to discourage use in any way.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It may not be intended, but that doesn’t mean it won’t, though. :P<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I can’t say exactly *why*, but I feel similar to David here in that<br>&gt;&gt;&gt;&gt; “fileprivate” is such an… odd… name that I’m inclined to just not use it<br>&gt;&gt;&gt;&gt; and let things default to “internal” instead. In fact, I have *already*<br>&gt;&gt;&gt;&gt; caught myself doing this. I don’t know if that’s *bad* exactly (would more<br>&gt;&gt;&gt;&gt; things being internal actually aid the compiler/optimizer?),<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I’m pretty sure more things being internal will not help the<br>&gt;&gt;&gt;&gt; optimizer.  In fact, if you are not compiling with WMO turned on it could<br>&gt;&gt;&gt;&gt; prevent optimizations.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; but I think this is a valid concern. The issue here is rooted in<br>&gt;&gt;&gt;&gt; psychology, not technology. :/<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That’s a fair perspective.  But a *significant* amount of time was<br>&gt;&gt;&gt;&gt; spent bike shedding this.  I’m not sure whether you and David participated<br>&gt;&gt;&gt;&gt; or not, but that was the time to have the naming discussion.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think the case being made here is that `fileprivate` was settled on<br>&gt;&gt;&gt; when it was thought that it would be rarely used. With what&#39;s emerged in<br>&gt;&gt;&gt; this discussion, it turns out that `fileprivate` might be more useful than<br>&gt;&gt;&gt; previously thought, and the awkwardness of the name therefore is more<br>&gt;&gt;&gt; troublesome than when the naming discussion first took place.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The example in this thread (placing data members in the type declaration<br>&gt;&gt;&gt; and methods in extensions) is one that received ample discussion during the<br>&gt;&gt;&gt; earlier threads and the review.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don’t know that `fileprivate` will be used in code more commonly than<br>&gt;&gt;&gt; previously thought.  The issue is about the default access level of members<br>&gt;&gt;&gt; inside a `private` type (i.e. when access is *not* directly specified).<br>&gt;&gt;&gt; With Jordan’s proposed solution, `fileprivate` will be used to describe<br>&gt;&gt;&gt; these members in documentation and diagnostics.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It will also be possible to state this default explicitly, but I don’t<br>&gt;&gt;&gt; think that will be too common.  This is the only change in what is possible<br>&gt;&gt;&gt; to do *in code* from the original proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; You&#39;re adding words to my argument that I didn&#39;t put there. I didn&#39;t<br>&gt;&gt; specify &quot;in code&quot;. Awkward is awkward, in code or in documentation.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That wasn’t intentional, sorry.  I misunderstood and thought you meant it<br>&gt;&gt; would be used more frequently in code than previously thought.  Thanks for<br>&gt;&gt; clarifying.<br>&gt;&gt;<br>&gt;&gt; I certainly don’t oppose a better name if anyone can suggest one that is<br>&gt;&gt; clearly better.  But I am skeptical that this is possible given the amount<br>&gt;&gt; of bike shedding that has already happened.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; IMO the value of having more control over visibility far outweighs a<br>&gt;&gt;&gt;&gt; slightly awkward name for file level visibility.  I don’t think it’s<br>&gt;&gt;&gt;&gt; anywhere near awkward enough to avoid, but I suppose YMMV.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; l8r<br>&gt;&gt;&gt;&gt; Sean<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/bf493385/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 11:14 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; I just want a name that is:<br>&gt; <br>&gt; - a single English language word<br>&gt; - whose common meaning has something to do with privacy, access, permissions, or a similar grouping concept that the other three keywords fits into <br>&gt; - and intuitively describes the intensity of the behavior relative to the other three keywords<br></p><p>I think everyone would like that.  But nobody has been able to come up with a word that doesn’t have problems of one kind or another (for the new access level or for the file access level).<br></p><p>&gt; <br>&gt; I&#39;m not sure if this is something we want to reopen, though, or what the right process would be.<br></p><p>This has received a vast amount of bike shedding already.  I would like to see us continue with the implementation of SE-0025.  If anyone thinks they have found a way to improve the naming a new proposal can be put forward.  If an obviously better name is suggested I will support such a proposal enthusiastically!<br></p><p>&gt; <br>&gt; Austin<br>&gt; <br>&gt; On Wed, Jun 29, 2016 at 9:10 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 11:06 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 29, 2016 at 11:03 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 10:55 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jun 29, 2016 at 10:52 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 10:46 AM, Sean Heber &lt;sean at fifthace.com &lt;mailto:sean at fifthace.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 10:22 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 10:08 AM, David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sorry if I wasn’t expressing myself well enough. In my original email, I said that:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The new rules make `private` more prominent compared to `fileprivate` (the latter has a somewhat worse name).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So I agree that my issue is more with the naming than the functionality. I’m mainly complaining that because of its name, `fileprivate` feels like more of a special corner case of `private`. But in the style of writing types through extensions, `fileprivate` will become much more prevalent than `private`, which feels slightly backwards.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don’t view it as more of a special corner case at all, but I can see why you feel that way since it has an unprecedented (AFAIK) and more verbose name.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The proposal originally left `private` alone and used a new name for the new access level.  We weren’t able to find a name that didn’t have problems which led to the idea of renaming the existing `private`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My perspective is that it’s just the best name we could come up with for the concept in the context of the various access levels we want to support.  The name isn’t intended to discourage use in any way.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It may not be intended, but that doesn’t mean it won’t, though. :P<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I can’t say exactly *why*, but I feel similar to David here in that “fileprivate” is such an… odd… name that I’m inclined to just not use it and let things default to “internal” instead. In fact, I have *already* caught myself doing this. I don’t know if that’s *bad* exactly (would more things being internal actually aid the compiler/optimizer?), <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m pretty sure more things being internal will not help the optimizer.  In fact, if you are not compiling with WMO turned on it could prevent optimizations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; but I think this is a valid concern. The issue here is rooted in psychology, not technology. :/<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s a fair perspective.  But a *significant* amount of time was spent bike shedding this.  I’m not sure whether you and David participated or not, but that was the time to have the naming discussion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the case being made here is that `fileprivate` was settled on when it was thought that it would be rarely used. With what&#39;s emerged in this discussion, it turns out that `fileprivate` might be more useful than previously thought, and the awkwardness of the name therefore is more troublesome than when the naming discussion first took place.<br>&gt;&gt; <br>&gt;&gt; The example in this thread (placing data members in the type declaration and methods in extensions) is one that received ample discussion during the earlier threads and the review.<br>&gt;&gt; <br>&gt;&gt; I don’t know that `fileprivate` will be used in code more commonly than previously thought.  The issue is about the default access level of members inside a `private` type (i.e. when access is *not* directly specified).  With Jordan’s proposed solution, `fileprivate` will be used to describe these members in documentation and diagnostics.  <br>&gt;&gt; <br>&gt;&gt; It will also be possible to state this default explicitly, but I don’t think that will be too common.  This is the only change in what is possible to do *in code* from the original proposal.<br>&gt;&gt; <br>&gt;&gt; You&#39;re adding words to my argument that I didn&#39;t put there. I didn&#39;t specify &quot;in code&quot;. Awkward is awkward, in code or in documentation.<br>&gt; <br>&gt; That wasn’t intentional, sorry.  I misunderstood and thought you meant it would be used more frequently in code than previously thought.  Thanks for clarifying.<br>&gt; <br>&gt; I certainly don’t oppose a better name if anyone can suggest one that is clearly better.  But I am skeptical that this is possible given the amount of bike shedding that has already happened.<br>&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO the value of having more control over visibility far outweighs a slightly awkward name for file level visibility.  I don’t think it’s anywhere near awkward enough to avoid, but I suppose YMMV.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; l8r<br>&gt;&gt;&gt;&gt; Sean<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/f03bd462/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 29, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 9:14, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I just want a name that is:<br>&gt; <br>&gt; - a single English language word<br>&gt; - whose common meaning has something to do with privacy, access, permissions, or a similar grouping concept that the other three keywords fits into <br>&gt; - and intuitively describes the intensity of the behavior relative to the other three keywords<br>&gt; <br>&gt; I&#39;m not sure if this is something we want to reopen, though, or what the right process would be.<br>&gt; <br>&gt; Austin<br></p><p>At this point I would suggest that a new proposal add a synonym for &#39;fileprivate&#39; in release X, with a plan to deprecate (warn on) &#39;fileprivate&#39; in release X+1. X should also be greater than 3 because we&#39;re honestly still burned from the last discussion and bikeshedding, and the name would have to be significantly better than &quot;fileprivate&quot; to even go up for review.<br></p><p>We tried to come up with something good; this was the one the core team thought was the best choice. Sometimes that&#39;s how it goes (cf. &quot;static&quot;/&quot;class&quot;, &quot;associatedtype&quot;).<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/86b3775b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 15, 2016 at 01:00:00pm</p></header><div class="content"><p>On Wed, Jun 15, 2016 at 1:37 PM, Robert Widmann via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The scope of the *declaration* is not the issue.  The scope of its<br>&gt; *members* is.<br>&gt;<br></p><p>Oy, if we&#39;re to have both `fileprivate` and `private`, then the previously<br>visually appealing rule about maximum visibility of members will have to be<br>a little messy.<br></p><p>IIUC, the problem is this: the current rule is that an internal type can<br>have members that are at most internally visible (not public), and that a<br>private type can have members that are at most privately visible. This is<br>nice and tidy because in all cases, the declaration and the members it<br>encloses are always in the same module and in the same file. But, with the<br>new meaning of `private`, the top-level declaration is actually in a<br>*different* scope than its members. So, a private type must be allowed to<br>have members that are at most fileprivately visible.<br></p><p><br>&gt; ~Robert Widmann<br>&gt;<br>&gt; 2016/06/15 11:36、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br>&gt;<br>&gt; &gt; The scope for a top-level declaration is the file itself.  This means<br>&gt; that top-level declarations with `private` and `fileprivate` should have<br>&gt; the same behavior.  They should not be uninstantiable or unusable.<br>&gt; &gt;<br>&gt; &gt; -Matthew<br>&gt; &gt;<br>&gt; &gt;&gt; On Jun 15, 2016, at 1:31 PM, Robert Widmann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug<br>&gt; in the proposal.  Under the implementation outlined there, any top-level<br>&gt; structure, class, or enum declared private cannot possibly be instantiated<br>&gt; and so cannot be used in any way.  Because of this, private top-level<br>&gt; declarations are more often than not blown away entirely by the compiler<br>&gt; for being unused.  It seems strange to me to allow a key language feature<br>&gt; to act solely as a hint to the optimizer to reduce the size of your<br>&gt; binary.  Perhaps the restrictions around private needs to be relaxed or the<br>&gt; line between fileprivate and private needs to be investigated again by the<br>&gt; community before inclusion in the language.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Thoughts?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ~Robert Widmann<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/3243e7f3/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 15, 2016 at 08:00:00pm</p></header><div class="content"><p>Shouldn’t it act theoretically something like this:<br></p><p>// Begin file A (which acts like a scope)<br></p><p>// where `type` can be enum, struct, class or protocol<br>private type X {}  <br></p><p>fileprivate type Y {}<br></p><p>public struct Z {<br>     <br>    var x: X<br>    var y: Y<br>}<br>// End file A<br>private should always behave the same as fileprivate on the same scope level of declaration, where fileprivate is accessible from anywhere within the same file no matter in which level it was declared.<br></p><p>// Begin file A (which acts like a scope)<br></p><p>public struct Z {<br>     <br>    fileprivate var a = 0<br>    private var b = &quot;z&quot;<br>}<br></p><p>public struct X {<br>     <br>        static func foo() {<br>             <br>            var z = Z()<br>            z.a // a is visible here<br>            z.b // raises an error because b is not visible from that scope<br>        }<br>}<br>// End file A<br>That how I imagine this to work.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 15. Juni 2016 um 20:32:09, Robert Widmann via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal. Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way. Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused. It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary. Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br></p><p>Thoughts?<br></p><p>~Robert Widmann<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/1f70657b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion] A Problem With SE-0025?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>June 15, 2016 at 11:00:00am</p></header><div class="content"><p>Yes, and it does, and this is not the issue.  The problem is that when we generate the initializer for a private type it is invisible to those outside its scope (which is, by definition, everybody else).  X cannot be initialized and cannot declare any initializer that can possibly be visible because you cannot declare members with a higher access level than their containing declaration.<br></p><p>~Robert Widmann<br></p><p>2016/06/15 11:46、Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; Shouldn’t it act theoretically something like this:<br>&gt; <br>&gt; // Begin file A (which acts like a scope)<br>&gt; <br>&gt; // where `type` can be enum, struct, class or protocol<br>&gt; private type X {}  <br>&gt; <br>&gt; fileprivate type Y {}<br>&gt; <br>&gt; public struct Z {<br>&gt;      <br>&gt;     var x: X<br>&gt;     var y: Y<br>&gt; }<br>&gt; // End file A<br>&gt; private should always behave the same as fileprivate on the same scope level of declaration, where fileprivate is accessible from anywhere within the same file no matter in which level it was declared.<br>&gt; <br>&gt; // Begin file A (which acts like a scope)<br>&gt; <br>&gt; public struct Z {<br>&gt;      <br>&gt;     fileprivate var a = 0<br>&gt;     private var b = &quot;z&quot;<br>&gt; }<br>&gt; <br>&gt; public struct X {<br>&gt;      <br>&gt;         static func foo() {<br>&gt;              <br>&gt;             var z = Z()<br>&gt;             z.a // a is visible here<br>&gt;             z.b // raises an error because b is not visible from that scope<br>&gt;         }<br>&gt; }<br>&gt; // End file A<br>&gt; That how I imagine this to work.<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 15. Juni 2016 um 20:32:09, Robert Widmann via swift-evolution (swift-evolution at swift.org) schrieb:<br>&gt; <br>&gt;&gt; While implementing SE-0025 (fileprivate), I noticed an interesting bug in the proposal. Under the implementation outlined there, any top-level structure, class, or enum declared private cannot possibly be instantiated and so cannot be used in any way. Because of this, private top-level declarations are more often than not blown away entirely by the compiler for being unused. It seems strange to me to allow a key language feature to act solely as a hint to the optimizer to reduce the size of your binary. Perhaps the restrictions around private needs to be relaxed or the line between fileprivate and private needs to be investigated again by the community before inclusion in the language.<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/286f4df7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
