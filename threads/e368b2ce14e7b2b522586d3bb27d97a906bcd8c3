<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>protocol for third-party testing frameworks</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>December 29, 2015 at 10:00:00pm</p></header><div class="content"><p>Rick Ballard has asked for a proposal for third-party testing frameworks:<br></p><p>&gt; Would you mind starting a thread on swift-build-dev at swift.org about your proposal here? I&#39;d love for us to put together a concrete proposal for how we&#39;ll support other test frameworks sooner rather than later – it sounds like you and others would like to get that support added soon!<br>&gt; <br>&gt; FWIW, the main concern I have with the lightweight &quot;just use a main.swift that runs whatever test code you want&quot; approach is that it doesn&#39;t lead to unified test behavior for swift packages. I&#39;d really like package users to be able to rely on being able to run the tests for all their dependencies without needing to manually install other test support first (re: @bppr &#39;s concern), and to get parseable test output in a uniform format, so that tools like a CI dashboard, or a package index that checks package health, can easily be built on top.<br>&gt; <br>&gt; Let&#39;s discuss on-list what sort of protocol we&#39;d need to define to let you easily get up and running with a different test framework while a) making it possible for swiftPM to get all the components it needs to run your tests automatically and b) providing the test output in a uniform format. Thanks!<br></p><p>It doesn&#39;t look like there is a thread yet.<br></p><p>I have some interest in this problem since I have problems such that it isn&#39;t clear whether they can be solved within the mandate of XCTest.  So I am potentially a test framework author, if only as an insurance policy against fixing XCTest to not suck.<br></p><p>I see some places for test framework to innovate, notably:<br></p><p>Parallelization of tests.  Swift language tests use all cores, which is AWESOME.  XCTest does not, which is sad.  But a general-purpose threading model for all software is not clear.  This is a good problem for third-party frameworks to study and try out different things.<br>Configuring what tests are to be performed.  Group them by suites?  Burn-in for 10 minutes, regardless of the number of tests?  Turn off and on tests in the sourcecode?<br>Complex pass/fail conditions.  XCTest is notoriously bad at failing an entire run because of one performance outlier.<br>Data reporting.  Performance tests might have various unusual metrics etc. that should be reported.  For example, I have tests that have metrics measured in &quot;bytes copied&quot;.<br></p><p>Based on those requirements, I propose the following API as a starting point of discussion.<br></p><p>protocol TestFramework {<br>    /**This function is called by SwiftPM to begin all tests<br>    A TestFramework discovers tests and reports them to the delegate.<br>    It performs the tests, keeping the delegate updated in realtime.<br>    Finally, it calls delegate.finish() */<br>    func begin()<br>    <br>    ///A test framework reports back data to SwiftPM (or other data gatherer) here<br>    var delegate: TestFrameworkDelegate { get set }<br>}<br></p><p>protocol Test {<br>    /**A unique name.  Reverse-domain notation is encouraged, and XCTest should use these to represent suites. */<br>    var name : String { get }<br>    <br>    /**The current status of the test */<br>    var status: TestStatus { get }<br>    <br>    /**Metrics that are standardized by this specification.  These metrics are well-known and interoperable between tools */<br>    var metrics: [StandardMetric] { get }<br>    <br>    /**A test may have other metrics, defined by third parties. */<br>    var userMetrics: [UserMetric] { get }<br>}<br></p><p>protocol TestFrameworkDelegate {<br>    /**Call this function to report an update to the test.<br>     <br>The implementation of this fuction should scan the ivars of the Test for a new name / status / metrics and update UX or reporting appropriately.<br>- warning: The implementation of this function must be threadsafe.<br>    */<br>    func updateTest(test: Test)<br>    <br>    /**Create a log event associated with the test, which is appended to the event log.  <br>     <br>SwiftPM uses this information to collate logs in the case that multiple tests are executing simultaneously.<br>- warning: The implementation of this function must be threadsafe.  In the case that the same test logs multiple events simultaneously, the order in which they are appended to the log is undefined.<br>*/<br>    func log(test: Test, event: String)<br>    <br>    /**Call this function to indicate that a test framework has discovered all tests and they have been updated to Planned status.  Novel tests will no longer be discovered.<br></p><p>The use of this method is optional, since some test frameworks may not plan a fixed number of tests.<br>This function can be used by UIs that want a complete list of tests for some reason (e.g. to put them in a UITableView). */<br>    func allTestsPlanned()<br>    <br>    /**Indicates that testing is complete and no more delegate callbacks will be made.<br>- parameter status: The status of the overall testing framework.  In general this is .Failed if any of the underlying tests failed, but a test framework may choose to apply custom logic to rule on its underlying tests.<br>     */<br>    func finish(status: TestStatus)<br>}<br></p><p>enum TestStatus {<br>    case Planned ///The test has been discovered<br>    case Running ///The test is currently executing<br>    case Passed ///The test finished successfully<br>    case Failed(ErrorType) ///The test failed for the specified reason<br>    case Skipped(String) ///The test will not execute.  The string contains more information (e.g. wrong suite, ran out of time, etc.)<br>    case Indeterminate ///The test executed, and ended in a state that is neither a pass nor a failure<br>    case Orange ///The test ended in a state that  may warrant further investigation but is not automatically ruled a failure.  https://wiki.mozilla.org/Auto-tools/Projects/OrangeFactor<br>}<br></p><p>enum StandardMetric {<br>    /// a list of test executions, with the number of seconds of each execution.  In XCTest&#39;s situation, this is 10 doubles, one for each run.<br>    case Runtime([Double])<br>    <br>    ///A unique string that identifies the &quot;performance class&quot; of the machine, such as &quot;iPhone 6s&quot;.  Equal strings mean test results are from a machine in the same performance class and so are directly comparable.  An unequal string means they are not comparable.<br>    case PerformanceClass(String)<br></p><p>}<br></p><p>protocol UserMetric {}<br></p><p>There is an extremely straightforward implementation of this API for XCTest.  Simply loop over the tests and update their status.<br></p><p>However this API is much more powerful than XCTest and would allow considerable experimentation for third-party frameworks on matters of parallelization, test discovery, pass/fail logic, etc., and so I think it is more agnostic and free of XCTest assumptions, which Kyle Fuller expressed concerns about, and I share.<br></p><p>Meanwhile the reporting APIs here makes sure we have parseable tests in a uniform format that UX tools can work with as Rick Ballard was concerned about.<br></p><p>I certainly think there are more ideas to consider here, but this is a reasonable first draft to have a conversation about.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151229/e368d8c3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>protocol for third-party testing frameworks</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>January  4, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; I have some interest in this problem since I have problems such that it isn&#39;t clear whether they can be solved within the mandate of XCTest.  So I am potentially a test framework author, if only as an insurance policy against fixing XCTest to not suck.<br>&gt; <br>&gt; I see some places for test framework to innovate, notably:<br>&gt; <br>&gt; Parallelization of tests.  Swift language tests use all cores, which is AWESOME.  XCTest does not, which is sad.  But a general-purpose threading model for all software is not clear.  This is a good problem for third-party frameworks to study and try out different things.<br></p><p>Sounds great.<br></p><p>&gt; Configuring what tests are to be performed.  Group them by suites?  Burn-in for 10 minutes, regardless of the number of tests?  Turn off and on tests in the source code?<br></p><p>I envisaged command line arguments to `swift build`. What use cases are we talking about here for making which tests run more configurable?<br></p><p>&gt; Complex pass/fail conditions.  XCTest is notoriously bad at failing an entire run because of one performance outlier.<br></p><p>Sounds good. Would fit into a “protocol” design easily enough.<br></p><p>&gt; Data reporting.  Performance tests might have various unusual metrics etc. that should be reported.  For example, I have tests that have metrics measured in &quot;bytes copied”.<br></p><p>Sounds good.<br></p><p>&gt; Based on those requirements, I propose the following API as a starting point of discussion.<br>&gt; <br>&gt; protocol TestFramework {<br>&gt;     /**This function is called by SwiftPM to begin all tests<br>&gt;     A TestFramework discovers tests and reports them to the delegate.<br>&gt;     It performs the tests, keeping the delegate updated in realtime.<br>&gt;     Finally, it calls delegate.finish() */<br>&gt;     func begin()<br>&gt;     <br>&gt;     ///A test framework reports back data to SwiftPM (or other data gatherer) here<br>&gt;     var delegate: TestFrameworkDelegate { get set }<br>&gt; }<br>&gt; <br>&gt; protocol Test {<br>&gt;     /**A unique name.  Reverse-domain notation is encouraged, and XCTest should use these to represent suites. */<br>&gt;     var name : String { get }<br>&gt;     <br>&gt;     /**The current status of the test */<br>&gt;     var status: TestStatus { get }<br>&gt;     <br>&gt;     /**Metrics that are standardized by this specification.  These metrics are well-known and interoperable between tools */<br>&gt;     var metrics: [StandardMetric] { get }<br>&gt;     <br>&gt;     /**A test may have other metrics, defined by third parties. */<br>&gt;     var userMetrics: [UserMetric] { get }<br>&gt; }<br>&gt; <br>&gt; protocol TestFrameworkDelegate {<br>&gt;     /**Call this function to report an update to the test.<br>&gt;      <br>&gt; The implementation of this fuction should scan the ivars of the Test for a new name / status / metrics and update UX or reporting appropriately.<br>&gt; - warning: The implementation of this function must be threadsafe.<br>&gt;     */<br>&gt;     func updateTest(test: Test)<br>&gt;     <br>&gt;     /**Create a log event associated with the test, which is appended to the event log.  <br>&gt;      <br>&gt; SwiftPM uses this information to collate logs in the case that multiple tests are executing simultaneously.<br>&gt; - warning: The implementation of this function must be threadsafe.  In the case that the same test logs multiple events simultaneously, the order in which they are appended to the log is undefined.<br>&gt; */<br>&gt;     func log(test: Test, event: String)<br>&gt;     <br>&gt;     /**Call this function to indicate that a test framework has discovered all tests and they have been updated to Planned status.  Novel tests will no longer be discovered.<br>&gt; <br>&gt; The use of this method is optional, since some test frameworks may not plan a fixed number of tests.<br>&gt; This function can be used by UIs that want a complete list of tests for some reason (e.g. to put them in a UITableView). */<br>&gt;     func allTestsPlanned()<br>&gt;     <br>&gt;     /**Indicates that testing is complete and no more delegate callbacks will be made.<br>&gt; - parameter status: The status of the overall testing framework.  In general this is .Failed if any of the underlying tests failed, but a test framework may choose to apply custom logic to rule on its underlying tests.<br>&gt;      */<br>&gt;     func finish(status: TestStatus)<br>&gt; }<br>&gt; <br>&gt; enum TestStatus {<br>&gt;     case Planned ///The test has been discovered<br>&gt;     case Running ///The test is currently executing<br>&gt;     case Passed ///The test finished successfully<br>&gt;     case Failed(ErrorType) ///The test failed for the specified reason<br>&gt;     case Skipped(String) ///The test will not execute.  The string contains more information (e.g. wrong suite, ran out of time, etc.)<br>&gt;     case Indeterminate ///The test executed, and ended in a state that is neither a pass nor a failure<br>&gt;     case Orange ///The test ended in a state that  may warrant further investigation but is not automatically ruled a failure.  https://wiki.mozilla.org/Auto-tools/Projects/OrangeFactor &lt;https://wiki.mozilla.org/Auto-tools/Projects/OrangeFactor&gt;<br>&gt; }<br>&gt; <br>&gt; enum StandardMetric {<br>&gt;     /// a list of test executions, with the number of seconds of each execution.  In XCTest&#39;s situation, this is 10 doubles, one for each run.<br>&gt;     case Runtime([Double])<br>&gt;     <br>&gt;     ///A unique string that identifies the &quot;performance class&quot; of the machine, such as &quot;iPhone 6s&quot;.  Equal strings mean test results are from a machine in the same performance class and so are directly comparable.  An unequal string means they are not comparable.<br>&gt;     case PerformanceClass(String)<br>&gt; <br>&gt; }<br>&gt; <br>&gt; protocol UserMetric {}<br>&gt; <br>&gt; There is an extremely straightforward implementation of this API for XCTest.  Simply loop over the tests and update their status.<br></p><p>My initial glance thinks this could be simpler, but maybe not. I’d have to give more time to this and I don’t right now have it. Certainly I think it is a great start.<br></p><p>&gt; However this API is much more powerful than XCTest and would allow considerable experimentation for third-party frameworks on matters of parallelization, test discovery, pass/fail logic, etc., and so I think it is more agnostic and free of XCTest assumptions, which Kyle Fuller expressed concerns about, and I share.<br>&gt; <br>&gt; Meanwhile the reporting APIs here makes sure we have parseable tests in a uniform format that UX tools can work with as Rick Ballard was concerned about.<br>&gt; <br>&gt; I certainly think there are more ideas to consider here, but this is a reasonable first draft to have a conversation about.<br></p><p>I’d like us to try and map existing popular testing styles onto this protocol before we right up the full proposal.<br></p><p>I’ll be working on the testing infrastructure as soon as the proposal has been reviewed. As I do so I’ll be making notes on this aspect.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160104/2233b449/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>protocol for third-party testing frameworks</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>January  5, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; On Jan 4, 2016, at 4:00 PM, Max Howell &lt;max.howell at apple.com&gt; wrote:<br>&gt; <br>&gt; I envisaged command line arguments to `swift build`. What use cases are we talking about here for making which tests run more configurable?<br></p><p>Well I think some kind of CLI support (like perhaps passing the whole CLI to the testing framework?) makes sense.<br></p><p>Specifically one problem that motivates flexibility here is the per-commit continuous integration. If my test suite is 15 minutes, and I&#39;m going to run that in a few different configurations  (32 vs 64-bit, or say we support iOS someday and I&#39;m cross-compiling for N simulators or hardware devices, etc.) I&#39;m in for a bad time trying to do all that every commit.<br></p><p>There are a lot of &quot;solutions&quot; here–parallelization, random sampling, running an abbreviated test suite ordinarily and the full test suite every 10th commit–a test suite that tries to maximize code coverage per unit time–there are all kinds of ways to look at this problem that may make sense to somebody.<br></p><p>I&#39;m simply pushing that decision out to individual test frameworks to study.  XCTest thinks you should have test suites that are human curated.  That&#39;s one way to skin the cat.  Let&#39;s give another test framework the flexibility to think differently on this problem.<br></p><p>&gt; I’ll be working on the testing infrastructure as soon as the proposal has been reviewed. As I do so I’ll be making notes on this aspect.<br></p><p>Thanks for picking this up.  Getting basic testing support in place is really important, and IMO the current proposal is really strong.  I am focusing on some of these other areas not as a distraction but because I think the basic testing ideas are strong enough already that they don&#39;t need my help :-)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160105/29415332/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>protocol for third-party testing frameworks</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>January  6, 2016 at 11:00:00am</p></header><div class="content"><p>&gt;&gt; I envisaged command line arguments to `swift build`. What use cases are we talking about here for making which tests run more configurable?<br>&gt; <br>&gt; Well I think some kind of CLI support (like perhaps passing the whole CLI to the testing framework?) makes sense.<br></p><p>That’s our current thinking.<br></p><p>&gt; Specifically one problem that motivates flexibility here is the per-commit continuous integration. If my test suite is 15 minutes, and I&#39;m going to run that in a few different configurations  (32 vs 64-bit, or say we support iOS someday and I&#39;m cross-compiling for N simulators or hardware devices, etc.) I&#39;m in for a bad time trying to do all that every commit.<br>&gt; <br>&gt; There are a lot of &quot;solutions&quot; here–parallelization, random sampling, running an abbreviated test suite ordinarily and the full test suite every 10th commit–a test suite that tries to maximize code coverage per unit time–there are all kinds of ways to look at this problem that may make sense to somebody.<br>&gt; <br>&gt; I&#39;m simply pushing that decision out to individual test frameworks to study.  XCTest thinks you should have test suites that are human curated.  That&#39;s one way to skin the cat.  Let&#39;s give another test framework the flexibility to think differently on this problem.<br></p><p>Sounds super interesting. We should make sure the protocol we design can do these things.<br></p><p>&gt;&gt; I’ll be working on the testing infrastructure as soon as the proposal has been reviewed. As I do so I’ll be making notes on this aspect.<br>&gt; <br>&gt; Thanks for picking this up.  Getting basic testing support in place is really important, and IMO the current proposal is really strong.  I am focusing on some of these other areas not as a distraction but because I think the basic testing ideas are strong enough already that they don&#39;t need my help :-)<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160106/dffa4e00/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>protocol for third-party testing frameworks</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>January 12, 2016 at 05:00:00pm</p></header><div class="content"><p>To follow up here, I’d like to put this particular proposal on the back burner for a couple weeks until we have the initial testing infrastructure in place.<br></p><p>We should keep this proposal in mind as we build the testing infrastructure, as this protocol is in my mind at least, the more important of the two.<br></p><p>&gt; On Jan 6, 2016, at 11:58 AM, Max Howell via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; I envisaged command line arguments to `swift build`. What use cases are we talking about here for making which tests run more configurable?<br>&gt;&gt; <br>&gt;&gt; Well I think some kind of CLI support (like perhaps passing the whole CLI to the testing framework?) makes sense.<br>&gt; <br>&gt; That’s our current thinking.<br>&gt; <br>&gt;&gt; Specifically one problem that motivates flexibility here is the per-commit continuous integration. If my test suite is 15 minutes, and I&#39;m going to run that in a few different configurations  (32 vs 64-bit, or say we support iOS someday and I&#39;m cross-compiling for N simulators or hardware devices, etc.) I&#39;m in for a bad time trying to do all that every commit.<br>&gt;&gt; <br>&gt;&gt; There are a lot of &quot;solutions&quot; here–parallelization, random sampling, running an abbreviated test suite ordinarily and the full test suite every 10th commit–a test suite that tries to maximize code coverage per unit time–there are all kinds of ways to look at this problem that may make sense to somebody.<br>&gt;&gt; <br>&gt;&gt; I&#39;m simply pushing that decision out to individual test frameworks to study.  XCTest thinks you should have test suites that are human curated.  That&#39;s one way to skin the cat.  Let&#39;s give another test framework the flexibility to think differently on this problem.<br>&gt; <br>&gt; Sounds super interesting. We should make sure the protocol we design can do these things.<br>&gt; <br>&gt;&gt;&gt; I’ll be working on the testing infrastructure as soon as the proposal has been reviewed. As I do so I’ll be making notes on this aspect.<br>&gt;&gt; <br>&gt;&gt; Thanks for picking this up.  Getting basic testing support in place is really important, and IMO the current proposal is really strong.  I am focusing on some of these other areas not as a distraction but because I think the basic testing ideas are strong enough already that they don&#39;t need my help :-)<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160112/14d14dd7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>protocol for third-party testing frameworks</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>March 16, 2016 at 06:00:00pm</p></header><div class="content"><p>It’s time to resurrect this proposal.<br></p><p>By all means let’s talk a bit more here, but I hope Drew will submit a proposal, or if he doesn’t have the time I can write it up, co-authored and we’ll submit to evolution.<br></p><p>&gt; On Jan 12, 2016, at 5:02 PM, Max Howell &lt;max.howell at apple.com&gt; wrote:<br>&gt; <br>&gt; To follow up here, I’d like to put this particular proposal on the back burner for a couple weeks until we have the initial testing infrastructure in place.<br>&gt; <br>&gt; We should keep this proposal in mind as we build the testing infrastructure, as this protocol is in my mind at least, the more important of the two.<br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 11:58 AM, Max Howell via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; I envisaged command line arguments to `swift build`. What use cases are we talking about here for making which tests run more configurable?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well I think some kind of CLI support (like perhaps passing the whole CLI to the testing framework?) makes sense.<br>&gt;&gt; <br>&gt;&gt; That’s our current thinking.<br>&gt;&gt; <br>&gt;&gt;&gt; Specifically one problem that motivates flexibility here is the per-commit continuous integration. If my test suite is 15 minutes, and I&#39;m going to run that in a few different configurations  (32 vs 64-bit, or say we support iOS someday and I&#39;m cross-compiling for N simulators or hardware devices, etc.) I&#39;m in for a bad time trying to do all that every commit.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are a lot of &quot;solutions&quot; here–parallelization, random sampling, running an abbreviated test suite ordinarily and the full test suite every 10th commit–a test suite that tries to maximize code coverage per unit time–there are all kinds of ways to look at this problem that may make sense to somebody.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m simply pushing that decision out to individual test frameworks to study.  XCTest thinks you should have test suites that are human curated.  That&#39;s one way to skin the cat.  Let&#39;s give another test framework the flexibility to think differently on this problem.<br>&gt;&gt; <br>&gt;&gt; Sounds super interesting. We should make sure the protocol we design can do these things.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; I’ll be working on the testing infrastructure as soon as the proposal has been reviewed. As I do so I’ll be making notes on this aspect.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for picking this up.  Getting basic testing support in place is really important, and IMO the current proposal is really strong.  I am focusing on some of these other areas not as a distraction but because I think the basic testing ideas are strong enough already that they don&#39;t need my help :-)<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-build-dev mailing list<br>&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160316/e3ecb075/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>protocol for third-party testing frameworks</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>March 16, 2016 at 08:00:00pm</p></header><div class="content"><p>Please take the lead on this.<br></p><p>For background.  We required a solution around the time I was working on this originally, and given that upstream wasn&#39;t ready (which is understandable) we decided to go alone, and we&#39;re now committed to our solution.  So from our POV the problem has been solved.<br></p><p>&gt; On Mar 16, 2016, at 8:12 PM, Max Howell &lt;max.howell at apple.com&gt; wrote:<br>&gt; <br>&gt; It’s time to resurrect this proposal.<br>&gt; <br>&gt; By all means let’s talk a bit more here, but I hope Drew will submit a proposal, or if he doesn’t have the time I can write it up, co-authored and we’ll submit to evolution.<br>&gt; <br>&gt;&gt; On Jan 12, 2016, at 5:02 PM, Max Howell &lt;max.howell at apple.com &lt;mailto:max.howell at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; To follow up here, I’d like to put this particular proposal on the back burner for a couple weeks until we have the initial testing infrastructure in place.<br>&gt;&gt; <br>&gt;&gt; We should keep this proposal in mind as we build the testing infrastructure, as this protocol is in my mind at least, the more important of the two.<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 6, 2016, at 11:58 AM, Max Howell via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I envisaged command line arguments to `swift build`. What use cases are we talking about here for making which tests run more configurable?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Well I think some kind of CLI support (like perhaps passing the whole CLI to the testing framework?) makes sense.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s our current thinking.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Specifically one problem that motivates flexibility here is the per-commit continuous integration. If my test suite is 15 minutes, and I&#39;m going to run that in a few different configurations  (32 vs 64-bit, or say we support iOS someday and I&#39;m cross-compiling for N simulators or hardware devices, etc.) I&#39;m in for a bad time trying to do all that every commit.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are a lot of &quot;solutions&quot; here–parallelization, random sampling, running an abbreviated test suite ordinarily and the full test suite every 10th commit–a test suite that tries to maximize code coverage per unit time–there are all kinds of ways to look at this problem that may make sense to somebody.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m simply pushing that decision out to individual test frameworks to study.  XCTest thinks you should have test suites that are human curated.  That&#39;s one way to skin the cat.  Let&#39;s give another test framework the flexibility to think differently on this problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sounds super interesting. We should make sure the protocol we design can do these things.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’ll be working on the testing infrastructure as soon as the proposal has been reviewed. As I do so I’ll be making notes on this aspect.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks for picking this up.  Getting basic testing support in place is really important, and IMO the current proposal is really strong.  I am focusing on some of these other areas not as a distraction but because I think the basic testing ideas are strong enough already that they don&#39;t need my help :-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160316/d6a6a9b4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/11a8e906b9e22dfebe544e4e218a4be0?s=50"></div><header><strong>protocol for third-party testing frameworks</strong> from <string>Brian Pratt</string> &lt;brian at pratt.io&gt;<p>March 17, 2016 at 10:00:00am</p></header><div class="content"><p>Hey folks,<br></p><p>I think from my perspective SwiftPM could solve this problem by simply allowing me to define and build targets that aren&#39;t going to be included in the distributed package. Maybe a field like `testTargets` or something that allows the author downstream to link `testDependencies`?<br></p><p>SwiftPM is great as a package manager, but for a lot of my most common development workflows, it falls short because of this limitation -- I can&#39;t use it to build things that I don&#39;t mean to distribute as part of the package.<br></p><p>-- <br>Brian Pratt<br></p><p>On March 16, 2016 at 8:39:02 PM, Drew Crawford via swift-build-dev (swift-build-dev at swift.org) wrote:<br></p><p>Please take the lead on this.<br></p><p>For background.  We required a solution around the time I was working on this originally, and given that upstream wasn&#39;t ready (which is understandable) we decided to go alone, and we&#39;re now committed to our solution.  So from our POV the problem has been solved.<br></p><p>On Mar 16, 2016, at 8:12 PM, Max Howell &lt;max.howell at apple.com&gt; wrote:<br></p><p>It’s time to resurrect this proposal.<br></p><p>By all means let’s talk a bit more here, but I hope Drew will submit a proposal, or if he doesn’t have the time I can write it up, co-authored and we’ll submit to evolution.<br></p><p>On Jan 12, 2016, at 5:02 PM, Max Howell &lt;max.howell at apple.com&gt; wrote:<br></p><p>To follow up here, I’d like to put this particular proposal on the back burner for a couple weeks until we have the initial testing infrastructure in place.<br></p><p>We should keep this proposal in mind as we build the testing infrastructure, as this protocol is in my mind at least, the more important of the two.<br></p><p>On Jan 6, 2016, at 11:58 AM, Max Howell via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br></p><p>I envisaged command line arguments to `swift build`. What use cases are we talking about here for making which tests run more configurable?<br></p><p>Well I think some kind of CLI support (like perhaps passing the whole CLI to the testing framework?) makes sense.<br></p><p>That’s our current thinking.<br></p><p>Specifically one problem that motivates flexibility here is the per-commit continuous integration. If my test suite is 15 minutes, and I&#39;m going to run that in a few different configurations  (32 vs 64-bit, or say we support iOS someday and I&#39;m cross-compiling for N simulators or hardware devices, etc.) I&#39;m in for a bad time trying to do all that every commit.<br></p><p>There are a lot of &quot;solutions&quot; here–parallelization, random sampling, running an abbreviated test suite ordinarily and the full test suite every 10th commit–a test suite that tries to maximize code coverage per unit time–there are all kinds of ways to look at this problem that may make sense to somebody.<br></p><p>I&#39;m simply pushing that decision out to individual test frameworks to study.  XCTest thinks you should have test suites that are human curated.  That&#39;s one way to skin the cat.  Let&#39;s give another test framework the flexibility to think differently on this problem.<br></p><p>Sounds super interesting. We should make sure the protocol we design can do these things.<br></p><p>I’ll be working on the testing infrastructure as soon as the proposal has been reviewed. As I do so I’ll be making notes on this aspect.<br></p><p>Thanks for picking this up.  Getting basic testing support in place is really important, and IMO the current proposal is really strong.  I am focusing on some of these other areas not as a distraction but because I think the basic testing ideas are strong enough already that they don&#39;t need my help :-)<br></p><p> _______________________________________________<br>swift-build-dev mailing list<br>swift-build-dev at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p><br></p><p>_______________________________________________<br>swift-build-dev mailing list<br>swift-build-dev at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-build-dev<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160317/7bb3914b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>protocol for third-party testing frameworks</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>March 17, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; Hey folks,<br>&gt; <br>&gt; I think from my perspective SwiftPM could solve this problem by simply allowing me to define and build targets that aren&#39;t going to be included in the distributed package. Maybe a field like `testTargets` or something that allows the author downstream to link `testDependencies`?<br>&gt; <br>&gt; SwiftPM is great as a package manager, but for a lot of my most common development workflows, it falls short because of this limitation -- I can&#39;t use it to build things that I don&#39;t mean to distribute as part of the package.<br></p><p>Can you refine your request a little?<br></p><p>I don’t quite understand because: everything is distributed in the package, because the package is sources.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160317/da8eaffd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/11a8e906b9e22dfebe544e4e218a4be0?s=50"></div><header><strong>protocol for third-party testing frameworks</strong> from <string>Brian Pratt</string> &lt;brian at pratt.io&gt;<p>March 17, 2016 at 12:00:00pm</p></header><div class="content"><p>Ah! Sorry, that word choice (&quot;distributed&quot;) was probably misleading. I&#39;m definitely not concerned about the sources being distributed -- moreso about being able to have finer-grained control over what gets built and what doesn&#39;t.<br></p><p>Right now I have two choices:<br>- define a target (and have it be built when someone lists my package as a dependency)<br>- exclude the target, and never have it be built at all by SwiftPM<br></p><p>I&#39;d like a middle-ground where I can define targets that are *only* built in the development context, link them with test dependencies, and then build only targets that I choose to make available when someone depends on the package.<br></p><p>-- <br>Brian Pratt<br></p><p>On March 17, 2016 at 11:53:01 AM, Max Howell (max.howell at apple.com) wrote:<br></p><p>Hey folks,<br></p><p>I think from my perspective SwiftPM could solve this problem by simply allowing me to define and build targets that aren&#39;t going to be included in the distributed package. Maybe a field like `testTargets` or something that allows the author downstream to link `testDependencies`?<br></p><p>SwiftPM is great as a package manager, but for a lot of my most common development workflows, it falls short because of this limitation -- I can&#39;t use it to build things that I don&#39;t mean to distribute as part of the package.<br></p><p>Can you refine your request a little?<br></p><p>I don’t quite understand because: everything is distributed in the package, because the package is sources.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160317/45807097/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>protocol for third-party testing frameworks</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>March 17, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Ah! Sorry, that word choice (&quot;distributed&quot;) was probably misleading. I&#39;m definitely not concerned about the sources being distributed -- moreso about being able to have finer-grained control over what gets built and what doesn&#39;t.<br>&gt; <br>&gt; Right now I have two choices:<br>&gt; - define a target (and have it be built when someone lists my package as a dependency)<br>&gt; - exclude the target, and never have it be built at all by SwiftPM<br>&gt; <br>&gt; I&#39;d like a middle-ground where I can define targets that are *only* built in the development context, link them with test dependencies, and then build only targets that I choose to make available when someone depends on the package.<br></p><p>Yes please open a ticket for this, we’ve discussed the need for this in the past and should schedule its development.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160317/50f682eb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/11a8e906b9e22dfebe544e4e218a4be0?s=50"></div><header><strong>protocol for third-party testing frameworks</strong> from <string>Brian Pratt</string> &lt;brian at pratt.io&gt;<p>March 17, 2016 at 01:00:00pm</p></header><div class="content"><p>Here&#39;s the ticket: https://bugs.swift.org/browse/SR-968<br>Feel free to add comments!<br></p><p>-- <br>Brian Pratt<br></p><p>On March 17, 2016 at 12:45:08 PM, Max Howell (max.howell at apple.com) wrote:<br></p><p>Ah! Sorry, that word choice (&quot;distributed&quot;) was probably misleading. I&#39;m definitely not concerned about the sources being distributed -- moreso about being able to have finer-grained control over what gets built and what doesn&#39;t.<br></p><p>Right now I have two choices:<br>- define a target (and have it be built when someone lists my package as a dependency)<br>- exclude the target, and never have it be built at all by SwiftPM<br></p><p>I&#39;d like a middle-ground where I can define targets that are *only* built in the development context, link them with test dependencies, and then build only targets that I choose to make available when someone depends on the package.<br></p><p>Yes please open a ticket for this, we’ve discussed the need for this in the past and should schedule its development.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160317/d51e3d57/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/11a8e906b9e22dfebe544e4e218a4be0?s=50"></div><header><strong>protocol for third-party testing frameworks</strong> from <string>Brian Pratt</string> &lt;brian at pratt.io&gt;<p>March 17, 2016 at 12:00:00pm</p></header><div class="content"><p>To get a bit more concrete:<br></p><p>let package = Package(<br>  name: &quot;MyCoolPackage&quot;,<br>  // etc<br>  targets: [<br>    Target(name: &quot;MyCoolPackageTarget&quot;)<br> ],<br> testTargets: [<br>    Target(name: &quot;MyCoolTestingTarget&quot;, dependencies: [.Dependency(&quot;one-of-my-test-dependencies&quot;)])<br>  ])<br>  <br>When someone else uses my package, MyCoolTestingTarget would not be built (although its sources would be present), but MyCoolPackageTarget would be -- if that makes sense. In this way, we&#39;d get ad-hoc support for third-party testing frameworks and also improve the Package Manager to be able to be more useful as a build tool for a whole dev environment as opposed to just a build tool for creating and consuming packages.<br></p><p>The only drawback I can think of that falls out of this approach is that 3rd-party testing frameworks wouldn&#39;t support the `swift test` command-line invocation, but I&#39;d personally rank that as a lower priority for me than just being able to get more granular control over what gets built in a local context vs what gets built when I&#39;m a dependency of something else.<br></p><p>Hopefully that clears my idea up a bit more.<br></p><p>-- <br>Brian Pratt<br></p><p>On March 17, 2016 at 10:05:23 AM, Brian Pratt (brian at pratt.io) wrote:<br></p><p>Hey folks,<br></p><p>I think from my perspective SwiftPM could solve this problem by simply allowing me to define and build targets that aren&#39;t going to be included in the distributed package. Maybe a field like `testTargets` or something that allows the author downstream to link `testDependencies`?<br></p><p>SwiftPM is great as a package manager, but for a lot of my most common development workflows, it falls short because of this limitation -- I can&#39;t use it to build things that I don&#39;t mean to distribute as part of the package.<br></p><p>-- <br>Brian Pratt<br></p><p>On March 16, 2016 at 8:39:02 PM, Drew Crawford via swift-build-dev (swift-build-dev at swift.org) wrote:<br></p><p>Please take the lead on this.<br></p><p>For background.  We required a solution around the time I was working on this originally, and given that upstream wasn&#39;t ready (which is understandable) we decided to go alone, and we&#39;re now committed to our solution.  So from our POV the problem has been solved.<br></p><p>On Mar 16, 2016, at 8:12 PM, Max Howell &lt;max.howell at apple.com&gt; wrote:<br></p><p>It’s time to resurrect this proposal.<br></p><p>By all means let’s talk a bit more here, but I hope Drew will submit a proposal, or if he doesn’t have the time I can write it up, co-authored and we’ll submit to evolution.<br></p><p>On Jan 12, 2016, at 5:02 PM, Max Howell &lt;max.howell at apple.com&gt; wrote:<br></p><p>To follow up here, I’d like to put this particular proposal on the back burner for a couple weeks until we have the initial testing infrastructure in place.<br></p><p>We should keep this proposal in mind as we build the testing infrastructure, as this protocol is in my mind at least, the more important of the two.<br></p><p>On Jan 6, 2016, at 11:58 AM, Max Howell via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br></p><p>I envisaged command line arguments to `swift build`. What use cases are we talking about here for making which tests run more configurable?<br></p><p>Well I think some kind of CLI support (like perhaps passing the whole CLI to the testing framework?) makes sense.<br></p><p>That’s our current thinking.<br></p><p>Specifically one problem that motivates flexibility here is the per-commit continuous integration. If my test suite is 15 minutes, and I&#39;m going to run that in a few different configurations  (32 vs 64-bit, or say we support iOS someday and I&#39;m cross-compiling for N simulators or hardware devices, etc.) I&#39;m in for a bad time trying to do all that every commit.<br></p><p>There are a lot of &quot;solutions&quot; here–parallelization, random sampling, running an abbreviated test suite ordinarily and the full test suite every 10th commit–a test suite that tries to maximize code coverage per unit time–there are all kinds of ways to look at this problem that may make sense to somebody.<br></p><p>I&#39;m simply pushing that decision out to individual test frameworks to study.  XCTest thinks you should have test suites that are human curated.  That&#39;s one way to skin the cat.  Let&#39;s give another test framework the flexibility to think differently on this problem.<br></p><p>Sounds super interesting. We should make sure the protocol we design can do these things.<br></p><p>I’ll be working on the testing infrastructure as soon as the proposal has been reviewed. As I do so I’ll be making notes on this aspect.<br></p><p>Thanks for picking this up.  Getting basic testing support in place is really important, and IMO the current proposal is really strong.  I am focusing on some of these other areas not as a distraction but because I think the basic testing ideas are strong enough already that they don&#39;t need my help :-)<br></p><p> _______________________________________________<br>swift-build-dev mailing list<br>swift-build-dev at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p><br></p><p>_______________________________________________<br>swift-build-dev mailing list<br>swift-build-dev at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-build-dev<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160317/2c9e4343/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>protocol for third-party testing frameworks</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>March 17, 2016 at 04:00:00pm</p></header><div class="content"><p>Resending as Outlook apparently has trouble including the list instead of just the recipients…<br></p><p> <br></p><p>---<br></p><p> <br></p><p>Honestly, I’m still confused why this is the approach that is desired to be taken. Why not just provide a way to invoke different runners from within SwiftPM? Like Drew mentioned, this approach still isn’t going to solve the problems we had. We simply provided a mechanism to run various things. This made it extremely trivial to integrate the running of any type of test framework we wanted with no additional work required by anyone.<br></p><p> <br></p><p>With this approach, it is trivial for us to support XCTest runners, shell script tests, tests that required files to be generated first, etc… <br></p><p> <br></p><p>I’ve also been doing some experiments with different ways to write tests, how would I go about doing that with SwiftPM? <br></p><p> <br></p><p>class Sum {<br>    func add(x: Int, _ y: Int) -&gt; Int { return x + y }<br>}<br> <br>func __test_sum_add_checkin() throws {<br>    let sum = Sum()<br>    assert(sum.add(4, 5) == 10, &quot;Math is hard!&quot;)<br>    assert(sum.add(-3, 3) == 0)<br>}<br></p><p> <br></p><p>Then with our build files:<br></p><p> <br></p><p>(package<br></p><p>  :name &quot;IntegratedUnitTests&quot;<br></p><p>  <br></p><p>  :tasks {<br></p><p>    :build {<br></p><p>      :tool &quot;atllbuild&quot;<br></p><p>      :sources [&quot;Sum.swift&quot;]<br></p><p>      :name &quot;math&quot;<br></p><p>      :output-type &quot;static-library&quot;<br></p><p>      :publish-product true<br></p><p>      :compile-options [&quot;-enable-testing&quot;]<br></p><p>    }<br></p><p> <br></p><p>    :test {<br></p><p>      :dependencies [&quot;generate-test-file&quot;]<br></p><p>      :tool &quot;atllbuild&quot;<br></p><p>      :sources [&quot;sum_test.swift&quot;]<br></p><p>      :name &quot;sum_test&quot;<br></p><p>      :output-type &quot;executable&quot;<br></p><p>      :publish-product true<br></p><p>      :link-with [&quot;math.a&quot;]<br></p><p>    }<br></p><p>    <br></p><p>    :generate-test-file {<br></p><p>      :dependencies [&quot;build&quot;]<br></p><p>      :tool &quot;shell&quot;<br></p><p>      :script &quot;echo &#39;@testable import math&#39; &gt; sum_test.swift &amp;&amp; xcrun -sdk macosx swiftc -print-ast Sum.swift | grep __test | sed &#39;s/internal func/try/g&#39; | sed &#39;s/throws//g&#39; &gt;&gt; sum_test.swift&quot;<br></p><p>    }<br></p><p> <br></p><p>    :run {<br></p><p>      :dependencies [&quot;test&quot;]<br></p><p>      :tool &quot;shell&quot;<br></p><p>      :script &quot;./bin/sum_test&quot;<br></p><p>    }<br></p><p>  }<br></p><p>)<br></p><p> <br></p><p>More details: http://owensd.io/blog/tooling-around---testing-in-swift/<br></p><p> <br></p><p>It would seem the plan is that I’d then have to go write some additional wrapper if I simply wanted it to work in SwiftPM. That’s not a problem that scales very well.<br></p><p> <br></p><p>-David<br></p><p> <br></p><p> <br></p><p>From: swift-build-dev-bounces at swift.org [mailto:swift-build-dev-bounces at swift.org] On Behalf Of Brian Pratt via swift-build-dev<br>Sent: Thursday, March 17, 2016 10:32 AM<br>To: Drew Crawford &lt;drew at sealedabstract.com&gt;; Max Howell &lt;max.howell at apple.com&gt;; Drew Crawford via swift-build-dev &lt;swift-build-dev at swift.org&gt;<br>Subject: Re: [swift-build-dev] protocol for third-party testing frameworks<br></p><p> <br></p><p>To get a bit more concrete:<br></p><p> <br></p><p>let package = Package(<br></p><p>  name: &quot;MyCoolPackage&quot;,<br></p><p>  // etc<br></p><p>  targets: [<br></p><p>    Target(name: &quot;MyCoolPackageTarget&quot;)<br></p><p> ],<br></p><p> testTargets: [<br></p><p>    Target(name: &quot;MyCoolTestingTarget&quot;, dependencies: [.Dependency(&quot;one-of-my-test-dependencies&quot;)])<br></p><p>  ])<br></p><p>  <br></p><p>When someone else uses my package, MyCoolTestingTarget would not be built (although its sources would be present), but MyCoolPackageTarget would be -- if that makes sense. In this way, we&#39;d get ad-hoc support for third-party testing frameworks and also improve the Package Manager to be able to be more useful as a build tool for a whole dev environment as opposed to just a build tool for creating and consuming packages.<br></p><p> <br></p><p>The only drawback I can think of that falls out of this approach is that 3rd-party testing frameworks wouldn&#39;t support the `swift test` command-line invocation, but I&#39;d personally rank that as a lower priority for me than just being able to get more granular control over what gets built in a local context vs what gets built when I&#39;m a dependency of something else.<br></p><p> <br></p><p>Hopefully that clears my idea up a bit more.<br></p><p> <br></p><p>-- <br></p><p>Brian Pratt<br></p><p> <br></p><p>On March 17, 2016 at 10:05:23 AM, Brian Pratt (brian at pratt.io &lt;mailto:brian at pratt.io&gt; ) wrote:<br></p><p>Hey folks,<br></p><p> <br></p><p>I think from my perspective SwiftPM could solve this problem by simply allowing me to define and build targets that aren&#39;t going to be included in the distributed package. Maybe a field like `testTargets` or something that allows the author downstream to link `testDependencies`?<br></p><p> <br></p><p>SwiftPM is great as a package manager, but for a lot of my most common development workflows, it falls short because of this limitation -- I can&#39;t use it to build things that I don&#39;t mean to distribute as part of the package.<br></p><p> <br></p><p>-- <br>Brian Pratt<br></p><p> <br></p><p>On March 16, 2016 at 8:39:02 PM, Drew Crawford via swift-build-dev (swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt; ) wrote:<br></p><p>Please take the lead on this. <br></p><p> <br></p><p>For background.  We required a solution around the time I was working on this originally, and given that upstream wasn&#39;t ready (which is understandable) we decided to go alone, and we&#39;re now committed to our solution.  So from our POV the problem has been solved.<br></p><p> <br></p><p>On Mar 16, 2016, at 8:12 PM, Max Howell &lt;max.howell at apple.com &lt;mailto:max.howell at apple.com&gt; &gt; wrote:<br></p><p> <br></p><p>It’s time to resurrect this proposal. <br></p><p> <br></p><p>By all means let’s talk a bit more here, but I hope Drew will submit a proposal, or if he doesn’t have the time I can write it up, co-authored and we’ll submit to evolution.<br></p><p> <br></p><p>On Jan 12, 2016, at 5:02 PM, Max Howell &lt;max.howell at apple.com &lt;mailto:max.howell at apple.com&gt; &gt; wrote:<br></p><p> <br></p><p>To follow up here, I’d like to put this particular proposal on the back burner for a couple weeks until we have the initial testing infrastructure in place. <br></p><p> <br></p><p>We should keep this proposal in mind as we build the testing infrastructure, as this protocol is in my mind at least, the more important of the two.<br></p><p> <br></p><p>On Jan 6, 2016, at 11:58 AM, Max Howell via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt; &gt; wrote:<br></p><p> <br></p><p>I envisaged command line arguments to `swift build`. What use cases are we talking about here for making which tests run more configurable?<br></p><p> <br></p><p>Well I think some kind of CLI support (like perhaps passing the whole CLI to the testing framework?) makes sense.<br></p><p> <br></p><p>That’s our current thinking.<br></p><p> <br></p><p>Specifically one problem that motivates flexibility here is the per-commit continuous integration. If my test suite is 15 minutes, and I&#39;m going to run that in a few different configurations  (32 vs 64-bit, or say we support iOS someday and I&#39;m cross-compiling for N simulators or hardware devices, etc.) I&#39;m in for a bad time trying to do all that every commit.<br></p><p> <br></p><p>There are a lot of &quot;solutions&quot; here–parallelization, random sampling, running an abbreviated test suite ordinarily and the full test suite every 10th commit–a test suite that tries to maximize code coverage per unit time–there are all kinds of ways to look at this problem that may make sense to somebody.<br></p><p> <br></p><p>I&#39;m simply pushing that decision out to individual test frameworks to study.  XCTest thinks you should have test suites that are human curated.  That&#39;s one way to skin the cat.  Let&#39;s give another test framework the flexibility to think differently on this problem.<br></p><p> <br></p><p>Sounds super interesting. We should make sure the protocol we design can do these things.<br></p><p><br></p><p><br></p><p>I’ll be working on the testing infrastructure as soon as the proposal has been reviewed. As I do so I’ll be making notes on this aspect.<br></p><p> <br></p><p>Thanks for picking this up.  Getting basic testing support in place is really important, and IMO the current proposal is really strong.  I am focusing on some of these other areas not as a distraction but because I think the basic testing ideas are strong enough already that they don&#39;t need my help :-)<br></p><p><br>  &lt;https://u2002410.ct.sendgrid.net/wf/open?upn=cbMbdH1LnH6O78Q-2BHw3jtU8ikibH470Fh9meAJKpwSqpJeTKnMxtBKMcwgO6eNd7RiBAIn9BZYPOs2eHgzutG3iFkECUBpSh2YJRbpFs5gYIFdbbC8ItMNA7gp-2BqGK4cWwBss4mY6Uv8sMAwKkzb1-2B1rswus8P2lPVMLer7xFPfSEQS6c96lmiGJyiZhqf-2F-2BJOnpV-2BhXXERxFHP94bzeH6uMWF-2B662RYrOYdPl-2FmMCE-3D&gt;  _______________________________________________<br>swift-build-dev mailing list<br> &lt;mailto:swift-build-dev at swift.org&gt; swift-build-dev at swift.org<br> &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p> <br></p><p> <br></p><p> <br></p><p>_______________________________________________<br>swift-build-dev mailing list<br>swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt; <br>https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160317/b0ab3979/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
