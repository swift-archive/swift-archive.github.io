<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February  1, 2016 at 05:00:00pm</p></header><div class="content"><p>on Mon Feb 01 2016, Tony Parker &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi Drew,<br>&gt;<br>&gt;&gt; On Jan 30, 2016, at 3:01 PM, Drew Crawford via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I am in favor of this proposal on balance, and I leave the bulk of<br>&gt;&gt; this to people who interop with Objective-C more often than I do.<br>&gt;&gt; <br>&gt;&gt; I would like to confine my remarks to one corner where I think we<br>&gt;&gt; are making a very serious mistake.<br>&gt;&gt; <br>&gt;&gt;&gt; The removal of the &quot;NS&quot; prefix for the Foundation module (or other<br>&gt;&gt;&gt; specifically identified modules) is a mechanical translation for<br>&gt;&gt;&gt; all global symbols defined within that module that can be performed<br>&gt;&gt;&gt; in the Clang importer.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; As I understand it (and I am no Cocoa historian) the NS prefix was<br>&gt;&gt; originally introduced because Objective-C lacks namespacing.<br>&gt;&gt; <br>&gt;&gt; The thinking seems to be that since Swift has proper namespacing,<br>&gt;&gt; this historicism is no longer necessary.  I find this argument very<br>&gt;&gt; flimsy.<br>&gt;&gt; <br>&gt;&gt; Of course Swift has stronger namespacing if one&#39;s frame of reference<br>&gt;&gt; is Objective-C or C.  But for those of us coming from other language<br>&gt;&gt; backgrounds, namespacing means something much stronger than Swift&#39;s<br>&gt;&gt; concept of it.  I don&#39;t mean to suggest that Swift&#39;s design is wrong<br>&gt;&gt; exactly (less is sometimes more), but I do mean to say that if we<br>&gt;&gt; propose to undo a decision that worked for several decades and break<br>&gt;&gt; every Swift project in existence on the theory that Swift&#39;s<br>&gt;&gt; namespacing is strong enough we had better be right.<br>&gt;&gt; <br>&gt;&gt; For those unfamiliar, I will explain some of the namespacing tools<br>&gt;&gt; Swift lacks relative to other languages.  First, many languages have<br>&gt;&gt; a &quot;hierarchical&quot; namespace system, where one can say<br>&gt;&gt; <br>&gt;&gt; import Foundation.Net.URL<br>&gt;&gt; let s = Session(...)<br>&gt;&gt; <br>&gt;&gt; instead of for example<br>&gt;&gt; <br>&gt;&gt; import Foundation<br>&gt;&gt; let s = NSURLSession(...)<br>&gt;&gt; <br>&gt;&gt; Some form of this is used in Rust, Python, and C#, as far as I know.<br>&gt;&gt; I believe Swift has some counterfeit version of this, as the book<br>&gt;&gt; mentions you can import a &quot;submodule<br>&gt;&gt; &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/import-declaration&gt;&quot;,<br>&gt;&gt; but I do not know what that is, do not know how to make one, have<br>&gt;&gt; never seen anyone use one, the book suggests it goes only 2 levels<br>&gt;&gt; deep, and perhaps as a consequences of some of these problems nobody<br>&gt;&gt; thought of using this for Foundation.<br>&gt;&gt; <br>&gt;&gt; A closely related difference is the use of so-called &quot;selective&quot;<br>&gt;&gt; imports, where we import only a single symbol (or a list of<br>&gt;&gt; explicitly-identified symbols) into the scope.  We might express<br>&gt;&gt; this as<br>&gt;&gt; <br>&gt;&gt; from Foundation.Net.URL import Session, HTTP //import two classes only<br>&gt;&gt; let s = Session(...)<br>&gt;&gt; <br>&gt;&gt; Again I think Swift technically supports some way to avoid importing<br>&gt;&gt; a whole gigantic namespace like Foundation, but I am not aware of<br>&gt;&gt; any actual uses of this feature, and certainly the convention is not<br>&gt;&gt; to write code this way.  Meanwhile, let&#39;s check in with the Python<br>&gt;&gt; community, who standardized the following guidance on these<br>&gt;&gt; &quot;wildcard&quot; imports as part of their language evolution process:<br>&gt;&gt; <br>&gt;&gt;&gt; Wildcard imports ( from &lt;module&gt; import * ) should be avoided, as<br>&gt;&gt;&gt; they make it unclear which names are present in the namespace,<br>&gt;&gt;&gt; confusing both readers and many automated tools. There is one<br>&gt;&gt;&gt; defensible use case for a wildcard import...<br>&gt;&gt; <br>&gt;&gt; When a language has a robust namespacing system, which we do not,<br>&gt;&gt; there are many follow-on consequences.  One is that an import<br>&gt;&gt; statement is much more of a scalpel than a bludgeon; each import<br>&gt;&gt; statement only introduces a handful of new names (even if it is a<br>&gt;&gt; so-called &quot;wildcard&quot; import that grabs all children of some<br>&gt;&gt; namespace, most of those children are themselves namespaces), unlike<br>&gt;&gt; importing Foundation which contains thousands of direct child types<br>&gt;&gt; that are injected into the local scope.<br>&gt;&gt; <br>&gt;&gt; Another consequence is that class names become quite short, shadow<br>&gt;&gt; each other, and nobody bats an eye.  I searched the C# standard<br>&gt;&gt; library for &quot;Session&quot;, and found some 12 classes with that name:<br>&gt;&gt; <br>&gt;&gt; &lt;Screen Shot 2016-01-30 at 3.44.23 PM.png&gt;<br>&gt;&gt; <br>&gt;&gt; These &quot;standard library&quot; classes not only potentially shadow<br>&gt;&gt; programmer-defined types, they also shadow each other.  But because<br>&gt;&gt; the C# language has a robust namespacing system, the chances of<br>&gt;&gt; there being more than one thing called &quot;Session&quot; in scope in your<br>&gt;&gt; program (or for that matter, when developing the standard library<br>&gt;&gt; itself) is quite small, so it&#39;s a non-issue.<br>&gt;&gt; <br>&gt;&gt; Now we return to the question of dropping the NS prefix, which will<br>&gt;&gt; rename thousands of classes in a typical program that has `import<br>&gt;&gt; Foundation`, in a way that potentially (let&#39;s be honest.  More like<br>&gt;&gt; &quot;probably&quot;) shadows one or more programmer-defined classes.  Our<br>&gt;&gt; review criteria is:<br>&gt;&gt; <br>&gt;&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; No, the elimination of 2 characters is not significant enough of a<br>&gt;&gt; problem to break all Swift programs, let alone to introduce<br>&gt;&gt; literally thousands of new opportunities for shadowing.<br>&gt;&gt; <br>&gt;&gt; To its credit, the proposal acknowledges this, and offers a concession:<br>&gt;&gt; <br>&gt;&gt;&gt; Note that this removal can create conflicts with the standard<br>&gt;&gt;&gt; library. For example, NSString and NSArray will become String and<br>&gt;&gt;&gt; Array, respectively, and Foundation&#39;s versions will shadow the<br>&gt;&gt;&gt; standard library&#39;s versions.  In cases where the Swift 3 names of<br>&gt;&gt;&gt; standard library entities conflict with prefix-stripped Foundation<br>&gt;&gt;&gt; entities, we retain the NS prefix. These Foundation entities are:<br>&gt;&gt;&gt; NSArray, NSDictionary, NSInteger, NSRange, NSSet, and NSString.<br>&gt;&gt; <br>&gt;&gt; But of course this needlessly draws a distinction between NSString<br>&gt;&gt; et al and the &quot;normal&quot; Foundation types, and what&#39;s more it draws<br>&gt;&gt; that distinction based on the present composition of the Swift<br>&gt;&gt; standard library and the present composition of Foundation.  But we<br>&gt;&gt; have already decided not to guarantee the source compatibility of<br>&gt;&gt; the standard library, so what happens when that composition changes?<br>&gt;&gt; Will we then go back and tweak which classes get NS prefixed to them<br>&gt;&gt; again?<br>&gt;&gt; <br>&gt;&gt; In my view, if Swift&#39;s namespacing is not good enough to let us drop<br>&gt;&gt; the NS in NSString it is not good enough to drop any prefix.  If we<br>&gt;&gt; believe that a programmer will struggle to distinguish between Swift<br>&gt;&gt; String and Foundation String then we should expect them to struggle<br>&gt;&gt; for any two classes in any two frameworks, and this is special<br>&gt;&gt; pleading on the part of Foundation.  C#&#39;s libraries declare *twelve*<br>&gt;&gt; different `Session`s and nobody bats an eye, but we have two types<br>&gt;&gt; share a name and everybody loses their minds?  Our namespacing is<br>&gt;&gt; not good enough to kill the prefix, period.<br>&gt;<br>&gt; I’m actually not sure how this line about shadowing ended up in the<br>&gt; guidelines, <br></p><p>Tony, what do you mean?  Unless I missed something, nobody is claiming<br>that the guidelines say anything directly about shadowing.<br></p><p>&gt; because it is not our plan. Instead, I have always wanted to do<br>&gt; something very close to what you suggest and rename these to something<br>&gt; like “Dynamic.Array” to reflect its role as a dynamically-dispatched,<br>&gt; subclass-capable Array.<br>&gt;<br>&gt; Types like NSURL are intended to be the canonical URL for everyone to<br>&gt; use, so for me it feels very natural to drop the prefix and make them<br>&gt; as accessible as Array, String, etc.<br>&gt;<br>&gt; - Tony<br>&gt;<br>&gt;&gt; <br>&gt;&gt; We should either drop these prefixes or we should not; because the<br>&gt;&gt; claimed motivation–that we have &quot;good enough&quot; namespacing in the<br>&gt;&gt; language now–is either true or it is not.  This proposal admits that<br>&gt;&gt; it is not, and tries to drop the prefixes anyway.  I believe that is<br>&gt;&gt; a mistake.<br>&gt;&gt; <br>&gt;&gt; I certainly support the goal of eliminating these prefixes, they are<br>&gt;&gt; ugly, they need to be killed, and namespacing is the right solution.<br>&gt;&gt; But we must not jump out of the plane until we are very sure our<br>&gt;&gt; parachute is in order.  In Swift 3 it is not.<br>&gt;&gt; <br>&gt;&gt; I do think the bulk of the proposal is fine, and I apologize for<br>&gt;&gt; using quite stark language for such a small paragraph in an<br>&gt;&gt; otherwise reasonable proposal, but I think the problem buried in<br>&gt;&gt; here is quite serious and is being overlooked.<br>&gt;&gt; <br>&gt;&gt; Drew<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 22, 2016, at 3:02 PM, Douglas Gregor via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of SE-0005&quot;Better Translation of Objective-C APIs Into<br>&gt;&gt;&gt; Swift&quot; begins now and runs through January 31, 2016. The proposal<br>&gt;&gt;&gt; is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;<br>&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All<br>&gt;&gt;&gt; reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to<br>&gt;&gt;&gt; the review manager. When replying, please try to keep the proposal<br>&gt;&gt;&gt; link at the top of the message:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal link:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;<br>&gt;&gt;&gt; Reply text<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Other replies<br>&gt;&gt;&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What<br>&gt;&gt;&gt; goes into a review?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The goal of the review process is to improve the proposal under<br>&gt;&gt;&gt; review through constructive criticism and, eventually, determine<br>&gt;&gt;&gt; the direction of Swift. When writing your review, here are some<br>&gt;&gt;&gt; questions you might want to answer in your review:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; If you have used other languages or libraries with a similar<br>&gt;&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt; How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Doug Gregor<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
