<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8ccacafa7f3e7f6a07cdc8d9f1f30471?s=50"></div><header><strong>Proposal: Syntax sugar for cps or async functions similar to the &quot;do try catch&quot; for error handling.</strong> from <string>Roy Fu</string> &lt;lingoerer at gmail.com&gt;<p>December  6, 2015 at 05:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>Similar to the syntax ‘do try catch throw’ and ’throws’ for error handling, I propose another syntax for handling CPS functions or async call backs:<br></p><p>func someFutureWrappedFunc(input: Int) future-&gt; String{<br>    doSomeStaffInBackground{ (result:String) in<br>        fulfil result<br>    }<br>}<br></p><p>do{<br>    let resultX = perform someFutureWrappedFunc(param)<br>    let resultY = perform anotherFutureWrappedFunc(resultX)<br>    let final   = resultX + resultY + perform justAnotherFutureWrappedFunc(resultX)<br>    self.someLabel.text = final<br>} timeout let context {<br>    //maybe some additional information<br>}<br></p><p>the reason for this proposal is for the importance of async models in modern application  architectures, and avoid such pyramids:<br></p><p>doSomeStaffInBackground { (resultX) -&gt; Void in<br>    <br>    doSomeOtherStaff { (resultY) -&gt; Void in<br>        <br>        if resultY.someCondition(resultX) {<br>            <br>            evenMakesItMadness(resultY) { (final) -&gt; Void in<br>                <br>                //finally<br>            }<br>        }<br>    }<br>}<br></p><p><br></p><p><br>For more context comparing this async syntax to the ‘do try catch’:<br></p><p>do try catch:<br>enum Result&lt;T&gt; {<br>    case Success(T)<br>    case Failure(ErrorType)<br>}<br></p><p>func flatMap&lt;T,U&gt; (result:Result&lt;T&gt;, f:T-&gt;Result&lt;U&gt;) -&gt; Result&lt;U&gt;{<br>    switch result{<br>    case .Success(let v): return f(v)<br>    case .Failure(let e): return .Failure(e)<br>    }<br>}<br></p><p>func wrap1&lt;T,U&gt;(f:T throws-&gt; U) -&gt; T-&gt;Result&lt;U&gt; {<br>    return {<br>        do{<br>            return try .Success(f($0))<br>        }catch let e{<br>            return .Failure(e)<br>        }<br>    }<br>}<br></p><p>func wrap2&lt;T,U&gt;(f:T -&gt; Result&lt;U&gt;) -&gt; T throws-&gt; U{<br>    return{<br>        switch f($0){<br>        case .Success(let v): return v<br>        case .Failure(let e): throw e<br>        }<br>    }<br>}<br></p><p>async:<br></p><p>func flatMap&lt;T,U&gt; (async: (T -&gt; Void) -&gt; Void, f:T -&gt; (U-&gt;Void) -&gt; Void) -&gt; (U -&gt; Void) -&gt; Void {<br>    return{ cont in<br>        async{ f($0)(cont) }<br>    }<br>}<br></p><p>func wrap1&lt;T,U&gt;(f:T future-&gt; U) -&gt; T-&gt;(U-&gt;Void)-&gt;Void {<br>    return {input in<br>        {cont in<br>            do{<br>                cont(perform f(input))<br>            }catch _{<br></p><p>            }<br>        }<br>    }<br>}<br></p><p>func wrap2&lt;T,U&gt;(f:T -&gt; (U-&gt;Void)-&gt;Void) -&gt; T future-&gt; U{<br>    return{<br>        f(input)({<br>            fulfil $0<br>        })<br>    }<br>}<br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/28d5ed01/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d933552ea7fda10a4488a74223c00988?s=50"></div><header><strong>Proposal: Syntax sugar for cps or async functions similar to the &quot;do try catch&quot; for error handling.</strong> from <string>Thorsten Seitz</string> &lt;thorsten.seitz at web.de&gt;<p>December  6, 2015 at 05:00:00pm</p></header><div class="content"><p>Hi Roy,<br></p><p>I’d prefer if such special syntax would not be reserved for just async computations but used for monadic computations in general (with the async case just being a monad implementation).<br></p><p>-Thorsten<br></p><p>&gt; Am 06.12.2015 um 10:21 schrieb Roy Fu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Similar to the syntax ‘do try catch throw’ and ’throws’ for error handling, I propose another syntax for handling CPS functions or async call backs:<br>&gt; <br>&gt; func someFutureWrappedFunc(input: Int) future-&gt; String{<br>&gt;     doSomeStaffInBackground{ (result:String) in<br>&gt;         fulfil result<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; do{<br>&gt;     let resultX = perform someFutureWrappedFunc(param)<br>&gt;     let resultY = perform anotherFutureWrappedFunc(resultX)<br>&gt;     let final   = resultX + resultY + perform justAnotherFutureWrappedFunc(resultX)<br>&gt;     self.someLabel.text = final<br>&gt; } timeout let context {<br>&gt;     //maybe some additional information<br>&gt; }<br>&gt; <br>&gt; the reason for this proposal is for the importance of async models in modern application  architectures, and avoid such pyramids:<br>&gt; <br>&gt; doSomeStaffInBackground { (resultX) -&gt; Void in<br>&gt;     <br>&gt;     doSomeOtherStaff { (resultY) -&gt; Void in<br>&gt;         <br>&gt;         if resultY.someCondition(resultX) {<br>&gt;             <br>&gt;             evenMakesItMadness(resultY) { (final) -&gt; Void in<br>&gt;                 <br>&gt;                 //finally<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; For more context comparing this async syntax to the ‘do try catch’:<br>&gt; <br>&gt; do try catch:<br>&gt; enum Result&lt;T&gt; {<br>&gt;     case Success(T)<br>&gt;     case Failure(ErrorType)<br>&gt; }<br>&gt; <br>&gt; func flatMap&lt;T,U&gt; (result:Result&lt;T&gt;, f:T-&gt;Result&lt;U&gt;) -&gt; Result&lt;U&gt;{<br>&gt;     switch result{<br>&gt;     case .Success(let v): return f(v)<br>&gt;     case .Failure(let e): return .Failure(e)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; func wrap1&lt;T,U&gt;(f:T throws-&gt; U) -&gt; T-&gt;Result&lt;U&gt; {<br>&gt;     return {<br>&gt;         do{<br>&gt;             return try .Success(f($0))<br>&gt;         }catch let e{<br>&gt;             return .Failure(e)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; func wrap2&lt;T,U&gt;(f:T -&gt; Result&lt;U&gt;) -&gt; T throws-&gt; U{<br>&gt;     return{<br>&gt;         switch f($0){<br>&gt;         case .Success(let v): return v<br>&gt;         case .Failure(let e): throw e<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; async:<br>&gt; <br>&gt; func flatMap&lt;T,U&gt; (async: (T -&gt; Void) -&gt; Void, f:T -&gt; (U-&gt;Void) -&gt; Void) -&gt; (U -&gt; Void) -&gt; Void {<br>&gt;     return{ cont in<br>&gt;         async{ f($0)(cont) }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; func wrap1&lt;T,U&gt;(f:T future-&gt; U) -&gt; T-&gt;(U-&gt;Void)-&gt;Void {<br>&gt;     return {input in<br>&gt;         {cont in<br>&gt;             do{<br>&gt;                 cont(perform f(input))<br>&gt;             }catch _{<br>&gt; <br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; func wrap2&lt;T,U&gt;(f:T -&gt; (U-&gt;Void)-&gt;Void) -&gt; T future-&gt; U{<br>&gt;     return{<br>&gt;         f(input)({<br>&gt;             fulfil $0<br>&gt;         })<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/e5669d6f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8ccacafa7f3e7f6a07cdc8d9f1f30471?s=50"></div><header><strong>Proposal: Syntax sugar for cps or async functions similar to the &quot;do try catch&quot; for error handling.</strong> from <string>Roy Fu</string> &lt;lingoerer at gmail.com&gt;<p>December  7, 2015 at 02:00:00am</p></header><div class="content"><p>I personally do prefer that too, but, it&#39;s still not that clear for the attitude of core team on introducing too much functional paradigms. More importantly we had to consider if this would add on learning curve for new programmers.<br></p><p>&gt; On Dec 7, 2015, at 12:36 AM, Thorsten Seitz &lt;thorsten.seitz at web.de&gt; wrote:<br>&gt; <br>&gt; Hi Roy,<br>&gt; <br>&gt; I’d prefer if such special syntax would not be reserved for just async computations but used for monadic computations in general (with the async case just being a monad implementation).<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt;&gt; Am 06.12.2015 um 10:21 schrieb Roy Fu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Similar to the syntax ‘do try catch throw’ and ’throws’ for error handling, I propose another syntax for handling CPS functions or async call backs:<br>&gt;&gt; <br>&gt;&gt; func someFutureWrappedFunc(input: Int) future-&gt; String{<br>&gt;&gt;     doSomeStaffInBackground{ (result:String) in<br>&gt;&gt;         fulfil result<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; do{<br>&gt;&gt;     let resultX = perform someFutureWrappedFunc(param)<br>&gt;&gt;     let resultY = perform anotherFutureWrappedFunc(resultX)<br>&gt;&gt;     let final   = resultX + resultY + perform justAnotherFutureWrappedFunc(resultX)<br>&gt;&gt;     self.someLabel.text = final<br>&gt;&gt; } timeout let context {<br>&gt;&gt;     //maybe some additional information<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; the reason for this proposal is for the importance of async models in modern application  architectures, and avoid such pyramids:<br>&gt;&gt; <br>&gt;&gt; doSomeStaffInBackground { (resultX) -&gt; Void in<br>&gt;&gt;     <br>&gt;&gt;     doSomeOtherStaff { (resultY) -&gt; Void in<br>&gt;&gt;         <br>&gt;&gt;         if resultY.someCondition(resultX) {<br>&gt;&gt;             <br>&gt;&gt;             evenMakesItMadness(resultY) { (final) -&gt; Void in<br>&gt;&gt;                 <br>&gt;&gt;                 //finally<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; For more context comparing this async syntax to the ‘do try catch’:<br>&gt;&gt; <br>&gt;&gt; do try catch:<br>&gt;&gt; enum Result&lt;T&gt; {<br>&gt;&gt;     case Success(T)<br>&gt;&gt;     case Failure(ErrorType)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func flatMap&lt;T,U&gt; (result:Result&lt;T&gt;, f:T-&gt;Result&lt;U&gt;) -&gt; Result&lt;U&gt;{<br>&gt;&gt;     switch result{<br>&gt;&gt;     case .Success(let v): return f(v)<br>&gt;&gt;     case .Failure(let e): return .Failure(e)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func wrap1&lt;T,U&gt;(f:T throws-&gt; U) -&gt; T-&gt;Result&lt;U&gt; {<br>&gt;&gt;     return {<br>&gt;&gt;         do{<br>&gt;&gt;             return try .Success(f($0))<br>&gt;&gt;         }catch let e{<br>&gt;&gt;             return .Failure(e)<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func wrap2&lt;T,U&gt;(f:T -&gt; Result&lt;U&gt;) -&gt; T throws-&gt; U{<br>&gt;&gt;     return{<br>&gt;&gt;         switch f($0){<br>&gt;&gt;         case .Success(let v): return v<br>&gt;&gt;         case .Failure(let e): throw e<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; async:<br>&gt;&gt; <br>&gt;&gt; func flatMap&lt;T,U&gt; (async: (T -&gt; Void) -&gt; Void, f:T -&gt; (U-&gt;Void) -&gt; Void) -&gt; (U -&gt; Void) -&gt; Void {<br>&gt;&gt;     return{ cont in<br>&gt;&gt;         async{ f($0)(cont) }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func wrap1&lt;T,U&gt;(f:T future-&gt; U) -&gt; T-&gt;(U-&gt;Void)-&gt;Void {<br>&gt;&gt;     return {input in<br>&gt;&gt;         {cont in<br>&gt;&gt;             do{<br>&gt;&gt;                 cont(perform f(input))<br>&gt;&gt;             }catch _{<br>&gt;&gt; <br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func wrap2&lt;T,U&gt;(f:T -&gt; (U-&gt;Void)-&gt;Void) -&gt; T future-&gt; U{<br>&gt;&gt;     return{<br>&gt;&gt;         f(input)({<br>&gt;&gt;             fulfil $0<br>&gt;&gt;         })<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/3f8e5e80/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Syntax sugar for cps or async functions similar to the &quot;do try catch&quot; for error handling.</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  6, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 6, 2015, at 1:21 AM, Roy Fu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Similar to the syntax ‘do try catch throw’ and ’throws’ for error handling, I propose another syntax for handling CPS functions or async call backs:<br></p><p>We are all very interested in doing things along these lines, but need to keep Swift 3 relatively focused to achieve our goals.  Please bring this idea back up as work on Swift 3 is winding down, for consideration in Swift 4.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; func someFutureWrappedFunc(input: Int) future-&gt; String{<br>&gt;     doSomeStaffInBackground{ (result:String) in<br>&gt;         fulfil result<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; do{<br>&gt;     let resultX = perform someFutureWrappedFunc(param)<br>&gt;     let resultY = perform anotherFutureWrappedFunc(resultX)<br>&gt;     let final   = resultX + resultY + perform justAnotherFutureWrappedFunc(resultX)<br>&gt;     self.someLabel.text = final<br>&gt; } timeout let context {<br>&gt;     //maybe some additional information<br>&gt; }<br>&gt; <br>&gt; the reason for this proposal is for the importance of async models in modern application  architectures, and avoid such pyramids:<br>&gt; <br>&gt; doSomeStaffInBackground { (resultX) -&gt; Void in<br>&gt;     <br>&gt;     doSomeOtherStaff { (resultY) -&gt; Void in<br>&gt;         <br>&gt;         if resultY.someCondition(resultX) {<br>&gt;             <br>&gt;             evenMakesItMadness(resultY) { (final) -&gt; Void in<br>&gt;                 <br>&gt;                 //finally<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; For more context comparing this async syntax to the ‘do try catch’:<br>&gt; <br>&gt; do try catch:<br>&gt; enum Result&lt;T&gt; {<br>&gt;     case Success(T)<br>&gt;     case Failure(ErrorType)<br>&gt; }<br>&gt; <br>&gt; func flatMap&lt;T,U&gt; (result:Result&lt;T&gt;, f:T-&gt;Result&lt;U&gt;) -&gt; Result&lt;U&gt;{<br>&gt;     switch result{<br>&gt;     case .Success(let v): return f(v)<br>&gt;     case .Failure(let e): return .Failure(e)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; func wrap1&lt;T,U&gt;(f:T throws-&gt; U) -&gt; T-&gt;Result&lt;U&gt; {<br>&gt;     return {<br>&gt;         do{<br>&gt;             return try .Success(f($0))<br>&gt;         }catch let e{<br>&gt;             return .Failure(e)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; func wrap2&lt;T,U&gt;(f:T -&gt; Result&lt;U&gt;) -&gt; T throws-&gt; U{<br>&gt;     return{<br>&gt;         switch f($0){<br>&gt;         case .Success(let v): return v<br>&gt;         case .Failure(let e): throw e<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; async:<br>&gt; <br>&gt; func flatMap&lt;T,U&gt; (async: (T -&gt; Void) -&gt; Void, f:T -&gt; (U-&gt;Void) -&gt; Void) -&gt; (U -&gt; Void) -&gt; Void {<br>&gt;     return{ cont in<br>&gt;         async{ f($0)(cont) }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; func wrap1&lt;T,U&gt;(f:T future-&gt; U) -&gt; T-&gt;(U-&gt;Void)-&gt;Void {<br>&gt;     return {input in<br>&gt;         {cont in<br>&gt;             do{<br>&gt;                 cont(perform f(input))<br>&gt;             }catch _{<br>&gt; <br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; func wrap2&lt;T,U&gt;(f:T -&gt; (U-&gt;Void)-&gt;Void) -&gt; T future-&gt; U{<br>&gt;     return{<br>&gt;         f(input)({<br>&gt;             fulfil $0<br>&gt;         })<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/262184eb/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
