<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 24, 2016 at 11:00:00am</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;SE-0089: Replace protocol&lt;P1,P2&gt; syntax with Any&lt;P1,P2&gt;&quot; begins now and runs through May 30. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 24, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt;    * What is your evaluation of the proposal?<br></p><p>+1.  This proposal pages the way for generalized existentials by getting the breaking change out of the way.<br></p><p>I encourage careful consideration of issues surrounding whether this proposal should retain the lowercase keyword convention with &#39;any&#39;, matching the current lowercase &#39;protocol&#39; or not.  <br></p><p>The argument for adopting uppercase is primarily that existentials are often used as types and type names are uppercase by convention.  <br></p><p>My opinion tends towards retaining lowercase primarily because uppercase &#39;Any&#39; looks like generic type but behaves differently.  While there is some overlap, it cannot be used in all of the syntactic forms that generic types can, and it can be used in syntactic locations where generic types cannot.  I believe this rules out the &quot;fits into a syntactic slot&quot; exemption for lowercasing keywords.  Such an exemption should only apply when keywords are used in a way that is indistinguishable from user-defined constructs (such as dynamicType).<br></p><p>Another argument for upper case is the idea that we will directly use existentials in place of current type erased wrappers.  I would prefer to see us establish the practice of declaring typealiases for commonly used existentials (which will quickly become verbose if used directly everywhere in out code).  <br></p><p>The example given is &#39;Any&lt;Sequence where .Element == String&gt;&#39;.  I would prefer to see:<br></p><p>typealias AnySequence&lt;T&gt; = Any&lt;Sequence where .Element == T&gt;<br></p><p>This allows us to continue saying &#39;AnySequence&lt;String&gt;&#39; in our code.  This is a relatively simple constrained existential and yet I believe it reads much better than the raw existential.  The difference will be quite significant with more complex existentials. <br></p><p><br>&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.  &#39;protocol&lt;&gt;&#39; doesn&#39;t feel like the right syntax for generalized existentials.<br></p><p>&gt;    * Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt;    * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I don&#39;t believe I have.<br></p><p>&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>In depth study and participation in the discussion.<br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 24, 2016 at 12:00:00pm</p></header><div class="content"><p>&#39;Any&#39; is definitely a better name, but I think this is still syntax only a compiler can love. If we&#39;re going to repaint this bikeshed, I think we should also consider as an alternative some form of infix syntax for composing constraints. Rust uses `P1 + P2`, and various C++ proposals have suggested `P1 &amp;&amp; P2`. Some pros(+) and cons(-) I can see with this approach:<br></p><p>+ Infix notation works not only in type position, but constraint position as well, providing a nicer way to express multiple type variable constraints:<br>	var x: P &amp;&amp; Q<br>	func foo&lt;T: P &amp;&amp; Q, U&gt;(x: T)<br></p><p>+ Infix notation feels subjectively lighter, being less nesty and angle-bracket-blinding. Compare the above with:<br>	var x: Any&lt;P, Q&gt;<br>	func foo&lt;T: Any&lt;P,Q&gt;, U&gt;(x: T)<br></p><p>Particularly in the second declaration, I find the nested angle brackets and comma delimiters to be hard to visually parse.<br></p><p>± Like &#39;Any&#39;, an infix operator doesn&#39;t pass judgment on what kinds of constraint is being applied, so it naturally extends to expressing class-with-protocol constraints.<br></p><p>- Infix notation doesn&#39;t provide an obvious place for generalized existentials to hang secondary constraints. The angle brackets for Any provide an enclosed syntactic space we can easily stuff a &#39;where&#39; clause:<br></p><p>	func sum(_ collection: Any&lt;Sequence where Element == Int&gt;) -&gt; Int { ... }<br></p><p>(though this notation still feels heavy and awkward to me).<br></p><p>- The bracketing of `Any` might let us address the curious case of protocol vs existential metatypes in a better way. Right now, the static metatype for a protocol type (the type of `P.self`) is spelled `P.Protocol`, and the dynamic metatype for any type conforming to the protocol (the erased type of `T.self` where T: P) is spelled `P.Type`. Unintuitively, when a protocol type is substituted into `T.Type` in a generic context, you get the static type `P.Protocol` rather than `P.Type`, for soundness reasons:<br></p><p>	func staticType&lt;T&gt;(of _: T) -&gt; T.Type { return T.self }<br></p><p>This substitution behavior could be made clearer if we moved a dynamic metatype&#39;s `.Type` into the Any brackets, so that `Any&lt;P.Type&gt;` would be the dynamic metatype of any type conforming to P, and `Any&lt;P&gt;.Type` would be the static metatype of the type `Any&lt;P&gt;`. Infix notation doesn&#39;t provide an opportunity to make this clarification.<br></p><p>- A few people have also noted the similarity between Any&lt;...&gt; and normal generic types. This is potentially confusing today, but with enough magic language features from the future, Any *could* conceivably be made a library feature in the fullness of time:<br></p><p>	// Let&#39;s say &#39;protocol&#39; constraints indicate second-order constraint variables:<br>	enum Any&lt;Constraints: protocol&gt; {<br>		// And we have GADTs:<br>		case value&lt;T: Constraints&gt;(T)<br>	}<br></p><p>	// And we have user-defined value subtyping:<br>	extension &lt;Constraints: protocol, T: Constraints&gt; T: Any&lt;Constraints&gt; { ... }<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 24, 2016 at 12:00:00pm</p></header><div class="content"><p>I actually consider the angle brackets to be easier to read, because it&#39;s<br>visually easy to pair the starting &quot;&lt;&quot; with the ending &quot;&gt;&quot; and mentally<br>delineate the entire extent of the declaration. (I suspect I may be alone<br>in this, though :).<br></p><p>If we can come up with reasonable strawman syntax for adding constraints,<br>we should probably throw this idea into the mix. I meant to ask you<br>earlier, but forgot. I would be happy to submit a PR to add it to the<br>alternatives section, though, so it can be formally reviewed, discussed,<br>and considered.<br></p><p>Austin<br></p><p>On Tue, May 24, 2016 at 12:07 PM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &#39;Any&#39; is definitely a better name, but I think this is still syntax only a<br>&gt; compiler can love. If we&#39;re going to repaint this bikeshed, I think we<br>&gt; should also consider as an alternative some form of infix syntax for<br>&gt; composing constraints. Rust uses `P1 + P2`, and various C++ proposals have<br>&gt; suggested `P1 &amp;&amp; P2`. Some pros(+) and cons(-) I can see with this approach:<br>&gt;<br>&gt; + Infix notation works not only in type position, but constraint position<br>&gt; as well, providing a nicer way to express multiple type variable<br>&gt; constraints:<br>&gt;         var x: P &amp;&amp; Q<br>&gt;         func foo&lt;T: P &amp;&amp; Q, U&gt;(x: T)<br>&gt;<br>&gt; + Infix notation feels subjectively lighter, being less nesty and<br>&gt; angle-bracket-blinding. Compare the above with:<br>&gt;         var x: Any&lt;P, Q&gt;<br>&gt;         func foo&lt;T: Any&lt;P,Q&gt;, U&gt;(x: T)<br>&gt;<br>&gt; Particularly in the second declaration, I find the nested angle brackets<br>&gt; and comma delimiters to be hard to visually parse.<br>&gt;<br>&gt; ± Like &#39;Any&#39;, an infix operator doesn&#39;t pass judgment on what kinds of<br>&gt; constraint is being applied, so it naturally extends to expressing<br>&gt; class-with-protocol constraints.<br>&gt;<br>&gt; - Infix notation doesn&#39;t provide an obvious place for generalized<br>&gt; existentials to hang secondary constraints. The angle brackets for Any<br>&gt; provide an enclosed syntactic space we can easily stuff a &#39;where&#39; clause:<br>&gt;<br>&gt;         func sum(_ collection: Any&lt;Sequence where Element == Int&gt;) -&gt; Int<br>&gt; { ... }<br>&gt;<br>&gt; (though this notation still feels heavy and awkward to me).<br>&gt;<br>&gt; - The bracketing of `Any` might let us address the curious case of<br>&gt; protocol vs existential metatypes in a better way. Right now, the static<br>&gt; metatype for a protocol type (the type of `P.self`) is spelled<br>&gt; `P.Protocol`, and the dynamic metatype for any type conforming to the<br>&gt; protocol (the erased type of `T.self` where T: P) is spelled `P.Type`.<br>&gt; Unintuitively, when a protocol type is substituted into `T.Type` in a<br>&gt; generic context, you get the static type `P.Protocol` rather than `P.Type`,<br>&gt; for soundness reasons:<br>&gt;<br>&gt;         func staticType&lt;T&gt;(of _: T) -&gt; T.Type { return T.self }<br>&gt;<br>&gt; This substitution behavior could be made clearer if we moved a dynamic<br>&gt; metatype&#39;s `.Type` into the Any brackets, so that `Any&lt;P.Type&gt;` would be<br>&gt; the dynamic metatype of any type conforming to P, and `Any&lt;P&gt;.Type` would<br>&gt; be the static metatype of the type `Any&lt;P&gt;`. Infix notation doesn&#39;t provide<br>&gt; an opportunity to make this clarification.<br>&gt;<br>&gt; - A few people have also noted the similarity between Any&lt;...&gt; and normal<br>&gt; generic types. This is potentially confusing today, but with enough magic<br>&gt; language features from the future, Any *could* conceivably be made a<br>&gt; library feature in the fullness of time:<br>&gt;<br>&gt;         // Let&#39;s say &#39;protocol&#39; constraints indicate second-order<br>&gt; constraint variables:<br>&gt;         enum Any&lt;Constraints: protocol&gt; {<br>&gt;                 // And we have GADTs:<br>&gt;                 case value&lt;T: Constraints&gt;(T)<br>&gt;         }<br>&gt;<br>&gt;         // And we have user-defined value subtyping:<br>&gt;         extension &lt;Constraints: protocol, T: Constraints&gt; T:<br>&gt; Any&lt;Constraints&gt; { ... }<br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/7fba5a0c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 24, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 24, 2016, at 2:20 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I actually consider the angle brackets to be easier to read, because it&#39;s visually easy to pair the starting &quot;&lt;&quot; with the ending &quot;&gt;&quot; and mentally delineate the entire extent of the declaration. (I suspect I may be alone in this, though :).<br>&gt; <br>&gt; If we can come up with reasonable strawman syntax for adding constraints, we should probably throw this idea into the mix. I meant to ask you earlier, but forgot. I would be happy to submit a PR to add it to the alternatives section, though, so it can be formally reviewed, discussed, and considered.<br></p><p>Or maybe you should put it in the future directions section?  IMO, it is pretty reasonable to consider the operator syntax to be shorthand, similar to the shorthand for Optional, Array, and Dictionary.<br></p><p>&gt; <br>&gt; Austin<br>&gt; <br>&gt; On Tue, May 24, 2016 at 12:07 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &#39;Any&#39; is definitely a better name, but I think this is still syntax only a compiler can love. If we&#39;re going to repaint this bikeshed, I think we should also consider as an alternative some form of infix syntax for composing constraints. Rust uses `P1 + P2`, and various C++ proposals have suggested `P1 &amp;&amp; P2`. Some pros(+) and cons(-) I can see with this approach:<br>&gt; <br>&gt; + Infix notation works not only in type position, but constraint position as well, providing a nicer way to express multiple type variable constraints:<br>&gt;         var x: P &amp;&amp; Q<br>&gt;         func foo&lt;T: P &amp;&amp; Q, U&gt;(x: T)<br>&gt; <br>&gt; + Infix notation feels subjectively lighter, being less nesty and angle-bracket-blinding. Compare the above with:<br>&gt;         var x: Any&lt;P, Q&gt;<br>&gt;         func foo&lt;T: Any&lt;P,Q&gt;, U&gt;(x: T)<br>&gt; <br>&gt; Particularly in the second declaration, I find the nested angle brackets and comma delimiters to be hard to visually parse.<br>&gt; <br>&gt; ± Like &#39;Any&#39;, an infix operator doesn&#39;t pass judgment on what kinds of constraint is being applied, so it naturally extends to expressing class-with-protocol constraints.<br>&gt; <br>&gt; - Infix notation doesn&#39;t provide an obvious place for generalized existentials to hang secondary constraints. The angle brackets for Any provide an enclosed syntactic space we can easily stuff a &#39;where&#39; clause:<br>&gt; <br>&gt;         func sum(_ collection: Any&lt;Sequence where Element == Int&gt;) -&gt; Int { ... }<br>&gt; <br>&gt; (though this notation still feels heavy and awkward to me).<br>&gt; <br>&gt; - The bracketing of `Any` might let us address the curious case of protocol vs existential metatypes in a better way. Right now, the static metatype for a protocol type (the type of `P.self`) is spelled `P.Protocol`, and the dynamic metatype for any type conforming to the protocol (the erased type of `T.self` where T: P) is spelled `P.Type`. Unintuitively, when a protocol type is substituted into `T.Type` in a generic context, you get the static type `P.Protocol` rather than `P.Type`, for soundness reasons:<br>&gt; <br>&gt;         func staticType&lt;T&gt;(of _: T) -&gt; T.Type { return T.self }<br>&gt; <br>&gt; This substitution behavior could be made clearer if we moved a dynamic metatype&#39;s `.Type` into the Any brackets, so that `Any&lt;P.Type&gt;` would be the dynamic metatype of any type conforming to P, and `Any&lt;P&gt;.Type` would be the static metatype of the type `Any&lt;P&gt;`. Infix notation doesn&#39;t provide an opportunity to make this clarification.<br>&gt; <br>&gt; - A few people have also noted the similarity between Any&lt;...&gt; and normal generic types. This is potentially confusing today, but with enough magic language features from the future, Any *could* conceivably be made a library feature in the fullness of time:<br>&gt; <br>&gt;         // Let&#39;s say &#39;protocol&#39; constraints indicate second-order constraint variables:<br>&gt;         enum Any&lt;Constraints: protocol&gt; {<br>&gt;                 // And we have GADTs:<br>&gt;                 case value&lt;T: Constraints&gt;(T)<br>&gt;         }<br>&gt; <br>&gt;         // And we have user-defined value subtyping:<br>&gt;         extension &lt;Constraints: protocol, T: Constraints&gt; T: Any&lt;Constraints&gt; { ... }<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/0c931617/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 24, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 24, 2016, at 2:07 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &#39;Any&#39; is definitely a better name, but I think this is still syntax only a compiler can love. If we&#39;re going to repaint this bikeshed, I think we should also consider as an alternative some form of infix syntax for composing constraints. Rust uses `P1 + P2`, and various C++ proposals have suggested `P1 &amp;&amp; P2`. Some pros(+) and cons(-) I can see with this approach:<br></p><p>Using infix operator syntax was discussed.  IIRC, the conclusion of the discussion is that it would be an alternative shorthand for the more verbose Any&lt;&gt; syntax (which would be necessary when you have constraints, but in that case you probably want to use a typealias anyway).  The shorthand was deemed likely impractical for Swift 3 and the change from `protocol` to `Any` a good idea to get the breaking change out of the way.  How do you feel about that approach?<br></p><p><br>&gt; <br>&gt; + Infix notation works not only in type position, but constraint position as well, providing a nicer way to express multiple type variable constraints:<br>&gt; 	var x: P &amp;&amp; Q<br>&gt; 	func foo&lt;T: P &amp;&amp; Q, U&gt;(x: T)<br>&gt; <br>&gt; + Infix notation feels subjectively lighter, being less nesty and angle-bracket-blinding. Compare the above with:<br>&gt; 	var x: Any&lt;P, Q&gt;<br>&gt; 	func foo&lt;T: Any&lt;P,Q&gt;, U&gt;(x: T)<br>&gt; <br>&gt; Particularly in the second declaration, I find the nested angle brackets and comma delimiters to be hard to visually parse.<br>&gt; <br>&gt; ± Like &#39;Any&#39;, an infix operator doesn&#39;t pass judgment on what kinds of constraint is being applied, so it naturally extends to expressing class-with-protocol constraints.<br>&gt; <br>&gt; - Infix notation doesn&#39;t provide an obvious place for generalized existentials to hang secondary constraints. The angle brackets for Any provide an enclosed syntactic space we can easily stuff a &#39;where&#39; clause:<br>&gt; <br>&gt; 	func sum(_ collection: Any&lt;Sequence where Element == Int&gt;) -&gt; Int { ... }<br>&gt; <br>&gt; (though this notation still feels heavy and awkward to me).<br>&gt; - The bracketing of `Any` might let us address the curious case of protocol vs existential metatypes in a better way. Right now, the static metatype for a protocol type (the type of `P.self`) is spelled `P.Protocol`, and the dynamic metatype for any type conforming to the protocol (the erased type of `T.self` where T: P) is spelled `P.Type`. Unintuitively, when a protocol type is substituted into `T.Type` in a generic context, you get the static type `P.Protocol` rather than `P.Type`, for soundness reasons:<br>&gt; <br>&gt; 	func staticType&lt;T&gt;(of _: T) -&gt; T.Type { return T.self }<br>&gt; <br>&gt; This substitution behavior could be made clearer if we moved a dynamic metatype&#39;s `.Type` into the Any brackets, so that `Any&lt;P.Type&gt;` would be the dynamic metatype of any type conforming to P, and `Any&lt;P&gt;.Type` would be the static metatype of the type `Any&lt;P&gt;`. Infix notation doesn&#39;t provide an opportunity to make this clarification.<br>&gt; <br>&gt; - A few people have also noted the similarity between Any&lt;...&gt; and normal generic types. This is potentially confusing today, but with enough magic language features from the future, Any *could* conceivably be made a library feature in the fullness of time:<br>&gt; <br>&gt; 	// Let&#39;s say &#39;protocol&#39; constraints indicate second-order constraint variables:<br>&gt; 	enum Any&lt;Constraints: protocol&gt; {<br>&gt; 		// And we have GADTs:<br>&gt; 		case value&lt;T: Constraints&gt;(T)<br>&gt; 	}<br>&gt; <br>&gt; 	// And we have user-defined value subtyping:<br>&gt; 	extension &lt;Constraints: protocol, T: Constraints&gt; T: Any&lt;Constraints&gt; { … }<br></p><p>This is cool.  If it is deemed a likely direction it is a good case for using the uppercase `Any`.  The preference I stated for lowercase is based on trying to apply our casing rules constantly and library types use uppercase.<br></p><p>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>May 24, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 24, 2016, at 12:07 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &#39;Any&#39; is definitely a better name, but I think this is still syntax only a compiler can love. If we&#39;re going to repaint this bikeshed, I think we should also consider as an alternative some form of infix syntax for composing constraints. Rust uses `P1 + P2`, and various C++ proposals have suggested `P1 &amp;&amp; P2`. Some pros(+) and cons(-) I can see with this approach:<br>&gt; <br>&gt; + Infix notation works not only in type position, but constraint position as well, providing a nicer way to express multiple type variable constraints:<br>&gt; 	var x: P &amp;&amp; Q<br>&gt; 	func foo&lt;T: P &amp;&amp; Q, U&gt;(x: T)<br>&gt; <br>&gt; + Infix notation feels subjectively lighter, being less nesty and angle-bracket-blinding. Compare the above with:<br>&gt; 	var x: Any&lt;P, Q&gt;<br>&gt; 	func foo&lt;T: Any&lt;P,Q&gt;, U&gt;(x: T)<br>&gt; <br></p><p>Perhaps just a comma separated list like a type-inheritance-clause, using parenthesis for disambiguation?<br></p><p>var x: P, Q<br>func foo&lt;(T: P, Q), U&gt;<br></p><p>or<br> <br>func foo&lt;T: (P, Q), U&gt;<br></p><p><br></p><p>&gt; Particularly in the second declaration, I find the nested angle brackets and comma delimiters to be hard to visually parse.<br>&gt; <br>&gt; ± Like &#39;Any&#39;, an infix operator doesn&#39;t pass judgment on what kinds of constraint is being applied, so it naturally extends to expressing class-with-protocol constraints.<br>&gt; <br>&gt; - Infix notation doesn&#39;t provide an obvious place for generalized existentials to hang secondary constraints. The angle brackets for Any provide an enclosed syntactic space we can easily stuff a &#39;where&#39; clause:<br>&gt; <br>&gt; 	func sum(_ collection: Any&lt;Sequence where Element == Int&gt;) -&gt; Int { ... }<br>&gt; <br>&gt; (though this notation still feels heavy and awkward to me).<br>&gt; <br>&gt; - The bracketing of `Any` might let us address the curious case of protocol vs existential metatypes in a better way. Right now, the static metatype for a protocol type (the type of `P.self`) is spelled `P.Protocol`, and the dynamic metatype for any type conforming to the protocol (the erased type of `T.self` where T: P) is spelled `P.Type`. Unintuitively, when a protocol type is substituted into `T.Type` in a generic context, you get the static type `P.Protocol` rather than `P.Type`, for soundness reasons:<br>&gt; <br>&gt; 	func staticType&lt;T&gt;(of _: T) -&gt; T.Type { return T.self }<br>&gt; <br>&gt; This substitution behavior could be made clearer if we moved a dynamic metatype&#39;s `.Type` into the Any brackets, so that `Any&lt;P.Type&gt;` would be the dynamic metatype of any type conforming to P, and `Any&lt;P&gt;.Type` would be the static metatype of the type `Any&lt;P&gt;`. Infix notation doesn&#39;t provide an opportunity to make this clarification.<br>&gt; <br>&gt; - A few people have also noted the similarity between Any&lt;...&gt; and normal generic types. This is potentially confusing today, but with enough magic language features from the future, Any *could* conceivably be made a library feature in the fullness of time:<br>&gt; <br>&gt; 	// Let&#39;s say &#39;protocol&#39; constraints indicate second-order constraint variables:<br>&gt; 	enum Any&lt;Constraints: protocol&gt; {<br>&gt; 		// And we have GADTs:<br>&gt; 		case value&lt;T: Constraints&gt;(T)<br>&gt; 	}<br>&gt; <br>&gt; 	// And we have user-defined value subtyping:<br>&gt; 	extension &lt;Constraints: protocol, T: Constraints&gt; T: Any&lt;Constraints&gt; { ... }<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/19ce58f0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 25, 2016 at 08:00:00am</p></header><div class="content"><p>-10  using a comma knowing that it creates ambiguity and then forcing to use brackets to disambiguate make no logical sense when there are plenty of other choices that make the grammar so much easier to read/implement<br></p><p>Regards<br>(From mobile)<br></p><p>&gt; On May 24, 2016, at 9:25 PM, Tyler Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 24, 2016, at 12:07 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &#39;Any&#39; is definitely a better name, but I think this is still syntax only a compiler can love. If we&#39;re going to repaint this bikeshed, I think we should also consider as an alternative some form of infix syntax for composing constraints. Rust uses `P1 + P2`, and various C++ proposals have suggested `P1 &amp;&amp; P2`. Some pros(+) and cons(-) I can see with this approach:<br>&gt;&gt; <br>&gt;&gt; + Infix notation works not only in type position, but constraint position as well, providing a nicer way to express multiple type variable constraints:<br>&gt;&gt; 	var x: P &amp;&amp; Q<br>&gt;&gt; 	func foo&lt;T: P &amp;&amp; Q, U&gt;(x: T)<br>&gt;&gt; <br>&gt;&gt; + Infix notation feels subjectively lighter, being less nesty and angle-bracket-blinding. Compare the above with:<br>&gt;&gt; 	var x: Any&lt;P, Q&gt;<br>&gt;&gt; 	func foo&lt;T: Any&lt;P,Q&gt;, U&gt;(x: T)<br>&gt; <br>&gt; Perhaps just a comma separated list like a type-inheritance-clause, using parenthesis for disambiguation?<br>&gt; <br>&gt; var x: P, Q<br>&gt; func foo&lt;(T: P, Q), U&gt;<br>&gt; <br>&gt; or<br>&gt;  <br>&gt; func foo&lt;T: (P, Q), U&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Particularly in the second declaration, I find the nested angle brackets and comma delimiters to be hard to visually parse.<br>&gt;&gt; <br>&gt;&gt; ± Like &#39;Any&#39;, an infix operator doesn&#39;t pass judgment on what kinds of constraint is being applied, so it naturally extends to expressing class-with-protocol constraints.<br>&gt;&gt; <br>&gt;&gt; - Infix notation doesn&#39;t provide an obvious place for generalized existentials to hang secondary constraints. The angle brackets for Any provide an enclosed syntactic space we can easily stuff a &#39;where&#39; clause:<br>&gt;&gt; <br>&gt;&gt; 	func sum(_ collection: Any&lt;Sequence where Element == Int&gt;) -&gt; Int { ... }<br>&gt;&gt; <br>&gt;&gt; (though this notation still feels heavy and awkward to me).<br>&gt;&gt; <br>&gt;&gt; - The bracketing of `Any` might let us address the curious case of protocol vs existential metatypes in a better way. Right now, the static metatype for a protocol type (the type of `P.self`) is spelled `P.Protocol`, and the dynamic metatype for any type conforming to the protocol (the erased type of `T.self` where T: P) is spelled `P.Type`. Unintuitively, when a protocol type is substituted into `T.Type` in a generic context, you get the static type `P.Protocol` rather than `P.Type`, for soundness reasons:<br>&gt;&gt; <br>&gt;&gt; 	func staticType&lt;T&gt;(of _: T) -&gt; T.Type { return T.self }<br>&gt;&gt; <br>&gt;&gt; This substitution behavior could be made clearer if we moved a dynamic metatype&#39;s `.Type` into the Any brackets, so that `Any&lt;P.Type&gt;` would be the dynamic metatype of any type conforming to P, and `Any&lt;P&gt;.Type` would be the static metatype of the type `Any&lt;P&gt;`. Infix notation doesn&#39;t provide an opportunity to make this clarification.<br>&gt;&gt; <br>&gt;&gt; - A few people have also noted the similarity between Any&lt;...&gt; and normal generic types. This is potentially confusing today, but with enough magic language features from the future, Any *could* conceivably be made a library feature in the fullness of time:<br>&gt;&gt; <br>&gt;&gt; 	// Let&#39;s say &#39;protocol&#39; constraints indicate second-order constraint variables:<br>&gt;&gt; 	enum Any&lt;Constraints: protocol&gt; {<br>&gt;&gt; 		// And we have GADTs:<br>&gt;&gt; 		case value&lt;T: Constraints&gt;(T)<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	// And we have user-defined value subtyping:<br>&gt;&gt; 	extension &lt;Constraints: protocol, T: Constraints&gt; T: Any&lt;Constraints&gt; { ... }<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/b0ca536d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 24, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; If we&#39;re going to repaint this bikeshed, I think we should also consider as an alternative some form of infix syntax for composing constraints. Rust uses `P1 + P2`, and various C++ proposals have suggested `P1 &amp;&amp; P2`.<br></p><p>Given our reluctance to even overload operators for use with Set, I&#39;d personally find this a bit incongruous.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 24, 2016 at 06:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>On May 24, 2016, at 6:09 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; If we&#39;re going to repaint this bikeshed, I think we should also consider as an alternative some form of infix syntax for composing constraints. Rust uses `P1 + P2`, and various C++ proposals have suggested `P1 &amp;&amp; P2`.<br>&gt; <br>&gt; Given our reluctance to even overload operators for use with Set, I&#39;d personally find this a bit incongruous.<br></p><p>I don&#39;t recall a proposal around operators for Set.  What did people want to use?  The obvious candidates are way too hard to type on the keyboards we have today.<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>May 24, 2016 at 11:00:00pm</p></header><div class="content"><p>I believe it was things like &quot;+&quot; and &quot;-&quot; for set union and subtraction, etc.<br></p><p>-Shawn<br></p><p>On Tue, May 24, 2016 at 4:16 PM Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On May 24, 2016, at 6:09 PM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; If we&#39;re going to repaint this bikeshed, I think we should also<br>&gt; consider as an alternative some form of infix syntax for composing<br>&gt; constraints. Rust uses `P1 + P2`, and various C++ proposals have suggested<br>&gt; `P1 &amp;&amp; P2`.<br>&gt; &gt;<br>&gt; &gt; Given our reluctance to even overload operators for use with Set, I&#39;d<br>&gt; personally find this a bit incongruous.<br>&gt;<br>&gt; I don&#39;t recall a proposal around operators for Set.  What did people want<br>&gt; to use?  The obvious candidates are way too hard to type on the keyboards<br>&gt; we have today.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/385a5e01/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 24, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; I believe it was things like &quot;+&quot; and &quot;-&quot; for set union and subtraction, etc.<br></p><p><br>That, or &amp;, |, and ^, by analogy with bitwise operators. It definitely came up during the SetAlgebra discussions. <br></p><p>-- <br>Brent Royal-Gordon<br>Sent from my iPhone<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/65ac89b4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 24, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On May 24, 2016, at 7:45 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; I believe it was things like &quot;+&quot; and &quot;-&quot; for set union and subtraction, etc.<br>&gt; <br>&gt; <br>&gt; That, or &amp;, |, and ^, by analogy with bitwise operators. It definitely came up during the SetAlgebra discussions. <br></p><p>Another thread I guess I didn’t follow closely enough.  I think I agree with avoiding using unconventional operators for operations which already have conventional operators associated with them.  Maybe someday it will be easy enough to type unicode operators that it might be reasonable to think about using them.<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/52aca3dc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May 24, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On May 24, 2016, at 8:06 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 24, 2016, at 7:45 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I believe it was things like &quot;+&quot; and &quot;-&quot; for set union and subtraction, etc.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; That, or &amp;, |, and ^, by analogy with bitwise operators. It definitely came up during the SetAlgebra discussions. <br>&gt; <br>&gt; Another thread I guess I didn’t follow closely enough.  I think I agree with avoiding using unconventional operators for operations which already have conventional operators associated with them.  Maybe someday it will be easy enough to type unicode operators that it might be reasonable to think about using them.<br>Kinda off-topic, but since you asked… I’m a fan of using a custom keyboard layout to remap the alt-layer (http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&amp;id=ukelele). There’s also the “Greek Polytonic” layout included in OS X which has several of math symbols, but notably not anything from set notation. You&#39;d still need a custom layout for those, or just keep the “emoji &amp; symbols” viewer up. <br></p><p>Unicode isn&#39;t hard to do (at least on OS X… I haven’t tried Windows or Linux), but it’s impossible to make a class-compliant keyboard that just directly types unicode characters because the USB HID spec doesn’t support it (https://github.com/kiibohd/KiiConf/issues/30). Until that changes, we’re stuck with using either custom keyboard layouts, macro software, or app-dependant shortcuts. It’s not impossible, it just takes a few of the 800+ member companies deciding that it’s time to get the ball rolling. If only someone who works for such a company were on this mailing list...<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/6ac792ca/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 25, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On May 25, 2016, at 1:15 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 24, 2016, at 6:09 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; If we&#39;re going to repaint this bikeshed, I think we should also consider as an alternative some form of infix syntax for composing constraints. Rust uses `P1 + P2`, and various C++ proposals have suggested `P1 &amp;&amp; P2`.<br>&gt;&gt; <br>&gt;&gt; Given our reluctance to even overload operators for use with Set, I&#39;d personally find this a bit incongruous.<br>&gt; <br>&gt; I don&#39;t recall a proposal around operators for Set.  What did people want to use?  The obvious candidates are way too hard to type on the keyboards we have today.<br></p><p>It is a joke, right? The layout of the keyboards used in one country as a driver for a feature.<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 25, 2016 at 08:00:00am</p></header><div class="content"><p>&gt;&gt;&gt; If we&#39;re going to repaint this bikeshed, I think we should also consider as an alternative some form of infix syntax for composing constraints. Rust uses `P1 + P2`, and various C++ proposals have suggested `P1 &amp;&amp; P2`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given our reluctance to even overload operators for use with Set, I&#39;d personally find this a bit incongruous.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t recall a proposal around operators for Set.  What did people want to use?  The obvious candidates are way too hard to type on the keyboards we have today.<br>&gt; <br>&gt; It is a joke, right? The layout of the keyboards used in one country as a driver for a feature.<br></p><p>I was a bit in shock when I saw this:<br></p><p>https://github.com/apple/swift/blob/master/stdlib/internal/SwiftExperimental/SwiftExperimental.swift<br></p><p>I know it&#39;s marked experimental, but wow... It looks pretty, but it&#39;s insane and IMHO something that shouldn&#39;t be in the standard lib&#39;s master branch.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 25, 2016 at 09:00:00am</p></header><div class="content"><p>I’ll read closely all the feedback we’ve got here so far and comment when I’m done with my work today.<br></p><p>Here is the future direction part from the other proposal we haven’t submitted yet, where I believe Joe mentioned a few words in that direction:<br></p><p>Future directions<br></p><p>any&lt;...&gt; should reflect powerful generalized generic features to be able to constrain types even further (e.g. where clause).<br></p><p>Adding constraints for other extendable types like struct and enum and generalize these. This will allow us to form more typealiases like:<br></p><p>typealias AnyStruct = any&lt;struct&gt;<br>typealias AnyEnum = any&lt;enum&gt;<br>Example:<br>protocol A { func boo() }<br></p><p>// Structs that conforms to a specific protocol.<br>func foo(value: any&lt;struct, SomeProtocol&gt;)  <br>func foo(value: any&lt;AnyStruct, SomeProtocol&gt;)  <br>     <br>// Enums that conforms to a specific protocol.<br>func foo(value: any&lt;enum, SomeProtocol&gt;)  <br>func foo(value: any&lt;AnyEnum, SomeProtocol&gt;)  <br>     <br>// Lets say this array is filled with structs, classes and enums,<br>// which all conforms to `SomeProtocol`.<br>let array: [SomeProtocol] = // fill<br></p><p>// Filter these types:<br>var classArray: [any&lt;class, SomeProtocol&gt;] = array.flatMap { $0 as? any&lt;class, SomeProtocol&gt; }<br>var structArray: [any&lt;struct, SomeProtocol&gt;] = array.flatMap { $0 as? any&lt;struct, SomeProtocol&gt; }<br>var enumArray: [any&lt;enum, SomeProtocol&gt;] = array.flatMap { $0 as? any&lt;enum, SomeProtocol&gt; }<br>Flattened operators or even Type operators for any&lt;...&gt;:<br></p><p>class B {<br>    var mainView: UIView &amp; SomeProtocol<br>     <br>    init(view: UIView &amp; SomeProtocol) {<br>        self. mainView = view<br>    }<br>}<br>The &amp; type operator would produce a “flattened&quot; any&lt;&gt; with its operands. It could be overloaded to accept either a concrete type or a protocol on the lhs and would produce Type for an lhs that is a type and any&lt;...&gt; when lhs is a protocol. Type operators would be evaluated during compile time and would produce a type that is used where the expression was present in the code. This is a long-term idea, not something that needs to be considered right now.<br></p><p>Written by: Matthew Johnson<br>Adding one&lt;...&gt; which can reduce overloading (idea provided by: Thorsten Seitz). one&lt;...&gt; will pick the first type match from within the angle brackets to the dynamic type at compile time and proceed. One would then need to handle the value by own desire.<br></p><p>func foo(value: one&lt;String, Int&gt;) {<br>     <br>    if let v = value as? String {<br>        // Do some work<br>    } else if let v = value as? Int {<br>        // Do some work<br>    }<br>}<br>     <br>// Flattened version:<br>func foo(value: String | Int)<br>Mix any&lt;...&gt; and one&lt;...&gt;:<br></p><p>// Accept only types constrained by  <br>// (`ClassA` AND `SomeProtocol`) OR (`ClassB` AND `SomeProtocol`)<br>func foo(value: any&lt;one&lt;ClassA, ClassB&gt;, SomeProtocol&gt;)<br></p><p>// Flattened version:<br>func foo(value: (ClassA | ClassB) &amp; SomeProtocol)<br>Typealias AnyValue (for extendable types only):<br></p><p>// Isn&#39;t this like magic<br>typealias AnyValue = one&lt;any&lt;struct&gt;, any&lt;enum&gt;&gt;  <br>typealias AnyValue = one&lt;AnyStruct, AnyEnum&gt;<br>typealias AnyValue = any&lt;struct&gt; | any&lt;enum&gt;<br>typealias AnyValue = AnyStruct | AnyEnum<br></p><p>// Any value which conforms to `SomeProtocol`.<br>// Reference types are finally out the way.<br>func foo(value: any&lt;AnyValue, SomeProtocol&gt;)  <br></p><p>// Flattened version:<br>func foo(value: AnyValue &amp; SomeProtocol)<br>————<br></p><p>one&lt;…&gt; is a different story, so don’t stick with it too much in this discussion.<br></p><p>@Austin: If you’re going to update the future direction of this proposal you may want to use something from the future direction part I just posted.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/6d0d2828/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 25, 2016 at 09:00:00am</p></header><div class="content"><p>The proposal I was just talking about is this one here: https://github.com/DevAndArtist/swift-evolution/blob/classes_in_any_existential/proposals/nnnn-classes-in-any-existential.md<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 25. Mai 2016 bei 09:38:29, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>I’ll read closely all the feedback we’ve got here so far and comment when I’m done with my work today.<br></p><p>Here is the future direction part from the other proposal we haven’t submitted yet, where I believe Joe mentioned a few words in that direction:<br></p><p>Future directions<br></p><p>any&lt;...&gt; should reflect powerful generalized generic features to be able to constrain types even further (e.g. where clause).<br></p><p>Adding constraints for other extendable types like struct and enum and generalize these. This will allow us to form more typealiases like:<br></p><p>typealias AnyStruct = any&lt;struct&gt;<br>typealias AnyEnum = any&lt;enum&gt;<br></p><p>Example:<br>protocol A { func boo() }<br></p><p>// Structs that conforms to a specific protocol.<br>func foo(value: any&lt;struct, SomeProtocol&gt;)   <br>func foo(value: any&lt;AnyStruct, SomeProtocol&gt;)   <br>      <br>// Enums that conforms to a specific protocol.<br>func foo(value: any&lt;enum, SomeProtocol&gt;)   <br>func foo(value: any&lt;AnyEnum, SomeProtocol&gt;)   <br>      <br>// Lets say this array is filled with structs, classes and enums,<br>// which all conforms to `SomeProtocol`.<br>let array: [SomeProtocol] = // fill<br></p><p>// Filter these types:<br>var classArray: [any&lt;class, SomeProtocol&gt;] = array.flatMap { $0 as? any&lt;class, SomeProtocol&gt; }<br>var structArray: [any&lt;struct, SomeProtocol&gt;] = array.flatMap { $0 as? any&lt;struct, SomeProtocol&gt; }<br>var enumArray: [any&lt;enum, SomeProtocol&gt;] = array.flatMap { $0 as? any&lt;enum, SomeProtocol&gt; }<br></p><p>Flattened operators or even Type operators for any&lt;...&gt;:<br></p><p>class B {<br>    var mainView: UIView &amp; SomeProtocol<br>      <br>    init(view: UIView &amp; SomeProtocol) {<br>        self. mainView = view<br>    }<br>}<br></p><p>The &amp; type operator would produce a “flattened&quot; any&lt;&gt; with its operands. It could be overloaded to accept either a concrete type or a protocol on the lhs and would produce Type for an lhs that is a type and any&lt;...&gt; when lhs is a protocol. Type operators would be evaluated during compile time and would produce a type that is used where the expression was present in the code. This is a long-term idea, not something that needs to be considered right now.<br></p><p>Written by: Matthew Johnson<br>Adding one&lt;...&gt; which can reduce overloading (idea provided by: Thorsten Seitz). one&lt;...&gt; will pick the first type match from within the angle brackets to the dynamic type at compile time and proceed. One would then need to handle the value by own desire.<br></p><p>func foo(value: one&lt;String, Int&gt;) {<br>      <br>    if let v = value as? String {<br>        // Do some work<br>    } else if let v = value as? Int {<br>        // Do some work<br>    }<br>}<br>      <br>// Flattened version:<br>func foo(value: String | Int)<br></p><p>Mix any&lt;...&gt; and one&lt;...&gt;:<br></p><p>// Accept only types constrained by   <br>// (`ClassA` AND `SomeProtocol`) OR (`ClassB` AND `SomeProtocol`)<br>func foo(value: any&lt;one&lt;ClassA, ClassB&gt;, SomeProtocol&gt;)<br></p><p>// Flattened version:<br>func foo(value: (ClassA | ClassB) &amp; SomeProtocol)<br></p><p>Typealias AnyValue (for extendable types only):<br></p><p>// Isn&#39;t this like magic<br>typealias AnyValue = one&lt;any&lt;struct&gt;, any&lt;enum&gt;&gt;   <br>typealias AnyValue = one&lt;AnyStruct, AnyEnum&gt;<br>typealias AnyValue = any&lt;struct&gt; | any&lt;enum&gt;<br>typealias AnyValue = AnyStruct | AnyEnum<br></p><p>// Any value which conforms to `SomeProtocol`.<br>// Reference types are finally out the way.<br>func foo(value: any&lt;AnyValue, SomeProtocol&gt;)   <br></p><p>// Flattened version:<br>func foo(value: AnyValue &amp; SomeProtocol)<br></p><p>————<br></p><p>one&lt;…&gt; is a different story, so don’t stick with it too much in this discussion.<br></p><p>@Austin: If you’re going to update the future direction of this proposal you may want to use something from the future direction part I just posted.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/40be6ecf/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 25, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 25, 2016, at 1:33 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On May 25, 2016, at 1:15 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On May 24, 2016, at 6:09 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; If we&#39;re going to repaint this bikeshed, I think we should also consider as an alternative some form of infix syntax for composing constraints. Rust uses `P1 + P2`, and various C++ proposals have suggested `P1 &amp;&amp; P2`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given our reluctance to even overload operators for use with Set, I&#39;d personally find this a bit incongruous.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t recall a proposal around operators for Set.  What did people want to use?  The obvious candidates are way too hard to type on the keyboards we have today.<br>&gt; <br>&gt; It is a joke, right? The layout of the keyboards used in one country as a driver for a feature.<br></p><p>I&#39;m thinking of keyboards much different than we have today.  Imagine a keyboard where the meaning of keys isn&#39;t fixed, but is instead controllable by apps.  This may, but need not be a touchscreen keyboard like we have on iPad.  There are hardware keyboards with physical keys where each key displays a software provided symbol.  If keyboards lie this become ubiquitous it would be easy for programming apps to make Unicode operator symbols relatively easy for everyone to type, regardless of locale.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 25, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; - A few people have also noted the similarity between Any&lt;...&gt; and normal generic types. This is potentially confusing today, but with enough magic language features from the future, Any *could* conceivably be made a library feature in the fullness of time:<br>&gt; <br>&gt; 	// Let&#39;s say &#39;protocol&#39; constraints indicate second-order constraint variables:<br>&gt; 	enum Any&lt;Constraints: protocol&gt; {<br>&gt; 		// And we have GADTs:<br>&gt; 		case value&lt;T: Constraints&gt;(T)<br>&gt; 	}<br>&gt; <br>&gt; 	// And we have user-defined value subtyping:<br>&gt; 	extension &lt;Constraints: protocol, T: Constraints&gt; T: Any&lt;Constraints&gt; { ... }<br></p><p>I wanted to reply to this, because this is a beautiful dream, but if we want to treat `Any` like some kind of magical variadic generic type, that has some interesting implications for its design right now.<br></p><p>1) In a normal generic type, when you leave out the generic parameters, Swift infers them. (Think of casting an array literal to `Array`, which pins down the collection type but not the elements.) If `Any` were handled similarly, that would mean that `foo as Any` would not necessarily have an empty set of constraints, but would rather have an *inferred* set of constraints. If you wanted to force it to have no constraints, you would need to write `Any&lt;&gt;`. <br></p><p>2) We would not normally expect to be able to cast between a normal generic type and the instance contained in it. Instead, we would expect to use initializers, just as we&#39;re now planning to require for Objective-C bridging:<br></p><p>	let myExistentialInteger = Any&lt;Integer&gt;(myInt)<br>	let myInt2 = Int(any: myExistentialInteger)!<br></p><p>Note that, if we were passing to an API which specifically expected an `Any&lt;Integer&gt;`, we could just write `Any(myInt)` and type inference would figure out the rest.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 25, 2016 at 06:00:00pm</p></header><div class="content"><p>On May 25, 2016, at 9:45 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; - A few people have also noted the similarity between Any&lt;...&gt; and normal generic types. This is potentially confusing today, but with enough magic language features from the future, Any *could* conceivably be made a library feature in the fullness of time:<br>&gt;&gt; <br>&gt;&gt;    // Let&#39;s say &#39;protocol&#39; constraints indicate second-order constraint variables:<br>&gt;&gt;    enum Any&lt;Constraints: protocol&gt; {<br>&gt;&gt;        // And we have GADTs:<br>&gt;&gt;        case value&lt;T: Constraints&gt;(T)<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    // And we have user-defined value subtyping:<br>&gt;&gt;    extension &lt;Constraints: protocol, T: Constraints&gt; T: Any&lt;Constraints&gt; { ... }<br>&gt; <br>&gt; I wanted to reply to this, because this is a beautiful dream, but if we want to treat `Any` like some kind of magical variadic generic type, that has some interesting implications for its design right now.<br>&gt; <br>&gt; 1) In a normal generic type, when you leave out the generic parameters, Swift infers them. (Think of casting an array literal to `Array`, which pins down the collection type but not the elements.) If `Any` were handled similarly, that would mean that `foo as Any` would not necessarily have an empty set of constraints, but would rather have an *inferred* set of constraints. If you wanted to force it to have no constraints, you would need to write `Any&lt;&gt;`. <br>&gt; <br>&gt; 2) We would not normally expect to be able to cast between a normal generic type and the instance contained in it. Instead, we would expect to use initializers, just as we&#39;re now planning to require for Objective-C bridging:<br>&gt; <br>&gt;    let myExistentialInteger = Any&lt;Integer&gt;(myInt)<br>&gt;    let myInt2 = Int(any: myExistentialInteger)!<br>&gt; <br></p><p>How realistic is it to plan something like that considering the details involved in something like (even just to filter it out):<br></p><p>  let myEx = Any&lt;Iterable&gt;([10,&quot;london&quot;,20,&quot;tokyo&quot;])<br></p><p>and then would you then propose something like:<br></p><p>let myExistentialInteger = Any&lt;Integer&gt;(myInt) {<br>  func hashValue -&gt; Int {<br>    return 42<br>  }<br>}<br></p><p><br></p><p>&gt; Note that, if we were passing to an API which specifically expected an `Any&lt;Integer&gt;`, we could just write `Any(myInt)` and type inference would figure out the rest.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>May 24, 2016 at 07:00:00pm</p></header><div class="content"><p>On Tue, May 24, 2016, at 11:06 AM, Chris Lattner wrote:<br>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1. protocol&lt;...&gt; feels like a weird corner of the language that not a lot of people know about. Also, changing to Any&lt;...&gt; opens the door to allowing classes in the list instead of just protocols (protocol&lt;UIViewController, MyProto&gt; doesn&#39;t make much sense, but Any&lt;UIViewController, MyProto&gt; is fine).<br></p><p>I prefer to spell it as Any instead of any. I think the biggest reason is because Any, without brackets, is used as an existential type, and it would be weird to have a lowercase identifier used as a type. Arguably we could introduce any&lt;...&gt; and make Any just a typealias for any&lt;&gt;, but that seems potentially confusing, so I&#39;d rather just have Any and Any&lt;...&gt;.<br></p><p>Joe Groff&#39;s infix notation proposal has some merit, and I&#39;d like to mention one other point in favor: Any&lt;P,Q&gt; and Any&lt;Q,P&gt; are equivalent types, but it&#39;s not immediately obvious that they should be, since all other uses of type parameters care about type ordering. Infix notation gets rid of the assumption of ordering (since infix operators like + are usually commutative). But it is a more dramatic change, and we can always consider switching to that later if we want (I imagine that usage of protocol&lt;...&gt; is fairly rare so not many people will be impacted by this change), and it does have the drawbacks that Joe mentioned which are non-trivial.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Probably, yeah. It removes a rarely-used construct in favor of one that people are probably more familiar with, and as I mentioned before it opens the door to allowing Any&lt;SomeClass,SomeProto&gt; (which is an Obj-C feature that Swift currently has no equivalent for).<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>The only language that comes to mind where I&#39;m familiar with the equivalent functionality is Rust, and as Joe Groff already said, Rust uses an infix operator for this.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A quick reading of the proposal and reading the review thread to date.<br></p><p>-Kevin Ballard<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 25, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>I am in favor. This is a necessary step towards many future features: class-plus-protocol types, the replacement/reimplementation of AnyObject with Any&lt;class&gt;, existentials with associated types, etc.<br></p><p>One reason to prefer `Any` over `any` which is not listed in the proposal is confusion with the unparameterized `Any` type. Having an uppercase `Any` and a lowercase `any&lt;…&gt;` is going to lead to a lot of confusion; people aren&#39;t going to remember whether they need the capitalized form or the lowercase one for any particular use. I don&#39;t think we can have `any&lt;...&gt;` unless we&#39;re also willing to have an unparameterized `any`, and I think `any` is 100% wrong, because it is absolutely a type but is lowercase.<br></p><p>Since we are trying to cram as many breaking changes as possible into Swift 3, I also think we should consider now, or soon, whether or not we want to draw a strong syntactic line between protocols-as-existentials and protocols-as-constraints by requiring the use of `Any&lt;…&gt;` on all existentials and forbidding its use in constraints. That would mean, for instance, that code like this:<br></p><p>	let printable: CustomStringConvertible = foo<br></p><p>Would now be written:<br></p><p>	let printable: Any&lt;CustomStringConvertible&gt; = foo<br></p><p>And also that code like:<br></p><p>	func foo&lt;X: Any&lt;Y, Z&gt;&gt;(x: X)<br></p><p>Would probably have to be written something like:<br></p><p>	func foo&lt;X: Y&gt;(x: X) where X: Z<br></p><p>However, I believe this would have a significant advantage: it would clarify the distinction between an existential and a constraint. It would more clearly mark where you are taking on the abstraction overhead of an existential. It would also improve the non-existential type situation: in the short term, it would make it clearer where uses of associated type protocols like `Comparable` would not be permitted; in the long term, once we have type-erased existentials for those protocols, it would make it clearer when type erasure was in effect.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. `protocol&lt;&gt;` is an ugly and unloved corner of the language; very few people know about it, remember it, or use it. The renaming improves this situation.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Given the way it enables many future features, yes.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>The only language I&#39;ve used with similar features is Objective-C. There, too, the `&lt;&gt;` is overloaded, now that lightweight generics are part of the language.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I&#39;d like to think I have a fairly deep understanding of this feature, having participated heavily in the discussions about it.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 25, 2016 at 01:00:00am</p></header><div class="content"><p>I am not going to comment on the proposal (conflict of interest etc). I do want to speak up in support of Brent&#39;s points, though.<br></p><p>&gt; On May 25, 2016, at 12:34 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; I am in favor. This is a necessary step towards many future features: class-plus-protocol types, the replacement/reimplementation of AnyObject with Any&lt;class&gt;, existentials with associated types, etc.<br>&gt; <br>&gt; One reason to prefer `Any` over `any` which is not listed in the proposal is confusion with the unparameterized `Any` type. Having an uppercase `Any` and a lowercase `any&lt;…&gt;` is going to lead to a lot of confusion; people aren&#39;t going to remember whether they need the capitalized form or the lowercase one for any particular use. I don&#39;t think we can have `any&lt;...&gt;` unless we&#39;re also willing to have an unparameterized `any`, and I think `any` is 100% wrong, because it is absolutely a type but is lowercase.<br>&gt; <br>&gt; Since we are trying to cram as many breaking changes as possible into Swift 3, I also think we should consider now, or soon, whether or not we want to draw a strong syntactic line between protocols-as-existentials and protocols-as-constraints by requiring the use of `Any&lt;…&gt;` on all existentials and forbidding its use in constraints. That would mean, for instance, that code like this:<br>&gt; <br>&gt; 	let printable: CustomStringConvertible = foo<br>&gt; <br>&gt; Would now be written:<br>&gt; <br>&gt; 	let printable: Any&lt;CustomStringConvertible&gt; = foo<br></p><p>I&#39;m sure this will be controversial, but I like the idea of marking all existential types using Any-syntax. It makes the distinction between concrete and existential types in code completely clear to the reader. Given that there are some subtle differences in how concrete and existential types can be used (for example, used as the types of values passed to generic functions), I think this is definitely worth considering.<br></p><p>There are an additional five characters (including two angle brackets to type), but I suspect bare existentials aren&#39;t used quite as often as concrete types are, so the aesthetic cost might not be too onerous.<br></p><p>&gt; <br>&gt; And also that code like:<br>&gt; <br>&gt; 	func foo&lt;X: Any&lt;Y, Z&gt;&gt;(x: X)<br>&gt; <br>&gt; Would probably have to be written something like:<br>&gt; <br>&gt; 	func foo&lt;X: Y&gt;(x: X) where X: Z<br></p><p>I also personally prefer this convention. The &#39;Any&lt;Y, Z&gt;&#39; construct in the constraint above does not really have anything to do with existential types as they exist everywhere else in Swift; it simply means that whatever concrete type can be used to instantiate the function must conform to two different protocols.<br></p><p>It&#39;s true that any concrete type that could be used to satisfy X in foo() could also be used to fill an Any&lt;Y, Z&gt; existential, but this correspondence isn&#39;t interesting to the user. The ways a user can use an Any&lt;Y, Z&gt; existential differ from the ways a sort-of-universal type like X in foo() can be used:<br></p><p>// firstElement&#39;s type is known exactly at compile time, because X must be &#39;filled in&#39;<br>// by a concrete type, and that concrete type&#39;s associated types are also known.<br>foo&lt;X : Collection&gt;(x: X) {<br>  let firstElement : X.Iterator.Element = x.first!<br>}<br></p><p>// firstElement&#39;s type is not ever known without some sort of dynamic downcasting,<br>// because the contract that defines the existential can guarantee nothing about its type.<br>let foo : &lt;X : Collection&gt; = ...<br>let firstElement : Any = x.first!<br></p><p>&gt; <br>&gt; However, I believe this would have a significant advantage: it would clarify the distinction between an existential and a constraint. It would more clearly mark where you are taking on the abstraction overhead of an existential. It would also improve the non-existential type situation: in the short term, it would make it clearer where uses of associated type protocols like `Comparable` would not be permitted; in the long term, once we have type-erased existentials for those protocols, it would make it clearer when type erasure was in effect.<br>&gt; <br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes. `protocol&lt;&gt;` is an ugly and unloved corner of the language; very few people know about it, remember it, or use it. The renaming improves this situation.<br>&gt; <br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Given the way it enables many future features, yes.<br>&gt; <br>&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; The only language I&#39;ve used with similar features is Objective-C. There, too, the `&lt;&gt;` is overloaded, now that lightweight generics are part of the language.<br>&gt; <br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I&#39;d like to think I have a fairly deep understanding of this feature, having participated heavily in the discussions about it.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 25, 2016 at 01:00:00am</p></header><div class="content"><p>Because I am bad at typing today, my code examples should read:<br></p><p>foo&lt;X : Collection&gt;(x: X) { ... }<br></p><p>and <br></p><p>let foo : &lt;Collection&gt; = ...<br></p><p><br>&gt; On May 25, 2016, at 1:01 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; I am not going to comment on the proposal (conflict of interest etc). I do want to speak up in support of Brent&#39;s points, though.<br>&gt; <br>&gt;&gt; On May 25, 2016, at 12:34 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; I am in favor. This is a necessary step towards many future features: class-plus-protocol types, the replacement/reimplementation of AnyObject with Any&lt;class&gt;, existentials with associated types, etc.<br>&gt;&gt; <br>&gt;&gt; One reason to prefer `Any` over `any` which is not listed in the proposal is confusion with the unparameterized `Any` type. Having an uppercase `Any` and a lowercase `any&lt;…&gt;` is going to lead to a lot of confusion; people aren&#39;t going to remember whether they need the capitalized form or the lowercase one for any particular use. I don&#39;t think we can have `any&lt;...&gt;` unless we&#39;re also willing to have an unparameterized `any`, and I think `any` is 100% wrong, because it is absolutely a type but is lowercase.<br>&gt;&gt; <br>&gt;&gt; Since we are trying to cram as many breaking changes as possible into Swift 3, I also think we should consider now, or soon, whether or not we want to draw a strong syntactic line between protocols-as-existentials and protocols-as-constraints by requiring the use of `Any&lt;…&gt;` on all existentials and forbidding its use in constraints. That would mean, for instance, that code like this:<br>&gt;&gt; <br>&gt;&gt; 	let printable: CustomStringConvertible = foo<br>&gt;&gt; <br>&gt;&gt; Would now be written:<br>&gt;&gt; <br>&gt;&gt; 	let printable: Any&lt;CustomStringConvertible&gt; = foo<br>&gt; <br>&gt; I&#39;m sure this will be controversial, but I like the idea of marking all existential types using Any-syntax. It makes the distinction between concrete and existential types in code completely clear to the reader. Given that there are some subtle differences in how concrete and existential types can be used (for example, used as the types of values passed to generic functions), I think this is definitely worth considering.<br>&gt; <br>&gt; There are an additional five characters (including two angle brackets to type), but I suspect bare existentials aren&#39;t used quite as often as concrete types are, so the aesthetic cost might not be too onerous.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; And also that code like:<br>&gt;&gt; <br>&gt;&gt; 	func foo&lt;X: Any&lt;Y, Z&gt;&gt;(x: X)<br>&gt;&gt; <br>&gt;&gt; Would probably have to be written something like:<br>&gt;&gt; <br>&gt;&gt; 	func foo&lt;X: Y&gt;(x: X) where X: Z<br>&gt; <br>&gt; I also personally prefer this convention. The &#39;Any&lt;Y, Z&gt;&#39; construct in the constraint above does not really have anything to do with existential types as they exist everywhere else in Swift; it simply means that whatever concrete type can be used to instantiate the function must conform to two different protocols.<br>&gt; <br>&gt; It&#39;s true that any concrete type that could be used to satisfy X in foo() could also be used to fill an Any&lt;Y, Z&gt; existential, but this correspondence isn&#39;t interesting to the user. The ways a user can use an Any&lt;Y, Z&gt; existential differ from the ways a sort-of-universal type like X in foo() can be used:<br>&gt; <br>&gt; // firstElement&#39;s type is known exactly at compile time, because X must be &#39;filled in&#39;<br>&gt; // by a concrete type, and that concrete type&#39;s associated types are also known.<br>&gt; foo&lt;X : Collection&gt;(x: X) {<br>&gt;  let firstElement : X.Iterator.Element = x.first!<br>&gt; }<br>&gt; <br>&gt; // firstElement&#39;s type is not ever known without some sort of dynamic downcasting,<br>&gt; // because the contract that defines the existential can guarantee nothing about its type.<br>&gt; let foo : &lt;X : Collection&gt; = ...<br>&gt; let firstElement : Any = x.first!<br>&gt; <br>&gt;&gt; <br>&gt;&gt; However, I believe this would have a significant advantage: it would clarify the distinction between an existential and a constraint. It would more clearly mark where you are taking on the abstraction overhead of an existential. It would also improve the non-existential type situation: in the short term, it would make it clearer where uses of associated type protocols like `Comparable` would not be permitted; in the long term, once we have type-erased existentials for those protocols, it would make it clearer when type erasure was in effect.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; <br>&gt;&gt; Yes. `protocol&lt;&gt;` is an ugly and unloved corner of the language; very few people know about it, remember it, or use it. The renaming improves this situation.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; Given the way it enables many future features, yes.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; <br>&gt;&gt; The only language I&#39;ve used with similar features is Objective-C. There, too, the `&lt;&gt;` is overloaded, now that lightweight generics are part of the language.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to think I have a fairly deep understanding of this feature, having participated heavily in the discussions about it.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/c7f4a4ea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 25, 2016 at 01:00:00am</p></header><div class="content"><p>func foo&lt;X : Collection&gt;(x: X) { ... }<br></p><p>I&#39;m done, sorry.<br></p><p>&gt; On May 25, 2016, at 1:07 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Because I am bad at typing today, my code examples should read:<br>&gt; <br>&gt; foo&lt;X : Collection&gt;(x: X) { ... }<br>&gt; <br>&gt; and <br>&gt; <br>&gt; let foo : &lt;Collection&gt; = ...<br>&gt; <br>&gt; <br>&gt;&gt; On May 25, 2016, at 1:01 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I am not going to comment on the proposal (conflict of interest etc). I do want to speak up in support of Brent&#39;s points, though.<br>&gt;&gt; <br>&gt;&gt;&gt; On May 25, 2016, at 12:34 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am in favor. This is a necessary step towards many future features: class-plus-protocol types, the replacement/reimplementation of AnyObject with Any&lt;class&gt;, existentials with associated types, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One reason to prefer `Any` over `any` which is not listed in the proposal is confusion with the unparameterized `Any` type. Having an uppercase `Any` and a lowercase `any&lt;…&gt;` is going to lead to a lot of confusion; people aren&#39;t going to remember whether they need the capitalized form or the lowercase one for any particular use. I don&#39;t think we can have `any&lt;...&gt;` unless we&#39;re also willing to have an unparameterized `any`, and I think `any` is 100% wrong, because it is absolutely a type but is lowercase.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since we are trying to cram as many breaking changes as possible into Swift 3, I also think we should consider now, or soon, whether or not we want to draw a strong syntactic line between protocols-as-existentials and protocols-as-constraints by requiring the use of `Any&lt;…&gt;` on all existentials and forbidding its use in constraints. That would mean, for instance, that code like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	let printable: CustomStringConvertible = foo<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would now be written:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	let printable: Any&lt;CustomStringConvertible&gt; = foo<br>&gt;&gt; <br>&gt;&gt; I&#39;m sure this will be controversial, but I like the idea of marking all existential types using Any-syntax. It makes the distinction between concrete and existential types in code completely clear to the reader. Given that there are some subtle differences in how concrete and existential types can be used (for example, used as the types of values passed to generic functions), I think this is definitely worth considering.<br>&gt;&gt; <br>&gt;&gt; There are an additional five characters (including two angle brackets to type), but I suspect bare existentials aren&#39;t used quite as often as concrete types are, so the aesthetic cost might not be too onerous.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And also that code like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	func foo&lt;X: Any&lt;Y, Z&gt;&gt;(x: X)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would probably have to be written something like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	func foo&lt;X: Y&gt;(x: X) where X: Z<br>&gt;&gt; <br>&gt;&gt; I also personally prefer this convention. The &#39;Any&lt;Y, Z&gt;&#39; construct in the constraint above does not really have anything to do with existential types as they exist everywhere else in Swift; it simply means that whatever concrete type can be used to instantiate the function must conform to two different protocols.<br>&gt;&gt; <br>&gt;&gt; It&#39;s true that any concrete type that could be used to satisfy X in foo() could also be used to fill an Any&lt;Y, Z&gt; existential, but this correspondence isn&#39;t interesting to the user. The ways a user can use an Any&lt;Y, Z&gt; existential differ from the ways a sort-of-universal type like X in foo() can be used:<br>&gt;&gt; <br>&gt;&gt; // firstElement&#39;s type is known exactly at compile time, because X must be &#39;filled in&#39;<br>&gt;&gt; // by a concrete type, and that concrete type&#39;s associated types are also known.<br>&gt;&gt; foo&lt;X : Collection&gt;(x: X) {<br>&gt;&gt;  let firstElement : X.Iterator.Element = x.first!<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // firstElement&#39;s type is not ever known without some sort of dynamic downcasting,<br>&gt;&gt; // because the contract that defines the existential can guarantee nothing about its type.<br>&gt;&gt; let foo : &lt;X : Collection&gt; = ...<br>&gt;&gt; let firstElement : Any = x.first!<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, I believe this would have a significant advantage: it would clarify the distinction between an existential and a constraint. It would more clearly mark where you are taking on the abstraction overhead of an existential. It would also improve the non-existential type situation: in the short term, it would make it clearer where uses of associated type protocols like `Comparable` would not be permitted; in the long term, once we have type-erased existentials for those protocols, it would make it clearer when type erasure was in effect.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes. `protocol&lt;&gt;` is an ugly and unloved corner of the language; very few people know about it, remember it, or use it. The renaming improves this situation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given the way it enables many future features, yes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The only language I&#39;ve used with similar features is Objective-C. There, too, the `&lt;&gt;` is overloaded, now that lightweight generics are part of the language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like to think I have a fairly deep understanding of this feature, having participated heavily in the discussions about it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/aafc0963/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 25, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On May 25, 2016, at 10:01 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I am not going to comment on the proposal (conflict of interest etc). I do want to speak up in support of Brent&#39;s points, though.<br>&gt; <br>&gt;&gt;&gt; On May 25, 2016, at 12:34 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    * What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; I am in favor. This is a necessary step towards many future features: class-plus-protocol types, the replacement/reimplementation of AnyObject with Any&lt;class&gt;, existentials with associated types, etc.<br>&gt;&gt; <br>&gt;&gt; One reason to prefer `Any` over `any` which is not listed in the proposal is confusion with the unparameterized `Any` type. Having an uppercase `Any` and a lowercase `any&lt;…&gt;` is going to lead to a lot of confusion; people aren&#39;t going to remember whether they need the capitalized form or the lowercase one for any particular use. I don&#39;t think we can have `any&lt;...&gt;` unless we&#39;re also willing to have an unparameterized `any`, and I think `any` is 100% wrong, because it is absolutely a type but is lowercase.<br>&gt;&gt; <br>&gt;&gt; Since we are trying to cram as many breaking changes as possible into Swift 3, I also think we should consider now, or soon, whether or not we want to draw a strong syntactic line between protocols-as-existentials and protocols-as-constraints by requiring the use of `Any&lt;…&gt;` on all existentials and forbidding its use in constraints. That would mean, for instance, that code like this:<br>&gt;&gt; <br>&gt;&gt;    let printable: CustomStringConvertible = foo<br>&gt;&gt; <br>&gt;&gt; Would now be written:<br>&gt;&gt; <br>&gt;&gt;    let printable: Any&lt;CustomStringConvertible&gt; = foo<br>&gt; <br>&gt; I&#39;m sure this will be controversial, but I like the idea of marking all existential types using Any-syntax. It makes the distinction between concrete and existential types in code completely clear to the reader. Given that there are some subtle differences in how concrete and existential types can be used (for example, used as the types of values passed to generic functions), I think this is definitely worth considering.<br>&gt; <br></p><p>Much of what I read about the swift philosophy seems to boil down to immediate association of the semantic with the syntax, to help the newcomer &#39;parse&#39; the language in their mind with less efforts. Seems to me that Any&lt;&gt; being so close to Array&lt;&gt; could be construed as running counter to that philosophie.<br></p><p>&gt; There are an additional five characters (including two angle brackets to type), but I suspect bare existentials aren&#39;t used quite as often as concrete types are, so the aesthetic cost might not be too onerous.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; And also that code like:<br>&gt;&gt; <br>&gt;&gt;    func foo&lt;X: Any&lt;Y, Z&gt;&gt;(x: X)<br>&gt;&gt; <br>&gt;&gt; Would probably have to be written something like:<br>&gt;&gt; <br>&gt;&gt;    func foo&lt;X: Y&gt;(x: X) where X: Z<br>&gt; <br>&gt; I also personally prefer this convention. The &#39;Any&lt;Y, Z&gt;&#39; construct in the constraint above does not really have anything to do with existential types as they exist everywhere else in Swift; it simply means that whatever concrete type can be used to instantiate the function must conform to two different protocols.<br>&gt; <br>&gt; It&#39;s true that any concrete type that could be used to satisfy X in foo() could also be used to fill an Any&lt;Y, Z&gt; existential, but this correspondence isn&#39;t interesting to the user. The ways a user can use an Any&lt;Y, Z&gt; existential differ from the ways a sort-of-universal type like X in foo() can be used:<br>&gt; <br>&gt; // firstElement&#39;s type is known exactly at compile time, because X must be &#39;filled in&#39;<br>&gt; // by a concrete type, and that concrete type&#39;s associated types are also known.<br>&gt; foo&lt;X : Collection&gt;(x: X) {<br>&gt;  let firstElement : X.Iterator.Element = x.first!<br>&gt; }<br>&gt; <br>&gt; // firstElement&#39;s type is not ever known without some sort of dynamic downcasting,<br>&gt; // because the contract that defines the existential can guarantee nothing about its type.<br>&gt; let foo : &lt;X : Collection&gt; = ...<br>&gt; let firstElement : Any = x.first!<br>&gt; <br>&gt;&gt; <br>&gt;&gt; However, I believe this would have a significant advantage: it would clarify the distinction between an existential and a constraint. It would more clearly mark where you are taking on the abstraction overhead of an existential. It would also improve the non-existential type situation: in the short term, it would make it clearer where uses of associated type protocols like `Comparable` would not be permitted; in the long term, once we have type-erased existentials for those protocols, it would make it clearer when type erasure was in effect.<br>&gt;&gt; <br>&gt;&gt;&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; <br>&gt;&gt; Yes. `protocol&lt;&gt;` is an ugly and unloved corner of the language; very few people know about it, remember it, or use it. The renaming improves this situation.<br>&gt;&gt; <br>&gt;&gt;&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; Given the way it enables many future features, yes.<br>&gt;&gt; <br>&gt;&gt;&gt;    * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; <br>&gt;&gt; The only language I&#39;ve used with similar features is Objective-C. There, too, the `&lt;&gt;` is overloaded, now that lightweight generics are part of the language.<br>&gt;&gt; <br>&gt;&gt;&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to think I have a fairly deep understanding of this feature, having participated heavily in the discussions about it.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 25, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 25, 2016, at 9:59 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 25, 2016, at 10:01 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I am not going to comment on the proposal (conflict of interest etc). I do want to speak up in support of Brent&#39;s points, though.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 25, 2016, at 12:34 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   * What is your evaluation of the proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am in favor. This is a necessary step towards many future features: class-plus-protocol types, the replacement/reimplementation of AnyObject with Any&lt;class&gt;, existentials with associated types, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One reason to prefer `Any` over `any` which is not listed in the proposal is confusion with the unparameterized `Any` type. Having an uppercase `Any` and a lowercase `any&lt;…&gt;` is going to lead to a lot of confusion; people aren&#39;t going to remember whether they need the capitalized form or the lowercase one for any particular use. I don&#39;t think we can have `any&lt;...&gt;` unless we&#39;re also willing to have an unparameterized `any`, and I think `any` is 100% wrong, because it is absolutely a type but is lowercase.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since we are trying to cram as many breaking changes as possible into Swift 3, I also think we should consider now, or soon, whether or not we want to draw a strong syntactic line between protocols-as-existentials and protocols-as-constraints by requiring the use of `Any&lt;…&gt;` on all existentials and forbidding its use in constraints. That would mean, for instance, that code like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   let printable: CustomStringConvertible = foo<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would now be written:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   let printable: Any&lt;CustomStringConvertible&gt; = foo<br>&gt;&gt; <br>&gt;&gt; I&#39;m sure this will be controversial, but I like the idea of marking all existential types using Any-syntax. It makes the distinction between concrete and existential types in code completely clear to the reader. Given that there are some subtle differences in how concrete and existential types can be used (for example, used as the types of values passed to generic functions), I think this is definitely worth considering.<br>&gt;&gt; <br>&gt; <br>&gt; Much of what I read about the swift philosophy seems to boil down to immediate association of the semantic with the syntax, to help the newcomer &#39;parse&#39; the language in their mind with less efforts. Seems to me that Any&lt;&gt; being so close to Array&lt;&gt; could be construed as running counter to that philosophy.<br></p><p>This is a big part of the case for using lowercase `any`.  But there are good arguments on both sides.  In Joe’s hypothetical future Swift, `Any` would be a standard library type thus it wouldn’t have such a strong difference from Array.<br></p><p>&gt; <br>&gt;&gt; There are an additional five characters (including two angle brackets to type), but I suspect bare existentials aren&#39;t used quite as often as concrete types are, so the aesthetic cost might not be too onerous.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And also that code like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func foo&lt;X: Any&lt;Y, Z&gt;&gt;(x: X)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would probably have to be written something like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func foo&lt;X: Y&gt;(x: X) where X: Z<br>&gt;&gt; <br>&gt;&gt; I also personally prefer this convention. The &#39;Any&lt;Y, Z&gt;&#39; construct in the constraint above does not really have anything to do with existential types as they exist everywhere else in Swift; it simply means that whatever concrete type can be used to instantiate the function must conform to two different protocols.<br>&gt;&gt; <br>&gt;&gt; It&#39;s true that any concrete type that could be used to satisfy X in foo() could also be used to fill an Any&lt;Y, Z&gt; existential, but this correspondence isn&#39;t interesting to the user. The ways a user can use an Any&lt;Y, Z&gt; existential differ from the ways a sort-of-universal type like X in foo() can be used:<br>&gt;&gt; <br>&gt;&gt; // firstElement&#39;s type is known exactly at compile time, because X must be &#39;filled in&#39;<br>&gt;&gt; // by a concrete type, and that concrete type&#39;s associated types are also known.<br>&gt;&gt; foo&lt;X : Collection&gt;(x: X) {<br>&gt;&gt; let firstElement : X.Iterator.Element = x.first!<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // firstElement&#39;s type is not ever known without some sort of dynamic downcasting,<br>&gt;&gt; // because the contract that defines the existential can guarantee nothing about its type.<br>&gt;&gt; let foo : &lt;X : Collection&gt; = ...<br>&gt;&gt; let firstElement : Any = x.first!<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, I believe this would have a significant advantage: it would clarify the distinction between an existential and a constraint. It would more clearly mark where you are taking on the abstraction overhead of an existential. It would also improve the non-existential type situation: in the short term, it would make it clearer where uses of associated type protocols like `Comparable` would not be permitted; in the long term, once we have type-erased existentials for those protocols, it would make it clearer when type erasure was in effect.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes. `protocol&lt;&gt;` is an ugly and unloved corner of the language; very few people know about it, remember it, or use it. The renaming improves this situation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given the way it enables many future features, yes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The only language I&#39;ve used with similar features is Objective-C. There, too, the `&lt;&gt;` is overloaded, now that lightweight generics are part of the language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like to think I have a fairly deep understanding of this feature, having participated heavily in the discussions about it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/62d3ccab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 25, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 25, 2016, at 5:03 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On May 25, 2016, at 9:59 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 25, 2016, at 10:01 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am not going to comment on the proposal (conflict of interest etc). I do want to speak up in support of Brent&#39;s points, though.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 25, 2016, at 12:34 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I am in favor. This is a necessary step towards many future features: class-plus-protocol types, the replacement/reimplementation of AnyObject with Any&lt;class&gt;, existentials with associated types, etc.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One reason to prefer `Any` over `any` which is not listed in the proposal is confusion with the unparameterized `Any` type. Having an uppercase `Any` and a lowercase `any&lt;…&gt;` is going to lead to a lot of confusion; people aren&#39;t going to remember whether they need the capitalized form or the lowercase one for any particular use. I don&#39;t think we can have `any&lt;...&gt;` unless we&#39;re also willing to have an unparameterized `any`, and I think `any` is 100% wrong, because it is absolutely a type but is lowercase.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since we are trying to cram as many breaking changes as possible into Swift 3, I also think we should consider now, or soon, whether or not we want to draw a strong syntactic line between protocols-as-existentials and protocols-as-constraints by requiring the use of `Any&lt;…&gt;` on all existentials and forbidding its use in constraints. That would mean, for instance, that code like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   let printable: CustomStringConvertible = foo<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Would now be written:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   let printable: Any&lt;CustomStringConvertible&gt; = foo<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m sure this will be controversial, but I like the idea of marking all existential types using Any-syntax. It makes the distinction between concrete and existential types in code completely clear to the reader. Given that there are some subtle differences in how concrete and existential types can be used (for example, used as the types of values passed to generic functions), I think this is definitely worth considering.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Much of what I read about the swift philosophy seems to boil down to immediate association of the semantic with the syntax, to help the newcomer &#39;parse&#39; the language in their mind with less efforts. Seems to me that Any&lt;&gt; being so close to Array&lt;&gt; could be construed as running counter to that philosophy.<br>&gt; <br>&gt; This is a big part of the case for using lowercase `any`.  But there are good arguments on both sides.  In Joe’s hypothetical future Swift, `Any` would be a standard library type thus it wouldn’t have such a strong difference from Array.<br></p><p>I was not referring to Any/Array. I was pointing out the rest of the expressions<br></p><p>Xxxxx&lt;...&gt;    versus    Yxxxxx&lt;...&gt;<br></p><p>Might not be so easy to explain that despite the similarities of forms, these two expressions are vastly different. Flip side is: if this was scala, it would probably be at every yearly &quot;Swift Days&quot; conference in the &quot;Swift puzzlers&quot; session. :)<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; There are an additional five characters (including two angle brackets to type), but I suspect bare existentials aren&#39;t used quite as often as concrete types are, so the aesthetic cost might not be too onerous.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And also that code like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   func foo&lt;X: Any&lt;Y, Z&gt;&gt;(x: X)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Would probably have to be written something like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   func foo&lt;X: Y&gt;(x: X) where X: Z<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I also personally prefer this convention. The &#39;Any&lt;Y, Z&gt;&#39; construct in the constraint above does not really have anything to do with existential types as they exist everywhere else in Swift; it simply means that whatever concrete type can be used to instantiate the function must conform to two different protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s true that any concrete type that could be used to satisfy X in foo() could also be used to fill an Any&lt;Y, Z&gt; existential, but this correspondence isn&#39;t interesting to the user. The ways a user can use an Any&lt;Y, Z&gt; existential differ from the ways a sort-of-universal type like X in foo() can be used:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // firstElement&#39;s type is known exactly at compile time, because X must be &#39;filled in&#39;<br>&gt;&gt;&gt; // by a concrete type, and that concrete type&#39;s associated types are also known.<br>&gt;&gt;&gt; foo&lt;X : Collection&gt;(x: X) {<br>&gt;&gt;&gt; let firstElement : X.Iterator.Element = x.first!<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // firstElement&#39;s type is not ever known without some sort of dynamic downcasting,<br>&gt;&gt;&gt; // because the contract that defines the existential can guarantee nothing about its type.<br>&gt;&gt;&gt; let foo : &lt;X : Collection&gt; = ...<br>&gt;&gt;&gt; let firstElement : Any = x.first!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However, I believe this would have a significant advantage: it would clarify the distinction between an existential and a constraint. It would more clearly mark where you are taking on the abstraction overhead of an existential. It would also improve the non-existential type situation: in the short term, it would make it clearer where uses of associated type protocols like `Comparable` would not be permitted; in the long term, once we have type-erased existentials for those protocols, it would make it clearer when type erasure was in effect.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes. `protocol&lt;&gt;` is an ugly and unloved corner of the language; very few people know about it, remember it, or use it. The renaming improves this situation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Given the way it enables many future features, yes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The only language I&#39;ve used with similar features is Objective-C. There, too, the `&lt;&gt;` is overloaded, now that lightweight generics are part of the language.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d like to think I have a fairly deep understanding of this feature, having participated heavily in the discussions about it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/b8b0cb28/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 25, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 25, 2016, at 10:28 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On May 25, 2016, at 5:03 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 25, 2016, at 9:59 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 25, 2016, at 10:01 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I am not going to comment on the proposal (conflict of interest etc). I do want to speak up in support of Brent&#39;s points, though.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 25, 2016, at 12:34 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;   * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I am in favor. This is a necessary step towards many future features: class-plus-protocol types, the replacement/reimplementation of AnyObject with Any&lt;class&gt;, existentials with associated types, etc.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One reason to prefer `Any` over `any` which is not listed in the proposal is confusion with the unparameterized `Any` type. Having an uppercase `Any` and a lowercase `any&lt;…&gt;` is going to lead to a lot of confusion; people aren&#39;t going to remember whether they need the capitalized form or the lowercase one for any particular use. I don&#39;t think we can have `any&lt;...&gt;` unless we&#39;re also willing to have an unparameterized `any`, and I think `any` is 100% wrong, because it is absolutely a type but is lowercase.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Since we are trying to cram as many breaking changes as possible into Swift 3, I also think we should consider now, or soon, whether or not we want to draw a strong syntactic line between protocols-as-existentials and protocols-as-constraints by requiring the use of `Any&lt;…&gt;` on all existentials and forbidding its use in constraints. That would mean, for instance, that code like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   let printable: CustomStringConvertible = foo<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Would now be written:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   let printable: Any&lt;CustomStringConvertible&gt; = foo<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m sure this will be controversial, but I like the idea of marking all existential types using Any-syntax. It makes the distinction between concrete and existential types in code completely clear to the reader. Given that there are some subtle differences in how concrete and existential types can be used (for example, used as the types of values passed to generic functions), I think this is definitely worth considering.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Much of what I read about the swift philosophy seems to boil down to immediate association of the semantic with the syntax, to help the newcomer &#39;parse&#39; the language in their mind with less efforts. Seems to me that Any&lt;&gt; being so close to Array&lt;&gt; could be construed as running counter to that philosophy.<br>&gt;&gt; <br>&gt;&gt; This is a big part of the case for using lowercase `any`.  But there are good arguments on both sides.  In Joe’s hypothetical future Swift, `Any` would be a standard library type thus it wouldn’t have such a strong difference from Array.<br>&gt; <br>&gt; I was not referring to Any/Array. I was pointing out the rest of the expressions<br>&gt; <br>&gt; Xxxxx&lt;...&gt;    versus    Yxxxxx&lt;...&gt;<br>&gt; <br>&gt; Might not be so easy to explain that despite the similarities of forms, these two expressions are vastly different. Flip side is: if this was scala, it would probably be at every yearly &quot;Swift Days&quot; conference in the &quot;Swift puzzlers&quot; session. :)<br></p><p>You are referring to the fact that `any` is not a generic type and that is the source of its different behavior, aren’t you? If not, can you clarify what you mean?<br></p><p>If so, my point was that if it eventually becomes possible to write such constructs in a library as in Joe’s example:<br></p><p>&gt;  A few people have also noted the similarity between Any&lt;...&gt; and normal generic types. This is potentially confusing today, but with enough magic language features from the future, Any *could* conceivably be made a library feature in the fullness of time:<br>&gt; <br>&gt; 	// Let&#39;s say &#39;protocol&#39; constraints indicate second-order constraint variables:<br>&gt; 	enum Any&lt;Constraints: protocol&gt; {<br>&gt; 		// And we have GADTs:<br>&gt; 		case value&lt;T: Constraints&gt;(T)<br>&gt; 	}<br>&gt; <br>&gt; 	// And we have user-defined value subtyping:<br>&gt; 	extension &lt;Constraints: protocol, T: Constraints&gt; T: Any&lt;Constraints&gt; { … }<br></p><p><br>The distinction loses its power.  Users can write other things that have similar behavior to `Any`.  In that world uppercase makes sense as the naming convention.  I don’t think we would want to use lowercase for all similar user-defined constructs.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are an additional five characters (including two angle brackets to type), but I suspect bare existentials aren&#39;t used quite as often as concrete types are, so the aesthetic cost might not be too onerous.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And also that code like:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   func foo&lt;X: Any&lt;Y, Z&gt;&gt;(x: X)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Would probably have to be written something like:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   func foo&lt;X: Y&gt;(x: X) where X: Z<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I also personally prefer this convention. The &#39;Any&lt;Y, Z&gt;&#39; construct in the constraint above does not really have anything to do with existential types as they exist everywhere else in Swift; it simply means that whatever concrete type can be used to instantiate the function must conform to two different protocols.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s true that any concrete type that could be used to satisfy X in foo() could also be used to fill an Any&lt;Y, Z&gt; existential, but this correspondence isn&#39;t interesting to the user. The ways a user can use an Any&lt;Y, Z&gt; existential differ from the ways a sort-of-universal type like X in foo() can be used:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // firstElement&#39;s type is known exactly at compile time, because X must be &#39;filled in&#39;<br>&gt;&gt;&gt;&gt; // by a concrete type, and that concrete type&#39;s associated types are also known.<br>&gt;&gt;&gt;&gt; foo&lt;X : Collection&gt;(x: X) {<br>&gt;&gt;&gt;&gt; let firstElement : X.Iterator.Element = x.first!<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // firstElement&#39;s type is not ever known without some sort of dynamic downcasting,<br>&gt;&gt;&gt;&gt; // because the contract that defines the existential can guarantee nothing about its type.<br>&gt;&gt;&gt;&gt; let foo : &lt;X : Collection&gt; = ...<br>&gt;&gt;&gt;&gt; let firstElement : Any = x.first!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; However, I believe this would have a significant advantage: it would clarify the distinction between an existential and a constraint. It would more clearly mark where you are taking on the abstraction overhead of an existential. It would also improve the non-existential type situation: in the short term, it would make it clearer where uses of associated type protocols like `Comparable` would not be permitted; in the long term, once we have type-erased existentials for those protocols, it would make it clearer when type erasure was in effect.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;   * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes. `protocol&lt;&gt;` is an ugly and unloved corner of the language; very few people know about it, remember it, or use it. The renaming improves this situation.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;   * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Given the way it enables many future features, yes.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;   * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The only language I&#39;ve used with similar features is Objective-C. There, too, the `&lt;&gt;` is overloaded, now that lightweight generics are part of the language.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;   * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;d like to think I have a fairly deep understanding of this feature, having participated heavily in the discussions about it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/ad81b455/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 27, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Am 25.05.2016 um 17:03 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On May 25, 2016, at 9:59 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 25, 2016, at 10:01 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am not going to comment on the proposal (conflict of interest etc). I do want to speak up in support of Brent&#39;s points, though.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 25, 2016, at 12:34 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I am in favor. This is a necessary step towards many future features: class-plus-protocol types, the replacement/reimplementation of AnyObject with Any&lt;class&gt;, existentials with associated types, etc.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One reason to prefer `Any` over `any` which is not listed in the proposal is confusion with the unparameterized `Any` type. Having an uppercase `Any` and a lowercase `any&lt;…&gt;` is going to lead to a lot of confusion; people aren&#39;t going to remember whether they need the capitalized form or the lowercase one for any particular use. I don&#39;t think we can have `any&lt;...&gt;` unless we&#39;re also willing to have an unparameterized `any`, and I think `any` is 100% wrong, because it is absolutely a type but is lowercase.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since we are trying to cram as many breaking changes as possible into Swift 3, I also think we should consider now, or soon, whether or not we want to draw a strong syntactic line between protocols-as-existentials and protocols-as-constraints by requiring the use of `Any&lt;…&gt;` on all existentials and forbidding its use in constraints. That would mean, for instance, that code like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   let printable: CustomStringConvertible = foo<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Would now be written:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   let printable: Any&lt;CustomStringConvertible&gt; = foo<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m sure this will be controversial, but I like the idea of marking all existential types using Any-syntax. It makes the distinction between concrete and existential types in code completely clear to the reader. Given that there are some subtle differences in how concrete and existential types can be used (for example, used as the types of values passed to generic functions), I think this is definitely worth considering.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Much of what I read about the swift philosophy seems to boil down to immediate association of the semantic with the syntax, to help the newcomer &#39;parse&#39; the language in their mind with less efforts. Seems to me that Any&lt;&gt; being so close to Array&lt;&gt; could be construed as running counter to that philosophy.<br>&gt; <br>&gt; This is a big part of the case for using lowercase `any`.  But there are good arguments on both sides.  In Joe’s hypothetical future Swift, `Any` would be a standard library type thus it wouldn’t have such a strong difference from Array.<br></p><p>The difference stems from the fact that the order of parameters does not matter in `Any` whereas it is essential for generic types.<br>Would this be changed by Joe’s vision?<br></p><p>-Thorsten<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/4bb2544a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 27, 2016, at 3:57 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Am 25.05.2016 um 17:03 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 25, 2016, at 9:59 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 25, 2016, at 10:01 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I am not going to comment on the proposal (conflict of interest etc). I do want to speak up in support of Brent&#39;s points, though.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 25, 2016, at 12:34 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;   * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I am in favor. This is a necessary step towards many future features: class-plus-protocol types, the replacement/reimplementation of AnyObject with Any&lt;class&gt;, existentials with associated types, etc.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One reason to prefer `Any` over `any` which is not listed in the proposal is confusion with the unparameterized `Any` type. Having an uppercase `Any` and a lowercase `any&lt;…&gt;` is going to lead to a lot of confusion; people aren&#39;t going to remember whether they need the capitalized form or the lowercase one for any particular use. I don&#39;t think we can have `any&lt;...&gt;` unless we&#39;re also willing to have an unparameterized `any`, and I think `any` is 100% wrong, because it is absolutely a type but is lowercase.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Since we are trying to cram as many breaking changes as possible into Swift 3, I also think we should consider now, or soon, whether or not we want to draw a strong syntactic line between protocols-as-existentials and protocols-as-constraints by requiring the use of `Any&lt;…&gt;` on all existentials and forbidding its use in constraints. That would mean, for instance, that code like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   let printable: CustomStringConvertible = foo<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Would now be written:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   let printable: Any&lt;CustomStringConvertible&gt; = foo<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m sure this will be controversial, but I like the idea of marking all existential types using Any-syntax. It makes the distinction between concrete and existential types in code completely clear to the reader. Given that there are some subtle differences in how concrete and existential types can be used (for example, used as the types of values passed to generic functions), I think this is definitely worth considering.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Much of what I read about the swift philosophy seems to boil down to immediate association of the semantic with the syntax, to help the newcomer &#39;parse&#39; the language in their mind with less efforts. Seems to me that Any&lt;&gt; being so close to Array&lt;&gt; could be construed as running counter to that philosophy.<br>&gt;&gt; <br>&gt;&gt; This is a big part of the case for using lowercase `any`.  But there are good arguments on both sides.  In Joe’s hypothetical future Swift, `Any` would be a standard library type thus it wouldn’t have such a strong difference from Array.<br>&gt; <br>&gt; The difference stems from the fact that the order of parameters does not matter in `Any` whereas it is essential for generic types.<br>&gt; Would this be changed by Joe’s vision?<br></p><p>I’m not sure.  Hopefully Joe can answer.  <br></p><p>I agree that indifference to order is important here and is an important difference from the generic types we have today.<br></p><p>&gt; <br>&gt; -Thorsten<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/fe863b60/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0095: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 27, 2016 at 04:00:00pm</p></header><div class="content"><p>Moving this review to where it belongs. Not sure who renamed it to SE–0089?!<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 27. Mai 2016 bei 16:58:16, Matthew Johnson via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p><br>On May 27, 2016, at 3:57 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br></p><p><br>Am 25.05.2016 um 17:03 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p><br>On May 25, 2016, at 9:59 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p><br>On May 25, 2016, at 10:01 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>I am not going to comment on the proposal (conflict of interest etc). I do want to speak up in support of Brent&#39;s points, though.<br></p><p>On May 25, 2016, at 12:34 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>  * What is your evaluation of the proposal?<br></p><p>I am in favor. This is a necessary step towards many future features: class-plus-protocol types, the replacement/reimplementation of AnyObject with Any&lt;class&gt;, existentials with associated types, etc.<br></p><p>One reason to prefer `Any` over `any` which is not listed in the proposal is confusion with the unparameterized `Any` type. Having an uppercase `Any` and a lowercase `any&lt;…&gt;` is going to lead to a lot of confusion; people aren&#39;t going to remember whether they need the capitalized form or the lowercase one for any particular use. I don&#39;t think we can have `any&lt;...&gt;` unless we&#39;re also willing to have an unparameterized `any`, and I think `any` is 100% wrong, because it is absolutely a type but is lowercase.<br></p><p>Since we are trying to cram as many breaking changes as possible into Swift 3, I also think we should consider now, or soon, whether or not we want to draw a strong syntactic line between protocols-as-existentials and protocols-as-constraints by requiring the use of `Any&lt;…&gt;` on all existentials and forbidding its use in constraints. That would mean, for instance, that code like this:<br></p><p>  let printable: CustomStringConvertible = foo<br></p><p>Would now be written:<br></p><p>  let printable: Any&lt;CustomStringConvertible&gt; = foo<br></p><p>I&#39;m sure this will be controversial, but I like the idea of marking all existential types using Any-syntax. It makes the distinction between concrete and existential types in code completely clear to the reader. Given that there are some subtle differences in how concrete and existential types can be used (for example, used as the types of values passed to generic functions), I think this is definitely worth considering.<br></p><p><br>Much of what I read about the swift philosophy seems to boil down to immediate association of the semantic with the syntax, to help the newcomer &#39;parse&#39; the language in their mind with less efforts. Seems to me that Any&lt;&gt; being so close to Array&lt;&gt; could be construed as running counter to that philosophy.<br></p><p>This is a big part of the case for using lowercase `any`.  But there are good arguments on both sides.  In Joe’s hypothetical future Swift, `Any` would be a standard library type thus it wouldn’t have such a strong difference from Array.<br></p><p>The difference stems from the fact that the order of parameters does not matter in `Any` whereas it is essential for generic types.<br>Would this be changed by Joe’s vision?<br></p><p>I’m not sure.  Hopefully Joe can answer.  <br></p><p>I agree that indifference to order is important here and is an important difference from the generic types we have today.<br></p><p><br>-Thorsten<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/b04d10a5/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 25, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 25, 2016, at 3:01 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I am not going to comment on the proposal (conflict of interest etc). I do want to speak up in support of Brent&#39;s points, though.<br>&gt; <br>&gt;&gt; On May 25, 2016, at 12:34 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; I am in favor. This is a necessary step towards many future features: class-plus-protocol types, the replacement/reimplementation of AnyObject with Any&lt;class&gt;, existentials with associated types, etc.<br>&gt;&gt; <br>&gt;&gt; One reason to prefer `Any` over `any` which is not listed in the proposal is confusion with the unparameterized `Any` type. Having an uppercase `Any` and a lowercase `any&lt;…&gt;` is going to lead to a lot of confusion; people aren&#39;t going to remember whether they need the capitalized form or the lowercase one for any particular use. I don&#39;t think we can have `any&lt;...&gt;` unless we&#39;re also willing to have an unparameterized `any`, and I think `any` is 100% wrong, because it is absolutely a type but is lowercase.<br>&gt;&gt; <br>&gt;&gt; Since we are trying to cram as many breaking changes as possible into Swift 3, I also think we should consider now, or soon, whether or not we want to draw a strong syntactic line between protocols-as-existentials and protocols-as-constraints by requiring the use of `Any&lt;…&gt;` on all existentials and forbidding its use in constraints. That would mean, for instance, that code like this:<br>&gt;&gt; <br>&gt;&gt; 	let printable: CustomStringConvertible = foo<br>&gt;&gt; <br>&gt;&gt; Would now be written:<br>&gt;&gt; <br>&gt;&gt; 	let printable: Any&lt;CustomStringConvertible&gt; = foo<br>&gt; <br>&gt; I&#39;m sure this will be controversial, but I like the idea of marking all existential types using Any-syntax. It makes the distinction between concrete and existential types in code completely clear to the reader. Given that there are some subtle differences in how concrete and existential types can be used (for example, used as the types of values passed to generic functions), I think this is definitely worth considering.<br>&gt; <br>&gt; There are an additional five characters (including two angle brackets to type), but I suspect bare existentials aren&#39;t used quite as often as concrete types are, so the aesthetic cost might not be too onerous.<br>&gt;&gt; <br>&gt;&gt; And also that code like:<br>&gt;&gt; <br>&gt;&gt; 	func foo&lt;X: Any&lt;Y, Z&gt;&gt;(x: X)<br>&gt;&gt; <br>&gt;&gt; Would probably have to be written something like:<br>&gt;&gt; <br>&gt;&gt; 	func foo&lt;X: Y&gt;(x: X) where X: Z<br>&gt; <br>&gt; I also personally prefer this convention. The &#39;Any&lt;Y, Z&gt;&#39; construct in the constraint above does not really have anything to do with existential types as they exist everywhere else in Swift; it simply means that whatever concrete type can be used to instantiate the function must conform to two different protocols.<br></p><p>I don’t mind banning the direct use of `Any` in constraints and agree that would be bad style.  But if we are going to remove the ability to use typealiases bound to `Any` in constraints we need to introduce an alternative mechanism for factoring out constraints (hopefully a superior mechanism that can abstract over constraints that relate generic parameters to each other).<br></p><p>&gt; <br>&gt; It&#39;s true that any concrete type that could be used to satisfy X in foo() could also be used to fill an Any&lt;Y, Z&gt; existential, but this correspondence isn&#39;t interesting to the user. The ways a user can use an Any&lt;Y, Z&gt; existential differ from the ways a sort-of-universal type like X in foo() can be used:<br>&gt; <br>&gt; // firstElement&#39;s type is known exactly at compile time, because X must be &#39;filled in&#39;<br>&gt; // by a concrete type, and that concrete type&#39;s associated types are also known.<br>&gt; foo&lt;X : Collection&gt;(x: X) {<br>&gt;  let firstElement : X.Iterator.Element = x.first!<br>&gt; }<br>&gt; <br>&gt; // firstElement&#39;s type is not ever known without some sort of dynamic downcasting,<br>&gt; // because the contract that defines the existential can guarantee nothing about its type.<br>&gt; let foo : &lt;X : Collection&gt; = ...<br>&gt; let firstElement : Any = x.first!<br>&gt; <br>&gt;&gt; <br>&gt;&gt; However, I believe this would have a significant advantage: it would clarify the distinction between an existential and a constraint. It would more clearly mark where you are taking on the abstraction overhead of an existential. It would also improve the non-existential type situation: in the short term, it would make it clearer where uses of associated type protocols like `Comparable` would not be permitted; in the long term, once we have type-erased existentials for those protocols, it would make it clearer when type erasure was in effect.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; <br>&gt;&gt; Yes. `protocol&lt;&gt;` is an ugly and unloved corner of the language; very few people know about it, remember it, or use it. The renaming improves this situation.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; Given the way it enables many future features, yes.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; <br>&gt;&gt; The only language I&#39;ve used with similar features is Objective-C. There, too, the `&lt;&gt;` is overloaded, now that lightweight generics are part of the language.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to think I have a fairly deep understanding of this feature, having participated heavily in the discussions about it.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/e534124c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 25, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; But if we are going to remove the ability to use typealiases bound to `Any` in constraints we need to introduce an alternative mechanism for factoring out constraints (hopefully a superior mechanism that can abstract over constraints that relate generic parameters to each other).<br></p><p>I could certainly imagine having, for instance, a `constraintalias` keyword:<br></p><p>	constraintalias HashableAndComparable = Hashable, Comparable<br>	constraintalias CollectionOfConforming&lt;ElementConstraint&gt; = Collection where .Element: ElementConstraint<br></p><p>	let value: Any&lt;HashableAndComparable&gt; = 123<br>	<br>	func sum&lt;C: CollectionOfConforming&lt;Integer&gt;&gt;(numbers: C) -&gt; C.Iterator.Element {<br>		return numbers.reduce(0, combine: +)<br>	}<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 25, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 25, 2016, at 2:22 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; But if we are going to remove the ability to use typealiases bound to `Any` in constraints we need to introduce an alternative mechanism for factoring out constraints (hopefully a superior mechanism that can abstract over constraints that relate generic parameters to each other).<br>&gt; <br>&gt; I could certainly imagine having, for instance, a `constraintalias` keyword:<br>&gt; <br>&gt; 	constraintalias HashableAndComparable = Hashable, Comparable<br>&gt; 	constraintalias CollectionOfConforming&lt;ElementConstraint&gt; = Collection where .Element: ElementConstraint<br>&gt; <br>&gt; 	let value: Any&lt;HashableAndComparable&gt; = 123<br>&gt; 	<br>&gt; 	func sum&lt;C: CollectionOfConforming&lt;Integer&gt;&gt;(numbers: C) -&gt; C.Iterator.Element {<br>&gt; 		return numbers.reduce(0, combine: +)<br>&gt; 	}<br></p><p>If we do something specific to generic constraints I would prefer to see something that generalizes to support cases where you want to accept two types that both conform to `Sequence`, `Collection`, etc and both have the same `Element` (or any other constraint that relates associated types from more than one type argument).  It could be similar to what you have, but slightly more generalized.<br></p><p><br>func sum<br>        &lt;T, C1, C2<br>        where C1: Sequence, C2: Sequence, C1.Iterator.Element == T, C2.Iterator.Element == T&gt;<br>        (c1: C1, c2: C2, op: (T, T) -&gt; T) -&gt; [T] {<br>        return zip(c1, c2).map(op)<br>}<br></p><p>This would allow me to write something along the lines of:<br></p><p>func zipMap<br>        &lt;S1, S2 where SameElementSequences&lt;S1, S2&gt;&gt;<br>        (s1:S1, s2: S2, op: (S1.Element, S2.Element) -&gt; S1.Element) -&gt; [S1.Element] {<br>        return zip(s1, s2).map(op)<br>}<br></p><p>So what syntax do we use to define something like `SameElementSequences&lt;S1, S2 &gt;`?  It is effectively a predicate that returns true if all of the constraints it defines are satisfied.  It could be similar to what you have above, but we would need to allow for more than one “constrainee”.<br></p><p>Maybe it would look something like this:<br></p><p>constraint SameElementSequences S1, S2 = <br>        S1: Sequence, S2: Sequence<br>        where S1.Element == S2.Element<br></p><p>If we want to allow concrete types and higher order constraints to be passed we would have to specify “kinds” for the arguments to the constraints.  We might say `Constrainee` for an argument that is getting constrained, `Type` for a concrete type argument and `Constraint` for a higher order constraint that applies to a single type and something like function type syntax for multi-argument higher order constraints: `(Type, Constrainee, Constraint) -&gt; Constraint` or something like that.<br></p><p>This would let us do something like:<br></p><p>constraint SequencesOf Element: Type, S1: Constrainee, S2: Constrainee =<br>        S1: Sequence, S2: Sequence<br>        where S1.Element == Element, S2.Element == Element<br></p><p>Used like this: <br></p><p>func intZipMap<br>        &lt;S1, S2 where SequencesOf&lt;Int, S1, S2&gt;&gt;<br>        (s1:S1, s2: S2, op: (Int) -&gt; Int) -&gt; [Int] {<br>        return zip(s1, s2).map(op)<br>}<br></p><p>We could allow shorthand for simple constraints where the “kinds” are omitted and assumed to be `Constrainee`.<br></p><p>Ideally we would be able to overload constraints so we could use the name “SequencesOf” for a constraint that accepts three sequences, etc.<br></p><p>I think I prefer `constraint` rather than `constraintalias` but am open to arguments for both of them.<br></p><p>I like that you are allowed a `constraintalias` to be used as an existential.  That would still work for single argument constraints in the generalized form I am suggesting.<br></p><p>I’m just spitballing on syntax and keyword names here to try and communicate the capability that I think we should strive for.  I’m interested in hearing everyone’s thoughts on this…<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 27, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; Am 25.05.2016 um 22:16 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On May 25, 2016, at 2:22 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; But if we are going to remove the ability to use typealiases bound to `Any` in constraints we need to introduce an alternative mechanism for factoring out constraints (hopefully a superior mechanism that can abstract over constraints that relate generic parameters to each other).<br>&gt;&gt; <br>&gt;&gt; I could certainly imagine having, for instance, a `constraintalias` keyword:<br>&gt;&gt; <br>&gt;&gt; 	constraintalias HashableAndComparable = Hashable, Comparable<br>&gt;&gt; 	constraintalias CollectionOfConforming&lt;ElementConstraint&gt; = Collection where .Element: ElementConstraint<br>&gt;&gt; <br>&gt;&gt; 	let value: Any&lt;HashableAndComparable&gt; = 123<br>&gt;&gt; 	<br>&gt;&gt; 	func sum&lt;C: CollectionOfConforming&lt;Integer&gt;&gt;(numbers: C) -&gt; C.Iterator.Element {<br>&gt;&gt; 		return numbers.reduce(0, combine: +)<br>&gt;&gt; 	}<br>&gt; <br>&gt; If we do something specific to generic constraints I would prefer to see something that generalizes to support cases where you want to accept two types that both conform to `Sequence`, `Collection`, etc and both have the same `Element` (or any other constraint that relates associated types from more than one type argument).  It could be similar to what you have, but slightly more generalized.<br>&gt; <br>&gt; <br>&gt; func sum<br>&gt;        &lt;T, C1, C2<br>&gt;        where C1: Sequence, C2: Sequence, C1.Iterator.Element == T, C2.Iterator.Element == T&gt;<br>&gt;        (c1: C1, c2: C2, op: (T, T) -&gt; T) -&gt; [T] {<br>&gt;        return zip(c1, c2).map(op)<br>&gt; }<br>&gt; <br>&gt; This would allow me to write something along the lines of:<br>&gt; <br>&gt; func zipMap<br>&gt;        &lt;S1, S2 where SameElementSequences&lt;S1, S2&gt;&gt;<br>&gt;        (s1:S1, s2: S2, op: (S1.Element, S2.Element) -&gt; S1.Element) -&gt; [S1.Element] {<br>&gt;        return zip(s1, s2).map(op)<br>&gt; }<br>&gt; <br>&gt; So what syntax do we use to define something like `SameElementSequences&lt;S1, S2 &gt;`?  It is effectively a predicate that returns true if all of the constraints it defines are satisfied.  It could be similar to what you have above, but we would need to allow for more than one “constrainee”.<br>&gt; <br>&gt; Maybe it would look something like this:<br>&gt; <br>&gt; constraint SameElementSequences S1, S2 = <br>&gt;        S1: Sequence, S2: Sequence<br>&gt;        where S1.Element == S2.Element<br></p><p>That’s a good example! Now this is beginning to make sense (or now I’m starting to understand it :-)<br></p><p><br>Side note: I would prefer zipMap being defined more generally which unfortunately renders this obsolete as an example for abstracted constraints as none are needed anymore:<br></p><p>func zipMap&lt;S1: Sequence, S2: Sequence, Result&gt;<br>	(s1: S1, s2: S2, op: (S1.Element, S2.Element) -&gt; Result) -&gt; [Result] {<br>	return zip(s1, s2).map(op)<br>}<br></p><p><br>But we might want to create a generic subtraction function like follows which could make use of the constraint you defined further down:<br></p><p>func subtract&lt;S1, S2, E where SequencesOf&lt;E, S1, S2&gt;, E: Equatable&gt;<br>	(s1: S1, s2: S2) -&gt; [E] {<br>	// answer array containing all elements of s1 which are not in s2<br>}<br></p><p>Note that `E` is not a concrete type argument here. I’m not sure whether it makes sense to distinguish between `Type` and `Constrainee` as these kinds are simply a result of supplying either a concrete type or a type parameter:<br></p><p>constraint SequencesOf&lt;Element, S1, S2&gt; =<br>       S1: Sequence, S2: Sequence<br>       where S1.Element == Element, S2.Element == Element<br></p><p>Regardless whether Element, S1 or S2 are concrete types or type parameters, the constraint can simply be checked whether it holds.<br></p><p><br>Maybe we could change the syntax a little bit:<br></p><p>constraint SequencesOf&lt;Element, S1, S2&gt; where S1: Sequence, S2: Sequence, S1.Element == Element, S2.Element == Element<br></p><p>which might alternatively be written as:<br></p><p>constraint SequencesOf&lt;Element, S1: Sequence, S2: Sequence&gt; where S1.Element == Element, S2.Element == Element<br></p><p><br>This would distinguish constraints better from typealiases. Otherwise a simple constraint would look like a typealias:<br></p><p>constraint SequenceOf&lt;Element, S&gt; = S where S: Sequence, Element == S.Element<br></p><p>vs.<br></p><p>constraint SequenceOf&lt;Element, S&gt; where S: Sequence, Element == S.Element<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt; If we want to allow concrete types and higher order constraints to be passed we would have to specify “kinds” for the arguments to the constraints.  We might say `Constrainee` for an argument that is getting constrained, `Type` for a concrete type argument and `Constraint` for a higher order constraint that applies to a single type and something like function type syntax for multi-argument higher order constraints: `(Type, Constrainee, Constraint) -&gt; Constraint` or something like that.<br>&gt; <br>&gt; This would let us do something like:<br>&gt; <br>&gt; constraint SequencesOf Element: Type, S1: Constrainee, S2: Constrainee =<br>&gt;        S1: Sequence, S2: Sequence<br>&gt;        where S1.Element == Element, S2.Element == Element<br>&gt; <br>&gt; Used like this: <br>&gt; <br>&gt; func intZipMap<br>&gt;        &lt;S1, S2 where SequencesOf&lt;Int, S1, S2&gt;&gt;<br>&gt;        (s1:S1, s2: S2, op: (Int) -&gt; Int) -&gt; [Int] {<br>&gt;        return zip(s1, s2).map(op)<br>&gt; }<br>&gt; <br>&gt; We could allow shorthand for simple constraints where the “kinds” are omitted and assumed to be `Constrainee`.<br>&gt; <br>&gt; Ideally we would be able to overload constraints so we could use the name “SequencesOf” for a constraint that accepts three sequences, etc.<br>&gt; <br>&gt; I think I prefer `constraint` rather than `constraintalias` but am open to arguments for both of them.<br>&gt; <br>&gt; I like that you are allowed a `constraintalias` to be used as an existential.  That would still work for single argument constraints in the generalized form I am suggesting.<br>&gt; <br>&gt; I’m just spitballing on syntax and keyword names here to try and communicate the capability that I think we should strive for.  I’m interested in hearing everyone’s thoughts on this…<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/e7bb3ec3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 27, 2016, at 7:08 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Am 25.05.2016 um 22:16 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 25, 2016, at 2:22 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But if we are going to remove the ability to use typealiases bound to `Any` in constraints we need to introduce an alternative mechanism for factoring out constraints (hopefully a superior mechanism that can abstract over constraints that relate generic parameters to each other).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I could certainly imagine having, for instance, a `constraintalias` keyword:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	constraintalias HashableAndComparable = Hashable, Comparable<br>&gt;&gt;&gt; 	constraintalias CollectionOfConforming&lt;ElementConstraint&gt; = Collection where .Element: ElementConstraint<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	let value: Any&lt;HashableAndComparable&gt; = 123<br>&gt;&gt;&gt; 	<br>&gt;&gt;&gt; 	func sum&lt;C: CollectionOfConforming&lt;Integer&gt;&gt;(numbers: C) -&gt; C.Iterator.Element {<br>&gt;&gt;&gt; 		return numbers.reduce(0, combine: +)<br>&gt;&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; If we do something specific to generic constraints I would prefer to see something that generalizes to support cases where you want to accept two types that both conform to `Sequence`, `Collection`, etc and both have the same `Element` (or any other constraint that relates associated types from more than one type argument).  It could be similar to what you have, but slightly more generalized.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; func sum<br>&gt;&gt;        &lt;T, C1, C2<br>&gt;&gt;        where C1: Sequence, C2: Sequence, C1.Iterator.Element == T, C2.Iterator.Element == T&gt;<br>&gt;&gt;        (c1: C1, c2: C2, op: (T, T) -&gt; T) -&gt; [T] {<br>&gt;&gt;        return zip(c1, c2).map(op)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This would allow me to write something along the lines of:<br>&gt;&gt; <br>&gt;&gt; func zipMap<br>&gt;&gt;        &lt;S1, S2 where SameElementSequences&lt;S1, S2&gt;&gt;<br>&gt;&gt;        (s1:S1, s2: S2, op: (S1.Element, S2.Element) -&gt; S1.Element) -&gt; [S1.Element] {<br>&gt;&gt;        return zip(s1, s2).map(op)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; So what syntax do we use to define something like `SameElementSequences&lt;S1, S2 &gt;`?  It is effectively a predicate that returns true if all of the constraints it defines are satisfied.  It could be similar to what you have above, but we would need to allow for more than one “constrainee”.<br>&gt;&gt; <br>&gt;&gt; Maybe it would look something like this:<br>&gt;&gt; <br>&gt;&gt; constraint SameElementSequences S1, S2 = <br>&gt;&gt;        S1: Sequence, S2: Sequence<br>&gt;&gt;        where S1.Element == S2.Element<br>&gt; <br>&gt; That’s a good example! Now this is beginning to make sense (or now I’m starting to understand it :-)<br></p><p>Great!<br></p><p>&gt; <br>&gt; <br>&gt; Side note: I would prefer zipMap being defined more generally which unfortunately renders this obsolete as an example for abstracted constraints as none are needed anymore:<br></p><p>Yeah, I wasn’t trying to provide the best / most general design for `zipMap`.  I chose a signature that would demonstrate how you might want to abstract over constraints that apply to more than one constrainee.  It was the first thing that came to mind.  :-)<br></p><p>&gt; <br>&gt; func zipMap&lt;S1: Sequence, S2: Sequence, Result&gt;<br>&gt; 	(s1: S1, s2: S2, op: (S1.Element, S2.Element) -&gt; Result) -&gt; [Result] {<br>&gt; 	return zip(s1, s2).map(op)<br>&gt; }<br>&gt; <br>&gt; <br>&gt; But we might want to create a generic subtraction function like follows which could make use of the constraint you defined further down:<br>&gt; <br>&gt; func subtract&lt;S1, S2, E where SequencesOf&lt;E, S1, S2&gt;, E: Equatable&gt;<br>&gt; 	(s1: S1, s2: S2) -&gt; [E] {<br>&gt; 	// answer array containing all elements of s1 which are not in s2<br>&gt; }<br>&gt; <br>&gt; Note that `E` is not a concrete type argument here. I’m not sure whether it makes sense to distinguish between `Type` and `Constrainee` as these kinds are simply a result of supplying either a concrete type or a type parameter:<br>&gt; <br>&gt; constraint SequencesOf&lt;Element, S1, S2&gt; =<br>&gt;        S1: Sequence, S2: Sequence<br>&gt;        where S1.Element == Element, S2.Element == Element<br>&gt; <br>&gt; Regardless whether Element, S1 or S2 are concrete types or type parameters, the constraint can simply be checked whether it holds.<br></p><p>The reason it matters is that you *must* pass something that can be constrained to a `Constrainee` argument.  You *cannot* pass a concrete type.  This could be inferred, but I think that would fall into the same category as inference across a function signature, which Swift is specifically avoiding.  Thus the “kind” specification.<br></p><p>&gt; <br>&gt; <br>&gt; Maybe we could change the syntax a little bit:<br>&gt; <br>&gt; constraint SequencesOf&lt;Element, S1, S2&gt; where S1: Sequence, S2: Sequence, S1.Element == Element, S2.Element == Element<br>&gt; <br>&gt; which might alternatively be written as:<br>&gt; <br>&gt; constraint SequencesOf&lt;Element, S1: Sequence, S2: Sequence&gt; where S1.Element == Element, S2.Element == Element<br>&gt; <br>&gt; <br>&gt; This would distinguish constraints better from typealiases. Otherwise a simple constraint would look like a typealias:<br>&gt; <br>&gt; constraint SequenceOf&lt;Element, S&gt; = S where S: Sequence, Element == S.Element<br>&gt; <br>&gt; vs.<br>&gt; <br>&gt; constraint SequenceOf&lt;Element, S&gt; where S: Sequence, Element == S.Element<br></p><p>I avoided angle brackets on the arguments because I think it’s more readable without them.  But there is a good case to be made that angle brackets should be used for compile-time parameters in Swift.  This syntax works for me.  <br></p><p>One thing that just occurred to me when looking at your example:<br></p><p>constraint SequencesOf&lt;Element, S1: Sequence, S2: Sequence&gt; where S1.Element == Element, S2.Element == Element<br></p><p>I wonder if we would ever need the ability to pass a constrained but concrete type to a constraint abstraction.  I can’t quickly think of any examples where we would.  If we don’t need the ability to do this, we could easily infer that `S1` and `S2` are of kind `Constrainee` because they are constrained in the signature.  We could also say that the default kind is `Type`.  This would minimize the need to state and think explicitly about kinds.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; If we want to allow concrete types and higher order constraints to be passed we would have to specify “kinds” for the arguments to the constraints.  We might say `Constrainee` for an argument that is getting constrained, `Type` for a concrete type argument and `Constraint` for a higher order constraint that applies to a single type and something like function type syntax for multi-argument higher order constraints: `(Type, Constrainee, Constraint) -&gt; Constraint` or something like that.<br>&gt;&gt; <br>&gt;&gt; This would let us do something like:<br>&gt;&gt; <br>&gt;&gt; constraint SequencesOf Element: Type, S1: Constrainee, S2: Constrainee =<br>&gt;&gt;        S1: Sequence, S2: Sequence<br>&gt;&gt;        where S1.Element == Element, S2.Element == Element<br>&gt;&gt; <br>&gt;&gt; Used like this: <br>&gt;&gt; <br>&gt;&gt; func intZipMap<br>&gt;&gt;        &lt;S1, S2 where SequencesOf&lt;Int, S1, S2&gt;&gt;<br>&gt;&gt;        (s1:S1, s2: S2, op: (Int) -&gt; Int) -&gt; [Int] {<br>&gt;&gt;        return zip(s1, s2).map(op)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; We could allow shorthand for simple constraints where the “kinds” are omitted and assumed to be `Constrainee`.<br>&gt;&gt; <br>&gt;&gt; Ideally we would be able to overload constraints so we could use the name “SequencesOf” for a constraint that accepts three sequences, etc.<br>&gt;&gt; <br>&gt;&gt; I think I prefer `constraint` rather than `constraintalias` but am open to arguments for both of them.<br>&gt;&gt; <br>&gt;&gt; I like that you are allowed a `constraintalias` to be used as an existential.  That would still work for single argument constraints in the generalized form I am suggesting.<br>&gt;&gt; <br>&gt;&gt; I’m just spitballing on syntax and keyword names here to try and communicate the capability that I think we should strive for.  I’m interested in hearing everyone’s thoughts on this…<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/e06c9243/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 27, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; Am 25.05.2016 um 21:22 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; But if we are going to remove the ability to use typealiases bound to `Any` in constraints we need to introduce an alternative mechanism for factoring out constraints (hopefully a superior mechanism that can abstract over constraints that relate generic parameters to each other).<br>&gt; <br>&gt; I could certainly imagine having, for instance, a `constraintalias` keyword:<br>&gt; <br>&gt; 	constraintalias HashableAndComparable = Hashable, Comparable<br>&gt; 	constraintalias CollectionOfConforming&lt;ElementConstraint&gt; = Collection where .Element: ElementConstraint<br></p><p>The second one is not really a constraintalias but a regular generic typealias making use of an abstracted constraint, isn’t it?<br></p><p>If we use `P &amp; Q` instead of `Any&lt;P, Q&gt;` and just `P` instead of `Any&lt;P&gt;` we not only avoid the confusion between `Any&lt;P&gt;` being the same as `P` in case of P not having associated types or self constraints, we also don’t have to distinguish between using existentials as types and constraints, and we don’t have to introduce something like constraintalias, because typealias is sufficient.<br></p><p>i.e.<br></p><p>typealias HashableAndComparable = Hashable &amp; Comparable<br></p><p>typealias CollectionOfConforming&lt;ElementConstraint&gt; = Collection where .Element: ElementConstraint<br></p><p>let a: HashableAndComparable = 123<br></p><p>let b: Hashable &amp; Comparable = 123<br></p><p>func sum&lt;C: CollectionOfConforming&lt;Integer&gt;&gt;(numbers: C) -&gt; C.Iterator.Element {<br>	return numbers.reduce(0, combine: +)<br>}<br></p><p>-Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 27, 2016 at 03:00:00pm</p></header><div class="content"><p>Support Thorsten&#39;s opinion. I believe P &amp; Q much more clear and expressive, <br>don&#39;t confuse if we should understand comma separation as &#39;and&#39; action or <br>&#39;or&#39; (in case Any&lt;P,Q&gt;) and don&#39;t confuse that &lt;P,Q&gt; is not a list of <br>gerenic types. Also such syntax is very lightweight and very readable and <br>understandable.<br></p><p>There was suggestions to introduce `class` `struct` `enum` keywords in <br>meaning &#39;any class&#39; &#39;any strict&#39; &#39;any enum&#39;. Could this work in the variant <br>with `&amp;` ?<br></p><p>let b: class &amp; Hashable = ..<br>func f(s: struct &amp; Comparable) {...}<br></p><p>etc<br></p><p>On 27.05.2016 14:16, Thorsten Seitz via swift-evolution wrote:<br>&gt;<br>&gt;&gt; Am 25.05.2016 um 21:22 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt;&gt; But if we are going to remove the ability to use typealiases bound to `Any` in constraints we need to introduce an alternative mechanism for factoring out constraints (hopefully a superior mechanism that can abstract over constraints that relate generic parameters to each other).<br>&gt;&gt;<br>&gt;&gt; I could certainly imagine having, for instance, a `constraintalias` keyword:<br>&gt;&gt;<br>&gt;&gt; 	constraintalias HashableAndComparable = Hashable, Comparable<br>&gt;&gt; 	constraintalias CollectionOfConforming&lt;ElementConstraint&gt; = Collection where .Element: ElementConstraint<br>&gt;<br>&gt; The second one is not really a constraintalias but a regular generic typealias making use of an abstracted constraint, isn’t it?<br>&gt;<br>&gt; If we use `P &amp; Q` instead of `Any&lt;P, Q&gt;` and just `P` instead of `Any&lt;P&gt;` we not only avoid the confusion between `Any&lt;P&gt;` being the same as `P` in case of P not having associated types or self constraints, we also don’t have to distinguish between using existentials as types and constraints, and we don’t have to introduce something like constraintalias, because typealias is sufficient.<br>&gt;<br>&gt; i.e.<br>&gt;<br>&gt; typealias HashableAndComparable = Hashable &amp; Comparable<br>&gt;<br>&gt; typealias CollectionOfConforming&lt;ElementConstraint&gt; = Collection where .Element: ElementConstraint<br>&gt;<br>&gt; let a: HashableAndComparable = 123<br>&gt;<br>&gt; let b: Hashable &amp; Comparable = 123<br>&gt;<br>&gt; func sum&lt;C: CollectionOfConforming&lt;Integer&gt;&gt;(numbers: C) -&gt; C.Iterator.Element {<br>&gt; 	return numbers.reduce(0, combine: +)<br>&gt; }<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 27, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Am 27.05.2016 um 14:13 schrieb Vladimir.S &lt;svabox at gmail.com&gt;:<br>&gt; <br>&gt; Support Thorsten&#39;s opinion. I believe P &amp; Q much more clear and expressive, don&#39;t confuse if we should understand comma separation as &#39;and&#39; action or &#39;or&#39; (in case Any&lt;P,Q&gt;) and don&#39;t confuse that &lt;P,Q&gt; is not a list of gerenic types. Also such syntax is very lightweight and very readable and understandable.<br>&gt; <br>&gt; There was suggestions to introduce `class` `struct` `enum` keywords in meaning &#39;any class&#39; &#39;any strict&#39; &#39;any enum&#39;. Could this work in the variant with `&amp;` ?<br>&gt; <br>&gt; let b: class &amp; Hashable = ..<br>&gt; func f(s: struct &amp; Comparable) {…}<br></p><p>Yes, that would be fine.<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt; etc<br>&gt; <br>&gt; On 27.05.2016 14:16, Thorsten Seitz via swift-evolution wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Am 25.05.2016 um 21:22 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But if we are going to remove the ability to use typealiases bound to `Any` in constraints we need to introduce an alternative mechanism for factoring out constraints (hopefully a superior mechanism that can abstract over constraints that relate generic parameters to each other).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I could certainly imagine having, for instance, a `constraintalias` keyword:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	constraintalias HashableAndComparable = Hashable, Comparable<br>&gt;&gt;&gt; 	constraintalias CollectionOfConforming&lt;ElementConstraint&gt; = Collection where .Element: ElementConstraint<br>&gt;&gt; <br>&gt;&gt; The second one is not really a constraintalias but a regular generic typealias making use of an abstracted constraint, isn’t it?<br>&gt;&gt; <br>&gt;&gt; If we use `P &amp; Q` instead of `Any&lt;P, Q&gt;` and just `P` instead of `Any&lt;P&gt;` we not only avoid the confusion between `Any&lt;P&gt;` being the same as `P` in case of P not having associated types or self constraints, we also don’t have to distinguish between using existentials as types and constraints, and we don’t have to introduce something like constraintalias, because typealias is sufficient.<br>&gt;&gt; <br>&gt;&gt; i.e.<br>&gt;&gt; <br>&gt;&gt; typealias HashableAndComparable = Hashable &amp; Comparable<br>&gt;&gt; <br>&gt;&gt; typealias CollectionOfConforming&lt;ElementConstraint&gt; = Collection where .Element: ElementConstraint<br>&gt;&gt; <br>&gt;&gt; let a: HashableAndComparable = 123<br>&gt;&gt; <br>&gt;&gt; let b: Hashable &amp; Comparable = 123<br>&gt;&gt; <br>&gt;&gt; func sum&lt;C: CollectionOfConforming&lt;Integer&gt;&gt;(numbers: C) -&gt; C.Iterator.Element {<br>&gt;&gt; 	return numbers.reduce(0, combine: +)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 27, 2016, at 6:16 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 25.05.2016 um 21:22 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; But if we are going to remove the ability to use typealiases bound to `Any` in constraints we need to introduce an alternative mechanism for factoring out constraints (hopefully a superior mechanism that can abstract over constraints that relate generic parameters to each other).<br>&gt;&gt; <br>&gt;&gt; I could certainly imagine having, for instance, a `constraintalias` keyword:<br>&gt;&gt; <br>&gt;&gt; 	constraintalias HashableAndComparable = Hashable, Comparable<br>&gt;&gt; 	constraintalias CollectionOfConforming&lt;ElementConstraint&gt; = Collection where .Element: ElementConstraint<br>&gt; <br>&gt; The second one is not really a constraintalias but a regular generic typealias making use of an abstracted constraint, isn’t it?<br>&gt; <br>&gt; If we use `P &amp; Q` instead of `Any&lt;P, Q&gt;` and just `P` instead of `Any&lt;P&gt;` we not only avoid the confusion between `Any&lt;P&gt;` being the same as `P` in case of P not having associated types or self constraints, we also don’t have to distinguish between using existentials as types and constraints, and we don’t have to introduce something like constraintalias, because typealias is sufficient.<br></p><p>Typealias is already sufficient anyway (try it today with a typealias of a protocol&lt;&gt; type).  IIUC Brent just wants to draw a stronger distinction between syntax you use for existential types and syntax you use for constraints.<br></p><p>One thing that is different from what is possible today in both of your examples is that you are passing a higher-order constraint.  That is really cool but it isn’t possible today and is somewhat orthogonal to the syntax used to describe existentials and I imagine it is down the road a ways further than generalized existentials.<br></p><p>&gt; <br>&gt; i.e.<br>&gt; <br>&gt; typealias HashableAndComparable = Hashable &amp; Comparable<br>&gt; <br>&gt; typealias CollectionOfConforming&lt;ElementConstraint&gt; = Collection where .Element: ElementConstraint<br>&gt; <br>&gt; let a: HashableAndComparable = 123<br>&gt; <br>&gt; let b: Hashable &amp; Comparable = 123<br>&gt; <br>&gt; func sum&lt;C: CollectionOfConforming&lt;Integer&gt;&gt;(numbers: C) -&gt; C.Iterator.Element {<br>&gt; 	return numbers.reduce(0, combine: +)<br>&gt; }<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 25, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; However, I believe this would have a significant advantage: it would clarify the distinction between an existential and a constraint. It would more clearly mark where you are taking on the abstraction overhead of an existential. It would also improve the non-existential type situation: in the short term, it would make it clearer where uses of associated type protocols like `Comparable` would not be permitted; in the long term, once we have type-erased existentials for those protocols, it would make it clearer when type erasure was in effect.<br></p><p>Sorry to self-reply, but I had some additional thoughts on this.<br></p><p>Swift&#39;s type system has a logical hierarchy of types. A type&#39;s supertypes include any protocols it conforms to, and then the protocols they conform to, ultimately rooted at Any. Additionally, a class&#39;s supertypes include its superclass, and then its superclass, and so on up to a root class, and then AnyObject, and finally Any once more. And of course, Any&lt;…&gt; lets you build composite types out of several protocols which fit into this framework: Any&lt;Foo, Bar&gt; is a subtype of both Foo and Bar and a supertype of any type which conforms to both Foo and Bar.<br></p><p>At an implementation level, however, this is only partially true. A class can be transformed into its superclass, all the way up to AnyObject, without any change in memory representation. But once you enter the world of protocols, everything changes. To cast to a protocol, you must place the instance in an existential, a different instance with a different memory layout. This can have significant performance consequences; for example, it&#39;s the reason you can&#39;t use `as` to convert an array of instances to an array of some protocol they all belong to.<br></p><p>Requiring the use of `Any&lt;…&gt;` to mark any existential would help reinforce this distinction. It would give users a better understanding of what their code was actually doing and why they might not be able to do things like make certain seemingly sensible casts.<br></p><p>(Although technically, this would seem to imply that AnyObject&#39;s future equivalent should *not* require an Any&lt;&gt;. Hmm.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>May 25, 2016 at 10:00:00am</p></header><div class="content"><p>I like the direction about creating a unified syntax for current<br>implementation of existentials and future generalized existentials.  I<br>am concerned about the chosen syntax though, I don&#39;t think it reads<br>right.  I read Any&lt;X, Y&gt; as a union type.<br></p><p>var x1: Any // OK, &#39;x1&#39; can have any dynamic type.<br>var x2: Any&lt;ErrorProtocol&gt; // OK, &#39;x2&#39; is any value that conforms to<br>ErrorProtocol.<br></p><p>var x3: Any&lt;Hashable, Comparable&gt; // &#39;x3&#39; is any of the following<br>types.  Either a Hashable, or a Comparable.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 25, 2016 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 25, 2016, at 12:28 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I like the direction about creating a unified syntax for current<br>&gt; implementation of existentials and future generalized existentials.  I<br>&gt; am concerned about the chosen syntax though, I don&#39;t think it reads<br>&gt; right.  I read Any&lt;X, Y&gt; as a union type.<br>&gt; <br>&gt; var x1: Any // OK, &#39;x1&#39; can have any dynamic type.<br>&gt; var x2: Any&lt;ErrorProtocol&gt; // OK, &#39;x2&#39; is any value that conforms to<br>&gt; ErrorProtocol.<br>&gt; <br>&gt; var x3: Any&lt;Hashable, Comparable&gt; // &#39;x3&#39; is any of the following<br>&gt; types.  Either a Hashable, or a Comparable.<br></p><p>Any suggestions? (pun intended) <br></p><p>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 25, 2016 at 09:00:00pm</p></header><div class="content"><p>On 25.05.2016 20:28, Dmitri Gribenko via swift-evolution wrote:<br>&gt; var x3: Any&lt;Hashable, Comparable&gt; // &#39;x3&#39; is any of the following<br>&gt; types.  Either a Hashable, or a Comparable.<br></p><p>Support that Any&lt;Some, Another&gt; could be confusing and could be read as <br>&quot;any Some or any Another&quot;. Although as I understand there is no support for <br>this, I probably think this is more clear:<br></p><p>var x3: Any&lt;Hashable &amp; Comparable&gt;<br></p><p>and reads like a poem ;-) &quot;any that is hashable AND comparable&quot;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0095: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June  1, 2016 at 09:00:00am</p></header><div class="content"><p>[Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md&gt; ]<br></p><p>I’m late again to this one, but the discussion’s certainly still going. I’m pretty strongly against the bare ‘A &amp; B’ syntax, for a few reasons:<br></p><p>- Swift doesn’t use ‘&amp;’ for anything except bitwise AND. In particular, it didn’t get picked for set intersection.<br></p><p>- In theory people are allowed to overload ‘&amp;’ to operate on types. That doesn’t make sense for all types, but you could probably come up with a particular type hierarchy or use of generics where it does make sense.<br></p><p>- I don’t like types with spaces in them when the spaces aren’t bracketed in some way. This is entirely an aesthetic objection, of the form “I don’t naturally read that as a type, or even as a single unit, when looking at code.” This isn’t a great objection because someone could have said it about `[Int]` or `Int?` as well. (It would be a more realistic objection if some of our brackets weren’t “&lt;&quot; and “&gt;”.)<br></p><p>And I still support the ‘Any’ syntax, despite the “order doesn’t matter” problem:<br></p><p>- It’s consistent with the existing unconstrained ‘Any’ and with the current dedicated wrapper types. If we didn’t think it was a good name for those, we wouldn’t use it there either.<br></p><p>- It’s easily learnable. It’s rare enough that someone wouldn’t be exposed to it right away, like Optional, Array, and Dictionary sugar, but when they do see it it’ll be obvious that it’s a type, and probably obvious that it’s special because of the “Any”.<br></p><p>- It’s a type; types always start with uppercase letters. (This has been said plenty by others.)<br></p><p>None of these are particularly strong arguments, I know, and I don’t have a good alternate suggestion. But I did want to go on record as being in favor of ‘Any’ and against a binary operator, even though that seems to put me in the minority.<br></p><p>Jordan<br></p><p><br></p><p>&gt; On May 24, 2016, at 11:06, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0089: Replace protocol&lt;P1,P2&gt; syntax with Any&lt;P1,P2&gt;&quot; begins now and runs through May 30. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/8d57894f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0095: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  1, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; [Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md ]<br>&gt; <br>&gt; I’m late again to this one, but the discussion’s certainly still going. I’m pretty strongly against the bare ‘A &amp; B’ syntax, for a few reasons:<br>&gt; <br>&gt; - Swift doesn’t use ‘&amp;’ for anything except bitwise AND. In particular, it didn’t get picked for set intersection.<br></p><p>I very, *very* much agree with this point. Thus far, Swift has been very conservative about overloading. It seems bizarre that we would violate that policy for these type combinators when much closer matches have been passed over.<br></p><p>I also think that using `&amp;` absolutely *begs* to have an `|` as well, and as much as the Ceylon people clamor for them, I don&#39;t think union types make sense in Swift. Unlike Ceylon, Swift uses an algebraic data type for Optional, doesn&#39;t use type-erased generics, and supports overloading. As far as I can tell, *none* of the reasons cited in the Ceylon language design FAQ &lt;http://ceylon-lang.org/documentation/1.2/faq/language-design/&gt; apply to Swift.<br></p><p>(P.S. That language design FAQ is a *fantastic* document.)<br></p><p>&gt; - In theory people are allowed to overload ‘&amp;’ to operate on types. That doesn’t make sense for all types, but you could probably come up with a particular type hierarchy or use of generics where it does make sense.<br>&gt; <br>&gt; - I don’t like types with spaces in them when the spaces aren’t bracketed in some way. This is entirely an aesthetic objection, of the form “I don’t naturally read that as a type, or even as a single unit, when looking at code.” This isn’t a great objection because someone could have said it about `[Int]` or `Int?` as well. (It would be a more realistic objection if some of our brackets weren’t “&lt;&quot; and “&gt;”.)<br></p><p>To augment this: I think that if we&#39;re going to see a lot of little `where` clauses attached to types, you kind of have to have a bracketing syntax to put them in. And no, `(Collection where .Element == String)` doesn&#39;t count. `()` is about precedence, and this isn&#39;t a question of precedence; it&#39;s a question of making the type read as a single unit.<br></p><p>&gt; And I still support the ‘Any’ syntax, despite the “order doesn’t matter” problem:<br>&gt; <br>&gt; - It’s consistent with the existing unconstrained ‘Any’ and with the current dedicated wrapper types. If we didn’t think it was a good name for those, we wouldn’t use it there either.<br></p><p>One of my concerns with the `&amp;` syntax is that it leaves no good way to define `Any`. I don&#39;t like having a magic `&amp;` operator *and* a magic `Any` keyword, neither of which derives from anything more general.<br></p><p>&gt; - It’s easily learnable. It’s rare enough that someone wouldn’t be exposed to it right away, like Optional, Array, and Dictionary sugar, but when they do see it it’ll be obvious that it’s a type, and probably obvious that it’s special because of the “Any”.<br>&gt; <br>&gt; - It’s a type; types always start with uppercase letters. (This has been said plenty by others.)<br>&gt; <br>&gt; None of these are particularly strong arguments, I know, and I don’t have a good alternate suggestion. But I did want to go on record as being in favor of ‘Any’ and against a binary operator, even though that seems to put me in the minority.<br></p><p>I suspect that at least part of this is simply greater enthusiasm. I know I checked out of this thread for a few days while the `&amp;` guys ran rampant.<br></p><p>(P.S. A thought I had just now: If `Any` is our top type, then `All` would be a good name for our bottom type. And `All&lt;Foo, Bar&gt;` would be a good &quot;All common supertypes of these types&quot; operation. Both of these came up in the variadic generics thread, where we were talking about how to create a type representing any member of a tuple you were trying to splat in.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0095: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  1, 2016 at 02:00:00pm</p></header><div class="content"><p>After thinking about this topic for the past few days, I&#39;d like to throw in<br>my support for &quot;Any&lt;&gt;&quot; as well. It&#39;s one magic construct to learn, looks<br>like a type, has the visual delineation, and shares continuity with both<br>protocol&lt;&gt; and Any today.<br></p><p>I&#39;d also like to express my support for the proposal to delineate generic<br>and existential syntax: all existentials must be written with Any&lt;...&gt;;<br>generic type constraints cannot use it. I hope this will make it clear to<br>people learning and using the language that, despite their superficial<br>similarities, they are actually two different concepts.<br></p><p>Austin<br></p><p><br>On Wed, Jun 1, 2016 at 1:59 PM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; [Proposal:<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md<br>&gt; ]<br>&gt; &gt;<br>&gt; &gt; I’m late again to this one, but the discussion’s certainly still going.<br>&gt; I’m pretty strongly against the bare ‘A &amp; B’ syntax, for a few reasons:<br>&gt; &gt;<br>&gt; &gt; - Swift doesn’t use ‘&amp;’ for anything except bitwise AND. In particular,<br>&gt; it didn’t get picked for set intersection.<br>&gt;<br>&gt; I very, *very* much agree with this point. Thus far, Swift has been very<br>&gt; conservative about overloading. It seems bizarre that we would violate that<br>&gt; policy for these type combinators when much closer matches have been passed<br>&gt; over.<br>&gt;<br>&gt; I also think that using `&amp;` absolutely *begs* to have an `|` as well, and<br>&gt; as much as the Ceylon people clamor for them, I don&#39;t think union types<br>&gt; make sense in Swift. Unlike Ceylon, Swift uses an algebraic data type for<br>&gt; Optional, doesn&#39;t use type-erased generics, and supports overloading. As<br>&gt; far as I can tell, *none* of the reasons cited in the Ceylon language<br>&gt; design FAQ &lt;http://ceylon-lang.org/documentation/1.2/faq/language-design/&gt;<br>&gt; apply to Swift.<br>&gt;<br>&gt; (P.S. That language design FAQ is a *fantastic* document.)<br>&gt;<br>&gt; &gt; - In theory people are allowed to overload ‘&amp;’ to operate on types. That<br>&gt; doesn’t make sense for all types, but you could probably come up with a<br>&gt; particular type hierarchy or use of generics where it does make sense.<br>&gt; &gt;<br>&gt; &gt; - I don’t like types with spaces in them when the spaces aren’t<br>&gt; bracketed in some way. This is entirely an aesthetic objection, of the form<br>&gt; “I don’t naturally read that as a type, or even as a single unit, when<br>&gt; looking at code.” This isn’t a great objection because someone could have<br>&gt; said it about `[Int]` or `Int?` as well. (It would be a more realistic<br>&gt; objection if some of our brackets weren’t “&lt;&quot; and “&gt;”.)<br>&gt;<br>&gt; To augment this: I think that if we&#39;re going to see a lot of little<br>&gt; `where` clauses attached to types, you kind of have to have a bracketing<br>&gt; syntax to put them in. And no, `(Collection where .Element == String)`<br>&gt; doesn&#39;t count. `()` is about precedence, and this isn&#39;t a question of<br>&gt; precedence; it&#39;s a question of making the type read as a single unit.<br>&gt;<br>&gt; &gt; And I still support the ‘Any’ syntax, despite the “order doesn’t matter”<br>&gt; problem:<br>&gt; &gt;<br>&gt; &gt; - It’s consistent with the existing unconstrained ‘Any’ and with the<br>&gt; current dedicated wrapper types. If we didn’t think it was a good name for<br>&gt; those, we wouldn’t use it there either.<br>&gt;<br>&gt; One of my concerns with the `&amp;` syntax is that it leaves no good way to<br>&gt; define `Any`. I don&#39;t like having a magic `&amp;` operator *and* a magic `Any`<br>&gt; keyword, neither of which derives from anything more general.<br>&gt;<br>&gt; &gt; - It’s easily learnable. It’s rare enough that someone wouldn’t be<br>&gt; exposed to it right away, like Optional, Array, and Dictionary sugar, but<br>&gt; when they do see it it’ll be obvious that it’s a type, and probably obvious<br>&gt; that it’s special because of the “Any”.<br>&gt; &gt;<br>&gt; &gt; - It’s a type; types always start with uppercase letters. (This has been<br>&gt; said plenty by others.)<br>&gt; &gt;<br>&gt; &gt; None of these are particularly strong arguments, I know, and I don’t<br>&gt; have a good alternate suggestion. But I did want to go on record as being<br>&gt; in favor of ‘Any’ and against a binary operator, even though that seems to<br>&gt; put me in the minority.<br>&gt;<br>&gt; I suspect that at least part of this is simply greater enthusiasm. I know<br>&gt; I checked out of this thread for a few days while the `&amp;` guys ran rampant.<br>&gt;<br>&gt; (P.S. A thought I had just now: If `Any` is our top type, then `All` would<br>&gt; be a good name for our bottom type. And `All&lt;Foo, Bar&gt;` would be a good<br>&gt; &quot;All common supertypes of these types&quot; operation. Both of these came up in<br>&gt; the variadic generics thread, where we were talking about how to create a<br>&gt; type representing any member of a tuple you were trying to splat in.)<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/743c1ec2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0095: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  1, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 1, 2016, at 4:18 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; After thinking about this topic for the past few days, I&#39;d like to throw in my support for &quot;Any&lt;&gt;&quot; as well. It&#39;s one magic construct to learn, looks like a type, has the visual delineation, and shares continuity with both protocol&lt;&gt; and Any today.<br>&gt; <br>&gt; I&#39;d also like to express my support for the proposal to delineate generic and existential syntax: all existentials must be written with Any&lt;...&gt;; generic type constraints cannot use it. I hope this will make it clear to people learning and using the language that, despite their superficial similarities, they are actually two different concepts.<br></p><p>I&#39;m neutral on the syntax.  But I strongly believe removing the ability to use protocol / Any in generic constraints *must* be accompanied by the introduction of a new (hopefully more robust) mechanism for factoring out common generic constraints.<br></p><p>&gt; <br>&gt; Austin<br>&gt; <br>&gt; <br>&gt;&gt; On Wed, Jun 1, 2016 at 1:59 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; [Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md ]<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I’m late again to this one, but the discussion’s certainly still going. I’m pretty strongly against the bare ‘A &amp; B’ syntax, for a few reasons:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; - Swift doesn’t use ‘&amp;’ for anything except bitwise AND. In particular, it didn’t get picked for set intersection.<br>&gt;&gt; <br>&gt;&gt; I very, *very* much agree with this point. Thus far, Swift has been very conservative about overloading. It seems bizarre that we would violate that policy for these type combinators when much closer matches have been passed over.<br>&gt;&gt; <br>&gt;&gt; I also think that using `&amp;` absolutely *begs* to have an `|` as well, and as much as the Ceylon people clamor for them, I don&#39;t think union types make sense in Swift. Unlike Ceylon, Swift uses an algebraic data type for Optional, doesn&#39;t use type-erased generics, and supports overloading. As far as I can tell, *none* of the reasons cited in the Ceylon language design FAQ &lt;http://ceylon-lang.org/documentation/1.2/faq/language-design/&gt; apply to Swift.<br>&gt;&gt; <br>&gt;&gt; (P.S. That language design FAQ is a *fantastic* document.)<br>&gt;&gt; <br>&gt;&gt; &gt; - In theory people are allowed to overload ‘&amp;’ to operate on types. That doesn’t make sense for all types, but you could probably come up with a particular type hierarchy or use of generics where it does make sense.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; - I don’t like types with spaces in them when the spaces aren’t bracketed in some way. This is entirely an aesthetic objection, of the form “I don’t naturally read that as a type, or even as a single unit, when looking at code.” This isn’t a great objection because someone could have said it about `[Int]` or `Int?` as well. (It would be a more realistic objection if some of our brackets weren’t “&lt;&quot; and “&gt;”.)<br>&gt;&gt; <br>&gt;&gt; To augment this: I think that if we&#39;re going to see a lot of little `where` clauses attached to types, you kind of have to have a bracketing syntax to put them in. And no, `(Collection where .Element == String)` doesn&#39;t count. `()` is about precedence, and this isn&#39;t a question of precedence; it&#39;s a question of making the type read as a single unit.<br>&gt;&gt; <br>&gt;&gt; &gt; And I still support the ‘Any’ syntax, despite the “order doesn’t matter” problem:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; - It’s consistent with the existing unconstrained ‘Any’ and with the current dedicated wrapper types. If we didn’t think it was a good name for those, we wouldn’t use it there either.<br>&gt;&gt; <br>&gt;&gt; One of my concerns with the `&amp;` syntax is that it leaves no good way to define `Any`. I don&#39;t like having a magic `&amp;` operator *and* a magic `Any` keyword, neither of which derives from anything more general.<br>&gt;&gt; <br>&gt;&gt; &gt; - It’s easily learnable. It’s rare enough that someone wouldn’t be exposed to it right away, like Optional, Array, and Dictionary sugar, but when they do see it it’ll be obvious that it’s a type, and probably obvious that it’s special because of the “Any”.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; - It’s a type; types always start with uppercase letters. (This has been said plenty by others.)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; None of these are particularly strong arguments, I know, and I don’t have a good alternate suggestion. But I did want to go on record as being in favor of ‘Any’ and against a binary operator, even though that seems to put me in the minority.<br>&gt;&gt; <br>&gt;&gt; I suspect that at least part of this is simply greater enthusiasm. I know I checked out of this thread for a few days while the `&amp;` guys ran rampant.<br>&gt;&gt; <br>&gt;&gt; (P.S. A thought I had just now: If `Any` is our top type, then `All` would be a good name for our bottom type. And `All&lt;Foo, Bar&gt;` would be a good &quot;All common supertypes of these types&quot; operation. Both of these came up in the variadic generics thread, where we were talking about how to create a type representing any member of a tuple you were trying to splat in.)<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/60f07321/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0095: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June  1, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jun 1, 2016, at 14:18, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; I&#39;d also like to express my support for the proposal to delineate generic and existential syntax: all existentials must be written with Any&lt;...&gt;; generic type constraints cannot use it. I hope this will make it clear to people learning and using the language that, despite their superficial similarities, they are actually two different concepts.<br></p><p>This is definitely getting off-topic for this particular review, but I’ve come to agree with you. I can only speak for myself, but back when we were implementing protocols in Swift it felt great to eliminate the wedge between ’NSTableView *’ and ‘id &lt;NSTableViewDelegate&gt;’. But then we started using protocols for many more things in Swift, and it turns out that the simple use case of “I have a protocol-typed property” isn’t really the one worth optimizing for anymore. When they’re arguments, you more often than not might want to use them generically, and you should at least be thinking about that when you define a function.<br></p><p>Where we are today, the protocol-typed value is the obvious choice, and then you move to generics when the compiler tells you no. Having the choice be between these two:<br></p><p>func foo&lt;T: SignedInteger&gt;(value: T)<br>func foo(value: Any&lt;SignedInteger&gt;)<br></p><p>makes it a little more likely that someone will stop and think about picking the first.<br></p><p>(Then again, Joe’s talked about making the second use the ABI of the first anyway as an optimization, though that can backfire if the value is copied around a lot.)<br></p><p>I suppose a middle ground would restrict the protocol-name-only syntax to class-bound protocols, which are the most likely to be used in properties (“delegate-like protocols”). I’d be hesitant to restrict to “class-bound protocols without associated types” because we want adding an associated type to be a non-breaking change &lt;http://jrose-apple.github.io/swift-library-evolution/#protocols&gt; (if we can figure out how to do it).<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/4cc6d26d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
