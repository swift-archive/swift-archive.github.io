<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/71784126c20615c242e2fa11dc33e613?s=50"></div><header><strong>Proposal: Enum &#39;count&#39; functionality</strong> from <string>Andyy Hope</string> &lt;andyyhopedev at me.com&gt;<p>December 21, 2015 at 07:00:00pm</p></header><div class="content"><p>Hi Swift Team and Community<br></p><p>I’ve put a proposal up on GitHub to add a cases ‘count’ functionality to Enums for the Swift language<br>https://gist.github.com/andyyhope/2fc5b6bee8ee1346f688<br></p><p><br>Comments, feedback, scenario appends very much welcomed. Thank you<br></p><p>-- <br>Andyy Hope<br>iOS Developer, Melbourne<br>@andyyhope<br>andyyhope.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/cce38a6f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: Enum &#39;count&#39; functionality</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 21, 2015 at 12:00:00am</p></header><div class="content"><p>&gt; I’ve put a proposal up on GitHub to add a cases ‘count’ functionality to Enums for the Swift language<br>&gt; https://gist.github.com/andyyhope/2fc5b6bee8ee1346f688<br></p><p>I think we&#39;d be much better off having a list of all cases. That would make this feature useful for enums which don&#39;t have a raw type, or don&#39;t use Int as their raw type, or don&#39;t use sequential raw values for their cases.<br></p><p>That approach has been discussed before, but not formally proposed.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>Proposal: Enum &#39;count&#39; functionality</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>December 21, 2015 at 12:00:00am</p></header><div class="content"><p>If you change your proposal to focus on &quot;.values&quot; instead<br>of &quot;.values.count&quot; (which you&#39;d get for free, as you note) I would strongly<br>support it. I don&#39;t need &quot;.count&quot; on its own, but &quot;.values&quot; ... well, I<br>have a whole load of enums in my current projects with a &quot;.values&quot; I had to<br>hardcode myself. I would love to get that for free.<br></p><p>On Mon, Dec 21, 2015 at 12:46 AM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; I’ve put a proposal up on GitHub to add a cases ‘count’ functionality to<br>&gt; Enums for the Swift language<br>&gt; &gt; https://gist.github.com/andyyhope/2fc5b6bee8ee1346f688<br>&gt;<br>&gt; I think we&#39;d be much better off having a list of all cases. That would<br>&gt; make this feature useful for enums which don&#39;t have a raw type, or don&#39;t<br>&gt; use Int as their raw type, or don&#39;t use sequential raw values for their<br>&gt; cases.<br>&gt;<br>&gt; That approach has been discussed before, but not formally proposed.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/cccfde4a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Proposal: Enum &#39;count&#39; functionality</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December 21, 2015 at 10:00:00am</p></header><div class="content"><p>Does the naming &quot;values&quot; have precedence elsewhere? To me, &quot;cases&quot; is clearer, whereas &quot;rawValues&quot; would make sense if there was an additional, auto-generated static property for enumerations with underlying values.<br></p><p>    enum Section: Int { case SectionA, Section B }<br>    Section.cases // [.SectionA, .SectionB]<br>    Section.rawValues // [0, 1]<br></p><p>Because &quot;rawValue&quot; already exists, &quot;values&quot; makes things a bit more confusing: are they the cases themselves or are they their underlying values?<br></p><p>Stephen<br></p><p>&gt; On Dec 21, 2015, at 3:57 AM, Charles Constant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If you change your proposal to focus on &quot;.values&quot; instead of &quot;.values.count&quot; (which you&#39;d get for free, as you note) I would strongly support it. I don&#39;t need &quot;.count&quot; on its own, but &quot;.values&quot; ... well, I have a whole load of enums in my current projects with a &quot;.values&quot; I had to hardcode myself. I would love to get that for free.<br>&gt; <br>&gt; On Mon, Dec 21, 2015 at 12:46 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; I’ve put a proposal up on GitHub to add a cases ‘count’ functionality to Enums for the Swift language<br>&gt; &gt; https://gist.github.com/andyyhope/2fc5b6bee8ee1346f688 &lt;https://gist.github.com/andyyhope/2fc5b6bee8ee1346f688&gt;<br>&gt; <br>&gt; I think we&#39;d be much better off having a list of all cases. That would make this feature useful for enums which don&#39;t have a raw type, or don&#39;t use Int as their raw type, or don&#39;t use sequential raw values for their cases.<br>&gt; <br>&gt; That approach has been discussed before, but not formally proposed.<br>&gt; <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/dc8681fe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>Proposal: Enum &#39;count&#39; functionality</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>December 21, 2015 at 11:00:00am</p></header><div class="content"><p>Would .cases return the enum’s cases in source-code order? That seems<br>fragile at first glance.<br></p><p>It might be worth considering to have it return an unordered collection<br>(set) instead.<br></p><p>Nevin<br></p><p><br>On Mon, Dec 21, 2015 at 10:52 AM, Stephen Celis via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Does the naming &quot;values&quot; have precedence elsewhere? To me, &quot;cases&quot; is<br>&gt; clearer, whereas &quot;rawValues&quot; would make sense if there was an additional,<br>&gt; auto-generated static property for enumerations with underlying values.<br>&gt;<br>&gt;     enum Section: Int { case SectionA, Section B }<br>&gt;     Section.cases // [.SectionA, .SectionB]<br>&gt;     Section.rawValues // [0, 1]<br>&gt;<br>&gt; Because &quot;rawValue&quot; already exists, &quot;values&quot; makes things a bit more<br>&gt; confusing: are they the cases themselves or are they their underlying<br>&gt; values?<br>&gt;<br>&gt; Stephen<br>&gt;<br>&gt; On Dec 21, 2015, at 3:57 AM, Charles Constant via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; If you change your proposal to focus on &quot;.values&quot; instead<br>&gt; of &quot;.values.count&quot; (which you&#39;d get for free, as you note) I would strongly<br>&gt; support it. I don&#39;t need &quot;.count&quot; on its own, but &quot;.values&quot; ... well, I<br>&gt; have a whole load of enums in my current projects with a &quot;.values&quot; I had to<br>&gt; hardcode myself. I would love to get that for free.<br>&gt;<br>&gt; On Mon, Dec 21, 2015 at 12:46 AM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; I’ve put a proposal up on GitHub to add a cases ‘count’ functionality<br>&gt;&gt; to Enums for the Swift language<br>&gt;&gt; &gt; https://gist.github.com/andyyhope/2fc5b6bee8ee1346f688<br>&gt;&gt;<br>&gt;&gt; I think we&#39;d be much better off having a list of all cases. That would<br>&gt;&gt; make this feature useful for enums which don&#39;t have a raw type, or don&#39;t<br>&gt;&gt; use Int as their raw type, or don&#39;t use sequential raw values for their<br>&gt;&gt; cases.<br>&gt;&gt;<br>&gt;&gt; That approach has been discussed before, but not formally proposed.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/148b4ca6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Proposal: Enum &#39;count&#39; functionality</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December 21, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 11:27 AM, Nevin Brackett-Rozinsky &lt;nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt; <br>&gt; Would .cases return the enum’s cases in source-code order? That seems fragile at first glance.<br>&gt; <br>&gt; It might be worth considering to have it return an unordered collection (set) instead.<br></p><p>Care to elaborate on why you think it may be fragile?<br></p><p>Retaining order makes sense to me given that integer-backed enumerations auto-increment and that enumerations cannot be extended with new cases. I&#39;m not opposed to using a set, though, if that makes more sense.<br></p><p>Stephen<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/caa2d516/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Proposal: Enum &#39;count&#39; functionality</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December 21, 2015 at 11:00:00am</p></header><div class="content"><p>I brought up this topic a couple weeks ago in a thread called &quot;List of all<br>Enum values (for simple enums)&quot;:<br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001233.html<br></p><p>I suppose it&#39;s time to start synthesizing those ideas/discussion into a<br>proposal :)<br></p><p>Jacob<br></p><p>On Mon, Dec 21, 2015 at 8:35 AM, Stephen Celis via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Dec 21, 2015, at 11:27 AM, Nevin Brackett-Rozinsky &lt;<br>&gt; nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt;<br>&gt; Would .cases return the enum’s cases in source-code order? That seems<br>&gt; fragile at first glance.<br>&gt;<br>&gt; It might be worth considering to have it return an unordered collection<br>&gt; (set) instead.<br>&gt;<br>&gt;<br>&gt; Care to elaborate on why you think it may be fragile?<br>&gt;<br>&gt; Retaining order makes sense to me given that integer-backed enumerations<br>&gt; auto-increment and that enumerations cannot be extended with new cases. I&#39;m<br>&gt; not opposed to using a set, though, if that makes more sense.<br>&gt;<br>&gt; Stephen<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/dbaa37d3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Proposal: Enum &#39;count&#39; functionality</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 21, 2015 at 01:00:00pm</p></header><div class="content"><p>My wild aspirations in a nutshell:<br></p><p>Core enums:  Any enum that&#39;s created without raw or associated values, e.g. enum MyEnum {case This, That, Whatever, Etc},  can (and should) be Array&lt;Self&gt; representable. This would add intrinsic ordering and raw value construction starting with 0, up to count - 1. End-devs could use the ordering or not use the ordering, but it would be possible to convert to bit representation (1 &lt;&lt; this.rawValue),  support iteration through the enumeration, introduce ranges for switches, etc. A massive improvement.<br></p><p>Raw value enums: Any enum that uses raw values, e.g. enum ForExample: String {case Hello = &quot;hello&quot;, There = &quot;there&quot;} should be representable as Set&lt;T&gt;<br></p><p>Associated type enums: all bets are off<br></p><p>-- E<br></p><p>&gt; On Dec 21, 2015, at 12:52 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I brought up this topic a couple weeks ago in a thread called &quot;List of all Enum values (for simple enums)&quot;:<br>&gt; <br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001233.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001233.html&gt;<br>&gt; <br>&gt; I suppose it&#39;s time to start synthesizing those ideas/discussion into a proposal :)<br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Mon, Dec 21, 2015 at 8:35 AM, Stephen Celis via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; On Dec 21, 2015, at 11:27 AM, Nevin Brackett-Rozinsky &lt;nevin.brackettrozinsky at gmail.com &lt;mailto:nevin.brackettrozinsky at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Would .cases return the enum’s cases in source-code order? That seems fragile at first glance.<br>&gt;&gt; <br>&gt;&gt; It might be worth considering to have it return an unordered collection (set) instead.<br>&gt; <br>&gt; Care to elaborate on why you think it may be fragile?<br>&gt; <br>&gt; Retaining order makes sense to me given that integer-backed enumerations auto-increment and that enumerations cannot be extended with new cases. I&#39;m not opposed to using a set, though, if that makes more sense.<br>&gt; <br>&gt; Stephen<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/e4a64465/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Enum &#39;count&#39; functionality</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 21, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 12:09 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; My wild aspirations in a nutshell:<br>&gt; <br>&gt; Core enums:  Any enum that&#39;s created without raw or associated values, e.g. enum MyEnum {case This, That, Whatever, Etc},  can (and should) be Array&lt;Self&gt; representable. This would add intrinsic ordering and raw value construction starting with 0, up to count - 1. End-devs could use the ordering or not use the ordering, but it would be possible to convert to bit representation (1 &lt;&lt; this.rawValue),  support iteration through the enumeration, introduce ranges for switches, etc. A massive improvement.<br>&gt; <br>&gt; Raw value enums: Any enum that uses raw values, e.g. enum ForExample: String {case Hello = &quot;hello&quot;, There = &quot;there&quot;} should be representable as Set&lt;T&gt;<br>&gt; <br>&gt; Associated type enums: all bets are off<br></p><p>There&#39;s only one kind of enum fundamentally, and I think we should make for more continuity between different instances of enum rather than less. Any type with a reasonably finite number of states ought to be able to support a `values` collection. If it happens to have a RawRepresentable conformance, mapping from values to rawValues is easy, and could be provided by a protocol extension on ValueEnumerable where Self: RawRepresentable. Enums with associated values that are themselves ValueEnumerable could enumerate all the values of the associated value, so something like this:<br></p><p>enum Foo: ValueEnumerable { case A, B, C }<br></p><p>enum Bar: ValueEnumerable { case X(Foo), Y(Foo) }<br></p><p>would give you `.X(.A)`, `.X(.B)`, `.X(.C)`, etc. (You could also derive ValueEnumerable for structs by walking the cartesian product of the stored properties&#39; values, but I don&#39;t know if that&#39;s really useful.)<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/f765f29e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Proposal: Enum &#39;count&#39; functionality</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 21, 2015 at 01:00:00pm</p></header><div class="content"><p>I could be satisfied by such an approach.  I could even be more satisfied if<br></p><p>&gt; enum Foo: ValueEnumerable { case A, B, C }<br></p><p><br>were also essentially an alias for<br></p><p>&gt; enum Foo: Int, ValueEnumerable { case A=0, B, C }<br></p><p>:)<br></p><p>-- E<br></p><p><br>&gt; On Dec 21, 2015, at 1:14 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 21, 2015, at 12:09 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; My wild aspirations in a nutshell:<br>&gt;&gt; <br>&gt;&gt; Core enums:  Any enum that&#39;s created without raw or associated values, e.g. enum MyEnum {case This, That, Whatever, Etc},  can (and should) be Array&lt;Self&gt; representable. This would add intrinsic ordering and raw value construction starting with 0, up to count - 1. End-devs could use the ordering or not use the ordering, but it would be possible to convert to bit representation (1 &lt;&lt; this.rawValue),  support iteration through the enumeration, introduce ranges for switches, etc. A massive improvement.<br>&gt;&gt; <br>&gt;&gt; Raw value enums: Any enum that uses raw values, e.g. enum ForExample: String {case Hello = &quot;hello&quot;, There = &quot;there&quot;} should be representable as Set&lt;T&gt;<br>&gt;&gt; <br>&gt;&gt; Associated type enums: all bets are off<br>&gt; <br>&gt; There&#39;s only one kind of enum fundamentally, and I think we should make for more continuity between different instances of enum rather than less. Any type with a reasonably finite number of states ought to be able to support a `values` collection. If it happens to have a RawRepresentable conformance, mapping from values to rawValues is easy, and could be provided by a protocol extension on ValueEnumerable where Self: RawRepresentable. Enums with associated values that are themselves ValueEnumerable could enumerate all the values of the associated value, so something like this:<br>&gt; <br>&gt; enum Foo: ValueEnumerable { case A, B, C }<br>&gt; <br>&gt; enum Bar: ValueEnumerable { case X(Foo), Y(Foo) }<br>&gt; <br>&gt; would give you `.X(.A)`, `.X(.B)`, `.X(.C)`, etc. (You could also derive ValueEnumerable for structs by walking the cartesian product of the stored properties&#39; values, but I don&#39;t know if that&#39;s really useful.)<br>&gt; <br>&gt; -Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/d4aaadea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/71784126c20615c242e2fa11dc33e613?s=50"></div><header><strong>Proposal: Enum &#39;count&#39; functionality</strong> from <string>Andyy Hope</string> &lt;andyyhopedev at me.com&gt;<p>December 22, 2015 at 09:00:00am</p></header><div class="content"><p>I&#39;ve updated the gist to include alternative collection types and naming for the enum values <br></p><p>Andyy Hope<br>iOS Developer, Melbourne<br>@andyyhope<br>andyyhope.com<br></p><p>&gt; On 22 Dec 2015, at 7:24 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; I could be satisfied by such an approach.  I could even be more satisfied if<br>&gt; <br>&gt;&gt; enum Foo: ValueEnumerable { case A, B, C }<br>&gt; <br>&gt; <br>&gt; were also essentially an alias for<br>&gt; <br>&gt;&gt; enum Foo: Int, ValueEnumerable { case A=0, B, C }<br>&gt; <br>&gt; :)<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Dec 21, 2015, at 1:14 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 21, 2015, at 12:09 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My wild aspirations in a nutshell:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Core enums:  Any enum that&#39;s created without raw or associated values, e.g. enum MyEnum {case This, That, Whatever, Etc},  can (and should) be Array&lt;Self&gt; representable. This would add intrinsic ordering and raw value construction starting with 0, up to count - 1. End-devs could use the ordering or not use the ordering, but it would be possible to convert to bit representation (1 &lt;&lt; this.rawValue),  support iteration through the enumeration, introduce ranges for switches, etc. A massive improvement.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Raw value enums: Any enum that uses raw values, e.g. enum ForExample: String {case Hello = &quot;hello&quot;, There = &quot;there&quot;} should be representable as Set&lt;T&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Associated type enums: all bets are off<br>&gt;&gt; <br>&gt;&gt; There&#39;s only one kind of enum fundamentally, and I think we should make for more continuity between different instances of enum rather than less. Any type with a reasonably finite number of states ought to be able to support a `values` collection. If it happens to have a RawRepresentable conformance, mapping from values to rawValues is easy, and could be provided by a protocol extension on ValueEnumerable where Self: RawRepresentable. Enums with associated values that are themselves ValueEnumerable could enumerate all the values of the associated value, so something like this:<br>&gt;&gt; <br>&gt;&gt; enum Foo: ValueEnumerable { case A, B, C }<br>&gt;&gt; <br>&gt;&gt; enum Bar: ValueEnumerable { case X(Foo), Y(Foo) }<br>&gt;&gt; <br>&gt;&gt; would give you `.X(.A)`, `.X(.B)`, `.X(.C)`, etc. (You could also derive ValueEnumerable for structs by walking the cartesian product of the stored properties&#39; values, but I don&#39;t know if that&#39;s really useful.)<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/3bbe84a8/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Enum &#39;count&#39; functionality</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 21, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 12:24 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; I could be satisfied by such an approach.  I could even be more satisfied if<br>&gt; <br>&gt;&gt; enum Foo: ValueEnumerable { case A, B, C }<br>&gt; <br>&gt; <br>&gt; were also essentially an alias for<br>&gt; <br>&gt;&gt; enum Foo: Int, ValueEnumerable { case A=0, B, C }<br>&gt; <br>&gt; :)<br></p><p>If the value collection were sufficiently capable, you wouldn&#39;t necessarily need an implicit Int raw value; you could do `allValues.indexOf(.A)` to get the index for a case.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Proposal: Enum &#39;count&#39; functionality</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 21, 2015 at 03:00:00pm</p></header><div class="content"><p>That would be okay too. Thank you, Santa Joe.<br></p><p>-- E, who hopes she was on the nice list.<br></p><p>&gt; On Dec 21, 2015, at 3:56 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 21, 2015, at 12:24 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I could be satisfied by such an approach.  I could even be more satisfied if<br>&gt;&gt; <br>&gt;&gt;&gt; enum Foo: ValueEnumerable { case A, B, C }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; were also essentially an alias for<br>&gt;&gt; <br>&gt;&gt;&gt; enum Foo: Int, ValueEnumerable { case A=0, B, C }<br>&gt;&gt; <br>&gt;&gt; :)<br>&gt; <br>&gt; If the value collection were sufficiently capable, you wouldn&#39;t necessarily need an implicit Int raw value; you could do `allValues.indexOf(.A)` to get the index for a case.<br>&gt; <br>&gt; -Joe<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/289e63405066acfc02feee3b7abf39bb?s=50"></div><header><strong>Proposal: Enum &#39;count&#39; functionality</strong> from <string>Zef Houssney</string> &lt;zefmail at gmail.com&gt;<p>December 21, 2015 at 11:00:00pm</p></header><div class="content"><p>I agree with Stephen Celis that the best names for this (yet) are definitely `cases` and optionally `rawValues` if the cases are RawRepresentable.<br></p><p>Regarding handling cases with associated values where some of those values are other enums, it seems odd to me to try to return every variation of each case. I can’t picture how that would work sanely when there are multiple associated values, such as a case like `MyCase(String, SomeEnum)`. Therefore I prefer the idea of having the array contain the constructor for cases with associated values. The main problem I see here is that the type system (as far as I know) can’t fully represent that type of thing, but I think it’s still potentially valuable. Related to this I’m putting together a separate proposal that explores a bit more on why I believe the enum constructor to be valuable, though that’s in a bit of a different context.<br></p><p>I shared these thoughts in a bit more detail here a couple weeks ago, with some followup in the next two messages:<br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001864.html<br></p><p>Zef<br></p><p><br></p><p>&gt; On Dec 21, 2015, at 3:58 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; That would be okay too. Thank you, Santa Joe.<br>&gt; <br>&gt; -- E, who hopes she was on the nice list.<br>&gt; <br>&gt;&gt; On Dec 21, 2015, at 3:56 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 21, 2015, at 12:24 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I could be satisfied by such an approach.  I could even be more satisfied if<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum Foo: ValueEnumerable { case A, B, C }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; were also essentially an alias for<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum Foo: Int, ValueEnumerable { case A=0, B, C }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; :)<br>&gt;&gt; <br>&gt;&gt; If the value collection were sufficiently capable, you wouldn&#39;t necessarily need an implicit Int raw value; you could do `allValues.indexOf(.A)` to get the index for a case.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Enum &#39;count&#39; functionality</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 22, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 10:33 PM, Zef Houssney &lt;zefmail at gmail.com&gt; wrote:<br>&gt; <br>&gt; I agree with Stephen Celis that the best names for this (yet) are definitely `cases` and optionally `rawValues` if the cases are RawRepresentable.<br>&gt; <br>&gt; Regarding handling cases with associated values where some of those values are other enums, it seems odd to me to try to return every variation of each case. I can’t picture how that would work sanely when there are multiple associated values, such as a case like `MyCase(String, SomeEnum)`. Therefore I prefer the idea of having the array contain the constructor for cases with associated values. The main problem I see here is that the type system (as far as I know) can’t fully represent that type of thing, but I think it’s still potentially valuable. Related to this I’m putting together a separate proposal that explores a bit more on why I believe the enum constructor to be valuable, though that’s in a bit of a different context.<br></p><p>Generating a list of values for MyCase(String, SomeEnum) wouldn&#39;t make sense because there are an infinite number of Strings, so Strings don&#39;t make sense as a value-enumerable type. However, you could have a mostly-flat enum that uses subenums for organization:<br></p><p>enum Food {<br>  enum Fruit {<br>    case Apple, Banana, BellPepper<br>  }<br>  case fruit(Fruit)<br></p><p>  enum Meat {<br>    case Beef, Pork, Venison<br>  }<br>  case meat(Meat)<br>}<br></p><p>In many C family code bases it&#39;s common to group related enums by order, even if there&#39;s otherwise no intrinsic order among the elements. Preserving the structure of the cases in the type system makes them easier to understand and work with in pattern-matching, since you can handle all fruits by matching `.fruit(_)` instead of having to maintain `food &gt;= FirstFruit &amp;&amp; foo &lt;= LastFruit` ranges. For these kinds of enums, recursively generating the associated values is still useful.<br></p><p>-Joe<br></p><p>&gt; I shared these thoughts in a bit more detail here a couple weeks ago, with some followup in the next two messages:<br>&gt; <br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001864.html<br>&gt; <br>&gt; Zef<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Dec 21, 2015, at 3:58 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; That would be okay too. Thank you, Santa Joe.<br>&gt;&gt; <br>&gt;&gt; -- E, who hopes she was on the nice list.<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 21, 2015, at 3:56 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 21, 2015, at 12:24 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I could be satisfied by such an approach.  I could even be more satisfied if<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; enum Foo: ValueEnumerable { case A, B, C }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; were also essentially an alias for<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; enum Foo: Int, ValueEnumerable { case A=0, B, C }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If the value collection were sufficiently capable, you wouldn&#39;t necessarily need an implicit Int raw value; you could do `allValues.indexOf(.A)` to get the index for a case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5a72880ffed1a30cb9b8e3f372507145?s=50"></div><header><strong>Proposal: Enum &#39;count&#39; functionality</strong> from <string>Rob Mayoff</string> &lt;mayoff at dqd.com&gt;<p>December 23, 2015 at 02:00:00am</p></header><div class="content"><p>On Tue, Dec 22, 2015 at 12:33 AM, Zef Houssney via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I agree with Stephen Celis that the best names for this (yet) are<br>&gt; definitely `cases` and optionally `rawValues` if the cases are<br>&gt; RawRepresentable.<br>&gt;<br></p><p>That makes me want to say `for case in SomeEnum.cases { ... }`, which is a<br>syntax error, as opposed to `for value in SomeEnum.values { ... }`, which<br>is legal.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/c0a665e5/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Proposal: Enum &#39;count&#39; functionality</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>December 22, 2015 at 07:00:00am</p></header><div class="content"><p>+1 for &quot;.values&quot; instead of just &quot;.count&quot;. Really handy feature that Java has. In Java it returns a set not an array which is great for representing status. In C you would use a bit field, but an enum set is better. <br></p><p>Sent from my iPad<br></p><p>&gt; On 21 Dec 2015, at 7:57 PM, Charles Constant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If you change your proposal to focus on &quot;.values&quot; instead of &quot;.values.count&quot; (which you&#39;d get for free, as you note) I would strongly support it. I don&#39;t need &quot;.count&quot; on its own, but &quot;.values&quot; ... well, I have a whole load of enums in my current projects with a &quot;.values&quot; I had to hardcode myself. I would love to get that for free.<br>&gt; <br>&gt;&gt; On Mon, Dec 21, 2015 at 12:46 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; I’ve put a proposal up on GitHub to add a cases ‘count’ functionality to Enums for the Swift language<br>&gt;&gt; &gt; https://gist.github.com/andyyhope/2fc5b6bee8ee1346f688<br>&gt;&gt; <br>&gt;&gt; I think we&#39;d be much better off having a list of all cases. That would make this feature useful for enums which don&#39;t have a raw type, or don&#39;t use Int as their raw type, or don&#39;t use sequential raw values for their cases.<br>&gt;&gt; <br>&gt;&gt; That approach has been discussed before, but not formally proposed.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/327f7355/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a4ec28142b500669d39c463d459bea9b?s=50"></div><header><strong>Proposal: Enum &#39;count&#39; functionality</strong> from <string>Extelligent Cocoa</string> &lt;extelligentcocoa at extelligentcocoa.org&gt;<p>December 23, 2015 at 12:00:00pm</p></header><div class="content"><p>Brent Royal-Gordon &lt;mailto:swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I think we&#39;d be much better off having a list of all cases. That would <br>&gt; make this feature useful for enums which don&#39;t have a raw type, or <br>&gt; don&#39;t use Int as their raw type, or don&#39;t use sequential raw values <br>&gt; for their cases.<br>&gt;<br>&gt; That approach has been discussed before, but not formally proposed.<br>I&#39;d just like to +1 this as it&#39;s a feature I often use - enums are <br>perfect for limiting user choices (days of the week, anyone?) and having <br>to manually create and update the list of cases would be much easier and <br>safer with a dedicated feature. (I&#39;d prefer for it not to be a set <br>because a set has no inbuilt order; if it were returned as a set I&#39;d <br>then have to create an array manually anyway; I want my weekdays to <br>appear neither randomly sorted nor alphabetical.<br></p><p><br>Catja Pafort<br>-- <br>www.extelligentcocoa.org<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8b9f0c10986385f3c7f50615d6176be3?s=50"></div><header><strong>Proposal: Enum &#39;count&#39; functionality</strong> from <string>Pierre Monod-Broca</string> &lt;pierre at monod-broca.fr&gt;<p>December 23, 2015 at 02:00:00pm</p></header><div class="content"><p>+1 for an ordered collection of all cases, it could be an ordered set to please proponents of a set.<br></p><p>I have no strong opinions about the name<br>`cases` is good, but I agree it begs to do &#39;&#39;for case in SomeEnum.cases&#39;&#39;<br>`values` is good, and IMO it&#39;s consistent with `rawValue` when there is one, not confusing<br></p><p>-- <br>Pierre<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/803ec8b6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/289e63405066acfc02feee3b7abf39bb?s=50"></div><header><strong>Proposal: Enum &#39;count&#39; functionality</strong> from <string>Zef Houssney</string> &lt;zefmail at gmail.com&gt;<p>December 23, 2015 at 09:00:00am</p></header><div class="content"><p>To be clear, I think there should be a distinction between what would be returned by `cases` and `rawValues`, and I think there is good reason to include both:<br></p><p>- `cases` would return actual instances of the enum type, or the constructor if there is an associated value for the case and an instance can’t be automatically created<br>- `rawValues` would also exist for enums that have a RawRepresentable value.<br></p><p>The collision of using “case&quot; in something like `for case in SomeEnum.cases` is unfortunate, but I think it’s still the most clear and accurate representation of something that does what I described above. Initially I was thinking there was an existing proposal that would fix this, but now I realize that it’s only scoped to keyword arguments: https://github.com/apple/swift-evolution/blob/master/proposals/0001-keywords-as-argument-labels.md<br></p><p><br>Joe, thank you for your thoughts on this! Yes I agree that it doesn’t make sense to try to generate a list of all possible values for all associated types — and that’s pretty much my point. Deciding to omit such unsupported cases is one way to deal with that issue, but it seems confusing and limiting to me that some enum cases would not be represented in the array of values, while others are represented multiple times. I’m not saying that there’s no value to something like that and I’m certainly not opposed to the inclusion of that kind of thing, but I’m interested in finding a way to deal with this in a manner that is more understandable, predictable, and flexible.<br></p><p>I’d love to hear what you think about returning an array that includes constructors for the cases with associated values. Here’s what I like about that idea:<br></p><p>- The array consists of a 1-to-1 mapping regardless of the type of case. This is more understandable and predictable in my opinion.<br>- It provides the ability to cover more use-cases, while I believe the other approach would prevent certain things from being possible in a dynamic way.<br>- It still allows for developers to generate an array with the recursive structure/Cartesian product as you described.<br></p><p>Here is an example that demonstrates the usefulness of constructors as the included value for cases with associated values. I am providing a stubbed implementation of a `cases` static var. The concept is that you have an enum that defines a number of built-in color schemes, but provides a mechanism for users to dynamically create their own color schemes.<br></p><p>https://gist.github.com/zef/c6069ed4ed11e41661bf<br></p><p>I have a couple other real-world ideas for where this would be useful too.<br></p><p><br>Downsides I can see to this approach:<br></p><p>- For enums that have disparate constructor signatures, [Any] would have to be the return value of cases, which doesn’t seem ideal because the cases array would always require some kind of manual manipulation to be useful.<br>- There isn’t currently a way in the type system to know what case you are working based on the constructor. For instance say two cases both have a constructor of (String), you can’t determine which case you are working on until you call the constructor to instantiate the case. This could be done by looking at the index of the constructor in the cases array, but that is brittle and messy. If there was a way to determine that more dynamically, this would be more powerful and easier to use.<br></p><p><br></p><p><br>&gt; On Dec 23, 2015, at 6:00 AM, Pierre Monod-Broca via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 for an ordered collection of all cases, it could be an ordered set to please proponents of a set.<br>&gt; <br>&gt; I have no strong opinions about the name<br>&gt; `cases` is good, but I agree it begs to do &#39;&#39;for case in SomeEnum.cases&#39;&#39;<br>&gt; `values` is good, and IMO it&#39;s consistent with `rawValue` when there is one, not confusing<br>&gt; <br>&gt; -- <br>&gt; Pierre<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/14494ab2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47e3aeeaf151d4f51ee15fc7871bf584?s=50"></div><header><strong>Proposal: Enum &#39;count&#39; functionality</strong> from <string>Rudolf Adamkovič</string> &lt;salutis at me.com&gt;<p>December 23, 2015 at 11:00:00pm</p></header><div class="content"><p>Zef, do you really think `rawValues` are worth adding?<br></p><p>With `cases`, they would be one `map` away, no?<br></p><p>R+<br></p><p>&gt; On 23 Dec 2015, at 17:21, Zef Houssney via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; To be clear, I think there should be a distinction between what would be returned by `cases` and `rawValues`, and I think there is good reason to include both:<br>&gt; <br>&gt; - `cases` would return actual instances of the enum type, or the constructor if there is an associated value for the case and an instance can’t be automatically created<br>&gt; - `rawValues` would also exist for enums that have a RawRepresentable value.<br>&gt; <br>&gt; The collision of using “case&quot; in something like `for case in SomeEnum.cases` is unfortunate, but I think it’s still the most clear and accurate representation of something that does what I described above. Initially I was thinking there was an existing proposal that would fix this, but now I realize that it’s only scoped to keyword arguments: https://github.com/apple/swift-evolution/blob/master/proposals/0001-keywords-as-argument-labels.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0001-keywords-as-argument-labels.md&gt;<br>&gt; <br>&gt; <br>&gt; Joe, thank you for your thoughts on this! Yes I agree that it doesn’t make sense to try to generate a list of all possible values for all associated types — and that’s pretty much my point. Deciding to omit such unsupported cases is one way to deal with that issue, but it seems confusing and limiting to me that some enum cases would not be represented in the array of values, while others are represented multiple times. I’m not saying that there’s no value to something like that and I’m certainly not opposed to the inclusion of that kind of thing, but I’m interested in finding a way to deal with this in a manner that is more understandable, predictable, and flexible.<br>&gt; <br>&gt; I’d love to hear what you think about returning an array that includes constructors for the cases with associated values. Here’s what I like about that idea:<br>&gt; <br>&gt; - The array consists of a 1-to-1 mapping regardless of the type of case. This is more understandable and predictable in my opinion.<br>&gt; - It provides the ability to cover more use-cases, while I believe the other approach would prevent certain things from being possible in a dynamic way.<br>&gt; - It still allows for developers to generate an array with the recursive structure/Cartesian product as you described.<br>&gt; <br>&gt; Here is an example that demonstrates the usefulness of constructors as the included value for cases with associated values. I am providing a stubbed implementation of a `cases` static var. The concept is that you have an enum that defines a number of built-in color schemes, but provides a mechanism for users to dynamically create their own color schemes.<br>&gt; <br>&gt; https://gist.github.com/zef/c6069ed4ed11e41661bf &lt;https://gist.github.com/zef/c6069ed4ed11e41661bf&gt;<br>&gt; <br>&gt; I have a couple other real-world ideas for where this would be useful too.<br>&gt; <br>&gt; <br>&gt; Downsides I can see to this approach:<br>&gt; <br>&gt; - For enums that have disparate constructor signatures, [Any] would have to be the return value of cases, which doesn’t seem ideal because the cases array would always require some kind of manual manipulation to be useful.<br>&gt; - There isn’t currently a way in the type system to know what case you are working based on the constructor. For instance say two cases both have a constructor of (String), you can’t determine which case you are working on until you call the constructor to instantiate the case. This could be done by looking at the index of the constructor in the cases array, but that is brittle and messy. If there was a way to determine that more dynamically, this would be more powerful and easier to use.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 6:00 AM, Pierre Monod-Broca via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1 for an ordered collection of all cases, it could be an ordered set to please proponents of a set.<br>&gt;&gt; <br>&gt;&gt; I have no strong opinions about the name<br>&gt;&gt; `cases` is good, but I agree it begs to do &#39;&#39;for case in SomeEnum.cases&#39;&#39;<br>&gt;&gt; `values` is good, and IMO it&#39;s consistent with `rawValue` when there is one, not confusing<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Pierre<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/468240dc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/23a31075ffa046c5a4da64af895ceb07?s=50"></div><header><strong>Proposal: Enum &#39;count&#39; functionality</strong> from <string>Cihat Gündüz</string> &lt;CihatGuenduez at posteo.de&gt;<p>December 25, 2015 at 10:00:00pm</p></header><div class="content"><p>+1 for adding `.allCases` to enums. I just wanted to propose this exact idea but then found this thread (and another where the thread starter was pointed to this thread).<br></p><p>The count would then be `MyEnum.allCases.count` and the rawValues would be `MyEnum.allCases.map{ $0.rawValue }`. I think the latter two are sufficient here, no need for extra integration IMO. But those points could be still discussed.<br></p><p>Shouldn’t we create a new properly named proposal for this though? This thread / proposal is about adding the .count and the naming is somehow misleading.<br></p><p>– Cihat<br></p><p><br>&gt; Am 23.12.2015 um 23:50 schrieb Rudolf Adamkovič via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Zef, do you really think `rawValues` are worth adding?<br>&gt; <br>&gt; With `cases`, they would be one `map` away, no?<br>&gt; <br>&gt; R+<br>&gt; <br>&gt;&gt; On 23 Dec 2015, at 17:21, Zef Houssney via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; To be clear, I think there should be a distinction between what would be returned by `cases` and `rawValues`, and I think there is good reason to include both:<br>&gt;&gt; <br>&gt;&gt; - `cases` would return actual instances of the enum type, or the constructor if there is an associated value for the case and an instance can’t be automatically created<br>&gt;&gt; - `rawValues` would also exist for enums that have a RawRepresentable value.<br>&gt;&gt; <br>&gt;&gt; The collision of using “case&quot; in something like `for case in SomeEnum.cases` is unfortunate, but I think it’s still the most clear and accurate representation of something that does what I described above. Initially I was thinking there was an existing proposal that would fix this, but now I realize that it’s only scoped to keyword arguments: https://github.com/apple/swift-evolution/blob/master/proposals/0001-keywords-as-argument-labels.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0001-keywords-as-argument-labels.md&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Joe, thank you for your thoughts on this! Yes I agree that it doesn’t make sense to try to generate a list of all possible values for all associated types — and that’s pretty much my point. Deciding to omit such unsupported cases is one way to deal with that issue, but it seems confusing and limiting to me that some enum cases would not be represented in the array of values, while others are represented multiple times. I’m not saying that there’s no value to something like that and I’m certainly not opposed to the inclusion of that kind of thing, but I’m interested in finding a way to deal with this in a manner that is more understandable, predictable, and flexible.<br>&gt;&gt; <br>&gt;&gt; I’d love to hear what you think about returning an array that includes constructors for the cases with associated values. Here’s what I like about that idea:<br>&gt;&gt; <br>&gt;&gt; - The array consists of a 1-to-1 mapping regardless of the type of case. This is more understandable and predictable in my opinion.<br>&gt;&gt; - It provides the ability to cover more use-cases, while I believe the other approach would prevent certain things from being possible in a dynamic way.<br>&gt;&gt; - It still allows for developers to generate an array with the recursive structure/Cartesian product as you described.<br>&gt;&gt; <br>&gt;&gt; Here is an example that demonstrates the usefulness of constructors as the included value for cases with associated values. I am providing a stubbed implementation of a `cases` static var. The concept is that you have an enum that defines a number of built-in color schemes, but provides a mechanism for users to dynamically create their own color schemes.<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/zef/c6069ed4ed11e41661bf &lt;https://gist.github.com/zef/c6069ed4ed11e41661bf&gt;<br>&gt;&gt; <br>&gt;&gt; I have a couple other real-world ideas for where this would be useful too.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Downsides I can see to this approach:<br>&gt;&gt; <br>&gt;&gt; - For enums that have disparate constructor signatures, [Any] would have to be the return value of cases, which doesn’t seem ideal because the cases array would always require some kind of manual manipulation to be useful.<br>&gt;&gt; - There isn’t currently a way in the type system to know what case you are working based on the constructor. For instance say two cases both have a constructor of (String), you can’t determine which case you are working on until you call the constructor to instantiate the case. This could be done by looking at the index of the constructor in the cases array, but that is brittle and messy. If there was a way to determine that more dynamically, this would be more powerful and easier to use.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 23, 2015, at 6:00 AM, Pierre Monod-Broca via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 for an ordered collection of all cases, it could be an ordered set to please proponents of a set.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have no strong opinions about the name<br>&gt;&gt;&gt; `cases` is good, but I agree it begs to do &#39;&#39;for case in SomeEnum.cases&#39;&#39;<br>&gt;&gt;&gt; `values` is good, and IMO it&#39;s consistent with `rawValue` when there is one, not confusing<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Pierre<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151225/8bfa4739/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4889457e1fdb5f3ba65d7053432042f8?s=50"></div><header><strong>Proposal: Enum &#39;count&#39; functionality</strong> from <string>Bart Whiteley</string> &lt;bwhiteley at gmail.com&gt;<p>December 22, 2015 at 10:00:00am</p></header><div class="content"><p>On Mon, Dec 21, 2015 at 1:42 AM, Andyy Hope via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi Swift Team and Community<br>&gt;<br>&gt; I’ve put a proposal up on GitHub to add a cases ‘count’ functionality to<br>&gt; Enums for the Swift language<br>&gt; https://gist.github.com/andyyhope/2fc5b6bee8ee1346f688<br>&gt;<br>&gt;<br>&gt; Comments, feedback, scenario appends very much welcomed. Thank you<br>&gt;<br></p><p>I would discourage adding just a `.count`. I&#39;ve heard a few people ask for<br>this over the last year. In almost all cases it is due to people falling<br>back to the way they dealt with enums in Objective C when in fact there is<br>usually a better way in Swift.  Adding `.count` would inhibit the discovery<br>of better ways of doing things.<br></p><p>However, I&#39;m having a hard time arguing against `.cases`. In at least one<br>place I currently have an `.allCases` computed property on an enum.<br></p><p>--<br>bart<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/a82f00f7/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
