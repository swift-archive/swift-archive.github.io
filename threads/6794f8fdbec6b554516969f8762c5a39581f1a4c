<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Pitch] Add namespacing to associatedTypes</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>April  8, 2016 at 04:00:00pm</p></header><div class="content"><p>I agree with Brent that there is a larger issue to solve, but I would still like to hear your solution, as it may inform the larger solution (and this may be a starting point to tackling the whole thing).<br></p><p>The thing that makes the most sense to me, off the top of my head, is to have an error that says: “T is ambiguous: Use A.T or B.T to disambiguate.”.  It should actually list out the cases if that is technically possible.  I could also see the argument that you should always have to specify the protocol (i.e. ‘A.T&#39; instead of just ’T’) since that would solve post-hoc naming collisions.  I would also be ok with inferring which protocol T belongs to when it is unambiguously possible.<br></p><p><br>The larger issue is what if protocols A &amp; B both have ‘var t:T’.  The interaction of these two problems needs to be considered before we can make traction on either.<br></p><p>It seems to me there are two cases for ‘var t:T’: either the T’s are the same or they are different.  If they are the same, then everything is ok assuming the semantics are also the same, but that is a big assumption.  If the T&#39;s are different, compliance would require overloading a property, which isn’t currently allowed in Swift.  I think there was a proposal to have something like ‘var t:T implements A’ and then having the caller disambiguate at the call site using ‘(x as A).t’.<br></p><p>It starts to get complex very quickly… (but it is still design work that we have to do at some point)<br></p><p>Thanks,<br>Jon<br></p><p>&gt; Types associated with a protocol are not namespaced by the protocol, but<br>&gt; rather by the protocol&#39;s adopters. As such, when two protocols declare a<br>&gt; common associatedType, adoption of those protocols introduces undesirable<br>&gt; ambiguity.<br>&gt; <br>&gt; Given the understandable propensity of developers to arrive at similarly<br>&gt; named types (T, for example), it is likely that this problem will reduce<br>&gt; the compatibility of packages for reasons that may not be entirely clear to<br>&gt; the package consumer.<br>&gt; <br>&gt; Here is a demonstration of the issue. Apologies, I&#39;m a longtime reader of<br>&gt; the list, but this is my first time posting, and I&#39;m not sure how best to<br>&gt; format this. You may also find this example on Jira (<br>&gt; https://bugs.swift.org/browse/SR-1065 &lt;https://bugs.swift.org/browse/SR-1065&gt;).<br>&gt; <br>&gt; ```<br>&gt; protocol A {<br>&gt;     associatedtype T<br>&gt;     var aT: T { get }<br>&gt; }<br>&gt; <br>&gt; protocol B {<br>&gt;     associatedtype T<br>&gt;     var bT: T { get }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; T is ambiguous: &quot;Type C does not conform to protocol &#39;B&#39;.&quot;<br>&gt; ```<br>&gt; class C: A, B {<br>&gt;     var aT = String()<br>&gt;     var bT = Int()<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; <br>&gt; T is inferred unambiguously, compiles without error.<br>&gt; ```<br>&gt; class C: A, B {<br>&gt;     var aT = String()<br>&gt;     var bT = String()<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; T is explicit, but problematic: &quot;Type C does not conform to protocol &#39;A&#39;.&quot;<br>&gt; ```<br>&gt; class C: A, B {<br>&gt;     typealias T = Int<br>&gt;     var aT = String()<br>&gt;     var bT = Int()<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; I would greatly appreciate any advice or direction as to next steps. I have<br>&gt; a proposal for resolving this in mind, but it seemed premature to offer it<br>&gt; before finding some agreement that this was worth carrying forward.<br>&gt; <br>&gt; Best regards,<br>&gt; Noah Blake<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160408/67941a4c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/421f5b513b7d921519635cd23d723191?s=50"></div><header><strong>[Pitch] Add namespacing to associatedTypes</strong> from <string>Noah Blake</string> &lt;nononoah at gmail.com&gt;<p>April  9, 2016 at 07:00:00pm</p></header><div class="content"><p>There&#39;s been a little movement on this in the ticket that I opened. Joe<br>Groff suggested the following attribute:<br></p><p>@implements(A.T)<br>typealias AT = String<br>@implements(B.T)<br>typealias BT = Int<br></p><p>I would prefer a syntax more in line with what you suggested<br></p><p>typealias A.T = String<br>typealias B.T = Int<br></p><p>The advantage of the attribute approach, however, is that it may be<br>extended to solve various naming collisions.<br></p><p>When it comes to associatedtypes, I can&#39;t think of a case where the<br>compiler couldn&#39;t infer type from the adopter&#39;s implementation. No matter<br>what the syntax is, it would regularly be sugared in.<br></p><p>While I think there&#39;s merit to the opinion that you and Brent share (solve<br>this problem when solving all protocol implementation collisions), it may<br>be best to address this somewhat large problem through a series of<br>incremental changes that target its components.<br></p><p>The thing that makes the most sense to me, off the top of my head, is to<br>&gt; have an error that says: “T is ambiguous: Use A.T or B.T to disambiguate.”.<br></p><p><br>I agree that it would be best to update the error associated with this<br>issue.<br></p><p>On Fri, Apr 8, 2016 at 7:24 PM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br></p><p>&gt; I agree with Brent that there is a larger issue to solve, but I would<br>&gt; still like to hear your solution, as it may inform the larger solution (and<br>&gt; this may be a starting point to tackling the whole thing).<br>&gt;<br>&gt; The thing that makes the most sense to me, off the top of my head, is to<br>&gt; have an error that says: “T is ambiguous: Use A.T or B.T to<br>&gt; disambiguate.”.  It should actually list out the cases if that is<br>&gt; technically possible.  I could also see the argument that you should always<br>&gt; have to specify the protocol (i.e. ‘A.T&#39; instead of just ’T’) since that<br>&gt; would solve post-hoc naming collisions.  I would also be ok with inferring<br>&gt; which protocol T belongs to when it is unambiguously possible.<br>&gt;<br>&gt;<br>&gt; The larger issue is what if protocols A &amp; B both have ‘var t:T’.  The<br>&gt; interaction of these two problems needs to be considered before we can make<br>&gt; traction on either.<br>&gt;<br>&gt; It seems to me there are two cases for ‘var t:T’: either the T’s are the<br>&gt; same or they are different.  If they are the same, then everything is ok<br>&gt; assuming the semantics are also the same, but that is a big assumption.  If<br>&gt; the T&#39;s are different, compliance would require overloading a property,<br>&gt; which isn’t currently allowed in Swift.  I think there was a proposal to<br>&gt; have something like ‘var t:T implements A’ and then having the caller<br>&gt; disambiguate at the call site using ‘(x as A).t’.<br>&gt;<br>&gt; It starts to get complex very quickly… (but it is still design work that<br>&gt; we have to do at some point)<br>&gt;<br>&gt; Thanks,<br>&gt; Jon<br>&gt;<br>&gt; Types associated with a protocol are not namespaced by the protocol, but<br>&gt; rather by the protocol&#39;s adopters. As such, when two protocols declare a<br>&gt; common associatedType, adoption of those protocols introduces undesirable<br>&gt; ambiguity.<br>&gt;<br>&gt; Given the understandable propensity of developers to arrive at similarly<br>&gt; named types (T, for example), it is likely that this problem will reduce<br>&gt; the compatibility of packages for reasons that may not be entirely clear to<br>&gt; the package consumer.<br>&gt;<br>&gt; Here is a demonstration of the issue. Apologies, I&#39;m a longtime reader of<br>&gt; the list, but this is my first time posting, and I&#39;m not sure how best to<br>&gt; format this. You may also find this example on Jira (<br>&gt; https://bugs.swift.org/browse/SR-1065).<br>&gt;<br>&gt; ```<br>&gt; protocol A {<br>&gt;     associatedtype T<br>&gt;     var aT: T { get }<br>&gt; }<br>&gt;<br>&gt; protocol B {<br>&gt;     associatedtype T<br>&gt;     var bT: T { get }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; T is ambiguous: &quot;Type C does not conform to protocol &#39;B&#39;.&quot;<br>&gt; ```<br>&gt; class C: A, B {<br>&gt;     var aT = String()<br>&gt;     var bT = Int()<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt;<br>&gt; T is inferred unambiguously, compiles without error.<br>&gt; ```<br>&gt; class C: A, B {<br>&gt;     var aT = String()<br>&gt;     var bT = String()<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; T is explicit, but problematic: &quot;Type C does not conform to protocol &#39;A&#39;.&quot;<br>&gt; ```<br>&gt; class C: A, B {<br>&gt;     typealias T = Int<br>&gt;     var aT = String()<br>&gt;     var bT = Int()<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; I would greatly appreciate any advice or direction as to next steps. I have<br>&gt; a proposal for resolving this in mind, but it seemed premature to offer it<br>&gt; before finding some agreement that this was worth carrying forward.<br>&gt;<br>&gt; Best regards,<br>&gt; Noah Blake<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160409/4d9a4d7c/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
