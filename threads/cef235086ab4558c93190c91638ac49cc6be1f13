<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Custom equality/hash for Sets</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 21, 2016 at 04:00:00am</p></header><div class="content"><p>on Fri Feb 19 2016, Nicola Salmoria &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Would it make sense to abstract the hash functions into a protocol?<br>&gt;<br>&gt; The limit of the Hashable protocol is that it forces a type to commit to a specific ‘canonical’ hash implementation, while there might be more efficient implementations depending on the application.<br>&gt;<br>&gt; To truly support composition patterns, it would seem appropriate for the standard library to support decoupling the hashing functionality from the type of the container element.<br>&gt;<br>&gt; E.g.<br>&gt;<br>&gt; protocol Hash {<br>&gt;     typealias Element<br>&gt;<br>&gt;     static func equal(lhs: Element, _ rhs: Element) -&gt; Bool<br>&gt;     static func hashValue(x: Element) -&gt; Int<br>&gt; }<br>&gt;<br>&gt; // now we can define a generic box<br>&gt; struct HashableBox&lt;T, H: Hash where H.Element == T&gt; : Hashable {<br>&gt;     let value: T<br>&gt;<br>&gt;     var hashValue: Int {<br>&gt;         return H.hashValue(value)<br>&gt;     }<br>&gt; }<br>&gt; func ==&lt;T, H&gt;(lhs: HashableBox&lt;T, H&gt;, rhs: HashableBox&lt;T, H&gt;) -&gt; Bool {<br>&gt;     return H.equal(lhs.value, rhs.value)<br>&gt; }<br></p><p>Wow, this looks mighty familiar.  Sorry I didn&#39;t read your post first :-)<br></p><p>&gt; // now we can define a wrapper around Set, using an explicit Hash<br>&gt; struct CustomHashSet&lt;Element, H: Hash where H.Element == Element&gt; {<br>&gt;     // this is an implementation detail; if CustomHashSet was part of the standard library,<br>&gt;     // the .gyb could produce a more efficient implementation<br>&gt;     private var set: Set&lt;HashableBox&lt;Element, H&gt;&gt;<br>&gt;<br>&gt;     init() {}<br>&gt;     init&lt;S: SequenceType where S.Generator.Element == Element&gt;(_ sequence: S) {<br>&gt;         set = Set(sequence.lazy.map { HashableBox&lt;Element, H&gt;(value: $0) })<br>&gt;     }<br>&gt;     // etc.<br>&gt; }<br></p><p>&gt; // Example usage<br>&gt; struct NaiveCollectionHash&lt;C: CollectionType where C.Generator.Element: Hashable&gt;: Hash {<br>&gt;     typealias Element = C<br>&gt;<br>&gt;     static func equal(lhs: Element, _ rhs: Element) -&gt; Bool {<br>&gt;         guard lhs.count == rhs.count else { return false }<br>&gt;         return zip(lhs, rhs).lazy.reduce(true) { $0 &amp;&amp; ($1.0 == $1.1) }<br>&gt;     }<br>&gt;     static func hashValue(x: Element) -&gt; Int {<br>&gt;         return x.reduce(0) { $0 ^ $1.hashValue }    // a bad hash just as an example<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; let arrays = [[1],[2]]<br>&gt;<br>&gt; // This doesn&#39;t work because Array is not Hashable (yet)<br>&gt; var s1 = Set(arrays) // Error<br>&gt;<br>&gt; // This works but we need to explicitly specify all the types<br>&gt; var s2 = CustomHashSet&lt;Array&lt;Int&gt;, NaiveCollectionHash&lt;Array&lt;Int&gt;&gt;&gt;(arrays) // ok<br>&gt;<br>&gt; // Generic typealiases would help reducing the boilerplate, e.g.<br>&gt; // it would be useful if we could do<br>&gt; typealias NaiveHashSet&lt;T&gt; = CustomHashSet&lt;T, NaiveCollectionHash&lt;T&gt;&gt;    // Error<br>&gt; // then Swift&#39;s type inference should be able to automatically handle this:<br>&gt; var s3 = NaiveHashSet(arrays)   // Error<br>&gt;<br>&gt; Nicola<br>&gt;<br>&gt;&gt; Cc:swift-evolution&lt;swift-evolution at swift.org&gt;<br>&gt;&gt; Subject:[swift-evolution] Custom equality/hash for Sets<br>&gt;&gt; Date:19 February 2016 at 05:04:51 GMT+1<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; On Feb 18, 2016, at 16:09 , Dave Abrahams via<br>&gt;&gt; &gt; swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; on Thu Feb 18 2016, Jacob<br>&gt;&gt; &gt; Bandes-Storch&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; &gt; Would it make sense for the standard library Set to provide variants (or<br>&gt;&gt; &gt; &gt; parallel versions of the same data structure) that take custom hashValue/==<br>&gt;&gt; &gt; &gt; implementations at init time (functions taking in Elements), rather than<br>&gt;&gt; &gt; &gt; relying on Hashable/Comparable protocols?<br>&gt;&gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; Use case: I want a set of objects that are compared for equality using ===<br>&gt;&gt; &gt; &gt; rather than ==. This doesn&#39;t seem possible today, using Set, without<br>&gt;&gt; &gt; &gt; creating some sort of wrapper object.<br>&gt;&gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; This particular case would be analogous to using NSHashTable with<br>&gt;&gt; &gt; &gt; NSPointerFunctionsObjectPointerPersonality. (Maybe all I&#39;m asking for is a<br>&gt;&gt; &gt; &gt; Swiftier API for NSHashTable — including ArrayLiteralConvertible, using<br>&gt;&gt; &gt; &gt; generics instead of UnsafePointer&lt;Void&gt;, etc.)<br>&gt;&gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; Similarly, C++&#39;s unordered_map<br>&gt;&gt; &gt; &gt; &lt;http://en.cppreference.com/w/cpp/container/unordered_map&gt;and friends have<br>&gt;&gt; &gt; &gt; template parameters specifying the hash function and equality comparator,<br>&gt;&gt; &gt; &gt; which use std::hash and == by default.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; It might make sense.How bad is the wrapper solution for user code?<br>&gt;&gt; &gt; struct CustomHashableFoo: Hashable {<br>&gt;&gt; &gt; var value: Foo<br>&gt;&gt; &gt; func hash() -&gt;Int {<br>&gt;&gt; &gt; // custom hash function here<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt; func ==(a: CustomHashableWrapped, b: CustomHashableWrapped) {<br>&gt;&gt; &gt; // custom == here<br>&gt;&gt; &gt; }<br>&gt;&gt; Really not that bad, although you do have to get &#39;value&#39; in and out<br>&gt;&gt; of the box. It&#39;s also not reusable code—you have to rewrite the box<br>&gt;&gt; for every type.<br>&gt;&gt; <br>&gt;&gt; I&#39;d say you usuallydon&#39;twant to allow custom hash/== closures<br>&gt;&gt; because (a) then you have to store them somewhere, and (b) the<br>&gt;&gt; compiler won&#39;t usually be able to inline them away. You also end up<br>&gt;&gt; with a Set&lt;Foo&gt;that doesn&#39;t behave like a normal Set&lt;Foo&gt;—maybe you<br>&gt;&gt; can insert equal-but-not-identical elements—which is bad if anyone&#39;s<br>&gt;&gt; relying on normal Set-like guarantees.<br>&gt;&gt; <br>&gt;&gt; -1 from me until we can put functions in generics, if ever.<br>&gt;&gt; <br>&gt;&gt; Jordan_______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
