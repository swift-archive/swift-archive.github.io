<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05540cd6be96706f76aa66a4519f7db9?s=50"></div><header><strong>Proposal: SwiftPM Target Access Control</strong> from <string>Ankit Agarwal</string> &lt;ankit at ankit.im&gt;<p>July  7, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi swift packagers,<br></p><p>I am proposing access control to package targets.<br></p><p>Link:<br>https://github.com/aciidb0mb3r/swift-evolution/blob/swiftpm-module-access-control/proposals/xxxx-swiftpm-target-access-control.md<br></p><p>Feedback appreciated!<br></p><p>SwiftPM Target Access Control<br></p><p>   - Proposal: SE-XXXX<br>   &lt;https://github.com/apple/swift-evolution/blob/master/proposals/xxxx-swiftpm-target-access-control.md&gt;<br>   - Author: Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>   - Status: In Discussion<br>   - Review manager: TBD<br></p><p>&lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#introduction&gt;<br>Introduction<br></p><p>This proposal aims to address two issues:<br></p><p>   1.<br></p><p>   Control over the targets exposed (and built) when a SwiftPM package is<br>   used as a dependency.<br>   2.<br></p><p>   Import (and build) selected targets of a dependency.<br></p><p>&lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#motivation&gt;<br>Motivation<br>&lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#1-control-over-exposed-targets&gt;1.<br>Control over exposed targets:<br></p><p>SwiftPM allows multiple targets (or modules) inside a package. Packages<br>usually contain sample usage or example targets which are useful during<br>development or testing of the package but are redundant when the package is<br>used as a dependency. This increases compile time for the user of the<br>package.<br></p><p>As a concrete example: Vapor has a target called Development<br>&lt;https://github.com/qutheory/vapor/tree/master/Sources/Development&gt;.<br>&lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#2-import-selected-targets&gt;2.<br>Import selected targets:<br></p><p>Sometimes user of a package is only interested in few targets of a<br>dependency instead of all the targets. Currently there is no way to state<br>this in Package.swift and all the targets are implicitly built and exposed<br>to the user package.<br></p><p>For e.g.: I would like to use the targets libc, POSIX, Basic of SwiftPM but<br>don&#39;t want other targets to be built or exposed in my package.<br>&lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#proposed-solution&gt;Proposed<br>Solution<br>&lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#1-control-over-exposed-targets-1&gt;1.<br>Control over exposed targets:<br></p><p>I propose that package authors be able mark the targets they don&#39;t want to<br>be exposed as private i.e. the privatetargets will be built when that<br>package is root package but not when the package is used as a dependency.<br></p><p>To mark a target as private I propose PackageDescription&#39;s Target gains a<br>isPrivate boolean property which defaults to false.<br>&lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#2-import-selected-targets-1&gt;2.<br>Import selected targets:<br></p><p>I propose that package user be able to specify the targets they want to<br>import into their package.<br></p><p>To specify the targets to be import I propose to add an optional string<br>array property targets in PackageDescription&#39;s Package.Dependency which<br>defaults to nil i.e. all targets.<br></p><p>Instead of an optional string array property an enum can also be used:<br></p><p>enum ImportedTargets {<br>    case allTargets // Import all the targets, default value.<br>    case targets([String]) // Import only these targets.<br>}<br></p><p>&lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#detailed-design&gt;Detailed<br>Design<br>&lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#1-control-over-exposed-targets-2&gt;1.<br>Control over exposed targets:<br></p><p>Consider a package with following structure:<br></p><p>├── Package.swift<br>└── Sources<br>    ├── FooLibrary<br>    │   └── Foo.swift<br>    └── SampleCLI<br>        └── main.swift<br></p><p>The manifest with private target could look like:<br></p><p>import PackageDescription<br>let package = Package(<br>   name: &quot;FooLibrary&quot;,<br>   targets: [<br>       Target(name: &quot;FooLibrary&quot;),<br>       Target(name: &quot;SampleCLI&quot;, isPrivate: true),<br>   ])<br></p><p>When this package is used as a dependency only FooLibrary is built and is<br>importable.<br></p><p>Targets can have other targets as dependency inside a package. A private target<br>should only be a dependency to other private targets. For e.g. A manifest<br>like this should result in a build failure.<br></p><p>import PackageDescription<br>let package = Package(<br>   name: &quot;FooLibrary&quot;,<br>   targets: [<br>       Target(name: &quot;FooCore&quot;, isPrivate: true),<br>       Target(name: &quot;FooLibrary&quot;, dependencies: [&quot;FooCore&quot;]), // Error<br>FooCore is private.<br>       Target(name: &quot;SampleCLI&quot;, dependencies: [&quot;FooCore&quot;], isPrivate:<br>true), // Not an error because SampleCLI is private.<br>   ])<br></p><p>Error: FooCore is a private target, it cannot be a dependency to the public<br>target FooLibrary.<br>&lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#2-import-selected-targets-2&gt;2.<br>Import selected targets:<br></p><p>Consider a dependency with following manifest file:<br></p><p>import PackageDescription<br>let package = Package(<br>   name: &quot;FooLibrary&quot;,<br>   targets: [<br>       Target(name: &quot;Foo&quot;),<br>       Target(name: &quot;Bar&quot;, dependencies: [&quot;Foo&quot;]),<br>       Target(name: &quot;Baz&quot;),<br>   ])<br></p><p>To get only the Bar target from the above package, following manifest could<br>be written:<br></p><p>import PackageDescription<br>let package = Package(<br>   name: &quot;FooUser&quot;,<br>   dependencies: [<br>       .Package(<br>           url: &quot;../FooLibrary&quot;,<br>           majorVersion: 1,<br>           targets: [&quot;Bar&quot;])<br>   ])<br></p><p>Note: In this case since Bar depends on Foo, Foo will be also be implicitly<br>built and be available.<br></p><p>Any target mentioned in targets and not present in the package should<br>result in build failure.<br>&lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#impact-on-existing-code&gt;Impact<br>on Existing Code<br></p><p>There will be no impact on existing code as these features are additive.<br>&lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#alternatives-considered&gt;Alternatives<br>Considered<br></p><p>None at this time.<br></p><p>-- <br>Ankit<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160707/4a0684c1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17301ad52a677b00a621c39ab052e16d?s=50"></div><header><strong>Proposal: SwiftPM Target Access Control</strong> from <string>Daniel Dunbar</string> &lt;daniel at zuster.org&gt;<p>July  7, 2016 at 06:00:00am</p></header><div class="content"><p>Thanks for writing this up, I definitely want us to figure out how to<br>handle this problem.<br></p><p>One thing I would like to see addressed alongside this is the ability to<br>specify the dependency on a SwiftPM target level, since that is usually<br>where the dependency lies (one target imports another) and not necessarily<br>at the package level.  What do you think?<br></p><p> - Daniel<br></p><p>On Thursday, July 7, 2016, Ankit Agarwal via swift-build-dev &lt;<br>swift-build-dev at swift.org&gt; wrote:<br></p><p>&gt; Hi swift packagers,<br>&gt;<br>&gt; I am proposing access control to package targets.<br>&gt;<br>&gt; Link:<br>&gt; https://github.com/aciidb0mb3r/swift-evolution/blob/swiftpm-module-access-control/proposals/xxxx-swiftpm-target-access-control.md<br>&gt;<br>&gt; Feedback appreciated!<br>&gt;<br>&gt; SwiftPM Target Access Control<br>&gt;<br>&gt;    - Proposal: SE-XXXX<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/xxxx-swiftpm-target-access-control.md&gt;<br>&gt;    - Author: Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt;    - Status: In Discussion<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal aims to address two issues:<br>&gt;<br>&gt;    1.<br>&gt;<br>&gt;    Control over the targets exposed (and built) when a SwiftPM package is<br>&gt;    used as a dependency.<br>&gt;    2.<br>&gt;<br>&gt;    Import (and build) selected targets of a dependency.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#motivation&gt;<br>&gt; Motivation<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#1-control-over-exposed-targets&gt;1.<br>&gt; Control over exposed targets:<br>&gt;<br>&gt; SwiftPM allows multiple targets (or modules) inside a package. Packages<br>&gt; usually contain sample usage or example targets which are useful during<br>&gt; development or testing of the package but are redundant when the package is<br>&gt; used as a dependency. This increases compile time for the user of the<br>&gt; package.<br>&gt;<br>&gt; As a concrete example: Vapor has a target called Development<br>&gt; &lt;https://github.com/qutheory/vapor/tree/master/Sources/Development&gt;.<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#2-import-selected-targets&gt;2.<br>&gt; Import selected targets:<br>&gt;<br>&gt; Sometimes user of a package is only interested in few targets of a<br>&gt; dependency instead of all the targets. Currently there is no way to state<br>&gt; this in Package.swift and all the targets are implicitly built and<br>&gt; exposed to the user package.<br>&gt;<br>&gt; For e.g.: I would like to use the targets libc, POSIX, Basic of SwiftPM<br>&gt; but don&#39;t want other targets to be built or exposed in my package.<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#proposed-solution&gt;Proposed<br>&gt; Solution<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#1-control-over-exposed-targets-1&gt;1.<br>&gt; Control over exposed targets:<br>&gt;<br>&gt; I propose that package authors be able mark the targets they don&#39;t want to<br>&gt; be exposed as private i.e. the privatetargets will be built when that<br>&gt; package is root package but not when the package is used as a dependency.<br>&gt;<br>&gt; To mark a target as private I propose PackageDescription&#39;s Target gains a<br>&gt; isPrivate boolean property which defaults to false.<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#2-import-selected-targets-1&gt;2.<br>&gt; Import selected targets:<br>&gt;<br>&gt; I propose that package user be able to specify the targets they want to<br>&gt; import into their package.<br>&gt;<br>&gt; To specify the targets to be import I propose to add an optional string<br>&gt; array property targets in PackageDescription&#39;s Package.Dependency which<br>&gt; defaults to nil i.e. all targets.<br>&gt;<br>&gt; Instead of an optional string array property an enum can also be used:<br>&gt;<br>&gt; enum ImportedTargets {<br>&gt;     case allTargets // Import all the targets, default value.<br>&gt;     case targets([String]) // Import only these targets.<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#detailed-design&gt;Detailed<br>&gt; Design<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#1-control-over-exposed-targets-2&gt;1.<br>&gt; Control over exposed targets:<br>&gt;<br>&gt; Consider a package with following structure:<br>&gt;<br>&gt; ├── Package.swift<br>&gt; └── Sources<br>&gt;     ├── FooLibrary<br>&gt;     │   └── Foo.swift<br>&gt;     └── SampleCLI<br>&gt;         └── main.swift<br>&gt;<br>&gt; The manifest with private target could look like:<br>&gt;<br>&gt; import PackageDescription<br>&gt; let package = Package(<br>&gt;    name: &quot;FooLibrary&quot;,<br>&gt;    targets: [<br>&gt;        Target(name: &quot;FooLibrary&quot;),<br>&gt;        Target(name: &quot;SampleCLI&quot;, isPrivate: true),<br>&gt;    ])<br>&gt;<br>&gt; When this package is used as a dependency only FooLibrary is built and is<br>&gt; importable.<br>&gt;<br>&gt; Targets can have other targets as dependency inside a package. A private target<br>&gt; should only be a dependency to other private targets. For e.g. A manifest<br>&gt; like this should result in a build failure.<br>&gt;<br>&gt; import PackageDescription<br>&gt; let package = Package(<br>&gt;    name: &quot;FooLibrary&quot;,<br>&gt;    targets: [<br>&gt;        Target(name: &quot;FooCore&quot;, isPrivate: true),<br>&gt;        Target(name: &quot;FooLibrary&quot;, dependencies: [&quot;FooCore&quot;]), // Error FooCore is private.<br>&gt;        Target(name: &quot;SampleCLI&quot;, dependencies: [&quot;FooCore&quot;], isPrivate: true), // Not an error because SampleCLI is private.<br>&gt;    ])<br>&gt;<br>&gt; Error: FooCore is a private target, it cannot be a dependency to the<br>&gt; public target FooLibrary.<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#2-import-selected-targets-2&gt;2.<br>&gt; Import selected targets:<br>&gt;<br>&gt; Consider a dependency with following manifest file:<br>&gt;<br>&gt; import PackageDescription<br>&gt; let package = Package(<br>&gt;    name: &quot;FooLibrary&quot;,<br>&gt;    targets: [<br>&gt;        Target(name: &quot;Foo&quot;),<br>&gt;        Target(name: &quot;Bar&quot;, dependencies: [&quot;Foo&quot;]),<br>&gt;        Target(name: &quot;Baz&quot;),<br>&gt;    ])<br>&gt;<br>&gt; To get only the Bar target from the above package, following manifest<br>&gt; could be written:<br>&gt;<br>&gt; import PackageDescription<br>&gt; let package = Package(<br>&gt;    name: &quot;FooUser&quot;,<br>&gt;    dependencies: [<br>&gt;        .Package(<br>&gt;            url: &quot;../FooLibrary&quot;,<br>&gt;            majorVersion: 1,<br>&gt;            targets: [&quot;Bar&quot;])<br>&gt;    ])<br>&gt;<br>&gt; Note: In this case since Bar depends on Foo, Foo will be also be<br>&gt; implicitly built and be available.<br>&gt;<br>&gt; Any target mentioned in targets and not present in the package should<br>&gt; result in build failure.<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; There will be no impact on existing code as these features are additive.<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt;<br>&gt; None at this time.<br>&gt;<br>&gt; --<br>&gt; Ankit<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160707/53c0b220/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b2fa5f52f699e07a98fefcf30fb95354?s=50"></div><header><strong>[swift-evolution] Proposal: SwiftPM Target Access Control</strong> from <string>James Richard</string> &lt;ketzu at me.com&gt;<p>July  7, 2016 at 08:00:00am</p></header><div class="content"><p>Happy to see this in motion! I wrote up a jira a while back for this: https://bugs.swift.org/browse/SR-859<br></p><p>+1 for the solution. I prefer the target-based system over source files.<br></p><p>&gt; On Jul 7, 2016, at 5:26 AM, Ankit Agarwal via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi swift packagers,<br>&gt; <br>&gt; I am proposing access control to package targets. <br>&gt; <br>&gt; Link: https://github.com/aciidb0mb3r/swift-evolution/blob/swiftpm-module-access-control/proposals/xxxx-swiftpm-target-access-control.md &lt;https://github.com/aciidb0mb3r/swift-evolution/blob/swiftpm-module-access-control/proposals/xxxx-swiftpm-target-access-control.md&gt;<br>&gt; <br>&gt; Feedback appreciated!<br>&gt; <br>&gt; SwiftPM Target Access Control<br>&gt; <br>&gt; Proposal: SE-XXXX &lt;https://github.com/apple/swift-evolution/blob/master/proposals/xxxx-swiftpm-target-access-control.md&gt;<br>&gt; Author: Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt; Status: In Discussion<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal aims to address two issues:<br>&gt; <br>&gt; Control over the targets exposed (and built) when a SwiftPM package is used as a dependency.<br>&gt; <br>&gt; Import (and build) selected targets of a dependency.<br>&gt; <br>&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#motivation&gt;Motivation<br>&gt; <br>&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#1-control-over-exposed-targets&gt;1. Control over exposed targets:<br>&gt; <br>&gt; SwiftPM allows multiple targets (or modules) inside a package. Packages usually contain sample usage or example targets which are useful during development or testing of the package but are redundant when the package is used as a dependency. This increases compile time for the user of the package.<br>&gt; <br>&gt; As a concrete example: Vapor has a target called Development &lt;https://github.com/qutheory/vapor/tree/master/Sources/Development&gt;.<br>&gt; <br>&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#2-import-selected-targets&gt;2. Import selected targets:<br>&gt; <br>&gt; Sometimes user of a package is only interested in few targets of a dependency instead of all the targets. Currently there is no way to state this in Package.swift and all the targets are implicitly built and exposed to the user package.<br>&gt; <br>&gt; For e.g.: I would like to use the targets libc, POSIX, Basic of SwiftPM but don&#39;t want other targets to be built or exposed in my package.<br>&gt; <br>&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#proposed-solution&gt;Proposed Solution<br>&gt; <br>&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#1-control-over-exposed-targets-1&gt;1. Control over exposed targets:<br>&gt; <br>&gt; I propose that package authors be able mark the targets they don&#39;t want to be exposed as private i.e. the privatetargets will be built when that package is root package but not when the package is used as a dependency.<br>&gt; <br>&gt; To mark a target as private I propose PackageDescription&#39;s Target gains a isPrivate boolean property which defaults to false.<br>&gt; <br>&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#2-import-selected-targets-1&gt;2. Import selected targets:<br>&gt; <br>&gt; I propose that package user be able to specify the targets they want to import into their package.<br>&gt; <br>&gt; To specify the targets to be import I propose to add an optional string array property targets in PackageDescription&#39;s Package.Dependency which defaults to nil i.e. all targets.<br>&gt; <br>&gt; Instead of an optional string array property an enum can also be used:<br>&gt; <br>&gt; enum ImportedTargets {<br>&gt;     case allTargets // Import all the targets, default value.<br>&gt;     case targets([String]) // Import only these targets.<br>&gt; }<br>&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#detailed-design&gt;Detailed Design<br>&gt; <br>&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#1-control-over-exposed-targets-2&gt;1. Control over exposed targets:<br>&gt; <br>&gt; Consider a package with following structure: <br>&gt; <br>&gt; ├── Package.swift<br>&gt; └── Sources<br>&gt;     ├── FooLibrary<br>&gt;     │   └── Foo.swift<br>&gt;     └── SampleCLI<br>&gt;         └── main.swift<br>&gt; The manifest with private target could look like:<br>&gt; <br>&gt; import PackageDescription<br>&gt; <br>&gt; let package = Package(<br>&gt;    name: &quot;FooLibrary&quot;,<br>&gt;    targets: [<br>&gt;        Target(name: &quot;FooLibrary&quot;),<br>&gt;        Target(name: &quot;SampleCLI&quot;, isPrivate: true),<br>&gt;    ])<br>&gt; When this package is used as a dependency only FooLibrary is built and is importable.<br>&gt; <br>&gt; Targets can have other targets as dependency inside a package. A private target should only be a dependency to other private targets. For e.g. A manifest like this should result in a build failure.<br>&gt; <br>&gt; import PackageDescription<br>&gt; <br>&gt; let package = Package(<br>&gt;    name: &quot;FooLibrary&quot;,<br>&gt;    targets: [<br>&gt;        Target(name: &quot;FooCore&quot;, isPrivate: true),<br>&gt;        Target(name: &quot;FooLibrary&quot;, dependencies: [&quot;FooCore&quot;]), // Error FooCore is private.<br>&gt;        Target(name: &quot;SampleCLI&quot;, dependencies: [&quot;FooCore&quot;], isPrivate: true), // Not an error because SampleCLI is private.<br>&gt;    ])<br>&gt; Error: FooCore is a private target, it cannot be a dependency to the public target FooLibrary.<br>&gt; <br>&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#2-import-selected-targets-2&gt;2. Import selected targets:<br>&gt; <br>&gt; Consider a dependency with following manifest file:<br>&gt; <br>&gt; import PackageDescription<br>&gt; <br>&gt; let package = Package(<br>&gt;    name: &quot;FooLibrary&quot;,<br>&gt;    targets: [<br>&gt;        Target(name: &quot;Foo&quot;),<br>&gt;        Target(name: &quot;Bar&quot;, dependencies: [&quot;Foo&quot;]),<br>&gt;        Target(name: &quot;Baz&quot;),<br>&gt;    ])<br>&gt; To get only the Bar target from the above package, following manifest could be written:<br>&gt; <br>&gt; import PackageDescription<br>&gt; <br>&gt; let package = Package(<br>&gt;    name: &quot;FooUser&quot;,<br>&gt;    dependencies: [<br>&gt;        .Package(<br>&gt;            url: &quot;../FooLibrary&quot;, <br>&gt;            majorVersion: 1, <br>&gt;            targets: [&quot;Bar&quot;])<br>&gt;    ])<br>&gt; Note: In this case since Bar depends on Foo, Foo will be also be implicitly built and be available.<br>&gt; <br>&gt; Any target mentioned in targets and not present in the package should result in build failure.<br>&gt; <br>&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; There will be no impact on existing code as these features are additive.<br>&gt; <br>&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; None at this time.<br>&gt; <br>&gt; -- <br>&gt; Ankit<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160707/12af9706/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fd5bd4566ee1f286333b7dbf2df6fadb?s=50"></div><header><strong>Proposal: SwiftPM Target Access Control</strong> from <string>Anders Bertelrud</string> &lt;anders at apple.com&gt;<p>July  7, 2016 at 09:00:00am</p></header><div class="content"><p>Hello Ankit,<br></p><p>Thanks a lot for taking the initiative for this!  This looks like a great start.<br></p><p>I think what we will eventually want to do is to let package authors express the &quot;role&quot; of each target, which would then allow expression of such things as build-time vs run-time dependencies.  For example, in some cases there may be a dependency on a build tool (that generates code or formats resources in some way) and that affects such things as the platform and architectures for which the target should be built.<br></p><p>But that can all be added in the future.  I like the direction represented by this proposal, and I think it represents a good improvement on its own.  I do agree with other comments that it would be a great addition to let dependencies be specified at the target level, not just the package level.  That would be in scope for inclusion in this proposal.<br></p><p>Thanks!<br></p><p>Anders<br></p><p>&gt; On 2016-07-07, at 05.26, Ankit Agarwal via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi swift packagers,<br>&gt; <br>&gt; I am proposing access control to package targets. <br>&gt; <br>&gt; Link: https://github.com/aciidb0mb3r/swift-evolution/blob/swiftpm-module-access-control/proposals/xxxx-swiftpm-target-access-control.md &lt;https://github.com/aciidb0mb3r/swift-evolution/blob/swiftpm-module-access-control/proposals/xxxx-swiftpm-target-access-control.md&gt;<br>&gt; <br>&gt; Feedback appreciated!<br>&gt; <br>&gt; SwiftPM Target Access Control<br>&gt; <br>&gt; Proposal: SE-XXXX &lt;https://github.com/apple/swift-evolution/blob/master/proposals/xxxx-swiftpm-target-access-control.md&gt;<br>&gt; Author: Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt; Status: In Discussion<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal aims to address two issues:<br>&gt; <br>&gt; Control over the targets exposed (and built) when a SwiftPM package is used as a dependency.<br>&gt; <br>&gt; Import (and build) selected targets of a dependency.<br>&gt; <br>&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#motivation&gt;Motivation<br>&gt; <br>&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#1-control-over-exposed-targets&gt;1. Control over exposed targets:<br>&gt; <br>&gt; SwiftPM allows multiple targets (or modules) inside a package. Packages usually contain sample usage or example targets which are useful during development or testing of the package but are redundant when the package is used as a dependency. This increases compile time for the user of the package.<br>&gt; <br>&gt; As a concrete example: Vapor has a target called Development &lt;https://github.com/qutheory/vapor/tree/master/Sources/Development&gt;.<br>&gt; <br>&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#2-import-selected-targets&gt;2. Import selected targets:<br>&gt; <br>&gt; Sometimes user of a package is only interested in few targets of a dependency instead of all the targets. Currently there is no way to state this in Package.swift and all the targets are implicitly built and exposed to the user package.<br>&gt; <br>&gt; For e.g.: I would like to use the targets libc, POSIX, Basic of SwiftPM but don&#39;t want other targets to be built or exposed in my package.<br>&gt; <br>&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#proposed-solution&gt;Proposed Solution<br>&gt; <br>&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#1-control-over-exposed-targets-1&gt;1. Control over exposed targets:<br>&gt; <br>&gt; I propose that package authors be able mark the targets they don&#39;t want to be exposed as private i.e. the privatetargets will be built when that package is root package but not when the package is used as a dependency.<br>&gt; <br>&gt; To mark a target as private I propose PackageDescription&#39;s Target gains a isPrivate boolean property which defaults to false.<br>&gt; <br>&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#2-import-selected-targets-1&gt;2. Import selected targets:<br>&gt; <br>&gt; I propose that package user be able to specify the targets they want to import into their package.<br>&gt; <br>&gt; To specify the targets to be import I propose to add an optional string array property targets in PackageDescription&#39;s Package.Dependency which defaults to nil i.e. all targets.<br>&gt; <br>&gt; Instead of an optional string array property an enum can also be used:<br>&gt; <br>&gt; enum ImportedTargets {<br>&gt;     case allTargets // Import all the targets, default value.<br>&gt;     case targets([String]) // Import only these targets.<br>&gt; }<br>&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#detailed-design&gt;Detailed Design<br>&gt; <br>&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#1-control-over-exposed-targets-2&gt;1. Control over exposed targets:<br>&gt; <br>&gt; Consider a package with following structure: <br>&gt; <br>&gt; ├── Package.swift<br>&gt; └── Sources<br>&gt;     ├── FooLibrary<br>&gt;     │   └── Foo.swift<br>&gt;     └── SampleCLI<br>&gt;         └── main.swift<br>&gt; The manifest with private target could look like:<br>&gt; <br>&gt; import PackageDescription<br>&gt; <br>&gt; let package = Package(<br>&gt;    name: &quot;FooLibrary&quot;,<br>&gt;    targets: [<br>&gt;        Target(name: &quot;FooLibrary&quot;),<br>&gt;        Target(name: &quot;SampleCLI&quot;, isPrivate: true),<br>&gt;    ])<br>&gt; When this package is used as a dependency only FooLibrary is built and is importable.<br>&gt; <br>&gt; Targets can have other targets as dependency inside a package. A private target should only be a dependency to other private targets. For e.g. A manifest like this should result in a build failure.<br>&gt; <br>&gt; import PackageDescription<br>&gt; <br>&gt; let package = Package(<br>&gt;    name: &quot;FooLibrary&quot;,<br>&gt;    targets: [<br>&gt;        Target(name: &quot;FooCore&quot;, isPrivate: true),<br>&gt;        Target(name: &quot;FooLibrary&quot;, dependencies: [&quot;FooCore&quot;]), // Error FooCore is private.<br>&gt;        Target(name: &quot;SampleCLI&quot;, dependencies: [&quot;FooCore&quot;], isPrivate: true), // Not an error because SampleCLI is private.<br>&gt;    ])<br>&gt; Error: FooCore is a private target, it cannot be a dependency to the public target FooLibrary.<br>&gt; <br>&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#2-import-selected-targets-2&gt;2. Import selected targets:<br>&gt; <br>&gt; Consider a dependency with following manifest file:<br>&gt; <br>&gt; import PackageDescription<br>&gt; <br>&gt; let package = Package(<br>&gt;    name: &quot;FooLibrary&quot;,<br>&gt;    targets: [<br>&gt;        Target(name: &quot;Foo&quot;),<br>&gt;        Target(name: &quot;Bar&quot;, dependencies: [&quot;Foo&quot;]),<br>&gt;        Target(name: &quot;Baz&quot;),<br>&gt;    ])<br>&gt; To get only the Bar target from the above package, following manifest could be written:<br>&gt; <br>&gt; import PackageDescription<br>&gt; <br>&gt; let package = Package(<br>&gt;    name: &quot;FooUser&quot;,<br>&gt;    dependencies: [<br>&gt;        .Package(<br>&gt;            url: &quot;../FooLibrary&quot;, <br>&gt;            majorVersion: 1, <br>&gt;            targets: [&quot;Bar&quot;])<br>&gt;    ])<br>&gt; Note: In this case since Bar depends on Foo, Foo will be also be implicitly built and be available.<br>&gt; <br>&gt; Any target mentioned in targets and not present in the package should result in build failure.<br>&gt; <br>&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; There will be no impact on existing code as these features are additive.<br>&gt; <br>&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; None at this time.<br>&gt; <br>&gt; -- <br>&gt; Ankit<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160707/d2bc2ff7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05540cd6be96706f76aa66a4519f7db9?s=50"></div><header><strong>Proposal: SwiftPM Target Access Control</strong> from <string>Ankit Agarwal</string> &lt;ankit at ankit.im&gt;<p>July  8, 2016 at 12:00:00am</p></header><div class="content"><p>Hi,<br></p><p>Thanks for feedback. I agree that specifying external dependencies with<br>targets would be great.<br>I think the only thing issue is to figure out is how to specify them. Some<br>thoughts:<br></p><p>Note: Currently target name has to be unique across all the targets in the<br>package (including its dependencies).<br></p><p>1. Target(name: &quot;FooLibrary&quot;, dependencies: [&quot;FooCore&quot;, &quot;ExternalTarget&quot;])<br></p><p>pro: This is probably the easiest way to specify the external dependency<br>it. It fits perfectly into the current semantics and just needs to be<br>implemented for external deps.<br>con: No way to know which targets are external dependencies by just looking<br>at manifest file. No way to know from which package that dep is coming from.<br></p><p>2. Target(name: &quot;FooLibrary&quot;, dependencies: [&quot;FooCore&quot;],<br>externalDependencies: [&quot;ExternalTarget&quot;])<br></p><p>pro: Explicitly mentions what all external deps the target relies on.<br>con: Doesn&#39;t mention which package contains that external dep.<br></p><p>3. Target(name: &quot;FooLibrary&quot;, dependencies: [&quot;FooCore&quot;,<br>&quot;SomePackage.ExternalTarget&quot;])<br></p><p>pro: Mentions which package + target the external dependency belongs to.<br>con: is probably too verbose and stringly typed.<br></p><p>4. Target(name: &quot;FooLibrary&quot;, dependencies: [&quot;FooCore&quot;],<br>externalDependencies: [(&quot;SomePackage&quot;, &quot;ExternalTarget&quot;)])<br></p><p>pro: Mentions which package + target the external dependency belongs to.<br>con: verbose and stringly typed.<br></p><p>Would love some feedback or another way to better express the external<br>deps, will update the proposal then.<br></p><p>Thanks!<br></p><p>On Thu, Jul 7, 2016 at 9:35 PM, Anders Bertelrud &lt;anders at apple.com&gt; wrote:<br></p><p>&gt; Hello Ankit,<br>&gt;<br>&gt; Thanks a lot for taking the initiative for this!  This looks like a great<br>&gt; start.<br>&gt;<br>&gt; I think what we will eventually want to do is to let package authors<br>&gt; express the &quot;role&quot; of each target, which would then allow expression of<br>&gt; such things as build-time vs run-time dependencies.  For example, in some<br>&gt; cases there may be a dependency on a build tool (that generates code or<br>&gt; formats resources in some way) and that affects such things as the platform<br>&gt; and architectures for which the target should be built.<br>&gt;<br>&gt; But that can all be added in the future.  I like the direction represented<br>&gt; by this proposal, and I think it represents a good improvement on its own.<br>&gt; I do agree with other comments that it would be a great addition to let<br>&gt; dependencies be specified at the target level, not just the package level.<br>&gt; That would be in scope for inclusion in this proposal.<br>&gt;<br>&gt; Thanks!<br>&gt;<br>&gt; Anders<br>&gt;<br>&gt; On 2016-07-07, at 05.26, Ankit Agarwal via swift-build-dev &lt;<br>&gt; swift-build-dev at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi swift packagers,<br>&gt;<br>&gt; I am proposing access control to package targets.<br>&gt;<br>&gt; Link:<br>&gt; https://github.com/aciidb0mb3r/swift-evolution/blob/swiftpm-module-access-control/proposals/xxxx-swiftpm-target-access-control.md<br>&gt;<br>&gt; Feedback appreciated!<br>&gt;<br>&gt; SwiftPM Target Access Control<br>&gt;<br>&gt;    - Proposal: SE-XXXX<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/xxxx-swiftpm-target-access-control.md&gt;<br>&gt;    - Author: Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt;    - Status: In Discussion<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal aims to address two issues:<br>&gt;<br>&gt;    1.<br>&gt;<br>&gt;    Control over the targets exposed (and built) when a SwiftPM package is<br>&gt;    used as a dependency.<br>&gt;    2.<br>&gt;<br>&gt;    Import (and build) selected targets of a dependency.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#motivation&gt;<br>&gt; Motivation<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#1-control-over-exposed-targets&gt;1.<br>&gt; Control over exposed targets:<br>&gt;<br>&gt; SwiftPM allows multiple targets (or modules) inside a package. Packages<br>&gt; usually contain sample usage or example targets which are useful during<br>&gt; development or testing of the package but are redundant when the package is<br>&gt; used as a dependency. This increases compile time for the user of the<br>&gt; package.<br>&gt;<br>&gt; As a concrete example: Vapor has a target called Development<br>&gt; &lt;https://github.com/qutheory/vapor/tree/master/Sources/Development&gt;.<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#2-import-selected-targets&gt;2.<br>&gt; Import selected targets:<br>&gt;<br>&gt; Sometimes user of a package is only interested in few targets of a<br>&gt; dependency instead of all the targets. Currently there is no way to state<br>&gt; this in Package.swift and all the targets are implicitly built and<br>&gt; exposed to the user package.<br>&gt;<br>&gt; For e.g.: I would like to use the targets libc, POSIX, Basic of SwiftPM<br>&gt; but don&#39;t want other targets to be built or exposed in my package.<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#proposed-solution&gt;Proposed<br>&gt; Solution<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#1-control-over-exposed-targets-1&gt;1.<br>&gt; Control over exposed targets:<br>&gt;<br>&gt; I propose that package authors be able mark the targets they don&#39;t want to<br>&gt; be exposed as private i.e. the privatetargets will be built when that<br>&gt; package is root package but not when the package is used as a dependency.<br>&gt;<br>&gt; To mark a target as private I propose PackageDescription&#39;s Target gains a<br>&gt; isPrivate boolean property which defaults to false.<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#2-import-selected-targets-1&gt;2.<br>&gt; Import selected targets:<br>&gt;<br>&gt; I propose that package user be able to specify the targets they want to<br>&gt; import into their package.<br>&gt;<br>&gt; To specify the targets to be import I propose to add an optional string<br>&gt; array property targets in PackageDescription&#39;s Package.Dependency which<br>&gt; defaults to nil i.e. all targets.<br>&gt;<br>&gt; Instead of an optional string array property an enum can also be used:<br>&gt;<br>&gt; enum ImportedTargets {<br>&gt;     case allTargets // Import all the targets, default value.<br>&gt;     case targets([String]) // Import only these targets.<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#detailed-design&gt;Detailed<br>&gt; Design<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#1-control-over-exposed-targets-2&gt;1.<br>&gt; Control over exposed targets:<br>&gt;<br>&gt; Consider a package with following structure:<br>&gt;<br>&gt; ├── Package.swift<br>&gt; └── Sources<br>&gt;     ├── FooLibrary<br>&gt;     │   └── Foo.swift<br>&gt;     └── SampleCLI<br>&gt;         └── main.swift<br>&gt;<br>&gt; The manifest with private target could look like:<br>&gt;<br>&gt; import PackageDescription<br>&gt; let package = Package(<br>&gt;    name: &quot;FooLibrary&quot;,<br>&gt;    targets: [<br>&gt;        Target(name: &quot;FooLibrary&quot;),<br>&gt;        Target(name: &quot;SampleCLI&quot;, isPrivate: true),<br>&gt;    ])<br>&gt;<br>&gt; When this package is used as a dependency only FooLibrary is built and is<br>&gt; importable.<br>&gt;<br>&gt; Targets can have other targets as dependency inside a package. A private target<br>&gt; should only be a dependency to other private targets. For e.g. A manifest<br>&gt; like this should result in a build failure.<br>&gt;<br>&gt; import PackageDescription<br>&gt; let package = Package(<br>&gt;    name: &quot;FooLibrary&quot;,<br>&gt;    targets: [<br>&gt;        Target(name: &quot;FooCore&quot;, isPrivate: true),<br>&gt;        Target(name: &quot;FooLibrary&quot;, dependencies: [&quot;FooCore&quot;]), // Error FooCore is private.<br>&gt;        Target(name: &quot;SampleCLI&quot;, dependencies: [&quot;FooCore&quot;], isPrivate: true), // Not an error because SampleCLI is private.<br>&gt;    ])<br>&gt;<br>&gt; Error: FooCore is a private target, it cannot be a dependency to the<br>&gt; public target FooLibrary.<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#2-import-selected-targets-2&gt;2.<br>&gt; Import selected targets:<br>&gt;<br>&gt; Consider a dependency with following manifest file:<br>&gt;<br>&gt; import PackageDescription<br>&gt; let package = Package(<br>&gt;    name: &quot;FooLibrary&quot;,<br>&gt;    targets: [<br>&gt;        Target(name: &quot;Foo&quot;),<br>&gt;        Target(name: &quot;Bar&quot;, dependencies: [&quot;Foo&quot;]),<br>&gt;        Target(name: &quot;Baz&quot;),<br>&gt;    ])<br>&gt;<br>&gt; To get only the Bar target from the above package, following manifest<br>&gt; could be written:<br>&gt;<br>&gt; import PackageDescription<br>&gt; let package = Package(<br>&gt;    name: &quot;FooUser&quot;,<br>&gt;    dependencies: [<br>&gt;        .Package(<br>&gt;            url: &quot;../FooLibrary&quot;,<br>&gt;            majorVersion: 1,<br>&gt;            targets: [&quot;Bar&quot;])<br>&gt;    ])<br>&gt;<br>&gt; Note: In this case since Bar depends on Foo, Foo will be also be<br>&gt; implicitly built and be available.<br>&gt;<br>&gt; Any target mentioned in targets and not present in the package should<br>&gt; result in build failure.<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; There will be no impact on existing code as these features are additive.<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt; None at this time.<br>&gt;<br>&gt; --<br>&gt; Ankit<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br>Ankit<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160708/07a26d97/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3a28b53f05e7f3067fb104cb78fbb585?s=50"></div><header><strong>Proposal: SwiftPM Target Access Control</strong> from <string>Kostiantyn Koval</string> &lt;konstantin.koval1 at gmail.com&gt;<p>July  7, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi<br>Thanks for the proposal, looks very nice.<br></p><p>The Package.swift manifest files is very string typed already, (package name, url, target names, etc) and and think that is ok in our case.<br></p><p>We can make a type for external dependency that would have 2 properties: package and target.<br>That could help expressing a External dependency. <br></p><p>3. Target(name: &quot;FooLibrary&quot;, dependencies: [&quot;FooCore&quot;, External(package: “SomePackage”, target: &quot;ExternalTarget&quot;])<br>or<br>2. Target(name: &quot;FooLibrary&quot;, dependencies: [&quot;FooCore&quot;], externalDependencies: Dependency(package: “SomePackage”, target: &quot;ExternalTarget”])<br></p><p>Idea: <br>- How about making 2 types of targets in the Package, public and private<br></p><p>import PackageDescription<br></p><p>let package = Package(<br>   name: &quot;FooLibrary&quot;,<br>   targets: [<br>       Target(name: &quot;FooLibrary”),<br>   privateTargets: [<br>	Target(name: &quot;SampleCLI”)<br>   ])<br>By keeping private and public targets separate it would be easier for package author to organise them and don’t mix theirs dependencies, like in the example below<br>       Target(name: &quot;FooLibrary&quot;, dependencies: [&quot;FooCore&quot;]), // Error FooCore is private.<br></p><p>Thanks<br>- Kostiantyn<br></p><p>&gt; On 07 Jul 2016, at 20:45, Ankit Agarwal via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; Thanks for feedback. I agree that specifying external dependencies with targets would be great.<br>&gt; I think the only thing issue is to figure out is how to specify them. Some thoughts: <br>&gt; <br>&gt; Note: Currently target name has to be unique across all the targets in the package (including its dependencies).<br>&gt; <br>&gt; 1. Target(name: &quot;FooLibrary&quot;, dependencies: [&quot;FooCore&quot;, &quot;ExternalTarget&quot;])<br>&gt; <br>&gt; pro: This is probably the easiest way to specify the external dependency it. It fits perfectly into the current semantics and just needs to be implemented for external deps.<br>&gt; con: No way to know which targets are external dependencies by just looking at manifest file. No way to know from which package that dep is coming from.<br>&gt; <br>&gt; 2. Target(name: &quot;FooLibrary&quot;, dependencies: [&quot;FooCore&quot;], externalDependencies: [&quot;ExternalTarget&quot;])<br>&gt; <br>&gt; pro: Explicitly mentions what all external deps the target relies on.<br>&gt; con: Doesn&#39;t mention which package contains that external dep.<br>&gt; <br>&gt; 3. Target(name: &quot;FooLibrary&quot;, dependencies: [&quot;FooCore&quot;, &quot;SomePackage.ExternalTarget&quot;])<br>&gt; <br>&gt; pro: Mentions which package + target the external dependency belongs to.<br>&gt; con: is probably too verbose and stringly typed.<br>&gt; <br>&gt; 4. Target(name: &quot;FooLibrary&quot;, dependencies: [&quot;FooCore&quot;], externalDependencies: [(&quot;SomePackage&quot;, &quot;ExternalTarget&quot;)])<br>&gt; <br>&gt; pro: Mentions which package + target the external dependency belongs to.<br>&gt; con: verbose and stringly typed.<br>&gt; <br>&gt; Would love some feedback or another way to better express the external deps, will update the proposal then.<br>&gt; <br>&gt; Thanks!<br>&gt; <br>&gt; On Thu, Jul 7, 2016 at 9:35 PM, Anders Bertelrud &lt;anders at apple.com &lt;mailto:anders at apple.com&gt;&gt; wrote:<br>&gt; Hello Ankit,<br>&gt; <br>&gt; Thanks a lot for taking the initiative for this!  This looks like a great start.<br>&gt; <br>&gt; I think what we will eventually want to do is to let package authors express the &quot;role&quot; of each target, which would then allow expression of such things as build-time vs run-time dependencies.  For example, in some cases there may be a dependency on a build tool (that generates code or formats resources in some way) and that affects such things as the platform and architectures for which the target should be built.<br>&gt; <br>&gt; But that can all be added in the future.  I like the direction represented by this proposal, and I think it represents a good improvement on its own.  I do agree with other comments that it would be a great addition to let dependencies be specified at the target level, not just the package level.  That would be in scope for inclusion in this proposal.<br>&gt; <br>&gt; Thanks!<br>&gt; <br>&gt; Anders<br>&gt; <br>&gt;&gt; On 2016-07-07, at 05.26, Ankit Agarwal via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi swift packagers,<br>&gt;&gt; <br>&gt;&gt; I am proposing access control to package targets. <br>&gt;&gt; <br>&gt;&gt; Link: https://github.com/aciidb0mb3r/swift-evolution/blob/swiftpm-module-access-control/proposals/xxxx-swiftpm-target-access-control.md &lt;https://github.com/aciidb0mb3r/swift-evolution/blob/swiftpm-module-access-control/proposals/xxxx-swiftpm-target-access-control.md&gt;<br>&gt;&gt; <br>&gt;&gt; Feedback appreciated!<br>&gt;&gt; <br>&gt;&gt; SwiftPM Target Access Control<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-XXXX &lt;https://github.com/apple/swift-evolution/blob/master/proposals/xxxx-swiftpm-target-access-control.md&gt;<br>&gt;&gt; Author: Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt;&gt; Status: In Discussion<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal aims to address two issues:<br>&gt;&gt; <br>&gt;&gt; Control over the targets exposed (and built) when a SwiftPM package is used as a dependency.<br>&gt;&gt; <br>&gt;&gt; Import (and build) selected targets of a dependency.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#1-control-over-exposed-targets&gt;1. Control over exposed targets:<br>&gt;&gt; <br>&gt;&gt; SwiftPM allows multiple targets (or modules) inside a package. Packages usually contain sample usage or example targets which are useful during development or testing of the package but are redundant when the package is used as a dependency. This increases compile time for the user of the package.<br>&gt;&gt; <br>&gt;&gt; As a concrete example: Vapor has a target called Development &lt;https://github.com/qutheory/vapor/tree/master/Sources/Development&gt;.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#2-import-selected-targets&gt;2. Import selected targets:<br>&gt;&gt; <br>&gt;&gt; Sometimes user of a package is only interested in few targets of a dependency instead of all the targets. Currently there is no way to state this in Package.swift and all the targets are implicitly built and exposed to the user package.<br>&gt;&gt; <br>&gt;&gt; For e.g.: I would like to use the targets libc, POSIX, Basic of SwiftPM but don&#39;t want other targets to be built or exposed in my package.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#proposed-solution&gt;Proposed Solution<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#1-control-over-exposed-targets-1&gt;1. Control over exposed targets:<br>&gt;&gt; <br>&gt;&gt; I propose that package authors be able mark the targets they don&#39;t want to be exposed as private i.e. the privatetargets will be built when that package is root package but not when the package is used as a dependency.<br>&gt;&gt; <br>&gt;&gt; To mark a target as private I propose PackageDescription&#39;s Target gains a isPrivate boolean property which defaults to false.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#2-import-selected-targets-1&gt;2. Import selected targets:<br>&gt;&gt; <br>&gt;&gt; I propose that package user be able to specify the targets they want to import into their package.<br>&gt;&gt; <br>&gt;&gt; To specify the targets to be import I propose to add an optional string array property targets in PackageDescription&#39;s Package.Dependency which defaults to nil i.e. all targets.<br>&gt;&gt; <br>&gt;&gt; Instead of an optional string array property an enum can also be used:<br>&gt;&gt; <br>&gt;&gt; enum ImportedTargets {<br>&gt;&gt;     case allTargets // Import all the targets, default value.<br>&gt;&gt;     case targets([String]) // Import only these targets.<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#detailed-design&gt;Detailed Design<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#1-control-over-exposed-targets-2&gt;1. Control over exposed targets:<br>&gt;&gt; <br>&gt;&gt; Consider a package with following structure: <br>&gt;&gt; <br>&gt;&gt; ├── Package.swift<br>&gt;&gt; └── Sources<br>&gt;&gt;     ├── FooLibrary<br>&gt;&gt;     │   └── Foo.swift<br>&gt;&gt;     └── SampleCLI<br>&gt;&gt;         └── main.swift<br>&gt;&gt; The manifest with private target could look like:<br>&gt;&gt; <br>&gt;&gt; import PackageDescription<br>&gt;&gt; <br>&gt;&gt; let package = Package(<br>&gt;&gt;    name: &quot;FooLibrary&quot;,<br>&gt;&gt;    targets: [<br>&gt;&gt;        Target(name: &quot;FooLibrary&quot;),<br>&gt;&gt;        Target(name: &quot;SampleCLI&quot;, isPrivate: true),<br>&gt;&gt;    ])<br>&gt;&gt; When this package is used as a dependency only FooLibrary is built and is importable.<br>&gt;&gt; <br>&gt;&gt; Targets can have other targets as dependency inside a package. A private target should only be a dependency to other private targets. For e.g. A manifest like this should result in a build failure.<br>&gt;&gt; <br>&gt;&gt; import PackageDescription<br>&gt;&gt; <br>&gt;&gt; let package = Package(<br>&gt;&gt;    name: &quot;FooLibrary&quot;,<br>&gt;&gt;    targets: [<br>&gt;&gt;        Target(name: &quot;FooCore&quot;, isPrivate: true),<br>&gt;&gt;        Target(name: &quot;FooLibrary&quot;, dependencies: [&quot;FooCore&quot;]), // Error FooCore is private.<br>&gt;&gt;        Target(name: &quot;SampleCLI&quot;, dependencies: [&quot;FooCore&quot;], isPrivate: true), // Not an error because SampleCLI is private.<br>&gt;&gt;    ])<br>&gt;&gt; Error: FooCore is a private target, it cannot be a dependency to the public target FooLibrary.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#2-import-selected-targets-2&gt;2. Import selected targets:<br>&gt;&gt; <br>&gt;&gt; Consider a dependency with following manifest file:<br>&gt;&gt; <br>&gt;&gt; import PackageDescription<br>&gt;&gt; <br>&gt;&gt; let package = Package(<br>&gt;&gt;    name: &quot;FooLibrary&quot;,<br>&gt;&gt;    targets: [<br>&gt;&gt;        Target(name: &quot;Foo&quot;),<br>&gt;&gt;        Target(name: &quot;Bar&quot;, dependencies: [&quot;Foo&quot;]),<br>&gt;&gt;        Target(name: &quot;Baz&quot;),<br>&gt;&gt;    ])<br>&gt;&gt; To get only the Bar target from the above package, following manifest could be written:<br>&gt;&gt; <br>&gt;&gt; import PackageDescription<br>&gt;&gt; <br>&gt;&gt; let package = Package(<br>&gt;&gt;    name: &quot;FooUser&quot;,<br>&gt;&gt;    dependencies: [<br>&gt;&gt;        .Package(<br>&gt;&gt;            url: &quot;../FooLibrary&quot;, <br>&gt;&gt;            majorVersion: 1, <br>&gt;&gt;            targets: [&quot;Bar&quot;])<br>&gt;&gt;    ])<br>&gt;&gt; Note: In this case since Bar depends on Foo, Foo will be also be implicitly built and be available.<br>&gt;&gt; <br>&gt;&gt; Any target mentioned in targets and not present in the package should result in build failure.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#impact-on-existing-code&gt;Impact on Existing Code<br>&gt;&gt; <br>&gt;&gt; There will be no impact on existing code as these features are additive.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#alternatives-considered&gt;Alternatives Considered<br>&gt;&gt; <br>&gt;&gt; None at this time.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Ankit<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-build-dev mailing list<br>&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Ankit<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160707/a24a5172/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17301ad52a677b00a621c39ab052e16d?s=50"></div><header><strong>Proposal: SwiftPM Target Access Control</strong> from <string>Daniel Dunbar</string> &lt;daniel at zuster.org&gt;<p>July  8, 2016 at 04:00:00pm</p></header><div class="content"><p>On Thu, Jul 7, 2016 at 2:02 PM, Kostiantyn Koval via swift-build-dev &lt;<br>swift-build-dev at swift.org&gt; wrote:<br></p><p>&gt; Hi<br>&gt; Thanks for the proposal, looks very nice.<br>&gt;<br>&gt; The *Package.swift* manifest files is very string typed already, (package<br>&gt; name, url, target names, etc) and and think that is ok in our case.<br>&gt;<br>&gt; We can make a type for external dependency that would have 2<br>&gt; properties: package and target.<br>&gt; That could help expressing a External dependency.<br>&gt;<br>&gt; 3. Target(name: &quot;FooLibrary&quot;, dependencies: [&quot;FooCore&quot;, External(package:<br>&gt; “SomePackage”, target: &quot;ExternalTarget&quot;])<br>&gt;<br></p><p>I like this general direction... we would need to outline the exact<br>semantics (presumably `package` here is required to refer to a package<br>named in the overall package dependencies).<br></p><p>or<br>&gt; 2. Target(name: &quot;FooLibrary&quot;, dependencies: [&quot;FooCore&quot;],<br>&gt; externalDependencies: Dependency(package: “SomePackage”, target:<br>&gt; &quot;ExternalTarget”])<br>&gt;<br>&gt; Idea:<br>&gt; - How about making 2 types of targets in the Package, public and private<br>&gt;<br></p><p>I&#39;m less in favor of this, I think an attribute of the target is more<br>appropriate than a separate group. An attribute is more true to the actual<br>model the objects are defining, and I think in practice this will be more<br>annoying to the organization of targets than it is helpful. For example,<br>for many packages the right answer is to have *one* public target which is<br>the clean stable API you are trying to vend, so it doesn&#39;t add much value<br>to have other categories. For another, for complex packages with many<br>internal modules, the public/private nature may be driven by the layering<br>discipline of the project and only tangentially fall into the<br>public/private categories based on what the developers care to expose. If<br>you look at SwiftPM&#39;s manifest, for example, having two arrays would be<br>more annoying than helpful if we wanted to expose, say, libc, Basic and<br>Commands but not any of the others.<br></p><p> - Daniel<br></p><p><br>&gt; import PackageDescription<br>&gt; let package = Package(<br>&gt;    name: &quot;FooLibrary&quot;,<br>&gt;    targets: [<br>&gt;        Target(name: &quot;FooLibrary”),<br>&gt;    privateTargets: [	Target(name: &quot;SampleCLI”)<br>&gt;    ])<br>&gt;<br>&gt; By keeping private and public targets separate it would be easier for<br>&gt; package author to organise them and don’t mix theirs dependencies, like in<br>&gt; the example below<br>&gt;<br>&gt;        Target(name: &quot;FooLibrary&quot;, dependencies: [&quot;FooCore&quot;]), // Error FooCore is private.<br>&gt;<br>&gt;<br>&gt; Thanks<br>&gt; - Kostiantyn<br>&gt;<br>&gt; On 07 Jul 2016, at 20:45, Ankit Agarwal via swift-build-dev &lt;<br>&gt; swift-build-dev at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi,<br>&gt;<br>&gt; Thanks for feedback. I agree that specifying external dependencies with<br>&gt; targets would be great.<br>&gt; I think the only thing issue is to figure out is how to specify them. Some<br>&gt; thoughts:<br>&gt;<br>&gt; Note: Currently target name has to be unique across all the targets in the<br>&gt; package (including its dependencies).<br>&gt;<br>&gt; 1. Target(name: &quot;FooLibrary&quot;, dependencies: [&quot;FooCore&quot;, &quot;ExternalTarget&quot;])<br>&gt;<br>&gt; pro: This is probably the easiest way to specify the external dependency<br>&gt; it. It fits perfectly into the current semantics and just needs to be<br>&gt; implemented for external deps.<br>&gt; con: No way to know which targets are external dependencies by just<br>&gt; looking at manifest file. No way to know from which package that dep is<br>&gt; coming from.<br>&gt;<br>&gt; 2. Target(name: &quot;FooLibrary&quot;, dependencies: [&quot;FooCore&quot;],<br>&gt; externalDependencies: [&quot;ExternalTarget&quot;])<br>&gt;<br>&gt; pro: Explicitly mentions what all external deps the target relies on.<br>&gt; con: Doesn&#39;t mention which package contains that external dep.<br>&gt;<br>&gt; 3. Target(name: &quot;FooLibrary&quot;, dependencies: [&quot;FooCore&quot;,<br>&gt; &quot;SomePackage.ExternalTarget&quot;])<br>&gt;<br>&gt; pro: Mentions which package + target the external dependency belongs to.<br>&gt; con: is probably too verbose and stringly typed.<br>&gt;<br>&gt; 4. Target(name: &quot;FooLibrary&quot;, dependencies: [&quot;FooCore&quot;],<br>&gt; externalDependencies: [(&quot;SomePackage&quot;, &quot;ExternalTarget&quot;)])<br>&gt;<br>&gt; pro: Mentions which package + target the external dependency belongs to.<br>&gt; con: verbose and stringly typed.<br>&gt;<br>&gt; Would love some feedback or another way to better express the external<br>&gt; deps, will update the proposal then.<br>&gt;<br>&gt; Thanks!<br>&gt;<br>&gt; On Thu, Jul 7, 2016 at 9:35 PM, Anders Bertelrud &lt;anders at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; Hello Ankit,<br>&gt;&gt;<br>&gt;&gt; Thanks a lot for taking the initiative for this!  This looks like a great<br>&gt;&gt; start.<br>&gt;&gt;<br>&gt;&gt; I think what we will eventually want to do is to let package authors<br>&gt;&gt; express the &quot;role&quot; of each target, which would then allow expression of<br>&gt;&gt; such things as build-time vs run-time dependencies.  For example, in some<br>&gt;&gt; cases there may be a dependency on a build tool (that generates code or<br>&gt;&gt; formats resources in some way) and that affects such things as the platform<br>&gt;&gt; and architectures for which the target should be built.<br>&gt;&gt;<br>&gt;&gt; But that can all be added in the future.  I like the direction<br>&gt;&gt; represented by this proposal, and I think it represents a good improvement<br>&gt;&gt; on its own.  I do agree with other comments that it would be a great<br>&gt;&gt; addition to let dependencies be specified at the target level, not just the<br>&gt;&gt; package level.  That would be in scope for inclusion in this proposal.<br>&gt;&gt;<br>&gt;&gt; Thanks!<br>&gt;&gt;<br>&gt;&gt; Anders<br>&gt;&gt;<br>&gt;&gt; On 2016-07-07, at 05.26, Ankit Agarwal via swift-build-dev &lt;<br>&gt;&gt; swift-build-dev at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi swift packagers,<br>&gt;&gt;<br>&gt;&gt; I am proposing access control to package targets.<br>&gt;&gt;<br>&gt;&gt; Link:<br>&gt;&gt; https://github.com/aciidb0mb3r/swift-evolution/blob/swiftpm-module-access-control/proposals/xxxx-swiftpm-target-access-control.md<br>&gt;&gt;<br>&gt;&gt; Feedback appreciated!<br>&gt;&gt;<br>&gt;&gt; SwiftPM Target Access Control<br>&gt;&gt;<br>&gt;&gt;    - Proposal: SE-XXXX<br>&gt;&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/xxxx-swiftpm-target-access-control.md&gt;<br>&gt;&gt;    - Author: Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt;&gt;    - Status: In Discussion<br>&gt;&gt;    - Review manager: TBD<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#introduction&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; This proposal aims to address two issues:<br>&gt;&gt;<br>&gt;&gt;    1.<br>&gt;&gt;<br>&gt;&gt;    Control over the targets exposed (and built) when a SwiftPM package<br>&gt;&gt;    is used as a dependency.<br>&gt;&gt;    2.<br>&gt;&gt;<br>&gt;&gt;    Import (and build) selected targets of a dependency.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#motivation&gt;<br>&gt;&gt; Motivation<br>&gt;&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#1-control-over-exposed-targets&gt;1.<br>&gt;&gt; Control over exposed targets:<br>&gt;&gt;<br>&gt;&gt; SwiftPM allows multiple targets (or modules) inside a package. Packages<br>&gt;&gt; usually contain sample usage or example targets which are useful during<br>&gt;&gt; development or testing of the package but are redundant when the package is<br>&gt;&gt; used as a dependency. This increases compile time for the user of the<br>&gt;&gt; package.<br>&gt;&gt;<br>&gt;&gt; As a concrete example: Vapor has a target called Development<br>&gt;&gt; &lt;https://github.com/qutheory/vapor/tree/master/Sources/Development&gt;.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#2-import-selected-targets&gt;2.<br>&gt;&gt; Import selected targets:<br>&gt;&gt;<br>&gt;&gt; Sometimes user of a package is only interested in few targets of a<br>&gt;&gt; dependency instead of all the targets. Currently there is no way to state<br>&gt;&gt; this in Package.swift and all the targets are implicitly built and<br>&gt;&gt; exposed to the user package.<br>&gt;&gt;<br>&gt;&gt; For e.g.: I would like to use the targets libc, POSIX, Basic of SwiftPM<br>&gt;&gt; but don&#39;t want other targets to be built or exposed in my package.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#proposed-solution&gt;Proposed<br>&gt;&gt; Solution<br>&gt;&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#1-control-over-exposed-targets-1&gt;1.<br>&gt;&gt; Control over exposed targets:<br>&gt;&gt;<br>&gt;&gt; I propose that package authors be able mark the targets they don&#39;t want<br>&gt;&gt; to be exposed as private i.e. the privatetargets will be built when that<br>&gt;&gt; package is root package but not when the package is used as a dependency.<br>&gt;&gt;<br>&gt;&gt; To mark a target as private I propose PackageDescription&#39;s Target gains<br>&gt;&gt; a isPrivate boolean property which defaults to false.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#2-import-selected-targets-1&gt;2.<br>&gt;&gt; Import selected targets:<br>&gt;&gt;<br>&gt;&gt; I propose that package user be able to specify the targets they want to<br>&gt;&gt; import into their package.<br>&gt;&gt;<br>&gt;&gt; To specify the targets to be import I propose to add an optional string<br>&gt;&gt; array property targets in PackageDescription&#39;s Package.Dependency which<br>&gt;&gt; defaults to nil i.e. all targets.<br>&gt;&gt;<br>&gt;&gt; Instead of an optional string array property an enum can also be used:<br>&gt;&gt;<br>&gt;&gt; enum ImportedTargets {<br>&gt;&gt;     case allTargets // Import all the targets, default value.<br>&gt;&gt;     case targets([String]) // Import only these targets.<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#detailed-design&gt;Detailed<br>&gt;&gt; Design<br>&gt;&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#1-control-over-exposed-targets-2&gt;1.<br>&gt;&gt; Control over exposed targets:<br>&gt;&gt;<br>&gt;&gt; Consider a package with following structure:<br>&gt;&gt;<br>&gt;&gt; ├── Package.swift<br>&gt;&gt; └── Sources<br>&gt;&gt;     ├── FooLibrary<br>&gt;&gt;     │   └── Foo.swift<br>&gt;&gt;     └── SampleCLI<br>&gt;&gt;         └── main.swift<br>&gt;&gt;<br>&gt;&gt; The manifest with private target could look like:<br>&gt;&gt;<br>&gt;&gt; import PackageDescription<br>&gt;&gt; let package = Package(<br>&gt;&gt;    name: &quot;FooLibrary&quot;,<br>&gt;&gt;    targets: [<br>&gt;&gt;        Target(name: &quot;FooLibrary&quot;),<br>&gt;&gt;        Target(name: &quot;SampleCLI&quot;, isPrivate: true),<br>&gt;&gt;    ])<br>&gt;&gt;<br>&gt;&gt; When this package is used as a dependency only FooLibrary is built and<br>&gt;&gt; is importable.<br>&gt;&gt;<br>&gt;&gt; Targets can have other targets as dependency inside a package. A private target<br>&gt;&gt; should only be a dependency to other private targets. For e.g. A manifest<br>&gt;&gt; like this should result in a build failure.<br>&gt;&gt;<br>&gt;&gt; import PackageDescription<br>&gt;&gt; let package = Package(<br>&gt;&gt;    name: &quot;FooLibrary&quot;,<br>&gt;&gt;    targets: [<br>&gt;&gt;        Target(name: &quot;FooCore&quot;, isPrivate: true),<br>&gt;&gt;        Target(name: &quot;FooLibrary&quot;, dependencies: [&quot;FooCore&quot;]), // Error FooCore is private.<br>&gt;&gt;        Target(name: &quot;SampleCLI&quot;, dependencies: [&quot;FooCore&quot;], isPrivate: true), // Not an error because SampleCLI is private.<br>&gt;&gt;    ])<br>&gt;&gt;<br>&gt;&gt; Error: FooCore is a private target, it cannot be a dependency to the<br>&gt;&gt; public target FooLibrary.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#2-import-selected-targets-2&gt;2.<br>&gt;&gt; Import selected targets:<br>&gt;&gt;<br>&gt;&gt; Consider a dependency with following manifest file:<br>&gt;&gt;<br>&gt;&gt; import PackageDescription<br>&gt;&gt; let package = Package(<br>&gt;&gt;    name: &quot;FooLibrary&quot;,<br>&gt;&gt;    targets: [<br>&gt;&gt;        Target(name: &quot;Foo&quot;),<br>&gt;&gt;        Target(name: &quot;Bar&quot;, dependencies: [&quot;Foo&quot;]),<br>&gt;&gt;        Target(name: &quot;Baz&quot;),<br>&gt;&gt;    ])<br>&gt;&gt;<br>&gt;&gt; To get only the Bar target from the above package, following manifest<br>&gt;&gt; could be written:<br>&gt;&gt;<br>&gt;&gt; import PackageDescription<br>&gt;&gt; let package = Package(<br>&gt;&gt;    name: &quot;FooUser&quot;,<br>&gt;&gt;    dependencies: [<br>&gt;&gt;        .Package(<br>&gt;&gt;            url: &quot;../FooLibrary&quot;,<br>&gt;&gt;            majorVersion: 1,<br>&gt;&gt;            targets: [&quot;Bar&quot;])<br>&gt;&gt;    ])<br>&gt;&gt;<br>&gt;&gt; Note: In this case since Bar depends on Foo, Foo will be also be<br>&gt;&gt; implicitly built and be available.<br>&gt;&gt;<br>&gt;&gt; Any target mentioned in targets and not present in the package should<br>&gt;&gt; result in build failure.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#impact-on-existing-code&gt;Impact<br>&gt;&gt; on Existing Code<br>&gt;&gt;<br>&gt;&gt; There will be no impact on existing code as these features are additive.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#alternatives-considered&gt;Alternatives<br>&gt;&gt; Considered<br>&gt;&gt; None at this time.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Ankit<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-build-dev mailing list<br>&gt;&gt; swift-build-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Ankit<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160708/4a4005c8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17301ad52a677b00a621c39ab052e16d?s=50"></div><header><strong>Proposal: SwiftPM Target Access Control</strong> from <string>Daniel Dunbar</string> &lt;daniel at zuster.org&gt;<p>July  8, 2016 at 04:00:00pm</p></header><div class="content"><p>Some minor points:<br></p><p>1. One major reason for wanting control over which targets are exported are<br>so packages can control which parts of their API is supported for external<br>use. This is very important to large projects undergoing active development<br>while also trying to support a well-defined, semantically versioned API.<br></p><p>2. In keeping with #1, and the design of the Swift language, I think the<br>right default is for a module to be private/unexported. This is basically<br>for the same reasons as `internal` is the default access control modifier<br>in Swift. This also relates to the discussion below.<br></p><p>3. If we are going to add this via a new Target attribute, I suggest we do<br>so using a `flags` parameter and accompanying enumeration. This will be<br>equally readable, I think, but more extensible over time.<br></p><p>4. Technically, this proposal is defining two new few features, the<br>public/private exported/imported part and the ability for packages to<br>depend on specific targets. They are related problems, but the proposals<br>(and implementation) are otherwise somewhat orthogonal. I&#39;m fine combining<br>them into one proposal, but if it appears that one part is going to require<br>much more design or discussion than the other (or that the combined<br>discussion is too large) we might consider breaking them up.<br></p><p>There is a larger thing we need to consider with regard to the<br>public/private part of the proposal, and that is its relation to<br>hypothetical future support for package-level namespaces, whereby I mean<br>Swift language support for a new level of namespace (and accompanying<br>access control support in some form) for an entire Package. There are<br>several reasons I think that we will ultimately need such a thing, the most<br>major of which is the module-name collision problem (two packages that want<br>to use a shared common name for a module) that cannot be resolved by<br>SwiftPM without language support. Since such a feature is purely<br>hypothetical at this point, I don&#39;t think we need to block forward progress<br>in SwiftPM on it, but I do think we should discuss the consequences.<br></p><p>Some examples of how these things might be related:<br></p><p>1. The choice of `public/private` is probably wrong when viewed as a<br>language feature, since they already having existing meanings and<br>`internal` would be a more accurate name within the context of an<br>individual Package. I think we should include some discussion of the best<br>names if we reuse modifier names, or if there is a good argument for<br>finding alternate names (&quot;exported/unexported&quot;?).<br></p><p>2. Suppose Swift added support for a `package` namespace and access control<br>modifier. This might make it somewhat awkward if we had tied expectations<br>of what targets in an external dependency were built to a *manifest*-level<br>construct.<br></p><p>3. We should call out that public/private in this sense ultimately won&#39;t<br>have any enforcement by the compiler. If a public target exposes a type<br>declared in a private module implicitly (say via a return value), there<br>won&#39;t be any error, even though it breaks the encapsulation this feature<br>would partially be intended to provide. Similarly, nothing will prevent a<br>target from importing a private module from an external dependency if was<br>already a transitive dependency of some other public target.<br></p><p>It would be good to try and work through some of these issues and lay out<br>pros &amp; cons as well as other strategies we could use to mitigate them. In<br>the short term I think we will need to accept and implement some form of<br>this proposal, so this doesn&#39;t mean working out what a full solution would<br>look like, let&#39;s just make sure we aren&#39;t (unknowingly) painting ourselves<br>into a corner.<br></p><p> - Daniel<br></p><p><br>On Thu, Jul 7, 2016 at 6:26 AM, Ankit Agarwal via swift-build-dev &lt;<br>swift-build-dev at swift.org&gt; wrote:<br></p><p>&gt; Hi swift packagers,<br>&gt;<br>&gt; I am proposing access control to package targets.<br>&gt;<br>&gt; Link:<br>&gt; https://github.com/aciidb0mb3r/swift-evolution/blob/swiftpm-module-access-control/proposals/xxxx-swiftpm-target-access-control.md<br>&gt;<br>&gt; Feedback appreciated!<br>&gt;<br>&gt; SwiftPM Target Access Control<br>&gt;<br>&gt;    - Proposal: SE-XXXX<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/xxxx-swiftpm-target-access-control.md&gt;<br>&gt;    - Author: Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt;    - Status: In Discussion<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal aims to address two issues:<br>&gt;<br>&gt;    1.<br>&gt;<br>&gt;    Control over the targets exposed (and built) when a SwiftPM package is<br>&gt;    used as a dependency.<br>&gt;    2.<br>&gt;<br>&gt;    Import (and build) selected targets of a dependency.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#motivation&gt;<br>&gt; Motivation<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#1-control-over-exposed-targets&gt;1.<br>&gt; Control over exposed targets:<br>&gt;<br>&gt; SwiftPM allows multiple targets (or modules) inside a package. Packages<br>&gt; usually contain sample usage or example targets which are useful during<br>&gt; development or testing of the package but are redundant when the package is<br>&gt; used as a dependency. This increases compile time for the user of the<br>&gt; package.<br>&gt;<br>&gt; As a concrete example: Vapor has a target called Development<br>&gt; &lt;https://github.com/qutheory/vapor/tree/master/Sources/Development&gt;.<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#2-import-selected-targets&gt;2.<br>&gt; Import selected targets:<br>&gt;<br>&gt; Sometimes user of a package is only interested in few targets of a<br>&gt; dependency instead of all the targets. Currently there is no way to state<br>&gt; this in Package.swift and all the targets are implicitly built and<br>&gt; exposed to the user package.<br>&gt;<br>&gt; For e.g.: I would like to use the targets libc, POSIX, Basic of SwiftPM<br>&gt; but don&#39;t want other targets to be built or exposed in my package.<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#proposed-solution&gt;Proposed<br>&gt; Solution<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#1-control-over-exposed-targets-1&gt;1.<br>&gt; Control over exposed targets:<br>&gt;<br>&gt; I propose that package authors be able mark the targets they don&#39;t want to<br>&gt; be exposed as private i.e. the privatetargets will be built when that<br>&gt; package is root package but not when the package is used as a dependency.<br>&gt;<br>&gt; To mark a target as private I propose PackageDescription&#39;s Target gains a<br>&gt; isPrivate boolean property which defaults to false.<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#2-import-selected-targets-1&gt;2.<br>&gt; Import selected targets:<br>&gt;<br>&gt; I propose that package user be able to specify the targets they want to<br>&gt; import into their package.<br>&gt;<br>&gt; To specify the targets to be import I propose to add an optional string<br>&gt; array property targets in PackageDescription&#39;s Package.Dependency which<br>&gt; defaults to nil i.e. all targets.<br>&gt;<br>&gt; Instead of an optional string array property an enum can also be used:<br>&gt;<br>&gt; enum ImportedTargets {<br>&gt;     case allTargets // Import all the targets, default value.<br>&gt;     case targets([String]) // Import only these targets.<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#detailed-design&gt;Detailed<br>&gt; Design<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#1-control-over-exposed-targets-2&gt;1.<br>&gt; Control over exposed targets:<br>&gt;<br>&gt; Consider a package with following structure:<br>&gt;<br>&gt; ├── Package.swift<br>&gt; └── Sources<br>&gt;     ├── FooLibrary<br>&gt;     │   └── Foo.swift<br>&gt;     └── SampleCLI<br>&gt;         └── main.swift<br>&gt;<br>&gt; The manifest with private target could look like:<br>&gt;<br>&gt; import PackageDescription<br>&gt; let package = Package(<br>&gt;    name: &quot;FooLibrary&quot;,<br>&gt;    targets: [<br>&gt;        Target(name: &quot;FooLibrary&quot;),<br>&gt;        Target(name: &quot;SampleCLI&quot;, isPrivate: true),<br>&gt;    ])<br>&gt;<br>&gt; When this package is used as a dependency only FooLibrary is built and is<br>&gt; importable.<br>&gt;<br>&gt; Targets can have other targets as dependency inside a package. A private target<br>&gt; should only be a dependency to other private targets. For e.g. A manifest<br>&gt; like this should result in a build failure.<br>&gt;<br>&gt; import PackageDescription<br>&gt; let package = Package(<br>&gt;    name: &quot;FooLibrary&quot;,<br>&gt;    targets: [<br>&gt;        Target(name: &quot;FooCore&quot;, isPrivate: true),<br>&gt;        Target(name: &quot;FooLibrary&quot;, dependencies: [&quot;FooCore&quot;]), // Error FooCore is private.<br>&gt;        Target(name: &quot;SampleCLI&quot;, dependencies: [&quot;FooCore&quot;], isPrivate: true), // Not an error because SampleCLI is private.<br>&gt;    ])<br>&gt;<br>&gt; Error: FooCore is a private target, it cannot be a dependency to the<br>&gt; public target FooLibrary.<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#2-import-selected-targets-2&gt;2.<br>&gt; Import selected targets:<br>&gt;<br>&gt; Consider a dependency with following manifest file:<br>&gt;<br>&gt; import PackageDescription<br>&gt; let package = Package(<br>&gt;    name: &quot;FooLibrary&quot;,<br>&gt;    targets: [<br>&gt;        Target(name: &quot;Foo&quot;),<br>&gt;        Target(name: &quot;Bar&quot;, dependencies: [&quot;Foo&quot;]),<br>&gt;        Target(name: &quot;Baz&quot;),<br>&gt;    ])<br>&gt;<br>&gt; To get only the Bar target from the above package, following manifest<br>&gt; could be written:<br>&gt;<br>&gt; import PackageDescription<br>&gt; let package = Package(<br>&gt;    name: &quot;FooUser&quot;,<br>&gt;    dependencies: [<br>&gt;        .Package(<br>&gt;            url: &quot;../FooLibrary&quot;,<br>&gt;            majorVersion: 1,<br>&gt;            targets: [&quot;Bar&quot;])<br>&gt;    ])<br>&gt;<br>&gt; Note: In this case since Bar depends on Foo, Foo will be also be<br>&gt; implicitly built and be available.<br>&gt;<br>&gt; Any target mentioned in targets and not present in the package should<br>&gt; result in build failure.<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; There will be no impact on existing code as these features are additive.<br>&gt;<br>&gt; &lt;https://github.com/aciidb0mb3r/swift-evolution/tree/swiftpm-module-access-control#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt;<br>&gt; None at this time.<br>&gt;<br>&gt; --<br>&gt; Ankit<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160708/05ae34b8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05540cd6be96706f76aa66a4519f7db9?s=50"></div><header><strong>Proposal: SwiftPM Target Access Control</strong> from <string>Ankit Agarwal</string> &lt;ankit at ankit.im&gt;<p>July 11, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; 1. One major reason for wanting control over which targets are exported<br>&gt; are so packages can control which parts of their API is supported for<br>&gt; external use. This is very important to large projects undergoing active<br>&gt; development while also trying to support a well-defined, semantically<br>&gt; versioned API.<br>&gt;<br>&gt; 2. In keeping with #1, and the design of the Swift language, I think the<br>&gt; right default is for a module to be private/unexported. This is basically<br>&gt; for the same reasons as `internal` is the default access control modifier<br>&gt; in Swift. This also relates to the discussion below.<br>&gt;<br></p><p>I agree keeping things unexported/internal will make sure a certain module<br>is not being used as a dependency when it shouldn&#39;t. I also think the<br>default behaviour of a dependency package being exposed to every target<br>should be discontinued with this proposal and each target which wants to<br>use a certain external dependency should require explicit declaration. This<br>will make the manifest file clearer as to which target exactly depends on<br>what.<br>However it might break all currently packages (which is probably okay) but<br>it might also get confusing for beginners that why their package is not<br>compiling after declaring the external package. We can probably provide a<br>useful warning when an external package is declared but there is no<br>reference of it in any of the targets.<br></p><p><br>&gt; 3. If we are going to add this via a new Target attribute, I suggest we do<br>&gt; so using a `flags` parameter and accompanying enumeration. This will be<br>&gt; equally readable, I think, but more extensible over time.<br>&gt;<br>4. Technically, this proposal is defining two new few features, the<br>&gt; public/private exported/imported part and the ability for packages to<br>&gt; depend on specific targets. They are related problems, but the proposals<br>&gt; (and implementation) are otherwise somewhat orthogonal. I&#39;m fine combining<br>&gt; them into one proposal, but if it appears that one part is going to require<br>&gt; much more design or discussion than the other (or that the combined<br>&gt; discussion is too large) we might consider breaking them up.<br>&gt;<br>&gt;<br>I agree.<br></p><p><br>&gt; There is a larger thing we need to consider with regard to the<br>&gt; public/private part of the proposal, and that is its relation to<br>&gt; hypothetical future support for package-level namespaces, whereby I mean<br>&gt; Swift language support for a new level of namespace (and accompanying<br>&gt; access control support in some form) for an entire Package. There are<br>&gt; several reasons I think that we will ultimately need such a thing, the most<br>&gt; major of which is the module-name collision problem (two packages that want<br>&gt; to use a shared common name for a module) that cannot be resolved by<br>&gt; SwiftPM without language support. Since such a feature is purely<br>&gt; hypothetical at this point, I don&#39;t think we need to block forward progress<br>&gt; in SwiftPM on it, but I do think we should discuss the consequences.<br>&gt;<br>&gt; Some examples of how these things might be related:<br>&gt;<br>&gt; 1. The choice of `public/private` is probably wrong when viewed as a<br>&gt; language feature, since they already having existing meanings and<br>&gt; `internal` would be a more accurate name within the context of an<br>&gt; individual Package. I think we should include some discussion of the best<br>&gt; names if we reuse modifier names, or if there is a good argument for<br>&gt; finding alternate names (&quot;exported/unexported&quot;?).<br>&gt;<br></p><p>if things are going to be private/internal/unexported by default, I think<br>we only need to define the public/exported name. Exported seems like the<br>correct name for this behaviour and is well known however I think public is<br>also equally clear (and simple) here.<br></p><p><br>&gt; 2. Suppose Swift added support for a `package` namespace and access<br>&gt; control modifier. This might make it somewhat awkward if we had tied<br>&gt; expectations of what targets in an external dependency were built to a<br>&gt; *manifest*-level construct.<br>&gt;<br></p><p>If such a feature is added to swift it would probably require to rethink<br>the manifest file but I agree we should try to minimize the damage if<br>possible.<br></p><p><br>&gt;<br>&gt; 3. We should call out that public/private in this sense ultimately won&#39;t<br>&gt; have any enforcement by the compiler. If a public target exposes a type<br>&gt; declared in a private module implicitly (say via a return value), there<br>&gt; won&#39;t be any error, even though it breaks the encapsulation this feature<br>&gt; would partially be intended to provide. Similarly, nothing will prevent a<br>&gt; target from importing a private module from an external dependency if was<br>&gt; already a transitive dependency of some other public target.<br>&gt;<br></p><p>In the current draft proposal I mentioned private target&#39;s dependency can<br>only be another private target for the same reason but I think the approach<br>of having dependencies providing one (or more) well maintained exported<br>target makes more sense. True as of now we cannot enforce this and modules<br>can and will leak out. Maybe we can implement some form of enforcer or<br>checker using SourceKit in future.<br></p><p>-- <br>Ankit<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160711/a2a89548/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Proposal: SwiftPM Target Access Control</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>July 11, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 8:30 AM, Ankit Agarwal via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;  <br>&gt; 1. One major reason for wanting control over which targets are exported are so packages can control which parts of their API is supported for external use. This is very important to large projects undergoing active development while also trying to support a well-defined, semantically versioned API.<br>&gt; <br>&gt; 2. In keeping with #1, and the design of the Swift language, I think the right default is for a module to be private/unexported. This is basically for the same reasons as `internal` is the default access control modifier in Swift. This also relates to the discussion below.<br>&gt; <br>&gt; I agree keeping things unexported/internal will make sure a certain module is not being used as a dependency when it shouldn&#39;t. I also think the default behaviour of a dependency package being exposed to every target should be discontinued with this proposal and each target which wants to use a certain external dependency should require explicit declaration. This will make the manifest file clearer as to which target exactly depends on what.<br>&gt; However it might break all currently packages (which is probably okay) but it might also get confusing for beginners that why their package is not compiling after declaring the external package. We can probably provide a useful warning when an external package is declared but there is no reference of it in any of the targets.<br></p><p>Ya, there are pros/cons here, probably a good start is to just have the proposal articulate each of them and pick the one that looks best after that.<br></p><p>Another choice would be to have some more subtle default (like export single module packages by default, or export all root targets (ones with no dependents) by default, or export the eponymous target). The latter two seem like relatives ok defaults to me, but its much less obvious to have a more complex defaulting strategy.<br></p><p>Yet another choice would be to separate the declaration of the public modules from any individual target, and keep the default that they be all exported, but if a target chooses to explicitly define a list of exported ones, then that project adopts full control. This has the advantage that only larger projects which care about the distinction need worry about the maintenance of the list.<br></p><p>&gt; 3. If we are going to add this via a new Target attribute, I suggest we do so using a `flags` parameter and accompanying enumeration. This will be equally readable, I think, but more extensible over time. <br>&gt; 4. Technically, this proposal is defining two new few features, the public/private exported/imported part and the ability for packages to depend on specific targets. They are related problems, but the proposals (and implementation) are otherwise somewhat orthogonal. I&#39;m fine combining them into one proposal, but if it appears that one part is going to require much more design or discussion than the other (or that the combined discussion is too large) we might consider breaking them up.<br>&gt; <br>&gt; <br>&gt; I agree.<br>&gt;  <br>&gt; There is a larger thing we need to consider with regard to the public/private part of the proposal, and that is its relation to hypothetical future support for package-level namespaces, whereby I mean Swift language support for a new level of namespace (and accompanying access control support in some form) for an entire Package. There are several reasons I think that we will ultimately need such a thing, the most major of which is the module-name collision problem (two packages that want to use a shared common name for a module) that cannot be resolved by SwiftPM without language support. Since such a feature is purely hypothetical at this point, I don&#39;t think we need to block forward progress in SwiftPM on it, but I do think we should discuss the consequences.<br>&gt; <br>&gt; Some examples of how these things might be related:<br>&gt; <br>&gt; 1. The choice of `public/private` is probably wrong when viewed as a language feature, since they already having existing meanings and `internal` would be a more accurate name within the context of an individual Package. I think we should include some discussion of the best names if we reuse modifier names, or if there is a good argument for finding alternate names (&quot;exported/unexported&quot;?).<br>&gt; <br>&gt; if things are going to be private/internal/unexported by default, I think we only need to define the public/exported name. Exported seems like the correct name for this behaviour and is well known however I think public is also equally clear (and simple) here.<br></p><p>I agree picking the public name is somewhat nicer, and could go either way on the name.<br></p><p>&gt; 2. Suppose Swift added support for a `package` namespace and access control modifier. This might make it somewhat awkward if we had tied expectations of what targets in an external dependency were built to a *manifest*-level construct.<br>&gt; <br>&gt; If such a feature is added to swift it would probably require to rethink the manifest file but I agree we should try to minimize the damage if possible.<br></p><p>True.<br></p><p>&gt; 3. We should call out that public/private in this sense ultimately won&#39;t have any enforcement by the compiler. If a public target exposes a type declared in a private module implicitly (say via a return value), there won&#39;t be any error, even though it breaks the encapsulation this feature would partially be intended to provide. Similarly, nothing will prevent a target from importing a private module from an external dependency if was already a transitive dependency of some other public target.<br>&gt; <br>&gt; In the current draft proposal I mentioned private target&#39;s dependency can only be another private target for the same reason but I think the approach of having dependencies providing one (or more) well maintained exported target makes more sense. True as of now we cannot enforce this and modules can and will leak out. Maybe we can implement some form of enforcer or checker using SourceKit in future.<br></p><p>FWIW, my hope is we can eventually get a compiler feature which will allow us to enforce this...<br></p><p> - Daniel<br></p><p>&gt;  <br>&gt; -- <br>&gt; Ankit<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160711/96a0a329/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05540cd6be96706f76aa66a4519f7db9?s=50"></div><header><strong>Proposal: SwiftPM Target Access Control</strong> from <string>Ankit Agarwal</string> &lt;ankit at ankit.im&gt;<p>July 12, 2016 at 11:00:00pm</p></header><div class="content"><p>I have updated the proposal accommodating recent discussion<br></p><p>Link:<br>https://github.com/aciidb0mb3r/swift-evolution/blob/swiftpm-module-access-control/proposals/xxxx-swiftpm-target-access-control.md<br></p><p>SwiftPM Target Access Control<br></p><p>   - Proposal: SE-XXXX<br>   &lt;https://github.com/apple/swift-evolution/blob/master/proposals/xxxx-swiftpm-target-access-control.md&gt;<br>   - Author: Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>   - Status: *In Discussion*<br>   - Review manager: TBD<br></p><p>Introduction<br></p><p>This proposal aims to address two issues:<br></p><p>   1.<br></p><p>   Control over the targets exposed (and built) when a SwiftPM package is<br>   used as a dependency i.e. the targets which are exported and can be used in<br>   other packages.<br>   2.<br></p><p>   Specify external target dependencies of a target.<br></p><p>swift-evolution thread<br>&lt;https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160704/000531.html&gt;<br>Motivation1. Control over exposed targets:<br></p><p>SwiftPM allows multiple targets (or modules) inside a package. Most of the<br>time package author will want to provide one (or more) stable<br>public/exported target which should be utilised by other packages. We<br>should actively discourage use of targets which are not meant to be<br>imported by other packages.<br></p><p>Additionally packages usually contain sample usage or example targets which<br>are useful during development or testing of the package but are redundant<br>when the package is used as a dependency. This increases compilation time<br>for the user of the package which can be avoided.<br></p><p>As a concrete example: Vapor has a target called Development<br>&lt;https://github.com/qutheory/vapor/tree/master/Sources/Development&gt;.<br>2. Specify external target dependencies of a target:<br></p><p>Currently all the targets of an external dependency are implicitly built<br>and exposed to the user package. This works well for one target package but<br>becomes unclear which targets are using which target of an external<br>dependency.<br></p><p>Moreover user of a package may only be interested in few targets of a<br>dependency instead of all the exposed targets. Currently there is no way to<br>state this in Package.swift.<br></p><p>For e.g.: One would like to use the targets libc, POSIX, Basic of SwiftPM<br>but don&#39;t want other targets to be built or exposed in their package.<br>Proposed Solution1. Control over exposed targets:<br></p><p>I propose that all targets should by default be private/unexported. Authors<br>should explicitly mark the targets they want to expose as exported/public.<br></p><p>To mark a target as exported/public I propose PackageDescription&#39;s Target gains<br>a flags property which would be a Set of the following Flag enum declared<br>inside Target class:<br></p><p>public enum Flag {<br>    /// Makes the target public or &quot;exported&quot; for other packages to use.<br>    case public}<br></p><p>The Flag enum will be flexible in case we need to add more attributes in<br>future as opposed to a boolean property to mark the public nature of the<br>target.<br></p><p>exported is also a choice instead of public which matches the semantics<br>here. However public is equally clear in current context.<br></p><p>We can keep some obvious defaults for targets which can be implicitly<br>public for e.g.<br></p><p>   1. Package has only one target.<br>   2. Target with same name as package.<br></p><p>Or have all targets be public (the current behaviour) until some target<br>uses the public flag assuming full control over all the exported target.<br>This has an advantage that only larger projects which cares about this need<br>to maintain it.<br></p><p>However I believe private by default and explicit public declaration is the<br>right way to go here to avoid the misuse of packages/targets which are not<br>intended to act as a dependency and the public targets will become obvious<br>(and documented) in the manifest file.<br></p><p>It should be noted that this behaviour cannot be enforced by the compiler<br>right now and there is no way to stop symbols from other modules from<br>leaking out. For e.g. there could be a type used in the public interface<br>which belongs to a private target.<br></p><p>Dependencies of the public targets will also leak and can be imported since<br>they&#39;ll become transitive dependency of some target.<br></p><p>Hopefully we can enforce this using compiler feature in future.<br></p><p>Swift compiler might gain support for package-level namespaces and access<br>control in future to solve problems like module name collision i.e. two<br>packages have modules with same name. At that point we will probably need<br>to rethink the manifest file.<br>2. Specify external target dependencies of a target:<br></p><p>I propose that enum Target.Dependency gains a new case External(package:<br>String, target: String) to declare dependency on an external package&#39;s<br>target. The enum would look like this after modification:<br></p><p>/// The description for an individual target or package<br>dependency.public enum Dependency {<br>    /// A dependency on a target in the same project.<br>    case Target(name: String)<br>    /// A dependency on a target in a external package.<br>    case External(package: String, target: String)}<br></p><p>Note that the package name is not *really* needed (at least currently)<br>because the target names has to be unique across the dependency graph but<br>it keeps the manifest file cleaner i.e. which external package this<br>external target belongs to.<br></p><p>An external package dependency declaration implicitly becomes dependency of<br>each target in the package. I propose this behaviour should be retained but<br>if a target dependency contains an External declaration then all other<br>targets which wants to use that external dependency should explicitly state<br>their dependency on that external package using External.<br>Detailed Design1. Control over exposed targets:<br></p><p>Consider a package with following structure:<br></p><p>├── Package.swift<br>└── Sources<br>    ├── FooLibrary<br>    │   └── Foo.swift<br>    └── SampleCLI<br>        └── main.swift<br></p><p>The manifest with a public target could look like:<br></p><p>import PackageDescription<br>let package = Package(<br>   name: &quot;FooLibrary&quot;,<br>   targets: [<br>       Target(name: &quot;FooLibrary&quot;, flags: [.public]),<br>       Target(name: &quot;SampleCLI&quot;, dependencies: [&quot;FooLibrary&quot;]),<br>   ])<br></p><p>When this package is used as a dependency only FooLibrary is built and is<br>importable.<br>2. Specify external target dependencies of a target:<br></p><p>Consider a dependency with following manifest file:<br></p><p>import PackageDescription<br>let package = Package(<br>   name: &quot;FooLibrary&quot;,<br>   targets: [<br>       Target(name: &quot;Foo&quot;),<br>       Target(name: &quot;Bar&quot;, dependencies: [&quot;Foo&quot;], flags: [.public]),<br>       Target(name: &quot;Baz&quot;, flags: [.public]),<br>   ])<br></p><p>To get only the Bar target from the above package, following manifest could<br>be written:<br></p><p>import PackageDescription<br>let package = Package(<br>   name: &quot;BarUser&quot;,<br>   targets: [<br>        Target(name: &quot;BarUser&quot;,<br>               dependencies: [.External(package: &quot;FooLibrary&quot;, target: &quot;Bar&quot;)<br>               ])<br>   ],<br>   dependencies: [<br>       .Package(<br>           url: &quot;../FooLibrary&quot;,<br>           majorVersion: 1)<br>   ])<br></p><p>Note: In this case since Bar depends on Foo, Foo will be also be implicitly<br>built but Baz need not be compiled at all.<br></p><p>Also Note: If the external dependency is not declared then both Bar<br>and Baz will<br>be available to BarUser.<br>Impact on Existing Code1. Control over exposed targets:<br></p><p>All targets will become private by default so package authors will need to<br>mark the targets they want to expose as public.<br>2. Specify external target dependencies of a target:<br></p><p>None as all the public targets will still be dependencies to the overall<br>package when External is not used.<br>Alternatives Considered<br></p><p>None at this time.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160712/f66cc682/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc38aef146f886571b3c445851add884?s=50"></div><header><strong>Proposal: SwiftPM Target Access Control</strong> from <string>Honza Dvorsky</string> &lt;jan.dvorsky at me.com&gt;<p>July 13, 2016 at 08:00:00am</p></header><div class="content"><p>Very happy to see this proposal, thanks Ankit for pushing it forward! I<br>can&#39;t wait to be able to hide many example executables in my packages, as<br>I&#39;ve been getting a steady stream of complaints from people being annoyed<br>about the polluted compilation log and slower compilation times.<br></p><p>However I&#39;m leaning towards keeping the default module visibility to<br>*public*, not *private*. I appreciate all the arguments that compare<br>targets with code in Swift, where the default is internal - and it makes<br>sense. But the more pragmatic side of me feels that it might become a piece<br>of boilerplate we&#39;ll have to write in our manifests for a long time,<br>without much benefit (but with regret). And adding magic to sometimes<br>export by default (single module packages or modules matching the packages<br>name) IMO just complicates the conceptual model of how SwiftPM treats<br>package manifests. I think we should be very careful with adding such<br>nonlinear behaviors (where e.g. adding another module suddenly breaks the<br>package&#39;s visible targets), and in this case I don&#39;t believe it&#39;s<br>justified. (That&#39;s while completely ignoring the fact that such a change<br>would break 100% of packages out there, which could be a toll on the good<br>will the project seems to have right now. Not that we should never make<br>breaking changes, I just feel we should give a good reason we&#39;re making<br>them, potentially to allow a new feature. Which is not the case here.)<br></p><p>That&#39;s my two cents. :)<br></p><p>Overall I&#39;m enthusiastic about this proposal, it will solve a few real<br>issues I&#39;m having with my projects!<br></p><p>While I don&#39;t think we should add this to the proposal - it might be very<br>useful to add a mode to SwiftPM that dumps the module visibility<br>information. I think that should be added regardless of what the default<br>visibility ends up being.<br></p><p>Something like:<br>*$ swift package show-target-visibility*<br>Found 3 modules<br></p><p>*Public:*<br>Foo<br></p><p>*Private:*<br>PrivateBar<br>ExampleFoo<br></p><p>- Honza<br></p><p>On Tue, Jul 12, 2016 at 8:16 PM Ankit Agarwal via swift-build-dev &lt;<br>swift-build-dev at swift.org&gt; wrote:<br></p><p>&gt; I have updated the proposal accommodating recent discussion<br>&gt;<br>&gt; Link:<br>&gt; https://github.com/aciidb0mb3r/swift-evolution/blob/swiftpm-module-access-control/proposals/xxxx-swiftpm-target-access-control.md<br>&gt;<br>&gt; SwiftPM Target Access Control<br>&gt;<br>&gt;    - Proposal: SE-XXXX<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/xxxx-swiftpm-target-access-control.md&gt;<br>&gt;    - Author: Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt;    - Status: *In Discussion*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal aims to address two issues:<br>&gt;<br>&gt;    1.<br>&gt;<br>&gt;    Control over the targets exposed (and built) when a SwiftPM package is<br>&gt;    used as a dependency i.e. the targets which are exported and can be used in<br>&gt;    other packages.<br>&gt;    2.<br>&gt;<br>&gt;    Specify external target dependencies of a target.<br>&gt;<br>&gt; swift-evolution thread<br>&gt; &lt;https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160704/000531.html&gt;<br>&gt; Motivation1. Control over exposed targets:<br>&gt;<br>&gt; SwiftPM allows multiple targets (or modules) inside a package. Most of the<br>&gt; time package author will want to provide one (or more) stable<br>&gt; public/exported target which should be utilised by other packages. We<br>&gt; should actively discourage use of targets which are not meant to be<br>&gt; imported by other packages.<br>&gt;<br>&gt; Additionally packages usually contain sample usage or example targets<br>&gt; which are useful during development or testing of the package but are<br>&gt; redundant when the package is used as a dependency. This increases<br>&gt; compilation time for the user of the package which can be avoided.<br>&gt;<br>&gt; As a concrete example: Vapor has a target called Development<br>&gt; &lt;https://github.com/qutheory/vapor/tree/master/Sources/Development&gt;.<br>&gt; 2. Specify external target dependencies of a target:<br>&gt;<br>&gt; Currently all the targets of an external dependency are implicitly built<br>&gt; and exposed to the user package. This works well for one target package but<br>&gt; becomes unclear which targets are using which target of an external<br>&gt; dependency.<br>&gt;<br>&gt; Moreover user of a package may only be interested in few targets of a<br>&gt; dependency instead of all the exposed targets. Currently there is no way to<br>&gt; state this in Package.swift.<br>&gt;<br>&gt; For e.g.: One would like to use the targets libc, POSIX, Basic of SwiftPM<br>&gt; but don&#39;t want other targets to be built or exposed in their package.<br>&gt; Proposed Solution1. Control over exposed targets:<br>&gt;<br>&gt; I propose that all targets should by default be private/unexported.<br>&gt; Authors should explicitly mark the targets they want to expose as<br>&gt; exported/public.<br>&gt;<br>&gt; To mark a target as exported/public I propose PackageDescription&#39;s Target gains<br>&gt; a flags property which would be a Set of the following Flag enum declared<br>&gt; inside Target class:<br>&gt;<br>&gt; public enum Flag {<br>&gt;     /// Makes the target public or &quot;exported&quot; for other packages to use.<br>&gt;     case public}<br>&gt;<br>&gt; The Flag enum will be flexible in case we need to add more attributes in<br>&gt; future as opposed to a boolean property to mark the public nature of the<br>&gt; target.<br>&gt;<br>&gt; exported is also a choice instead of public which matches the semantics<br>&gt; here. However public is equally clear in current context.<br>&gt;<br>&gt; We can keep some obvious defaults for targets which can be implicitly<br>&gt; public for e.g.<br>&gt;<br>&gt;    1. Package has only one target.<br>&gt;    2. Target with same name as package.<br>&gt;<br>&gt; Or have all targets be public (the current behaviour) until some target<br>&gt; uses the public flag assuming full control over all the exported target.<br>&gt; This has an advantage that only larger projects which cares about this need<br>&gt; to maintain it.<br>&gt;<br>&gt; However I believe private by default and explicit public declaration is<br>&gt; the right way to go here to avoid the misuse of packages/targets which are<br>&gt; not intended to act as a dependency and the public targets will become<br>&gt; obvious (and documented) in the manifest file.<br>&gt;<br>&gt; It should be noted that this behaviour cannot be enforced by the compiler<br>&gt; right now and there is no way to stop symbols from other modules from<br>&gt; leaking out. For e.g. there could be a type used in the public interface<br>&gt; which belongs to a private target.<br>&gt;<br>&gt; Dependencies of the public targets will also leak and can be imported<br>&gt; since they&#39;ll become transitive dependency of some target.<br>&gt;<br>&gt; Hopefully we can enforce this using compiler feature in future.<br>&gt;<br>&gt; Swift compiler might gain support for package-level namespaces and access<br>&gt; control in future to solve problems like module name collision i.e. two<br>&gt; packages have modules with same name. At that point we will probably need<br>&gt; to rethink the manifest file.<br>&gt; 2. Specify external target dependencies of a target:<br>&gt;<br>&gt; I propose that enum Target.Dependency gains a new case External(package:<br>&gt; String, target: String) to declare dependency on an external package&#39;s<br>&gt; target. The enum would look like this after modification:<br>&gt;<br>&gt; /// The description for an individual target or package dependency.public enum Dependency {<br>&gt;     /// A dependency on a target in the same project.<br>&gt;     case Target(name: String)<br>&gt;     /// A dependency on a target in a external package.<br>&gt;     case External(package: String, target: String)}<br>&gt;<br>&gt; Note that the package name is not *really* needed (at least currently)<br>&gt; because the target names has to be unique across the dependency graph but<br>&gt; it keeps the manifest file cleaner i.e. which external package this<br>&gt; external target belongs to.<br>&gt;<br>&gt; An external package dependency declaration implicitly becomes dependency<br>&gt; of each target in the package. I propose this behaviour should be retained<br>&gt; but if a target dependency contains an External declaration then all<br>&gt; other targets which wants to use that external dependency should explicitly<br>&gt; state their dependency on that external package using External.<br>&gt; Detailed Design1. Control over exposed targets:<br>&gt;<br>&gt; Consider a package with following structure:<br>&gt;<br>&gt; ├── Package.swift<br>&gt; └── Sources<br>&gt;     ├── FooLibrary<br>&gt;     │   └── Foo.swift<br>&gt;     └── SampleCLI<br>&gt;         └── main.swift<br>&gt;<br>&gt; The manifest with a public target could look like:<br>&gt;<br>&gt; import PackageDescription<br>&gt; let package = Package(<br>&gt;    name: &quot;FooLibrary&quot;,<br>&gt;    targets: [<br>&gt;<br>&gt;<br>&gt;        Target(name: &quot;FooLibrary&quot;, flags: [.public]),<br>&gt;        Target(name: &quot;SampleCLI&quot;, dependencies: [&quot;FooLibrary&quot;]),<br>&gt;    ])<br>&gt;<br>&gt; When this package is used as a dependency only FooLibrary is built and is<br>&gt; importable.<br>&gt; 2. Specify external target dependencies of a target:<br>&gt;<br>&gt; Consider a dependency with following manifest file:<br>&gt;<br>&gt; import PackageDescription<br>&gt; let package = Package(<br>&gt;    name: &quot;FooLibrary&quot;,<br>&gt;    targets: [<br>&gt;        Target(name: &quot;Foo&quot;),<br>&gt;<br>&gt;<br>&gt;        Target(name: &quot;Bar&quot;, dependencies: [&quot;Foo&quot;], flags: [.public]),<br>&gt;        Target(name: &quot;Baz&quot;, flags: [.public]),<br>&gt;    ])<br>&gt;<br>&gt; To get only the Bar target from the above package, following manifest<br>&gt; could be written:<br>&gt;<br>&gt; import PackageDescription<br>&gt; let package = Package(<br>&gt;<br>&gt;<br>&gt;    name: &quot;BarUser&quot;,<br>&gt;    targets: [<br>&gt;         Target(name: &quot;BarUser&quot;,<br>&gt;                dependencies: [.External(package: &quot;FooLibrary&quot;, target: &quot;Bar&quot;)<br>&gt;                ])<br>&gt;    ],<br>&gt;<br>&gt;<br>&gt;    dependencies: [<br>&gt;        .Package(<br>&gt;            url: &quot;../FooLibrary&quot;,<br>&gt;<br>&gt;<br>&gt;            majorVersion: 1)<br>&gt;    ])<br>&gt;<br>&gt; Note: In this case since Bar depends on Foo, Foo will be also be<br>&gt; implicitly built but Baz need not be compiled at all.<br>&gt;<br>&gt; Also Note: If the external dependency is not declared then both Bar and<br>&gt; Baz will be available to BarUser.<br>&gt; Impact on Existing Code<br>&gt; 1. Control over exposed targets:<br>&gt;<br>&gt; All targets will become private by default so package authors will need to<br>&gt; mark the targets they want to expose as public.<br>&gt; 2. Specify external target dependencies of a target:<br>&gt;<br>&gt; None as all the public targets will still be dependencies to the overall<br>&gt; package when External is not used.<br>&gt; Alternatives Considered<br>&gt;<br>&gt; None at this time.<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160713/11441dd8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Proposal: SwiftPM Target Access Control</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>July 13, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jul 13, 2016, at 1:56 AM, Honza Dvorsky &lt;jan.dvorsky at me.com&gt; wrote:<br>&gt; <br>&gt; Very happy to see this proposal, thanks Ankit for pushing it forward! I can&#39;t wait to be able to hide many example executables in my packages, as I&#39;ve been getting a steady stream of complaints from people being annoyed about the polluted compilation log and slower compilation times.<br>&gt; <br>&gt; However I&#39;m leaning towards keeping the default module visibility to public, not private. I appreciate all the arguments that compare targets with code in Swift, where the default is internal - and it makes sense. But the more pragmatic side of me feels that it might become a piece of boilerplate we&#39;ll have to write in our manifests for a long time, without much benefit (but with regret). And adding magic to sometimes export by default (single module packages or modules matching the packages name) IMO just complicates the conceptual model of how SwiftPM treats package manifests. I think we should be very careful with adding such nonlinear behaviors (where e.g. adding another module suddenly breaks the package&#39;s visible targets), and in this case I don&#39;t believe it&#39;s justified. (That&#39;s while completely ignoring the fact that such a change would break 100% of packages out there, which could be a toll on the good will the project seems to have right now. Not that we should never make breaking changes, I just feel we should give a good reason we&#39;re making them, potentially to allow a new feature. Which is not the case here.) <br></p><p>I agree, this is a big concern of mine as well.<br></p><p>Ankit and I discussed this at length last night and he has updated the proposal here:<br>  https://github.com/aciidb0mb3r/swift-evolution/blob/swiftpm-module-access-control/proposals/xxxx-swiftpm-target-access-control.md &lt;https://github.com/aciidb0mb3r/swift-evolution/blob/swiftpm-module-access-control/proposals/xxxx-swiftpm-target-access-control.md&gt;<br></p><p>&gt; That&#39;s my two cents. :)<br>&gt; <br>&gt; Overall I&#39;m enthusiastic about this proposal, it will solve a few real issues I&#39;m having with my projects! <br>&gt; <br>&gt; While I don&#39;t think we should add this to the proposal - it might be very useful to add a mode to SwiftPM that dumps the module visibility information. I think that should be added regardless of what the default visibility ends up being.<br></p><p>I agree. I would like a `swift package describe` which shows how the convention system and manifest are causing the package to be interpreted. It would show things like the targets, dependencies, etc.<br></p><p> - Daniel<br></p><p>&gt; Something like:<br>&gt; $ swift package show-target-visibility<br>&gt; Found 3 modules<br>&gt; <br>&gt; Public:<br>&gt; Foo<br>&gt; <br>&gt; Private:<br>&gt; PrivateBar<br>&gt; ExampleFoo<br>&gt; <br>&gt; - Honza<br>&gt; <br>&gt; On Tue, Jul 12, 2016 at 8:16 PM Ankit Agarwal via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt; I have updated the proposal accommodating recent discussion<br>&gt; <br>&gt; Link: https://github.com/aciidb0mb3r/swift-evolution/blob/swiftpm-module-access-control/proposals/xxxx-swiftpm-target-access-control.md &lt;https://github.com/aciidb0mb3r/swift-evolution/blob/swiftpm-module-access-control/proposals/xxxx-swiftpm-target-access-control.md&gt;<br>&gt; <br>&gt; SwiftPM Target Access Control<br>&gt; Proposal: SE-XXXX &lt;https://github.com/apple/swift-evolution/blob/master/proposals/xxxx-swiftpm-target-access-control.md&gt;<br>&gt; Author: Ankit Aggarwal &lt;https://github.com/aciidb0mb3r&gt;<br>&gt; Status: In Discussion<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; This proposal aims to address two issues:<br>&gt; <br>&gt; Control over the targets exposed (and built) when a SwiftPM package is used as a dependency i.e. the targets which are exported and can be used in other packages.<br>&gt; <br>&gt; Specify external target dependencies of a target.<br>&gt; <br>&gt; swift-evolution thread &lt;https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160704/000531.html&gt;<br>&gt; Motivation<br>&gt; 1. Control over exposed targets:<br>&gt; <br>&gt; SwiftPM allows multiple targets (or modules) inside a package. Most of the time package author will want to provide one (or more) stable public/exported target which should be utilised by other packages. We should actively discourage use of targets which are not meant to be imported by other packages.<br>&gt; <br>&gt; Additionally packages usually contain sample usage or example targets which are useful during development or testing of the package but are redundant when the package is used as a dependency. This increases compilation time for the user of the package which can be avoided.<br>&gt; <br>&gt; As a concrete example: Vapor has a target called Development &lt;https://github.com/qutheory/vapor/tree/master/Sources/Development&gt;.<br>&gt; <br>&gt; 2. Specify external target dependencies of a target:<br>&gt; <br>&gt; Currently all the targets of an external dependency are implicitly built and exposed to the user package. This works well for one target package but becomes unclear which targets are using which target of an external dependency.<br>&gt; <br>&gt; Moreover user of a package may only be interested in few targets of a dependency instead of all the exposed targets. Currently there is no way to state this in Package.swift.<br>&gt; <br>&gt; For e.g.: One would like to use the targets libc, POSIX, Basic of SwiftPM but don&#39;t want other targets to be built or exposed in their package.<br>&gt; <br>&gt; Proposed Solution<br>&gt; 1. Control over exposed targets:<br>&gt; <br>&gt; I propose that all targets should by default be private/unexported. Authors should explicitly mark the targets they want to expose as exported/public.<br>&gt; <br>&gt; To mark a target as exported/public I propose PackageDescription&#39;s Target gains a flags property which would be a Set of the following Flag enum declared inside Target class:<br>&gt; <br>&gt; public enum Flag {<br>&gt;     /// Makes the target public or &quot;exported&quot; for other packages to use.<br>&gt;     case public<br>&gt; }<br>&gt; The Flag enum will be flexible in case we need to add more attributes in future as opposed to a boolean property to mark the public nature of the target.<br>&gt; <br>&gt; exported is also a choice instead of public which matches the semantics here. However public is equally clear in current context.<br>&gt; <br>&gt; We can keep some obvious defaults for targets which can be implicitly public for e.g. <br>&gt; <br>&gt; Package has only one target.<br>&gt; Target with same name as package.<br>&gt; Or have all targets be public (the current behaviour) until some target uses the public flag assuming full control over all the exported target. This has an advantage that only larger projects which cares about this need to maintain it.<br>&gt; <br>&gt; However I believe private by default and explicit public declaration is the right way to go here to avoid the misuse of packages/targets which are not intended to act as a dependency and the public targets will become obvious (and documented) in the manifest file.<br>&gt; <br>&gt; It should be noted that this behaviour cannot be enforced by the compiler right now and there is no way to stop symbols from other modules from leaking out. For e.g. there could be a type used in the public interface which belongs to a private target.<br>&gt; <br>&gt; Dependencies of the public targets will also leak and can be imported since they&#39;ll become transitive dependency of some target.<br>&gt; <br>&gt; Hopefully we can enforce this using compiler feature in future.<br>&gt; <br>&gt; Swift compiler might gain support for package-level namespaces and access control in future to solve problems like module name collision i.e. two packages have modules with same name. At that point we will probably need to rethink the manifest file.<br>&gt; <br>&gt; 2. Specify external target dependencies of a target:<br>&gt; <br>&gt; I propose that enum Target.Dependency gains a new case External(package: String, target: String) to declare dependency on an external package&#39;s target. The enum would look like this after modification:<br>&gt; <br>&gt; /// The description for an individual target or package dependency.<br>&gt; public enum Dependency {<br>&gt;     /// A dependency on a target in the same project.<br>&gt;     case Target(name: String)<br>&gt;     /// A dependency on a target in a external package.<br>&gt;     case External(package: String, target: String)<br>&gt; }<br>&gt; Note that the package name is not really needed (at least currently) because the target names has to be unique across the dependency graph but it keeps the manifest file cleaner i.e. which external package this external target belongs to.<br>&gt; <br>&gt; An external package dependency declaration implicitly becomes dependency of each target in the package. I propose this behaviour should be retained but if a target dependency contains an External declaration then all other targets which wants to use that external dependency should explicitly state their dependency on that external package using External.<br>&gt; <br>&gt; Detailed Design<br>&gt; 1. Control over exposed targets:<br>&gt; <br>&gt; Consider a package with following structure: <br>&gt; <br>&gt; ├── Package.swift<br>&gt; └── Sources<br>&gt;     ├── FooLibrary<br>&gt;     │   └── Foo.swift<br>&gt;     └── SampleCLI<br>&gt;         └── main.swift<br>&gt; The manifest with a public target could look like:<br>&gt; <br>&gt; import PackageDescription<br>&gt; <br>&gt; let package = Package(<br>&gt;    name: &quot;FooLibrary&quot;,<br>&gt;    targets: [<br>&gt; <br>&gt;        Target(name: &quot;FooLibrary&quot;, flags: [.public]),<br>&gt;        Target(name: &quot;SampleCLI&quot;, dependencies: [&quot;FooLibrary&quot;]),<br>&gt;    ])<br>&gt; When this package is used as a dependency only FooLibrary is built and is importable.<br>&gt; <br>&gt; 2. Specify external target dependencies of a target:<br>&gt; <br>&gt; Consider a dependency with following manifest file:<br>&gt; <br>&gt; import PackageDescription<br>&gt; <br>&gt; let package = Package(<br>&gt;    name: &quot;FooLibrary&quot;,<br>&gt;    targets: [<br>&gt;        Target(name: &quot;Foo&quot;),<br>&gt; <br>&gt;        Target(name: &quot;Bar&quot;, dependencies: [&quot;Foo&quot;], flags: [.public]),<br>&gt;        Target(name: &quot;Baz&quot;, flags: [.public]),<br>&gt;    ])<br>&gt; To get only the Bar target from the above package, following manifest could be written:<br>&gt; <br>&gt; import PackageDescription<br>&gt; <br>&gt; let package = Package(<br>&gt; <br>&gt;    name: &quot;BarUser&quot;,<br>&gt;    targets: [<br>&gt;         Target(name: &quot;BarUser&quot;, <br>&gt;                dependencies: [.External(package: &quot;FooLibrary&quot;, target: &quot;Bar&quot;)<br>&gt;                ])<br>&gt;    ],<br>&gt; <br>&gt;    dependencies: [<br>&gt;        .Package(<br>&gt;            url: &quot;../FooLibrary&quot;,<br>&gt;  <br>&gt;            majorVersion: 1)<br>&gt;    ])<br>&gt; Note: In this case since Bar depends on Foo, Foo will be also be implicitly built but Baz need not be compiled at all.<br>&gt; <br>&gt; Also Note: If the external dependency is not declared then both Bar and Baz will be available to BarUser.<br>&gt; <br>&gt; Impact on Existing Code<br>&gt; 1. Control over exposed targets:<br>&gt; <br>&gt; All targets will become private by default so package authors will need to mark the targets they want to expose as public.<br>&gt; <br>&gt; 2. Specify external target dependencies of a target:<br>&gt; <br>&gt; None as all the public targets will still be dependencies to the overall package when External is not used.<br>&gt; <br>&gt; Alternatives Considered<br>&gt; None at this time.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160713/540ec782/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fd5bd4566ee1f286333b7dbf2df6fadb?s=50"></div><header><strong>Proposal: SwiftPM Target Access Control</strong> from <string>Anders Bertelrud</string> &lt;anders at apple.com&gt;<p>July 13, 2016 at 08:00:00am</p></header><div class="content"><p>Thanks for taking the initiative for this, Ankit.  It&#39;s a very welcome improvement.<br></p><p>Comments inline.<br></p><p>On 2016-07-12, at 11.15, Ankit Agarwal via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; To mark a target as exported/public I propose PackageDescription&#39;s Target gains a flags property which would be a Set of the following Flag enum declared inside Target class:<br>&gt; <br>&gt; public enum Flag {<br>&gt;     /// Makes the target public or &quot;exported&quot; for other packages to use.<br>&gt;     case public<br>&gt; }<br>&gt; The Flag enum will be flexible in case we need to add more attributes in future as opposed to a boolean property to mark the public nature of the target.<br>&gt; <br>I would prefer that this be a boolean parameter rather than a generic `flags` parameter, since it makes the manifest read more naturally, and, importantly, is no less extensible than an enum.  Additional parameters with default values can as easily be added as more enum cases can, and in either case, a manifest written to assume the existence of `public` will be equally incompatible with older versions of the package manager.<br></p><p>So, for example:<br></p><p>let package = Package(<br>   name: &quot;FooLibrary&quot;,<br>   targets: [<br>       Target(name: &quot;FooLibrary&quot;, public: true),<br>       Target(name: &quot;SampleCLI&quot;, dependencies: [&quot;FooLibrary&quot;]),<br>   ])<br>&gt; We can keep some obvious defaults for targets which can be implicitly public for e.g. <br>&gt; <br>&gt; Package has only one target.<br>&gt; Target with same name as package.<br>I&#39;m a bit wary of magic here.  I think it would be clearer to have the manifest declare what is public and what is not.  With magic naming conventions it&#39;s too easy to accidentally change semantics just by renaming a target.<br>&gt; I propose that enum Target.Dependency gains a new case External(package: String, target: String) to declare dependency on an external package&#39;s target.<br>&gt; <br>Since it&#39;s the same fundamental kind of dependency in either case, would it be better to have `package` be an optional parameter to Target?<br></p><p>So that `Target(name: &quot;Foo&quot;)` is local but `Target(name: &quot;Foo&quot;, package: &quot;Bar&quot;)` external?  That would seem more logical.<br></p><p>Anders<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160713/67576b9f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05540cd6be96706f76aa66a4519f7db9?s=50"></div><header><strong>Proposal: SwiftPM Target Access Control</strong> from <string>Ankit Agarwal</string> &lt;ankit at ankit.im&gt;<p>July 13, 2016 at 09:00:00pm</p></header><div class="content"><p>On Wed, Jul 13, 2016 at 9:27 PM, Anders Bertelrud &lt;anders at apple.com&gt; wrote:<br></p><p>&gt; Thanks for taking the initiative for this, Ankit.  It&#39;s a very welcome<br>&gt; improvement.<br>&gt;<br>&gt; Comments inline.<br>&gt;<br>&gt; On 2016-07-12, at 11.15, Ankit Agarwal via swift-build-dev &lt;<br>&gt; swift-build-dev at swift.org&gt; wrote:<br>&gt;<br>&gt; To mark a target as exported/public I propose PackageDescription&#39;s Target gains<br>&gt; a flags property which would be a Set of the following Flag enum declared<br>&gt; inside Target class:<br>&gt;<br>&gt; public enum Flag {<br>&gt;     /// Makes the target public or &quot;exported&quot; for other packages to use.<br>&gt;     case public}<br>&gt;<br>&gt; The Flag enum will be flexible in case we need to add more attributes in<br>&gt; future as opposed to a boolean property to mark the public nature of the<br>&gt; target.<br>&gt;<br>&gt; I would prefer that this be a boolean parameter rather than a generic<br>&gt; `flags` parameter, since it makes the manifest read more naturally, and,<br>&gt; importantly, is no less extensible than an enum.  Additional parameters<br>&gt; with default values can as easily be added as more enum cases can, and in<br>&gt; either case, a manifest written to assume the existence of `public` will be<br>&gt; equally incompatible with older versions of the package manager.<br>&gt;<br>&gt; So, for example:<br>&gt;<br>&gt; let package = Package(<br>&gt;    name: &quot;FooLibrary&quot;,<br>&gt;    targets: [<br>&gt;        Target(name: &quot;FooLibrary&quot;, public: true),<br>&gt;        Target(name: &quot;SampleCLI&quot;, dependencies: [&quot;FooLibrary&quot;]),<br>&gt;    ])<br>&gt;<br>&gt; We can keep some obvious defaults for targets which can be implicitly<br>&gt; public for e.g.<br>&gt;<br>&gt;    1. Package has only one target.<br>&gt;    2. Target with same name as package.<br>&gt;<br>&gt; I&#39;m a bit wary of magic here.  I think it would be clearer to have the<br>&gt; manifest declare what is public and what is not.  With magic naming<br>&gt; conventions it&#39;s too easy to accidentally change semantics just by renaming<br>&gt; a target.<br>&gt;<br></p><p>I agree that we should avoid too much magic, I think you missed the<br>sentence below those examples in the proposal where I mentioned that we<br>should avoid those instead. However as Daniel mentioned we don&#39;t want to<br>overcomplicate the manifest for simple packages and for beginners, keeping<br>that in mind we updated the proposed solution which you can find on the<br>proposal link (<br>https://github.com/aciidb0mb3r/swift-evolution/blob/swiftpm-module-access-control/proposals/xxxx-swiftpm-target-access-control.md<br>)<br></p><p><br>&gt; I propose that enum Target.Dependency gains a new case External(package:<br>&gt; String, target: String) to declare dependency on an external package&#39;s<br>&gt; target.<br>&gt;<br>&gt; Since it&#39;s the same fundamental kind of dependency in either case, would<br>&gt; it be better to have `package` be an optional parameter to Target?<br>&gt;<br>&gt; So that `Target(name: &quot;Foo&quot;)` is local but `Target(name: &quot;Foo&quot;, package:<br>&gt; &quot;Bar&quot;)` external?  That would seem more logical.<br>&gt;<br>&gt;<br>I like `Target(name: &quot;Foo&quot;, package: &quot;Bar&quot;)` but I prefer package name is<br>stated before the target name `Target(package: &quot;Foo&quot;, name: &quot;Bar&quot;)` but<br>then this gets weird and `Target(package:target)` is also weird so I chose<br>`External(package:target)` instead. However if people prefer<br>`Target(name:package)` more then I am fine with it.<br></p><p>-- <br>Ankit<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160713/6049abc2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
