<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Idea for declaring expected types and value ranges</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>December  3, 2015 at 04:00:00pm</p></header><div class="content"><p>It may be nice to have a keyword that tells the compiler to try to statically prove certain conditions are true after some point without needing to leave the scope or wrap it in an if-let or something else that happens at runtime. This way the compiler could check the validity of the assertion and it would do so at compile time.<br></p><p>For example, imagine using something like this to unwrap an optional beyond a certain point in the function body:<br></p><p>func doSomething() -&gt; Int {<br>  var something: Int? = nil<br></p><p>  if something == nil {<br>     something = 42<br>  }<br></p><p>  require something: Int<br></p><p>  return something * 2<br>}<br></p><p>The compiler would be expected to prove that at the ?require? line, ?something? could be an ?Int? (non-optional). If the compiler cannot prove that, it is an error. If it can prove it, the type of the variable is effectively changed from that point on (the compiler effectively changes all instances of ?something? to ?something!? - but it knows it should never fail which might mean it could avoid doing certain checks and it eliminates a piece of state from the mind of the programmer).<br></p><p>This idea could be extended in other ways, potentially, if you could specify rules in a flexible enough way. For example, imagine being able to declare a constraint on the ranges of basic value types:<br></p><p>require x in 0?1<br>let result = someValue * x<br></p><p>Ideally, the compiler would then attempt to prove that x must always be in the range of 0?1 at this point. If it cannot prove this to be true, then it would be a compiler error.<br></p><p>Going farther, you could use the same thing on type declarations themselves so you could have a Float that could only contain 0?1:<br></p><p>var scaler: Float in 0?1<br></p><p>Or build a function that has constrained input ranges:<br></p><p>func scale(x: Float in 0?1) -&gt; Float {<br>  return someValue * x<br>}<br></p><p>I like the idea of this always being a compile-time check when possible, but it could also be useful to force the requirement to be evaluated at runtime by adding a force operator to it:<br></p><p>func scale(x: Float in! 0?1) -&gt; Float {<br>  return someValue * x<br>}<br></p><p>In this scenario the compiler would probably still try to prove it statically - and if it could, it?d skip runtime checks - but if it cannot, it would then insert runtime guards that catch requirement failures and crash as necessary - similar to a forced unwrap - instead of being a compile time error.<br></p><p>l8r<br>Sean<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d30e546d655d1c7ece0464791a9a90d5?s=50"></div><header><strong>Idea for declaring expected types and value ranges</strong> from <string>Adrian Kashivskyy</string> &lt;adrian.kashivskyy at me.com&gt;<p>December  3, 2015 at 11:00:00pm</p></header><div class="content"><p>How is this different from guard or precondition()?<br></p><p>func f(x: Int) {<br>    guard (0...1).contains(x) else {<br>        return<br>    }<br>    // use x<br>}<br></p><p>func f(x: Int) {<br>    precondition((0...1).contains(x))<br>    // use x<br>}<br></p><p>Pozdrawiam ? Regards,<br>Adrian Kashivskyy<br></p><p>&gt; Wiadomo?? napisana przez Sean Heber &lt;sean at fifthace.com&gt; w dniu 03.12.2015, o godz. 23:12:<br>&gt; <br>&gt; It may be nice to have a keyword that tells the compiler to try to statically prove certain conditions are true after some point without needing to leave the scope or wrap it in an if-let or something else that happens at runtime. This way the compiler could check the validity of the assertion and it would do so at compile time.<br>&gt; <br>&gt; For example, imagine using something like this to unwrap an optional beyond a certain point in the function body:<br>&gt; <br>&gt; func doSomething() -&gt; Int {<br>&gt;  var something: Int? = nil<br>&gt; <br>&gt;  if something == nil {<br>&gt;     something = 42<br>&gt;  }<br>&gt; <br>&gt;  require something: Int<br>&gt; <br>&gt;  return something * 2<br>&gt; }<br>&gt; <br>&gt; The compiler would be expected to prove that at the ?require? line, ?something? could be an ?Int? (non-optional). If the compiler cannot prove that, it is an error. If it can prove it, the type of the variable is effectively changed from that point on (the compiler effectively changes all instances of ?something? to ?something!? - but it knows it should never fail which might mean it could avoid doing certain checks and it eliminates a piece of state from the mind of the programmer).<br>&gt; <br>&gt; This idea could be extended in other ways, potentially, if you could specify rules in a flexible enough way. For example, imagine being able to declare a constraint on the ranges of basic value types:<br>&gt; <br>&gt; require x in 0?1<br>&gt; let result = someValue * x<br>&gt; <br>&gt; Ideally, the compiler would then attempt to prove that x must always be in the range of 0?1 at this point. If it cannot prove this to be true, then it would be a compiler error.<br>&gt; <br>&gt; Going farther, you could use the same thing on type declarations themselves so you could have a Float that could only contain 0?1:<br>&gt; <br>&gt; var scaler: Float in 0?1<br>&gt; <br>&gt; Or build a function that has constrained input ranges:<br>&gt; <br>&gt; func scale(x: Float in 0?1) -&gt; Float {<br>&gt;  return someValue * x<br>&gt; }<br>&gt; <br>&gt; I like the idea of this always being a compile-time check when possible, but it could also be useful to force the requirement to be evaluated at runtime by adding a force operator to it:<br>&gt; <br>&gt; func scale(x: Float in! 0?1) -&gt; Float {<br>&gt;  return someValue * x<br>&gt; }<br>&gt; <br>&gt; In this scenario the compiler would probably still try to prove it statically - and if it could, it?d skip runtime checks - but if it cannot, it would then insert runtime guards that catch requirement failures and crash as necessary - similar to a forced unwrap - instead of being a compile time error.<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/1c84a551/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Idea for declaring expected types and value ranges</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  3, 2015 at 02:00:00pm</p></header><div class="content"><p>Part of this suggestion seems to be achievable using `guard`. Some,<br>however, isn&#39;t.<br></p><p>Folks may be interested in reading about Refinement Types:<br>https://en.wikipedia.org/wiki/Refinement_(computing)#Refinement_types<br></p><p>On Thu, Dec 3, 2015 at 2:29 PM, Adrian Kashivskyy &lt;adrian.kashivskyy at me.com&gt;<br>wrote:<br></p><p>&gt; How is this different from guard or precondition()?<br>&gt;<br>&gt; func f(x: Int) {<br>&gt;     guard (0...1).contains(x) else {<br>&gt;         return<br>&gt;     }<br>&gt;     // use x<br>&gt; }<br>&gt;<br>&gt; func f(x: Int) {<br>&gt;     precondition((0...1).contains(x))<br>&gt;     // use x<br>&gt; }<br>&gt;<br>&gt; Pozdrawiam ? Regards,<br>&gt; Adrian Kashivskyy<br>&gt;<br>&gt; Wiadomo?? napisana przez Sean Heber &lt;sean at fifthace.com&gt; w dniu<br>&gt; 03.12.2015, o godz. 23:12:<br>&gt;<br>&gt; It may be nice to have a keyword that tells the compiler to try to<br>&gt; statically prove certain conditions are true after some point without<br>&gt; needing to leave the scope or wrap it in an if-let or something else that<br>&gt; happens at runtime. This way the compiler could check the validity of the<br>&gt; assertion and it would do so at compile time.<br>&gt;<br>&gt; For example, imagine using something like this to unwrap an optional<br>&gt; beyond a certain point in the function body:<br>&gt;<br>&gt; func doSomething() -&gt; Int {<br>&gt;  var something: Int? = nil<br>&gt;<br>&gt;  if something == nil {<br>&gt;     something = 42<br>&gt;  }<br>&gt;<br>&gt;  require something: Int<br>&gt;<br>&gt;  return something * 2<br>&gt; }<br>&gt;<br>&gt; The compiler would be expected to prove that at the ?require? line,<br>&gt; ?something? could be an ?Int? (non-optional). If the compiler cannot prove<br>&gt; that, it is an error. If it can prove it, the type of the variable is<br>&gt; effectively changed from that point on (the compiler effectively changes<br>&gt; all instances of ?something? to ?something!? - but it knows it should never<br>&gt; fail which might mean it could avoid doing certain checks and it eliminates<br>&gt; a piece of state from the mind of the programmer).<br>&gt;<br>&gt; This idea could be extended in other ways, potentially, if you could<br>&gt; specify rules in a flexible enough way. For example, imagine being able to<br>&gt; declare a constraint on the ranges of basic value types:<br>&gt;<br>&gt; require x in 0?1<br>&gt; let result = someValue * x<br>&gt;<br>&gt; Ideally, the compiler would then attempt to prove that x must always be in<br>&gt; the range of 0?1 at this point. If it cannot prove this to be true, then it<br>&gt; would be a compiler error.<br>&gt;<br>&gt; Going farther, you could use the same thing on type declarations<br>&gt; themselves so you could have a Float that could only contain 0?1:<br>&gt;<br>&gt; var scaler: Float in 0?1<br>&gt;<br>&gt; Or build a function that has constrained input ranges:<br>&gt;<br>&gt; func scale(x: Float in 0?1) -&gt; Float {<br>&gt;  return someValue * x<br>&gt; }<br>&gt;<br>&gt; I like the idea of this always being a compile-time check when possible,<br>&gt; but it could also be useful to force the requirement to be evaluated at<br>&gt; runtime by adding a force operator to it:<br>&gt;<br>&gt; func scale(x: Float in! 0?1) -&gt; Float {<br>&gt;  return someValue * x<br>&gt; }<br>&gt;<br>&gt; In this scenario the compiler would probably still try to prove it<br>&gt; statically - and if it could, it?d skip runtime checks - but if it cannot,<br>&gt; it would then insert runtime guards that catch requirement failures and<br>&gt; crash as necessary - similar to a forced unwrap - instead of being a<br>&gt; compile time error.<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/23d6d33c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Idea for declaring expected types and value ranges</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>December  3, 2015 at 04:00:00pm</p></header><div class="content"><p>The primary difference would be that I?m suggesting the checks would be occurring at compile-time rather than run-time (unless it was forced to be runtime with !). The idea of applying range (or perhaps other kinds of rules) on values is something that, I think, would be quite useful in many applications and is, perhaps, a different concept.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Dec 3, 2015, at 4:29 PM, Adrian Kashivskyy &lt;adrian.kashivskyy at me.com&gt; wrote:<br>&gt; <br>&gt; How is this different from guard or precondition()?<br>&gt; <br>&gt; func f(x: Int) {<br>&gt;     guard (0...1).contains(x) else {<br>&gt;         return<br>&gt;     }<br>&gt;     // use x<br>&gt; }<br>&gt; <br>&gt; func f(x: Int) {<br>&gt;     precondition((0...1).contains(x))<br>&gt;     // use x<br>&gt; }<br>&gt; <br>&gt; Pozdrawiam ? Regards,<br>&gt; Adrian Kashivskyy<br>&gt; <br>&gt;&gt; Wiadomo?? napisana przez Sean Heber &lt;sean at fifthace.com&gt; w dniu 03.12.2015, o godz. 23:12:<br>&gt;&gt; <br>&gt;&gt; It may be nice to have a keyword that tells the compiler to try to statically prove certain conditions are true after some point without needing to leave the scope or wrap it in an if-let or something else that happens at runtime. This way the compiler could check the validity of the assertion and it would do so at compile time.<br>&gt;&gt; <br>&gt;&gt; For example, imagine using something like this to unwrap an optional beyond a certain point in the function body:<br>&gt;&gt; <br>&gt;&gt; func doSomething() -&gt; Int {<br>&gt;&gt;  var something: Int? = nil<br>&gt;&gt; <br>&gt;&gt;  if something == nil {<br>&gt;&gt;     something = 42<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  require something: Int<br>&gt;&gt; <br>&gt;&gt;  return something * 2<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The compiler would be expected to prove that at the ?require? line, ?something? could be an ?Int? (non-optional). If the compiler cannot prove that, it is an error. If it can prove it, the type of the variable is effectively changed from that point on (the compiler effectively changes all instances of ?something? to ?something!? - but it knows it should never fail which might mean it could avoid doing certain checks and it eliminates a piece of state from the mind of the programmer).<br>&gt;&gt; <br>&gt;&gt; This idea could be extended in other ways, potentially, if you could specify rules in a flexible enough way. For example, imagine being able to declare a constraint on the ranges of basic value types:<br>&gt;&gt; <br>&gt;&gt; require x in 0?1<br>&gt;&gt; let result = someValue * x<br>&gt;&gt; <br>&gt;&gt; Ideally, the compiler would then attempt to prove that x must always be in the range of 0?1 at this point. If it cannot prove this to be true, then it would be a compiler error.<br>&gt;&gt; <br>&gt;&gt; Going farther, you could use the same thing on type declarations themselves so you could have a Float that could only contain 0?1:<br>&gt;&gt; <br>&gt;&gt; var scaler: Float in 0?1<br>&gt;&gt; <br>&gt;&gt; Or build a function that has constrained input ranges:<br>&gt;&gt; <br>&gt;&gt; func scale(x: Float in 0?1) -&gt; Float {<br>&gt;&gt;  return someValue * x<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I like the idea of this always being a compile-time check when possible, but it could also be useful to force the requirement to be evaluated at runtime by adding a force operator to it:<br>&gt;&gt; <br>&gt;&gt; func scale(x: Float in! 0?1) -&gt; Float {<br>&gt;&gt;  return someValue * x<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In this scenario the compiler would probably still try to prove it statically - and if it could, it?d skip runtime checks - but if it cannot, it would then insert runtime guards that catch requirement failures and crash as necessary - similar to a forced unwrap - instead of being a compile time error.<br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
