<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Pitch] Require Any for existentials</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>August 23, 2016 at 11:00:00pm</p></header><div class="content"><p>I haven&#39;t yet prepared a formal proposal, but the idea should be understood<br>by pretty much everyone. This topic has been discussed, but deferred to<br>&quot;post-Swift3&quot;. I think the time for it has come.<br></p><p>Basically, the proposal is to make protocols non-types. To use protocol as<br>an existential type, it must be wrapped in Any:<br></p><p>protocol ExampleProtocol {<br>    func foo() -&gt; Int<br>    func bar() -&gt; String<br>}<br></p><p>func f&lt;T: ExampleProtocol&gt;()    // OK<br></p><p>func f(x: ExampleProtocol)    // error: ExampleProtocol is not a type<br>func f(x: Any&lt;ExampleProtocol&gt;)    // OK<br></p><p>This will syntactically separate existential types from protocols<br>themselves and generic constraints.<br>The proposal does not allow for much variativity, and it looks like the<br>proposal can be easily created and submitted.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/2ec792e2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] Require Any for existentials</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>August 23, 2016 at 02:00:00pm</p></header><div class="content"><p>On Aug 23, 2016, at 1:49 PM, Anton Zhilin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I haven&#39;t yet prepared a formal proposal, but the idea should be understood by pretty much everyone. This topic has been discussed, but deferred to &quot;post-Swift3&quot;. I think the time for it has come.<br></p><p>Hi Anton,<br></p><p>This is a source breaking change, and we don’t have a framework established for how to handle those in the post-swift 3 world yet.  The core team is focusing on finishing up Swift 3 right now, but I expect that one of the first topics will be to define and iterate on the model for handling source changes.<br></p><p>Only once that is established can we determine whether a proposal like this is possible and know what the tradeoffs are that it entails.<br></p><p>-Chris<br></p><p><br>&gt; <br>&gt; Basically, the proposal is to make protocols non-types. To use protocol as an existential type, it must be wrapped in Any:<br>&gt; <br>&gt; protocol ExampleProtocol {<br>&gt;     func foo() -&gt; Int<br>&gt;     func bar() -&gt; String<br>&gt; }<br>&gt; <br>&gt; func f&lt;T: ExampleProtocol&gt;()    // OK<br>&gt; <br>&gt; func f(x: ExampleProtocol)    // error: ExampleProtocol is not a type<br>&gt; func f(x: Any&lt;ExampleProtocol&gt;)    // OK<br>&gt; <br>&gt; This will syntactically separate existential types from protocols themselves and generic constraints.<br>&gt; The proposal does not allow for much variativity, and it looks like the proposal can be easily created and submitted.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Require Any for existentials</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>August 24, 2016 at 12:00:00am</p></header><div class="content"><p>The basic design is fine, but I wouldn&#39;t want to add more noise to my code. We could keep (label: Protocol) as a shorthand form for (label: Any&lt;Protocol&gt;) similar to Optionals.  <br></p><p>What&#39;s the benifite of this anywasys? What exactly will this solve?!  <br></p><p>--  <br>Adrian Zubarev<br>Sent with Airmail  <br></p><p>Am 23. August 2016 um 23:18:35, Chris Lattner via swift-evolution (swift-evolution at swift.org(mailto:swift-evolution at swift.org)) schrieb:<br></p><p>&gt;  <br>&gt; On Aug 23, 2016, at 1:49 PM, Anton Zhilin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; I haven&#39;t yet prepared a formal proposal, but the idea should be understood by pretty much everyone. This topic has been discussed, but deferred to &quot;post-Swift3&quot;. I think the time for it has come.<br>&gt;  <br>&gt; Hi Anton,<br>&gt;  <br>&gt; This is a source breaking change, and we don’t have a framework established for how to handle those in the post-swift 3 world yet. The core team is focusing on finishing up Swift 3 right now, but I expect that one of the first topics will be to define and iterate on the model for handling source changes.<br>&gt;  <br>&gt; Only once that is established can we determine whether a proposal like this is possible and know what the tradeoffs are that it entails.<br>&gt;  <br>&gt; -Chris<br>&gt;  <br>&gt;  <br>&gt; &gt;  <br>&gt; &gt; Basically, the proposal is to make protocols non-types. To use protocol as an existential type, it must be wrapped in Any:<br>&gt; &gt;  <br>&gt; &gt; protocol ExampleProtocol {<br>&gt; &gt; func foo() -&gt; Int<br>&gt; &gt; func bar() -&gt; String<br>&gt; &gt; }<br>&gt; &gt;  <br>&gt; &gt; func f&lt;T: ExampleProtocol&gt;() // OK<br>&gt; &gt;  <br>&gt; &gt; func f(x: ExampleProtocol) // error: ExampleProtocol is not a type<br>&gt; &gt; func f(x: Any&lt;ExampleProtocol&gt;) // OK<br>&gt; &gt;  <br>&gt; &gt; This will syntactically separate existential types from protocols themselves and generic constraints.<br>&gt; &gt; The proposal does not allow for much variativity, and it looks like the proposal can be easily created and submitted.<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/20efec7a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pitch] Require Any for existentials</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>August 24, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 23 Aug 2016, at 23:14, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The basic design is fine, but I wouldn&#39;t want to add more noise to my code. We could keep (label: Protocol) as a shorthand form for (label: Any&lt;Protocol&gt;) similar to Optionals.<br>&gt; <br>&gt; What&#39;s the benifite of this anywasys? What exactly will this solve?!<br></p><p>Currently we can only use a protocol as if it were a type when it has no associated types, existentials will eliminate that restriction, allowing us to use a protocol Foo where we would currently either have to use AnyFoo or a very verbose generic constraint. I think the point of this proposal is to ask whether we should be able to use protocols as if they were concrete types, or whether it would be better to require Any&lt;&gt; to clarify what&#39;s really happening.<br></p><p>Personally I&#39;m on the fence; I don&#39;t particularly mind being able to use a protocol name as if it were a concrete type, but I do generally prefer for things to be explicit wherever confusion may be caused. I think that requiring Any&lt;&gt; could be a good thing, as it clarifies that what you&#39;re interacting with is not a concrete type, and highlights that it may optimise differently (I&#39;m not 100% on the details of how existentials actually work).<br></p><p>So I&#39;d say I&#39;m a tentative +0.5; in terms of migration I don&#39;t think this is all that source breaking, as it&#39;s very easy to add a fixit for (possibly even an automatic one?) and it only currently applies to non-generic protocols anyway, which seems relatively niche.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Pitch] Require Any for existentials</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>August 24, 2016 at 05:00:00pm</p></header><div class="content"><p>On 24.08.2016 13:23, Haravikk via swift-evolution wrote:<br>&gt;<br>&gt;&gt; On 23 Aug 2016, at 23:14, Adrian Zubarev via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; The basic design is fine, but I wouldn&#39;t want to add more noise to my<br>&gt;&gt; code. We could keep (label: Protocol) as a shorthand form for (label:<br>&gt;&gt; Any&lt;Protocol&gt;) similar to Optionals.<br>&gt;&gt;<br>&gt;&gt; What&#39;s the benifite of this anywasys? What exactly will this solve?!<br>&gt;<br>&gt; Currently we can only use a protocol as if it were a type when it has no<br>&gt; associated types, existentials will eliminate that restriction, allowing<br>&gt; us to use a protocol Foo where we would currently either have to use<br>&gt; AnyFoo or a very verbose generic constraint. I think the point of this<br>&gt; proposal is to ask whether we should be able to use protocols as if they<br>&gt; were concrete types, or whether it would be better to require Any&lt;&gt; to<br>&gt; clarify what&#39;s really happening.<br></p><p>I believe Any&lt;&gt; could remove some inconsistency/confusion when protocol is <br>used as generic constraint in &#39;where&#39; clause. Let&#39;s see:<br></p><p>we can have such function:<br>func process&lt;T: Sequence&gt;(_ seq: T) where T.Iterator.Element == MyElement<br>and we can have such :<br>func process&lt;T: Sequence&gt;(_ seq: T) where T.Iterator.Element : MyElement<br></p><p>the first will accept array only if typed as [MyElement] i.e.<br>let arr : [MyElement] = ...<br>, it is logical as constraint defined with &#39;==&#39; i.e. type is strictly equal.<br></p><p>but the second form will not allow you to use instance typed as [MyElement] <br>or as any derived protocol like [ProtocolDerivedFromMyElement] - although <br>one can expect this in analogue with class/value type in constraint - but <br>will accept array *typed* as class/struct conformed to MyElement protocol, <br>i.e.<br>struct S: MyElement {..}<br>let arr : [S] = ...<br></p><p>In case we&#39;ll have Any&lt;&gt;, the second definition as I understand should <br>looks like:<br></p><p>func process&lt;T: Sequence&gt;(_ seq: T) where T.Iterator.Element : Any&lt;MyElement&gt;<br></p><p>i.e. in this case it clearly show that it will accept array(sequence) typed <br>as some concrete type conformed to protocol.<br></p><p>&gt;<br>&gt; Personally I&#39;m on the fence; I don&#39;t particularly mind being able to use<br>&gt; a protocol name as if it were a concrete type, but I do generally prefer<br>&gt; for things to be explicit wherever confusion may be caused. I think that<br>&gt; requiring Any&lt;&gt; could be a good thing, as it clarifies that what you&#39;re<br>&gt; interacting with is not a concrete type, and highlights that it may<br>&gt; optimise differently (I&#39;m not 100% on the details of how existentials<br>&gt; actually work).<br>&gt;<br>&gt; So I&#39;d say I&#39;m a tentative +0.5; in terms of migration I don&#39;t think<br>&gt; this is all that source breaking, as it&#39;s very easy to add a fixit for<br>&gt; (possibly even an automatic one?) and it only currently applies to<br>&gt; non-generic protocols anyway, which seems relatively niche.<br>&gt; _______________________________________________ swift-evolution mailing<br>&gt; list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Pitch] Require Any for existentials</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>August 25, 2016 at 07:00:00pm</p></header><div class="content"><p>Syntax for `T == P || T: P` is off-topic for current proposal, which is<br>just about replacing `P` with `Any&lt;P&gt;`.<br></p><p>Currently, equivalent of `Any&lt;P&gt;` has no subtypes (besides itself). This is<br>likely not going to be changed. So `where U : Any&lt;P&gt;` will not be allowed.<br></p><p>Generalized existentials also don&#39;t solve this problem. Existential<br>`Sequence` would look like this:<br></p><p>`Any&lt;Sequence where Iterator.Element : P&gt;`<br></p><p>Here, we can&#39;t accept `Iterator.Element == Any&lt;P&gt;` for the same reason that<br>we can&#39;t accept `Any&lt;P&gt; : P` in any other place: static member requirements<br>are not implemented.<br></p><p>To solve this problem, we should invent another generic requirement, say<br>`:==`, that prohibits calling static members on generic parameter. This<br>should be a separate proposal. `Any&lt;P&gt;` can&#39;t help here, because the<br>problem with calling static members only happens with static polymorphism.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160825/918313aa/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Require Any for existentials</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>August 24, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On 24 Aug 2016, at 00:14, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The basic design is fine, but I wouldn&#39;t want to add more noise to my code. We could keep (label: Protocol) as a shorthand form for (label: Any&lt;Protocol&gt;) similar to Optionals.<br>&gt; <br>&gt; What&#39;s the benifite of this anywasys? What exactly will this solve?! <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br></p><p>The problem, as I understand it, is that when you use “MyProtocol” as a type, there is sometimes a confusion as to whether you mean:<br>- the protocol itself, or<br>- anything which “is” that protocol (similar to how I might write “MyClass” when meaning anything which “is” a MyClass, including MyDerviedClass), i.e. an existential<br></p><p>See the discussion about protocol self-conformance. Any&lt;MyProtocol&gt; would make it clear that you mean the latter.<br></p><p>I quite like using protocol names to refer to existentials. I’d like to consider the other options for disambiguating the protocol type before giving a +/- 1. This would fit nicely with another commonly-requested feature though: the ability to constrain concrete types by protocol conformance - e.g. UIView&lt;MyProtocol&gt;.<br></p><p>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/985e9590/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
