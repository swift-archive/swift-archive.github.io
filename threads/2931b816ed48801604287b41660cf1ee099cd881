<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>Coroutine for Swift</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>December 22, 2015 at 02:00:00pm</p></header><div class="content"><p>here is my proposal for swift lang<br></p><p>https://github.com/SusanDoggie/swift-evolution/blob/master/proposals/0018-coroutine-for-swift.md<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/2931d881/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Coroutine for Swift</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 22, 2015 at 02:00:00am</p></header><div class="content"><p>There&#39;s probably some additional work to do on the proposal document, but I would like to see coroutines in Swift too. The feature has been very successful in other languages like Python and C#, and unless I&#39;m mistaken, work is being done to standardize it in C++.<br></p><p>Generators are one use case, but resumable functions in general can also be used to make async code look prettier.<br></p><p>Félix<br></p><p>&gt; Le 22 déc. 2015 à 01:47:05, Susan Cheng via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; here is my proposal for swift lang<br>&gt; <br>&gt; https://github.com/SusanDoggie/swift-evolution/blob/master/proposals/0018-coroutine-for-swift.md &lt;https://github.com/SusanDoggie/swift-evolution/blob/master/proposals/0018-coroutine-for-swift.md&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/482ca828/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Coroutine for Swift</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December 22, 2015 at 06:00:00pm</p></header><div class="content"><p>Great proposal! I&#39;m all for this, I think your proposed implementation is<br>pretty good too.<br></p><p>It would be interesting to expand the proposal to consider more cases in<br>more detail:<br> * Concurrency<br> * SequenceType versus GeneratorType<br> * Should a language feature depend on the Standard Library<br>(GeneratorType)? Alternatives:<br>     + func myFunction -&gt; () -&gt; T?<br>     + func myFunction -&gt; () -&gt; (myFunction_State, myFunction_State -&gt; T?)<br> * What happens if you write: guard ... else { yield ... }<br> * Use an enum for the state that encapsulates all possible variables in<br>each state<br></p><p>If you&#39;re not familiar with it, there&#39;s another thread that discussed<br>similar here:<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001872.html<br></p><p>In particular you may be interested in Chris Lattner&#39;s comment:<br></p><p>I’m very interested in this, but it is clearly out of scope for Swift 3. It<br>should also be considered alongside whatever async/concurrency approach we<br>tackle (likely in swift 4).<br></p><p><br>Either way it&#39;s worth discussing and working towards :)<br></p><p>On Tue, Dec 22, 2015 at 6:03 PM, Félix Cloutier &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; There&#39;s probably some additional work to do on the proposal document, but<br>&gt; I would like to see coroutines in Swift too. The feature has been very<br>&gt; successful in other languages like Python and C#, and unless I&#39;m mistaken,<br>&gt; work is being done to standardize it in C++.<br>&gt;<br>&gt; Generators are one use case, but resumable functions in general can also<br>&gt; be used to make async code look prettier.<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 22 déc. 2015 à 01:47:05, Susan Cheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; here is my proposal for swift lang<br>&gt;<br>&gt;<br>&gt; https://github.com/SusanDoggie/swift-evolution/blob/master/proposals/0018-coroutine-for-swift.md<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/a0bd9039/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d5c03d71ebd1813a9c856bff896009b7?s=50"></div><header><strong>Coroutine for Swift</strong> from <string>Daniel Valls Estella</string> &lt;daniel at upzzle.com&gt;<p>December 22, 2015 at 11:00:00am</p></header><div class="content"><p>I think it’s better to take as a reference the Go language and his goroutines and channels.<br></p><p>Not just to face these type of problems but also to take new architectural aproches to build software solutions.<br></p><p><br>refs:<br> <br>https://tour.golang.org/concurrency/1<br>https://tour.golang.org/concurrency/2<br>https://tour.golang.org/concurrency/5<br>https://youtu.be/f6kdp27TYZs<br></p><p><br>What you think?<br></p><p>Daniel<br></p><p>Daniel Valls Estella · tel. 659.910.830 · daniel at upzzle.com<br></p><p>&gt; El 22 des 2015, a les 8:33, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; va escriure:<br>&gt; <br>&gt; Great proposal! I&#39;m all for this, I think your proposed implementation is pretty good too.<br>&gt; <br>&gt; It would be interesting to expand the proposal to consider more cases in more detail:<br>&gt;  * Concurrency<br>&gt;  * SequenceType versus GeneratorType<br>&gt;  * Should a language feature depend on the Standard Library (GeneratorType)? Alternatives:<br>&gt;      + func myFunction -&gt; () -&gt; T?<br>&gt;      + func myFunction -&gt; () -&gt; (myFunction_State, myFunction_State -&gt; T?)<br>&gt;  * What happens if you write: guard ... else { yield ... }<br>&gt;  * Use an enum for the state that encapsulates all possible variables in each state<br>&gt; <br>&gt; If you&#39;re not familiar with it, there&#39;s another thread that discussed similar here:<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001872.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001872.html&gt;<br>&gt; <br>&gt; In particular you may be interested in Chris Lattner&#39;s comment:<br>&gt; I’m very interested in this, but it is clearly out of scope for Swift 3. It should also be considered alongside whatever async/concurrency approach we tackle (likely in swift 4).<br>&gt; <br>&gt; Either way it&#39;s worth discussing and working towards :)<br>&gt; <br>&gt; On Tue, Dec 22, 2015 at 6:03 PM, Félix Cloutier &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; There&#39;s probably some additional work to do on the proposal document, but I would like to see coroutines in Swift too. The feature has been very successful in other languages like Python and C#, and unless I&#39;m mistaken, work is being done to standardize it in C++.<br>&gt; <br>&gt; Generators are one use case, but resumable functions in general can also be used to make async code look prettier.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 22 déc. 2015 à 01:47:05, Susan Cheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; here is my proposal for swift lang<br>&gt;&gt; <br>&gt;&gt; https://github.com/SusanDoggie/swift-evolution/blob/master/proposals/0018-coroutine-for-swift.md &lt;https://github.com/SusanDoggie/swift-evolution/blob/master/proposals/0018-coroutine-for-swift.md&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/172dcf97/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>Coroutine for Swift</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>December 22, 2015 at 06:00:00pm</p></header><div class="content"><p>It&#39;s a little difference with goroutine. Go using threads and signal.<br>My implementation is following C# methods that MS staff tells me.<br></p><p>Daniel Valls Estella &lt;daniel at upzzle.com&gt; 於 2015年12月22日星期二 寫道：<br></p><p>&gt; I think it’s better to take as a reference the *Go* language and his<br>&gt; *goroutines* and *channels*.<br>&gt;<br>&gt; Not just to face these type of problems but also to take new architectural<br>&gt; aproches to build software solutions.<br>&gt;<br>&gt;<br>&gt; refs:<br>&gt;<br>&gt; https://tour.golang.org/concurrency/1<br>&gt; https://tour.golang.org/concurrency/2<br>&gt; https://tour.golang.org/concurrency/5<br>&gt; https://youtu.be/f6kdp27TYZs<br>&gt;<br>&gt;<br>&gt; What you think?<br>&gt;<br>&gt; Daniel<br>&gt;<br>&gt; Daniel Valls Estella · tel. 659.910.830 · daniel at upzzle.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;daniel at upzzle.com&#39;);&gt;<br>&gt;<br>&gt; El 22 des 2015, a les 8:33, Andrew Bennett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; va escriure:<br>&gt;<br>&gt; Great proposal! I&#39;m all for this, I think your proposed implementation is<br>&gt; pretty good too.<br>&gt;<br>&gt; It would be interesting to expand the proposal to consider more cases in<br>&gt; more detail:<br>&gt;  * Concurrency<br>&gt;  * SequenceType versus GeneratorType<br>&gt;  * Should a language feature depend on the Standard Library<br>&gt; (GeneratorType)? Alternatives:<br>&gt;      + func myFunction -&gt; () -&gt; T?<br>&gt;      + func myFunction -&gt; () -&gt; (myFunction_State, myFunction_State -&gt; T?)<br>&gt;  * What happens if you write: guard ... else { yield ... }<br>&gt;  * Use an enum for the state that encapsulates all possible variables in<br>&gt; each state<br>&gt;<br>&gt; If you&#39;re not familiar with it, there&#39;s another thread that discussed<br>&gt; similar here:<br>&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001872.html<br>&gt;<br>&gt; In particular you may be interested in Chris Lattner&#39;s comment:<br>&gt;<br>&gt; I’m very interested in this, but it is clearly out of scope for Swift 3.<br>&gt; It should also be considered alongside whatever async/concurrency approach<br>&gt; we tackle (likely in swift 4).<br>&gt;<br>&gt;<br>&gt; Either way it&#39;s worth discussing and working towards :)<br>&gt;<br>&gt; On Tue, Dec 22, 2015 at 6:03 PM, Félix Cloutier &lt;swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; There&#39;s probably some additional work to do on the proposal document, but<br>&gt;&gt; I would like to see coroutines in Swift too. The feature has been very<br>&gt;&gt; successful in other languages like Python and C#, and unless I&#39;m mistaken,<br>&gt;&gt; work is being done to standardize it in C++.<br>&gt;&gt;<br>&gt;&gt; Generators are one use case, but resumable functions in general can also<br>&gt;&gt; be used to make async code look prettier.<br>&gt;&gt;<br>&gt;&gt; Félix<br>&gt;&gt;<br>&gt;&gt; Le 22 déc. 2015 à 01:47:05, Susan Cheng via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; here is my proposal for swift lang<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/SusanDoggie/swift-evolution/blob/master/proposals/0018-coroutine-for-swift.md<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/d4282691/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d5c03d71ebd1813a9c856bff896009b7?s=50"></div><header><strong>Coroutine for Swift</strong> from <string>Daniel Valls Estella</string> &lt;daniel at upzzle.com&gt;<p>December 22, 2015 at 03:00:00pm</p></header><div class="content"><p>Ok,<br></p><p>But I think goroutines are not really threads (are faster and cheaper enought to make a diference) and channels are more like filedescriptors than signals, you stream data throught these.<br></p><p>Thanks for your answer!<br></p><p>Daniel<br></p><p>Daniel Valls Estella · tel. 659.910.830 · daniel at upzzle.com<br></p><p>&gt; El 22 des 2015, a les 11:50, Susan Cheng &lt;susan.doggie at gmail.com&gt; va escriure:<br>&gt; <br>&gt; It&#39;s a little difference with goroutine. Go using threads and signal.<br>&gt; My implementation is following C# methods that MS staff tells me.<br>&gt; <br>&gt; Daniel Valls Estella &lt;daniel at upzzle.com &lt;mailto:daniel at upzzle.com&gt;&gt; 於 2015年12月22日星期二 寫道：<br>&gt; I think it’s better to take as a reference the Go language and his goroutines and channels.<br>&gt; <br>&gt; Not just to face these type of problems but also to take new architectural aproches to build software solutions.<br>&gt; <br>&gt; <br>&gt; refs:<br>&gt;  <br>&gt; https://tour.golang.org/concurrency/1 &lt;https://tour.golang.org/concurrency/1&gt;<br>&gt; https://tour.golang.org/concurrency/2 &lt;https://tour.golang.org/concurrency/2&gt;<br>&gt; https://tour.golang.org/concurrency/5 &lt;https://tour.golang.org/concurrency/5&gt;<br>&gt; https://youtu.be/f6kdp27TYZs &lt;https://youtu.be/f6kdp27TYZs&gt;<br>&gt; <br>&gt; <br>&gt; What you think?<br>&gt; <br>&gt; Daniel<br>&gt; <br>&gt; Daniel Valls Estella · tel. 659.910.830 · daniel at upzzle.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;daniel at upzzle.com&#39;);&gt;<br>&gt;&gt; El 22 des 2015, a les 8:33, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; va escriure:<br>&gt;&gt; <br>&gt;&gt; Great proposal! I&#39;m all for this, I think your proposed implementation is pretty good too.<br>&gt;&gt; <br>&gt;&gt; It would be interesting to expand the proposal to consider more cases in more detail:<br>&gt;&gt;  * Concurrency<br>&gt;&gt;  * SequenceType versus GeneratorType<br>&gt;&gt;  * Should a language feature depend on the Standard Library (GeneratorType)? Alternatives:<br>&gt;&gt;      + func myFunction -&gt; () -&gt; T?<br>&gt;&gt;      + func myFunction -&gt; () -&gt; (myFunction_State, myFunction_State -&gt; T?)<br>&gt;&gt;  * What happens if you write: guard ... else { yield ... }<br>&gt;&gt;  * Use an enum for the state that encapsulates all possible variables in each state<br>&gt;&gt; <br>&gt;&gt; If you&#39;re not familiar with it, there&#39;s another thread that discussed similar here:<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001872.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001872.html&gt;<br>&gt;&gt; <br>&gt;&gt; In particular you may be interested in Chris Lattner&#39;s comment:<br>&gt;&gt; I’m very interested in this, but it is clearly out of scope for Swift 3. It should also be considered alongside whatever async/concurrency approach we tackle (likely in swift 4).<br>&gt;&gt; <br>&gt;&gt; Either way it&#39;s worth discussing and working towards :)<br>&gt;&gt; <br>&gt;&gt; On Tue, Dec 22, 2015 at 6:03 PM, Félix Cloutier &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt; There&#39;s probably some additional work to do on the proposal document, but I would like to see coroutines in Swift too. The feature has been very successful in other languages like Python and C#, and unless I&#39;m mistaken, work is being done to standardize it in C++.<br>&gt;&gt; <br>&gt;&gt; Generators are one use case, but resumable functions in general can also be used to make async code look prettier.<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 22 déc. 2015 à 01:47:05, Susan Cheng via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; here is my proposal for swift lang<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/SusanDoggie/swift-evolution/blob/master/proposals/0018-coroutine-for-swift.md &lt;https://github.com/SusanDoggie/swift-evolution/blob/master/proposals/0018-coroutine-for-swift.md&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/ade7ce24/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Coroutine for Swift</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December 23, 2015 at 07:00:00am</p></header><div class="content"><p>Hi Daniel,<br></p><p>I&#39;ve heard many great things about goroutines, and I definitively think<br>their advantages should be considered in the design of Swift&#39;s concurrency.<br></p><p>I haven&#39;t used goroutines much so I may be incorrect, but I don&#39;t think<br>they can be used to efficiently represent a generator like the proposal<br>suggests.<br></p><p>The generator described in the proposal has the following properties:<br> * it is basically just syntactic sugar<br> * new elements are generated lazily<br> * the length doesn&#39;t need to be known at initialisation<br> * it uses existing function syntax in the caller<br> * it can all run on one thread<br> * concurrency considerations may be limited to safely updating the state<br>variable from more than one thread<br></p><p>Maybe goroutines can be equivalent if the compiler can optimise it down to<br>a generator. This proposal is basically syntactic sugar to concisely define<br>a generator. Goroutines probably aren&#39;t a concise replacement for that<br>sugar.<br></p><p><br>On Wednesday, 23 December 2015, Daniel Valls Estella &lt;daniel at upzzle.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; Ok,<br>&gt;<br>&gt; But I think goroutines are not really threads (are faster and cheaper<br>&gt; enought to make a diference) and channels are more like filedescriptors<br>&gt; than signals, you stream data throught these.<br>&gt;<br>&gt; Thanks for your answer!<br>&gt;<br>&gt; Daniel<br>&gt;<br>&gt; Daniel Valls Estella · tel. 659.910.830 · daniel at upzzle.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;daniel at upzzle.com&#39;);&gt;<br>&gt;<br>&gt; El 22 des 2015, a les 11:50, Susan Cheng &lt;susan.doggie at gmail.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;susan.doggie at gmail.com&#39;);&gt;&gt; va escriure:<br>&gt;<br>&gt; It&#39;s a little difference with goroutine. Go using threads and signal.<br>&gt; My implementation is following C# methods that MS staff tells me.<br>&gt;<br>&gt; Daniel Valls Estella &lt;daniel at upzzle.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;daniel at upzzle.com&#39;);&gt;&gt; 於 2015年12月22日星期二 寫道：<br>&gt;<br>&gt;&gt; I think it’s better to take as a reference the *Go* language and his<br>&gt;&gt; *goroutines* and *channels*.<br>&gt;&gt;<br>&gt;&gt; Not just to face these type of problems but also to take new<br>&gt;&gt; architectural aproches to build software solutions.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; refs:<br>&gt;&gt;<br>&gt;&gt; https://tour.golang.org/concurrency/1<br>&gt;&gt; https://tour.golang.org/concurrency/2<br>&gt;&gt; https://tour.golang.org/concurrency/5<br>&gt;&gt; https://youtu.be/f6kdp27TYZs<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; What you think?<br>&gt;&gt;<br>&gt;&gt; Daniel<br>&gt;&gt;<br>&gt;&gt; Daniel Valls Estella · tel. 659.910.830 · daniel at upzzle.com<br>&gt;&gt;<br>&gt;&gt; El 22 des 2015, a les 8:33, Andrew Bennett via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; va escriure:<br>&gt;&gt;<br>&gt;&gt; Great proposal! I&#39;m all for this, I think your proposed implementation is<br>&gt;&gt; pretty good too.<br>&gt;&gt;<br>&gt;&gt; It would be interesting to expand the proposal to consider more cases in<br>&gt;&gt; more detail:<br>&gt;&gt;  * Concurrency<br>&gt;&gt;  * SequenceType versus GeneratorType<br>&gt;&gt;  * Should a language feature depend on the Standard Library<br>&gt;&gt; (GeneratorType)? Alternatives:<br>&gt;&gt;      + func myFunction -&gt; () -&gt; T?<br>&gt;&gt;      + func myFunction -&gt; () -&gt; (myFunction_State, myFunction_State -&gt; T?)<br>&gt;&gt;  * What happens if you write: guard ... else { yield ... }<br>&gt;&gt;  * Use an enum for the state that encapsulates all possible variables in<br>&gt;&gt; each state<br>&gt;&gt;<br>&gt;&gt; If you&#39;re not familiar with it, there&#39;s another thread that discussed<br>&gt;&gt; similar here:<br>&gt;&gt;<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001872.html<br>&gt;&gt;<br>&gt;&gt; In particular you may be interested in Chris Lattner&#39;s comment:<br>&gt;&gt;<br>&gt;&gt; I’m very interested in this, but it is clearly out of scope for Swift 3.<br>&gt;&gt; It should also be considered alongside whatever async/concurrency approach<br>&gt;&gt; we tackle (likely in swift 4).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Either way it&#39;s worth discussing and working towards :)<br>&gt;&gt;<br>&gt;&gt; On Tue, Dec 22, 2015 at 6:03 PM, Félix Cloutier &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; There&#39;s probably some additional work to do on the proposal document,<br>&gt;&gt;&gt; but I would like to see coroutines in Swift too. The feature has been very<br>&gt;&gt;&gt; successful in other languages like Python and C#, and unless I&#39;m mistaken,<br>&gt;&gt;&gt; work is being done to standardize it in C++.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Generators are one use case, but resumable functions in general can also<br>&gt;&gt;&gt; be used to make async code look prettier.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Le 22 déc. 2015 à 01:47:05, Susan Cheng via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; here is my proposal for swift lang<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://github.com/SusanDoggie/swift-evolution/blob/master/proposals/0018-coroutine-for-swift.md<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/af47a27b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Coroutine for Swift</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 22, 2015 at 02:00:00pm</p></header><div class="content"><p>Hi Susan,<br></p><p>As I mentioned on your original pull request, coroutines are closely related to async and other concurrency forms.  That entire space is out of scope for Swift 3, so we should wait until fall 2016 to pick up discussion on this and related topics.<br></p><p>-Chris<br></p><p>&gt; On Dec 22, 2015, at 12:16 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Daniel,<br>&gt; <br>&gt; I&#39;ve heard many great things about goroutines, and I definitively think their advantages should be considered in the design of Swift&#39;s concurrency.<br>&gt; <br>&gt; I haven&#39;t used goroutines much so I may be incorrect, but I don&#39;t think they can be used to efficiently represent a generator like the proposal suggests.<br>&gt; <br>&gt; The generator described in the proposal has the following properties:<br>&gt;  * it is basically just syntactic sugar<br>&gt;  * new elements are generated lazily<br>&gt;  * the length doesn&#39;t need to be known at initialisation<br>&gt;  * it uses existing function syntax in the caller<br>&gt;  * it can all run on one thread<br>&gt;  * concurrency considerations may be limited to safely updating the state variable from more than one thread<br>&gt; <br>&gt; Maybe goroutines can be equivalent if the compiler can optimise it down to a generator. This proposal is basically syntactic sugar to concisely define a generator. Goroutines probably aren&#39;t a concise replacement for that sugar.<br>&gt; <br>&gt; <br>&gt; On Wednesday, 23 December 2015, Daniel Valls Estella &lt;daniel at upzzle.com &lt;mailto:daniel at upzzle.com&gt;&gt; wrote:<br>&gt; <br>&gt; Ok,<br>&gt; <br>&gt; But I think goroutines are not really threads (are faster and cheaper enought to make a diference) and channels are more like filedescriptors than signals, you stream data throught these.<br>&gt; <br>&gt; Thanks for your answer!<br>&gt; <br>&gt; Daniel<br>&gt; <br>&gt; Daniel Valls Estella · tel. 659.910.830 · daniel at upzzle.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;daniel at upzzle.com&#39;);&gt;<br>&gt;&gt; El 22 des 2015, a les 11:50, Susan Cheng &lt;susan.doggie at gmail.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;susan.doggie at gmail.com&#39;);&gt;&gt; va escriure:<br>&gt;&gt; <br>&gt;&gt; It&#39;s a little difference with goroutine. Go using threads and signal.<br>&gt;&gt; My implementation is following C# methods that MS staff tells me.<br>&gt;&gt; <br>&gt;&gt; Daniel Valls Estella &lt;daniel at upzzle.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;daniel at upzzle.com&#39;);&gt;&gt; 於 2015年12月22日星期二 寫道：<br>&gt;&gt; I think it’s better to take as a reference the Go language and his goroutines and channels.<br>&gt;&gt; <br>&gt;&gt; Not just to face these type of problems but also to take new architectural aproches to build software solutions.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; refs:<br>&gt;&gt;  <br>&gt;&gt; https://tour.golang.org/concurrency/1 &lt;https://tour.golang.org/concurrency/1&gt;<br>&gt;&gt; https://tour.golang.org/concurrency/2 &lt;https://tour.golang.org/concurrency/2&gt;<br>&gt;&gt; https://tour.golang.org/concurrency/5 &lt;https://tour.golang.org/concurrency/5&gt;<br>&gt;&gt; https://youtu.be/f6kdp27TYZs &lt;https://youtu.be/f6kdp27TYZs&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; What you think?<br>&gt;&gt; <br>&gt;&gt; Daniel<br>&gt;&gt; <br>&gt;&gt; Daniel Valls Estella · tel. 659.910.830 · daniel at upzzle.com &lt;&gt;<br>&gt;&gt;&gt; El 22 des 2015, a les 8:33, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; va escriure:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Great proposal! I&#39;m all for this, I think your proposed implementation is pretty good too.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would be interesting to expand the proposal to consider more cases in more detail:<br>&gt;&gt;&gt;  * Concurrency<br>&gt;&gt;&gt;  * SequenceType versus GeneratorType<br>&gt;&gt;&gt;  * Should a language feature depend on the Standard Library (GeneratorType)? Alternatives:<br>&gt;&gt;&gt;      + func myFunction -&gt; () -&gt; T?<br>&gt;&gt;&gt;      + func myFunction -&gt; () -&gt; (myFunction_State, myFunction_State -&gt; T?)<br>&gt;&gt;&gt;  * What happens if you write: guard ... else { yield ... }<br>&gt;&gt;&gt;  * Use an enum for the state that encapsulates all possible variables in each state<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you&#39;re not familiar with it, there&#39;s another thread that discussed similar here:<br>&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001872.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001872.html&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In particular you may be interested in Chris Lattner&#39;s comment:<br>&gt;&gt;&gt; I’m very interested in this, but it is clearly out of scope for Swift 3. It should also be considered alongside whatever async/concurrency approach we tackle (likely in swift 4).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Either way it&#39;s worth discussing and working towards :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Dec 22, 2015 at 6:03 PM, Félix Cloutier &lt;swift-evolution at swift.org &lt;&gt;&gt; wrote:<br>&gt;&gt;&gt; There&#39;s probably some additional work to do on the proposal document, but I would like to see coroutines in Swift too. The feature has been very successful in other languages like Python and C#, and unless I&#39;m mistaken, work is being done to standardize it in C++.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Generators are one use case, but resumable functions in general can also be used to make async code look prettier.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 22 déc. 2015 à 01:47:05, Susan Cheng via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; here is my proposal for swift lang<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/SusanDoggie/swift-evolution/blob/master/proposals/0018-coroutine-for-swift.md &lt;https://github.com/SusanDoggie/swift-evolution/blob/master/proposals/0018-coroutine-for-swift.md&gt;<br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/1997253b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47dd6e088b6ba4fb06a7030dda8b7122?s=50"></div><header><strong>Coroutine for Swift</strong> from <string>marc hoffman</string> &lt;mh at remobjects.com&gt;<p>December 22, 2015 at 06:00:00pm</p></header><div class="content"><p>Chris, Susan,<br></p><p>fwiw, this looks pretty similar to how we have Iterators as extension on our Swift compiler: http://docs.elementscompiler.com/Silver/LanguageExtensions/Iterators/. Looking forward to (something like) this becoming part of official Swift — the more custom extensions we can get rid of, the better ;).<br></p><p>—marc<br></p><p>&gt; On Dec 22, 2015, at 6:13 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Susan,<br>&gt; <br>&gt; As I mentioned on your original pull request, coroutines are closely related to async and other concurrency forms.  That entire space is out of scope for Swift 3, so we should wait until fall 2016 to pick up discussion on this and related topics.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 12:16 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Daniel,<br>&gt;&gt; <br>&gt;&gt; I&#39;ve heard many great things about goroutines, and I definitively think their advantages should be considered in the design of Swift&#39;s concurrency.<br>&gt;&gt; <br>&gt;&gt; I haven&#39;t used goroutines much so I may be incorrect, but I don&#39;t think they can be used to efficiently represent a generator like the proposal suggests.<br>&gt;&gt; <br>&gt;&gt; The generator described in the proposal has the following properties:<br>&gt;&gt;  * it is basically just syntactic sugar<br>&gt;&gt;  * new elements are generated lazily<br>&gt;&gt;  * the length doesn&#39;t need to be known at initialisation<br>&gt;&gt;  * it uses existing function syntax in the caller<br>&gt;&gt;  * it can all run on one thread<br>&gt;&gt;  * concurrency considerations may be limited to safely updating the state variable from more than one thread<br>&gt;&gt; <br>&gt;&gt; Maybe goroutines can be equivalent if the compiler can optimise it down to a generator. This proposal is basically syntactic sugar to concisely define a generator. Goroutines probably aren&#39;t a concise replacement for that sugar.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Wednesday, 23 December 2015, Daniel Valls Estella &lt;daniel at upzzle.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Ok,<br>&gt;&gt; <br>&gt;&gt; But I think goroutines are not really threads (are faster and cheaper enought to make a diference) and channels are more like filedescriptors than signals, you stream data throught these.<br>&gt;&gt; <br>&gt;&gt; Thanks for your answer!<br>&gt;&gt; <br>&gt;&gt; Daniel<br>&gt;&gt; <br>&gt;&gt; Daniel Valls Estella · tel. 659.910.830 · daniel at upzzle.com<br>&gt;&gt; <br>&gt;&gt;&gt; El 22 des 2015, a les 11:50, Susan Cheng &lt;susan.doggie at gmail.com&gt; va escriure:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s a little difference with goroutine. Go using threads and signal.<br>&gt;&gt;&gt; My implementation is following C# methods that MS staff tells me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Daniel Valls Estella &lt;daniel at upzzle.com&gt; 於 2015年12月22日星期二 寫道：<br>&gt;&gt;&gt; I think it’s better to take as a reference the Go language and his goroutines and channels.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not just to face these type of problems but also to take new architectural aproches to build software solutions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; refs:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; https://tour.golang.org/concurrency/1<br>&gt;&gt;&gt; https://tour.golang.org/concurrency/2<br>&gt;&gt;&gt; https://tour.golang.org/concurrency/5<br>&gt;&gt;&gt; https://youtu.be/f6kdp27TYZs<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What you think?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Daniel<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Daniel Valls Estella · tel. 659.910.830 · daniel at upzzle.com<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; El 22 des 2015, a les 8:33, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; va escriure:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Great proposal! I&#39;m all for this, I think your proposed implementation is pretty good too.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It would be interesting to expand the proposal to consider more cases in more detail:<br>&gt;&gt;&gt;&gt;  * Concurrency<br>&gt;&gt;&gt;&gt;  * SequenceType versus GeneratorType<br>&gt;&gt;&gt;&gt;  * Should a language feature depend on the Standard Library (GeneratorType)? Alternatives:<br>&gt;&gt;&gt;&gt;      + func myFunction -&gt; () -&gt; T?<br>&gt;&gt;&gt;&gt;      + func myFunction -&gt; () -&gt; (myFunction_State, myFunction_State -&gt; T?)<br>&gt;&gt;&gt;&gt;  * What happens if you write: guard ... else { yield ... }<br>&gt;&gt;&gt;&gt;  * Use an enum for the state that encapsulates all possible variables in each state<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you&#39;re not familiar with it, there&#39;s another thread that discussed similar here:<br>&gt;&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001872.html<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In particular you may be interested in Chris Lattner&#39;s comment:<br>&gt;&gt;&gt;&gt; I’m very interested in this, but it is clearly out of scope for Swift 3. It should also be considered alongside whatever async/concurrency approach we tackle (likely in swift 4).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Either way it&#39;s worth discussing and working towards :)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, Dec 22, 2015 at 6:03 PM, Félix Cloutier &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; There&#39;s probably some additional work to do on the proposal document, but I would like to see coroutines in Swift too. The feature has been very successful in other languages like Python and C#, and unless I&#39;m mistaken, work is being done to standardize it in C++.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Generators are one use case, but resumable functions in general can also be used to make async code look prettier.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Le 22 déc. 2015 à 01:47:05, Susan Cheng via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; here is my proposal for swift lang<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://github.com/SusanDoggie/swift-evolution/blob/master/proposals/0018-coroutine-for-swift.md<br>&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>Coroutine for Swift</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>December 23, 2015 at 10:00:00am</p></header><div class="content"><p>Hi,<br></p><p>I just want a wide public concern in swift community with this<br>implementation.<br>Should we have a proposal about @goto and @label as workaround? Just a joke<br>;)<br></p><p>Chris Lattner &lt;clattner at apple.com&gt; 於 2015年12月23日星期三 寫道：<br></p><p>&gt; Hi Susan,<br>&gt;<br>&gt; As I mentioned on your original pull request, coroutines are closely<br>&gt; related to async and other concurrency forms.  That entire space is out of<br>&gt; scope for Swift 3, so we should wait until fall 2016 to pick up discussion<br>&gt; on this and related topics.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; On Dec 22, 2015, at 12:16 PM, Andrew Bennett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; Hi Daniel,<br>&gt;<br>&gt; I&#39;ve heard many great things about goroutines, and I definitively think<br>&gt; their advantages should be considered in the design of Swift&#39;s concurrency.<br>&gt;<br>&gt; I haven&#39;t used goroutines much so I may be incorrect, but I don&#39;t think<br>&gt; they can be used to efficiently represent a generator like the proposal<br>&gt; suggests.<br>&gt;<br>&gt; The generator described in the proposal has the following properties:<br>&gt;  * it is basically just syntactic sugar<br>&gt;  * new elements are generated lazily<br>&gt;  * the length doesn&#39;t need to be known at initialisation<br>&gt;  * it uses existing function syntax in the caller<br>&gt;  * it can all run on one thread<br>&gt;  * concurrency considerations may be limited to safely updating the state<br>&gt; variable from more than one thread<br>&gt;<br>&gt; Maybe goroutines can be equivalent if the compiler can optimise it down to<br>&gt; a generator. This proposal is basically syntactic sugar to concisely define<br>&gt; a generator. Goroutines probably aren&#39;t a concise replacement for that<br>&gt; sugar.<br>&gt;<br>&gt;<br>&gt; On Wednesday, 23 December 2015, Daniel Valls Estella &lt;daniel at upzzle.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;daniel at upzzle.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; Ok,<br>&gt;&gt;<br>&gt;&gt; But I think goroutines are not really threads (are faster and cheaper<br>&gt;&gt; enought to make a diference) and channels are more like filedescriptors<br>&gt;&gt; than signals, you stream data throught these.<br>&gt;&gt;<br>&gt;&gt; Thanks for your answer!<br>&gt;&gt;<br>&gt;&gt; Daniel<br>&gt;&gt;<br>&gt;&gt; Daniel Valls Estella · tel. 659.910.830 · daniel at upzzle.com<br>&gt;&gt;<br>&gt;&gt; El 22 des 2015, a les 11:50, Susan Cheng &lt;susan.doggie at gmail.com&gt; va<br>&gt;&gt; escriure:<br>&gt;&gt;<br>&gt;&gt; It&#39;s a little difference with goroutine. Go using threads and signal.<br>&gt;&gt; My implementation is following C# methods that MS staff tells me.<br>&gt;&gt;<br>&gt;&gt; Daniel Valls Estella &lt;daniel at upzzle.com&gt; 於 2015年12月22日星期二 寫道：<br>&gt;&gt;<br>&gt;&gt;&gt; I think it’s better to take as a reference the *Go* language and his<br>&gt;&gt;&gt; *goroutines* and *channels*.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Not just to face these type of problems but also to take new<br>&gt;&gt;&gt; architectural aproches to build software solutions.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; refs:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://tour.golang.org/concurrency/1<br>&gt;&gt;&gt; https://tour.golang.org/concurrency/2<br>&gt;&gt;&gt; https://tour.golang.org/concurrency/5<br>&gt;&gt;&gt; https://youtu.be/f6kdp27TYZs<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What you think?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Daniel<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Daniel Valls Estella · tel. 659.910.830 · daniel at upzzle.com<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; El 22 des 2015, a les 8:33, Andrew Bennett via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; va escriure:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Great proposal! I&#39;m all for this, I think your proposed implementation<br>&gt;&gt;&gt; is pretty good too.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It would be interesting to expand the proposal to consider more cases in<br>&gt;&gt;&gt; more detail:<br>&gt;&gt;&gt;  * Concurrency<br>&gt;&gt;&gt;  * SequenceType versus GeneratorType<br>&gt;&gt;&gt;  * Should a language feature depend on the Standard Library<br>&gt;&gt;&gt; (GeneratorType)? Alternatives:<br>&gt;&gt;&gt;      + func myFunction -&gt; () -&gt; T?<br>&gt;&gt;&gt;      + func myFunction -&gt; () -&gt; (myFunction_State, myFunction_State -&gt;<br>&gt;&gt;&gt; T?)<br>&gt;&gt;&gt;  * What happens if you write: guard ... else { yield ... }<br>&gt;&gt;&gt;  * Use an enum for the state that encapsulates all possible variables in<br>&gt;&gt;&gt; each state<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If you&#39;re not familiar with it, there&#39;s another thread that discussed<br>&gt;&gt;&gt; similar here:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001872.html<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In particular you may be interested in Chris Lattner&#39;s comment:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’m very interested in this, but it is clearly out of scope for Swift 3.<br>&gt;&gt;&gt; It should also be considered alongside whatever async/concurrency approach<br>&gt;&gt;&gt; we tackle (likely in swift 4).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Either way it&#39;s worth discussing and working towards :)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tue, Dec 22, 2015 at 6:03 PM, Félix Cloutier &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; There&#39;s probably some additional work to do on the proposal document,<br>&gt;&gt;&gt;&gt; but I would like to see coroutines in Swift too. The feature has been very<br>&gt;&gt;&gt;&gt; successful in other languages like Python and C#, and unless I&#39;m mistaken,<br>&gt;&gt;&gt;&gt; work is being done to standardize it in C++.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Generators are one use case, but resumable functions in general can<br>&gt;&gt;&gt;&gt; also be used to make async code look prettier.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Le 22 déc. 2015 à 01:47:05, Susan Cheng via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; here is my proposal for swift lang<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; https://github.com/SusanDoggie/swift-evolution/blob/master/proposals/0018-coroutine-for-swift.md<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/b8d3e6a8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>Coroutine for Swift</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>December 23, 2015 at 05:00:00am</p></header><div class="content"><p>FWIW: https://github.com/Zewo/Venice<br></p><p>On Wed, Dec 23, 2015, 00:13 Susan Cheng via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi,<br>&gt;<br>&gt; I just want a wide public concern in swift community with this<br>&gt; implementation.<br>&gt; Should we have a proposal about @goto and @label as workaround? Just a<br>&gt; joke ;)<br>&gt;<br>&gt;<br>&gt; Chris Lattner &lt;clattner at apple.com&gt; 於 2015年12月23日星期三 寫道：<br>&gt;<br>&gt;&gt; Hi Susan,<br>&gt;&gt;<br>&gt;&gt; As I mentioned on your original pull request, coroutines are closely<br>&gt;&gt; related to async and other concurrency forms.  That entire space is out of<br>&gt;&gt; scope for Swift 3, so we should wait until fall 2016 to pick up discussion<br>&gt;&gt; on this and related topics.<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt; On Dec 22, 2015, at 12:16 PM, Andrew Bennett via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi Daniel,<br>&gt;&gt;<br>&gt;&gt; I&#39;ve heard many great things about goroutines, and I definitively think<br>&gt;&gt; their advantages should be considered in the design of Swift&#39;s concurrency.<br>&gt;&gt;<br>&gt;&gt; I haven&#39;t used goroutines much so I may be incorrect, but I don&#39;t think<br>&gt;&gt; they can be used to efficiently represent a generator like the proposal<br>&gt;&gt; suggests.<br>&gt;&gt;<br>&gt;&gt; The generator described in the proposal has the following properties:<br>&gt;&gt;  * it is basically just syntactic sugar<br>&gt;&gt;  * new elements are generated lazily<br>&gt;&gt;  * the length doesn&#39;t need to be known at initialisation<br>&gt;&gt;  * it uses existing function syntax in the caller<br>&gt;&gt;  * it can all run on one thread<br>&gt;&gt;  * concurrency considerations may be limited to safely updating the state<br>&gt;&gt; variable from more than one thread<br>&gt;&gt;<br>&gt;&gt; Maybe goroutines can be equivalent if the compiler can optimise it down<br>&gt;&gt; to a generator. This proposal is basically syntactic sugar to concisely<br>&gt;&gt; define a generator. Goroutines probably aren&#39;t a concise replacement for<br>&gt;&gt; that sugar.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Wednesday, 23 December 2015, Daniel Valls Estella &lt;daniel at upzzle.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Ok,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But I think goroutines are not really threads (are faster and cheaper<br>&gt;&gt;&gt; enought to make a diference) and channels are more like filedescriptors<br>&gt;&gt;&gt; than signals, you stream data throught these.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks for your answer!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Daniel<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Daniel Valls Estella · tel. 659.910.830 · daniel at upzzle.com<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; El 22 des 2015, a les 11:50, Susan Cheng &lt;susan.doggie at gmail.com&gt; va<br>&gt;&gt;&gt; escriure:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It&#39;s a little difference with goroutine. Go using threads and signal.<br>&gt;&gt;&gt; My implementation is following C# methods that MS staff tells me.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Daniel Valls Estella &lt;daniel at upzzle.com&gt; 於 2015年12月22日星期二 寫道：<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I think it’s better to take as a reference the *Go* language and his<br>&gt;&gt;&gt;&gt; *goroutines* and *channels*.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Not just to face these type of problems but also to take new<br>&gt;&gt;&gt;&gt; architectural aproches to build software solutions.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; refs:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; https://tour.golang.org/concurrency/1<br>&gt;&gt;&gt;&gt; https://tour.golang.org/concurrency/2<br>&gt;&gt;&gt;&gt; https://tour.golang.org/concurrency/5<br>&gt;&gt;&gt;&gt; https://youtu.be/f6kdp27TYZs<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; What you think?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Daniel<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Daniel Valls Estella · tel. 659.910.830 · daniel at upzzle.com<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; El 22 des 2015, a les 8:33, Andrew Bennett via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; va escriure:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Great proposal! I&#39;m all for this, I think your proposed implementation<br>&gt;&gt;&gt;&gt; is pretty good too.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It would be interesting to expand the proposal to consider more cases<br>&gt;&gt;&gt;&gt; in more detail:<br>&gt;&gt;&gt;&gt;  * Concurrency<br>&gt;&gt;&gt;&gt;  * SequenceType versus GeneratorType<br>&gt;&gt;&gt;&gt;  * Should a language feature depend on the Standard Library<br>&gt;&gt;&gt;&gt; (GeneratorType)? Alternatives:<br>&gt;&gt;&gt;&gt;      + func myFunction -&gt; () -&gt; T?<br>&gt;&gt;&gt;&gt;      + func myFunction -&gt; () -&gt; (myFunction_State, myFunction_State -&gt;<br>&gt;&gt;&gt;&gt; T?)<br>&gt;&gt;&gt;&gt;  * What happens if you write: guard ... else { yield ... }<br>&gt;&gt;&gt;&gt;  * Use an enum for the state that encapsulates all possible variables<br>&gt;&gt;&gt;&gt; in each state<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If you&#39;re not familiar with it, there&#39;s another thread that discussed<br>&gt;&gt;&gt;&gt; similar here:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001872.html<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In particular you may be interested in Chris Lattner&#39;s comment:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I’m very interested in this, but it is clearly out of scope for Swift<br>&gt;&gt;&gt;&gt; 3. It should also be considered alongside whatever async/concurrency<br>&gt;&gt;&gt;&gt; approach we tackle (likely in swift 4).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Either way it&#39;s worth discussing and working towards :)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Tue, Dec 22, 2015 at 6:03 PM, Félix Cloutier &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; There&#39;s probably some additional work to do on the proposal document,<br>&gt;&gt;&gt;&gt;&gt; but I would like to see coroutines in Swift too. The feature has been very<br>&gt;&gt;&gt;&gt;&gt; successful in other languages like Python and C#, and unless I&#39;m mistaken,<br>&gt;&gt;&gt;&gt;&gt; work is being done to standardize it in C++.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Generators are one use case, but resumable functions in general can<br>&gt;&gt;&gt;&gt;&gt; also be used to make async code look prettier.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Le 22 déc. 2015 à 01:47:05, Susan Cheng via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; here is my proposal for swift lang<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; https://github.com/SusanDoggie/swift-evolution/blob/master/proposals/0018-coroutine-for-swift.md<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/f6839a92/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>Coroutine for Swift</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>December 22, 2015 at 06:00:00pm</p></header><div class="content"><p>with consider defer statement<br>we can clean up the memory if coroutine is not completed.<br></p><p>i have updated the proposal.<br></p><p>2015-12-22 15:33 GMT+08:00 Andrew Bennett &lt;cacoyi at gmail.com&gt;:<br></p><p>&gt; Great proposal! I&#39;m all for this, I think your proposed implementation is<br>&gt; pretty good too.<br>&gt;<br>&gt; It would be interesting to expand the proposal to consider more cases in<br>&gt; more detail:<br>&gt;  * Concurrency<br>&gt;  * SequenceType versus GeneratorType<br>&gt;  * Should a language feature depend on the Standard Library<br>&gt; (GeneratorType)? Alternatives:<br>&gt;      + func myFunction -&gt; () -&gt; T?<br>&gt;      + func myFunction -&gt; () -&gt; (myFunction_State, myFunction_State -&gt; T?)<br>&gt;  * What happens if you write: guard ... else { yield ... }<br>&gt;  * Use an enum for the state that encapsulates all possible variables in<br>&gt; each state<br>&gt;<br>&gt; If you&#39;re not familiar with it, there&#39;s another thread that discussed<br>&gt; similar here:<br>&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001872.html<br>&gt;<br>&gt; In particular you may be interested in Chris Lattner&#39;s comment:<br>&gt;<br>&gt; I’m very interested in this, but it is clearly out of scope for Swift 3.<br>&gt; It should also be considered alongside whatever async/concurrency approach<br>&gt; we tackle (likely in swift 4).<br>&gt;<br>&gt;<br>&gt; Either way it&#39;s worth discussing and working towards :)<br>&gt;<br>&gt; On Tue, Dec 22, 2015 at 6:03 PM, Félix Cloutier &lt;swift-evolution at swift.org<br>&gt; &gt; wrote:<br>&gt;<br>&gt;&gt; There&#39;s probably some additional work to do on the proposal document, but<br>&gt;&gt; I would like to see coroutines in Swift too. The feature has been very<br>&gt;&gt; successful in other languages like Python and C#, and unless I&#39;m mistaken,<br>&gt;&gt; work is being done to standardize it in C++.<br>&gt;&gt;<br>&gt;&gt; Generators are one use case, but resumable functions in general can also<br>&gt;&gt; be used to make async code look prettier.<br>&gt;&gt;<br>&gt;&gt; Félix<br>&gt;&gt;<br>&gt;&gt; Le 22 déc. 2015 à 01:47:05, Susan Cheng via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; here is my proposal for swift lang<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/SusanDoggie/swift-evolution/blob/master/proposals/0018-coroutine-for-swift.md<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/59eecc1f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
