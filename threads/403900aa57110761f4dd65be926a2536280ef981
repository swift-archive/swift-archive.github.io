<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 14, 2016 at 10:00:00pm</p></header><div class="content"><p>Dear Evolutionaries,<br></p><p>First off, I like Swift!<br></p><p>I have some proposals for swift 3ff. (since the `++` operator is discouraged ;) ):<br></p><p>1. Custom implementation of equals operator `==` for value types should be forbidden. Rationale: Why has it been added in the first place? For omitting some values from the equals test? A user may introduce side-effects in that very method, i.e., check some global variable. It should to the most be allowed to mark/annotate some properties with `transient` or some better name, in order to prevent it being part of the equals test. But I would discourage the ability to omit some of the values from the equals test, since it does not make sense for value types, does it? If a value instance is equal to another, but the value may differ... this is odd semantics. Properties pointing at reference types should be tested with `===`. The `hashValue` for `Hashable` value types, should be auto-computed, too. Since a value type is &quot;kind of&quot; immutable (will be copied if it is changed), the hash value can be cached.<br>2. `dispatch` keyword on functions/parameters especially for operators. Which leads to dynamic dispatch of one or more parameters (as defined via the keyword). Rationale: Swift is a multi-paradigm language. It is neither as hard with immutability as Haskell is, but not as open as Python or whatever. I see Swift as a golden middle course. This is why in Swift value and reference types coexist, isn&#39;t it? So, although the focus seems to lie on value types and static dispatch, the dynamic world still is your frient, right? Adding dynamic/multi dispatch on-demand would be great. Now I have to implement it by defining an operator on a super type and implement an instance method, which the operator can delegate to. Last but not least, in the instance method I have to do the dispatch of the second parameter by hand. This feature could be used wonderfully together with value types using your great Existential Containers, too.<br>3. As a follow-up to *2.*: `default`-case for methods/operators like equals (`==`) to allow safe polymorphic calls for mixed types (or even complete pattern matching for method overloading, like many functional languages do it for having functions with different entry points for different values). Rationale: If you could add a `default`-case (e.g. as an additional statement to the `return` or beneath the definition of the return type in the method head) which returns `false`, then you could safely implement all `T == T` checks and all `T == U` checks will just return false. This does not make sense for all methods, but I can imagine of more than just equals ;) . This way swift could soften the requirement of PATs (Protocol with Associated Types) with the associated type `Self`. This would be a very first step to existentials... leading to the next and last proposal for today<br>4. Add poor-mans existentials which allow to access non-PAT methods as well as methods with a `default`-case (see *3.*). Rationale: I read the [generics manifesto][0] and really liked the part [existentials][1]. In a first step I wouldn&#39;t do complicated things like chaining existentials, but do something similar like in structs with `mutating` functions: You just cannot call them on `let` variables (compiler error). The same could be done for methods using the associated type in their signature (because of the co-/contravariance problem) unless the associated type is `Self` and the function has a `default`-clause. By the way I think, that not implementing pseudo-existentials (like Java and Kotlin do with their wildcards or variance declarations `in`/`out` respectively) and I hope that the existentials will come to swift in the future... I was a little bit afraid that the &quot;Existentials&quot; section is beneath &quot;Unlikely&quot; and &quot;Potential Removals&quot;, but since these headings are on the same level, this does not mean that implementing existentials in the future are unlikely, does it? I have some ideas how they could fit into the language very well, if you like to hear them...?<br></p><p>I would really appreciate discussing these 4 proposals :) .<br></p><p>All the best<br>Johannes<br></p><p>[0]: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md<br>[1]: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#existentials<br></p><p>--<br>Dr. Johannes Neubauer<br>E-Mail: neubauer at kingsware.de<br>WWW   : http://www.kingsware.de<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160714/4039f981/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/36f3ec204630839e54fb68c6979e5f78?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Daniel Resnick</string> &lt;danielzresnick at gmail.com&gt;<p>July 14, 2016 at 01:00:00pm</p></header><div class="content"><p>Forbidding custom `==` for value types would break equality for all Swift<br>collection types, since they use reference types behind the scenes for<br>storing memory and copy on write semantics. Furthermore, why should<br>properties pointing to reference types always use `===`? What if the<br>reference type conforms to `Equatable`?<br></p><p>On Thu, Jul 14, 2016 at 1:36 PM, Johannes Neubauer via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Dear Evolutionaries,<br>&gt;<br>&gt; First off, I like Swift!<br>&gt;<br>&gt; I have some proposals for swift 3ff. (since the `++` operator is<br>&gt; discouraged ;) ):<br>&gt;<br>&gt; 1. Custom implementation of equals operator `==` for value types should be<br>&gt; forbidden. Rationale: Why has it been added in the first place? For<br>&gt; omitting some values from the equals test? A user may introduce<br>&gt; side-effects in that very method, i.e., check some global variable. It<br>&gt; should to the most be allowed to mark/annotate some properties with<br>&gt; `transient` or some better name, in order to prevent it being part of the<br>&gt; equals test. But I would discourage the ability to omit some of the values<br>&gt; from the equals test, since it does not make sense for value types, does<br>&gt; it? If a value instance is equal to another, but the value may differ...<br>&gt; this is odd semantics. Properties pointing at reference types should be<br>&gt; tested with `===`. The `hashValue` for `Hashable` value types, should be<br>&gt; auto-computed, too. Since a value type is &quot;kind of&quot; immutable (will be<br>&gt; copied if it is changed), the hash value can be cached.<br>&gt; 2. `dispatch` keyword on functions/parameters especially for operators.<br>&gt; Which leads to dynamic dispatch of one or more parameters (as defined via<br>&gt; the keyword). Rationale: Swift is a multi-paradigm language. It is neither<br>&gt; as hard with immutability as Haskell is, but not as open as Python or<br>&gt; whatever. I see Swift as a golden middle course. This is why in Swift value<br>&gt; and reference types coexist, isn&#39;t it? So, although the focus seems to lie<br>&gt; on value types and static dispatch, the dynamic world still is your frient,<br>&gt; right? Adding dynamic/multi dispatch on-demand would be great. Now I have<br>&gt; to implement it by defining an operator on a super type and implement an<br>&gt; instance method, which the operator can delegate to. Last but not least, in<br>&gt; the instance method I have to do the dispatch of the second parameter by<br>&gt; hand. This feature could be used wonderfully together with value types<br>&gt; using your great Existential Containers, too.<br>&gt; 3. As a follow-up to *2.*: `default`-case for methods/operators like<br>&gt; equals (`==`) to allow safe polymorphic calls for mixed types (or even<br>&gt; complete pattern matching for method overloading, like many functional<br>&gt; languages do it for having functions with different entry points for<br>&gt; different values). Rationale: If you could add a `default`-case (e.g. as an<br>&gt; additional statement to the `return` or beneath the definition of the<br>&gt; return type in the method head) which returns `false`, then you could<br>&gt; safely implement all `T == T` checks and all `T == U` checks will just<br>&gt; return false. This does not make sense for all methods, but I can imagine<br>&gt; of more than just equals ;) . This way swift could soften the requirement<br>&gt; of PATs (Protocol with Associated Types) with the associated type `Self`.<br>&gt; This would be a very first step to existentials... leading to the next and<br>&gt; last proposal for today<br>&gt; 4. Add poor-mans existentials which allow to access non-PAT methods as<br>&gt; well as methods with a `default`-case (see *3.*). Rationale: I read the<br>&gt; [generics manifesto][0] and really liked the part [existentials][1]. In a<br>&gt; first step I wouldn&#39;t do complicated things like chaining existentials, but<br>&gt; do something similar like in structs with `mutating` functions: You just<br>&gt; cannot call them on `let` variables (compiler error). The same could be<br>&gt; done for methods using the associated type in their signature (because of<br>&gt; the co-/contravariance problem) unless the associated type is `Self` and<br>&gt; the function has a `default`-clause. By the way I think, that not<br>&gt; implementing pseudo-existentials (like Java and Kotlin do with their<br>&gt; wildcards or variance declarations `in`/`out` respectively) and I hope that<br>&gt; the existentials will come to swift in the future... I was a little bit<br>&gt; afraid that the &quot;Existentials&quot; section is beneath &quot;Unlikely&quot; and &quot;Potential<br>&gt; Removals&quot;, but since these headings are on the same level, this does not<br>&gt; mean that implementing existentials in the future are unlikely, does it? I<br>&gt; have some ideas how they could fit into the language very well, if you like<br>&gt; to hear them...?<br>&gt;<br>&gt; I would really appreciate discussing these 4 proposals :) .<br>&gt;<br>&gt; All the best<br>&gt; Johannes<br>&gt;<br>&gt; [0]: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md<br>&gt; [1]:<br>&gt; https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#existentials<br>&gt;<br>&gt; --<br>&gt; Dr. Johannes Neubauer<br>&gt; E-Mail: neubauer at kingsware.de<br>&gt; WWW   : http://www.kingsware.de<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160714/f181e59b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 15, 2016 at 12:00:00am</p></header><div class="content"><p>Hi Daniel,<br></p><p>I will answer backwards, since it is easier for me this way.<br></p><p>&gt; Am 14.07.2016 um 22:47 schrieb Daniel Resnick &lt;danielzresnick at gmail.com&gt;:<br>&gt; <br>&gt; Furthermore, why should properties pointing to reference types always use `===`? What if the reference type conforms to `Equatable`?<br></p><p>I proposed to use `===`, since a value of a reference a value type is referencing is the reference itself. But point taken. So a solution could be to use `==` for reference types implementing `Equatable`. But wait for the punch-line below ;).<br></p><p>&gt; Forbidding custom `==` for value types would break equality for all Swift collection types, since they use reference types behind the scenes for storing memory and copy on write semantics.<br></p><p>If the storage implements `Equatable`, this problem should be solved, right?<br></p><p>Anyway (punch-line following), although I don’t know how exactly the low-level Value-Witness-Table works, but if it works as I would expect, then there should be only exactly one entry per „equal“ storage, and all collection types with the same data point to the same reference (which is very memory efficient and table lookup using hashing should be constant time). If this is correct, a check for `===` suffices. AFAIK, the low-level swift implementation already checks for `===` on value types that are stored on the heap (see [this blog post][0]) and don’t bother calling `==` if `===` holds.<br></p><p>All the best<br>Johannes<br></p><p>[0]: https://www.raywenderlich.com/112029/reference-value-types-in-swift-part-2<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160715/1e06833b/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>July 14, 2016 at 03:00:00pm</p></header><div class="content"><p>Additive proposals are out of scope for Swift 3; you&#39;ll have better luck if<br>you come back around August and propose these one at a time.<br></p><p>I don&#39;t see the need for &quot;poor man&#39;s existentials&quot; - existential<br>improvements are out of scope for the next release, and there are already a<br>bunch of designs floating around. You might want to search the archives for<br>more details. #3 falls out of a proper implementation of existential types<br>that support protocols with associated types and self requirements.<br></p><p><br>&gt; If the storage implements `Equatable`, this problem should be solved,<br>&gt; right?<br>&gt;<br>&gt; Anyway (punch-line following), although I don’t know how exactly the<br>&gt; low-level Value-Witness-Table works, but if it works as I would expect,<br>&gt; then there should be only exactly one entry per „equal“ storage, and all<br>&gt; collection types with the same data point to the same reference (which is<br>&gt; very memory efficient and table lookup using hashing should be constant<br>&gt; time). If this is correct, a check for `===` suffices. AFAIK, the low-level<br>&gt; swift implementation already checks for `===` on value types that are<br>&gt; stored on the heap (see [this blog post][0]) and don’t bother calling `==`<br>&gt; if `===` holds.<br>&gt;<br></p><p>This isn&#39;t true. Two buffers can have the same contents and therefore be<br>equal, but be distinct from each other in terms of identity.<br></p><p><br>&gt;<br>&gt; All the best<br>&gt; Johannes<br>&gt;<br>&gt; [0]:<br>&gt; https://www.raywenderlich.com/112029/reference-value-types-in-swift-part-2<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160714/c19a0610/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 15, 2016 at 01:00:00am</p></header><div class="content"><p>Hi Austin,<br></p><p>&gt; Am 15.07.2016 um 00:35 schrieb Austin Zheng &lt;austinzheng at gmail.com&gt;:<br>&gt; <br>&gt; Additive proposals are out of scope for Swift 3; you&#39;ll have better luck if you come back around August and propose these one at a time.<br></p><p>Ok. I didn’t know that proposals can be only for the next release. I will come back later ;).<br></p><p>&gt; I don&#39;t see the need for &quot;poor man&#39;s existentials&quot; - existential improvements are out of scope for the next release, and there are already a bunch of designs floating around. You might want to search the archives for more details. #3 falls out of a proper implementation of existential types that support protocols with associated types and self requirements.<br></p><p><br>&gt; If the storage implements `Equatable`, this problem should be solved, right?<br>&gt; <br>&gt; Anyway (punch-line following), although I don’t know how exactly the low-level Value-Witness-Table works, but if it works as I would expect, then there should be only exactly one entry per „equal“ storage, and all collection types with the same data point to the same reference (which is very memory efficient and table lookup using hashing should be constant time). If this is correct, a check for `===` suffices. AFAIK, the low-level swift implementation already checks for `===` on value types that are stored on the heap (see [this blog post][0]) and don’t bother calling `==` if `===` holds.<br>&gt; <br>&gt; This isn&#39;t true. Two buffers can have the same contents and therefore be equal, but be distinct from each other in terms of identity.<br></p><p>Yeah, I had a discussion on swift-dev about this, too. There were some misleading blog posts out there. But perhaps it should be that way… could be another proposal, but not for Swift 3.<br></p><p>&gt; <br>&gt; [0]: https://www.raywenderlich.com/112029/reference-value-types-in-swift-part-2<br></p><p>All the best<br>Johannes<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160715/e6cbf37c/attachment.sig&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 15, 2016 at 02:00:00pm</p></header><div class="content"><p>Hello Johannes,<br></p><p>&gt; Am 14.07.2016 um 22:36 schrieb Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; 1. Custom implementation of equals operator `==` for value types should be forbidden. Rationale: Why has it been added in the first place? For omitting some values from the equals test?<br></p><p>It would be nice to have an easy way to conform to Hashable &amp; Equatable without writing much boilerplate (it&#39;s possible in other existing languages), but I see no motivation to forbid custom implementations — not only because you are free to stay away from those, but also because there can be good reasons to do so:<br>Equality isn&#39;t always as simple as it seems, and many developers have been bitten by issues with floating point types… instead of &quot;a == b&quot;, often &quot;abs(a - b) &lt; delta&quot; is the right choice, and a custom &quot;==&quot; is the only option to specify delta (given a situation where you are comparing float-members of a struct).<br></p><p>For the other three points, I&#39;d suggest to present each of them later in separate threads — it&#39;s already hard to follow each topic, and it would be even harder when there are three different proposals in a single thread ;-)<br></p><p>Best regards,<br>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>July 15, 2016 at 01:00:00pm</p></header><div class="content"><p>Additional two &quot;things&quot; maybe considered equal in the chosen problem domain<br>despite their identity (memory location, etc.) being different. Having the<br>ability to supply custom hash and equality for types can be a useful tool<br>in a developers toolbox. For example two pathways of code may create what<br>is actually the same thing (say a reference to the same file on disk) then<br>want to work with stdlib set and/or dictionary with the equivalent things<br>being resolved correctly, etc.<br></p><p>To remove custom equality will limit some designs and to force identity<br>based equality with present similar problems on the other end of the<br>spectrum.<br></p><p><br>-Shawn<br></p><p>On Fri, Jul 15, 2016 at 8:37 AM Tino Heth via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Johannes,<br>&gt;<br>&gt; &gt; Am 14.07.2016 um 22:36 schrieb Johannes Neubauer via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;<br>&gt; &gt; 1. Custom implementation of equals operator `==` for value types should<br>&gt; be forbidden. Rationale: Why has it been added in the first place? For<br>&gt; omitting some values from the equals test?<br>&gt;<br>&gt; It would be nice to have an easy way to conform to Hashable &amp; Equatable<br>&gt; without writing much boilerplate (it&#39;s possible in other existing<br>&gt; languages), but I see no motivation to forbid custom implementations — not<br>&gt; only because you are free to stay away from those, but also because there<br>&gt; can be good reasons to do so:<br>&gt; Equality isn&#39;t always as simple as it seems, and many developers have been<br>&gt; bitten by issues with floating point types… instead of &quot;a == b&quot;, often<br>&gt; &quot;abs(a - b) &lt; delta&quot; is the right choice, and a custom &quot;==&quot; is the only<br>&gt; option to specify delta (given a situation where you are comparing<br>&gt; float-members of a struct).<br>&gt;<br>&gt; For the other three points, I&#39;d suggest to present each of them later in<br>&gt; separate threads — it&#39;s already hard to follow each topic, and it would be<br>&gt; even harder when there are three different proposals in a single thread ;-)<br>&gt;<br>&gt; Best regards,<br>&gt; Tino<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160715/d9b997ff/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 15, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 15.07.2016 um 15:19 schrieb Shawn Erickson &lt;shawnce at gmail.com&gt;:<br>&gt; <br>&gt; Additional two &quot;things&quot; maybe considered equal in the chosen problem domain despite their identity (memory location, etc.) being different. Having the ability to supply custom hash and equality for types can be a useful tool in a developers toolbox. For example two pathways of code may create what is actually the same thing (say a reference to the same file on disk) then want to work with stdlib set and/or dictionary with the equivalent things being resolved correctly, etc.<br>&gt; <br>&gt; To remove custom equality will limit some designs and to force identity based equality with present similar problems on the other end of the spectrum.<br></p><p>It is only for value types. For reference types, which have an identity, you are right, but it doesn’t hold for values.<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160715/6574f964/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>July 15, 2016 at 04:00:00pm</p></header><div class="content"><p>Here&#39;s a value type that uses custom equality (at least, I think so):<br>String. Since it uses extended grapheme clusters, internally two Strings<br>may be composed of different Unicode scalars, but if they create the same<br>Characters they are considered to be equal.<br></p><p>On Fri, Jul 15, 2016 at 09:12 Johannes Neubauer via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; Am 15.07.2016 um 15:19 schrieb Shawn Erickson &lt;shawnce at gmail.com&gt;:<br>&gt; &gt;<br>&gt; &gt; Additional two &quot;things&quot; maybe considered equal in the chosen problem<br>&gt; domain despite their identity (memory location, etc.) being different.<br>&gt; Having the ability to supply custom hash and equality for types can be a<br>&gt; useful tool in a developers toolbox. For example two pathways of code may<br>&gt; create what is actually the same thing (say a reference to the same file on<br>&gt; disk) then want to work with stdlib set and/or dictionary with the<br>&gt; equivalent things being resolved correctly, etc.<br>&gt; &gt;<br>&gt; &gt; To remove custom equality will limit some designs and to force identity<br>&gt; based equality with present similar problems on the other end of the<br>&gt; spectrum.<br>&gt;<br>&gt; It is only for value types. For reference types, which have an identity,<br>&gt; you are right, but it doesn’t hold for values.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>-Saagar Jha<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160715/33c37367/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 15, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 15.07.2016 um 18:29 schrieb Saagar Jha &lt;saagarjha28 at gmail.com&gt;:<br>&gt; <br>&gt; Here&#39;s a value type that uses custom equality (at least, I think so): String. Since it uses extended grapheme clusters, internally two Strings may be composed of different Unicode scalars, but if they create the same Characters they are considered to be equal.<br></p><p>Good point. But shouldn’t this be another type of equality then or do they behave exactly the same and are just implemented differently? Because if not, this seems to be introducing mixed-type comparisons like `5l == 5` or `Point2D(0, 0) == Point3D(0, 0, 0) which are bad since they make it impossible to guarantee reflexivity, symmetry, and transitivity. Swift does a hard job to enforce this from the programmer. If this is really intended, then there should be a fixed implementation for equality of value types, which can be overridden, but which leads to a warning (which has to be suppressed with some kind of annotation or so). Because, these custom implementations can do harm.<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160715/46c1dd86/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 15, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Am 15.07.2016 um 18:41 schrieb Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; Am 15.07.2016 um 18:29 schrieb Saagar Jha &lt;saagarjha28 at gmail.com&gt;:<br>&gt;&gt; <br>&gt;&gt; Here&#39;s a value type that uses custom equality (at least, I think so): String. Since it uses extended grapheme clusters, internally two Strings may be composed of different Unicode scalars, but if they create the same Characters they are considered to be equal.<br>&gt; <br>&gt; Good point. But shouldn’t this be another type of equality then or do they behave exactly the same and are just implemented differently? Because if not, this seems to be introducing mixed-type comparisons like `5l == 5` or `Point2D(0, 0) == Point3D(0, 0, 0) which are bad since they make it impossible to guarantee reflexivity, symmetry, and transitivity. Swift does a hard job to enforce this from the programmer. If this is really intended, then there should be a fixed implementation for equality of value types, which can be overridden, but which leads to a warning (which has to be suppressed with some kind of annotation or so). Because, these custom implementations can do harm.<br></p><p>And I would do the „standard equality“ upfront even if there is a custom implementation and if the „standard equality“ says `true`, the custom implementation is not asked. This would reduce the possibility of false-negatives.<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160715/1e544865/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>July 15, 2016 at 05:00:00pm</p></header><div class="content"><p>Equatable, where the == operator is defined, will not let you compare two<br>things of a different type.<br>On Fri, Jul 15, 2016 at 10:02 Johannes Neubauer &lt;neubauer at kingsware.de&gt;<br>wrote:<br></p><p>&gt;<br>&gt; &gt; Am 15.07.2016 um 18:41 schrieb Johannes Neubauer via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; Am 15.07.2016 um 18:29 schrieb Saagar Jha &lt;saagarjha28 at gmail.com&gt;:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Here&#39;s a value type that uses custom equality (at least, I think so):<br>&gt; String. Since it uses extended grapheme clusters, internally two Strings<br>&gt; may be composed of different Unicode scalars, but if they create the same<br>&gt; Characters they are considered to be equal.<br>&gt; &gt;<br>&gt; &gt; Good point. But shouldn’t this be another type of equality then or do<br>&gt; they behave exactly the same and are just implemented differently? Because<br>&gt; if not, this seems to be introducing mixed-type comparisons like `5l == 5`<br>&gt; or `Point2D(0, 0) == Point3D(0, 0, 0) which are bad since they make it<br>&gt; impossible to guarantee reflexivity, symmetry, and transitivity. Swift does<br>&gt; a hard job to enforce this from the programmer. If this is really intended,<br>&gt; then there should be a fixed implementation for equality of value types,<br>&gt; which can be overridden, but which leads to a warning (which has to be<br>&gt; suppressed with some kind of annotation or so). Because, these custom<br>&gt; implementations can do harm.<br>&gt;<br>&gt; And I would do the „standard equality“ upfront even if there is a custom<br>&gt; implementation and if the „standard equality“ says `true`, the custom<br>&gt; implementation is not asked. This would reduce the possibility of<br>&gt; false-negatives.<br>&gt;<br>-- <br>-Saagar Jha<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160715/c02371ee/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 15, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Am 15.07.2016 um 19:05 schrieb Saagar Jha &lt;saagarjha28 at gmail.com&gt;:<br>&gt; <br>&gt; Equatable, where the == operator is defined, will not let you compare two things of a different type.<br></p><p>I  know that. I mean, this is what I meant with „Swift does a hard job to enforce this“.<br></p><p>&gt; On Fri, Jul 15, 2016 at 10:02 Johannes Neubauer &lt;neubauer at kingsware.de&gt; wrote:<br>&gt; <br>&gt; &gt; Am 15.07.2016 um 18:41 schrieb Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; Am 15.07.2016 um 18:29 schrieb Saagar Jha &lt;saagarjha28 at gmail.com&gt;:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Here&#39;s a value type that uses custom equality (at least, I think so): String. Since it uses extended grapheme clusters, internally two Strings may be composed of different Unicode scalars, but if they create the same Characters they are considered to be equal.<br>&gt; &gt;<br>&gt; &gt; Good point. But shouldn’t this be another type of equality then or do they behave exactly the same and are just implemented differently? Because if not, this seems to be introducing mixed-type comparisons like `5l == 5` or `Point2D(0, 0) == Point3D(0, 0, 0) which are bad since they make it impossible to guarantee reflexivity, symmetry, and transitivity. Swift does a hard job to enforce this from the programmer. If this is really intended, then there should be a fixed implementation for equality of value types, which can be overridden, but which leads to a warning (which has to be suppressed with some kind of annotation or so). Because, these custom implementations can do harm.<br>&gt; <br>&gt; And I would do the „standard equality“ upfront even if there is a custom implementation and if the „standard equality“ says `true`, the custom implementation is not asked. This would reduce the possibility of false-negatives.<br>&gt; --<br>&gt; -Saagar Jha<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160715/1022c47e/attachment.sig&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 16, 2016 at 03:00:00pm</p></header><div class="content"><p>Dear Saagar,<br></p><p>&gt; Am 15.07.2016 um 19:05 schrieb Saagar Jha &lt;saagarjha28 at gmail.com&gt;:<br>&gt; <br>&gt; Equatable, where the == operator is defined, will not let you compare two things of a different type. <br></p><p>This is not true for reference types. Consider the following **bad** (but compiling code):<br></p><p>```swift<br>class A: Equatable {}<br></p><p>class Aa: A {<br>    let a: Int<br>    <br>    init(a: Int) {<br>        self.a = a<br>    }<br>}<br></p><p>func ==(lhs: A, rhs: A) -&gt; Bool {<br>    return lhs === rhs<br>}<br></p><p>func ==(lhs: Aa, rhs: Aa) -&gt; Bool {<br>    return lhs.a == rhs.a<br>}<br>```<br></p><p>Now let us use this:<br></p><p>```swift<br>let a = A()<br>let a2 = A()<br>let aa = Aa(a: 0)<br>let aa2 = Aa(a: 1)<br>let aa3 = Aa(a: 1)<br></p><p>// prints `true`<br>print(a == a)<br></p><p>// prints `false`<br>print(a == a2)<br></p><p>// prints `false`<br>print(a == aa)<br></p><p>// prints `false`<br>print(a == aa3)<br></p><p>// prints `false`<br>print(aa == aa2)<br></p><p>// prints `true` because it compares the `a: Int` values.<br>print(aa2 == aa3)<br></p><p>// now mixed-type comparison (returns `false`)<br>print(a == aa2)<br>```<br></p><p>Hence, you can do mixed-type equality checks in Swift. Even worse is, you can do this:<br></p><p>```swift<br>let aa2AsA: A = aa2,<br>    aa3AsA: A = aa3<br></p><p>// prints `true` because it compares the `a: Int` values.<br>print(aa2 == aa3)<br></p><p>// prints `false`, because the equals method of `A` is used<br>print(aa2AsA == aa3AsA)<br>```<br></p><p>Just by assigning an object to a variable that is typed differently the result is completely different. This is because method parameters are dispatched statically. This is fast, but results in really unintended results, you can do a **lot** of things breaking the contract of `==` with that. This is why I wanted to add a `default` clause (in *3.* of my original proposal) for such methods involving two references to `Self`. Further on, I wanted to add the keyword `dispatch` for method (and operator) parameters, where dispatching is necessary (see *2.* of my original proposal).<br></p><p>I think these changes are crucial for the safety of the language. Now you can write really bad code and the compiler/IDE doesn’t help you. You may do the dynamic dispatch manually, but this is error-prone (and many developers aren’t even aware of the issue).<br></p><p>All the best<br>Johannes<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>July 16, 2016 at 09:00:00am</p></header><div class="content"><p>How about Polar(r: 0, phi: 0) ?<br>It should all equal with any angles if r == 0.<br></p><p>2016-07-16 0:41 GMT+08:00 Johannes Neubauer via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt;<br>&gt; &gt; Am 15.07.2016 um 18:29 schrieb Saagar Jha &lt;saagarjha28 at gmail.com&gt;:<br>&gt; &gt;<br>&gt; &gt; Here&#39;s a value type that uses custom equality (at least, I think so):<br>&gt; String. Since it uses extended grapheme clusters, internally two Strings<br>&gt; may be composed of different Unicode scalars, but if they create the same<br>&gt; Characters they are considered to be equal.<br>&gt;<br>&gt; Good point. But shouldn’t this be another type of equality then or do they<br>&gt; behave exactly the same and are just implemented differently? Because if<br>&gt; not, this seems to be introducing mixed-type comparisons like `5l == 5` or<br>&gt; `Point2D(0, 0) == Point3D(0, 0, 0) which are bad since they make it<br>&gt; impossible to guarantee reflexivity, symmetry, and transitivity. Swift does<br>&gt; a hard job to enforce this from the programmer. If this is really intended,<br>&gt; then there should be a fixed implementation for equality of value types,<br>&gt; which can be overridden, but which leads to a warning (which has to be<br>&gt; suppressed with some kind of annotation or so). Because, these custom<br>&gt; implementations can do harm.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/0c30ddd6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 16, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Am 16.07.2016 um 03:53 schrieb Susan Cheng &lt;susan.doggie at gmail.com&gt;:<br>&gt; <br>&gt; How about Polar(r: 0, phi: 0) ?<br>&gt; It should all equal with any angles if r == 0.<br></p><p>In an earlier post I wrote:<br></p><p>&gt; And I would do the „standard equality“ upfront even if there is a custom implementation<br>&gt; and if the „standard equality“ says `true`, the custom implementation is not asked.<br>&gt; This would reduce the possibility of false-negatives.<br></p><p>So, if you’d like to override the &quot;standard equality“ you would be able to do this, but with this chain you cannot create false-negatives as easy:<br></p><p>* for heap allocated values (e.g. values bigger than the value buffer in an existential container for protocol types) do a `===`. If `true` return `true`.<br>* for stack allocated values use „standard equality“. If `true` return `true`.<br>* if „standard equality“ return `false`, execute possible custom equality check `==`. Return result.<br></p><p>But If you override `==` in a value type I would warn, because this makes sense in only very rare occasions (perhaps with a @suppress annotation or alike). If you would like to ignore some values (produce „false“-negatives on purpose) add a `transient` keyword or alike. But I wouldn’t allow the latter, but instead offer the developer best practices like value types with indirect storage and copy-on-write for value semantics, in order to omit the values in the `==` implementation of the indirect storage reference type. Last but not least, in a far future, when the indirect storage of value types is done automatically (potentially) and these values are uniquely stored on the heap (in some kind of value pool), you can check for them `===`, too. The latter would **not** be as easy, if we allow custom equality because if we store values uniquely in the value pool and the equality puts values in the same equivalence class that are actually **not** equal from a value types point of view (be it for false-positives and false-negatives), it would put the values into the same slot, since you don’t have an identity check (`===`) on values.<br></p><p>In summary, IMHO using custom equality for value types is dangerous as it puts values that are actually different into the same equivalence class, which make their usage in dictionaries very difficult (especially for false-negatives, which hold some context information not part of the value) and correspondingly the implementation of value pools hard. So, custom equality should be used only in exceptional cases and it should be possible to do at most false-positives (like in the `Polar(r:0, phi: whatever)` example), but for false-negatives (like in the URI example) it should be handled differently, by introducing indirection.<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/dec44666/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 16, 2016 at 01:00:00pm</p></header><div class="content"><p>Dear Susan,<br></p><p>I wrote the former mail in a hurry: the URI example from before is a *false-positive* either and can be handled like the `Polar` example. But the problem with false-negatives are still valid. Example:<br></p><p>```swift<br>func ==(lhs: A, rhs: B) {<br>  if(globalBooleanVarIsDayEven) {<br>    return false<br>  }<br>  // do a normal check<br>}<br>```<br></p><p>This would not be possible, if you check for equality upfront and omitting executing the custom code above if the standard check returns `true` already.<br></p><p>Another **big** problem with using `==` for properties to reference types implementing `Equatable` is race conditions and as Matt Wright pointed out in his talk [Concurrent Programming with GCD in Swift 3][0] on WWDC 2016, there are no harmless cases of concurrency issues. Rationale:<br></p><p>Reference types share state possible with code that runs concurrently in different threads. So if you compare via `==` to value types and use `==` to compare the object(s) of a reference type property this object(s) may change during the check (even if the machine has only one core, if the OS is preemptive). And this may happen even if it is the very same (by identity and `===`) object that is referenced. A (future) automatic value pool for indirect storage with copy-on-write for value semantics would not share this problem, of course, since their storage is only shared for reads and not for writes (the `===` check on this indirect storage would by definition suffice and be much faster than executing the check). This does not hold for properties of references types in that indirect storage.<br></p><p>[0]: http://devstreaming.apple.com/videos/wwdc/2016/720w6g8t9zhd23va0ai/720/720_concurrent_programming_with_gcd_in_swift_3.pdf<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 16, 2016 at 04:00:00pm</p></header><div class="content"><p>In order to prevent false-negatives for reference types, I would like to add a 5th. point to my proposals:<br></p><p>5. Identity (i.e. `===`) should be checked even for reference types upfront and only if it returns `false` the custom `==` function of the developer is executed. This way you cannot implement an equals operator, that says two objects are **not** equal although they are the very same instance.<br></p><p><br>&gt; Am 16.07.2016 um 13:50 schrieb Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I wrote the former mail in a hurry: the URI example from before is a *false-positive* either and can be handled like the `Polar` example. But the problem with false-negatives are still valid. Example:<br>&gt; <br>&gt; ```swift<br>&gt; func ==(lhs: A, rhs: B) {<br>&gt;  if(globalBooleanVarIsDayEven) {<br>&gt;    return false<br>&gt;  }<br>&gt;  // do a normal check<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; This would not be possible, if you check for equality upfront and omitting executing the custom code above if the standard check returns `true` already.<br>&gt; <br>&gt; Another **big** problem with using `==` for properties to reference types implementing `Equatable` is race conditions and as Matt Wright pointed out in his talk [Concurrent Programming with GCD in Swift 3][0] on WWDC 2016, there are no harmless cases of concurrency issues. Rationale:<br>&gt; <br>&gt; Reference types share state possible with code that runs concurrently in different threads. So if you compare via `==` to value types and use `==` to compare the object(s) of a reference type property this object(s) may change during the check (even if the machine has only one core, if the OS is preemptive). And this may happen even if it is the very same (by identity and `===`) object that is referenced. A (future) automatic value pool for indirect storage with copy-on-write for value semantics would not share this problem, of course, since their storage is only shared for reads and not for writes (the `===` check on this indirect storage would by definition suffice and be much faster than executing the check). This does not hold for properties of references types in that indirect storage.<br>&gt; <br>&gt; [0]: http://devstreaming.apple.com/videos/wwdc/2016/720w6g8t9zhd23va0ai/720/720_concurrent_programming_with_gcd_in_swift_3.pdf<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>July 18, 2016 at 12:00:00pm</p></header><div class="content"><p>so, you want to propose default == operator but not forbidding all peoples<br>to custom == operator?<br>Why don&#39;t just adding the following function to std library?<br></p><p><br>public func == &lt;T : Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br></p><p>    var lhs = lhs<br></p><p>    var rhs = rhs<br></p><p>    return memcmp(&amp;lhs, &amp;rhs, sizeof(T.self)) == 0<br></p><p>}<br></p><p><br>Thread safety can&#39;t fixed by std library. Value type only can atomic<br>compared when additional mutex provided.<br></p><p>2016-07-16 19:50 GMT+08:00 Johannes Neubauer &lt;neubauer at kingsware.de&gt;:<br></p><p>&gt; Dear Susan,<br>&gt;<br>&gt; I wrote the former mail in a hurry: the URI example from before is a<br>&gt; *false-positive* either and can be handled like the `Polar` example. But<br>&gt; the problem with false-negatives are still valid. Example:<br>&gt;<br>&gt; ```swift<br>&gt; func ==(lhs: A, rhs: B) {<br>&gt;   if(globalBooleanVarIsDayEven) {<br>&gt;     return false<br>&gt;   }<br>&gt;   // do a normal check<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; This would not be possible, if you check for equality upfront and omitting<br>&gt; executing the custom code above if the standard check returns `true`<br>&gt; already.<br>&gt;<br>&gt; Another **big** problem with using `==` for properties to reference types<br>&gt; implementing `Equatable` is race conditions and as Matt Wright pointed out<br>&gt; in his talk [Concurrent Programming with GCD in Swift 3][0] on WWDC 2016,<br>&gt; there are no harmless cases of concurrency issues. Rationale:<br>&gt;<br>&gt; Reference types share state possible with code that runs concurrently in<br>&gt; different threads. So if you compare via `==` to value types and use `==`<br>&gt; to compare the object(s) of a reference type property this object(s) may<br>&gt; change during the check (even if the machine has only one core, if the OS<br>&gt; is preemptive). And this may happen even if it is the very same (by<br>&gt; identity and `===`) object that is referenced. A (future) automatic value<br>&gt; pool for indirect storage with copy-on-write for value semantics would not<br>&gt; share this problem, of course, since their storage is only shared for reads<br>&gt; and not for writes (the `===` check on this indirect storage would by<br>&gt; definition suffice and be much faster than executing the check). This does<br>&gt; not hold for properties of references types in that indirect storage.<br>&gt;<br>&gt; [0]:<br>&gt; http://devstreaming.apple.com/videos/wwdc/2016/720w6g8t9zhd23va0ai/720/720_concurrent_programming_with_gcd_in_swift_3.pdf<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/2b423744/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 18, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Am 18.07.2016 um 06:47 schrieb Susan Cheng &lt;susan.doggie at gmail.com&gt;:<br>&gt; <br>&gt; so, you want to propose default == operator but not forbidding all peoples to custom == operator?<br>&gt; Why don&#39;t just adding the following function to std library?<br>&gt; <br>&gt; public func == &lt;T : Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;     var lhs = lhs<br>&gt;     var rhs = rhs<br>&gt;     return memcmp(&amp;lhs, &amp;rhs, sizeof(T.self)) == 0<br>&gt; }<br></p><p>This does not work, because method parameters are statically dispatched. This function will never be executed for any type, that has a custom equality implementation. So this would not enforce this check upfront. You would need to copy this code to every custom implementation (which can be forgotten). Or you have to implement it like this<br></p><p>```swift<br>public func isSame(lhs: Any, rhs: Any) -&gt; Bool {<br>  // like above in your code<br>}<br></p><p>public func ==(lhs: MyType, rhs: MyType) -&gt; Bool {<br>  if isSame(lhs, rhs: rhs) {<br>    return true<br>  }<br>  // do custom behavior<br>}<br>```<br></p><p>&gt; Thread safety can&#39;t fixed by std library. Value type only can atomic compared when additional mutex provided.<br></p><p>Value types are either on the stack or they are **copied** to the heap (for protocol types with large value types). So, you don’t have any thread safety issues (as they are copied before they are changed in the new thread) as long as you don’t do (or check) anything on a property of a reference type, because the latter has shared **state**.<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/753bfe97/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>July 20, 2016 at 09:00:00am</p></header><div class="content"><p>But I don&#39;t want swift force using default equal comparator before my<br>implementation when I knew it was redundant that everything checking twice.<br></p><p>I have wrote lots of structure type with cache object for lazy evaluation.<br>All of them dose not need to compare the cache object.<br></p><p>Johannes Neubauer &lt;neubauer at kingsware.de&gt; 於 2016年7月18日星期一 寫道：<br></p><p>&gt;<br>&gt; &gt; Am 18.07.2016 um 06:47 schrieb Susan Cheng &lt;susan.doggie at gmail.com<br>&gt; &lt;javascript:;&gt;&gt;:<br>&gt; &gt;<br>&gt; &gt; so, you want to propose default == operator but not forbidding all<br>&gt; peoples to custom == operator?<br>&gt; &gt; Why don&#39;t just adding the following function to std library?<br>&gt; &gt;<br>&gt; &gt; public func == &lt;T : Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt; &gt;     var lhs = lhs<br>&gt; &gt;     var rhs = rhs<br>&gt; &gt;     return memcmp(&amp;lhs, &amp;rhs, sizeof(T.self)) == 0<br>&gt; &gt; }<br>&gt;<br>&gt; This does not work, because method parameters are statically dispatched.<br>&gt; This function will never be executed for any type, that has a custom<br>&gt; equality implementation. So this would not enforce this check upfront. You<br>&gt; would need to copy this code to every custom implementation (which can be<br>&gt; forgotten). Or you have to implement it like this<br>&gt;<br>&gt; ```swift<br>&gt; public func isSame(lhs: Any, rhs: Any) -&gt; Bool {<br>&gt;   // like above in your code<br>&gt; }<br>&gt;<br>&gt; public func ==(lhs: MyType, rhs: MyType) -&gt; Bool {<br>&gt;   if isSame(lhs, rhs: rhs) {<br>&gt;     return true<br>&gt;   }<br>&gt;   // do custom behavior<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; &gt; Thread safety can&#39;t fixed by std library. Value type only can atomic<br>&gt; compared when additional mutex provided.<br>&gt;<br>&gt; Value types are either on the stack or they are **copied** to the heap<br>&gt; (for protocol types with large value types). So, you don’t have any thread<br>&gt; safety issues (as they are copied before they are changed in the new<br>&gt; thread) as long as you don’t do (or check) anything on a property of a<br>&gt; reference type, because the latter has shared **state**.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/adcc0a07/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>July 20, 2016 at 08:00:00pm</p></header><div class="content"><p>I forgot to reply, a shared value type can capture by multiple closures.<br></p><p>func twoThreads() -&gt; (Thread, Thread) {<br>    var shared_int = 0<br>    return (Thread { shared_int = 1 }, Thread { shared_int = 2 })<br>}<br></p><p>Johannes Neubauer &lt;neubauer at kingsware.de&gt; 於 2016年7月18日星期一 寫道：<br></p><p>&gt;<br>&gt; &gt; Am 18.07.2016 um 06:47 schrieb Susan Cheng &lt;susan.doggie at gmail.com<br>&gt; &lt;javascript:;&gt;&gt;:<br>&gt; &gt;<br>&gt; &gt; so, you want to propose default == operator but not forbidding all<br>&gt; peoples to custom == operator?<br>&gt; &gt; Why don&#39;t just adding the following function to std library?<br>&gt; &gt;<br>&gt; &gt; public func == &lt;T : Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt; &gt;     var lhs = lhs<br>&gt; &gt;     var rhs = rhs<br>&gt; &gt;     return memcmp(&amp;lhs, &amp;rhs, sizeof(T.self)) == 0<br>&gt; &gt; }<br>&gt;<br>&gt; This does not work, because method parameters are statically dispatched.<br>&gt; This function will never be executed for any type, that has a custom<br>&gt; equality implementation. So this would not enforce this check upfront. You<br>&gt; would need to copy this code to every custom implementation (which can be<br>&gt; forgotten). Or you have to implement it like this<br>&gt;<br>&gt; ```swift<br>&gt; public func isSame(lhs: Any, rhs: Any) -&gt; Bool {<br>&gt;   // like above in your code<br>&gt; }<br>&gt;<br>&gt; public func ==(lhs: MyType, rhs: MyType) -&gt; Bool {<br>&gt;   if isSame(lhs, rhs: rhs) {<br>&gt;     return true<br>&gt;   }<br>&gt;   // do custom behavior<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; &gt; Thread safety can&#39;t fixed by std library. Value type only can atomic<br>&gt; compared when additional mutex provided.<br>&gt;<br>&gt; Value types are either on the stack or they are **copied** to the heap<br>&gt; (for protocol types with large value types). So, you don’t have any thread<br>&gt; safety issues (as they are copied before they are changed in the new<br>&gt; thread) as long as you don’t do (or check) anything on a property of a<br>&gt; reference type, because the latter has shared **state**.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/3799343e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 20, 2016 at 03:00:00pm</p></header><div class="content"><p>Dear Susan,<br></p><p>&gt; Am 20.07.2016 um 14:14 schrieb Susan Cheng &lt;susan.doggie at gmail.com&gt;:<br>&gt; <br>&gt; I forgot to reply, a shared value type can capture by multiple closures.<br>&gt; <br>&gt; func twoThreads() -&gt; (Thread, Thread) {<br>&gt;     var shared_int = 0<br>&gt;     return (Thread { shared_int = 1 }, Thread { shared_int = 2 })<br>&gt; }<br></p><p>You are not sharing the value type, but the reference to it (so you share the surrounding function context *by reference* or more precisely via *call by sharing*). I use an array as example (and synchronous dispatch queues, to get a reliable answer), because its value is less „atomic“: <br></p><p>```swift<br>var shared_array = [Int]()<br>var not_shared_array = shared_array<br>dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {<br>    var not_shared_array = shared_array<br>    not_shared_array.append(1)<br>    print(&quot;not shared 1: \(not_shared_array)&quot;)<br>    shared_array.append(2)<br>    print(&quot;shared 2: \(shared_array)&quot;)<br>}<br></p><p>dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {<br>    var not_shared_array = shared_array<br>    not_shared_array.append(3)<br>    print(&quot;not shared 3: \(not_shared_array)&quot;)<br>    shared_array.append(4)<br>    print(&quot;shared 4: \(shared_array)&quot;)<br>}<br></p><p>not_shared_array.append(5)<br>shared_array.append(6)<br>print(&quot;not shared: \(not_shared_array)&quot;)<br>print(&quot;shared: \(shared_array)“)<br></p><p>// prints:<br>// not shared 1: [1]<br>// shared 2: [2]<br>// not shared 3: [2, 3]<br>// shared 4: [2, 4]<br>// not shared: [5]<br>// shared: [2, 4, 6]<br>```<br></p><p>You could do this without closures using a reference type as a wrapper, but you still do not share the value instance but the wrapper:<br></p><p>```swift<br>class Wrapper {<br>    var shared_array = [Int]()<br>}<br></p><p>func appendNumber(w: Wrapper, n: Int) {<br>    w.shared_array.append(n)<br>}<br></p><p>func appendNumber(var v: [Int], n: Int) {<br>    v.append(n)<br>}<br></p><p>let wi = Wrapper(),<br>    vi = [Int]()<br></p><p>appendNumber(wi, n: 1)<br>appendNumber(vi, n: 2)<br>print(wi.shared_array)<br>print(vi)<br></p><p>// prints:<br>// [1]<br>// []<br>```<br></p><p>All the best<br>Johannes<br></p><p>&gt; <br>&gt; Johannes Neubauer &lt;neubauer at kingsware.de&gt; 於 2016年7月18日星期一 寫道：<br>&gt; <br>&gt; &gt; Am 18.07.2016 um 06:47 schrieb Susan Cheng &lt;susan.doggie at gmail.com&gt;:<br>&gt; &gt;<br>&gt; &gt; so, you want to propose default == operator but not forbidding all peoples to custom == operator?<br>&gt; &gt; Why don&#39;t just adding the following function to std library?<br>&gt; &gt;<br>&gt; &gt; public func == &lt;T : Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt; &gt;     var lhs = lhs<br>&gt; &gt;     var rhs = rhs<br>&gt; &gt;     return memcmp(&amp;lhs, &amp;rhs, sizeof(T.self)) == 0<br>&gt; &gt; }<br>&gt; <br>&gt; This does not work, because method parameters are statically dispatched. This function will never be executed for any type, that has a custom equality implementation. So this would not enforce this check upfront. You would need to copy this code to every custom implementation (which can be forgotten). Or you have to implement it like this<br>&gt; <br>&gt; ```swift<br>&gt; public func isSame(lhs: Any, rhs: Any) -&gt; Bool {<br>&gt;   // like above in your code<br>&gt; }<br>&gt; <br>&gt; public func ==(lhs: MyType, rhs: MyType) -&gt; Bool {<br>&gt;   if isSame(lhs, rhs: rhs) {<br>&gt;     return true<br>&gt;   }<br>&gt;   // do custom behavior<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; &gt; Thread safety can&#39;t fixed by std library. Value type only can atomic compared when additional mutex provided.<br>&gt; <br>&gt; Value types are either on the stack or they are **copied** to the heap (for protocol types with large value types). So, you don’t have any thread safety issues (as they are copied before they are changed in the new thread) as long as you don’t do (or check) anything on a property of a reference type, because the latter has shared **state**.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>July 21, 2016 at 08:00:00am</p></header><div class="content"><p>I know and I want to point out that you said value type don&#39;t have any<br>thread safety issues is wrong.<br></p><p>Johannes Neubauer &lt;neubauer at kingsware.de&gt; 於 2016年7月20日星期三 寫道：<br></p><p>&gt; Dear Susan,<br>&gt;<br>&gt; &gt; Am 20.07.2016 um 14:14 schrieb Susan Cheng &lt;susan.doggie at gmail.com<br>&gt; &lt;javascript:;&gt;&gt;:<br>&gt; &gt;<br>&gt; &gt; I forgot to reply, a shared value type can capture by multiple closures.<br>&gt; &gt;<br>&gt; &gt; func twoThreads() -&gt; (Thread, Thread) {<br>&gt; &gt;     var shared_int = 0<br>&gt; &gt;     return (Thread { shared_int = 1 }, Thread { shared_int = 2 })<br>&gt; &gt; }<br>&gt;<br>&gt; You are not sharing the value type, but the reference to it (so you share<br>&gt; the surrounding function context *by reference* or more precisely via *call<br>&gt; by sharing*). I use an array as example (and synchronous dispatch queues,<br>&gt; to get a reliable answer), because its value is less „atomic“:<br>&gt;<br>&gt; ```swift<br>&gt; var shared_array = [Int]()<br>&gt; var not_shared_array = shared_array<br>&gt; dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<br>&gt; 0)) {<br>&gt;     var not_shared_array = shared_array<br>&gt;     not_shared_array.append(1)<br>&gt;     print(&quot;not shared 1: \(not_shared_array)&quot;)<br>&gt;     shared_array.append(2)<br>&gt;     print(&quot;shared 2: \(shared_array)&quot;)<br>&gt; }<br>&gt;<br>&gt; dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<br>&gt; 0)) {<br>&gt;     var not_shared_array = shared_array<br>&gt;     not_shared_array.append(3)<br>&gt;     print(&quot;not shared 3: \(not_shared_array)&quot;)<br>&gt;     shared_array.append(4)<br>&gt;     print(&quot;shared 4: \(shared_array)&quot;)<br>&gt; }<br>&gt;<br>&gt; not_shared_array.append(5)<br>&gt; shared_array.append(6)<br>&gt; print(&quot;not shared: \(not_shared_array)&quot;)<br>&gt; print(&quot;shared: \(shared_array)“)<br>&gt;<br>&gt; // prints:<br>&gt; // not shared 1: [1]<br>&gt; // shared 2: [2]<br>&gt; // not shared 3: [2, 3]<br>&gt; // shared 4: [2, 4]<br>&gt; // not shared: [5]<br>&gt; // shared: [2, 4, 6]<br>&gt; ```<br>&gt;<br>&gt; You could do this without closures using a reference type as a wrapper,<br>&gt; but you still do not share the value instance but the wrapper:<br>&gt;<br>&gt; ```swift<br>&gt; class Wrapper {<br>&gt;     var shared_array = [Int]()<br>&gt; }<br>&gt;<br>&gt; func appendNumber(w: Wrapper, n: Int) {<br>&gt;     w.shared_array.append(n)<br>&gt; }<br>&gt;<br>&gt; func appendNumber(var v: [Int], n: Int) {<br>&gt;     v.append(n)<br>&gt; }<br>&gt;<br>&gt; let wi = Wrapper(),<br>&gt;     vi = [Int]()<br>&gt;<br>&gt; appendNumber(wi, n: 1)<br>&gt; appendNumber(vi, n: 2)<br>&gt; print(wi.shared_array)<br>&gt; print(vi)<br>&gt;<br>&gt; // prints:<br>&gt; // [1]<br>&gt; // []<br>&gt; ```<br>&gt;<br>&gt; All the best<br>&gt; Johannes<br>&gt;<br>&gt; &gt;<br>&gt; &gt; Johannes Neubauer &lt;neubauer at kingsware.de &lt;javascript:;&gt;&gt; 於<br>&gt; 2016年7月18日星期一 寫道：<br>&gt; &gt;<br>&gt; &gt; &gt; Am 18.07.2016 um 06:47 schrieb Susan Cheng &lt;susan.doggie at gmail.com<br>&gt; &lt;javascript:;&gt;&gt;:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; so, you want to propose default == operator but not forbidding all<br>&gt; peoples to custom == operator?<br>&gt; &gt; &gt; Why don&#39;t just adding the following function to std library?<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; public func == &lt;T : Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt; &gt; &gt;     var lhs = lhs<br>&gt; &gt; &gt;     var rhs = rhs<br>&gt; &gt; &gt;     return memcmp(&amp;lhs, &amp;rhs, sizeof(T.self)) == 0<br>&gt; &gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; This does not work, because method parameters are statically dispatched.<br>&gt; This function will never be executed for any type, that has a custom<br>&gt; equality implementation. So this would not enforce this check upfront. You<br>&gt; would need to copy this code to every custom implementation (which can be<br>&gt; forgotten). Or you have to implement it like this<br>&gt; &gt;<br>&gt; &gt; ```swift<br>&gt; &gt; public func isSame(lhs: Any, rhs: Any) -&gt; Bool {<br>&gt; &gt;   // like above in your code<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; public func ==(lhs: MyType, rhs: MyType) -&gt; Bool {<br>&gt; &gt;   if isSame(lhs, rhs: rhs) {<br>&gt; &gt;     return true<br>&gt; &gt;   }<br>&gt; &gt;   // do custom behavior<br>&gt; &gt; }<br>&gt; &gt; ```<br>&gt; &gt;<br>&gt; &gt; &gt; Thread safety can&#39;t fixed by std library. Value type only can atomic<br>&gt; compared when additional mutex provided.<br>&gt; &gt;<br>&gt; &gt; Value types are either on the stack or they are **copied** to the heap<br>&gt; (for protocol types with large value types). So, you don’t have any thread<br>&gt; safety issues (as they are copied before they are changed in the new<br>&gt; thread) as long as you don’t do (or check) anything on a property of a<br>&gt; reference type, because the latter has shared **state**.<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/aaab48c3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 21, 2016 at 10:00:00am</p></header><div class="content"><p>Dear Susan,<br></p><p>&gt; Am 21.07.2016 um 02:19 schrieb Susan Cheng &lt;susan.doggie at gmail.com&gt;:<br>&gt; <br>&gt; I know and I want to point out that you said value type don&#39;t have any thread safety issues is wrong.<br></p><p>I did not mean that, sorry. I meant: calling == on reference types in the standard implementation of == in value types, creates new risks for race conditions and this is why this would be a bad decision. Value types themselves introduce less thread safety issues than reference types, and changes to the language should IMO not make this position weaker.<br></p><p>Anyway, closures are much more fragile than currying (or partial application) is [0] (the article is about Java 8, but the underlying issues hold for any language). So, I am a bit disappointed that Swift removed currying instead of making its syntax better (and more flexible) and allow only closures without variable capturing (in order to have fully partially applied functions [1] or in objective-c-terms a *parameterless block*).<br></p><p>All the best<br>Johannes<br></p><p>[0]: https://dzone.com/articles/whats-wrong-java-8-currying-vs<br>[1]: https://www.kingsware.de/2014/08/27/apple-swift-emulate-partial-fully-applied-functions/<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/3537d936/attachment.sig&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 15, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 15.07.2016 um 18:12 schrieb Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; Am 15.07.2016 um 15:19 schrieb Shawn Erickson &lt;shawnce at gmail.com&gt;:<br>&gt;&gt; <br>&gt;&gt; Additional two &quot;things&quot; maybe considered equal in the chosen problem domain despite their identity (memory location, etc.) being different. Having the ability to supply custom hash and equality for types can be a useful tool in a developers toolbox. For example two pathways of code may create what is actually the same thing (say a reference to the same file on disk) then want to work with stdlib set and/or dictionary with the equivalent things being resolved correctly, etc.<br>&gt;&gt; <br>&gt;&gt; To remove custom equality will limit some designs and to force identity based equality with present similar problems on the other end of the spectrum.<br>&gt; <br>&gt; It is only for value types. For reference types, which have an identity, you are right, but it doesn’t hold for values.<br></p><p>Sorry, this can be misunderstood. I meant: I would remove custom equality only for value types (for the reasons I meant above). The fixed implementation of checking equality for value types would check equality `==` of all referenced structs and reference types implementing `Equatable`. If a reference type does not implement `Equatable` `===` will be used.<br></p><p>If the shiny days will come, where indirect storage is used for value types with at least two properties with reference types (or other value types with indirect storage) **automatically**, with the guarantee that these storages are uniquely stored in a given value table/pool, then `===` can be used for that too (e.g. for the storage of Arrays or Strings, which would then be automatically generated either!).<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160715/6bf34b36/attachment.sig&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 17, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Jul 14, 2016, at 1:36 PM, Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 1. Custom implementation of equals operator `==` for value types should be forbidden. Rationale: Why has it been added in the first place? For omitting some values from the equals test?<br></p><p>This limitation would prevent you from even implementing IEEE floating-point semantics (+0.0 == -0.0, while NaN != NaN; neither would be allowed by this rule). It would similarly prevent you from implementing even moderately <br></p><p>&gt; Properties pointing at reference types should be tested with `===`.<br></p><p>This rule in particular would also prevent you from implementing Equatable semantics for most of the copy-on-write containers (String, Array, Set, Dictionary), which all use an internal reference to a memory buffer. And several of Foundation&#39;s struct wrappers, like the `Data` type that wraps `NSData`. And any value type of your own which contains a lot of internal data and which, after a lot of testing and benchmarking, you determine would be more efficiently implemented as a value type wrapping a reference type with copy-on-write semantics. And who knows what else.<br></p><p>Ultimately, it boils down to this:<br></p><p>&gt; If a value instance is equal to another, but the value may differ... this is odd semantics.<br></p><p>Equality is how we define whether two instances differ: If `==` returns `true`, then they don&#39;t differ. Now, there are some important commonsense rules about this—two `==` instances should have virtually identical behavior—but you can&#39;t just ignore the widespread need for this feature. If Swift didn&#39;t offer `Equatable` overloading, we would have to invent it ourselves—most likely with some sort of half-baked workaround that would cause confusion about whether you ought to use &quot;pure&quot; equality or &quot;smart&quot; equality in any given situation. Think of the `==` vs. `===` mess in JavaScript and you&#39;ll get an idea of what I mean.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 17, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Am 17.07.2016 um 15:11 schrieb Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br>&gt; <br>&gt;&gt; On Jul 14, 2016, at 1:36 PM, Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 1. Custom implementation of equals operator `==` for value types should be forbidden. Rationale: Why has it been added in the first place? For omitting some values from the equals test?<br>&gt; <br>&gt; This limitation would prevent you from even implementing IEEE floating-point semantics (+0.0 == -0.0, while NaN != NaN; neither would be allowed by this rule). It would similarly prevent you from implementing even moderately <br></p><p>Didn’t you follow the correspondence of these proposals? There are corner cases (like this one above), but there should be a default equality check and you shouldn’t be able to decide, that something is not equal, which the default equality check says that it is equal. In addition, you mention basic types of the swift language. Of course their have to be some axioms in the language which have to be created by the language designers. Floating-point semantics fall exactly into this category.<br></p><p>&gt;&gt; Properties pointing at reference types should be tested with `===`.<br>&gt; <br>&gt; This rule in particular would also prevent you from implementing Equatable semantics for most of the copy-on-write containers (String, Array, Set, Dictionary), which all use an internal reference to a memory buffer. And several of Foundation&#39;s struct wrappers, like the `Data` type that wraps `NSData`. And any value type of your own which contains a lot of internal data and which, after a lot of testing and benchmarking, you determine would be more efficiently implemented as a value type wrapping a reference type with copy-on-write semantics. And who knows what else.<br></p><p>Please, you should really follow the discussion here. I already lined out all these cases. I wrote this before Arnold from apple told me that some blog posts out there are wrong about how value types work internally. This is something that can be done in the future, as soon as swift has something like automatic indirect storage with a unique value pool and with copy-on-write semantics for „large“ value types.<br></p><p>&gt; Ultimately, it boils down to this:<br>&gt; <br>&gt;&gt; If a value instance is equal to another, but the value may differ... this is odd semantics.<br>&gt; <br>&gt; Equality is how we define whether two instances differ: If `==` returns `true`, then they don&#39;t differ. Now, there are some important commonsense rules about this—two `==` instances should have virtually identical behavior—but you can&#39;t just ignore the widespread need for this feature. If Swift didn&#39;t offer `Equatable` overloading, we would have to invent it ourselves—most likely with some sort of half-baked workaround that would cause confusion about whether you ought to use &quot;pure&quot; equality or &quot;smart&quot; equality in any given situation. Think of the `==` vs. `===` mess in JavaScript and you&#39;ll get an idea of what I mean.<br></p><p>Really, please read especially my last mails. My proposal does not prevent you from doing this differentiation directly in the language, but prevents you from doing some nasty bugs.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>July 17, 2016 at 06:00:00pm</p></header><div class="content"><p>Your initial rationale no longer makes sense with your suggested solution. If the dumb comparison returns false, people can still introduce side effects in the comparison method, except that now it&#39;s even harder to find out because all of my equality tests have been rewritten as &quot;memcmp(a, b) || ==(a, b)&quot;.<br></p><p>What are you trying to protect me from?<br></p><p>Félix<br></p><p>&gt; Le 17 juil. 2016 à 06:30:42, Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; Am 17.07.2016 um 15:11 schrieb Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 14, 2016, at 1:36 PM, Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Custom implementation of equals operator `==` for value types should be forbidden. Rationale: Why has it been added in the first place? For omitting some values from the equals test?<br>&gt;&gt; <br>&gt;&gt; This limitation would prevent you from even implementing IEEE floating-point semantics (+0.0 == -0.0, while NaN != NaN; neither would be allowed by this rule). It would similarly prevent you from implementing even moderately <br>&gt; <br>&gt; Didn’t you follow the correspondence of these proposals? There are corner cases (like this one above), but there should be a default equality check and you shouldn’t be able to decide, that something is not equal, which the default equality check says that it is equal. In addition, you mention basic types of the swift language. Of course their have to be some axioms in the language which have to be created by the language designers. Floating-point semantics fall exactly into this category.<br>&gt; <br>&gt;&gt;&gt; Properties pointing at reference types should be tested with `===`.<br>&gt;&gt; <br>&gt;&gt; This rule in particular would also prevent you from implementing Equatable semantics for most of the copy-on-write containers (String, Array, Set, Dictionary), which all use an internal reference to a memory buffer. And several of Foundation&#39;s struct wrappers, like the `Data` type that wraps `NSData`. And any value type of your own which contains a lot of internal data and which, after a lot of testing and benchmarking, you determine would be more efficiently implemented as a value type wrapping a reference type with copy-on-write semantics. And who knows what else.<br>&gt; <br>&gt; Please, you should really follow the discussion here. I already lined out all these cases. I wrote this before Arnold from apple told me that some blog posts out there are wrong about how value types work internally. This is something that can be done in the future, as soon as swift has something like automatic indirect storage with a unique value pool and with copy-on-write semantics for „large“ value types.<br>&gt; <br>&gt;&gt; Ultimately, it boils down to this:<br>&gt;&gt; <br>&gt;&gt;&gt; If a value instance is equal to another, but the value may differ... this is odd semantics.<br>&gt;&gt; <br>&gt;&gt; Equality is how we define whether two instances differ: If `==` returns `true`, then they don&#39;t differ. Now, there are some important commonsense rules about this—two `==` instances should have virtually identical behavior—but you can&#39;t just ignore the widespread need for this feature. If Swift didn&#39;t offer `Equatable` overloading, we would have to invent it ourselves—most likely with some sort of half-baked workaround that would cause confusion about whether you ought to use &quot;pure&quot; equality or &quot;smart&quot; equality in any given situation. Think of the `==` vs. `===` mess in JavaScript and you&#39;ll get an idea of what I mean.<br>&gt; <br>&gt; Really, please read especially my last mails. My proposal does not prevent you from doing this differentiation directly in the language, but prevents you from doing some nasty bugs.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160717/27de6d1c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 18, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Am 18.07.2016 um 03:51 schrieb Félix Cloutier &lt;felixcca at yahoo.ca&gt;:<br>&gt; <br>&gt; Your initial rationale no longer makes sense with your suggested solution. If the dumb comparison returns false, people can still introduce side effects in the comparison method, except that now it&#39;s even harder to find out because all of my equality tests have been rewritten as &quot;memcmp(a, b) || ==(a, b)“.<br></p><p>No its `memcmp(a, b) &amp;&amp; ==(a,b)`, since if the „standard equality“ says `true` there is no short-circuit, but the custom implementation has to be `true` either! It is just a pre-condition.<br></p><p>&gt; What are you trying to protect me from?<br></p><p>1. You cannot say something is unequal although the system says it is equal<br>2. You do not have to implement equality for value types, only if you really need custom behavior (so you do not write boiler-plate code, which is error prone), so side effects will be less common<br>3. With unique indirect storage (and copy-on-write) you would be able use `==` for large values, because these values are only shared for reads not for writes  (future, not yet available in swift), so no race conditions<br>4. With `dispatch` in operator-methods (or any other) as well as a `default` clause for reference types, so that equality of mixed-types just result in `false`, so that this is not possible anymore (see excerpt of discussion):<br></p><p>&gt; Am 16.07.2016 um 15:18 schrieb Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; This is not true for reference types. Consider the following **bad** (but compiling code):<br>&gt; <br>&gt; ```swift<br>&gt; class A: Equatable {}<br>&gt; <br>&gt; class Aa: A {<br>&gt;    let a: Int<br>&gt; <br>&gt;    init(a: Int) {<br>&gt;        self.a = a<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; func ==(lhs: A, rhs: A) -&gt; Bool {<br>&gt;    return lhs === rhs<br>&gt; }<br>&gt; <br>&gt; func ==(lhs: Aa, rhs: Aa) -&gt; Bool {<br>&gt;    return lhs.a == rhs.a<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; Now let us use this:<br>&gt; <br>&gt; ```swift<br>&gt; let a = A()<br>&gt; let a2 = A()<br>&gt; let aa = Aa(a: 0)<br>&gt; let aa2 = Aa(a: 1)<br>&gt; let aa3 = Aa(a: 1)<br>&gt; <br>&gt; // prints `true`<br>&gt; print(a == a)<br>&gt; <br>&gt; // prints `false`<br>&gt; print(a == a2)<br>&gt; <br>&gt; // prints `false`<br>&gt; print(a == aa)<br>&gt; <br>&gt; // prints `false`<br>&gt; print(a == aa3)<br>&gt; <br>&gt; // prints `false`<br>&gt; print(aa == aa2)<br>&gt; <br>&gt; // prints `true` because it compares the `a: Int` values.<br>&gt; print(aa2 == aa3)<br>&gt; <br>&gt; // now mixed-type comparison (returns `false`)<br>&gt; print(a == aa2)<br>&gt; ```<br>&gt; <br>&gt; Hence, you can do mixed-type equality checks in Swift. Even worse is, you can do this:<br>&gt; <br>&gt; ```swift<br>&gt; let aa2AsA: A = aa2,<br>&gt;    aa3AsA: A = aa3<br>&gt; <br>&gt; // prints `true` because it compares the `a: Int` values.<br>&gt; print(aa2 == aa3)<br>&gt; <br>&gt; // prints `false`, because the equals method of `A` is used<br>&gt; print(aa2AsA == aa3AsA)<br>&gt; ```<br>&gt; <br>&gt; Just by assigning an object to a variable that is typed differently the result is completely different. This is because method parameters are dispatched statically. This is fast, but results in really unintended results, you can do a **lot** of things breaking the contract of `==` with that. This is why I wanted to add a `default` clause (in *3.* of my original proposal) for such methods involving two references to `Self`. Further on, I wanted to add the keyword `dispatch` for method (and operator) parameters, where dispatching is necessary (see *2.* of my original proposal).<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 18, 2016 at 12:00:00pm</p></header><div class="content"><p>Dear  Félix,<br></p><p>As a small follow-up, because you asked what I am protecting you from. Dictionaries and Sets, for instance, will work only, if equality and hash value are computed contract conform. As soon as you let (unintendedly) differing values collapse or same values break up, you will have unintended behavior. This is crucial and I think every developer should be thankful for any help he gets here from a language. If (in the future) the swift runtime will create value pools for you, and you have a wrong implementation of equality, the complete system will just misbehave. **That** will be bugs hard to find.<br></p><p>All the best<br>Johannes<br></p><p>&gt; Am 18.07.2016 um 11:50 schrieb Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; Am 18.07.2016 um 03:51 schrieb Félix Cloutier &lt;felixcca at yahoo.ca&gt;:<br>&gt;&gt; <br>&gt;&gt; Your initial rationale no longer makes sense with your suggested solution. If the dumb comparison returns false, people can still introduce side effects in the comparison method, except that now it&#39;s even harder to find out because all of my equality tests have been rewritten as &quot;memcmp(a, b) || ==(a, b)“.<br>&gt; <br>&gt; No its `memcmp(a, b) &amp;&amp; ==(a,b)`, since if the „standard equality“ says `true` there is no short-circuit, but the custom implementation has to be `true` either! It is just a pre-condition.<br>&gt; <br>&gt;&gt; What are you trying to protect me from?<br>&gt; <br>&gt; 1. You cannot say something is unequal although the system says it is equal<br>&gt; 2. You do not have to implement equality for value types, only if you really need custom behavior (so you do not write boiler-plate code, which is error prone), so side effects will be less common<br>&gt; 3. With unique indirect storage (and copy-on-write) you would be able use `==` for large values, because these values are only shared for reads not for writes  (future, not yet available in swift), so no race conditions<br>&gt; 4. With `dispatch` in operator-methods (or any other) as well as a `default` clause for reference types, so that equality of mixed-types just result in `false`, so that this is not possible anymore (see excerpt of discussion):<br>&gt; <br>&gt;&gt; Am 16.07.2016 um 15:18 schrieb Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; This is not true for reference types. Consider the following **bad** (but compiling code):<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; class A: Equatable {}<br>&gt;&gt; <br>&gt;&gt; class Aa: A {<br>&gt;&gt;   let a: Int<br>&gt;&gt; <br>&gt;&gt;   init(a: Int) {<br>&gt;&gt;       self.a = a<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func ==(lhs: A, rhs: A) -&gt; Bool {<br>&gt;&gt;   return lhs === rhs<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func ==(lhs: Aa, rhs: Aa) -&gt; Bool {<br>&gt;&gt;   return lhs.a == rhs.a<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Now let us use this:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; let a = A()<br>&gt;&gt; let a2 = A()<br>&gt;&gt; let aa = Aa(a: 0)<br>&gt;&gt; let aa2 = Aa(a: 1)<br>&gt;&gt; let aa3 = Aa(a: 1)<br>&gt;&gt; <br>&gt;&gt; // prints `true`<br>&gt;&gt; print(a == a)<br>&gt;&gt; <br>&gt;&gt; // prints `false`<br>&gt;&gt; print(a == a2)<br>&gt;&gt; <br>&gt;&gt; // prints `false`<br>&gt;&gt; print(a == aa)<br>&gt;&gt; <br>&gt;&gt; // prints `false`<br>&gt;&gt; print(a == aa3)<br>&gt;&gt; <br>&gt;&gt; // prints `false`<br>&gt;&gt; print(aa == aa2)<br>&gt;&gt; <br>&gt;&gt; // prints `true` because it compares the `a: Int` values.<br>&gt;&gt; print(aa2 == aa3)<br>&gt;&gt; <br>&gt;&gt; // now mixed-type comparison (returns `false`)<br>&gt;&gt; print(a == aa2)<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Hence, you can do mixed-type equality checks in Swift. Even worse is, you can do this:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; let aa2AsA: A = aa2,<br>&gt;&gt;   aa3AsA: A = aa3<br>&gt;&gt; <br>&gt;&gt; // prints `true` because it compares the `a: Int` values.<br>&gt;&gt; print(aa2 == aa3)<br>&gt;&gt; <br>&gt;&gt; // prints `false`, because the equals method of `A` is used<br>&gt;&gt; print(aa2AsA == aa3AsA)<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Just by assigning an object to a variable that is typed differently the result is completely different. This is because method parameters are dispatched statically. This is fast, but results in really unintended results, you can do a **lot** of things breaking the contract of `==` with that. This is why I wanted to add a `default` clause (in *3.* of my original proposal) for such methods involving two references to `Self`. Further on, I wanted to add the keyword `dispatch` for method (and operator) parameters, where dispatching is necessary (see *2.* of my original proposal).<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 18, 2016 at 12:00:00pm</p></header><div class="content"><p>See below...<br></p><p>&gt; Am 18.07.2016 um 12:08 schrieb Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Dear  Félix,<br>&gt; <br>&gt; As a small follow-up, because you asked what I am protecting you from. Dictionaries and Sets, for instance, will work only, if equality and hash value are computed contract conform. As soon as you let (unintendedly) differing values collapse or same values break up, you will have unintended behavior. This is crucial and I think every developer should be thankful for any help he gets here from a language. If (in the future) the swift runtime will create value pools for you, and you have a wrong implementation of equality, the complete system will just misbehave. **That** will be bugs hard to find.<br>&gt; <br>&gt; All the best<br>&gt; Johannes<br>&gt; <br>&gt;&gt; Am 18.07.2016 um 11:50 schrieb Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 18.07.2016 um 03:51 schrieb Félix Cloutier &lt;felixcca at yahoo.ca&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Your initial rationale no longer makes sense with your suggested solution. If the dumb comparison returns false, people can still introduce side effects in the comparison method, except that now it&#39;s even harder to find out because all of my equality tests have been rewritten as &quot;memcmp(a, b) || ==(a, b)“.<br>&gt;&gt; <br>&gt;&gt; No its `memcmp(a, b) &amp;&amp; ==(a,b)`, since if the „standard equality“ says `true` there is no short-circuit, but the custom implementation has to be `true` either! It is just a pre-condition.<br></p><p>Sorry, wrote this in a hurry. It is `||` of course. But still the rest holds.<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; What are you trying to protect me from?<br>&gt;&gt; <br>&gt;&gt; 1. You cannot say something is unequal although the system says it is equal<br>&gt;&gt; 2. You do not have to implement equality for value types, only if you really need custom behavior (so you do not write boiler-plate code, which is error prone), so side effects will be less common<br>&gt;&gt; 3. With unique indirect storage (and copy-on-write) you would be able use `==` for large values, because these values are only shared for reads not for writes  (future, not yet available in swift), so no race conditions<br>&gt;&gt; 4. With `dispatch` in operator-methods (or any other) as well as a `default` clause for reference types, so that equality of mixed-types just result in `false`, so that this is not possible anymore (see excerpt of discussion):<br>&gt;&gt; <br>&gt;&gt;&gt; Am 16.07.2016 um 15:18 schrieb Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is not true for reference types. Consider the following **bad** (but compiling code):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; class A: Equatable {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Aa: A {<br>&gt;&gt;&gt;  let a: Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  init(a: Int) {<br>&gt;&gt;&gt;      self.a = a<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func ==(lhs: A, rhs: A) -&gt; Bool {<br>&gt;&gt;&gt;  return lhs === rhs<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func ==(lhs: Aa, rhs: Aa) -&gt; Bool {<br>&gt;&gt;&gt;  return lhs.a == rhs.a<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now let us use this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; let a = A()<br>&gt;&gt;&gt; let a2 = A()<br>&gt;&gt;&gt; let aa = Aa(a: 0)<br>&gt;&gt;&gt; let aa2 = Aa(a: 1)<br>&gt;&gt;&gt; let aa3 = Aa(a: 1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // prints `true`<br>&gt;&gt;&gt; print(a == a)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // prints `false`<br>&gt;&gt;&gt; print(a == a2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // prints `false`<br>&gt;&gt;&gt; print(a == aa)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // prints `false`<br>&gt;&gt;&gt; print(a == aa3)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // prints `false`<br>&gt;&gt;&gt; print(aa == aa2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // prints `true` because it compares the `a: Int` values.<br>&gt;&gt;&gt; print(aa2 == aa3)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // now mixed-type comparison (returns `false`)<br>&gt;&gt;&gt; print(a == aa2)<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hence, you can do mixed-type equality checks in Swift. Even worse is, you can do this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; let aa2AsA: A = aa2,<br>&gt;&gt;&gt;  aa3AsA: A = aa3<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // prints `true` because it compares the `a: Int` values.<br>&gt;&gt;&gt; print(aa2 == aa3)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // prints `false`, because the equals method of `A` is used<br>&gt;&gt;&gt; print(aa2AsA == aa3AsA)<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just by assigning an object to a variable that is typed differently the result is completely different. This is because method parameters are dispatched statically. This is fast, but results in really unintended results, you can do a **lot** of things breaking the contract of `==` with that. This is why I wanted to add a `default` clause (in *3.* of my original proposal) for such methods involving two references to `Self`. Further on, I wanted to add the keyword `dispatch` for method (and operator) parameters, where dispatching is necessary (see *2.* of my original proposal).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 18, 2016 at 01:00:00pm</p></header><div class="content"><p>IMHO implementing your proposal would close the door on some of the things you do when building in-memory dbs (T == U -&gt; TRUE for T not related to U), which if swift remains for small apps is not a terrible loss, but may be more of an issue for one day doing big-data with it.<br></p><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 18, 2016, at 12:21 PM, Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; See below...<br>&gt; <br>&gt;&gt; Am 18.07.2016 um 12:08 schrieb Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; Dear  Félix,<br>&gt;&gt; <br>&gt;&gt; As a small follow-up, because you asked what I am protecting you from. Dictionaries and Sets, for instance, will work only, if equality and hash value are computed contract conform. As soon as you let (unintendedly) differing values collapse or same values break up, you will have unintended behavior. This is crucial and I think every developer should be thankful for any help he gets here from a language. If (in the future) the swift runtime will create value pools for you, and you have a wrong implementation of equality, the complete system will just misbehave. **That** will be bugs hard to find.<br>&gt;&gt; <br>&gt;&gt; All the best<br>&gt;&gt; Johannes<br>&gt;&gt; <br>&gt;&gt;&gt; Am 18.07.2016 um 11:50 schrieb Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 18.07.2016 um 03:51 schrieb Félix Cloutier &lt;felixcca at yahoo.ca&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Your initial rationale no longer makes sense with your suggested solution. If the dumb comparison returns false, people can still introduce side effects in the comparison method, except that now it&#39;s even harder to find out because all of my equality tests have been rewritten as &quot;memcmp(a, b) || ==(a, b)“.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No its `memcmp(a, b) &amp;&amp; ==(a,b)`, since if the „standard equality“ says `true` there is no short-circuit, but the custom implementation has to be `true` either! It is just a pre-condition.<br>&gt; <br>&gt; Sorry, wrote this in a hurry. It is `||` of course. But still the rest holds.<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What are you trying to protect me from?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. You cannot say something is unequal although the system says it is equal<br>&gt;&gt;&gt; 2. You do not have to implement equality for value types, only if you really need custom behavior (so you do not write boiler-plate code, which is error prone), so side effects will be less common<br>&gt;&gt;&gt; 3. With unique indirect storage (and copy-on-write) you would be able use `==` for large values, because these values are only shared for reads not for writes  (future, not yet available in swift), so no race conditions<br>&gt;&gt;&gt; 4. With `dispatch` in operator-methods (or any other) as well as a `default` clause for reference types, so that equality of mixed-types just result in `false`, so that this is not possible anymore (see excerpt of discussion):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 16.07.2016 um 15:18 schrieb Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is not true for reference types. Consider the following **bad** (but compiling code):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; class A: Equatable {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Aa: A {<br>&gt;&gt;&gt;&gt; let a: Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; init(a: Int) {<br>&gt;&gt;&gt;&gt;     self.a = a<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func ==(lhs: A, rhs: A) -&gt; Bool {<br>&gt;&gt;&gt;&gt; return lhs === rhs<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func ==(lhs: Aa, rhs: Aa) -&gt; Bool {<br>&gt;&gt;&gt;&gt; return lhs.a == rhs.a<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now let us use this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; let a = A()<br>&gt;&gt;&gt;&gt; let a2 = A()<br>&gt;&gt;&gt;&gt; let aa = Aa(a: 0)<br>&gt;&gt;&gt;&gt; let aa2 = Aa(a: 1)<br>&gt;&gt;&gt;&gt; let aa3 = Aa(a: 1)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // prints `true`<br>&gt;&gt;&gt;&gt; print(a == a)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // prints `false`<br>&gt;&gt;&gt;&gt; print(a == a2)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // prints `false`<br>&gt;&gt;&gt;&gt; print(a == aa)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // prints `false`<br>&gt;&gt;&gt;&gt; print(a == aa3)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // prints `false`<br>&gt;&gt;&gt;&gt; print(aa == aa2)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // prints `true` because it compares the `a: Int` values.<br>&gt;&gt;&gt;&gt; print(aa2 == aa3)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // now mixed-type comparison (returns `false`)<br>&gt;&gt;&gt;&gt; print(a == aa2)<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hence, you can do mixed-type equality checks in Swift. Even worse is, you can do this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; let aa2AsA: A = aa2,<br>&gt;&gt;&gt;&gt; aa3AsA: A = aa3<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // prints `true` because it compares the `a: Int` values.<br>&gt;&gt;&gt;&gt; print(aa2 == aa3)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // prints `false`, because the equals method of `A` is used<br>&gt;&gt;&gt;&gt; print(aa2AsA == aa3AsA)<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Just by assigning an object to a variable that is typed differently the result is completely different. This is because method parameters are dispatched statically. This is fast, but results in really unintended results, you can do a **lot** of things breaking the contract of `==` with that. This is why I wanted to add a `default` clause (in *3.* of my original proposal) for such methods involving two references to `Self`. Further on, I wanted to add the keyword `dispatch` for method (and operator) parameters, where dispatching is necessary (see *2.* of my original proposal).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 18, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; Am 18.07.2016 um 13:05 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt; <br>&gt; IMHO implementing your proposal would close the door on some of the things you do when building in-memory dbs (T == U -&gt; TRUE for T not related to U), which if swift remains for small apps is not a terrible loss, but may be more of an issue for one day doing big-data with it.<br></p><p>You talk about reference types now, right? I proposed a `default` keyword, which (in a pattern matching fashion) would catch all calls to T == U for which no implementation exists (so this is exactly when T != U). You could of course change for a given type hierarchy the `default` result to `true` if appropriate.<br></p><p>If you recall how virtual functions work. There is a V-table, which contains an entry for each overridden function and the correct one is looked up and executed with an implicit _self parameter for the instance on which the method has been executed.<br></p><p>You could write something like this:<br></p><p>```swift<br>// you could equally write: `func ==(lhs: dispatch A, rhs: dispatch A) -&gt; Bool = false`<br>dispatch func ==(lhs: A, rhs: A) -&gt; Bool = false {<br>  lhs === rhs<br>}<br></p><p>// the default value `= false` is inferred...<br>dispatch func ==(lhs: Aa, rhs: Aa) -&gt; Bool {<br>  lhs.a == rhs.a<br>}<br>```<br></p><p>You could change the default value of course. For comparisons (`Comparable`) you could add a closure to calculate the default value (e.g. more specialized instances are greater than less specialized so Point3D is always greater than Point2D, in order to get total ordering).<br></p><p>The implementation would create a dispatch-table for this function. The key would be a tuple `(MetaType, MetaType)`. And the value would be the corresponding function. If the lookup `(lhs.dynamicType, rhs.dynamicType)` does not find a table entry (e.g. because it is `lhs.dynamicType != rhs.dynamicType`), then a auto-closure returning the default value (or if it is a closure, the closure itself) is returned and executed.<br></p><p>Cool?<br></p><p>All the best<br>Johannes<br>&gt; <br>&gt; Regards<br>&gt; (From mobile)<br>&gt; <br>&gt;&gt; On Jul 18, 2016, at 12:21 PM, Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; See below...<br>&gt;&gt; <br>&gt;&gt;&gt; Am 18.07.2016 um 12:08 schrieb Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dear  Félix,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a small follow-up, because you asked what I am protecting you from. Dictionaries and Sets, for instance, will work only, if equality and hash value are computed contract conform. As soon as you let (unintendedly) differing values collapse or same values break up, you will have unintended behavior. This is crucial and I think every developer should be thankful for any help he gets here from a language. If (in the future) the swift runtime will create value pools for you, and you have a wrong implementation of equality, the complete system will just misbehave. **That** will be bugs hard to find.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; All the best<br>&gt;&gt;&gt; Johannes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 18.07.2016 um 11:50 schrieb Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 18.07.2016 um 03:51 schrieb Félix Cloutier &lt;felixcca at yahoo.ca&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Your initial rationale no longer makes sense with your suggested solution. If the dumb comparison returns false, people can still introduce side effects in the comparison method, except that now it&#39;s even harder to find out because all of my equality tests have been rewritten as &quot;memcmp(a, b) || ==(a, b)“.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No its `memcmp(a, b) &amp;&amp; ==(a,b)`, since if the „standard equality“ says `true` there is no short-circuit, but the custom implementation has to be `true` either! It is just a pre-condition.<br>&gt;&gt; <br>&gt;&gt; Sorry, wrote this in a hurry. It is `||` of course. But still the rest holds.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What are you trying to protect me from?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. You cannot say something is unequal although the system says it is equal<br>&gt;&gt;&gt;&gt; 2. You do not have to implement equality for value types, only if you really need custom behavior (so you do not write boiler-plate code, which is error prone), so side effects will be less common<br>&gt;&gt;&gt;&gt; 3. With unique indirect storage (and copy-on-write) you would be able use `==` for large values, because these values are only shared for reads not for writes  (future, not yet available in swift), so no race conditions<br>&gt;&gt;&gt;&gt; 4. With `dispatch` in operator-methods (or any other) as well as a `default` clause for reference types, so that equality of mixed-types just result in `false`, so that this is not possible anymore (see excerpt of discussion):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 16.07.2016 um 15:18 schrieb Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is not true for reference types. Consider the following **bad** (but compiling code):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt; class A: Equatable {}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class Aa: A {<br>&gt;&gt;&gt;&gt;&gt; let a: Int<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; init(a: Int) {<br>&gt;&gt;&gt;&gt;&gt;    self.a = a<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func ==(lhs: A, rhs: A) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt; return lhs === rhs<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func ==(lhs: Aa, rhs: Aa) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt; return lhs.a == rhs.a<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Now let us use this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt; let a = A()<br>&gt;&gt;&gt;&gt;&gt; let a2 = A()<br>&gt;&gt;&gt;&gt;&gt; let aa = Aa(a: 0)<br>&gt;&gt;&gt;&gt;&gt; let aa2 = Aa(a: 1)<br>&gt;&gt;&gt;&gt;&gt; let aa3 = Aa(a: 1)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // prints `true`<br>&gt;&gt;&gt;&gt;&gt; print(a == a)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // prints `false`<br>&gt;&gt;&gt;&gt;&gt; print(a == a2)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // prints `false`<br>&gt;&gt;&gt;&gt;&gt; print(a == aa)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // prints `false`<br>&gt;&gt;&gt;&gt;&gt; print(a == aa3)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // prints `false`<br>&gt;&gt;&gt;&gt;&gt; print(aa == aa2)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // prints `true` because it compares the `a: Int` values.<br>&gt;&gt;&gt;&gt;&gt; print(aa2 == aa3)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // now mixed-type comparison (returns `false`)<br>&gt;&gt;&gt;&gt;&gt; print(a == aa2)<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hence, you can do mixed-type equality checks in Swift. Even worse is, you can do this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt;&gt; let aa2AsA: A = aa2,<br>&gt;&gt;&gt;&gt;&gt; aa3AsA: A = aa3<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // prints `true` because it compares the `a: Int` values.<br>&gt;&gt;&gt;&gt;&gt; print(aa2 == aa3)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // prints `false`, because the equals method of `A` is used<br>&gt;&gt;&gt;&gt;&gt; print(aa2AsA == aa3AsA)<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Just by assigning an object to a variable that is typed differently the result is completely different. This is because method parameters are dispatched statically. This is fast, but results in really unintended results, you can do a **lot** of things breaking the contract of `==` with that. This is why I wanted to add a `default` clause (in *3.* of my original proposal) for such methods involving two references to `Self`. Further on, I wanted to add the keyword `dispatch` for method (and operator) parameters, where dispatching is necessary (see *2.* of my original proposal).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 18, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; Am 18.07.2016 um 13:52 schrieb Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Am 18.07.2016 um 13:05 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt;&gt; <br>&gt;&gt; IMHO implementing your proposal would close the door on some of the things you do when building in-memory dbs (T == U -&gt; TRUE for T not related to U), which if swift remains for small apps is not a terrible loss, but may be more of an issue for one day doing big-data with it.<br>&gt; <br>&gt; You talk about reference types now, right? I proposed a `default` keyword, which (in a pattern matching fashion) would catch all calls to T == U for which no implementation exists (so this is exactly when T != U). You could of course change for a given type hierarchy the `default` result to `true` if appropriate.<br></p><p>This formulation can be misleading: I mean `a == b` where `a: T` and `b: U` and `T != U`. Due to dynamic dispatch even: `a.dynamicType == T &amp;&amp; b.dynamicType == U &amp;&amp; T != U`.<br></p><p>&gt; <br>&gt; If you recall how virtual functions work. There is a V-table, which contains an entry for each overridden function and the correct one is looked up and executed with an implicit _self parameter for the instance on which the method has been executed.<br>&gt; <br>&gt; You could write something like this:<br>&gt; <br>&gt; ```swift<br>&gt; // you could equally write: `func ==(lhs: dispatch A, rhs: dispatch A) -&gt; Bool = false`<br>&gt; dispatch func ==(lhs: A, rhs: A) -&gt; Bool = false {<br>&gt;  lhs === rhs<br>&gt; }<br>&gt; <br>&gt; // the default value `= false` is inferred...<br>&gt; dispatch func ==(lhs: Aa, rhs: Aa) -&gt; Bool {<br>&gt;  lhs.a == rhs.a<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; You could change the default value of course. For comparisons (`Comparable`) you could add a closure to calculate the default value (e.g. more specialized instances are greater than less specialized so Point3D is always greater than Point2D, in order to get total ordering).<br>&gt; <br>&gt; The implementation would create a dispatch-table for this function. The key would be a tuple `(MetaType, MetaType)`. And the value would be the corresponding function. If the lookup `(lhs.dynamicType, rhs.dynamicType)` does not find a table entry (e.g. because it is `lhs.dynamicType != rhs.dynamicType`), then a auto-closure returning the default value (or if it is a closure, the closure itself) is returned and executed.<br>&gt; <br>&gt; Cool?<br></p><p>All the best<br>Johannes<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 18, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Am 18.07.2016 um 14:01 schrieb Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; Am 18.07.2016 um 13:52 schrieb Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 18.07.2016 um 13:05 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMHO implementing your proposal would close the door on some of the things you do when building in-memory dbs (T == U -&gt; TRUE for T not related to U), which if swift remains for small apps is not a terrible loss, but may be more of an issue for one day doing big-data with it.<br>&gt;&gt; <br>&gt;&gt; You talk about reference types now, right? I proposed a `default` keyword, which (in a pattern matching fashion) would catch all calls to T == U for which no implementation exists (so this is exactly when T != U). You could of course change for a given type hierarchy the `default` result to `true` if appropriate.<br>&gt; <br>&gt; This formulation can be misleading: I mean `a == b` where `a: T` and `b: U` and `T != U`. Due to dynamic dispatch even: `a.dynamicType == T &amp;&amp; b.dynamicType == U &amp;&amp; T != U`.<br></p><p>But I think, for such a radical different semantic than the normal interpretation of equality I think I wouldn’t use the `Equatable`-protocol at all, but implement a custom protocol with a custom operator.<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/70d96cff/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 18, 2016 at 06:00:00pm</p></header><div class="content"><p>As mentioned earlier, NaN != NaN, demonstrating that an Equatable instance<br>that does not always equal itself is not &quot;radical.&quot; Plainly, your proposal<br>is unworkable.<br></p><p><br>On Mon, Jul 18, 2016 at 13:48 Johannes Neubauer via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; Am 18.07.2016 um 14:01 schrieb Johannes Neubauer via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; Am 18.07.2016 um 13:52 schrieb Johannes Neubauer via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Am 18.07.2016 um 13:05 schrieb L. Mihalkovic &lt;<br>&gt; laurent.mihalkovic at gmail.com&gt;:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; IMHO implementing your proposal would close the door on some of the<br>&gt; things you do when building in-memory dbs (T == U -&gt; TRUE for T not related<br>&gt; to U), which if swift remains for small apps is not a terrible loss, but<br>&gt; may be more of an issue for one day doing big-data with it.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; You talk about reference types now, right? I proposed a `default`<br>&gt; keyword, which (in a pattern matching fashion) would catch all calls to T<br>&gt; == U for which no implementation exists (so this is exactly when T != U).<br>&gt; You could of course change for a given type hierarchy the `default` result<br>&gt; to `true` if appropriate.<br>&gt; &gt;<br>&gt; &gt; This formulation can be misleading: I mean `a == b` where `a: T` and `b:<br>&gt; U` and `T != U`. Due to dynamic dispatch even: `a.dynamicType == T &amp;&amp;<br>&gt; b.dynamicType == U &amp;&amp; T != U`.<br>&gt;<br>&gt; But I think, for such a radical different semantic than the normal<br>&gt; interpretation of equality I think I wouldn’t use the `Equatable`-protocol<br>&gt; at all, but implement a custom protocol with a custom operator.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/f55d028b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 18, 2016 at 09:00:00pm</p></header><div class="content"><p>Dear Xiaodi,<br></p><p>&gt; Am 18.07.2016 um 20:55 schrieb Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt; <br>&gt; As mentioned earlier, NaN != NaN, demonstrating that an Equatable instance that does not always equal itself is not &quot;radical.&quot; Plainly, your proposal is unworkable.<br></p><p>1. this is a basic internal type, so it can have a special behavior, since it is a well-designed data type created by the language designers (since there is no need to bootstrap swift from the first bits this is OK).<br>2. when I made my proposal I didn’t expect that there is such a hard wish for doing things that for sure do **not** comply to the contract of equality (e.g. in order to work with dictionaries and sets). If you allow to implement something like NaN != NaN in custom code, you allow them to implement equality, that is **not reflexive**.<br></p><p>Swift (AFAIK) has three goals:<br></p><p>1. simplicity<br>2. performance<br>3. safety<br></p><p>Allowing things like NaN != NaN in custom value types **without** even flagging it with a keyword like `iknowthisisdangerousbutiknowwhatido`, is against goal 3.<br></p><p>All the best<br>Johannes<br>&gt; <br>&gt; <br>&gt; On Mon, Jul 18, 2016 at 13:48 Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &gt; Am 18.07.2016 um 14:01 schrieb Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; Am 18.07.2016 um 13:52 schrieb Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Am 18.07.2016 um 13:05 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; IMHO implementing your proposal would close the door on some of the things you do when building in-memory dbs (T == U -&gt; TRUE for T not related to U), which if swift remains for small apps is not a terrible loss, but may be more of an issue for one day doing big-data with it.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; You talk about reference types now, right? I proposed a `default` keyword, which (in a pattern matching fashion) would catch all calls to T == U for which no implementation exists (so this is exactly when T != U). You could of course change for a given type hierarchy the `default` result to `true` if appropriate.<br>&gt; &gt;<br>&gt; &gt; This formulation can be misleading: I mean `a == b` where `a: T` and `b: U` and `T != U`. Due to dynamic dispatch even: `a.dynamicType == T &amp;&amp; b.dynamicType == U &amp;&amp; T != U`.<br>&gt; <br>&gt; But I think, for such a radical different semantic than the normal interpretation of equality I think I wouldn’t use the `Equatable`-protocol at all, but implement a custom protocol with a custom operator.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/51f86559/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>July 18, 2016 at 12:00:00pm</p></header><div class="content"><p>On Mon, Jul 18, 2016 at 12:28 PM, Johannes Neubauer via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Dear Xiaodi,<br>&gt;<br>&gt; &gt; Am 18.07.2016 um 20:55 schrieb Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt; &gt;<br>&gt; &gt; As mentioned earlier, NaN != NaN, demonstrating that an Equatable<br>&gt; instance that does not always equal itself is not &quot;radical.&quot; Plainly, your<br>&gt; proposal is unworkable.<br>&gt;<br>&gt; 1. this is a basic internal type, so it can have a special behavior, since<br>&gt; it is a well-designed data type created by the language designers (since<br>&gt; there is no need to bootstrap swift from the first bits this is OK).<br>&gt;<br></p><p>The problem is that this is *exactly* how Swift works. There is nothing<br>special about e.g. Double except for the fact that it wraps a built-in type<br>and the implementation of its operations forward to built-in functions.<br>This is how all the stdlib types work. You can build your own refcounted<br>COW `Array` with exactly no additional compiler support from scratch, if<br>you want.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/d680fd84/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 18, 2016 at 11:00:00pm</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 18, 2016, at 9:43 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mon, Jul 18, 2016 at 12:28 PM, Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Dear Xiaodi,<br>&gt;&gt; <br>&gt;&gt; &gt; Am 18.07.2016 um 20:55 schrieb Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; As mentioned earlier, NaN != NaN, demonstrating that an Equatable instance that does not always equal itself is not &quot;radical.&quot; Plainly, your proposal is unworkable.<br>&gt;&gt; <br>&gt;&gt; 1. this is a basic internal type, so it can have a special behavior, since it is a well-designed data type created by the language designers (since there is no need to bootstrap swift from the first bits this is OK).<br>&gt; <br>&gt; The problem is that this is *exactly* how Swift works. There is nothing special about e.g. Double except for the fact that it wraps a built-in type and the implementation of its operations forward to built-in functions. This is how all the stdlib types work. You can build your own refcounted COW `Array` with exactly no additional compiler support from scratch, if you want.<br></p><p>Well, there is something special.. The fact that the compiler will to the forwarding, and not not do something equivalent for other data types.<br></p><p><br>&gt; <br>&gt;  <br>&gt; <br>&gt; <br>&gt;  <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/73694f85/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>July 18, 2016 at 02:00:00pm</p></header><div class="content"><p>The compiler &quot;will to the forwarding&quot; because the implementation calls the<br>built-in function, not because there is some special case logic in the<br>compiler to treat that type differently from other types.<br></p><p>On Mon, Jul 18, 2016 at 2:33 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com<br>&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Regards<br>&gt; (From mobile)<br>&gt;<br>&gt; On Jul 18, 2016, at 9:43 PM, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Mon, Jul 18, 2016 at 12:28 PM, Johannes Neubauer via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Dear Xiaodi,<br>&gt;&gt;<br>&gt;&gt; &gt; Am 18.07.2016 um 20:55 schrieb Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; As mentioned earlier, NaN != NaN, demonstrating that an Equatable<br>&gt;&gt; instance that does not always equal itself is not &quot;radical.&quot; Plainly, your<br>&gt;&gt; proposal is unworkable.<br>&gt;&gt;<br>&gt;&gt; 1. this is a basic internal type, so it can have a special behavior,<br>&gt;&gt; since it is a well-designed data type created by the language designers<br>&gt;&gt; (since there is no need to bootstrap swift from the first bits this is OK).<br>&gt;&gt;<br>&gt;<br>&gt; The problem is that this is *exactly* how Swift works. There is nothing<br>&gt; special about e.g. Double except for the fact that it wraps a built-in type<br>&gt; and the implementation of its operations forward to built-in functions.<br>&gt; This is how all the stdlib types work. You can build your own refcounted<br>&gt; COW `Array` with exactly no additional compiler support from scratch, if<br>&gt; you want.<br>&gt;<br>&gt;<br>&gt; Well, there is something special.. The fact that the compiler will to the<br>&gt; forwarding, and not not do something equivalent for other data types.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/e816bd14/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 18, 2016 at 08:00:00pm</p></header><div class="content"><p>You keep saying that floating point types are &quot;basic internal&quot; types, but<br>part of the purpose of having a FloatingPoint protocol and a separate<br>BinaryFloatingPoint protocol is that you can implement your own decimal<br>type without any compiler magic.<br></p><p>On Mon, Jul 18, 2016 at 14:28 Johannes Neubauer &lt;neubauer at kingsware.de&gt;<br>wrote:<br></p><p>&gt; Dear Xiaodi,<br>&gt;<br>&gt; &gt; Am 18.07.2016 um 20:55 schrieb Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt; &gt;<br>&gt; &gt; As mentioned earlier, NaN != NaN, demonstrating that an Equatable<br>&gt; instance that does not always equal itself is not &quot;radical.&quot; Plainly, your<br>&gt; proposal is unworkable.<br>&gt;<br>&gt; 1. this is a basic internal type, so it can have a special behavior, since<br>&gt; it is a well-designed data type created by the language designers (since<br>&gt; there is no need to bootstrap swift from the first bits this is OK).<br>&gt; 2. when I made my proposal I didn’t expect that there is such a hard wish<br>&gt; for doing things that for sure do **not** comply to the contract of<br>&gt; equality (e.g. in order to work with dictionaries and sets). If you allow<br>&gt; to implement something like NaN != NaN in custom code, you allow them to<br>&gt; implement equality, that is **not reflexive**.<br>&gt;<br>&gt; Swift (AFAIK) has three goals:<br>&gt;<br>&gt; 1. simplicity<br>&gt; 2. performance<br>&gt; 3. safety<br>&gt;<br>&gt; Allowing things like NaN != NaN in custom value types **without** even<br>&gt; flagging it with a keyword like `iknowthisisdangerousbutiknowwhatido`, is<br>&gt; against goal 3.<br>&gt;<br>&gt; All the best<br>&gt; Johannes<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Mon, Jul 18, 2016 at 13:48 Johannes Neubauer via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; &gt; Am 18.07.2016 um 14:01 schrieb Johannes Neubauer via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;&gt; Am 18.07.2016 um 13:52 schrieb Johannes Neubauer via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt; Am 18.07.2016 um 13:05 schrieb L. Mihalkovic &lt;<br>&gt; laurent.mihalkovic at gmail.com&gt;:<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt; IMHO implementing your proposal would close the door on some of the<br>&gt; things you do when building in-memory dbs (T == U -&gt; TRUE for T not related<br>&gt; to U), which if swift remains for small apps is not a terrible loss, but<br>&gt; may be more of an issue for one day doing big-data with it.<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; You talk about reference types now, right? I proposed a `default`<br>&gt; keyword, which (in a pattern matching fashion) would catch all calls to T<br>&gt; == U for which no implementation exists (so this is exactly when T != U).<br>&gt; You could of course change for a given type hierarchy the `default` result<br>&gt; to `true` if appropriate.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; This formulation can be misleading: I mean `a == b` where `a: T` and<br>&gt; `b: U` and `T != U`. Due to dynamic dispatch even: `a.dynamicType == T &amp;&amp;<br>&gt; b.dynamicType == U &amp;&amp; T != U`.<br>&gt; &gt;<br>&gt; &gt; But I think, for such a radical different semantic than the normal<br>&gt; interpretation of equality I think I wouldn’t use the `Equatable`-protocol<br>&gt; at all, but implement a custom protocol with a custom operator.<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/396afe68/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 18, 2016 at 11:00:00pm</p></header><div class="content"><p>I think this discussion goes into the wrong direction. Why are we discussing now how these types are implemented? It was just stating the fact, that the swift compiler does not do nothing and swift is a high-level language. I am a fan of bootstrapping (I implemented some bootstrapping processes by myself). If there is a keyword/annotation &quot;iknowwhatido&quot; then these types can be implemented in swift. Still they are implemented by the core team with caution...<br></p><p>But do you agree with me or not that (1) equality is reflexivity, symmetry, and transitivity, and (2) Swift should support the normal developer in fulfilling this contract and (3) that NaN != NaN is an extremely special case?<br></p><p>Perhaps it would be a good idea to have the possibility to identify these special cases and allow to model them (e.g. special case: sink value).<br></p><p>And for the very confident user the default implementation could be deactivated via keyword/annotation.<br></p><p>Von meinem iPhone gesendet<br></p><p>&gt; Am 18.07.2016 um 22:17 schrieb Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt; <br>&gt; You keep saying that floating point types are &quot;basic internal&quot; types, but part of the purpose of having a FloatingPoint protocol and a separate BinaryFloatingPoint protocol is that you can implement your own decimal type without any compiler magic.<br>&gt; <br>&gt;&gt; On Mon, Jul 18, 2016 at 14:28 Johannes Neubauer &lt;neubauer at kingsware.de&gt; wrote:<br>&gt;&gt; Dear Xiaodi,<br>&gt;&gt; <br>&gt;&gt; &gt; Am 18.07.2016 um 20:55 schrieb Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; As mentioned earlier, NaN != NaN, demonstrating that an Equatable instance that does not always equal itself is not &quot;radical.&quot; Plainly, your proposal is unworkable.<br>&gt;&gt; <br>&gt;&gt; 1. this is a basic internal type, so it can have a special behavior, since it is a well-designed data type created by the language designers (since there is no need to bootstrap swift from the first bits this is OK).<br>&gt;&gt; 2. when I made my proposal I didn’t expect that there is such a hard wish for doing things that for sure do **not** comply to the contract of equality (e.g. in order to work with dictionaries and sets). If you allow to implement something like NaN != NaN in custom code, you allow them to implement equality, that is **not reflexive**.<br>&gt;&gt; <br>&gt;&gt; Swift (AFAIK) has three goals:<br>&gt;&gt; <br>&gt;&gt; 1. simplicity<br>&gt;&gt; 2. performance<br>&gt;&gt; 3. safety<br>&gt;&gt; <br>&gt;&gt; Allowing things like NaN != NaN in custom value types **without** even flagging it with a keyword like `iknowthisisdangerousbutiknowwhatido`, is against goal 3.<br>&gt;&gt; <br>&gt;&gt; All the best<br>&gt;&gt; Johannes<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Mon, Jul 18, 2016 at 13:48 Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; &gt; Am 18.07.2016 um 14:01 schrieb Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt; &gt;<br>&gt;&gt; &gt; &gt;<br>&gt;&gt; &gt; &gt;&gt; Am 18.07.2016 um 13:52 schrieb Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt; &gt;&gt;<br>&gt;&gt; &gt; &gt;&gt;&gt;<br>&gt;&gt; &gt; &gt;&gt;&gt; Am 18.07.2016 um 13:05 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt;&gt; &gt; &gt;&gt;&gt;<br>&gt;&gt; &gt; &gt;&gt;&gt; IMHO implementing your proposal would close the door on some of the things you do when building in-memory dbs (T == U -&gt; TRUE for T not related to U), which if swift remains for small apps is not a terrible loss, but may be more of an issue for one day doing big-data with it.<br>&gt;&gt; &gt; &gt;&gt;<br>&gt;&gt; &gt; &gt;&gt; You talk about reference types now, right? I proposed a `default` keyword, which (in a pattern matching fashion) would catch all calls to T == U for which no implementation exists (so this is exactly when T != U). You could of course change for a given type hierarchy the `default` result to `true` if appropriate.<br>&gt;&gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; This formulation can be misleading: I mean `a == b` where `a: T` and `b: U` and `T != U`. Due to dynamic dispatch even: `a.dynamicType == T &amp;&amp; b.dynamicType == U &amp;&amp; T != U`.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; But I think, for such a radical different semantic than the normal interpretation of equality I think I wouldn’t use the `Equatable`-protocol at all, but implement a custom protocol with a custom operator.<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/1c7aab50/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 18, 2016 at 04:00:00pm</p></header><div class="content"><p>On Mon, Jul 18, 2016 at 4:27 PM, Johannes Neubauer &lt;neubauer at kingsware.de&gt;<br>wrote:<br></p><p>&gt; I think this discussion goes into the wrong direction. Why are we<br>&gt; discussing now how these types are implemented? It was just stating the<br>&gt; fact, that the swift compiler does not do nothing and swift is a high-level<br>&gt; language.<br>&gt;<br></p><p>Swift is a &quot;high-performance system programming language.&quot; It claims to be<br>&quot;memory safe by default&quot; and to offer &quot;high-level constructs&quot;; I see no<br>claim that Swift is safe or high-level in other respects.<br></p><p><br>&gt; I am a fan of bootstrapping (I implemented some bootstrapping processes by<br>&gt; myself). If there is a keyword/annotation &quot;iknowwhatido&quot; then these types<br>&gt; can be implemented in swift. Still they are implemented by the core team<br>&gt; with caution...<br>&gt;<br>&gt; But do you agree with me or not that (1) equality is reflexivity,<br>&gt; symmetry, and transitivity, and (2) Swift should support the normal<br>&gt; developer in fulfilling this contract and (3) that NaN != NaN is an<br>&gt; extremely special case?<br>&gt;<br></p><p>I do not. While protocols have semantic meaning, it is up to the owner of a<br>conforming type to ensure that the contract is meaningfully fulfilled. I<br>see no principled reason why Swift should have magic specific for `==` or<br>Equatable and not other methods or protocols.<br></p><p><br>&gt; Perhaps it would be a good idea to have the possibility to identify these<br>&gt; special cases and allow to model them (e.g. special case: sink value).<br>&gt;<br>&gt; And for the very confident user the default implementation could be<br>&gt; deactivated via keyword/annotation.<br>&gt;<br>&gt; Von meinem iPhone gesendet<br>&gt;<br>&gt; Am 18.07.2016 um 22:17 schrieb Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt;<br>&gt; You keep saying that floating point types are &quot;basic internal&quot; types, but<br>&gt; part of the purpose of having a FloatingPoint protocol and a separate<br>&gt; BinaryFloatingPoint protocol is that you can implement your own decimal<br>&gt; type without any compiler magic.<br>&gt;<br>&gt; On Mon, Jul 18, 2016 at 14:28 Johannes Neubauer &lt;neubauer at kingsware.de&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Dear Xiaodi,<br>&gt;&gt;<br>&gt;&gt; &gt; Am 18.07.2016 um 20:55 schrieb Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; As mentioned earlier, NaN != NaN, demonstrating that an Equatable<br>&gt;&gt; instance that does not always equal itself is not &quot;radical.&quot; Plainly, your<br>&gt;&gt; proposal is unworkable.<br>&gt;&gt;<br>&gt;&gt; 1. this is a basic internal type, so it can have a special behavior,<br>&gt;&gt; since it is a well-designed data type created by the language designers<br>&gt;&gt; (since there is no need to bootstrap swift from the first bits this is OK).<br>&gt;&gt; 2. when I made my proposal I didn’t expect that there is such a hard wish<br>&gt;&gt; for doing things that for sure do **not** comply to the contract of<br>&gt;&gt; equality (e.g. in order to work with dictionaries and sets). If you allow<br>&gt;&gt; to implement something like NaN != NaN in custom code, you allow them to<br>&gt;&gt; implement equality, that is **not reflexive**.<br>&gt;&gt;<br>&gt;&gt; Swift (AFAIK) has three goals:<br>&gt;&gt;<br>&gt;&gt; 1. simplicity<br>&gt;&gt; 2. performance<br>&gt;&gt; 3. safety<br>&gt;&gt;<br>&gt;&gt; Allowing things like NaN != NaN in custom value types **without** even<br>&gt;&gt; flagging it with a keyword like `iknowthisisdangerousbutiknowwhatido`, is<br>&gt;&gt; against goal 3.<br>&gt;&gt;<br>&gt;&gt; All the best<br>&gt;&gt; Johannes<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Mon, Jul 18, 2016 at 13:48 Johannes Neubauer via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; &gt; Am 18.07.2016 um 14:01 schrieb Johannes Neubauer via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt; &gt;<br>&gt;&gt; &gt; &gt;<br>&gt;&gt; &gt; &gt;&gt; Am 18.07.2016 um 13:52 schrieb Johannes Neubauer via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt; &gt;&gt;<br>&gt;&gt; &gt; &gt;&gt;&gt;<br>&gt;&gt; &gt; &gt;&gt;&gt; Am 18.07.2016 um 13:05 schrieb L. Mihalkovic &lt;<br>&gt;&gt; laurent.mihalkovic at gmail.com&gt;:<br>&gt;&gt; &gt; &gt;&gt;&gt;<br>&gt;&gt; &gt; &gt;&gt;&gt; IMHO implementing your proposal would close the door on some of the<br>&gt;&gt; things you do when building in-memory dbs (T == U -&gt; TRUE for T not related<br>&gt;&gt; to U), which if swift remains for small apps is not a terrible loss, but<br>&gt;&gt; may be more of an issue for one day doing big-data with it.<br>&gt;&gt; &gt; &gt;&gt;<br>&gt;&gt; &gt; &gt;&gt; You talk about reference types now, right? I proposed a `default`<br>&gt;&gt; keyword, which (in a pattern matching fashion) would catch all calls to T<br>&gt;&gt; == U for which no implementation exists (so this is exactly when T != U).<br>&gt;&gt; You could of course change for a given type hierarchy the `default` result<br>&gt;&gt; to `true` if appropriate.<br>&gt;&gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; This formulation can be misleading: I mean `a == b` where `a: T` and<br>&gt;&gt; `b: U` and `T != U`. Due to dynamic dispatch even: `a.dynamicType == T &amp;&amp;<br>&gt;&gt; b.dynamicType == U &amp;&amp; T != U`.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; But I think, for such a radical different semantic than the normal<br>&gt;&gt; interpretation of equality I think I wouldn’t use the `Equatable`-protocol<br>&gt;&gt; at all, but implement a custom protocol with a custom operator.<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/c3d5db88/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>July 18, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; 1. You cannot say something is unequal although the system says it is equal<br></p><p>That doesn&#39;t make me feel much safer. Comparison returned false when it should have returned true? Step into, see why it happened. Sounds like your garden variety of bugs. The downside is that every comparison now starts with an equality comparison of every field, which is not obvious (you can&#39;t step into invisible behavior), and does more work than necessary.<br></p><p>&gt; 2. You do not have to implement equality for value types, only if you really need custom behavior (so you do not write boiler-plate code, which is error prone), so side effects will be less common<br></p><p>I think that a default == for structs that only have Equatable fields makes sense and I can get behind that. We don&#39;t need the rest to implement this, though.<br></p><p>&gt; 3. With unique indirect storage (and copy-on-write) you would be able use `==` for large values, because these values are only shared for reads not for writes  (future, not yet available in swift), so no race conditions<br></p><p>This is hypothetical and in advance of Swift&#39;s concurrency model.<br></p><p>&gt; 4. With `dispatch` in operator-methods (or any other) as well as a `default` clause for reference types, so that equality of mixed-types just result in `false`, so that this is not possible anymore (see excerpt of discussion):<br></p><p>If I understand the suggested dispatch keyword correctly, it could only work if executables carried metadata for every method, which would be a size concern (especially on size-constrained platforms like Apple Watch) and make reverse engineering about as easy as it is in the Objective-C world. We had an improvement here and this would roll it back.<br></p><p>You are imposing the costs not just upon yourself, but upon everybody, on every platform, on every project, forever. Would it be a web app or an operating system component, the only way to opt out is to stop using the default equality and fragment the way that you do comparison. Are you really that confident that this will make everyone happier, now and in the future, than the model that we currently have?<br></p><p>Please realize that this is an absolutely radical change. Swift currently has little to no invisible behavior, and currently lets you implement equality any way that you like. In my book, radical changes should be considered with extreme skepticism, and should have an extremely compelling case behind them.<br></p><p>Félix<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 18, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Am 18.07.2016 um 18:23 schrieb Félix Cloutier &lt;felixcca at yahoo.ca&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; 1. You cannot say something is unequal although the system says it is equal<br>&gt; <br>&gt; That doesn&#39;t make me feel much safer. Comparison returned false when it should have returned true?<br></p><p>Yes you just may have a condition inverted e.g.. You could even have a compiler flag, where you remove the short-circuit and throw an error, if you have a false-negative. This would ease finding such issues (easier than just not having this feature)<br></p><p>&gt; Step into, see why it happened. Sounds like your garden variety of bugs. The downside is that every comparison now starts with an equality comparison of every field, which is not obvious (you can&#39;t step into invisible behavior), and does more work than necessary.<br></p><p>There could again be compiler optimizations, that skip this check (in a given mode), but I don’t think in the future this won’t be necessary anymore:<br>* For small value types the comparison will be very fast.<br>* For bigger values I hope for such a unique value pool (with copy-on-write) which can be checked with a simple reference comparison (very cheap, very fast).<br></p><p>Invisible behavior is everywhere: Automatic Reference Counting, Existential Containers, Virtual Functions, …<br></p><p>Swift is a high-level language, so it’s main appeal is invisible behavior, but I would call it *rich semantics* or something like that.<br></p><p>&gt;&gt; 2. You do not have to implement equality for value types, only if you really need custom behavior (so you do not write boiler-plate code, which is error prone), so side effects will be less common<br>&gt; <br>&gt; I think that a default == for structs that only have Equatable fields makes sense and I can get behind that. We don&#39;t need the rest to implement this, though.<br></p><p>The default implementation should definitively not call == on properties to reference types conforming to equatable (by default), since this means that the standard semantics of equality of structs is prone to race conditions. This should be something, that a user can do in a custom implementation, if he really needs to and then he should consider using a synchronous dispatching queue using GCD.<br></p><p>&gt;&gt; 3. With unique indirect storage (and copy-on-write) you would be able use `==` for large values, because these values are only shared for reads not for writes  (future, not yet available in swift), so no race conditions<br>&gt; <br>&gt; This is hypothetical and in advance of Swift&#39;s concurrency model.<br></p><p>It’s proposal. Yes it’s hypothetical. But there are discussions going on at apple already as Arnold Schwaighofer told me on the swift-dev list.<br></p><p>&gt;&gt; 4. With `dispatch` in operator-methods (or any other) as well as a `default` clause for reference types, so that equality of mixed-types just result in `false`, so that this is not possible anymore (see excerpt of discussion):<br>&gt; <br>&gt; If I understand the suggested dispatch keyword correctly, it could only work if executables carried metadata for every method,<br></p><p>It is like a virtual method, but for arbitrary parameters, so you need some kind of V-table for that and a lookup, that can be done in constant time. It is something, that I wouldn’t add by default. It is something that you may add to a method explicitly via a keyword (instead of implementing the dynamic dispatch by hand, by calling an `equals:other` method on the left-hand-side and then doing an if-cascade for rhs for example; which is error-prone). So you may use it wisely only, where necessary (and the internal implementation of swift will be much faster, than the manual variant). The XTend language has such a feature.<br></p><p>&gt; which would be a size concern (especially on size-constrained platforms like Apple Watch) and make reverse engineering about as easy as it is in the Objective-C world. We had an improvement here and this would roll it back.<br></p><p>See above. Objective-C has some nice features. I wouldn’t say „roll back to the dynamic world“, but „allow dynamicity where necessary“. We have reference types with virtual functions. This is a consequent step.<br></p><p>&gt; You are imposing the costs not just upon yourself, but upon everybody, on every platform, on every project, forever. Would it be a web app or an operating system component, the only way to opt out is to stop using the default equality and fragment the way that you do comparison. Are you really that confident that this will make everyone happier, now and in the future, than the model that we currently have?<br></p><p>My proposals are just additions, they are not forcing to do anyone anything. They just help to reduce bugs and to have more intuitive (visible) behavior of methods via dynamic dispatch where it is needed.<br></p><p>&gt; Please realize that this is an absolutely radical change. Swift currently has little to no invisible behavior, and currently lets you implement equality any way that you like. In my book, radical changes should be considered with extreme skepticism, and should have an extremely compelling case behind them.<br></p><p>First off, I don’t think, that the changes are that radical and second this example gives a small insight how bad you can implement equality in swift:<br></p><p>&gt;&gt;&gt; Am 16.07.2016 um 15:18 schrieb Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is not true for reference types. Consider the following **bad** (but compiling code):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; class A: Equatable {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Aa: A {<br>&gt;&gt;&gt; let a: Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; init(a: Int) {<br>&gt;&gt;&gt;     self.a = a<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func ==(lhs: A, rhs: A) -&gt; Bool {<br>&gt;&gt;&gt; return lhs === rhs<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func ==(lhs: Aa, rhs: Aa) -&gt; Bool {<br>&gt;&gt;&gt; return lhs.a == rhs.a<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now let us use this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; let a = A()<br>&gt;&gt;&gt; let a2 = A()<br>&gt;&gt;&gt; let aa = Aa(a: 0)<br>&gt;&gt;&gt; let aa2 = Aa(a: 1)<br>&gt;&gt;&gt; let aa3 = Aa(a: 1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // prints `true`<br>&gt;&gt;&gt; print(a == a)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // prints `false`<br>&gt;&gt;&gt; print(a == a2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // prints `false`<br>&gt;&gt;&gt; print(a == aa)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // prints `false`<br>&gt;&gt;&gt; print(a == aa3)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // prints `false`<br>&gt;&gt;&gt; print(aa == aa2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // prints `true` because it compares the `a: Int` values.<br>&gt;&gt;&gt; print(aa2 == aa3)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // now mixed-type comparison (returns `false`)<br>&gt;&gt;&gt; print(a == aa2)<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hence, you can do mixed-type equality checks in Swift. Even worse is, you can do this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; let aa2AsA: A = aa2,<br>&gt;&gt;&gt; aa3AsA: A = aa3<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // prints `true` because it compares the `a: Int` values.<br>&gt;&gt;&gt; print(aa2 == aa3)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // prints `false`, because the equals method of `A` is used<br>&gt;&gt;&gt; print(aa2AsA == aa3AsA)<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just by assigning an object to a variable that is typed differently the result is completely different. This is because method parameters are dispatched statically. This is fast, but results in really unintended results, you can do a **lot** of things breaking the contract of `==` with that. This is why I wanted to add a `default` clause (in *3.* of my original proposal) for such methods involving two references to `Self`. Further on, I wanted to add the keyword `dispatch` for method (and operator) parameters, where dispatching is necessary (see *2.* of my original proposal).<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/343c61ca/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>July 18, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt;&gt; <br>&gt;&gt;&gt; 1. You cannot say something is unequal although the system says it is equal<br>&gt;&gt; <br>&gt;&gt; That doesn&#39;t make me feel much safer. Comparison returned false when it should have returned true?<br>&gt; <br>&gt; Yes you just may have a condition inverted e.g.. You could even have a compiler flag, where you remove the short-circuit and throw an error, if you have a false-negative. This would ease finding such issues (easier than just not having this feature)<br></p><p>This minor enhancement could most likely be obtained by just having a default ==, which is a project that I can get behind.<br></p><p>&gt; <br>&gt;&gt; Step into, see why it happened. Sounds like your garden variety of bugs. The downside is that every comparison now starts with an equality comparison of every field, which is not obvious (you can&#39;t step into invisible behavior), and does more work than necessary.<br>&gt; <br>&gt; There could again be compiler optimizations, that skip this check (in a given mode), but I don’t think in the future this won’t be necessary anymore:<br>&gt; * For small value types the comparison will be very fast.<br>&gt; * For bigger values I hope for such a unique value pool (with copy-on-write) which can be checked with a simple reference comparison (very cheap, very fast).<br></p><p>The fact that the mandatory memberwise comparison would be &quot;fast&quot; is no excuse for the fact that if it doesn&#39;t hit but the structures are still equal, you&#39;re possibly *doubling* the time that it takes to check.<br></p><p>Also, what about C structures with character arrays? They get translated as tuples of CChar (if that&#39;s what they&#39;re still called now, didn&#39;t really keep track). The two are equal as soon as you hit a null terminator, but memberwise comparison doesn&#39;t know that.<br></p><p>&gt; Invisible behavior is everywhere: Automatic Reference Counting, Existential Containers, Virtual Functions, …<br>&gt; <br>&gt; Swift is a high-level language, so it’s main appeal is invisible behavior, but I would call it *rich semantics* or something like that.<br></p><p>There is an actual demand for these. With ARC, I don&#39;t need to think about memory management (too much). Virtual functions let me implement OO design, which allows a ton of developers to leverage experience. With forced memberwise comparisons, I can trade easily debuggable problems for surprising behavior.<br></p><p>Also keep in mind that most of these things are criticized to some degree. ARC is a common enough source of bugs that Apple has a relatively large investment into tools specially made to debug them. OO also has a ton of detractors.<br></p><p>&gt;&gt;&gt; 2. You do not have to implement equality for value types, only if you really need custom behavior (so you do not write boiler-plate code, which is error prone), so side effects will be less common<br>&gt;&gt; <br>&gt;&gt; I think that a default == for structs that only have Equatable fields makes sense and I can get behind that. We don&#39;t need the rest to implement this, though.<br>&gt; <br>&gt; The default implementation should definitively not call == on properties to reference types conforming to equatable (by default), since this means that the standard semantics of equality of structs is prone to race conditions. This should be something, that a user can do in a custom implementation, if he really needs to and then he should consider using a synchronous dispatching queue using GCD.<br></p><p>I don&#39;t care a lot how a default == would be implemented if we had one, as long as it made some sense. I&#39;m sure that the community would come together and nitpick every last wrinkle out of the correct implementation. I&#39;d be happy to have one, that&#39;s the main point.<br></p><p>&gt;&gt;&gt; 4. With `dispatch` in operator-methods (or any other) as well as a `default` clause for reference types, so that equality of mixed-types just result in `false`, so that this is not possible anymore (see excerpt of discussion):<br>&gt;&gt; <br>&gt;&gt; If I understand the suggested dispatch keyword correctly, it could only work if executables carried metadata for every method,<br>&gt; <br>&gt; It is like a virtual method, but for arbitrary parameters, so you need some kind of V-table for that and a lookup, that can be done in constant time. It is something, that I wouldn’t add by default. It is something that you may add to a method explicitly via a keyword (instead of implementing the dynamic dispatch by hand, by calling an `equals:other` method on the left-hand-side and then doing an if-cascade for rhs for example; which is error-prone). So you may use it wisely only, where necessary (and the internal implementation of swift will be much faster, than the manual variant). The XTend language has such a feature.<br></p><p>I didn&#39;t understand what you meant with dispatch. Now, my understanding is that it would be used to implement virtual dispatch over multiple parameters (instead of just `self`). I can see uses for that, and I can see that it doesn&#39;t need as much metadata. I could agree to that feature independently.<br></p><p>&gt;&gt; You are imposing the costs not just upon yourself, but upon everybody, on every platform, on every project, forever. Would it be a web app or an operating system component, the only way to opt out is to stop using the default equality and fragment the way that you do comparison. Are you really that confident that this will make everyone happier, now and in the future, than the model that we currently have?<br>&gt; <br>&gt; My proposals are just additions, they are not forcing to do anyone anything. They just help to reduce bugs and to have more intuitive (visible) behavior of methods via dynamic dispatch where it is needed.<br></p><p>What? You want to force every equality check to start with a memberwise comparison of *everything*.<br></p><p>&gt;&gt; Please realize that this is an absolutely radical change. Swift currently has little to no invisible behavior, and currently lets you implement equality any way that you like. In my book, radical changes should be considered with extreme skepticism, and should have an extremely compelling case behind them.<br>&gt; <br>&gt; First off, I don’t think, that the changes are that radical and second this example gives a small insight how bad you can implement equality in swift:<br></p><p>None of it is hard enough to debug to justify a performance hit. Just because you&#39;re able to misuse a feature is not an argument that this feature shouldn&#39;t be available, especially if you can only half-solve the problem.<br></p><p>Why can&#39;t you be content with a default implementation? People all over are saying &quot;don&#39;t touch my code&quot;, there&#39;s a very easy way to not touch anyone&#39;s code, but it&#39;s like you really want to.<br></p><p>Félix<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 19, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; Am 19.07.2016 um 06:29 schrieb Félix Cloutier &lt;felixcca at yahoo.ca&gt;:<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. You cannot say something is unequal although the system says it is equal<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That doesn&#39;t make me feel much safer. Comparison returned false when it should have returned true?<br>&gt;&gt; <br>&gt;&gt; Yes you just may have a condition inverted e.g.. You could even have a compiler flag, where you remove the short-circuit and throw an error, if you have a false-negative. This would ease finding such issues (easier than just not having this feature)<br>&gt; <br>&gt; This minor enhancement could most likely be obtained by just having a default ==, which is a project that I can get behind.<br></p><p>Structs do not have a common ancestor, this is why swift uses existential containers, in order to create polymorphic behavior for protocol types with value type implementations. So implementing such a default == would bring changes to swift either. But I didn’t bring this idea in the first place to have some more convenience. I am sure (and literature as well as my experience as a developer and project lead in many industrial projects proves me right), that implementing equality is a major source of errors in software development and I think that you underestimate this issue. This issues are really hard to track down. It is always better to implement a custom protocol for custom equality semantics, so that it doesn’t interfere with the expectations of the standard library and the many libraries to come, that will depend on the equals-contract.<br></p><p>Swift has the chance, not to make the same mistakes that other languages did before. But perhaps I just have to wait until Swift 3 has finished and repost the proposal, so that the core team has time to revisit it and we can start a fruitful discussion. Because right now I have the feeling that we are just spinning although I am 100% confident that this proposal (or at least a modified variant) is beneficial for swift.<br></p><p>&gt; Also, what about C structures with character arrays? They get translated as tuples of CChar (if that&#39;s what they&#39;re still called now, didn&#39;t really keep track). The two are equal as soon as you hit a null terminator, but memberwise comparison doesn&#39;t know that.<br></p><p>They can have its own standard implementation. There is a lot of translation going on between Objective C &lt;-&gt; Swift as well as C &lt;-&gt; Swift (e.g., some constants are automatically coerced into enums).<br></p><p>&gt;&gt; Invisible behavior is everywhere: Automatic Reference Counting, Existential Containers, Virtual Functions, …<br>&gt;&gt; <br>&gt;&gt; Swift is a high-level language, so it’s main appeal is invisible behavior, but I would call it *rich semantics* or something like that.<br>&gt; <br>&gt; There is an actual demand for these. With ARC, I don&#39;t need to think about memory management (too much).<br></p><p>You have to, as soon as you have cyclic structures (weak, unowned). It is a tradeoff between performance (ARC) and convenience (garbage collection).<br></p><p>Analogously, Having a better corset for equality helps me not to think so much about doing this implementation right.<br></p><p>&gt; Virtual functions let me implement OO design, which allows a ton of developers to leverage experience. With forced memberwise comparisons, I can trade easily debuggable problems for surprising behavior.<br></p><p>With my proposal you wouldn’t make it harder to find these issues it makes it easier. As I told before, you could have an instrumentation/error handling, that (in debug mode) does both checks default and custom implementation (so no short-circuit) and inform you about false-negatives automatically.<br></p><p>&gt; Also keep in mind that most of these things are criticized to some degree. ARC is a common enough source of bugs that Apple has a relatively large investment into tools specially made to debug them.<br></p><p>This is due to the tension between the goal „safety“ and „performance“. Perhaps swift switches to garbage collection in the future. Or they decide to use garbage collection on fast devices as well as ARC on slow devices. Who knows.<br></p><p>&gt; OO also has a ton of detractors.<br></p><p>Yes, because it is not restrictive enough in it’s current implementation. This is why I add these proposals. But there is not just black and white. Languages like Haskell are not that widely adopted, because a pure functional approach has its own downsides. Try to implement something like SpriteKit with Haskell.<br></p><p>&gt;&gt; It is like a virtual method, but for arbitrary parameters, so you need some kind of V-table for that and a lookup, that can be done in constant time. It is something, that I wouldn’t add by default. It is something that you may add to a method explicitly via a keyword (instead of implementing the dynamic dispatch by hand, by calling an `equals:other` method on the left-hand-side and then doing an if-cascade for rhs for example; which is error-prone). So you may use it wisely only, where necessary (and the internal implementation of swift will be much faster, than the manual variant). The XTend language has such a feature.<br>&gt; <br>&gt; I didn&#39;t understand what you meant with dispatch. Now, my understanding is that it would be used to implement virtual dispatch over multiple parameters (instead of just `self`).<br></p><p>Yes and no. Operators (like ==) do not have `self`, this is a major issue IMO, since even the left-hand-side is not dispatched. Operators (and global functions) are non-virtual.<br></p><p>&gt; What? You want to force every equality check to start with a memberwise comparison of *everything*.<br></p><p>I just proposed these two standard implementations executed before any custom implementation (no recursion or anything alike):<br></p><p>1. a `memcmp` for value types (not recursing through referenced types or anything) and<br>2. a === check for reference types (just comparing one address)<br></p><p>&gt;&gt;&gt; Please realize that this is an absolutely radical change. Swift currently has little to no invisible behavior, and currently lets you implement equality any way that you like. In my book, radical changes should be considered with extreme skepticism, and should have an extremely compelling case behind them.<br>&gt;&gt; <br>&gt;&gt; First off, I don’t think, that the changes are that radical and second this example gives a small insight how bad you can implement equality in swift:<br>&gt; <br>&gt; None of it is hard enough to debug to justify a performance hit. Just because you&#39;re able to misuse a feature is not an argument that this feature shouldn&#39;t be available, especially if you can only half-solve the problem.<br></p><p>You cannot solve the `null` problem or the fragile base class problem completely either, but still swift has:<br></p><p>1. no abstract classes and no abstract methods<br>2. optionals<br>3. 2-phase initialization<br></p><p>to narrow the problem space.<br></p><p>&gt; Why can&#39;t you be content with a default implementation? People all over are saying &quot;don&#39;t touch my code&quot;, there&#39;s a very easy way to not touch anyone&#39;s code, but it&#39;s like you really want to.<br></p><p>As mentioned above AFAIK this would introduce a change to swift either, since structs don’t have a common ancestor (in terms of „inheritance“) **and** this would just be a convenience feature and not help to reduce really hard to trace bugs.<br></p><p>These features aren’t only for the master-of-the-blaster programmer. In a normal project you have differently skilled programmers and a type system should help even the average skilled one.<br></p><p>All the best<br>Johannes<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160719/d1d38c44/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 19, 2016 at 09:00:00am</p></header><div class="content"><p>Von meinem iPhone gesendet<br></p><p>&gt; Am 19.07.2016 um 08:51 schrieb Johannes Neubauer via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; Am 19.07.2016 um 06:29 schrieb Félix Cloutier &lt;felixcca at yahoo.ca&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. You cannot say something is unequal although the system says it is equal<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That doesn&#39;t make me feel much safer. Comparison returned false when it should have returned true?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes you just may have a condition inverted e.g.. You could even have a compiler flag, where you remove the short-circuit and throw an error, if you have a false-negative. This would ease finding such issues (easier than just not having this feature)<br>&gt;&gt; <br>&gt;&gt; This minor enhancement could most likely be obtained by just having a default ==, which is a project that I can get behind.<br>&gt; <br>&gt; Structs do not have a common ancestor, this is why swift uses existential containers, in order to create polymorphic behavior for protocol types with value type implementations. So implementing such a default == would bring changes to swift either. But I didn’t bring this idea in the first place to have some more convenience. I am sure (and literature as well as my experience as a developer and project lead in many industrial projects proves me right), that implementing equality is a major source of errors in software development and I think that you underestimate this issue. This issues are really hard to track down. It is always better to implement a custom protocol for custom equality semantics, so that it doesn’t interfere with the expectations of the standard library and the many libraries to come, that will depend on the equals-contract.<br></p><p>I mean custom semantics violating the contract, only.<br></p><p>&gt; <br>&gt; Swift has the chance, not to make the same mistakes that other languages did before. But perhaps I just have to wait until Swift 3 has finished and repost the proposal, so that the core team has time to revisit it and we can start a fruitful discussion. Because right now I have the feeling that we are just spinning although I am 100% confident that this proposal (or at least a modified variant) is beneficial for swift.<br>&gt; <br>&gt;&gt; Also, what about C structures with character arrays? They get translated as tuples of CChar (if that&#39;s what they&#39;re still called now, didn&#39;t really keep track). The two are equal as soon as you hit a null terminator, but memberwise comparison doesn&#39;t know that.<br>&gt; <br>&gt; They can have its own standard implementation. There is a lot of translation going on between Objective C &lt;-&gt; Swift as well as C &lt;-&gt; Swift (e.g., some constants are automatically coerced into enums).<br>&gt; <br>&gt;&gt;&gt; Invisible behavior is everywhere: Automatic Reference Counting, Existential Containers, Virtual Functions, …<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift is a high-level language, so it’s main appeal is invisible behavior, but I would call it *rich semantics* or something like that.<br>&gt;&gt; <br>&gt;&gt; There is an actual demand for these. With ARC, I don&#39;t need to think about memory management (too much).<br>&gt; <br>&gt; You have to, as soon as you have cyclic structures (weak, unowned). It is a tradeoff between performance (ARC) and convenience (garbage collection).<br>&gt; <br>&gt; Analogously, Having a better corset for equality helps me not to think so much about doing this implementation right.<br>&gt; <br>&gt;&gt; Virtual functions let me implement OO design, which allows a ton of developers to leverage experience. With forced memberwise comparisons, I can trade easily debuggable problems for surprising behavior.<br>&gt; <br>&gt; With my proposal you wouldn’t make it harder to find these issues it makes it easier. As I told before, you could have an instrumentation/error handling, that (in debug mode) does both checks default and custom implementation (so no short-circuit) and inform you about false-negatives automatically.<br>&gt; <br>&gt;&gt; Also keep in mind that most of these things are criticized to some degree. ARC is a common enough source of bugs that Apple has a relatively large investment into tools specially made to debug them.<br>&gt; <br>&gt; This is due to the tension between the goal „safety“ and „performance“. Perhaps swift switches to garbage collection in the future. Or they decide to use garbage collection on fast devices as well as ARC on slow devices. Who knows.<br>&gt; <br>&gt;&gt; OO also has a ton of detractors.<br>&gt; <br>&gt; Yes, because it is not restrictive enough in it’s current implementation. This is why I add these proposals. But there is not just black and white. Languages like Haskell are not that widely adopted, because a pure functional approach has its own downsides. Try to implement something like SpriteKit with Haskell.<br>&gt; <br>&gt;&gt;&gt; It is like a virtual method, but for arbitrary parameters, so you need some kind of V-table for that and a lookup, that can be done in constant time. It is something, that I wouldn’t add by default. It is something that you may add to a method explicitly via a keyword (instead of implementing the dynamic dispatch by hand, by calling an `equals:other` method on the left-hand-side and then doing an if-cascade for rhs for example; which is error-prone). So you may use it wisely only, where necessary (and the internal implementation of swift will be much faster, than the manual variant). The XTend language has such a feature.<br>&gt;&gt; <br>&gt;&gt; I didn&#39;t understand what you meant with dispatch. Now, my understanding is that it would be used to implement virtual dispatch over multiple parameters (instead of just `self`).<br>&gt; <br>&gt; Yes and no. Operators (like ==) do not have `self`, this is a major issue IMO, since even the left-hand-side is not dispatched. Operators (and global functions) are non-virtual.<br>&gt; <br>&gt;&gt; What? You want to force every equality check to start with a memberwise comparison of *everything*.<br>&gt; <br>&gt; I just proposed these two standard implementations executed before any custom implementation (no recursion or anything alike):<br>&gt; <br>&gt; 1. a `memcmp` for value types (not recursing through referenced types or anything) and<br>&gt; 2. a === check for reference types (just comparing one address)<br>&gt; <br>&gt;&gt;&gt;&gt; Please realize that this is an absolutely radical change. Swift currently has little to no invisible behavior, and currently lets you implement equality any way that you like. In my book, radical changes should be considered with extreme skepticism, and should have an extremely compelling case behind them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; First off, I don’t think, that the changes are that radical and second this example gives a small insight how bad you can implement equality in swift:<br>&gt;&gt; <br>&gt;&gt; None of it is hard enough to debug to justify a performance hit. Just because you&#39;re able to misuse a feature is not an argument that this feature shouldn&#39;t be available, especially if you can only half-solve the problem.<br>&gt; <br>&gt; You cannot solve the `null` problem or the fragile base class problem completely either, but still swift has:<br>&gt; <br>&gt; 1. no abstract classes and no abstract methods<br>&gt; 2. optionals<br>&gt; 3. 2-phase initialization<br>&gt; <br>&gt; to narrow the problem space.<br>&gt; <br>&gt;&gt; Why can&#39;t you be content with a default implementation? People all over are saying &quot;don&#39;t touch my code&quot;, there&#39;s a very easy way to not touch anyone&#39;s code, but it&#39;s like you really want to.<br>&gt; <br>&gt; As mentioned above AFAIK this would introduce a change to swift either, since structs don’t have a common ancestor (in terms of „inheritance“) **and** this would just be a convenience feature and not help to reduce really hard to trace bugs.<br>&gt; <br>&gt; These features aren’t only for the master-of-the-blaster programmer. In a normal project you have differently skilled programmers and a type system should help even the average skilled one.<br>&gt; <br>&gt; All the best<br>&gt; Johannes<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>July 19, 2016 at 09:00:00am</p></header><div class="content"><p>&gt;&gt; This minor enhancement could most likely be obtained by just having a default ==, which is a project that I can get behind.<br>&gt; <br>&gt; Structs do not have a common ancestor, this is why swift uses existential containers, in order to create polymorphic behavior for protocol types with value type implementations. So implementing such a default == would bring changes to swift either. But I didn’t bring this idea in the first place to have some more convenience. I am sure (and literature as well as my experience as a developer and project lead in many industrial projects proves me right), that implementing equality is a major source of errors in software development and I think that you underestimate this issue.<br></p><p>Please do point me to that literature that shows that developers frequently misimplement their own comparators.<br></p><p>&gt;&gt; Also, what about C structures with character arrays? They get translated as tuples of CChar (if that&#39;s what they&#39;re still called now, didn&#39;t really keep track). The two are equal as soon as you hit a null terminator, but memberwise comparison doesn&#39;t know that.<br>&gt; <br>&gt; They can have its own standard implementation. There is a lot of translation going on between Objective C &lt;-&gt; Swift as well as C &lt;-&gt; Swift (e.g., some constants are automatically coerced into enums).<br></p><p>No, they can&#39;t. There is no way to differentiate a char array that should be a null-terminated string from a char array that is actually a byte array at the C level.<br></p><p>&gt;&gt;&gt; Invisible behavior is everywhere: Automatic Reference Counting, Existential Containers, Virtual Functions, …<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift is a high-level language, so it’s main appeal is invisible behavior, but I would call it *rich semantics* or something like that.<br>&gt;&gt; <br>&gt;&gt; There is an actual demand for these. With ARC, I don&#39;t need to think about memory management (too much). Virtual functions let me implement OO design, which allows a ton of developers to leverage experience. With forced memberwise comparisons, I can trade easily debuggable problems for surprising behavior.<br>&gt; <br>&gt; With my proposal you wouldn’t make it harder to find these issues it makes it easier. As I told before, you could have an instrumentation/error handling, that (in debug mode) does both checks default and custom implementation (so no short-circuit) and inform you about false-negatives automatically.<br></p><p>This sounds like piling on more work for the sake of it. If we end up forcing a default equality check on everything, I hope that we can at least rely on it being there all the time, because otherwise that will also be a bug vector.<br></p><p>&gt;&gt; Also keep in mind that most of these things are criticized to some degree. ARC is a common enough source of bugs that Apple has a relatively large investment into tools specially made to debug them.<br>&gt; <br>&gt; This is due to the tension between the goal „safety“ and „performance“. Perhaps swift switches to garbage collection in the future. Or they decide to use garbage collection on fast devices as well as ARC on slow devices. Who knows.<br></p><p>Swift won&#39;t switch to a GC in the foreseeable future. That discussion has already happened. The points brought forward are that you couldn&#39;t implement COW semantics because a GC doesn&#39;t keep a reference count around at all times; that ARC means that resources are deallocated deterministically; that a fast GC requires you to use up to 2-3x as much memory as you actually need.<br></p><p>&gt;&gt; What? You want to force every equality check to start with a memberwise comparison of *everything*.<br>&gt; <br>&gt; I just proposed these two standard implementations executed before any custom implementation (no recursion or anything alike):<br>&gt; <br>&gt; 1. a `memcmp` for value types (not recursing through referenced types or anything) and<br>&gt; 2. a === check for reference types (just comparing one address)<br></p><p>Exactly.<br></p><p>&gt;&gt; Why can&#39;t you be content with a default implementation? People all over are saying &quot;don&#39;t touch my code&quot;, there&#39;s a very easy way to not touch anyone&#39;s code, but it&#39;s like you really want to.<br>&gt; <br>&gt; As mentioned above AFAIK this would introduce a change to swift either, since structs don’t have a common ancestor (in terms of „inheritance“) **and** this would just be a convenience feature and not help to reduce really hard to trace bugs.<br></p><p>Here&#39;s one way this could be implemented: if you write `struct Foo: Equatable` without implementing a `func ==`, the compiler makes one for you. Done.<br></p><p>Félix<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>July 19, 2016 at 04:00:00pm</p></header><div class="content"><p>On Tue, Jul 19, 2016 at 9:00 AM Félix Cloutier &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt;<br>&gt; Here&#39;s one way this could be implemented: if you write `struct Foo:<br>&gt; Equatable` without implementing a `func ==`, the compiler makes one for<br>&gt; you. Done.<br>&gt;<br></p><p>I floated a draft proposal a while back that addressed exactly this use<br>case:<br></p><p>https://gist.github.com/allevato/2fd10290bfa84accfbe977d8ac07daad<br></p><p>It&#39;s purely additive so it&#39;s effectively shelved till post-Swift-3, and<br>there are still some issues up for debate (the discussion thread was here &lt;<br>http://thread.gmane.org/gmane.comp.lang.swift.evolution/18495&gt;), but it<br>would likely address many of these concerns without going to the extreme of<br>forbidding explicit implementation of Equatable or the other suggestions<br>offered here (which I wouldn&#39;t support).<br></p><p><br></p><p>&gt; Félix<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160719/8960b9ba/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 19, 2016 at 07:00:00pm</p></header><div class="content"><p>Dear Tony,<br></p><p>&gt; Am 19.07.2016 um 18:10 schrieb Tony Allevato &lt;allevato at google.com&gt;:<br>&gt; <br></p><p>&gt; I floated a draft proposal a while back that addressed exactly this use case:<br>&gt; <br>&gt; https://gist.github.com/allevato/2fd10290bfa84accfbe977d8ac07daad<br></p><p>I will take a look at it, thank you very much.<br></p><p>&gt; It&#39;s purely additive so it&#39;s effectively shelved till post-Swift-3, and there are still some issues up for debate (the discussion thread was here &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/18495&gt;), but it would likely address many of these concerns without going to the extreme of forbidding explicit implementation of Equatable or the other suggestions offered here (which I wouldn&#39;t support).<br></p><p>I do not want to forbid it, but discourage it. It makes only sense in some occasions to override the default equality for value types, and the developer should be aware that he does something uncommon (like force unwrapping of optionals). But implementing equals and violating the contract should only be possible only, if you state that you really no what you are doing (like force unwrapping an optional that is via data-flow analysis *for sure* a `nil` or writing code in a code path that can for sure never bean reached (dead code)). Although, I think that there are only a few corner cases (like sink values) that could directly be modeled instead of allowing to do everything (like deciding whether to objects are equal depending on the dollar rate).<br></p><p>But the other proposals like „default“ case and „dispatch“ for reference types are at least as important, if you look at my example where you can make two formerly equal objects unequal just by assigning them to another variable (with a different type)…<br></p><p>All the best<br>Johannes<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>July 19, 2016 at 06:00:00pm</p></header><div class="content"><p>Dear Félix,<br></p><p>We just disagree here and I am confident you are wrong, but I will bring this topic up again in August after Swift 3 has been released.<br></p><p>Some literature for you to start with (of course it is not for swift):<br></p><p>* http://www.artima.com/lejava/articles/equality.html (from Martin Odersky et. al. the founder of Scala)<br>* http://www.angelikalanger.com/Articles/JavaSolutions/SecretsOfEquals/Equals.html (from Angelika Langer)<br>* Book: Effective Java (from Joshua Bloch)<br>* Book: Java Puzzler  (from Joshua Bloch)<br> <br>&gt; Am 19.07.2016 um 18:00 schrieb Félix Cloutier &lt;felixcca at yahoo.ca&gt;:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; This minor enhancement could most likely be obtained by just having a default ==, which is a project that I can get behind.<br>&gt;&gt; <br>&gt;&gt; Structs do not have a common ancestor, this is why swift uses existential containers, in order to create polymorphic behavior for protocol types with value type implementations. So implementing such a default == would bring changes to swift either. But I didn’t bring this idea in the first place to have some more convenience. I am sure (and literature as well as my experience as a developer and project lead in many industrial projects proves me right), that implementing equality is a major source of errors in software development and I think that you underestimate this issue.<br>&gt; <br>&gt; Please do point me to that literature that shows that developers frequently misimplement their own comparators.<br></p><p>See above. We are talking about equality (Equatable) not about comparison (i.e. Comparable or in mathematics &lt;=), so the example literature is about the former (although implementing Comparable is error-prone, too).<br></p><p>&gt; No, they can&#39;t. There is no way to differentiate a char array that should be a null-terminated string from a char array that is actually a byte array at the C level.<br></p><p>There is a feature/paradigm/whatever called in-/outboxing and coercing. On that level of abstraction (as long as you know what is underlying and for C structs the default is null-termination) you can just decide, which comparison should be used… if not, you couldn’t call `size` or `length` on them, too.<br></p><p>&gt; This sounds like piling on more work for the sake of it. If we end up forcing a default equality check on everything, I hope that we can at least rely on it being there all the time, because otherwise that will also be a bug vector.<br></p><p>It would be part of the compiler, that is as if you would question whether an instance is created when you call the constructor. You have to trust the compiler to some extend.<br></p><p>All the best<br>Johannes<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposals: (1) Forbidding custom `==` for value types, (2) `dispatch` keyword, (3) `default`-result for methods with `Self`, and (4) Poor-Mans-Existentials</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>July 19, 2016 at 09:00:00pm</p></header><div class="content"><p>Allow me to reciprocate the feeling. Java equality isn&#39;t particularly relevant to Swift equality, and the majority of issues are already solved. Here&#39;s a breakdown of the first link that you posted:<br>&quot;Defining equals with the wrong signature.&quot; Impossible in Swift.&quot;Changing equals without also changing hashCode.&quot; Not addressed by your proposal.&quot;Defining equals in terms of mutable fields.&quot; Only a problem for reference types, which are not addressed by your proposal.&quot;Failing to define equals as an equivalence relation.&quot; The only one which your proposal for structure types actually addresses, and I am skeptical that it needs as much attention as it does in Java.<br>I am still far from convinced.<br> <br></p><p>    On Tuesday, July 19, 2016 9:53 AM, Johannes Neubauer &lt;neubauer at kingsware.de&gt; wrote:<br> <br></p><p> Dear Félix,<br></p><p>We just disagree here and I am confident you are wrong, but I will bring this topic up again in August after Swift 3 has been released.<br></p><p>Some literature for you to start with (of course it is not for swift):<br></p><p>* http://www.artima.com/lejava/articles/equality.html(from Martin Odersky et. al. the founder of Scala)<br>* http://www.angelikalanger.com/Articles/JavaSolutions/SecretsOfEquals/Equals.html(from Angelika Langer)<br>* Book: Effective Java (from Joshua Bloch)<br>* Book: Java Puzzler  (from Joshua Bloch)<br> <br>&gt; Am 19.07.2016 um 18:00 schrieb Félix Cloutier &lt;felixcca at yahoo.ca&gt;:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; This minor enhancement could most likely be obtained by just having a default ==, which is a project that I can get behind.<br>&gt;&gt; <br>&gt;&gt; Structs do not have a common ancestor, this is why swift uses existential containers, in order to create polymorphic behavior for protocol types with value type implementations. So implementing such a default == would bring changes to swift either. But I didn’t bring this idea in the first place to have some more convenience. I am sure (and literature as well as my experience as a developer and project lead in many industrial projects proves me right), that implementing equality is a major source of errors in software development and I think that you underestimate this issue.<br>&gt; <br>&gt; Please do point me to that literature that shows that developers frequently misimplement their own comparators.<br></p><p>See above. We are talking about equality (Equatable) not about comparison (i.e. Comparable or in mathematics &lt;=), so the example literature is about the former (although implementing Comparable is error-prone, too).<br></p><p>&gt; No, they can&#39;t. There is no way to differentiate a char array that should be a null-terminated string from a char array that is actually a byte array at the C level.<br></p><p>There is a feature/paradigm/whatever called in-/outboxing and coercing. On that level of abstraction (as long as you know what is underlying and for C structs the default is null-termination) you can just decide, which comparison should be used… if not, you couldn’t call `size` or `length` on them, too.<br></p><p>&gt; This sounds like piling on more work for the sake of it. If we end up forcing a default equality check on everything, I hope that we can at least rely on it being there all the time, because otherwise that will also be a bug vector.<br></p><p>It would be part of the compiler, that is as if you would question whether an instance is created when you call the constructor. You have to trust the compiler to some extend.<br></p><p>All the best<br>Johannes<br></p><p><br>  <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160719/a018ed1b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
