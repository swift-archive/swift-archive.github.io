<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/907ffad30f9e593c9e0b76b4cb700edb?s=50"></div><header><strong>Specify type of a delegate which conforms to a protocol</strong> from <string>Inder Kumar Rathore .</string> &lt;rathore619 at gmail.com&gt;<p>February  9, 2016 at 08:00:00pm</p></header><div class="content"><p>Hi All,<br>I used to do this in Obj-C but I&#39;m unable to do this in swift<br></p><p>*UIViewController&lt;MyProtocol&gt; *delegate;*<br></p><p>I posted this question on dev forums but didn&#39;t get the solution and<br>finally I&#39;m reporting here so that It can be added as a features in the<br>coming releases.<br></p><p>Thanks<br></p><p>Rathore<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/b7fdb128/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9ae1f2ed10d2ef77cce06bbb5a2dcf7e?s=50"></div><header><strong>Specify type of a delegate which conforms to a protocol</strong> from <string>Alex Hoppen</string> &lt;alex at ateamer.de&gt;<p>February  9, 2016 at 07:00:00pm</p></header><div class="content"><p>At the moment you can achieve the same effect using the following construction (at least that’s what I used):<br></p><p>protocol UIViewControllerProtocol {} // Make sure only UIViewController conforms to this protocol<br></p><p>extension UIViewController: UIViewControllerProtocol {}<br></p><p>protocol MyProtocol {}<br></p><p>let myVar: protocol&lt;UIViewControllerProtocol, MyProtocol&gt;<br></p><p>It’s obviously far longer and less obvious but I hope it at least solves your issue for now.<br></p><p>- Alex<br></p><p>&gt; On 09 Feb 2016, at 15:58, Inder Kumar Rathore . via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi All,<br>&gt; I used to do this in Obj-C but I&#39;m unable to do this in swift<br>&gt; <br>&gt; UIViewController&lt;MyProtocol&gt; *delegate;<br>&gt; <br>&gt; I posted this question on dev forums but didn&#39;t get the solution and finally I&#39;m reporting here so that It can be added as a features in the coming releases.<br>&gt; <br>&gt; Thanks<br>&gt; <br>&gt; Rathore<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/0941a804/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Specify type of a delegate which conforms to a protocol</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>February 10, 2016 at 12:00:00pm</p></header><div class="content"><p>The way to declare conformance to multiple protocols always seemed odd to me:<br></p><p>- It looks like protocol is a generic class, but generics always have a fixed number of parameters<br>- By convention, all types have to start with uppercase (besides protocol, there is at least another exception: Restricting protocols to reference types via &quot;class&quot;)<br></p><p>So, I definitely think there is room for improvement here… how about recycling the inheritance syntax?<br></p><p>let controller: (UIViewController, UITableViewDatasource)<br></p><p>I added the braces because it would be really when you add the question mark for an optional value; an alternative for this case would be<br></p><p>let controller: Optional&lt;UIViewController, UITableViewDatasource&gt;<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Specify type of a delegate which conforms to a protocol</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 10, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; So, I definitely think there is room for improvement here… how about recycling the inheritance syntax?<br>&gt; <br>&gt; let controller: (UIViewController, UITableViewDatasource)<br></p><p>This declares a tuple containing a UIViewController and a UITableViewDataSource.<br></p><p>&gt; I added the braces because it would be really when you add the question mark for an optional value; an alternative for this case would be<br>&gt; <br>&gt; let controller: Optional&lt;UIViewController, UITableViewDatasource&gt;<br></p><p>This attempts to declare an optional with two generic types, which doesn&#39;t work because Optional only has one type parameter. (But other types, like Dictionary, *do* take two type parameters.)<br></p><p>Swift does already have a syntax for declaring that a type must conform to two (or more!) protocols:<br></p><p>	let controller: protocol&lt;UITableViewDataSource, UITableViewDelegate&gt;<br></p><p>I think this could probably be extended to support one class type as well, perhaps with a new name:<br></p><p>	let controller: all&lt;UIViewController, UITableViewDataSource&gt;<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Specify type of a delegate which conforms to a protocol</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>February 10, 2016 at 02:00:00pm</p></header><div class="content"><p>In the thread &quot;Partially constrained protocols&quot; we have discussed a similar approach using where clauses:<br></p><p>        protocol&lt;MyProtocol where Self: UIViewController&gt;<br></p><p>- Maximilian<br></p><p>Am 10.02.2016 um 14:00 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p>&gt;&gt; So, I definitely think there is room for improvement here… how about recycling the inheritance syntax?<br>&gt;&gt; <br>&gt;&gt; let controller: (UIViewController, UITableViewDatasource)<br>&gt; <br>&gt; This declares a tuple containing a UIViewController and a UITableViewDataSource.<br>&gt; <br>&gt;&gt; I added the braces because it would be really when you add the question mark for an optional value; an alternative for this case would be<br>&gt;&gt; <br>&gt;&gt; let controller: Optional&lt;UIViewController, UITableViewDatasource&gt;<br>&gt; <br>&gt; This attempts to declare an optional with two generic types, which doesn&#39;t work because Optional only has one type parameter. (But other types, like Dictionary, *do* take two type parameters.)<br>&gt; <br>&gt; Swift does already have a syntax for declaring that a type must conform to two (or more!) protocols:<br>&gt; <br>&gt;    let controller: protocol&lt;UITableViewDataSource, UITableViewDelegate&gt;<br>&gt; <br>&gt; I think this could probably be extended to support one class type as well, perhaps with a new name:<br>&gt; <br>&gt;    let controller: all&lt;UIViewController, UITableViewDataSource&gt;<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>Specify type of a delegate which conforms to a protocol</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>February 10, 2016 at 01:00:00pm</p></header><div class="content"><p>I agree with everything Brent just said.<br>My question would then be: how does this extend?<br></p><p>Continuing the example:<br>&#39;typealias ViewControllerTableViewDataSource = all&lt;UIViewController,<br>UITableViewDataSource&gt;&#39;<br></p><p>It should then be possible to have a subtype of this which also conforms to<br>UITableViewDelegate.<br>So, given the above, this would work:<br>&#39;typealias ViewControllerTableViewPackage = all&lt;UIViewController,<br>UITableViewDataSource, UITableViewDelegate&gt;&#39;.<br>Would this also work?<br>&#39;typealias ViewControllerTableViewPackage =<br>all&lt;ViewControllerTableViewDataSource, UITableViewDelegate&gt;&#39;<br>Assuming someone defined this typealias: &#39;typealias TableViewPackage =<br>protocol&lt;UITableViewDataSource, UITableViewDelegate&gt;&#39;, would the above also<br>be equivalent to this?:<br>&#39;typealias ViewControllerTableViewPackage = all&lt;UIViewController,<br>TableViewPackage&gt;&#39;<br></p><p>The TableViewPackage protocol, defined above, is considered by Swift to be<br>a &#39;non-nominal type&#39;. Thus this is illegal:<br>&#39;extension TableViewPackage&#39;<br>(I don&#39;t know why. Perhaps a type conforming to the separate protocols has<br>to opt-in to the combination?)<br></p><p>However, we can have the following:<br>&#39;extension UITableViewDelegate where Self : UITableViewDataSource&#39;<br>&#39;extension UITableViewDelegate where Self : UIViewController&#39;<br>&#39;extension UITableViewDelegate where Self : UIViewController, Self :<br>UITableViewDataSource&#39;<br></p><p>Similarly we can&#39;t currently have this:<br>&#39;extension UIViewController where Self : UITableViewDataSource,<br>UITableViewDelegate&#39;<br>because UIViewController is not a generic type (and this is part of the<br>original complaint).<br></p><p>It would be nice to be able to write this out as: &#39;extension<br>all&lt;UIViewController, UITableViewDataSource, UITableViewDelegate&gt;&#39;, even if<br>it&#39;s just syntactic sugar for &#39;extension UITableViewDelegate where Self :<br>UIViewController, Self : UITableViewDataSource&#39;.<br></p><p>-- Ross<br></p><p><br>On Wed, Feb 10, 2016 at 1:44 PM, Maximilian Hünenberger &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; In the thread &quot;Partially constrained protocols&quot; we have discussed a<br>&gt; similar approach using where clauses:<br>&gt;<br>&gt;         protocol&lt;MyProtocol where Self: UIViewController&gt;<br>&gt;<br>&gt; - Maximilian<br>&gt;<br>&gt; Am 10.02.2016 um 14:00 schrieb Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; &gt;&gt; So, I definitely think there is room for improvement here… how about<br>&gt; recycling the inheritance syntax?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; let controller: (UIViewController, UITableViewDatasource)<br>&gt; &gt;<br>&gt; &gt; This declares a tuple containing a UIViewController and a<br>&gt; UITableViewDataSource.<br>&gt; &gt;<br>&gt; &gt;&gt; I added the braces because it would be really when you add the question<br>&gt; mark for an optional value; an alternative for this case would be<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; let controller: Optional&lt;UIViewController, UITableViewDatasource&gt;<br>&gt; &gt;<br>&gt; &gt; This attempts to declare an optional with two generic types, which<br>&gt; doesn&#39;t work because Optional only has one type parameter. (But other<br>&gt; types, like Dictionary, *do* take two type parameters.)<br>&gt; &gt;<br>&gt; &gt; Swift does already have a syntax for declaring that a type must conform<br>&gt; to two (or more!) protocols:<br>&gt; &gt;<br>&gt; &gt;    let controller: protocol&lt;UITableViewDataSource, UITableViewDelegate&gt;<br>&gt; &gt;<br>&gt; &gt; I think this could probably be extended to support one class type as<br>&gt; well, perhaps with a new name:<br>&gt; &gt;<br>&gt; &gt;    let controller: all&lt;UIViewController, UITableViewDataSource&gt;<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/3088ef14/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Specify type of a delegate which conforms to a protocol</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 11, 2016 at 09:00:00am</p></header><div class="content"><p>Ceylon uses &amp; for intersection types (and | for union types) which I find quite intuitive, meaning a type which conforms to this AND that protocol/type (OR in the case of unions).<br></p><p>It works like expected, i.e.<br>A &amp; B &amp; A == A &amp; B <br></p><p>or<br>typealias A = B &amp; C<br>A &amp; C == B &amp; C<br>A &amp; D == B &amp; C &amp; D<br></p><p>class A&lt;T&gt; {<br>        var x: T &amp; B<br>}<br></p><p>var a: A&lt;C&gt;<br>a.x has type C &amp; B<br></p><p>var b: A&lt;B&gt;<br>b.x has type B<br></p><p>etc.<br></p><p>-Thorsten <br></p><p><br>&gt; Am 10.02.2016 um 14:59 schrieb Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I agree with everything Brent just said.<br>&gt; My question would then be: how does this extend?<br>&gt; <br>&gt; Continuing the example:<br>&gt; &#39;typealias ViewControllerTableViewDataSource = all&lt;UIViewController, UITableViewDataSource&gt;&#39;<br>&gt; <br>&gt; It should then be possible to have a subtype of this which also conforms to UITableViewDelegate.<br>&gt; So, given the above, this would work:<br>&gt; &#39;typealias ViewControllerTableViewPackage = all&lt;UIViewController, UITableViewDataSource, UITableViewDelegate&gt;&#39;.<br>&gt; Would this also work?<br>&gt; &#39;typealias ViewControllerTableViewPackage = all&lt;ViewControllerTableViewDataSource, UITableViewDelegate&gt;&#39;<br>&gt; Assuming someone defined this typealias: &#39;typealias TableViewPackage = protocol&lt;UITableViewDataSource, UITableViewDelegate&gt;&#39;, would the above also be equivalent to this?:<br>&gt; &#39;typealias ViewControllerTableViewPackage = all&lt;UIViewController, TableViewPackage&gt;&#39;<br>&gt; <br>&gt; The TableViewPackage protocol, defined above, is considered by Swift to be a &#39;non-nominal type&#39;. Thus this is illegal:<br>&gt; &#39;extension TableViewPackage&#39;<br>&gt; (I don&#39;t know why. Perhaps a type conforming to the separate protocols has to opt-in to the combination?)<br>&gt; <br>&gt; However, we can have the following:<br>&gt; &#39;extension UITableViewDelegate where Self : UITableViewDataSource&#39;<br>&gt; &#39;extension UITableViewDelegate where Self : UIViewController&#39;<br>&gt; &#39;extension UITableViewDelegate where Self : UIViewController, Self : UITableViewDataSource&#39;<br>&gt; <br>&gt; Similarly we can&#39;t currently have this:<br>&gt; &#39;extension UIViewController where Self : UITableViewDataSource, UITableViewDelegate&#39;<br>&gt; because UIViewController is not a generic type (and this is part of the original complaint).<br>&gt; <br>&gt; It would be nice to be able to write this out as: &#39;extension all&lt;UIViewController, UITableViewDataSource, UITableViewDelegate&gt;&#39;, even if it&#39;s just syntactic sugar for &#39;extension UITableViewDelegate where Self : UIViewController, Self : UITableViewDataSource&#39;.<br>&gt; <br>&gt; -- Ross<br>&gt; <br>&gt; <br>&gt;&gt; On Wed, Feb 10, 2016 at 1:44 PM, Maximilian Hünenberger &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; In the thread &quot;Partially constrained protocols&quot; we have discussed a similar approach using where clauses:<br>&gt;&gt; <br>&gt;&gt;         protocol&lt;MyProtocol where Self: UIViewController&gt;<br>&gt;&gt; <br>&gt;&gt; - Maximilian<br>&gt;&gt; <br>&gt;&gt; Am 10.02.2016 um 14:00 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; &gt;&gt; So, I definitely think there is room for improvement here… how about recycling the inheritance syntax?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; let controller: (UIViewController, UITableViewDatasource)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This declares a tuple containing a UIViewController and a UITableViewDataSource.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; I added the braces because it would be really when you add the question mark for an optional value; an alternative for this case would be<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; let controller: Optional&lt;UIViewController, UITableViewDatasource&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This attempts to declare an optional with two generic types, which doesn&#39;t work because Optional only has one type parameter. (But other types, like Dictionary, *do* take two type parameters.)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Swift does already have a syntax for declaring that a type must conform to two (or more!) protocols:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;    let controller: protocol&lt;UITableViewDataSource, UITableViewDelegate&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I think this could probably be extended to support one class type as well, perhaps with a new name:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;    let controller: all&lt;UIViewController, UITableViewDataSource&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt; &gt; Architechies<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/27d82da9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Specify type of a delegate which conforms to a protocol</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>February 11, 2016 at 02:00:00pm</p></header><div class="content"><p>I don&#39;t see union and intersection types either in the &quot;goals list&quot; or in the &quot;non-goals list&quot;. Either way it should be a separate proposal.<br></p><p>- Maximilian<br></p><p>&gt; Am 11.02.2016 um 09:29 schrieb Thorsten Seitz &lt;tseitz42 at icloud.com&gt;:<br>&gt; <br>&gt; Ceylon uses &amp; for intersection types (and | for union types) which I find quite intuitive, meaning a type which conforms to this AND that protocol/type (OR in the case of unions).<br>&gt; <br>&gt; It works like expected, i.e.<br>&gt; A &amp; B &amp; A == A &amp; B <br>&gt; <br>&gt; or<br>&gt; typealias A = B &amp; C<br>&gt; A &amp; C == B &amp; C<br>&gt; A &amp; D == B &amp; C &amp; D<br>&gt; <br>&gt; class A&lt;T&gt; {<br>&gt;         var x: T &amp; B<br>&gt; }<br>&gt; <br>&gt; var a: A&lt;C&gt;<br>&gt; a.x has type C &amp; B<br>&gt; <br>&gt; var b: A&lt;B&gt;<br>&gt; b.x has type B<br>&gt; <br>&gt; etc.<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; <br>&gt;&gt; Am 10.02.2016 um 14:59 schrieb Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; I agree with everything Brent just said.<br>&gt;&gt; My question would then be: how does this extend?<br>&gt;&gt; <br>&gt;&gt; Continuing the example:<br>&gt;&gt; &#39;typealias ViewControllerTableViewDataSource = all&lt;UIViewController, UITableViewDataSource&gt;&#39;<br>&gt;&gt; <br>&gt;&gt; It should then be possible to have a subtype of this which also conforms to UITableViewDelegate.<br>&gt;&gt; So, given the above, this would work:<br>&gt;&gt; &#39;typealias ViewControllerTableViewPackage = all&lt;UIViewController, UITableViewDataSource, UITableViewDelegate&gt;&#39;.<br>&gt;&gt; Would this also work?<br>&gt;&gt; &#39;typealias ViewControllerTableViewPackage = all&lt;ViewControllerTableViewDataSource, UITableViewDelegate&gt;&#39;<br>&gt;&gt; Assuming someone defined this typealias: &#39;typealias TableViewPackage = protocol&lt;UITableViewDataSource, UITableViewDelegate&gt;&#39;, would the above also be equivalent to this?:<br>&gt;&gt; &#39;typealias ViewControllerTableViewPackage = all&lt;UIViewController, TableViewPackage&gt;&#39;<br>&gt;&gt; <br>&gt;&gt; The TableViewPackage protocol, defined above, is considered by Swift to be a &#39;non-nominal type&#39;. Thus this is illegal:<br>&gt;&gt; &#39;extension TableViewPackage&#39;<br>&gt;&gt; (I don&#39;t know why. Perhaps a type conforming to the separate protocols has to opt-in to the combination?)<br>&gt;&gt; <br>&gt;&gt; However, we can have the following:<br>&gt;&gt; &#39;extension UITableViewDelegate where Self : UITableViewDataSource&#39;<br>&gt;&gt; &#39;extension UITableViewDelegate where Self : UIViewController&#39;<br>&gt;&gt; &#39;extension UITableViewDelegate where Self : UIViewController, Self : UITableViewDataSource&#39;<br>&gt;&gt; <br>&gt;&gt; Similarly we can&#39;t currently have this:<br>&gt;&gt; &#39;extension UIViewController where Self : UITableViewDataSource, UITableViewDelegate&#39;<br>&gt;&gt; because UIViewController is not a generic type (and this is part of the original complaint).<br>&gt;&gt; <br>&gt;&gt; It would be nice to be able to write this out as: &#39;extension all&lt;UIViewController, UITableViewDataSource, UITableViewDelegate&gt;&#39;, even if it&#39;s just syntactic sugar for &#39;extension UITableViewDelegate where Self : UIViewController, Self : UITableViewDataSource&#39;.<br>&gt;&gt; <br>&gt;&gt; -- Ross<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Wed, Feb 10, 2016 at 1:44 PM, Maximilian Hünenberger &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; In the thread &quot;Partially constrained protocols&quot; we have discussed a similar approach using where clauses:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         protocol&lt;MyProtocol where Self: UIViewController&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Maximilian<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 10.02.2016 um 14:00 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; So, I definitely think there is room for improvement here… how about recycling the inheritance syntax?<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; let controller: (UIViewController, UITableViewDatasource)<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; This declares a tuple containing a UIViewController and a UITableViewDataSource.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; I added the braces because it would be really when you add the question mark for an optional value; an alternative for this case would be<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; let controller: Optional&lt;UIViewController, UITableViewDatasource&gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; This attempts to declare an optional with two generic types, which doesn&#39;t work because Optional only has one type parameter. (But other types, like Dictionary, *do* take two type parameters.)<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Swift does already have a syntax for declaring that a type must conform to two (or more!) protocols:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;    let controller: protocol&lt;UITableViewDataSource, UITableViewDelegate&gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I think this could probably be extended to support one class type as well, perhaps with a new name:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;    let controller: all&lt;UIViewController, UITableViewDataSource&gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt;&gt; &gt; Architechies<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/8185b45d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>Specify type of a delegate which conforms to a protocol</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>February 11, 2016 at 01:00:00pm</p></header><div class="content"><p>I think this proposal should stick to the intersection type: a type which<br>inherits from at most one class (multiple inheritance should definitely be<br>a separate proposal) if it conforms to all of one or more specified<br>protocols.<br></p><p>The immediate problem I see with a union type is using it. If I&#39;m<br>understanding it right, this would let me define a union type of<br>any&lt;UITextView, UITextField&gt;, to a variable &#39;textControl&#39;. I might then be<br>able to set &#39;textControl.text&#39; to a value, regardless of whether it&#39;s<br>actually a UITextView or UITextField. But the correct way to do this would<br>be to create a protocol (say) &#39;HasTextProperty&#39;, extend UITextView and<br>UITextField to conform to HasTextProperty, and use that. The intersection<br>type would even let us extend the type safety of &#39;textControl&#39; to<br>&#39;all&lt;UIView, HasTextProperty&gt;&#39;.<br></p><p>The next issue I&#39;d see with the union type is that it&#39;s the already<br>proposed Either type.<br></p><p>-- Ross<br></p><p><br>On Thu, Feb 11, 2016 at 1:10 PM, Maximilian Hünenberger &lt;<br>m.huenenberger at me.com&gt; wrote:<br></p><p>&gt; I don&#39;t see union and intersection types either in the &quot;goals list&quot; or in<br>&gt; the &quot;non-goals list&quot;. Either way it should be a separate proposal.<br>&gt;<br>&gt; - Maximilian<br>&gt;<br>&gt; Am 11.02.2016 um 09:29 schrieb Thorsten Seitz &lt;tseitz42 at icloud.com&gt;:<br>&gt;<br>&gt; Ceylon uses &amp; for intersection types (and | for union types) which I find<br>&gt; quite intuitive, meaning a type which conforms to this AND that<br>&gt; protocol/type (OR in the case of unions).<br>&gt;<br>&gt; It works like expected, i.e.<br>&gt; A &amp; B &amp; A == A &amp; B<br>&gt;<br>&gt; or<br>&gt; typealias A = B &amp; C<br>&gt; A &amp; C == B &amp; C<br>&gt; A &amp; D == B &amp; C &amp; D<br>&gt;<br>&gt; class A&lt;T&gt; {<br>&gt;         var x: T &amp; B<br>&gt; }<br>&gt;<br>&gt; var a: A&lt;C&gt;<br>&gt; a.x has type C &amp; B<br>&gt;<br>&gt; var b: A&lt;B&gt;<br>&gt; b.x has type B<br>&gt;<br>&gt; etc.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt; Am 10.02.2016 um 14:59 schrieb Ross O&#39;Brien via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; I agree with everything Brent just said.<br>&gt; My question would then be: how does this extend?<br>&gt;<br>&gt; Continuing the example:<br>&gt; &#39;typealias ViewControllerTableViewDataSource = all&lt;UIViewController,<br>&gt; UITableViewDataSource&gt;&#39;<br>&gt;<br>&gt; It should then be possible to have a subtype of this which also conforms<br>&gt; to UITableViewDelegate.<br>&gt; So, given the above, this would work:<br>&gt; &#39;typealias ViewControllerTableViewPackage = all&lt;UIViewController,<br>&gt; UITableViewDataSource, UITableViewDelegate&gt;&#39;.<br>&gt; Would this also work?<br>&gt; &#39;typealias ViewControllerTableViewPackage =<br>&gt; all&lt;ViewControllerTableViewDataSource, UITableViewDelegate&gt;&#39;<br>&gt; Assuming someone defined this typealias: &#39;typealias TableViewPackage =<br>&gt; protocol&lt;UITableViewDataSource, UITableViewDelegate&gt;&#39;, would the above also<br>&gt; be equivalent to this?:<br>&gt; &#39;typealias ViewControllerTableViewPackage = all&lt;UIViewController,<br>&gt; TableViewPackage&gt;&#39;<br>&gt;<br>&gt; The TableViewPackage protocol, defined above, is considered by Swift to be<br>&gt; a &#39;non-nominal type&#39;. Thus this is illegal:<br>&gt; &#39;extension TableViewPackage&#39;<br>&gt; (I don&#39;t know why. Perhaps a type conforming to the separate protocols has<br>&gt; to opt-in to the combination?)<br>&gt;<br>&gt; However, we can have the following:<br>&gt; &#39;extension UITableViewDelegate where Self : UITableViewDataSource&#39;<br>&gt; &#39;extension UITableViewDelegate where Self : UIViewController&#39;<br>&gt; &#39;extension UITableViewDelegate where Self : UIViewController, Self :<br>&gt; UITableViewDataSource&#39;<br>&gt;<br>&gt; Similarly we can&#39;t currently have this:<br>&gt; &#39;extension UIViewController where Self : UITableViewDataSource,<br>&gt; UITableViewDelegate&#39;<br>&gt; because UIViewController is not a generic type (and this is part of the<br>&gt; original complaint).<br>&gt;<br>&gt; It would be nice to be able to write this out as: &#39;extension<br>&gt; all&lt;UIViewController, UITableViewDataSource, UITableViewDelegate&gt;&#39;, even if<br>&gt; it&#39;s just syntactic sugar for &#39;extension UITableViewDelegate where Self :<br>&gt; UIViewController, Self : UITableViewDataSource&#39;.<br>&gt;<br>&gt; -- Ross<br>&gt;<br>&gt;<br>&gt; On Wed, Feb 10, 2016 at 1:44 PM, Maximilian Hünenberger &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; In the thread &quot;Partially constrained protocols&quot; we have discussed a<br>&gt;&gt; similar approach using where clauses:<br>&gt;&gt;<br>&gt;&gt;         protocol&lt;MyProtocol where Self: UIViewController&gt;<br>&gt;&gt;<br>&gt;&gt; - Maximilian<br>&gt;&gt;<br>&gt;&gt; Am 10.02.2016 um 14:00 schrieb Brent Royal-Gordon via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt; &gt;&gt; So, I definitely think there is room for improvement here… how about<br>&gt;&gt; recycling the inheritance syntax?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; let controller: (UIViewController, UITableViewDatasource)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This declares a tuple containing a UIViewController and a<br>&gt;&gt; UITableViewDataSource.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; I added the braces because it would be really when you add the<br>&gt;&gt; question mark for an optional value; an alternative for this case would be<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; let controller: Optional&lt;UIViewController, UITableViewDatasource&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This attempts to declare an optional with two generic types, which<br>&gt;&gt; doesn&#39;t work because Optional only has one type parameter. (But other<br>&gt;&gt; types, like Dictionary, *do* take two type parameters.)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Swift does already have a syntax for declaring that a type must conform<br>&gt;&gt; to two (or more!) protocols:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;    let controller: protocol&lt;UITableViewDataSource, UITableViewDelegate&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I think this could probably be extended to support one class type as<br>&gt;&gt; well, perhaps with a new name:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;    let controller: all&lt;UIViewController, UITableViewDataSource&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Brent Royal-Gordon<br>&gt;&gt; &gt; Architechies<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/558f2d86/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Specify type of a delegate which conforms to a protocol</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February 11, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On 2016-02-11, at 20:38:21, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think this proposal should stick to the intersection type: a type which inherits from at most one class (multiple inheritance should definitely be a separate proposal) if it conforms to all of one or more specified protocols.<br>&gt; <br>&gt; The next issue I&#39;d see with the union type is that it&#39;s the already proposed Either type.<br>&gt; <br>&gt; — Ross<br></p><p>Actually, no the union type has not been proposed.  It has been slightly talked about in the Either type discussion.  Either was a simple implementation that could do 80% of the use cases of type unions would allow (with 1% of the work :p).  <br></p><p>Whereas, union and intersection types are basically making changes to the type system itself — is it not?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>Specify type of a delegate which conforms to a protocol</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>February 11, 2016 at 01:00:00pm</p></header><div class="content"><p>Apologies.<br>For the sake of clarity: I had understood the term &#39;intersection type&#39; to<br>be referring to the concept in the original post of this thread - a type<br>which conforms to one type and all of a given collection of protocols (i.e.<br>to be a valid value of this type an instance must conform to the<br>intersection of all of these things), and a &#39;union type&#39; to conform to one<br>option in each series of options in a type.<br>e.g. if a type is a subclass of UIViewController and conforms to<br>UITableViewDataSource then - according to my misunderstanding - it would be<br>an eligible value for a variable of &quot;intersection type&quot;<br>all&lt;UIViewController, UITableViewDataSource&gt;, whereas if it conforms to<br>either UITableViewDataSource OR UITableViewDelegate then it would be<br>eligible for a variable of &quot;union type&quot; any&lt;UIViewController,<br>(UITableViewDataSource | UITableViewDelegate)&gt;. I got confused by the<br>terminology used in the thread (it sounded good).<br></p><p>So, to rephrase (hopefully) more correctly:<br>I think this proposal should stick with the &#39;all&#39; type: a type which<br>inherits from at most one class and conforms to all of a specified<br>collection of protocols.<br></p><p>&#39;any&#39;, intersection types, union types, and Either should be a different<br>proposal.<br></p><p>On Thu, Feb 11, 2016 at 1:45 PM, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On 2016-02-11, at 20:38:21, Ross O&#39;Brien via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I think this proposal should stick to the intersection type: a type<br>&gt; which inherits from at most one class (multiple inheritance should<br>&gt; definitely be a separate proposal) if it conforms to all of one or more<br>&gt; specified protocols.<br>&gt; &gt;<br>&gt; &gt; The next issue I&#39;d see with the union type is that it&#39;s the already<br>&gt; proposed Either type.<br>&gt; &gt;<br>&gt; &gt; — Ross<br>&gt;<br>&gt; Actually, no the union type has not been proposed.  It has been slightly<br>&gt; talked about in the Either type discussion.  Either was a simple<br>&gt; implementation that could do 80% of the use cases of type unions would<br>&gt; allow (with 1% of the work :p).<br>&gt;<br>&gt; Whereas, union and intersection types are basically making changes to the<br>&gt; type system itself — is it not?<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/d97d8436/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Specify type of a delegate which conforms to a protocol</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 11, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Am 11.02.2016 um 14:56 schrieb Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Apologies.<br>&gt; For the sake of clarity: I had understood the term &#39;intersection type&#39; to be referring to the concept in the original post of this thread - a type which conforms to one type and all of a given collection of protocols (i.e. to be a valid value of this type an instance must conform to the intersection of all of these things), and a &#39;union type&#39; to conform to one option in each series of options in a type.<br></p><p>That is correct. No misunderstanding there as far as I can see.<br></p><p><br>&gt; e.g. if a type is a subclass of UIViewController and conforms to UITableViewDataSource then - according to my misunderstanding - it would be an eligible value for a variable of &quot;intersection type&quot; all&lt;UIViewController, UITableViewDataSource&gt;, whereas if it conforms to either UITableViewDataSource OR UITableViewDelegate then it would be eligible for a variable of &quot;union type&quot; any&lt;UIViewController, (UITableViewDataSource | UITableViewDelegate)&gt;.<br></p><p>That’s exactly my understanding, too.<br></p><p>See http://ceylon-lang.org/documentation/tour/types/ for details of how this works in Ceylon’s type system.<br></p><p><br>&gt; I got confused by the terminology used in the thread (it sounded good).<br>&gt; <br>&gt; So, to rephrase (hopefully) more correctly:<br>&gt; I think this proposal should stick with the &#39;all&#39; type: a type which inherits from at most one class and conforms to all of a specified collection of protocols.<br></p><p>This won’t work for a tuple:<br></p><p>let a: A<br>let b: B<br>let t: (A, B) = (a, b)<br></p><p>t[i] has type A | B, as I will either get something conforming to A or to B, depending on the value of i. It would be necessary to switch on the type to do something with it, similar to unwrapping an optional (actually optionals in Ceylon are not wrappers but type unions of the given type T with the Nil type: T | Nil).<br>if t[i] had type A &amp; B this would mean that I can use any method of A and any method of B which will not work<br></p><p>I think you meant the third case for which I don’t have a technical term: a type containing the intersection of the methods (properties …) of A and B. That is not an intersection type as the term is used in Ceylon, but the term „intersection“ is certainly confusing here.<br></p><p><br>&gt; &#39;any&#39;, intersection types, union types, and Either should be a different proposal.<br></p><p>Either is different from union types like Craig already explained.<br></p><p>-Thorsten<br></p><p><br>&gt; On Thu, Feb 11, 2016 at 1:45 PM, Craig Cruden &lt;ccruden at novafore.com &lt;mailto:ccruden at novafore.com&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On 2016-02-11, at 20:38:21, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I think this proposal should stick to the intersection type: a type which inherits from at most one class (multiple inheritance should definitely be a separate proposal) if it conforms to all of one or more specified protocols.<br>&gt; &gt;<br>&gt; &gt; The next issue I&#39;d see with the union type is that it&#39;s the already proposed Either type.<br>&gt; &gt;<br>&gt; &gt; — Ross<br>&gt; <br>&gt; Actually, no the union type has not been proposed.  It has been slightly talked about in the Either type discussion.  Either was a simple implementation that could do 80% of the use cases of type unions would allow (with 1% of the work :p).<br>&gt; <br>&gt; Whereas, union and intersection types are basically making changes to the type system itself — is it not?<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/a917a73d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Specify type of a delegate which conforms to a protocol</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>February 10, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt;&gt; So, I definitely think there is room for improvement here… how about recycling the inheritance syntax?<br>&gt;&gt; <br>&gt;&gt; let controller: (UIViewController, UITableViewDatasource)<br>&gt; <br>&gt; This declares a tuple containing a UIViewController and a UITableViewDataSource.<br>right, normal parenthesis are already used...<br></p><p>&gt;&gt; let controller: Optional&lt;UIViewController, UITableViewDatasource&gt;<br>&gt; <br>&gt; This attempts to declare an optional with two generic types, which doesn&#39;t work because Optional only has one type parameter. (But other types, like Dictionary, *do* take two type parameters.)<br>true as well — seems I&#39;ve been quite dozy when I outlined those colliding syntaxes ;-)<br></p><p>However, I don&#39;t like grouping using brackets; how about<br>let controller: Optional&lt;UIViewController &amp; UITableViewDatasource&gt;<br></p><p>As we have inout, the ampersand should still be available — and it would fit nicely with &quot;|&quot; for sum types (although I have no idea wether algebraic data types will be considered in the future)<br></p><p>Tino<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Specify type of a delegate which conforms to a protocol</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 10, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Feb 10, 2016, at 5:00 , Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; So, I definitely think there is room for improvement here… how about recycling the inheritance syntax?<br>&gt;&gt; <br>&gt;&gt; let controller: (UIViewController, UITableViewDatasource)<br>&gt; <br>&gt; This declares a tuple containing a UIViewController and a UITableViewDataSource.<br>&gt; <br>&gt;&gt; I added the braces because it would be really when you add the question mark for an optional value; an alternative for this case would be<br>&gt;&gt; <br>&gt;&gt; let controller: Optional&lt;UIViewController, UITableViewDatasource&gt;<br>&gt; <br>&gt; This attempts to declare an optional with two generic types, which doesn&#39;t work because Optional only has one type parameter. (But other types, like Dictionary, *do* take two type parameters.)<br>&gt; <br>&gt; Swift does already have a syntax for declaring that a type must conform to two (or more!) protocols:<br>&gt; <br>&gt; 	let controller: protocol&lt;UITableViewDataSource, UITableViewDelegate&gt;<br>&gt; <br>&gt; I think this could probably be extended to support one class type as well, perhaps with a new name:<br>&gt; <br>&gt; 	let controller: all&lt;UIViewController, UITableViewDataSource&gt;<br></p><p>We&#39;ve been calling it &quot;any&quot; or &quot;Any&quot; (as in &quot;any instance that is-a UIViewController and is-a UITableViewDataSource&quot;), but I think this is the direction we&#39;ve been talking about over here.<br></p><p>(Not that syntax bikeshedding can&#39;t still be useful.)<br></p><p>Jordan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/907ffad30f9e593c9e0b76b4cb700edb?s=50"></div><header><strong>Specify type of a delegate which conforms to a protocol</strong> from <string>Inder Kumar Rathore .</string> &lt;rathore619 at gmail.com&gt;<p>February 11, 2016 at 12:00:00pm</p></header><div class="content"><p>I&#39;m somewhat convinced with Maximilian<br></p><p>for<br></p><p>*protocol&lt;MyProtocol where Self: UIViewController&gt;*<br></p><p>Brent also has a valid point of having at least one class type in the<br>protocol<br></p><p>protocol&lt;OneClass, OtherProtocol, SomeProtocol&gt;<br></p><p><br>On Wed, Feb 10, 2016 at 10:56 PM, Jordan Rose via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Feb 10, 2016, at 5:00 , Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; So, I definitely think there is room for improvement here… how about<br>&gt; recycling the inheritance syntax?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; let controller: (UIViewController, UITableViewDatasource)<br>&gt; &gt;<br>&gt; &gt; This declares a tuple containing a UIViewController and a<br>&gt; UITableViewDataSource.<br>&gt; &gt;<br>&gt; &gt;&gt; I added the braces because it would be really when you add the question<br>&gt; mark for an optional value; an alternative for this case would be<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; let controller: Optional&lt;UIViewController, UITableViewDatasource&gt;<br>&gt; &gt;<br>&gt; &gt; This attempts to declare an optional with two generic types, which<br>&gt; doesn&#39;t work because Optional only has one type parameter. (But other<br>&gt; types, like Dictionary, *do* take two type parameters.)<br>&gt; &gt;<br>&gt; &gt; Swift does already have a syntax for declaring that a type must conform<br>&gt; to two (or more!) protocols:<br>&gt; &gt;<br>&gt; &gt;       let controller: protocol&lt;UITableViewDataSource,<br>&gt; UITableViewDelegate&gt;<br>&gt; &gt;<br>&gt; &gt; I think this could probably be extended to support one class type as<br>&gt; well, perhaps with a new name:<br>&gt; &gt;<br>&gt; &gt;       let controller: all&lt;UIViewController, UITableViewDataSource&gt;<br>&gt;<br>&gt; We&#39;ve been calling it &quot;any&quot; or &quot;Any&quot; (as in &quot;any instance that is-a<br>&gt; UIViewController and is-a UITableViewDataSource&quot;), but I think this is the<br>&gt; direction we&#39;ve been talking about over here.<br>&gt;<br>&gt; (Not that syntax bikeshedding can&#39;t still be useful.)<br>&gt;<br>&gt; Jordan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Best regards,<br>Inder Kumar Rathore<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/f602a1b6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Specify type of a delegate which conforms to a protocol</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 11, 2016 at 09:00:00am</p></header><div class="content"><p>Jordan, I&#39;m not sure if I understood you correctly, do you mean to use  <br></p><p>    all&lt;A, B&gt; for intersection types (Ceylon&#39;s A &amp; B), i.e. a type conforming to all listed types <br>    any&lt;A, B&gt; for union types  (Ceylon&#39;s A | B), i.e. a type conforming to any of the listed types<br></p><p>That would be fine, too, I think, while a bit heavier than Ceylon&#39;s syntax (though I seem to remember from another thread that there was a problem with using Ceylon&#39;s syntax in Swift, though the reason escapes me at the moment).<br></p><p>-Thorsten <br></p><p>&gt; Am 10.02.2016 um 18:26 schrieb Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Feb 10, 2016, at 5:00 , Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, I definitely think there is room for improvement here… how about recycling the inheritance syntax?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let controller: (UIViewController, UITableViewDatasource)<br>&gt;&gt; <br>&gt;&gt; This declares a tuple containing a UIViewController and a UITableViewDataSource.<br>&gt;&gt; <br>&gt;&gt;&gt; I added the braces because it would be really when you add the question mark for an optional value; an alternative for this case would be<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let controller: Optional&lt;UIViewController, UITableViewDatasource&gt;<br>&gt;&gt; <br>&gt;&gt; This attempts to declare an optional with two generic types, which doesn&#39;t work because Optional only has one type parameter. (But other types, like Dictionary, *do* take two type parameters.)<br>&gt;&gt; <br>&gt;&gt; Swift does already have a syntax for declaring that a type must conform to two (or more!) protocols:<br>&gt;&gt; <br>&gt;&gt;    let controller: protocol&lt;UITableViewDataSource, UITableViewDelegate&gt;<br>&gt;&gt; <br>&gt;&gt; I think this could probably be extended to support one class type as well, perhaps with a new name:<br>&gt;&gt; <br>&gt;&gt;    let controller: all&lt;UIViewController, UITableViewDataSource&gt;<br>&gt; <br>&gt; We&#39;ve been calling it &quot;any&quot; or &quot;Any&quot; (as in &quot;any instance that is-a UIViewController and is-a UITableViewDataSource&quot;), but I think this is the direction we&#39;ve been talking about over here.<br>&gt; <br>&gt; (Not that syntax bikeshedding can&#39;t still be useful.)<br>&gt; <br>&gt; Jordan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Specify type of a delegate which conforms to a protocol</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 11, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 11 Feb 2016, at 08:39, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Jordan, I&#39;m not sure if I understood you correctly, do you mean to use  <br>&gt; <br>&gt;    all&lt;A, B&gt; for intersection types (Ceylon&#39;s A &amp; B), i.e. a type conforming to all listed types <br>&gt;    any&lt;A, B&gt; for union types  (Ceylon&#39;s A | B), i.e. a type conforming to any of the listed types<br>&gt; <br>&gt; That would be fine, too, I think, while a bit heavier than Ceylon&#39;s syntax (though I seem to remember from another thread that there was a problem with using Ceylon&#39;s syntax in Swift, though the reason escapes me at the moment).<br>&gt; <br>&gt; -Thorsten<br></p><p>The main conflict for using &amp; and | would be with BitwiseOperationsType, but personally I’m not sure that would be such a big deal, given that many developers may never need to fiddle with values in a bitwise fashion, and use of &amp; or | on type names (rather than variables) seems a clear enough distinction to me.<br></p><p>That said, I prefer the use of all and any instead, as it’s more explicit in its meaning.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Specify type of a delegate which conforms to a protocol</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 11, 2016 at 09:00:00am</p></header><div class="content"><p>No, both Brent and I were proposing replacing the &quot;protocol&quot; in &quot;protocol&lt;UITableViewDelegate, UITableViewDataSource&gt;&quot; with a different word. Brent&#39;s word was &quot;all&quot;, as in &quot;conforms to all of these&quot;; mine (and JoeG&#39;s?) was &quot;any&quot;, as in &quot;any type conforming to these&quot;. So both of them correspond to Ceylon&#39;s &quot;&amp;&quot;.<br></p><p>(The other motivation for &quot;any&quot; or &quot;Any&quot; was by analogy with &#39;AnyObject&#39; and the existing &#39;Any&#39;; the latter simply becomes a short form for &#39;Any&lt;&gt;&#39;.)<br></p><p>With the word &quot;protocol&quot; no longer in the type, we could then extend it to include a single class bound as well as protocol bounds.<br></p><p>Jordan<br></p><p><br>&gt; On Feb 11, 2016, at 0:39 , Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; Jordan, I&#39;m not sure if I understood you correctly, do you mean to use  <br>&gt; <br>&gt;    all&lt;A, B&gt; for intersection types (Ceylon&#39;s A &amp; B), i.e. a type conforming to all listed types <br>&gt;    any&lt;A, B&gt; for union types  (Ceylon&#39;s A | B), i.e. a type conforming to any of the listed types<br>&gt; <br>&gt; That would be fine, too, I think, while a bit heavier than Ceylon&#39;s syntax (though I seem to remember from another thread that there was a problem with using Ceylon&#39;s syntax in Swift, though the reason escapes me at the moment).<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt;&gt; Am 10.02.2016 um 18:26 schrieb Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 10, 2016, at 5:00 , Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So, I definitely think there is room for improvement here… how about recycling the inheritance syntax?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let controller: (UIViewController, UITableViewDatasource)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This declares a tuple containing a UIViewController and a UITableViewDataSource.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I added the braces because it would be really when you add the question mark for an optional value; an alternative for this case would be<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let controller: Optional&lt;UIViewController, UITableViewDatasource&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This attempts to declare an optional with two generic types, which doesn&#39;t work because Optional only has one type parameter. (But other types, like Dictionary, *do* take two type parameters.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift does already have a syntax for declaring that a type must conform to two (or more!) protocols:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   let controller: protocol&lt;UITableViewDataSource, UITableViewDelegate&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this could probably be extended to support one class type as well, perhaps with a new name:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   let controller: all&lt;UIViewController, UITableViewDataSource&gt;<br>&gt;&gt; <br>&gt;&gt; We&#39;ve been calling it &quot;any&quot; or &quot;Any&quot; (as in &quot;any instance that is-a UIViewController and is-a UITableViewDataSource&quot;), but I think this is the direction we&#39;ve been talking about over here.<br>&gt;&gt; <br>&gt;&gt; (Not that syntax bikeshedding can&#39;t still be useful.)<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/7f6bf75e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Specify type of a delegate which conforms to a protocol</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 11, 2016 at 06:00:00pm</p></header><div class="content"><p>Thanks for clarifying! In that case I’d prefer Ceylon’s syntax as it seems to express the ideas with less room for confusion (but this probably belongs into another thread). <br></p><p>-Thorsten<br></p><p><br>&gt; Am 11.02.2016 um 18:38 schrieb Jordan Rose &lt;jordan_rose at apple.com&gt;:<br>&gt; <br>&gt; No, both Brent and I were proposing replacing the &quot;protocol&quot; in &quot;protocol&lt;UITableViewDelegate, UITableViewDataSource&gt;&quot; with a different word. Brent&#39;s word was &quot;all&quot;, as in &quot;conforms to all of these&quot;; mine (and JoeG&#39;s?) was &quot;any&quot;, as in &quot;any type conforming to these&quot;. So both of them correspond to Ceylon&#39;s &quot;&amp;&quot;.<br>&gt; <br>&gt; (The other motivation for &quot;any&quot; or &quot;Any&quot; was by analogy with &#39;AnyObject&#39; and the existing &#39;Any&#39;; the latter simply becomes a short form for &#39;Any&lt;&gt;&#39;.)<br>&gt; <br>&gt; With the word &quot;protocol&quot; no longer in the type, we could then extend it to include a single class bound as well as protocol bounds.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 11, 2016, at 0:39 , Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Jordan, I&#39;m not sure if I understood you correctly, do you mean to use  <br>&gt;&gt; <br>&gt;&gt;    all&lt;A, B&gt; for intersection types (Ceylon&#39;s A &amp; B), i.e. a type conforming to all listed types <br>&gt;&gt;    any&lt;A, B&gt; for union types  (Ceylon&#39;s A | B), i.e. a type conforming to any of the listed types<br>&gt;&gt; <br>&gt;&gt; That would be fine, too, I think, while a bit heavier than Ceylon&#39;s syntax (though I seem to remember from another thread that there was a problem with using Ceylon&#39;s syntax in Swift, though the reason escapes me at the moment).<br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt;&gt; Am 10.02.2016 um 18:26 schrieb Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 10, 2016, at 5:00 , Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So, I definitely think there is room for improvement here… how about recycling the inheritance syntax?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let controller: (UIViewController, UITableViewDatasource)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This declares a tuple containing a UIViewController and a UITableViewDataSource.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I added the braces because it would be really when you add the question mark for an optional value; an alternative for this case would be<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let controller: Optional&lt;UIViewController, UITableViewDatasource&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This attempts to declare an optional with two generic types, which doesn&#39;t work because Optional only has one type parameter. (But other types, like Dictionary, *do* take two type parameters.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift does already have a syntax for declaring that a type must conform to two (or more!) protocols:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   let controller: protocol&lt;UITableViewDataSource, UITableViewDelegate&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think this could probably be extended to support one class type as well, perhaps with a new name:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   let controller: all&lt;UIViewController, UITableViewDataSource&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We&#39;ve been calling it &quot;any&quot; or &quot;Any&quot; (as in &quot;any instance that is-a UIViewController and is-a UITableViewDataSource&quot;), but I think this is the direction we&#39;ve been talking about over here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Not that syntax bikeshedding can&#39;t still be useful.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/528748be/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9ae1f2ed10d2ef77cce06bbb5a2dcf7e?s=50"></div><header><strong>Specify type of a delegate which conforms to a protocol</strong> from <string>Alex Hoppen</string> &lt;alex at ateamer.de&gt;<p>February  9, 2016 at 07:00:00pm</p></header><div class="content"><p>As for a new syntax, I was also thinking about this issue a few days ago and it occurred to me that there are even more types that cannot be properly represented in Swift. For example there is currently no way (that I know of) to create a variable that can contain any enum that is backed by a String. However, these kinds of constraints can easily be specified in generic constraints (the ones in angle brackets). Maybe we could add the same syntax for variables/constants as well so that the code would look something like the following for your issue:<br></p><p>var&lt;T, where T: UIViewController, T: MyProtocol&gt; myVar: T<br></p><p>or for enums backed by a String:<br></p><p>var&lt;T: RawRepresentable where T.RawValue == String&gt; myVar: T<br></p><p>Tell me what you think about it.<br></p><p>- Alex<br></p><p><br>&gt; On 09 Feb 2016, at 15:58, Inder Kumar Rathore . via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi All,<br>&gt; I used to do this in Obj-C but I&#39;m unable to do this in swift<br>&gt; <br>&gt; UIViewController&lt;MyProtocol&gt; *delegate;<br>&gt; <br>&gt; I posted this question on dev forums but didn&#39;t get the solution and finally I&#39;m reporting here so that It can be added as a features in the coming releases.<br>&gt; <br>&gt; Thanks<br>&gt; <br>&gt; Rathore<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/0f433734/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Specify type of a delegate which conforms to a protocol</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>February  9, 2016 at 12:00:00pm</p></header><div class="content"><p>That might solve Inder’s problem, but strictly speaking it doesn’t actually restrict the type to an enum. This struct meets all of RawRepresentable’s requirements:<br>struct Foo : RawRepresentable {<br>    typealias RawValue = String<br>    init?(rawValue: Foo.RawValue) {<br>        return nil<br>    }<br>    var rawValue: RawValue = &quot;bar&quot;<br>}<br></p><p>(Although in practice I can’t think of why that would matter, since you can’t do anything with a RawRepresentable other than get it’s rawValue or call init?(rawValue: String), and neither of those rely on enum features… I’ll stop being pedantic now.)<br></p><p>Anyway, the bigger point is that there’s no way to restrict a generic type to be an enum. I think it’s because there wouldn’t be a way to switch on it (or do other enum-ish things) without knowing all its cases, which requires knowing exactly which type it is, which means it’s no longer a generic type. That’s just a guess, though.<br></p><p>Maybe someone should propose that we allow something like this:<br>func foobar &lt;T, U where T: (case .foo, case .bar)&gt; (value: T) -&gt; U {<br>    switch value {<br>    case .foo: ...<br>    case .bar: ...<br>    }<br>}<br></p><p><br>- Dave Sweeris<br></p><p>&gt; On Feb 9, 2016, at 10:47, Alex Hoppen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As for a new syntax, I was also thinking about this issue a few days ago and it occurred to me that there are even more types that cannot be properly represented in Swift. For example there is currently no way (that I know of) to create a variable that can contain any enum that is backed by a String. However, these kinds of constraints can easily be specified in generic constraints (the ones in angle brackets). Maybe we could add the same syntax for variables/constants as well so that the code would look something like the following for your issue:<br>&gt; <br>&gt; var&lt;T, where T: UIViewController, T: MyProtocol&gt; myVar: T<br>&gt; <br>&gt; or for enums backed by a String:<br>&gt; <br>&gt; var&lt;T: RawRepresentable where T.RawValue == String&gt; myVar: T<br>&gt; <br>&gt; Tell me what you think about it.<br>&gt; <br>&gt; - Alex<br>&gt; <br>&gt; <br>&gt;&gt; On 09 Feb 2016, at 15:58, Inder Kumar Rathore . via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi All,<br>&gt;&gt; I used to do this in Obj-C but I&#39;m unable to do this in swift<br>&gt;&gt; <br>&gt;&gt; UIViewController&lt;MyProtocol&gt; *delegate;<br>&gt;&gt; <br>&gt;&gt; I posted this question on dev forums but didn&#39;t get the solution and finally I&#39;m reporting here so that It can be added as a features in the coming releases.<br>&gt;&gt; <br>&gt;&gt; Thanks<br>&gt;&gt; <br>&gt;&gt; Rathore<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/b261dfdb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9ae1f2ed10d2ef77cce06bbb5a2dcf7e?s=50"></div><header><strong>Specify type of a delegate which conforms to a protocol</strong> from <string>Alex Hoppen</string> &lt;alex at ateamer.de&gt;<p>February  9, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 09 Feb 2016, at 21:00, davesweeris at mac.com wrote:<br>&gt; <br>&gt; That might solve Inder’s problem, but strictly speaking it doesn’t actually restrict the type to an enum. This struct meets all of RawRepresentable’s requirements:<br>&gt; struct Foo : RawRepresentable {<br>&gt;     typealias RawValue = String<br>&gt;     init?(rawValue: Foo.RawValue) {<br>&gt;         return nil<br>&gt;     }<br>&gt;     var rawValue: RawValue = &quot;bar&quot;<br>&gt; }<br>&gt; <br>&gt; (Although in practice I can’t think of why that would matter, since you can’t do anything with a RawRepresentable other than get it’s rawValue or call init?(rawValue: String), and neither of those rely on enum features… I’ll stop being pedantic now.)<br></p><p>OK, your right, maybe my example was badly chosen. RawRepresentable was the first protocol with an associated type that came into my mind. But the same issue applies for a number of protocols as well, e.g. ArrayLiteralConvertible with associated value Element. Apart from the fact that I don’t like not being able to specify all variable types, you may want to use this in practice to store the values of an Array literal and decide later in what kind of data structure you would like to use to hold the values in the long term.<br></p><p>&gt; <br>&gt; Anyway, the bigger point is that there’s no way to restrict a generic type to be an enum. I think it’s because there wouldn’t be a way to switch on it (or do other enum-ish things) without knowing all its cases, which requires knowing exactly which type it is, which means it’s no longer a generic type. That’s just a guess, though.<br>&gt; <br>&gt; Maybe someone should propose that we allow something like this:<br>&gt; func foobar &lt;T, U where T: (case .foo, case .bar)&gt; (value: T) -&gt; U {<br>&gt;     switch value {<br>&gt;     case .foo: ...<br>&gt;     case .bar: ...<br>&gt;     }<br>&gt; }<br>&gt; <br></p><p>If you specify all the cases your enum should have, you could just specify the enum as well. The list would have to be exhaustive anyway so that the compiler can check that all cases have been covered in a switch statement and I can’t think of any reason why it would be useful to have two enums with exactly the same cases.<br></p><p>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; On Feb 9, 2016, at 10:47, Alex Hoppen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As for a new syntax, I was also thinking about this issue a few days ago and it occurred to me that there are even more types that cannot be properly represented in Swift. For example there is currently no way (that I know of) to create a variable that can contain any enum that is backed by a String. However, these kinds of constraints can easily be specified in generic constraints (the ones in angle brackets). Maybe we could add the same syntax for variables/constants as well so that the code would look something like the following for your issue:<br>&gt;&gt; <br>&gt;&gt; var&lt;T, where T: UIViewController, T: MyProtocol&gt; myVar: T<br>&gt;&gt; <br>&gt;&gt; or for enums backed by a String:<br>&gt;&gt; <br>&gt;&gt; var&lt;T: RawRepresentable where T.RawValue == String&gt; myVar: T<br>&gt;&gt; <br>&gt;&gt; Tell me what you think about it.<br>&gt;&gt; <br>&gt;&gt; - Alex<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 09 Feb 2016, at 15:58, Inder Kumar Rathore . via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi All,<br>&gt;&gt;&gt; I used to do this in Obj-C but I&#39;m unable to do this in swift<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; UIViewController&lt;MyProtocol&gt; *delegate;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I posted this question on dev forums but didn&#39;t get the solution and finally I&#39;m reporting here so that It can be added as a features in the coming releases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Rathore<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/c8a56bbf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Specify type of a delegate which conforms to a protocol</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>February  9, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 9, 2016, at 12:16, Alex Hoppen &lt;alex at ateamer.de&gt; wrote:<br>&gt; <br>&gt;&gt; On 09 Feb 2016, at 21:00, davesweeris at mac.com wrote:<br>&gt;&gt; <br>&gt;&gt; That might solve Inder’s problem, but strictly speaking it doesn’t actually restrict the type to an enum. This struct meets all of RawRepresentable’s requirements:<br>&gt;&gt; struct Foo : RawRepresentable {<br>&gt;&gt;     typealias RawValue = String<br>&gt;&gt;     init?(rawValue: Foo.RawValue) {<br>&gt;&gt;         return nil<br>&gt;&gt;     }<br>&gt;&gt;     var rawValue: RawValue = &quot;bar&quot;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; (Although in practice I can’t think of why that would matter, since you can’t do anything with a RawRepresentable other than get it’s rawValue or call init?(rawValue: String), and neither of those rely on enum features… I’ll stop being pedantic now.)<br>&gt; <br>&gt; OK, your right, maybe my example was badly chosen. RawRepresentable was the first protocol with an associated type that came into my mind. But the same issue applies for a number of protocols as well, e.g. ArrayLiteralConvertible with associated value Element. Apart from the fact that I don’t like not being able to specify all variable types, you may want to use this in practice to store the values of an Array literal and decide later in what kind of data structure you would like to use to hold the values in the long term.<br>Your example was not poorly chosen, I was just pointing out that Swift doesn&#39;t currently have a mechanism for explicitly restricting a generic type to *only* being an enum, in the way that you can say &quot;T: class&quot; and then T must be a class (which I think is used so that you know T has reference semantics).<br></p><p>&gt;&gt; Anyway, the bigger point is that there’s no way to restrict a generic type to be an enum. I think it’s because there wouldn’t be a way to switch on it (or do other enum-ish things) without knowing all its cases, which requires knowing exactly which type it is, which means it’s no longer a generic type. That’s just a guess, though.<br>&gt;&gt; <br>&gt;&gt; Maybe someone should propose that we allow something like this:<br>&gt;&gt; func foobar &lt;T, U where T: (case .foo, case .bar)&gt; (value: T) -&gt; U {<br>&gt;&gt;     switch value {<br>&gt;&gt;     case .foo: ...<br>&gt;&gt;     case .bar: ...<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; <br>&gt; If you specify all the cases your enum should have, you could just specify the enum as well. The list would have to be exhaustive anyway so that the compiler can check that all cases have been covered in a switch statement and I can’t think of any reason why it would be useful to have two enums with exactly the same cases.<br>Sorry, I was unclear... I meant T would be restricted to any enum that has *at least* a foo case and a bar case... There could be others, too. Speaking of which, there should have been a &quot;default&quot; in there to handle when &quot;value&quot; is one of T&#39;s potential other cases.<br></p><p>- Dave Sweeris.<br></p><p>Sent from my iPhone<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/7739d365/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
