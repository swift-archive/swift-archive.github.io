<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 16, 2015 at 11:00:00am</p></header><div class="content"><p># Introduction<br></p><p>The stdlib provides functions withUnsafePointer() and withUnsafeMutablePointer() (and plural variants) that take an inout reference and call a block with the UnsafePointer/UnsafeMutablePointer created from the reference.<br></p><p># Problem<br></p><p>withUnsafePointer() can only be used with mutable variables, because those are the only things that can be used with inout &amp;refs. Both functions are also fairly useless, as &amp;x refs can be passed directly to functions taking an UnsafePointer or UnsafeMutablePointer. The existence of the functions mostly just causes people to think they&#39;re necessary when they&#39;re not. The provide no functionality that passing &amp;x refs directly to the functions taking a pointer doesn&#39;t already fulfill.<br></p><p># Solution<br></p><p>Remove the functions from the stdlib. The Swift Book should also be updated to talk about passing an &amp;x ref to a function that takes an UnsafePointer or UnsafeMutablePointer (but of course changes to the book are not covered by the open-source project). Most uses of these functions can probably be replaced with a &amp;x ref directly. If any can&#39;t, they could be replaced with the following equivalent expressions:<br></p><p>{ (ptr: UnsafePointer&lt;Int&gt;) in<br>    // ...<br>}(&amp;x)<br></p><p>or:<br></p><p>withExtendedLifetime(&amp;x) { (ptr: UnsafePointer&lt;Int&gt;) in<br>    // ...<br>}<br></p><p># Detailed Solution<br></p><p>The functions would be marked as unavailable with a message saying to pass &amp;x directly to the function taking a pointer. If it&#39;s feasible to do so, Fix-Its would be introduced for the trivial case of the pointer being used once in the closure as a parameter to a function.<br></p><p>The documentation of UnsafePointer and UnsafeMutablePointer would be edited to include a mention of how &amp;x refs can be passed to functions expecting an UnsafePointer or UnsafeMutablePointer. This way anyone new to the language who encounters those types in the wild will be able to easily see how to create one from a variable.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 16, 2015 at 11:00:00am</p></header><div class="content"><p>Another replacement for withUnsafe[Mutable]Pointer is declaring a nested function of the appropriate type (this is equivalent to the anonymous closure, but perhaps more readable):<br></p><p>func foo(ptr: UnsafePointer&lt;Int&gt;) {<br>    // ...<br>}<br>foo(&amp;x)<br></p><p>-Kevin<br></p><p>On Wed, Dec 16, 2015, at 11:38 AM, Kevin Ballard wrote:<br>&gt; # Introduction<br>&gt; <br>&gt; The stdlib provides functions withUnsafePointer() and withUnsafeMutablePointer() (and plural variants) that take an inout reference and call a block with the UnsafePointer/UnsafeMutablePointer created from the reference.<br>&gt; <br>&gt; # Problem<br>&gt; <br>&gt; withUnsafePointer() can only be used with mutable variables, because those are the only things that can be used with inout &amp;refs. Both functions are also fairly useless, as &amp;x refs can be passed directly to functions taking an UnsafePointer or UnsafeMutablePointer. The existence of the functions mostly just causes people to think they&#39;re necessary when they&#39;re not. The provide no functionality that passing &amp;x refs directly to the functions taking a pointer doesn&#39;t already fulfill.<br>&gt; <br>&gt; # Solution<br>&gt; <br>&gt; Remove the functions from the stdlib. The Swift Book should also be updated to talk about passing an &amp;x ref to a function that takes an UnsafePointer or UnsafeMutablePointer (but of course changes to the book are not covered by the open-source project). Most uses of these functions can probably be replaced with a &amp;x ref directly. If any can&#39;t, they could be replaced with the following equivalent expressions:<br>&gt; <br>&gt; { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt;     // ...<br>&gt; }(&amp;x)<br>&gt; <br>&gt; or:<br>&gt; <br>&gt; withExtendedLifetime(&amp;x) { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt;     // ...<br>&gt; }<br>&gt; <br>&gt; # Detailed Solution<br>&gt; <br>&gt; The functions would be marked as unavailable with a message saying to pass &amp;x directly to the function taking a pointer. If it&#39;s feasible to do so, Fix-Its would be introduced for the trivial case of the pointer being used once in the closure as a parameter to a function.<br>&gt; <br>&gt; The documentation of UnsafePointer and UnsafeMutablePointer would be edited to include a mention of how &amp;x refs can be passed to functions expecting an UnsafePointer or UnsafeMutablePointer. This way anyone new to the language who encounters those types in the wild will be able to easily see how to create one from a variable.<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>December 16, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 1:49 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Another replacement for withUnsafe[Mutable]Pointer is declaring a nested function of the appropriate type (this is equivalent to the anonymous closure, but perhaps more readable):<br>&gt; <br>&gt; func foo(ptr: UnsafePointer&lt;Int&gt;) {<br>&gt;    // ...<br>&gt; }<br>&gt; foo(&amp;x)<br>&gt; <br>&gt; -Kevin<br>&gt; <br>&gt; On Wed, Dec 16, 2015, at 11:38 AM, Kevin Ballard wrote:<br>&gt;&gt; # Introduction<br>&gt;&gt; <br>&gt;&gt; The stdlib provides functions withUnsafePointer() and withUnsafeMutablePointer() (and plural variants) that take an inout reference and call a block with the UnsafePointer/UnsafeMutablePointer created from the reference.<br>&gt;&gt; <br>&gt;&gt; # Problem<br>&gt;&gt; <br>&gt;&gt; withUnsafePointer() can only be used with mutable variables, because those are the only things that can be used with inout &amp;refs. Both functions are also fairly useless, as &amp;x refs can be passed directly to functions taking an UnsafePointer or UnsafeMutablePointer. The existence of the functions mostly just causes people to think they&#39;re necessary when they&#39;re not. The provide no functionality that passing &amp;x refs directly to the functions taking a pointer doesn&#39;t already fulfill.<br>&gt;&gt; <br>&gt;&gt; # Solution<br>&gt;&gt; <br>&gt;&gt; Remove the functions from the stdlib. The Swift Book should also be updated to talk about passing an &amp;x ref to a function that takes an UnsafePointer or UnsafeMutablePointer (but of course changes to the book are not covered by the open-source project). Most uses of these functions can probably be replaced with a &amp;x ref directly. If any can&#39;t, they could be replaced with the following equivalent expressions:<br>&gt;&gt; <br>&gt;&gt; { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt;&gt;    // ...<br>&gt;&gt; }(&amp;x)<br>&gt;&gt; <br>&gt;&gt; or:<br>&gt;&gt; <br>&gt;&gt; withExtendedLifetime(&amp;x) { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt;&gt;    // ...<br>&gt;&gt; }<br></p><p>One thing to keep in mind here is that with*Pointer and friends is also meant to enable one to work around issues with the optimizer if they come up in a convenient manner. I.e. imagine if one is attempting to process an image using a 5d array and for whatever reason, you are not getting the performance you need. Hopefully you would file a bug report and then use with*Pointer for your image processing loop.<br></p><p>My fear about withExtendedLifetime is that the name is a misnomer. You are not extending the lifetime.<br></p><p>&gt;&gt; <br>&gt;&gt; # Detailed Solution<br>&gt;&gt; <br>&gt;&gt; The functions would be marked as unavailable with a message saying to pass &amp;x directly to the function taking a pointer. If it&#39;s feasible to do so, Fix-Its would be introduced for the trivial case of the pointer being used once in the closure as a parameter to a function.<br>&gt;&gt; <br>&gt;&gt; The documentation of UnsafePointer and UnsafeMutablePointer would be edited to include a mention of how &amp;x refs can be passed to functions expecting an UnsafePointer or UnsafeMutablePointer. This way anyone new to the language who encounters those types in the wild will be able to easily see how to create one from a variable.<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>December 16, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 1:54 PM, Michael Gottesman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 16, 2015, at 1:49 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Another replacement for withUnsafe[Mutable]Pointer is declaring a nested function of the appropriate type (this is equivalent to the anonymous closure, but perhaps more readable):<br>&gt;&gt; <br>&gt;&gt; func foo(ptr: UnsafePointer&lt;Int&gt;) {<br>&gt;&gt;   // ...<br>&gt;&gt; }<br>&gt;&gt; foo(&amp;x)<br>&gt;&gt; <br>&gt;&gt; -Kevin<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 16, 2015, at 11:38 AM, Kevin Ballard wrote:<br>&gt;&gt;&gt; # Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The stdlib provides functions withUnsafePointer() and withUnsafeMutablePointer() (and plural variants) that take an inout reference and call a block with the UnsafePointer/UnsafeMutablePointer created from the reference.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Problem<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; withUnsafePointer() can only be used with mutable variables, because those are the only things that can be used with inout &amp;refs. Both functions are also fairly useless, as &amp;x refs can be passed directly to functions taking an UnsafePointer or UnsafeMutablePointer. The existence of the functions mostly just causes people to think they&#39;re necessary when they&#39;re not. The provide no functionality that passing &amp;x refs directly to the functions taking a pointer doesn&#39;t already fulfill.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Remove the functions from the stdlib. The Swift Book should also be updated to talk about passing an &amp;x ref to a function that takes an UnsafePointer or UnsafeMutablePointer (but of course changes to the book are not covered by the open-source project). Most uses of these functions can probably be replaced with a &amp;x ref directly. If any can&#39;t, they could be replaced with the following equivalent expressions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt;&gt;&gt;   // ...<br>&gt;&gt;&gt; }(&amp;x)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; withExtendedLifetime(&amp;x) { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt;&gt;&gt;   // ...<br>&gt;&gt;&gt; }<br>&gt; <br>&gt; One thing to keep in mind here is that with*Pointer and friends is also meant to enable one to work around issues with the optimizer if they come up in a convenient manner. I.e. imagine if one is attempting to process an image using a 5d array and for whatever reason, you are not getting the performance you need. Hopefully you would file a bug report and then use with*Pointer for your image processing loop.<br>&gt; <br>&gt; My fear about withExtendedLifetime is that the name is a misnomer. You are not extending the lifetime.<br></p><p>It sounds to me like what you really want is something like:<br></p><p>with (&amp;x) {<br></p><p>}<br></p><p>which has been spoken about before internally. I do not remember what the result of it is.<br></p><p>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Detailed Solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The functions would be marked as unavailable with a message saying to pass &amp;x directly to the function taking a pointer. If it&#39;s feasible to do so, Fix-Its would be introduced for the trivial case of the pointer being used once in the closure as a parameter to a function.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The documentation of UnsafePointer and UnsafeMutablePointer would be edited to include a mention of how &amp;x refs can be passed to functions expecting an UnsafePointer or UnsafeMutablePointer. This way anyone new to the language who encounters those types in the wild will be able to easily see how to create one from a variable.<br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/c7632ac5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>December 16, 2015 at 01:00:00pm</p></header><div class="content"><p>... *was.<br></p><p>Michael<br></p><p>&gt; On Dec 16, 2015, at 1:57 PM, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 16, 2015, at 1:54 PM, Michael Gottesman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 16, 2015, at 1:49 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another replacement for withUnsafe[Mutable]Pointer is declaring a nested function of the appropriate type (this is equivalent to the anonymous closure, but perhaps more readable):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(ptr: UnsafePointer&lt;Int&gt;) {<br>&gt;&gt;&gt;   // ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; foo(&amp;x)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Kevin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Dec 16, 2015, at 11:38 AM, Kevin Ballard wrote:<br>&gt;&gt;&gt;&gt; # Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The stdlib provides functions withUnsafePointer() and withUnsafeMutablePointer() (and plural variants) that take an inout reference and call a block with the UnsafePointer/UnsafeMutablePointer created from the reference.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; # Problem<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; withUnsafePointer() can only be used with mutable variables, because those are the only things that can be used with inout &amp;refs. Both functions are also fairly useless, as &amp;x refs can be passed directly to functions taking an UnsafePointer or UnsafeMutablePointer. The existence of the functions mostly just causes people to think they&#39;re necessary when they&#39;re not. The provide no functionality that passing &amp;x refs directly to the functions taking a pointer doesn&#39;t already fulfill.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; # Solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Remove the functions from the stdlib. The Swift Book should also be updated to talk about passing an &amp;x ref to a function that takes an UnsafePointer or UnsafeMutablePointer (but of course changes to the book are not covered by the open-source project). Most uses of these functions can probably be replaced with a &amp;x ref directly. If any can&#39;t, they could be replaced with the following equivalent expressions:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt;&gt;&gt;&gt;   // ...<br>&gt;&gt;&gt;&gt; }(&amp;x)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; or:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; withExtendedLifetime(&amp;x) { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt;&gt;&gt;&gt;   // ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; One thing to keep in mind here is that with*Pointer and friends is also meant to enable one to work around issues with the optimizer if they come up in a convenient manner. I.e. imagine if one is attempting to process an image using a 5d array and for whatever reason, you are not getting the performance you need. Hopefully you would file a bug report and then use with*Pointer for your image processing loop.<br>&gt;&gt; <br>&gt;&gt; My fear about withExtendedLifetime is that the name is a misnomer. You are not extending the lifetime.<br>&gt; <br>&gt; It sounds to me like what you really want is something like:<br>&gt; <br>&gt; with (&amp;x) {<br>&gt; <br>&gt; }<br>&gt; <br>&gt; which has been spoken about before internally. I do not remember what the result of it is.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; # Detailed Solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The functions would be marked as unavailable with a message saying to pass &amp;x directly to the function taking a pointer. If it&#39;s feasible to do so, Fix-Its would be introduced for the trivial case of the pointer being used once in the closure as a parameter to a function.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The documentation of UnsafePointer and UnsafeMutablePointer would be edited to include a mention of how &amp;x refs can be passed to functions expecting an UnsafePointer or UnsafeMutablePointer. This way anyone new to the language who encounters those types in the wild will be able to easily see how to create one from a variable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/a0e1ec9d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 16, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 11:54 AM, Michael Gottesman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 16, 2015, at 1:49 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Another replacement for withUnsafe[Mutable]Pointer is declaring a nested function of the appropriate type (this is equivalent to the anonymous closure, but perhaps more readable):<br>&gt;&gt; <br>&gt;&gt; func foo(ptr: UnsafePointer&lt;Int&gt;) {<br>&gt;&gt;   // ...<br>&gt;&gt; }<br>&gt;&gt; foo(&amp;x)<br>&gt;&gt; <br>&gt;&gt; -Kevin<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 16, 2015, at 11:38 AM, Kevin Ballard wrote:<br>&gt;&gt;&gt; # Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The stdlib provides functions withUnsafePointer() and withUnsafeMutablePointer() (and plural variants) that take an inout reference and call a block with the UnsafePointer/UnsafeMutablePointer created from the reference.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Problem<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; withUnsafePointer() can only be used with mutable variables, because those are the only things that can be used with inout &amp;refs. Both functions are also fairly useless, as &amp;x refs can be passed directly to functions taking an UnsafePointer or UnsafeMutablePointer. The existence of the functions mostly just causes people to think they&#39;re necessary when they&#39;re not. The provide no functionality that passing &amp;x refs directly to the functions taking a pointer doesn&#39;t already fulfill.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Remove the functions from the stdlib. The Swift Book should also be updated to talk about passing an &amp;x ref to a function that takes an UnsafePointer or UnsafeMutablePointer (but of course changes to the book are not covered by the open-source project). Most uses of these functions can probably be replaced with a &amp;x ref directly. If any can&#39;t, they could be replaced with the following equivalent expressions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt;&gt;&gt;   // ...<br>&gt;&gt;&gt; }(&amp;x)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; withExtendedLifetime(&amp;x) { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt;&gt;&gt;   // ...<br>&gt;&gt;&gt; }<br>&gt; <br>&gt; One thing to keep in mind here is that with*Pointer and friends is also meant to enable one to work around issues with the optimizer if they come up in a convenient manner. I.e. imagine if one is attempting to process an image using a 5d array and for whatever reason, you are not getting the performance you need. Hopefully you would file a bug report and then use with*Pointer for your image processing loop.<br>&gt; <br>&gt; My fear about withExtendedLifetime is that the name is a misnomer. You are not extending the lifetime.<br></p><p>What makes you say that?  <br></p><p>If in fact it is true, shouldn&#39;t you file a bug report?<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>December 16, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 2:22 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 16, 2015, at 11:54 AM, Michael Gottesman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 16, 2015, at 1:49 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another replacement for withUnsafe[Mutable]Pointer is declaring a nested function of the appropriate type (this is equivalent to the anonymous closure, but perhaps more readable):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(ptr: UnsafePointer&lt;Int&gt;) {<br>&gt;&gt;&gt;  // ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; foo(&amp;x)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Kevin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Dec 16, 2015, at 11:38 AM, Kevin Ballard wrote:<br>&gt;&gt;&gt;&gt; # Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The stdlib provides functions withUnsafePointer() and withUnsafeMutablePointer() (and plural variants) that take an inout reference and call a block with the UnsafePointer/UnsafeMutablePointer created from the reference.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; # Problem<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; withUnsafePointer() can only be used with mutable variables, because those are the only things that can be used with inout &amp;refs. Both functions are also fairly useless, as &amp;x refs can be passed directly to functions taking an UnsafePointer or UnsafeMutablePointer. The existence of the functions mostly just causes people to think they&#39;re necessary when they&#39;re not. The provide no functionality that passing &amp;x refs directly to the functions taking a pointer doesn&#39;t already fulfill.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; # Solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Remove the functions from the stdlib. The Swift Book should also be updated to talk about passing an &amp;x ref to a function that takes an UnsafePointer or UnsafeMutablePointer (but of course changes to the book are not covered by the open-source project). Most uses of these functions can probably be replaced with a &amp;x ref directly. If any can&#39;t, they could be replaced with the following equivalent expressions:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt;&gt;&gt;&gt;  // ...<br>&gt;&gt;&gt;&gt; }(&amp;x)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; or:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; withExtendedLifetime(&amp;x) { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt;&gt;&gt;&gt;  // ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; One thing to keep in mind here is that with*Pointer and friends is also meant to enable one to work around issues with the optimizer if they come up in a convenient manner. I.e. imagine if one is attempting to process an image using a 5d array and for whatever reason, you are not getting the performance you need. Hopefully you would file a bug report and then use with*Pointer for your image processing loop.<br>&gt;&gt; <br>&gt;&gt; My fear about withExtendedLifetime is that the name is a misnomer. You are not extending the lifetime.<br>&gt; <br>&gt; What makes you say that?  <br></p><p>Let me be more specific.<br></p><p>My issue with the name &#39;withExtendedLifetime&#39; is that it is suggestive that the lifetime of &amp;x is being extended in a way that is different from if one just passed off &amp;x to any old function. In reality though, nothing special is happening here implying that the name is misleading. A better name IMO would be something that drops any such implication.<br></p><p>Michael<br></p><p>&gt; <br>&gt; If in fact it is true, shouldn&#39;t you file a bug report?<br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December 16, 2015 at 02:00:00pm</p></header><div class="content"><p>withExtendedLifetime(&amp;x) does extend the lifetime of &amp;x, it just doesn&#39;t<br>extend the lifetime of x.<br></p><p>However, withExtendedLifetime(x) does extend the lifetime of x by holding a<br>strong reference (if it&#39;s a reference type), which can be useful. Maybe<br>withExtendedLifetime should be changed to &lt;T: AnyObject&gt; rather than &lt;T&gt; ?<br></p><p>Jacob<br></p><p>On Wed, Dec 16, 2015 at 2:07 PM, Michael Gottesman via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Dec 16, 2015, at 2:22 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Dec 16, 2015, at 11:54 AM, Michael Gottesman via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On Dec 16, 2015, at 1:49 PM, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Another replacement for withUnsafe[Mutable]Pointer is declaring a<br>&gt; nested function of the appropriate type (this is equivalent to the<br>&gt; anonymous closure, but perhaps more readable):<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; func foo(ptr: UnsafePointer&lt;Int&gt;) {<br>&gt; &gt;&gt;&gt;  // ...<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt; foo(&amp;x)<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; -Kevin<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On Wed, Dec 16, 2015, at 11:38 AM, Kevin Ballard wrote:<br>&gt; &gt;&gt;&gt;&gt; # Introduction<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; The stdlib provides functions withUnsafePointer() and<br>&gt; withUnsafeMutablePointer() (and plural variants) that take an inout<br>&gt; reference and call a block with the UnsafePointer/UnsafeMutablePointer<br>&gt; created from the reference.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; # Problem<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; withUnsafePointer() can only be used with mutable variables, because<br>&gt; those are the only things that can be used with inout &amp;refs. Both functions<br>&gt; are also fairly useless, as &amp;x refs can be passed directly to functions<br>&gt; taking an UnsafePointer or UnsafeMutablePointer. The existence of the<br>&gt; functions mostly just causes people to think they&#39;re necessary when they&#39;re<br>&gt; not. The provide no functionality that passing &amp;x refs directly to the<br>&gt; functions taking a pointer doesn&#39;t already fulfill.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; # Solution<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Remove the functions from the stdlib. The Swift Book should also be<br>&gt; updated to talk about passing an &amp;x ref to a function that takes an<br>&gt; UnsafePointer or UnsafeMutablePointer (but of course changes to the book<br>&gt; are not covered by the open-source project). Most uses of these functions<br>&gt; can probably be replaced with a &amp;x ref directly. If any can&#39;t, they could<br>&gt; be replaced with the following equivalent expressions:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt; &gt;&gt;&gt;&gt;  // ...<br>&gt; &gt;&gt;&gt;&gt; }(&amp;x)<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; or:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; withExtendedLifetime(&amp;x) { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt; &gt;&gt;&gt;&gt;  // ...<br>&gt; &gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; One thing to keep in mind here is that with*Pointer and friends is also<br>&gt; meant to enable one to work around issues with the optimizer if they come<br>&gt; up in a convenient manner. I.e. imagine if one is attempting to process an<br>&gt; image using a 5d array and for whatever reason, you are not getting the<br>&gt; performance you need. Hopefully you would file a bug report and then use<br>&gt; with*Pointer for your image processing loop.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; My fear about withExtendedLifetime is that the name is a misnomer. You<br>&gt; are not extending the lifetime.<br>&gt; &gt;<br>&gt; &gt; What makes you say that?<br>&gt;<br>&gt; Let me be more specific.<br>&gt;<br>&gt; My issue with the name &#39;withExtendedLifetime&#39; is that it is suggestive<br>&gt; that the lifetime of &amp;x is being extended in a way that is different from<br>&gt; if one just passed off &amp;x to any old function. In reality though, nothing<br>&gt; special is happening here implying that the name is misleading. A better<br>&gt; name IMO would be something that drops any such implication.<br>&gt;<br>&gt; Michael<br>&gt;<br>&gt; &gt;<br>&gt; &gt; If in fact it is true, shouldn&#39;t you file a bug report?<br>&gt; &gt;<br>&gt; &gt; -Dave<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/e5446e4b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>December 16, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 4:07 PM, Michael Gottesman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 16, 2015, at 2:22 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 16, 2015, at 11:54 AM, Michael Gottesman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 16, 2015, at 1:49 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another replacement for withUnsafe[Mutable]Pointer is declaring a nested function of the appropriate type (this is equivalent to the anonymous closure, but perhaps more readable):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(ptr: UnsafePointer&lt;Int&gt;) {<br>&gt;&gt;&gt;&gt; // ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; foo(&amp;x)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Kevin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015, at 11:38 AM, Kevin Ballard wrote:<br>&gt;&gt;&gt;&gt;&gt; # Introduction<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The stdlib provides functions withUnsafePointer() and withUnsafeMutablePointer() (and plural variants) that take an inout reference and call a block with the UnsafePointer/UnsafeMutablePointer created from the reference.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; # Problem<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; withUnsafePointer() can only be used with mutable variables, because those are the only things that can be used with inout &amp;refs. Both functions are also fairly useless, as &amp;x refs can be passed directly to functions taking an UnsafePointer or UnsafeMutablePointer. The existence of the functions mostly just causes people to think they&#39;re necessary when they&#39;re not. The provide no functionality that passing &amp;x refs directly to the functions taking a pointer doesn&#39;t already fulfill.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; # Solution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Remove the functions from the stdlib. The Swift Book should also be updated to talk about passing an &amp;x ref to a function that takes an UnsafePointer or UnsafeMutablePointer (but of course changes to the book are not covered by the open-source project). Most uses of these functions can probably be replaced with a &amp;x ref directly. If any can&#39;t, they could be replaced with the following equivalent expressions:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt;&gt;&gt;&gt;&gt; // ...<br>&gt;&gt;&gt;&gt;&gt; }(&amp;x)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; or:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; withExtendedLifetime(&amp;x) { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt;&gt;&gt;&gt;&gt; // ...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One thing to keep in mind here is that with*Pointer and friends is also meant to enable one to work around issues with the optimizer if they come up in a convenient manner. I.e. imagine if one is attempting to process an image using a 5d array and for whatever reason, you are not getting the performance you need. Hopefully you would file a bug report and then use with*Pointer for your image processing loop.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My fear about withExtendedLifetime is that the name is a misnomer. You are not extending the lifetime.<br>&gt;&gt; <br>&gt;&gt; What makes you say that?  <br>&gt; <br>&gt; Let me be more specific.<br>&gt; <br>&gt; My issue with the name &#39;withExtendedLifetime&#39; is that it is suggestive that the lifetime of &amp;x is being extended in a way that is different from if one just passed off &amp;x to any old function. In reality though, nothing special is happening here implying that the name is misleading. A better name IMO would be something that drops any such implication.<br></p><p>For example, we could just use &#39;with&#39; (something that has been suggested for this use case in various blog posts). I.e.:<br></p><p>with(&amp;x) { (ptr: UnsafePointer&lt;Int&gt;) in<br>   ...<br>}<br></p><p>Michael<br></p><p>&gt; <br>&gt; Michael<br>&gt; <br>&gt;&gt; <br>&gt;&gt; If in fact it is true, shouldn&#39;t you file a bug report?<br>&gt;&gt; <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December 16, 2015 at 02:00:00pm</p></header><div class="content"><p>Is there a reason that this couldn&#39;t be made to work?<br></p><p>    let ptr: UnsafePointer&lt;Void&gt; = &amp;x<br></p><p>Jacob<br></p><p>On Wed, Dec 16, 2015 at 2:16 PM, Michael Gottesman via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Dec 16, 2015, at 4:07 PM, Michael Gottesman via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Dec 16, 2015, at 2:22 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Dec 16, 2015, at 11:54 AM, Michael Gottesman via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On Dec 16, 2015, at 1:49 PM, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Another replacement for withUnsafe[Mutable]Pointer is declaring a<br>&gt; nested function of the appropriate type (this is equivalent to the<br>&gt; anonymous closure, but perhaps more readable):<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; func foo(ptr: UnsafePointer&lt;Int&gt;) {<br>&gt; &gt;&gt;&gt;&gt; // ...<br>&gt; &gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt; foo(&amp;x)<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; -Kevin<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On Wed, Dec 16, 2015, at 11:38 AM, Kevin Ballard wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt; # Introduction<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; The stdlib provides functions withUnsafePointer() and<br>&gt; withUnsafeMutablePointer() (and plural variants) that take an inout<br>&gt; reference and call a block with the UnsafePointer/UnsafeMutablePointer<br>&gt; created from the reference.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; # Problem<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; withUnsafePointer() can only be used with mutable variables, because<br>&gt; those are the only things that can be used with inout &amp;refs. Both functions<br>&gt; are also fairly useless, as &amp;x refs can be passed directly to functions<br>&gt; taking an UnsafePointer or UnsafeMutablePointer. The existence of the<br>&gt; functions mostly just causes people to think they&#39;re necessary when they&#39;re<br>&gt; not. The provide no functionality that passing &amp;x refs directly to the<br>&gt; functions taking a pointer doesn&#39;t already fulfill.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; # Solution<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Remove the functions from the stdlib. The Swift Book should also be<br>&gt; updated to talk about passing an &amp;x ref to a function that takes an<br>&gt; UnsafePointer or UnsafeMutablePointer (but of course changes to the book<br>&gt; are not covered by the open-source project). Most uses of these functions<br>&gt; can probably be replaced with a &amp;x ref directly. If any can&#39;t, they could<br>&gt; be replaced with the following equivalent expressions:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt; &gt;&gt;&gt;&gt;&gt; // ...<br>&gt; &gt;&gt;&gt;&gt;&gt; }(&amp;x)<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; or:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; withExtendedLifetime(&amp;x) { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt; &gt;&gt;&gt;&gt;&gt; // ...<br>&gt; &gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; One thing to keep in mind here is that with*Pointer and friends is<br>&gt; also meant to enable one to work around issues with the optimizer if they<br>&gt; come up in a convenient manner. I.e. imagine if one is attempting to<br>&gt; process an image using a 5d array and for whatever reason, you are not<br>&gt; getting the performance you need. Hopefully you would file a bug report and<br>&gt; then use with*Pointer for your image processing loop.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; My fear about withExtendedLifetime is that the name is a misnomer. You<br>&gt; are not extending the lifetime.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; What makes you say that?<br>&gt; &gt;<br>&gt; &gt; Let me be more specific.<br>&gt; &gt;<br>&gt; &gt; My issue with the name &#39;withExtendedLifetime&#39; is that it is suggestive<br>&gt; that the lifetime of &amp;x is being extended in a way that is different from<br>&gt; if one just passed off &amp;x to any old function. In reality though, nothing<br>&gt; special is happening here implying that the name is misleading. A better<br>&gt; name IMO would be something that drops any such implication.<br>&gt;<br>&gt; For example, we could just use &#39;with&#39; (something that has been suggested<br>&gt; for this use case in various blog posts). I.e.:<br>&gt;<br>&gt; with(&amp;x) { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt;    ...<br>&gt; }<br>&gt;<br>&gt; Michael<br>&gt;<br>&gt; &gt;<br>&gt; &gt; Michael<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; If in fact it is true, shouldn&#39;t you file a bug report?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Dave<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/ffaef215/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 16, 2015 at 02:00:00pm</p></header><div class="content"><p>&#39;x&#39; may not have storage at all, either because it fits entirely in registers or because it&#39;s actually a computed property. So this would have to synthesize storage, presumably on the stack. It&#39;s unclear when it&#39;s safe to destroy that storage, too.<br></p><p>Limiting inout-to-pointer conversions to a single call gives a clear start and end for where the pointer is valid, which allows the compiler to do correct cleanup.<br></p><p>Jordan<br></p><p>&gt; On Dec 16, 2015, at 14:25 , Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Is there a reason that this couldn&#39;t be made to work?<br>&gt;     let ptr: UnsafePointer&lt;Void&gt; = &amp;x<br>&gt; <br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Wed, Dec 16, 2015 at 2:16 PM, Michael Gottesman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Dec 16, 2015, at 4:07 PM, Michael Gottesman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Dec 16, 2015, at 2:22 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Dec 16, 2015, at 11:54 AM, Michael Gottesman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On Dec 16, 2015, at 1:49 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Another replacement for withUnsafe[Mutable]Pointer is declaring a nested function of the appropriate type (this is equivalent to the anonymous closure, but perhaps more readable):<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; func foo(ptr: UnsafePointer&lt;Int&gt;) {<br>&gt; &gt;&gt;&gt;&gt; // ...<br>&gt; &gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt; foo(&amp;x)<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; -Kevin<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On Wed, Dec 16, 2015, at 11:38 AM, Kevin Ballard wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt; # Introduction<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; The stdlib provides functions withUnsafePointer() and withUnsafeMutablePointer() (and plural variants) that take an inout reference and call a block with the UnsafePointer/UnsafeMutablePointer created from the reference.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; # Problem<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; withUnsafePointer() can only be used with mutable variables, because those are the only things that can be used with inout &amp;refs. Both functions are also fairly useless, as &amp;x refs can be passed directly to functions taking an UnsafePointer or UnsafeMutablePointer. The existence of the functions mostly just causes people to think they&#39;re necessary when they&#39;re not. The provide no functionality that passing &amp;x refs directly to the functions taking a pointer doesn&#39;t already fulfill.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; # Solution<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Remove the functions from the stdlib. The Swift Book should also be updated to talk about passing an &amp;x ref to a function that takes an UnsafePointer or UnsafeMutablePointer (but of course changes to the book are not covered by the open-source project). Most uses of these functions can probably be replaced with a &amp;x ref directly. If any can&#39;t, they could be replaced with the following equivalent expressions:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt; &gt;&gt;&gt;&gt;&gt; // ...<br>&gt; &gt;&gt;&gt;&gt;&gt; }(&amp;x)<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; or:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; withExtendedLifetime(&amp;x) { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt; &gt;&gt;&gt;&gt;&gt; // ...<br>&gt; &gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; One thing to keep in mind here is that with*Pointer and friends is also meant to enable one to work around issues with the optimizer if they come up in a convenient manner. I.e. imagine if one is attempting to process an image using a 5d array and for whatever reason, you are not getting the performance you need. Hopefully you would file a bug report and then use with*Pointer for your image processing loop.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; My fear about withExtendedLifetime is that the name is a misnomer. You are not extending the lifetime.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; What makes you say that?<br>&gt; &gt;<br>&gt; &gt; Let me be more specific.<br>&gt; &gt;<br>&gt; &gt; My issue with the name &#39;withExtendedLifetime&#39; is that it is suggestive that the lifetime of &amp;x is being extended in a way that is different from if one just passed off &amp;x to any old function. In reality though, nothing special is happening here implying that the name is misleading. A better name IMO would be something that drops any such implication.<br>&gt; <br>&gt; For example, we could just use &#39;with&#39; (something that has been suggested for this use case in various blog posts). I.e.:<br>&gt; <br>&gt; with(&amp;x) { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt;    ...<br>&gt; }<br>&gt; <br>&gt; Michael<br>&gt; <br>&gt; &gt;<br>&gt; &gt; Michael<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; If in fact it is true, shouldn&#39;t you file a bug report?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Dave<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/0c6d4750/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 16, 2015 at 02:00:00pm</p></header><div class="content"><p>If &#39;ptr&#39; is a local variable, then the scope of &#39;ptr&#39; could potentially be used as the lifetime of the referenced memory. That&#39;s still not perfect if &#39;ptr&#39; is escaped and you expect it to remain valid for the longer duration of `x`, though.<br></p><p>-Joe<br></p><p>&gt; On Dec 16, 2015, at 2:38 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &#39;x&#39; may not have storage at all, either because it fits entirely in registers or because it&#39;s actually a computed property. So this would have to synthesize storage, presumably on the stack. It&#39;s unclear when it&#39;s safe to destroy that storage, too.<br>&gt; <br>&gt; Limiting inout-to-pointer conversions to a single call gives a clear start and end for where the pointer is valid, which allows the compiler to do correct cleanup.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt;&gt; On Dec 16, 2015, at 14:25 , Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Is there a reason that this couldn&#39;t be made to work?<br>&gt;&gt;     let ptr: UnsafePointer&lt;Void&gt; = &amp;x<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Jacob<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 16, 2015 at 2:16 PM, Michael Gottesman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; On Dec 16, 2015, at 4:07 PM, Michael Gottesman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Dec 16, 2015, at 2:22 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On Dec 16, 2015, at 11:54 AM, Michael Gottesman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; On Dec 16, 2015, at 1:49 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Another replacement for withUnsafe[Mutable]Pointer is declaring a nested function of the appropriate type (this is equivalent to the anonymous closure, but perhaps more readable):<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; func foo(ptr: UnsafePointer&lt;Int&gt;) {<br>&gt;&gt; &gt;&gt;&gt;&gt; // ...<br>&gt;&gt; &gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt; foo(&amp;x)<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; -Kevin<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; On Wed, Dec 16, 2015, at 11:38 AM, Kevin Ballard wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; # Introduction<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; The stdlib provides functions withUnsafePointer() and withUnsafeMutablePointer() (and plural variants) that take an inout reference and call a block with the UnsafePointer/UnsafeMutablePointer created from the reference.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; # Problem<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; withUnsafePointer() can only be used with mutable variables, because those are the only things that can be used with inout &amp;refs. Both functions are also fairly useless, as &amp;x refs can be passed directly to functions taking an UnsafePointer or UnsafeMutablePointer. The existence of the functions mostly just causes people to think they&#39;re necessary when they&#39;re not. The provide no functionality that passing &amp;x refs directly to the functions taking a pointer doesn&#39;t already fulfill.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; # Solution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Remove the functions from the stdlib. The Swift Book should also be updated to talk about passing an &amp;x ref to a function that takes an UnsafePointer or UnsafeMutablePointer (but of course changes to the book are not covered by the open-source project). Most uses of these functions can probably be replaced with a &amp;x ref directly. If any can&#39;t, they could be replaced with the following equivalent expressions:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; // ...<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; }(&amp;x)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; or:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; withExtendedLifetime(&amp;x) { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; // ...<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; One thing to keep in mind here is that with*Pointer and friends is also meant to enable one to work around issues with the optimizer if they come up in a convenient manner. I.e. imagine if one is attempting to process an image using a 5d array and for whatever reason, you are not getting the performance you need. Hopefully you would file a bug report and then use with*Pointer for your image processing loop.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; My fear about withExtendedLifetime is that the name is a misnomer. You are not extending the lifetime.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; What makes you say that?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Let me be more specific.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; My issue with the name &#39;withExtendedLifetime&#39; is that it is suggestive that the lifetime of &amp;x is being extended in a way that is different from if one just passed off &amp;x to any old function. In reality though, nothing special is happening here implying that the name is misleading. A better name IMO would be something that drops any such implication.<br>&gt;&gt; <br>&gt;&gt; For example, we could just use &#39;with&#39; (something that has been suggested for this use case in various blog posts). I.e.:<br>&gt;&gt; <br>&gt;&gt; with(&amp;x) { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt;&gt;    ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Michael<br>&gt;&gt; <br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Michael<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; If in fact it is true, shouldn&#39;t you file a bug report?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; -Dave<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/34f097a0/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 16, 2015 at 02:00:00pm</p></header><div class="content"><p>On Wed, Dec 16, 2015, at 02:25 PM, Jacob Bandes-Storch via swift-evolution wrote:<br>&gt; Is there a reason that this couldn&#39;t be made to work?  let ptr:<br>&gt; UnsafePointer&lt;Void&gt; = &amp;x<br></p><p><br>Yes. That breaks several parts of the language:<br></p><p>1. Swift semantics allow you to use computed properties and stored<br>   properties interchangeably. That expression there can&#39;t work with<br>   computed properties unless Swift silently creates a temporary that<br>   lives for the entire scope, which would be surprising behavior.<br>2. Swift also aggressively discards values that are no longer used even<br>   if they&#39;re still in scope (at least under optimization; it likely<br>   keeps them around in debug builds so they can be inspected). But<br>   there&#39;s no way for Swift to know how long that pointer is going to be<br>   used for (it could track that variable itself, but what about derived<br>   values?). So any value that&#39;s used in that expression would also have<br>   to have its lifetime extended for the entire scope, which is<br>   surprising behavior.<br>3. The pointer definitely cannot be valid outside of the current scope,<br>   but there&#39;s nothing in that statement to imply this.<br>   withUnsafePointer() taking a scope tells the user that the pointer is<br>   only valid for the scope (otherwise it would just return the<br>   pointer), and similarly the current &amp;x behavior can only be used as a<br>   parameter to a function, which tells the user that it&#39;s only valid<br>   for the duration of that function call.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/83291c0c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 16, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 2:25 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Is there a reason that this couldn&#39;t be made to work?<br>&gt;     let ptr: UnsafePointer&lt;Void&gt; = &amp;x<br>&gt; <br>Yeah, that could be made to work, and give an error if `x` isn&#39;t known to be a stored property.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/9958dc5b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 21, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 2:40 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 16, 2015, at 2:25 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Is there a reason that this couldn&#39;t be made to work?<br>&gt;&gt;     let ptr: UnsafePointer&lt;Void&gt; = &amp;x<br>&gt;&gt; <br>&gt; Yeah, that could be made to work, and give an error if `x` isn&#39;t known to be a stored property.<br></p><p>However, in the face of resilience, that could only be known if x were explicitly declared to be fragile, or within the current module.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/0bb6d592/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 16, 2015 at 01:00:00pm</p></header><div class="content"><p>On Wed, Dec 16, 2015, at 11:54 AM, Michael Gottesman wrote:<br>&gt; <br>&gt; One thing to keep in mind here is that with*Pointer and friends is also meant to enable one to work around issues with the optimizer if they come up in a convenient manner. I.e. imagine if one is attempting to process an image using a 5d array and for whatever reason, you are not getting the performance you need. Hopefully you would file a bug report and then use with*Pointer for your image processing loop.<br></p><p>The cited workarounds should all behave identically to withUnsafePointer() and friends. There&#39;s no special optimization done in withUnsafePointer() that&#39;s relevant. For the array example you cited, you&#39;d actually want to be calling Array.withUnsafeMutableBufferPointer() anyway, as withUnsafePointer() doesn&#39;t do anything useful there.<br></p><p>&gt; My fear about withExtendedLifetime is that the name is a misnomer. You are not extending the lifetime.<br></p><p>I assume you mean that you don&#39;t need to extend the lifetime, rather than that it&#39;s not actually extending anything (because it is, it&#39;s just technically extending the lifetime of the UnsafePointer).<br></p><p>But in a sense it&#39;s actually correct anyway. In the rare case where you need one of these workarounds (e.g. you need to use the pointer several times without it changing, or you need to use a value derived from the pointer while the pointer is still valid), you actually do need to extend the lifetime of the value that was passed by-ref into the function. Swift already ensures the lifetime is valid for the duration of the call because it&#39;s an inout parameter and the function itself is only going to actually keep the pointer alive, but in a broader sense you are saying &quot;keep this value alive for the lifetime of this closure, and give me a pointer to it&quot;.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>December 16, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 3:05 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Dec 16, 2015, at 11:54 AM, Michael Gottesman wrote:<br>&gt;&gt; <br>&gt;&gt; One thing to keep in mind here is that with*Pointer and friends is also meant to enable one to work around issues with the optimizer if they come up in a convenient manner. I.e. imagine if one is attempting to process an image using a 5d array and for whatever reason, you are not getting the performance you need. Hopefully you would file a bug report and then use with*Pointer for your image processing loop.<br>&gt; <br>&gt; The cited workarounds should all behave identically to withUnsafePointer() and friends. There&#39;s no special optimization done in withUnsafePointer() that&#39;s relevant. For the array example you cited, you&#39;d actually want to be calling Array.withUnsafeMutableBufferPointer() anyway, as withUnsafePointer() doesn&#39;t do anything useful there.<br></p><p>The interesting example is that by using withUnsafePointer one can avoid ARC, COW, or Uniqueness Check overhead.<br></p><p>&gt; <br>&gt;&gt; My fear about withExtendedLifetime is that the name is a misnomer. You are not extending the lifetime.<br>&gt; <br>&gt; I assume you mean that you don&#39;t need to extend the lifetime, rather than that it&#39;s not actually extending anything (because it is, it&#39;s just technically extending the lifetime of the UnsafePointer).<br></p><p>No, what I am saying is that withExtendedLifetime implies some sort of special lifetime extension (otherwise, why would one specifically call it out). It is not performing any sort of special lifetime extension, it is just using the normal lifetime extension rules.<br></p><p>&gt; <br>&gt; But in a sense it&#39;s actually correct anyway. In the rare case where you need one of these workarounds (e.g. you need to use the pointer several times without it changing, or you need to use a value derived from the pointer while the pointer is still valid), you actually do need to extend the lifetime of the value that was passed by-ref into the function. Swift already ensures the lifetime is valid for the duration of the call because it&#39;s an inout parameter and the function itself is only going to actually keep the pointer alive, but in a broader sense you are saying &quot;keep this value alive for the lifetime of this closure, and give me a pointer to it&quot;.<br></p><p><br>Michael<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 16, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 14:24 , Michael Gottesman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; My fear about withExtendedLifetime is that the name is a misnomer. You are not extending the lifetime.<br>&gt;&gt; <br>&gt;&gt; I assume you mean that you don&#39;t need to extend the lifetime, rather than that it&#39;s not actually extending anything (because it is, it&#39;s just technically extending the lifetime of the UnsafePointer).<br>&gt; <br>&gt; No, what I am saying is that withExtendedLifetime implies some sort of special lifetime extension (otherwise, why would one specifically call it out). It is not performing any sort of special lifetime extension, it is just using the normal lifetime extension rules.<br></p><p>withExtendedLifetime does extend lifetime: it guarantees that the object will stay alive for the entire body of the closure, rather than being released early by ARC. It&#39;s similar to the &#39;objc_precise_lifetime&#39; attribute in Clang.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/0176d7ca/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 16, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 14:27 , Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 16, 2015, at 14:24 , Michael Gottesman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; My fear about withExtendedLifetime is that the name is a misnomer. You are not extending the lifetime.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I assume you mean that you don&#39;t need to extend the lifetime, rather than that it&#39;s not actually extending anything (because it is, it&#39;s just technically extending the lifetime of the UnsafePointer).<br>&gt;&gt; <br>&gt;&gt; No, what I am saying is that withExtendedLifetime implies some sort of special lifetime extension (otherwise, why would one specifically call it out). It is not performing any sort of special lifetime extension, it is just using the normal lifetime extension rules.<br>&gt; <br>&gt; withExtendedLifetime does extend lifetime: it guarantees that the object will stay alive for the entire body of the closure, rather than being released early by ARC. It&#39;s similar to the &#39;objc_precise_lifetime&#39; attribute in Clang.<br></p><p>Michael explained to me that his comments are referring to Kevin&#39;s proposed (?) new overload of withExtendedLifetime, not the existing overload which takes a value.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/1aecbfa5/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>December 16, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 4:24 PM, Michael Gottesman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 16, 2015, at 3:05 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 16, 2015, at 11:54 AM, Michael Gottesman wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One thing to keep in mind here is that with*Pointer and friends is also meant to enable one to work around issues with the optimizer if they come up in a convenient manner. I.e. imagine if one is attempting to process an image using a 5d array and for whatever reason, you are not getting the performance you need. Hopefully you would file a bug report and then use with*Pointer for your image processing loop.<br>&gt;&gt; <br>&gt;&gt; The cited workarounds should all behave identically to withUnsafePointer() and friends. There&#39;s no special optimization done in withUnsafePointer() that&#39;s relevant. For the array example you cited, you&#39;d actually want to be calling Array.withUnsafeMutableBufferPointer() anyway, as withUnsafePointer() doesn&#39;t do anything useful there.<br>&gt; <br>&gt; The interesting example is that by using withUnsafePointer one can avoid ARC, COW, or Uniqueness Check overhead.<br></p><p>And to be clear, I am just saying that we need some form of this API. I do not care the form that it takes.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; My fear about withExtendedLifetime is that the name is a misnomer. You are not extending the lifetime.<br>&gt;&gt; <br>&gt;&gt; I assume you mean that you don&#39;t need to extend the lifetime, rather than that it&#39;s not actually extending anything (because it is, it&#39;s just technically extending the lifetime of the UnsafePointer).<br>&gt; <br>&gt; No, what I am saying is that withExtendedLifetime implies some sort of special lifetime extension (otherwise, why would one specifically call it out). It is not performing any sort of special lifetime extension, it is just using the normal lifetime extension rules.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; But in a sense it&#39;s actually correct anyway. In the rare case where you need one of these workarounds (e.g. you need to use the pointer several times without it changing, or you need to use a value derived from the pointer while the pointer is still valid), you actually do need to extend the lifetime of the value that was passed by-ref into the function. Swift already ensures the lifetime is valid for the duration of the call because it&#39;s an inout parameter and the function itself is only going to actually keep the pointer alive, but in a broader sense you are saying &quot;keep this value alive for the lifetime of this closure, and give me a pointer to it&quot;.<br>&gt; <br>&gt; <br>&gt; Michael<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 16, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 11:38 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; # Introduction<br>&gt; <br>&gt; The stdlib provides functions withUnsafePointer() and withUnsafeMutablePointer() (and plural variants) that take an inout reference and call a block with the UnsafePointer/UnsafeMutablePointer created from the reference.<br>&gt; <br>&gt; # Problem<br>&gt; <br>&gt; withUnsafePointer() can only be used with mutable variables, because those are the only things that can be used with inout &amp;refs. Both functions are also fairly useless, as &amp;x refs can be passed directly to functions taking an UnsafePointer or UnsafeMutablePointer. The existence of the functions mostly just causes people to think they&#39;re necessary when they&#39;re not. The provide no functionality that passing &amp;x refs directly to the functions taking a pointer doesn&#39;t already fulfill.<br>&gt; <br>&gt; # Solution<br>&gt; <br>&gt; Remove the functions from the stdlib. The Swift Book should also be updated to talk about passing an &amp;x ref to a function that takes an UnsafePointer or UnsafeMutablePointer (but of course changes to the book are not covered by the open-source project). Most uses of these functions can probably be replaced with a &amp;x ref directly. If any can&#39;t, they could be replaced with the following equivalent expressions:<br>&gt; <br>&gt; { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt;    // ...<br>&gt; }(&amp;x)<br>&gt; <br>&gt; or:<br>&gt; <br>&gt; withExtendedLifetime(&amp;x) { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt;    // ...<br>&gt; }<br></p><p>withExtendedLifetime doesn&#39;t have this overload. Adding it would essentially be just renaming withUnsafePointer.<br></p><p>&gt; <br>&gt; # Detailed Solution<br>&gt; <br>&gt; The functions would be marked as unavailable with a message saying to pass &amp;x directly to the function taking a pointer. If it&#39;s feasible to do so, Fix-Its would be introduced for the trivial case of the pointer being used once in the closure as a parameter to a function.<br>&gt; <br>&gt; The documentation of UnsafePointer and UnsafeMutablePointer would be edited to include a mention of how &amp;x refs can be passed to functions expecting an UnsafePointer or UnsafeMutablePointer. This way anyone new to the language who encounters those types in the wild will be able to easily see how to create one from a variable.<br></p><p>I&#39;m against removing the functionality. The magic pointer conversions were only ever intended to make interop with well-behaved C functions easier; it was in my mind that we would eventually constrain the magic pointer conversions to only apply to imported APIs. withUnsafePointer is necessary more often than you think, since the current semantics of the conversion only keep the pointer valid for one callyou can&#39;t call a conversion constructor or otherwise touch the pointer in between. We should fix that, but it&#39;ll still be necessary to persist a pointer across multiple C calls that expect pointer identity to be maintained. Your proposed alternatives all involve essentially reimplementing withUnsafePointer in a different way.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 16, 2015 at 01:00:00pm</p></header><div class="content"><p>On Wed, Dec 16, 2015, at 11:58 AM, Joe Groff wrote:<br>&gt; <br>&gt; &gt; On Dec 16, 2015, at 11:38 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; withExtendedLifetime(&amp;x) { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt; &gt;    // ...<br>&gt; &gt; }<br>&gt; <br>&gt; withExtendedLifetime doesn&#39;t have this overload. Adding it would essentially be just renaming withUnsafePointer.<br></p><p>No overload necessary. As I said, it already works today (tested in Swift 2.1). The generic type T is resolved to UnsafePointer&lt;Int&gt;, and so you can pass &amp;x into it just fine because you&#39;re passing it to a parameter of type UnsafePointer.<br></p><p>&gt; &gt; # Detailed Solution<br>&gt; &gt; <br>&gt; &gt; The functions would be marked as unavailable with a message saying to pass &amp;x directly to the function taking a pointer. If it&#39;s feasible to do so, Fix-Its would be introduced for the trivial case of the pointer being used once in the closure as a parameter to a function.<br>&gt; &gt; <br>&gt; &gt; The documentation of UnsafePointer and UnsafeMutablePointer would be edited to include a mention of how &amp;x refs can be passed to functions expecting an UnsafePointer or UnsafeMutablePointer. This way anyone new to the language who encounters those types in the wild will be able to easily see how to create one from a variable.<br>&gt; <br>&gt; I&#39;m against removing the functionality. The magic pointer conversions were only ever intended to make interop with well-behaved C functions easier; it was in my mind that we would eventually constrain the magic pointer conversions to only apply to imported APIs. withUnsafePointer is necessary more often than you think, since the current semantics of the conversion only keep the pointer valid for one callyou can&#39;t call a conversion constructor or otherwise touch the pointer in between. We should fix that, but it&#39;ll still be necessary to persist a pointer across multiple C calls that expect pointer identity to be maintained.<br></p><p>Why constrain the magic pointer conversions? We should discourage people from writing Swift functions that take UnsafePointers, but sometimes it is appropriate (e.g. when wrapping imported C functions, if you need a stable pointer or need to do pointer math, then your function should be taking Unsafe[Mutable]Pointer instead of taking an inout parameter).<br></p><p>&gt; Your proposed alternatives all involve essentially reimplementing withUnsafePointer in a different way.<br></p><p>Well yeah, but without requiring anything in the stdlib. swiftdoc.org lists 36 global Swift functions. 4 of them are unsafe[Mutable]Pointer[s]. That&#39;s 11% of the global functions in the stdlib, for functionality that can already be accomplished without any stdlib support and which is relatively rare.<br></p><p>The way I see it, if the stdlib didn&#39;t already have these functions, we wouldn&#39;t add them. So why keep them around? All they do is make people think they&#39;re necessary.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 16, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 1:11 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Dec 16, 2015, at 11:58 AM, Joe Groff wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 16, 2015, at 11:38 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; withExtendedLifetime(&amp;x) { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt;&gt;&gt;   // ...<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; withExtendedLifetime doesn&#39;t have this overload. Adding it would essentially be just renaming withUnsafePointer.<br>&gt; <br>&gt; No overload necessary. As I said, it already works today (tested in Swift 2.1). The generic type T is resolved to UnsafePointer&lt;Int&gt;, and so you can pass &amp;x into it just fine because you&#39;re passing it to a parameter of type UnsafePointer.<br></p><p>That&#39;s interesting emergent behavior, but it&#39;s not something we anticipated withUnsafePointer being used for.<br></p><p>&gt;&gt;&gt; # Detailed Solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The functions would be marked as unavailable with a message saying to pass &amp;x directly to the function taking a pointer. If it&#39;s feasible to do so, Fix-Its would be introduced for the trivial case of the pointer being used once in the closure as a parameter to a function.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The documentation of UnsafePointer and UnsafeMutablePointer would be edited to include a mention of how &amp;x refs can be passed to functions expecting an UnsafePointer or UnsafeMutablePointer. This way anyone new to the language who encounters those types in the wild will be able to easily see how to create one from a variable.<br>&gt;&gt; <br>&gt;&gt; I&#39;m against removing the functionality. The magic pointer conversions were only ever intended to make interop with well-behaved C functions easier; it was in my mind that we would eventually constrain the magic pointer conversions to only apply to imported APIs. withUnsafePointer is necessary more often than you think, since the current semantics of the conversion only keep the pointer valid for one callyou can&#39;t call a conversion constructor or otherwise touch the pointer in between. We should fix that, but it&#39;ll still be necessary to persist a pointer across multiple C calls that expect pointer identity to be maintained.<br>&gt; <br>&gt; Why constrain the magic pointer conversions?<br></p><p>In general, implicit conversions are bad. These particular conversions lead to lots of gross knock-on effects, things like [1] - [2] working by taking the difference of two transient pointers.<br></p><p>&gt; We should discourage people from writing Swift functions that take UnsafePointers, but sometimes it is appropriate (e.g. when wrapping imported C functions, if you need a stable pointer or need to do pointer math, then your function should be taking Unsafe[Mutable]Pointer instead of taking an inout parameter).<br></p><p>If you need a stable pointer internally in your implementation, I don&#39;t see a reason to expose that implementation detail to users. You could use withUnsafeMutablePointer(&amp;inoutParameter) internally.<br></p><p>&gt; <br>&gt;&gt; Your proposed alternatives all involve essentially reimplementing withUnsafePointer in a different way.<br>&gt; <br>&gt; Well yeah, but without requiring anything in the stdlib. swiftdoc.org lists 36 global Swift functions. 4 of them are unsafe[Mutable]Pointer[s]. That&#39;s 11% of the global functions in the stdlib, for functionality that can already be accomplished without any stdlib support and which is relatively rare.<br></p><p>I agree, it&#39;s unfortunate that these functions pollute the global namespace. Maybe they should be static methods of Unsafe[Mutable]Pointer instead?<br></p><p>&gt; The way I see it, if the stdlib didn&#39;t already have these functions, we wouldn&#39;t add them. So why keep them around? All they do is make people think they&#39;re necessary.<br></p><p>We added them because they *are* necessary.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 16, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 1:20 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 16, 2015, at 1:11 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 16, 2015, at 11:58 AM, Joe Groff wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 16, 2015, at 11:38 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; withExtendedLifetime(&amp;x) { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt;&gt;&gt;&gt;  // ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; withExtendedLifetime doesn&#39;t have this overload. Adding it would essentially be just renaming withUnsafePointer.<br>&gt;&gt; <br>&gt;&gt; No overload necessary. As I said, it already works today (tested in Swift 2.1). The generic type T is resolved to UnsafePointer&lt;Int&gt;, and so you can pass &amp;x into it just fine because you&#39;re passing it to a parameter of type UnsafePointer.<br>&gt; <br>&gt; That&#39;s interesting emergent behavior, but it&#39;s not something we anticipated withUnsafePointer being used for.<br>&gt; <br>&gt;&gt;&gt;&gt; # Detailed Solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The functions would be marked as unavailable with a message saying to pass &amp;x directly to the function taking a pointer. If it&#39;s feasible to do so, Fix-Its would be introduced for the trivial case of the pointer being used once in the closure as a parameter to a function.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The documentation of UnsafePointer and UnsafeMutablePointer would be edited to include a mention of how &amp;x refs can be passed to functions expecting an UnsafePointer or UnsafeMutablePointer. This way anyone new to the language who encounters those types in the wild will be able to easily see how to create one from a variable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m against removing the functionality. The magic pointer conversions were only ever intended to make interop with well-behaved C functions easier; it was in my mind that we would eventually constrain the magic pointer conversions to only apply to imported APIs. withUnsafePointer is necessary more often than you think, since the current semantics of the conversion only keep the pointer valid for one callyou can&#39;t call a conversion constructor or otherwise touch the pointer in between. We should fix that, but it&#39;ll still be necessary to persist a pointer across multiple C calls that expect pointer identity to be maintained.<br>&gt;&gt; <br>&gt;&gt; Why constrain the magic pointer conversions?<br>&gt; <br>&gt; In general, implicit conversions are bad. These particular conversions lead to lots of gross knock-on effects, things like [1] - [2] working by taking the difference of two transient pointers.<br>&gt; <br>&gt;&gt; We should discourage people from writing Swift functions that take UnsafePointers, but sometimes it is appropriate (e.g. when wrapping imported C functions, if you need a stable pointer or need to do pointer math, then your function should be taking Unsafe[Mutable]Pointer instead of taking an inout parameter).<br>&gt; <br>&gt; If you need a stable pointer internally in your implementation, I don&#39;t see a reason to expose that implementation detail to users. You could use withUnsafeMutablePointer(&amp;inoutParameter) internally.<br></p><p>And if you really need to preserve identity across multiple function calls, I&#39;d argue that after a certain point, it&#39;s better to allocate the memory yourself with UnsafeMutablePointer.alloc/dealloc (with optimizer support for promoting small, scoped .alloc/.dealloc pairs to stack allocations), since interfacing compiler-managed properties with manual memory manipulation is always going to be finicky.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/4828df1d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 16, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 1:24 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 16, 2015, at 1:20 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 16, 2015, at 1:11 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Dec 16, 2015, at 11:58 AM, Joe Groff wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 16, 2015, at 11:38 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; withExtendedLifetime(&amp;x) { (ptr: UnsafePointer&lt;Int&gt;) in<br>&gt;&gt;&gt;&gt;&gt;  // ...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; withExtendedLifetime doesn&#39;t have this overload. Adding it would essentially be just renaming withUnsafePointer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No overload necessary. As I said, it already works today (tested in Swift 2.1). The generic type T is resolved to UnsafePointer&lt;Int&gt;, and so you can pass &amp;x into it just fine because you&#39;re passing it to a parameter of type UnsafePointer.<br>&gt;&gt; <br>&gt;&gt; That&#39;s interesting emergent behavior, but it&#39;s not something we anticipated withUnsafePointer being used for.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; # Detailed Solution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The functions would be marked as unavailable with a message saying to pass &amp;x directly to the function taking a pointer. If it&#39;s feasible to do so, Fix-Its would be introduced for the trivial case of the pointer being used once in the closure as a parameter to a function.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The documentation of UnsafePointer and UnsafeMutablePointer would be edited to include a mention of how &amp;x refs can be passed to functions expecting an UnsafePointer or UnsafeMutablePointer. This way anyone new to the language who encounters those types in the wild will be able to easily see how to create one from a variable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m against removing the functionality. The magic pointer conversions were only ever intended to make interop with well-behaved C functions easier; it was in my mind that we would eventually constrain the magic pointer conversions to only apply to imported APIs. withUnsafePointer is necessary more often than you think, since the current semantics of the conversion only keep the pointer valid for one callyou can&#39;t call a conversion constructor or otherwise touch the pointer in between. We should fix that, but it&#39;ll still be necessary to persist a pointer across multiple C calls that expect pointer identity to be maintained.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why constrain the magic pointer conversions?<br>&gt;&gt; <br>&gt;&gt; In general, implicit conversions are bad. These particular conversions lead to lots of gross knock-on effects, things like [1] - [2] working by taking the difference of two transient pointers.<br>&gt;&gt; <br>&gt;&gt;&gt; We should discourage people from writing Swift functions that take UnsafePointers, but sometimes it is appropriate (e.g. when wrapping imported C functions, if you need a stable pointer or need to do pointer math, then your function should be taking Unsafe[Mutable]Pointer instead of taking an inout parameter).<br>&gt;&gt; <br>&gt;&gt; If you need a stable pointer internally in your implementation, I don&#39;t see a reason to expose that implementation detail to users. You could use withUnsafeMutablePointer(&amp;inoutParameter) internally.<br>&gt; <br>&gt; And if you really need to preserve identity across multiple function calls, I&#39;d argue that after a certain point, it&#39;s better to allocate the memory yourself with UnsafeMutablePointer.alloc/dealloc (with optimizer support for promoting small, scoped .alloc/.dealloc pairs to stack allocations), since interfacing compiler-managed properties with manual memory manipulation is always going to be finicky.<br></p><p>I would suggest the use of ManagedBuffer over UnsafeMutablePointer.alloc/dealloc for safety reasons, FWIW.<br></p><p>&gt; <br>&gt; -Joe<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/1939f241/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 16, 2015 at 01:00:00pm</p></header><div class="content"><p>On Wed, Dec 16, 2015, at 01:20 PM, Joe Groff wrote:<br>&gt; <br>&gt; &gt;&gt; withExtendedLifetime doesn&#39;t have this overload. Adding it would essentially be just renaming withUnsafePointer.<br>&gt; &gt; <br>&gt; &gt; No overload necessary. As I said, it already works today (tested in Swift 2.1). The generic type T is resolved to UnsafePointer&lt;Int&gt;, and so you can pass &amp;x into it just fine because you&#39;re passing it to a parameter of type UnsafePointer.<br>&gt; <br>&gt; That&#39;s interesting emergent behavior, but it&#39;s not something we anticipated withUnsafePointer being used for.<br></p><p>Sure, which is why there&#39;s 2 other alternatives that work just fine as well (nested function, or anonymous closure). And I listed that mostly because I find it neat that it actually works and it has the nice property of keeping the &amp;x ref above the scoped pointer instead of putting it below. But at this point I&#39;m inclined to encourage the nested function approach instead as it&#39;s simpler.<br></p><p>&gt; &gt; Why constrain the magic pointer conversions?<br>&gt; <br>&gt; In general, implicit conversions are bad. These particular conversions lead to lots of gross knock-on effects, things like [1] - [2] working by taking the difference of two transient pointers.<br></p><p>I meant why constrain them to just imported functions. I fully agree with the current constraint of only doing the conversion when the &amp;x ref is passed as a parameter to a function expecting Unsafe[Mutable]Pointer. I don&#39;t see any compelling reason to constrain it further to only imported functions, and that would be rather confusing (looking at the function signature, there&#39;d be no way to tell whether the conversion would work or not).<br></p><p>&gt; &gt; We should discourage people from writing Swift functions that take UnsafePointers, but sometimes it is appropriate (e.g. when wrapping imported C functions, if you need a stable pointer or need to do pointer math, then your function should be taking Unsafe[Mutable]Pointer instead of taking an inout parameter).<br>&gt; <br>&gt; If you need a stable pointer internally in your implementation, I don&#39;t see a reason to expose that implementation detail to users. You could use withUnsafeMutablePointer(&amp;inoutParameter) internally.<br></p><p>You could, and in many cases that may be appropriate, but it really depends on the function. If I&#39;m writing a private function that wraps a few calls to a C library, I may still want it to accept a pointer because e.g. the caller may need to pass a stable pointer to several functions including my Swift wrapper function.<br></p><p>&gt; &gt;&gt; Your proposed alternatives all involve essentially reimplementing withUnsafePointer in a different way.<br>&gt; &gt; <br>&gt; &gt; Well yeah, but without requiring anything in the stdlib. swiftdoc.org lists 36 global Swift functions. 4 of them are unsafe[Mutable]Pointer[s]. That&#39;s 11% of the global functions in the stdlib, for functionality that can already be accomplished without any stdlib support and which is relatively rare.<br>&gt; <br>&gt; I agree, it&#39;s unfortunate that these functions pollute the global namespace. Maybe they should be static methods of Unsafe[Mutable]Pointer instead?<br>&gt; <br>&gt; &gt; The way I see it, if the stdlib didn&#39;t already have these functions, we wouldn&#39;t add them. So why keep them around? All they do is make people think they&#39;re necessary.<br>&gt; <br>&gt; We added them because they *are* necessary.<br></p><p>You still haven&#39;t demonstrated that. Every single use of withUnsafe[Mutable]Pointer[s] that can&#39;t be handled with the implicit &amp;x conversion can be replaced with a nested function, a call to an anonymous closure, or an (ab)use of withExtendedLifetime. And the existence of the functions encourages people to call them when a simple &amp;x ref would have sufficed.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 16, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 1:30 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Dec 16, 2015, at 01:20 PM, Joe Groff wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; withExtendedLifetime doesn&#39;t have this overload. Adding it would essentially be just renaming withUnsafePointer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No overload necessary. As I said, it already works today (tested in Swift 2.1). The generic type T is resolved to UnsafePointer&lt;Int&gt;, and so you can pass &amp;x into it just fine because you&#39;re passing it to a parameter of type UnsafePointer.<br>&gt;&gt; <br>&gt;&gt; That&#39;s interesting emergent behavior, but it&#39;s not something we anticipated withUnsafePointer being used for.<br>&gt; <br>&gt; Sure, which is why there&#39;s 2 other alternatives that work just fine as well (nested function, or anonymous closure). And I listed that mostly because I find it neat that it actually works and it has the nice property of keeping the &amp;x ref above the scoped pointer instead of putting it below. But at this point I&#39;m inclined to encourage the nested function approach instead as it&#39;s simpler.<br>&gt; <br>&gt;&gt;&gt; Why constrain the magic pointer conversions?<br>&gt;&gt; <br>&gt;&gt; In general, implicit conversions are bad. These particular conversions lead to lots of gross knock-on effects, things like [1] - [2] working by taking the difference of two transient pointers.<br>&gt; <br>&gt; I meant why constrain them to just imported functions. I fully agree with the current constraint of only doing the conversion when the &amp;x ref is passed as a parameter to a function expecting Unsafe[Mutable]Pointer. I don&#39;t see any compelling reason to constrain it further to only imported functions, and that would be rather confusing (looking at the function signature, there&#39;d be no way to tell whether the conversion would work or not).<br></p><p>The pointer conversions are already poorly discoverable, and people don&#39;t know they exist since code completion doesn&#39;t make it apparent. Showing the APIs as overloaded taking &#39;inout&#39;s or something similar would make it more apparent how you can use them. It&#39;s my hope that better SDK annotations can make these conversions less necessary too, by letting us eventually import well-behaved in/inout/out arguments directly as value arguments/inouts/extra returns.<br></p><p>&gt;&gt;&gt; We should discourage people from writing Swift functions that take UnsafePointers, but sometimes it is appropriate (e.g. when wrapping imported C functions, if you need a stable pointer or need to do pointer math, then your function should be taking Unsafe[Mutable]Pointer instead of taking an inout parameter).<br>&gt;&gt; <br>&gt;&gt; If you need a stable pointer internally in your implementation, I don&#39;t see a reason to expose that implementation detail to users. You could use withUnsafeMutablePointer(&amp;inoutParameter) internally.<br>&gt; <br>&gt; You could, and in many cases that may be appropriate, but it really depends on the function. If I&#39;m writing a private function that wraps a few calls to a C library, I may still want it to accept a pointer because e.g. the caller may need to pass a stable pointer to several functions including my Swift wrapper function.<br>&gt; <br>&gt;&gt;&gt;&gt; Your proposed alternatives all involve essentially reimplementing withUnsafePointer in a different way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well yeah, but without requiring anything in the stdlib. swiftdoc.org lists 36 global Swift functions. 4 of them are unsafe[Mutable]Pointer[s]. That&#39;s 11% of the global functions in the stdlib, for functionality that can already be accomplished without any stdlib support and which is relatively rare.<br>&gt;&gt; <br>&gt;&gt; I agree, it&#39;s unfortunate that these functions pollute the global namespace. Maybe they should be static methods of Unsafe[Mutable]Pointer instead?<br>&gt;&gt; <br>&gt;&gt;&gt; The way I see it, if the stdlib didn&#39;t already have these functions, we wouldn&#39;t add them. So why keep them around? All they do is make people think they&#39;re necessary.<br>&gt;&gt; <br>&gt;&gt; We added them because they *are* necessary.<br>&gt; <br>&gt; You still haven&#39;t demonstrated that. Every single use of withUnsafe[Mutable]Pointer[s] that can&#39;t be handled with the implicit &amp;x conversion can be replaced with a nested function, a call to an anonymous closure, or an (ab)use of withExtendedLifetime. And the existence of the functions encourages people to call them when a simple &amp;x ref would have sufficed.<br></p><p>I guess it&#39;s a difference of perspective. Your alternatives hinge on blessing the pointer conversions as a core part of the language, rather than an affordance to make many C APIs not totally awful, which I&#39;m not comfortable with.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 16, 2015 at 01:00:00pm</p></header><div class="content"><p>On Wed, Dec 16, 2015, at 01:38 PM, Joe Groff wrote:<br>&gt; <br>&gt; The pointer conversions are already poorly discoverable, and people don&#39;t know they exist since code completion doesn&#39;t make it apparent. Showing the APIs as overloaded taking &#39;inout&#39;s or something similar would make it more apparent how you can use them.<br></p><p>I&#39;m hoping that adding documentation to UnsafePointer/UnsafeMutablePointer that mentions the conversions will help a lot, and ideally the book would mention this too (presumably as a note in the section on in-out parameters). If I didn&#39;t already know about the conversion and I encountered a function expecting an UnsafePointer/UnsafeMutablePointer, my first inclination is to type &quot;UnsafePointer&quot; (or &quot;UnsafeMutablePointer&quot;) into the documentation browser and read the results. This is why I don&#39;t like withUnsafe[Mutable]Pointer[s]() existing, because it makes people think that&#39;s what you have to use, when in most cases the &amp;x conversion is simpler.<br></p><p>&gt; It&#39;s my hope that better SDK annotations can make these conversions less necessary too, by letting us eventually import well-behaved in/inout/out arguments directly as value arguments/inouts/extra returns.<br></p><p>That would be nice.<br></p><p>&gt; &gt;&gt; We added them because they *are* necessary.<br>&gt; &gt; <br>&gt; &gt; You still haven&#39;t demonstrated that. Every single use of withUnsafe[Mutable]Pointer[s] that can&#39;t be handled with the implicit &amp;x conversion can be replaced with a nested function, a call to an anonymous closure, or an (ab)use of withExtendedLifetime. And the existence of the functions encourages people to call them when a simple &amp;x ref would have sufficed.<br>&gt; <br>&gt; I guess it&#39;s a difference of perspective. Your alternatives hinge on blessing the pointer conversions as a core part of the language, rather than an affordance to make many C APIs not totally awful, which I&#39;m not comfortable with.<br></p><p>I guess it is. From my perspective they&#39;re already a core part of the language.<br></p><p>-Kevin<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: [stdlib] Remove withUnsafe[Mutable]Pointer[s]()</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 16, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 1:51 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Dec 16, 2015, at 01:38 PM, Joe Groff wrote:<br>&gt;&gt; <br>&gt;&gt; The pointer conversions are already poorly discoverable, and people don&#39;t know they exist since code completion doesn&#39;t make it apparent. Showing the APIs as overloaded taking &#39;inout&#39;s or something similar would make it more apparent how you can use them.<br>&gt; <br>&gt; I&#39;m hoping that adding documentation to UnsafePointer/UnsafeMutablePointer that mentions the conversions will help a lot, and ideally the book would mention this too (presumably as a note in the section on in-out parameters). If I didn&#39;t already know about the conversion and I encountered a function expecting an UnsafePointer/UnsafeMutablePointer, my first inclination is to type &quot;UnsafePointer&quot; (or &quot;UnsafeMutablePointer&quot;) into the documentation browser and read the results. This is why I don&#39;t like withUnsafe[Mutable]Pointer[s]() existing, because it makes people think that&#39;s what you have to use, when in most cases the &amp;x conversion is simpler.<br></p><p>They are documented fairly extensively in &quot;Using Swift with Cocoa and Objective-C&quot; (since they exist to interop with C):<br></p><p>https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID17 &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID17&gt;<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/c18501a2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
