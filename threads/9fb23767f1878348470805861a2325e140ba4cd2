<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>January 16, 2016 at 11:00:00pm</p></header><div class="content"><p>It seems that this thread discusses only &quot;Make generics covariant&quot; and not so &quot;add generics to protocols&quot;. Should the latter one be separated into a new thread?<br></p><p>- Maximilian<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Make generics covariant - was: Make generics covariant and add generics to protocols</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 26, 2016 at 10:00:00pm</p></header><div class="content"><p>1st sorry for not replying sooner - work go it in the way!<br></p><p>At the suggestion of Maximilian I have split the discussion into two parts, this part is Make generics covariant.<br></p><p>Most people on this forum don&#39;t like the runtime type check I proposed for writing to a covariant generic. Therefore I propose a modification; a generically typed argument is covariant if it is a let, e.g.:<br></p><p>    struct Box&lt;T&gt; { <br>        var value: T<br>        init(_ value: T) { self.value = value }<br>    }<br>    let intBox = Box(1)<br>    let floatBox = Box(2.0)<br>    func boxesPrint(box1: Box&lt;Any&gt;, box2: Box&lt;Any&gt;) {<br>        print(box1.value)<br>        print(box2.value)<br>    }<br>    boxPrint(intBox, floatBox) // OK, covariant let (box1 and box2)<br></p><p>A var is invariant and if you want to convert from a let to a var you need to type cast, e.g.:<br></p><p>    func boxesIncrement(box1: Box&lt;Any&gt;, box2: Box&lt;Any&gt;) -&gt; (Box&lt;Any&gt;, Box&lt;Any&gt;) {<br>        var box1Int = box1 as! Box&lt;Int&gt; // Cast needed, Any is really an Int<br>        box1Int.value += 1<br>        var box2Float = box2 as! Box&lt;Double&gt; // Cast needed, Any is really a Double<br>        box2Float.value += 1.0<br>        return (box1Int, box2Float)<br>    }<br></p><p>Notes:<br>  1. inout parameters would be invariant<br>  2. Classes would need to behave like structs and have mutable annotation on methods that write to their fields so that mutating methods are disallowed in lets (this would make classes more consistent with structs and protocols)<br>  3. The implementation method previously presented would allow this type casting since each instance of Box would have field BoxT that identifies its actual type.<br></p><p>Currently Swift *Arrays* of *classes* allow covariance, but not generics in general or protocols (as pointed out by Douglas Gregor, but otherwise not well known or well documented). This array/class specific mechanism would be removed if generics were made covariant, since this proposed covariance would subsume this special case covariance.<br></p><p>Douglas Gregor has, quite reasonably, also asked for evidence for the usefulness of covariance. In Java it is easy to see where variance is used because it needs to be annotated. If the Java Collections API, i.e. functions that act on a Collection, is studied (https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html) then 25 of 66 functions use covariance (i.e. would be covered by this proposal).<br></p><p>Contravariance is mainly used in Java and other languages when function types are represented by an interface, e.g. the Java interface Function has a method:<br></p><p>&lt;V&gt; Function&lt;V,R&gt;	compose(Function&lt;? super V,? extends T&gt; before)<br></p><p>Note the type of before; it&#39;s a function, but it is necessary to annotate the contravariance of the input and covariance of the output. In Swift that is the behaviour of function types already and therefore the major use case for contravariance can be ignored. Also note how cluttered the declaration is because of the variance annotation.<br></p><p>However there are 4 other use cases for contravariance in that API, functions like:<br></p><p>static &lt;T&gt; void	fill(List&lt;? super T&gt; list, T obj)<br></p><p>Note how the argument list has a contravariance generic, i.e. the element type of the list to be filled can be a super type of the elements placed in the list. This usage is not covered by either current Swift or the proposal.<br></p><p>The use of covariance, 25 of 66, greatly outnumbers contravariance of the non-function type, 4 of 66, hence it is proposed that this minor use case is not covered (as at present).<br></p><p>A number of people have asked about the Java experience with annotated variance. When Oracle designed Java 8 in an open source manner there was much discussion of how variance notation clouded the intent of code and a simpler system (like that proposed above or indeed the present Swift system) would be desirable. An example of this sentiment was expressed by Josh Bloch, well known in the Java world as the main designer of Java&#39;s collection API, who stated when promoting both his book and the latest version of Java:<br></p><p>    &quot;Generics certainly improved the type safety and expressiveness of the language, and I&#39;m very glad they were added. But they haven&#39;t been an unqualified success. You only have to peruse Angelika Langer&#39;s 513-page  Java Generics FAQs to appreciate this. So I wish we&#39;d been able to simplify the design.&quot;<br>    (http://www.oracle.com/technetwork/articles/java/bloch-effective-08-qa-140880.html)<br></p><p>In summary, all that is needed in Swift is covariance of generic parameters since covariance also covers invariance and contravariance is mainly covered by function types already.<br></p><p>&gt; On 17 Jan 2016, at 9:16 AM, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It seems that this thread discusses only &quot;Make generics covariant&quot; and not so &quot;add generics to protocols&quot;. Should the latter one be separated into a new thread?<br>&gt; <br>&gt; - Maximilian<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/db8136bc/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
