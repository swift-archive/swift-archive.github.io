<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>RFC: &quot;Near-miss&quot; checking for defaulted protocol requirements</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 22, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>A common complaint with protocol conformance checking is that it’s easy to make a little mistake when trying to implement a protocol requirement that has a default implementation. Here is a silly example:<br></p><p>protocol P { <br>  func foo(value: Float)<br>}<br></p><p>extension P {<br>  func foo(value: Float) { } // default implementation of P.foo(value:)<br>}<br></p><p>struct S { }<br></p><p>extension S : P {<br>  func foo(value: Double) { } // intended-but-incorrect attempt to satisfy the requirement P.foo(value:)<br>}<br></p><p>S satisfies the requirement for P.foo(value:) using the implementation from the protocol extension, although it certainly looks like the user intended to provide a different implementation.<br></p><p>This kind of problem has prompted repeated calls for some kind of “implements” keyword to indicate that one is intending to implement a protocol requirement. I, personally, *really* don’t want yet another decorator keyword to indicate the intent here, because I believe the user has already indicated intent by stating conformance to the protocol P. I’ve recently committed a number of changes that provide “near-miss” checking for optional requirements of @objc protocols (which have the same problem).<br></p><p>It might be worth enabling this functionality for cases like the above as well. The Swift compiler patch to do so is attached, and will produce the following warning for the code above:<br></p><p>t2.swift:12:8: warning: instance method &#39;foo(value:)&#39; nearly matches optional requirement &#39;foo(value:)&#39; of protocol &#39;P&#39;<br>  func foo(value: Double) { }<br>       ^<br>t2.swift:12:8: note: candidate has non-matching type &#39;(value: Double) -&gt; ()&#39;<br>  func foo(value: Double) { }<br>       ^<br>t2.swift:12:8: note: move &#39;foo(value:)&#39; to another extension to silence this warning<br>  func foo(value: Double) { }<br>       ^<br>t2.swift:12:8: note: make &#39;foo(value:)&#39; private to silence this warning<br>  func foo(value: Double) { }<br>       ^<br>  private <br>t2.swift:2:8: note: requirement &#39;foo(value:)&#39; declared here<br>  func foo(value: Float)<br>       ^<br></p><p>It’s unfortunate that it’s a lot of notes. The first says what is wrong with the candidate (and there is much we could do to improve the precision of this diagnostic!), while the next two are mitigation strategies: move it to another extension (which implies that it’s not part of the conformance to P) or explicitly mark it as having less visibility than the conformance (in this case, private), which feels like a good way to state “I intend this to be a helper”. This might nudge Swift developers toward a style where they write one conformance per extension, but I don’t think that’s necessarily a bad thing: it’s a fine way to organize code.<br></p><p>Naturally, this handles typos as well, e.g.,<br></p><p>t2.swift:12:8: warning: instance method &#39;foob(value:)&#39; nearly matches optional requirement &#39;foo(value:)&#39; of protocol &#39;P&#39;<br>  func foob(value: Float) { }<br>       ^<br>t2.swift:12:8: note: rename to &#39;foo(value:)&#39; to satisfy this requirement<br>  func foob(value: Float) { }<br>       ^~~~<br>       foo<br></p><p>Running this on the standard library produces a number of results:<br></p><p>/Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: warning: instance method &#39;removeLast()&#39; nearly matches optional requirement &#39;removeFirst()&#39; of protocol &#39;RangeReplaceableCollection&#39;<br>  public mutating func removeLast() -&gt; Element {<br>                       ^<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: rename to &#39;removeFirst()&#39; to satisfy this requirement<br>  public mutating func removeLast() -&gt; Element {<br>                       ^~~~~~~~~~<br>                       removeFirst<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: move &#39;removeLast()&#39; to another extension to silence this warning<br>  public mutating func removeLast() -&gt; Element {<br>                       ^<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/RangeReplaceableCollection.swift:158:17: note: requirement &#39;removeFirst()&#39; declared here<br>  mutating func removeFirst() -&gt; Iterator.Element<br>                ^<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: warning: instance method &#39;removeLast()&#39; nearly matches optional requirement &#39;removeFirst()&#39; of protocol &#39;RangeReplaceableCollection&#39;<br>  public mutating func removeLast() -&gt; Element {<br>                       ^<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: rename to &#39;removeFirst()&#39; to satisfy this requirement<br>  public mutating func removeLast() -&gt; Element {<br>                       ^~~~~~~~~~<br>                       removeFirst<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: move &#39;removeLast()&#39; to another extension to silence this warning<br>  public mutating func removeLast() -&gt; Element {<br>                       ^<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/RangeReplaceableCollection.swift:158:17: note: requirement &#39;removeFirst()&#39; declared here<br>  mutating func removeFirst() -&gt; Iterator.Element<br>                ^<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: warning: instance method &#39;removeLast()&#39; nearly matches optional requirement &#39;removeFirst()&#39; of protocol &#39;RangeReplaceableCollection&#39;<br>  public mutating func removeLast() -&gt; Element {<br>                       ^<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: rename to &#39;removeFirst()&#39; to satisfy this requirement<br>  public mutating func removeLast() -&gt; Element {<br>                       ^~~~~~~~~~<br>                       removeFirst<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: move &#39;removeLast()&#39; to another extension to silence this warning<br>  public mutating func removeLast() -&gt; Element {<br>                       ^<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/RangeReplaceableCollection.swift:158:17: note: requirement &#39;removeFirst()&#39; declared here<br>  mutating func removeFirst() -&gt; Iterator.Element<br>                ^<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/HashedCollections.swift.gyb:1077:10: warning: subscript &#39;subscript&#39; nearly matches optional requirement &#39;subscript&#39; of protocol &#39;Collection&#39;<br>  public subscript(key: Key) -&gt; Value? {<br>         ^<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/HashedCollections.swift.gyb:1077:10: note: candidate has non-matching type &#39;Key -&gt; Value?&#39; [with Iterator = DictionaryIterator&lt;Key, Value&gt;, SubSequence = Slice&lt;Dictionary&lt;Key, Value&gt;&gt;]<br>  public subscript(key: Key) -&gt; Value? {<br>         ^<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/HashedCollections.swift.gyb:1077:10: note: move &#39;subscript&#39; to an extension to silence this warning<br>  public subscript(key: Key) -&gt; Value? {<br>         ^<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/Collection.swift:147:3: note: requirement &#39;subscript&#39; declared here<br>  subscript(bounds: Range&lt;Index&gt;) -&gt; SubSequence { get }<br>  ^<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/Range.swift:116:10: warning: subscript &#39;subscript&#39; nearly matches optional requirement &#39;subscript&#39; of protocol &#39;Collection&#39;<br>  public subscript(_: Element._DisabledRangeIndex) -&gt; Element {<br>         ^<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/Range.swift:116:10: note: candidate has non-matching type &#39;Element._DisabledRangeIndex -&gt; Element&#39; [with Iterator = RangeIterator&lt;Element&gt;, SubSequence = Slice&lt;Range&lt;Element&gt;&gt;]<br>  public subscript(_: Element._DisabledRangeIndex) -&gt; Element {<br>         ^<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/Range.swift:116:10: note: move &#39;subscript&#39; to an extension to silence this warning<br>  public subscript(_: Element._DisabledRangeIndex) -&gt; Element {<br>         ^<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/Collection.swift:147:3: note: requirement &#39;subscript&#39; declared here<br>  subscript(bounds: Range&lt;Index&gt;) -&gt; SubSequence { get }<br>  ^<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/ExistentialCollection.swift.gyb:508:15: warning: instance method &#39;_distance(to:)&#39; nearly matches optional requirement &#39;distance(to:)&#39; of protocol &#39;ForwardIndex&#39;<br>  public func _distance(to other: AnyForwardIndex) -&gt; AnyForwardIndex.Distance {<br>              ^<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/ExistentialCollection.swift.gyb:508:15: note: rename to &#39;distance(to:)&#39; to satisfy this requirement [with _DisabledRangeIndex = _DisabledRangeIndex_]<br>  public func _distance(to other: AnyForwardIndex) -&gt; AnyForwardIndex.Distance {<br>              ^~~~~~~~~<br>              distance<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/ExistentialCollection.swift.gyb:508:15: note: move &#39;_distance(to:)&#39; to an extension to silence this warning<br>  public func _distance(to other: AnyForwardIndex) -&gt; AnyForwardIndex.Distance {<br>              ^<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/Index.swift:180:8: note: requirement &#39;distance(to:)&#39; declared here<br>  func distance(to end: Self) -&gt; Distance<br>       ^<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/ExistentialCollection.swift.gyb:508:15: warning: instance method &#39;_distance(to:)&#39; nearly matches optional requirement &#39;distance(to:)&#39; of protocol &#39;ForwardIndex&#39;<br>  public func _distance(to other: AnyBidirectionalIndex) -&gt; AnyBidirectionalIndex.Distance {<br>              ^<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/ExistentialCollection.swift.gyb:508:15: note: rename to &#39;distance(to:)&#39; to satisfy this requirement [with _DisabledRangeIndex = _DisabledRangeIndex_]<br>  public func _distance(to other: AnyBidirectionalIndex) -&gt; AnyBidirectionalIndex.Distance {<br>              ^~~~~~~~~<br>              distance<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/ExistentialCollection.swift.gyb:508:15: note: move &#39;_distance(to:)&#39; to an extension to silence this warning<br>  public func _distance(to other: AnyBidirectionalIndex) -&gt; AnyBidirectionalIndex.Distance {<br>              ^<br>/Users/dgregor/Projects/swift/swift/stdlib/public/core/Index.swift:180:8: note: requirement &#39;distance(to:)&#39; declared here<br>  func distance(to end: Self) -&gt; Distance<br>       ^<br></p><p><br>It’s somewhat frustrating that these are *all* false positives. However, they seem like “reasonable” false positives, in the sense that they’re close enough to the requirement to be justifiable, and the suggested recovery strategies look acceptable.<br></p><p>Thoughts? Should we turn this on?<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160422/a0726059/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: default-impl-near-miss.patch<br>Type: application/octet-stream<br>Size: 627 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160422/a0726059/attachment.obj&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160422/a0726059/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>RFC: &quot;Near-miss&quot; checking for defaulted protocol requirements</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>April 22, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Apr 22, 2016, at 3:33 PM, Douglas Gregor via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; Hi all,<br>&gt; <br>&gt; A common complaint with protocol conformance checking is that it’s easy to make a little mistake when trying to implement a protocol requirement that has a default implementation. Here is a silly example:<br>&gt; <br>&gt; protocol P { <br>&gt;   func foo(value: Float)<br>&gt; }<br>&gt; <br>&gt; extension P {<br>&gt;   func foo(value: Float) { } // default implementation of P.foo(value:)<br>&gt; }<br>&gt; <br>&gt; struct S { }<br>&gt; <br>&gt; extension S : P {<br>&gt;   func foo(value: Double) { } // intended-but-incorrect attempt to satisfy the requirement P.foo(value:)<br>&gt; }<br>&gt; <br>&gt; S satisfies the requirement for P.foo(value:) using the implementation from the protocol extension, although it certainly looks like the user intended to provide a different implementation.<br>&gt; <br>&gt; This kind of problem has prompted repeated calls for some kind of “implements” keyword to indicate that one is intending to implement a protocol requirement. I, personally, *really* don’t want yet another decorator keyword to indicate the intent here, because I believe the user has already indicated intent by stating conformance to the protocol P. I’ve recently committed a number of changes that provide “near-miss” checking for optional requirements of @objc protocols (which have the same problem).<br>&gt; <br>&gt; It might be worth enabling this functionality for cases like the above as well. The Swift compiler patch to do so is attached, and will produce the following warning for the code above:<br>&gt; <br>&gt; t2.swift:12:8: warning: instance method &#39;foo(value:)&#39; nearly matches optional requirement &#39;foo(value:)&#39; of protocol &#39;P&#39;<br>&gt;   func foo(value: Double) { }<br>&gt;        ^<br>&gt; t2.swift:12:8: note: candidate has non-matching type &#39;(value: Double) -&gt; ()&#39;<br>&gt;   func foo(value: Double) { }<br>&gt;        ^<br>&gt; t2.swift:12:8: note: move &#39;foo(value:)&#39; to another extension to silence this warning<br>&gt;   func foo(value: Double) { }<br>&gt;        ^<br>&gt; t2.swift:12:8: note: make &#39;foo(value:)&#39; private to silence this warning<br>&gt;   func foo(value: Double) { }<br>&gt;        ^<br>&gt;   private <br>&gt; t2.swift:2:8: note: requirement &#39;foo(value:)&#39; declared here<br>&gt;   func foo(value: Float)<br>&gt;        ^<br>&gt; <br>&gt; It’s unfortunate that it’s a lot of notes. The first says what is wrong with the candidate (and there is much we could do to improve the precision of this diagnostic!), while the next two are mitigation strategies: move it to another extension (which implies that it’s not part of the conformance to P) or explicitly mark it as having less visibility than the conformance (in this case, private), which feels like a good way to state “I intend this to be a helper”. This might nudge Swift developers toward a style where they write one conformance per extension, but I don’t think that’s necessarily a bad thing: it’s a fine way to organize code.<br>&gt; <br>&gt; Naturally, this handles typos as well, e.g.,<br>&gt; <br>&gt; t2.swift:12:8: warning: instance method &#39;foob(value:)&#39; nearly matches optional requirement &#39;foo(value:)&#39; of protocol &#39;P&#39;<br>&gt;   func foob(value: Float) { }<br>&gt;        ^<br>&gt; t2.swift:12:8: note: rename to &#39;foo(value:)&#39; to satisfy this requirement<br>&gt;   func foob(value: Float) { }<br>&gt;        ^~~~<br>&gt;        foo<br>&gt; <br>&gt; Running this on the standard library produces a number of results:<br>&gt; <br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: warning: instance method &#39;removeLast()&#39; nearly matches optional requirement &#39;removeFirst()&#39; of protocol &#39;RangeReplaceableCollection&#39;<br>&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;                        ^<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: rename to &#39;removeFirst()&#39; to satisfy this requirement<br>&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;                        ^~~~~~~~~~<br>&gt;                        removeFirst<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: move &#39;removeLast()&#39; to another extension to silence this warning<br>&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;                        ^<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/RangeReplaceableCollection.swift:158:17: note: requirement &#39;removeFirst()&#39; declared here<br>&gt;   mutating func removeFirst() -&gt; Iterator.Element<br>&gt;                 ^<br></p><p>Would a word-by-word edit-distance heuristic work better?  That is, removeFirst is not a plausible typo for removeLast because First is not a plausible typo for Last.<br></p><p>Admittedly, you might need to do something else if the word counts don&#39;t match.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160422/c77b4ba1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>RFC: &quot;Near-miss&quot; checking for defaulted protocol requirements</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 25, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Apr 22, 2016, at 6:08 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Apr 22, 2016, at 3:33 PM, Douglas Gregor via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; A common complaint with protocol conformance checking is that it’s easy to make a little mistake when trying to implement a protocol requirement that has a default implementation. Here is a silly example:<br>&gt;&gt; [snip]<br>&gt;&gt; <br>&gt;&gt; Naturally, this handles typos as well, e.g.,<br>&gt;&gt; <br>&gt;&gt; t2.swift:12:8: warning: instance method &#39;foob(value:)&#39; nearly matches optional requirement &#39;foo(value:)&#39; of protocol &#39;P&#39;<br>&gt;&gt;   func foob(value: Float) { }<br>&gt;&gt;        ^<br>&gt;&gt; t2.swift:12:8: note: rename to &#39;foo(value:)&#39; to satisfy this requirement<br>&gt;&gt;   func foob(value: Float) { }<br>&gt;&gt;        ^~~~<br>&gt;&gt;        foo<br>&gt;&gt; <br>&gt;&gt; Running this on the standard library produces a number of results:<br>&gt;&gt; <br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: warning: instance method &#39;removeLast()&#39; nearly matches optional requirement &#39;removeFirst()&#39; of protocol &#39;RangeReplaceableCollection&#39;<br>&gt;&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;&gt;                        ^<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: rename to &#39;removeFirst()&#39; to satisfy this requirement<br>&gt;&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;&gt;                        ^~~~~~~~~~<br>&gt;&gt;                        removeFirst<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: move &#39;removeLast()&#39; to another extension to silence this warning<br>&gt;&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;&gt;                        ^<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/RangeReplaceableCollection.swift:158:17: note: requirement &#39;removeFirst()&#39; declared here<br>&gt;&gt;   mutating func removeFirst() -&gt; Iterator.Element<br>&gt;&gt;                 ^<br>&gt; <br>&gt; Would a word-by-word edit-distance heuristic work better?  That is, removeFirst is not a plausible typo for removeLast because First is not a plausible typo for Last.<br></p><p>A word-by-word edit distance seems to imply that if *any* word is too far off, reject. I’m a bit concerned that it would create false negatives.<br></p><p>One possibility in this space would be to remove common words from consideration. That way, only the mismatching words will be used to do the edit-distance computation, so the one-mistake-per-N-characters-typed heuristic wouldn’t consider the completely-matching parts.<br></p><p>In defense of the warning in this case: RangeReplaceableCollection has a “removeFirst” but not a “removeLast”; the conforming type here is implementing “removeLast” but not “removeFirst”. It is *so easy* to imagine this as programmer error that the warning feels justified.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160425/d6fd7d87/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>RFC: &quot;Near-miss&quot; checking for defaulted protocol requirements</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>April 25, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 25, 2016, at 9:57 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt; On Apr 22, 2016, at 6:08 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 22, 2016, at 3:33 PM, Douglas Gregor via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A common complaint with protocol conformance checking is that it’s easy to make a little mistake when trying to implement a protocol requirement that has a default implementation. Here is a silly example:<br>&gt;&gt;&gt; [snip]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Naturally, this handles typos as well, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; t2.swift:12:8: warning: instance method &#39;foob(value:)&#39; nearly matches optional requirement &#39;foo(value:)&#39; of protocol &#39;P&#39;<br>&gt;&gt;&gt;   func foob(value: Float) { }<br>&gt;&gt;&gt;        ^<br>&gt;&gt;&gt; t2.swift:12:8: note: rename to &#39;foo(value:)&#39; to satisfy this requirement<br>&gt;&gt;&gt;   func foob(value: Float) { }<br>&gt;&gt;&gt;        ^~~~<br>&gt;&gt;&gt;        foo<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Running this on the standard library produces a number of results:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: warning: instance method &#39;removeLast()&#39; nearly matches optional requirement &#39;removeFirst()&#39; of protocol &#39;RangeReplaceableCollection&#39;<br>&gt;&gt;&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;&gt;&gt;                        ^<br>&gt;&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: rename to &#39;removeFirst()&#39; to satisfy this requirement<br>&gt;&gt;&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;&gt;&gt;                        ^~~~~~~~~~<br>&gt;&gt;&gt;                        removeFirst<br>&gt;&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: move &#39;removeLast()&#39; to another extension to silence this warning<br>&gt;&gt;&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;&gt;&gt;                        ^<br>&gt;&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/RangeReplaceableCollection.swift:158:17: note: requirement &#39;removeFirst()&#39; declared here<br>&gt;&gt;&gt;   mutating func removeFirst() -&gt; Iterator.Element<br>&gt;&gt;&gt;                 ^<br>&gt;&gt; <br>&gt;&gt; Would a word-by-word edit-distance heuristic work better?  That is, removeFirst is not a plausible typo for removeLast because First is not a plausible typo for Last.<br>&gt; <br>&gt; A word-by-word edit distance seems to imply that if *any* word is too far off, reject. I’m a bit concerned that it would create false negatives.<br></p><p>Any shift in the heuristic will eliminate false positives at the risk of creating false negatives.<br></p><p>A word-by-word heuristic allows you to catch a large number of typos in a long method name without matching completely different words just because the method name is long.  That seems like the right trade-off to me.<br></p><p>&gt; One possibility in this space would be to remove common words from consideration. That way, only the mismatching words will be used to do the edit-distance computation, so the one-mistake-per-N-characters-typed heuristic wouldn’t consider the completely-matching parts.<br></p><p>I think you have fallen a bit too in love with dictionaries.<br></p><p>&gt; In defense of the warning in this case: RangeReplaceableCollection has a “removeFirst” but not a “removeLast”; the conforming type here is implementing “removeLast” but not “removeFirst”. It is *so easy* to imagine this as programmer error that the warning feels justified.<br></p><p>This does not feel like it leads to a reasonable general principle.  At best it calls for some way to opt in to a warning about implementing only &quot;related&quot; methods, analogous the related-type warnings in ObjC ARC bridging.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160425/63a95d4f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>RFC: &quot;Near-miss&quot; checking for defaulted protocol requirements</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 25, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 25, 2016, at 10:09 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Apr 25, 2016, at 9:57 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Apr 22, 2016, at 6:08 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Apr 22, 2016, at 3:33 PM, Douglas Gregor via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A common complaint with protocol conformance checking is that it’s easy to make a little mistake when trying to implement a protocol requirement that has a default implementation. Here is a silly example:<br>&gt;&gt;&gt;&gt; [snip]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Naturally, this handles typos as well, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; t2.swift:12:8: warning: instance method &#39;foob(value:)&#39; nearly matches optional requirement &#39;foo(value:)&#39; of protocol &#39;P&#39;<br>&gt;&gt;&gt;&gt;   func foob(value: Float) { }<br>&gt;&gt;&gt;&gt;        ^<br>&gt;&gt;&gt;&gt; t2.swift:12:8: note: rename to &#39;foo(value:)&#39; to satisfy this requirement<br>&gt;&gt;&gt;&gt;   func foob(value: Float) { }<br>&gt;&gt;&gt;&gt;        ^~~~<br>&gt;&gt;&gt;&gt;        foo<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Running this on the standard library produces a number of results:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: warning: instance method &#39;removeLast()&#39; nearly matches optional requirement &#39;removeFirst()&#39; of protocol &#39;RangeReplaceableCollection&#39;<br>&gt;&gt;&gt;&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;&gt;&gt;&gt;                        ^<br>&gt;&gt;&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: rename to &#39;removeFirst()&#39; to satisfy this requirement<br>&gt;&gt;&gt;&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;&gt;&gt;&gt;                        ^~~~~~~~~~<br>&gt;&gt;&gt;&gt;                        removeFirst<br>&gt;&gt;&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: move &#39;removeLast()&#39; to another extension to silence this warning<br>&gt;&gt;&gt;&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;&gt;&gt;&gt;                        ^<br>&gt;&gt;&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/RangeReplaceableCollection.swift:158:17: note: requirement &#39;removeFirst()&#39; declared here<br>&gt;&gt;&gt;&gt;   mutating func removeFirst() -&gt; Iterator.Element<br>&gt;&gt;&gt;&gt;                 ^<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would a word-by-word edit-distance heuristic work better?  That is, removeFirst is not a plausible typo for removeLast because First is not a plausible typo for Last.<br>&gt;&gt; <br>&gt;&gt; A word-by-word edit distance seems to imply that if *any* word is too far off, reject. I’m a bit concerned that it would create false negatives.<br>&gt; <br>&gt; Any shift in the heuristic will eliminate false positives at the risk of creating false negatives.<br>&gt; <br>&gt; A word-by-word heuristic allows you to catch a large number of typos in a long method name without matching completely different words just because the method name is long.  That seems like the right trade-off to me.<br>&gt; <br>&gt;&gt; One possibility in this space would be to remove common words from consideration. That way, only the mismatching words will be used to do the edit-distance computation, so the one-mistake-per-N-characters-typed heuristic wouldn’t consider the completely-matching parts.<br>&gt; <br>&gt; I think you have fallen a bit too in love with dictionaries.<br></p><p>By “common words” I mean “words that are common to both names”, not “common English words” :)<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160425/200ab41a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>RFC: &quot;Near-miss&quot; checking for defaulted protocol requirements</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>April 25, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 25, 2016, at 10:12 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt; On Apr 25, 2016, at 10:09 AM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 25, 2016, at 9:57 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; On Apr 22, 2016, at 6:08 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Apr 22, 2016, at 3:33 PM, Douglas Gregor via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A common complaint with protocol conformance checking is that it’s easy to make a little mistake when trying to implement a protocol requirement that has a default implementation. Here is a silly example:<br>&gt;&gt;&gt;&gt;&gt; [snip]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Naturally, this handles typos as well, e.g.,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; t2.swift:12:8: warning: instance method &#39;foob(value:)&#39; nearly matches optional requirement &#39;foo(value:)&#39; of protocol &#39;P&#39;<br>&gt;&gt;&gt;&gt;&gt;   func foob(value: Float) { }<br>&gt;&gt;&gt;&gt;&gt;        ^<br>&gt;&gt;&gt;&gt;&gt; t2.swift:12:8: note: rename to &#39;foo(value:)&#39; to satisfy this requirement<br>&gt;&gt;&gt;&gt;&gt;   func foob(value: Float) { }<br>&gt;&gt;&gt;&gt;&gt;        ^~~~<br>&gt;&gt;&gt;&gt;&gt;        foo<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Running this on the standard library produces a number of results:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: warning: instance method &#39;removeLast()&#39; nearly matches optional requirement &#39;removeFirst()&#39; of protocol &#39;RangeReplaceableCollection&#39;<br>&gt;&gt;&gt;&gt;&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;&gt;&gt;&gt;&gt;                        ^<br>&gt;&gt;&gt;&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: rename to &#39;removeFirst()&#39; to satisfy this requirement<br>&gt;&gt;&gt;&gt;&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;&gt;&gt;&gt;&gt;                        ^~~~~~~~~~<br>&gt;&gt;&gt;&gt;&gt;                        removeFirst<br>&gt;&gt;&gt;&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: move &#39;removeLast()&#39; to another extension to silence this warning<br>&gt;&gt;&gt;&gt;&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;&gt;&gt;&gt;&gt;                        ^<br>&gt;&gt;&gt;&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/RangeReplaceableCollection.swift:158:17: note: requirement &#39;removeFirst()&#39; declared here<br>&gt;&gt;&gt;&gt;&gt;   mutating func removeFirst() -&gt; Iterator.Element<br>&gt;&gt;&gt;&gt;&gt;                 ^<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Would a word-by-word edit-distance heuristic work better?  That is, removeFirst is not a plausible typo for removeLast because First is not a plausible typo for Last.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A word-by-word edit distance seems to imply that if *any* word is too far off, reject. I’m a bit concerned that it would create false negatives.<br>&gt;&gt; <br>&gt;&gt; Any shift in the heuristic will eliminate false positives at the risk of creating false negatives.<br>&gt;&gt; <br>&gt;&gt; A word-by-word heuristic allows you to catch a large number of typos in a long method name without matching completely different words just because the method name is long.  That seems like the right trade-off to me.<br>&gt;&gt; <br>&gt;&gt;&gt; One possibility in this space would be to remove common words from consideration. That way, only the mismatching words will be used to do the edit-distance computation, so the one-mistake-per-N-characters-typed heuristic wouldn’t consider the completely-matching parts.<br>&gt;&gt; <br>&gt;&gt; I think you have fallen a bit too in love with dictionaries.<br>&gt; <br>&gt; By “common words” I mean “words that are common to both names”, not “common English words” :)<br></p><p>Oh, I see, of course.  Yes, that would probably go a long way towards minimizing the false positives.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160425/0778b1db/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d631f09a3a336a15ae258e01899cb736?s=50"></div><header><strong>RFC: &quot;Near-miss&quot; checking for defaulted protocol requirements</strong> from <string>Kate Stone</string> &lt;k8stone at apple.com&gt;<p>April 25, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Apr 25, 2016, at 10:09 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Apr 25, 2016, at 9:57 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Apr 22, 2016, at 6:08 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Apr 22, 2016, at 3:33 PM, Douglas Gregor via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A common complaint with protocol conformance checking is that it’s easy to make a little mistake when trying to implement a protocol requirement that has a default implementation. Here is a silly example:<br>&gt;&gt;&gt;&gt; [snip]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Naturally, this handles typos as well, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; t2.swift:12:8: warning: instance method &#39;foob(value:)&#39; nearly matches optional requirement &#39;foo(value:)&#39; of protocol &#39;P&#39;<br>&gt;&gt;&gt;&gt;   func foob(value: Float) { }<br>&gt;&gt;&gt;&gt;        ^<br>&gt;&gt;&gt;&gt; t2.swift:12:8: note: rename to &#39;foo(value:)&#39; to satisfy this requirement<br>&gt;&gt;&gt;&gt;   func foob(value: Float) { }<br>&gt;&gt;&gt;&gt;        ^~~~<br>&gt;&gt;&gt;&gt;        foo<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Running this on the standard library produces a number of results:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: warning: instance method &#39;removeLast()&#39; nearly matches optional requirement &#39;removeFirst()&#39; of protocol &#39;RangeReplaceableCollection&#39;<br>&gt;&gt;&gt;&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;&gt;&gt;&gt;                        ^<br>&gt;&gt;&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: rename to &#39;removeFirst()&#39; to satisfy this requirement<br>&gt;&gt;&gt;&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;&gt;&gt;&gt;                        ^~~~~~~~~~<br>&gt;&gt;&gt;&gt;                        removeFirst<br>&gt;&gt;&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: move &#39;removeLast()&#39; to another extension to silence this warning<br>&gt;&gt;&gt;&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;&gt;&gt;&gt;                        ^<br>&gt;&gt;&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/RangeReplaceableCollection.swift:158:17: note: requirement &#39;removeFirst()&#39; declared here<br>&gt;&gt;&gt;&gt;   mutating func removeFirst() -&gt; Iterator.Element<br>&gt;&gt;&gt;&gt;                 ^<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would a word-by-word edit-distance heuristic work better?  That is, removeFirst is not a plausible typo for removeLast because First is not a plausible typo for Last.<br>&gt;&gt; <br>&gt;&gt; A word-by-word edit distance seems to imply that if *any* word is too far off, reject. I’m a bit concerned that it would create false negatives.<br>&gt; <br>&gt; Any shift in the heuristic will eliminate false positives at the risk of creating false negatives.<br>&gt; <br>&gt; A word-by-word heuristic allows you to catch a large number of typos in a long method name without matching completely different words just because the method name is long.  That seems like the right trade-off to me.<br></p><p>Common mistakes may well include omitting a word or inserting an extra word.  The resulting cascade of word-by-word mismatches is something I’d expect our algorithm to deal with more gracefully than purely word index-based comparisons could handle.<br></p><p>&gt;&gt; One possibility in this space would be to remove common words from consideration. That way, only the mismatching words will be used to do the edit-distance computation, so the one-mistake-per-N-characters-typed heuristic wouldn’t consider the completely-matching parts.<br>&gt; <br>&gt; I think you have fallen a bit too in love with dictionaries.<br>&gt; <br>&gt;&gt; In defense of the warning in this case: RangeReplaceableCollection has a “removeFirst” but not a “removeLast”; the conforming type here is implementing “removeLast” but not “removeFirst”. It is *so easy* to imagine this as programmer error that the warning feels justified.<br>&gt; <br>&gt; This does not feel like it leads to a reasonable general principle.  At best it calls for some way to opt in to a warning about implementing only &quot;related&quot; methods, analogous the related-type warnings in ObjC ARC bridging.<br>&gt; <br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160425/d8e7d0c7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>RFC: &quot;Near-miss&quot; checking for defaulted protocol requirements</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>April 25, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; I, personally, *really* don’t want yet another decorator keyword to indicate the intent here, because I believe the user has already indicated intent by stating conformance to the protocol P.<br></p><p>I don&#39;t find this so compelling in a language with defaulted requirements. The place where we&#39;re seeing this problem the most is optional requirements in ObjC protocols (because of all the name changes), but it&#39;s really the same thing: it&#39;s hard to know if a particular member is intended to be part of a protocol or just something that happens to be similar.<br></p><p><br>&gt; It’s somewhat frustrating that these are *all* false positives. However, they seem like “reasonable” false positives, in the sense that they’re close enough to the requirement to be justifiable, and the suggested recovery strategies look acceptable.<br></p><p>I agree that these are all reasonable, but I don&#39;t think moving decls to extensions is a great answer. A lot of these close names might be close because they&#39;re helper functions, or (in the case of removeLast) because they implement API that&#39;s in the same family as the protocol.<br></p><p>Jordan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>RFC: &quot;Near-miss&quot; checking for defaulted protocol requirements</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 25, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Apr 25, 2016, at 3:30 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; I, personally, *really* don’t want yet another decorator keyword to indicate the intent here, because I believe the user has already indicated intent by stating conformance to the protocol P.<br>&gt; <br>&gt; I don&#39;t find this so compelling in a language with defaulted requirements.<br></p><p>If we didn’t have defaulted/optional requirements, this wouldn’t be an issue at all.<br></p><p>&gt; The place where we&#39;re seeing this problem the most is optional requirements in ObjC protocols (because of all the name changes), but it&#39;s really the same thing: it&#39;s hard to know if a particular member is intended to be part of a protocol or just something that happens to be similar.<br></p><p><br></p><p>&gt; <br>&gt;&gt; It’s somewhat frustrating that these are *all* false positives. However, they seem like “reasonable” false positives, in the sense that they’re close enough to the requirement to be justifiable, and the suggested recovery strategies look acceptable.<br>&gt; <br>&gt; I agree that these are all reasonable, but I don&#39;t think moving decls to extensions is a great answer. A lot of these close names might be close because they&#39;re helper functions,<br></p><p>You can explicitly give them less visibility than the conformance, which makes it clear that they’re helper functions and disables the diagnostic.<br></p><p>&gt; or (in the case of removeLast) because they implement API that&#39;s in the same family as the protocol.<br></p><p><br>It seems less onerous to move removeLast out to a different extension than it is to splat some “implements” keyword on a bunch of declarations within an extension whose purpose is to conform to a protocol P:<br></p><p>	extension X : P {<br>	  // this is how X conforms to P<br>	}<br></p><p><br></p><p>	- Doug<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[swift-dev] RFC: &quot;Near-miss&quot; checking for defaulted protocol requirements</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 25, 2016 at 02:00:00pm</p></header><div class="content"><p>With apologies, I do not see near miss checks as a pressing need:<br></p><p>* Quick Help lists of required members (including associated types and inherited members) would be far more valuable to me than &quot;near miss&quot; detection. <br>* I&#39;d like the compiler to check for unsatisfied conformances and emit a list of required conformances including whether they are found and their origin. This would tangentially address the &quot;near miss&quot; case but only for unsatisfied conformances. It would not help when conformances are satisfied.<br>* I believe &quot;near miss&quot; is less important than &quot;intentional override&quot;, requiring a signature of intent as in inheritance. <br></p><p>Here&#39;s what you said previously on the topic of default implementation overrides that brought me here:<br>&gt; <br>&gt; This is a commonly-requested feature that I don’t think we need. The TL;DR version is that I feel like specifying the conformance explicitly (my type Foo conforms to protocol P) already expresses intent, and the compiler should help with the rest. I’ve recently been working on providing better warnings for cases where one has tried to implement an optional requirement for a protocol (but got the declaration wrong), and I think we can turn it on for cases where one got a default implementation instead:<br>&gt; <br>&gt; 	http://thread.gmane.org/gmane.comp.lang.swift.devel/1799 &lt;http://thread.gmane.org/gmane.comp.lang.swift.devel/1799&gt;<br></p><p>-- Erica<br></p><p><br>&gt; On Apr 22, 2016, at 4:33 PM, Douglas Gregor via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; A common complaint with protocol conformance checking is that it’s easy to make a little mistake when trying to implement a protocol requirement that has a default implementation. Here is a silly example:<br>&gt; <br>&gt; protocol P { <br>&gt;   func foo(value: Float)<br>&gt; }<br>&gt; <br>&gt; extension P {<br>&gt;   func foo(value: Float) { } // default implementation of P.foo(value:)<br>&gt; }<br>&gt; <br>&gt; struct S { }<br>&gt; <br>&gt; extension S : P {<br>&gt;   func foo(value: Double) { } // intended-but-incorrect attempt to satisfy the requirement P.foo(value:)<br>&gt; }<br>&gt; <br>&gt; S satisfies the requirement for P.foo(value:) using the implementation from the protocol extension, although it certainly looks like the user intended to provide a different implementation.<br>&gt; <br>&gt; This kind of problem has prompted repeated calls for some kind of “implements” keyword to indicate that one is intending to implement a protocol requirement. I, personally, *really* don’t want yet another decorator keyword to indicate the intent here, because I believe the user has already indicated intent by stating conformance to the protocol P. I’ve recently committed a number of changes that provide “near-miss” checking for optional requirements of @objc protocols (which have the same problem).<br>&gt; <br>&gt; It might be worth enabling this functionality for cases like the above as well. The Swift compiler patch to do so is attached, and will produce the following warning for the code above:<br>&gt; <br>&gt; t2.swift:12:8: warning: instance method &#39;foo(value:)&#39; nearly matches optional requirement &#39;foo(value:)&#39; of protocol &#39;P&#39;<br>&gt;   func foo(value: Double) { }<br>&gt;        ^<br>&gt; t2.swift:12:8: note: candidate has non-matching type &#39;(value: Double) -&gt; ()&#39;<br>&gt;   func foo(value: Double) { }<br>&gt;        ^<br>&gt; t2.swift:12:8: note: move &#39;foo(value:)&#39; to another extension to silence this warning<br>&gt;   func foo(value: Double) { }<br>&gt;        ^<br>&gt; t2.swift:12:8: note: make &#39;foo(value:)&#39; private to silence this warning<br>&gt;   func foo(value: Double) { }<br>&gt;        ^<br>&gt;   private <br>&gt; t2.swift:2:8: note: requirement &#39;foo(value:)&#39; declared here<br>&gt;   func foo(value: Float)<br>&gt;        ^<br>&gt; <br>&gt; It’s unfortunate that it’s a lot of notes. The first says what is wrong with the candidate (and there is much we could do to improve the precision of this diagnostic!), while the next two are mitigation strategies: move it to another extension (which implies that it’s not part of the conformance to P) or explicitly mark it as having less visibility than the conformance (in this case, private), which feels like a good way to state “I intend this to be a helper”. This might nudge Swift developers toward a style where they write one conformance per extension, but I don’t think that’s necessarily a bad thing: it’s a fine way to organize code.<br>&gt; <br>&gt; Naturally, this handles typos as well, e.g.,<br>&gt; <br>&gt; t2.swift:12:8: warning: instance method &#39;foob(value:)&#39; nearly matches optional requirement &#39;foo(value:)&#39; of protocol &#39;P&#39;<br>&gt;   func foob(value: Float) { }<br>&gt;        ^<br>&gt; t2.swift:12:8: note: rename to &#39;foo(value:)&#39; to satisfy this requirement<br>&gt;   func foob(value: Float) { }<br>&gt;        ^~~~<br>&gt;        foo<br>&gt; <br>&gt; Running this on the standard library produces a number of results:<br>&gt; <br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: warning: instance method &#39;removeLast()&#39; nearly matches optional requirement &#39;removeFirst()&#39; of protocol &#39;RangeReplaceableCollection&#39;<br>&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;                        ^<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: rename to &#39;removeFirst()&#39; to satisfy this requirement<br>&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;                        ^~~~~~~~~~<br>&gt;                        removeFirst<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: move &#39;removeLast()&#39; to another extension to silence this warning<br>&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;                        ^<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/RangeReplaceableCollection.swift:158:17: note: requirement &#39;removeFirst()&#39; declared here<br>&gt;   mutating func removeFirst() -&gt; Iterator.Element<br>&gt;                 ^<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: warning: instance method &#39;removeLast()&#39; nearly matches optional requirement &#39;removeFirst()&#39; of protocol &#39;RangeReplaceableCollection&#39;<br>&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;                        ^<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: rename to &#39;removeFirst()&#39; to satisfy this requirement<br>&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;                        ^~~~~~~~~~<br>&gt;                        removeFirst<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: move &#39;removeLast()&#39; to another extension to silence this warning<br>&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;                        ^<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/RangeReplaceableCollection.swift:158:17: note: requirement &#39;removeFirst()&#39; declared here<br>&gt;   mutating func removeFirst() -&gt; Iterator.Element<br>&gt;                 ^<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: warning: instance method &#39;removeLast()&#39; nearly matches optional requirement &#39;removeFirst()&#39; of protocol &#39;RangeReplaceableCollection&#39;<br>&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;                        ^<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: rename to &#39;removeFirst()&#39; to satisfy this requirement<br>&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;                        ^~~~~~~~~~<br>&gt;                        removeFirst<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: move &#39;removeLast()&#39; to another extension to silence this warning<br>&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;                        ^<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/RangeReplaceableCollection.swift:158:17: note: requirement &#39;removeFirst()&#39; declared here<br>&gt;   mutating func removeFirst() -&gt; Iterator.Element<br>&gt;                 ^<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/HashedCollections.swift.gyb:1077:10: warning: subscript &#39;subscript&#39; nearly matches optional requirement &#39;subscript&#39; of protocol &#39;Collection&#39;<br>&gt;   public subscript(key: Key) -&gt; Value? {<br>&gt;          ^<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/HashedCollections.swift.gyb:1077:10: note: candidate has non-matching type &#39;Key -&gt; Value?&#39; [with Iterator = DictionaryIterator&lt;Key, Value&gt;, SubSequence = Slice&lt;Dictionary&lt;Key, Value&gt;&gt;]<br>&gt;   public subscript(key: Key) -&gt; Value? {<br>&gt;          ^<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/HashedCollections.swift.gyb:1077:10: note: move &#39;subscript&#39; to an extension to silence this warning<br>&gt;   public subscript(key: Key) -&gt; Value? {<br>&gt;          ^<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Collection.swift:147:3: note: requirement &#39;subscript&#39; declared here<br>&gt;   subscript(bounds: Range&lt;Index&gt;) -&gt; SubSequence { get }<br>&gt;   ^<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Range.swift:116:10: warning: subscript &#39;subscript&#39; nearly matches optional requirement &#39;subscript&#39; of protocol &#39;Collection&#39;<br>&gt;   public subscript(_: Element._DisabledRangeIndex) -&gt; Element {<br>&gt;          ^<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Range.swift:116:10: note: candidate has non-matching type &#39;Element._DisabledRangeIndex -&gt; Element&#39; [with Iterator = RangeIterator&lt;Element&gt;, SubSequence = Slice&lt;Range&lt;Element&gt;&gt;]<br>&gt;   public subscript(_: Element._DisabledRangeIndex) -&gt; Element {<br>&gt;          ^<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Range.swift:116:10: note: move &#39;subscript&#39; to an extension to silence this warning<br>&gt;   public subscript(_: Element._DisabledRangeIndex) -&gt; Element {<br>&gt;          ^<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Collection.swift:147:3: note: requirement &#39;subscript&#39; declared here<br>&gt;   subscript(bounds: Range&lt;Index&gt;) -&gt; SubSequence { get }<br>&gt;   ^<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/ExistentialCollection.swift.gyb:508:15: warning: instance method &#39;_distance(to:)&#39; nearly matches optional requirement &#39;distance(to:)&#39; of protocol &#39;ForwardIndex&#39;<br>&gt;   public func _distance(to other: AnyForwardIndex) -&gt; AnyForwardIndex.Distance {<br>&gt;               ^<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/ExistentialCollection.swift.gyb:508:15: note: rename to &#39;distance(to:)&#39; to satisfy this requirement [with _DisabledRangeIndex = _DisabledRangeIndex_]<br>&gt;   public func _distance(to other: AnyForwardIndex) -&gt; AnyForwardIndex.Distance {<br>&gt;               ^~~~~~~~~<br>&gt;               distance<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/ExistentialCollection.swift.gyb:508:15: note: move &#39;_distance(to:)&#39; to an extension to silence this warning<br>&gt;   public func _distance(to other: AnyForwardIndex) -&gt; AnyForwardIndex.Distance {<br>&gt;               ^<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Index.swift:180:8: note: requirement &#39;distance(to:)&#39; declared here<br>&gt;   func distance(to end: Self) -&gt; Distance<br>&gt;        ^<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/ExistentialCollection.swift.gyb:508:15: warning: instance method &#39;_distance(to:)&#39; nearly matches optional requirement &#39;distance(to:)&#39; of protocol &#39;ForwardIndex&#39;<br>&gt;   public func _distance(to other: AnyBidirectionalIndex) -&gt; AnyBidirectionalIndex.Distance {<br>&gt;               ^<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/ExistentialCollection.swift.gyb:508:15: note: rename to &#39;distance(to:)&#39; to satisfy this requirement [with _DisabledRangeIndex = _DisabledRangeIndex_]<br>&gt;   public func _distance(to other: AnyBidirectionalIndex) -&gt; AnyBidirectionalIndex.Distance {<br>&gt;               ^~~~~~~~~<br>&gt;               distance<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/ExistentialCollection.swift.gyb:508:15: note: move &#39;_distance(to:)&#39; to an extension to silence this warning<br>&gt;   public func _distance(to other: AnyBidirectionalIndex) -&gt; AnyBidirectionalIndex.Distance {<br>&gt;               ^<br>&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Index.swift:180:8: note: requirement &#39;distance(to:)&#39; declared here<br>&gt;   func distance(to end: Self) -&gt; Distance<br>&gt;        ^<br>&gt; <br>&gt; <br>&gt; It’s somewhat frustrating that these are *all* false positives. However, they seem like “reasonable” false positives, in the sense that they’re close enough to the requirement to be justifiable, and the suggested recovery strategies look acceptable.<br>&gt; <br>&gt; Thoughts? Should we turn this on?<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; &lt;default-impl-near-miss.patch&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/dc8264d3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[swift-dev] RFC: &quot;Near-miss&quot; checking for defaulted protocol requirements</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 25, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Apr 25, 2016, at 1:13 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; With apologies, I do not see near miss checks as a pressing need:<br>&gt; <br>&gt; * Quick Help lists of required members (including associated types and inherited members) would be far more valuable to me than &quot;near miss&quot; detection.<br></p><p>Understood.<br></p><p>&gt; <br>&gt; * I&#39;d like the compiler to check for unsatisfied conformances and emit a list of required conformances including whether they are found and their origin. This would tangentially address the &quot;near miss&quot; case but only for unsatisfied conformances. It would not help when conformances are satisfied.<br></p><p>Yes, the experience here is terrible. What the compiler *should* do is give a serious of errors, each of which corresponds to a single requirement and has a Fix-It to stub out the appropriate method/property/etc. <br></p><p>&gt; * I believe &quot;near miss&quot; is less important than &quot;intentional override&quot;, requiring a signature of intent as in inheritance. <br></p><p>&gt; Here&#39;s what you said previously on the topic of default implementation overrides that brought me here:<br>&gt;&gt; <br>&gt;&gt; This is a commonly-requested feature that I don’t think we need. The TL;DR version is that I feel like specifying the conformance explicitly (my type Foo conforms to protocol P) already expresses intent, and the compiler should help with the rest. I’ve recently been working on providing better warnings for cases where one has tried to implement an optional requirement for a protocol (but got the declaration wrong), and I think we can turn it on for cases where one got a default implementation instead:<br>&gt;&gt; <br>&gt;&gt; 	http://thread.gmane.org/gmane.comp.lang.swift.devel/1799 &lt;http://thread.gmane.org/gmane.comp.lang.swift.devel/1799&gt;<br>My opinion is that the signature of intent is the explicitly-stated conformance to the protocol, but this is not universally agreed upon (even within the core team). It suffices to say that a proposal to add some kind of “implements” keyword won’t come from me :)<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; -- Erica<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 22, 2016, at 4:33 PM, Douglas Gregor via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; A common complaint with protocol conformance checking is that it’s easy to make a little mistake when trying to implement a protocol requirement that has a default implementation. Here is a silly example:<br>&gt;&gt; <br>&gt;&gt; protocol P { <br>&gt;&gt;   func foo(value: Float)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension P {<br>&gt;&gt;   func foo(value: Float) { } // default implementation of P.foo(value:)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct S { }<br>&gt;&gt; <br>&gt;&gt; extension S : P {<br>&gt;&gt;   func foo(value: Double) { } // intended-but-incorrect attempt to satisfy the requirement P.foo(value:)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; S satisfies the requirement for P.foo(value:) using the implementation from the protocol extension, although it certainly looks like the user intended to provide a different implementation.<br>&gt;&gt; <br>&gt;&gt; This kind of problem has prompted repeated calls for some kind of “implements” keyword to indicate that one is intending to implement a protocol requirement. I, personally, *really* don’t want yet another decorator keyword to indicate the intent here, because I believe the user has already indicated intent by stating conformance to the protocol P. I’ve recently committed a number of changes that provide “near-miss” checking for optional requirements of @objc protocols (which have the same problem).<br>&gt;&gt; <br>&gt;&gt; It might be worth enabling this functionality for cases like the above as well. The Swift compiler patch to do so is attached, and will produce the following warning for the code above:<br>&gt;&gt; <br>&gt;&gt; t2.swift:12:8: warning: instance method &#39;foo(value:)&#39; nearly matches optional requirement &#39;foo(value:)&#39; of protocol &#39;P&#39;<br>&gt;&gt;   func foo(value: Double) { }<br>&gt;&gt;        ^<br>&gt;&gt; t2.swift:12:8: note: candidate has non-matching type &#39;(value: Double) -&gt; ()&#39;<br>&gt;&gt;   func foo(value: Double) { }<br>&gt;&gt;        ^<br>&gt;&gt; t2.swift:12:8: note: move &#39;foo(value:)&#39; to another extension to silence this warning<br>&gt;&gt;   func foo(value: Double) { }<br>&gt;&gt;        ^<br>&gt;&gt; t2.swift:12:8: note: make &#39;foo(value:)&#39; private to silence this warning<br>&gt;&gt;   func foo(value: Double) { }<br>&gt;&gt;        ^<br>&gt;&gt;   private <br>&gt;&gt; t2.swift:2:8: note: requirement &#39;foo(value:)&#39; declared here<br>&gt;&gt;   func foo(value: Float)<br>&gt;&gt;        ^<br>&gt;&gt; <br>&gt;&gt; It’s unfortunate that it’s a lot of notes. The first says what is wrong with the candidate (and there is much we could do to improve the precision of this diagnostic!), while the next two are mitigation strategies: move it to another extension (which implies that it’s not part of the conformance to P) or explicitly mark it as having less visibility than the conformance (in this case, private), which feels like a good way to state “I intend this to be a helper”. This might nudge Swift developers toward a style where they write one conformance per extension, but I don’t think that’s necessarily a bad thing: it’s a fine way to organize code.<br>&gt;&gt; <br>&gt;&gt; Naturally, this handles typos as well, e.g.,<br>&gt;&gt; <br>&gt;&gt; t2.swift:12:8: warning: instance method &#39;foob(value:)&#39; nearly matches optional requirement &#39;foo(value:)&#39; of protocol &#39;P&#39;<br>&gt;&gt;   func foob(value: Float) { }<br>&gt;&gt;        ^<br>&gt;&gt; t2.swift:12:8: note: rename to &#39;foo(value:)&#39; to satisfy this requirement<br>&gt;&gt;   func foob(value: Float) { }<br>&gt;&gt;        ^~~~<br>&gt;&gt;        foo<br>&gt;&gt; <br>&gt;&gt; Running this on the standard library produces a number of results:<br>&gt;&gt; <br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: warning: instance method &#39;removeLast()&#39; nearly matches optional requirement &#39;removeFirst()&#39; of protocol &#39;RangeReplaceableCollection&#39;<br>&gt;&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;&gt;                        ^<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: rename to &#39;removeFirst()&#39; to satisfy this requirement<br>&gt;&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;&gt;                        ^~~~~~~~~~<br>&gt;&gt;                        removeFirst<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: move &#39;removeLast()&#39; to another extension to silence this warning<br>&gt;&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;&gt;                        ^<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/RangeReplaceableCollection.swift:158:17: note: requirement &#39;removeFirst()&#39; declared here<br>&gt;&gt;   mutating func removeFirst() -&gt; Iterator.Element<br>&gt;&gt;                 ^<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: warning: instance method &#39;removeLast()&#39; nearly matches optional requirement &#39;removeFirst()&#39; of protocol &#39;RangeReplaceableCollection&#39;<br>&gt;&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;&gt;                        ^<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: rename to &#39;removeFirst()&#39; to satisfy this requirement<br>&gt;&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;&gt;                        ^~~~~~~~~~<br>&gt;&gt;                        removeFirst<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: move &#39;removeLast()&#39; to another extension to silence this warning<br>&gt;&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;&gt;                        ^<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/RangeReplaceableCollection.swift:158:17: note: requirement &#39;removeFirst()&#39; declared here<br>&gt;&gt;   mutating func removeFirst() -&gt; Iterator.Element<br>&gt;&gt;                 ^<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: warning: instance method &#39;removeLast()&#39; nearly matches optional requirement &#39;removeFirst()&#39; of protocol &#39;RangeReplaceableCollection&#39;<br>&gt;&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;&gt;                        ^<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: rename to &#39;removeFirst()&#39; to satisfy this requirement<br>&gt;&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;&gt;                        ^~~~~~~~~~<br>&gt;&gt;                        removeFirst<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Arrays.swift.gyb:726:24: note: move &#39;removeLast()&#39; to another extension to silence this warning<br>&gt;&gt;   public mutating func removeLast() -&gt; Element {<br>&gt;&gt;                        ^<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/RangeReplaceableCollection.swift:158:17: note: requirement &#39;removeFirst()&#39; declared here<br>&gt;&gt;   mutating func removeFirst() -&gt; Iterator.Element<br>&gt;&gt;                 ^<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/HashedCollections.swift.gyb:1077:10: warning: subscript &#39;subscript&#39; nearly matches optional requirement &#39;subscript&#39; of protocol &#39;Collection&#39;<br>&gt;&gt;   public subscript(key: Key) -&gt; Value? {<br>&gt;&gt;          ^<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/HashedCollections.swift.gyb:1077:10: note: candidate has non-matching type &#39;Key -&gt; Value?&#39; [with Iterator = DictionaryIterator&lt;Key, Value&gt;, SubSequence = Slice&lt;Dictionary&lt;Key, Value&gt;&gt;]<br>&gt;&gt;   public subscript(key: Key) -&gt; Value? {<br>&gt;&gt;          ^<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/HashedCollections.swift.gyb:1077:10: note: move &#39;subscript&#39; to an extension to silence this warning<br>&gt;&gt;   public subscript(key: Key) -&gt; Value? {<br>&gt;&gt;          ^<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Collection.swift:147:3: note: requirement &#39;subscript&#39; declared here<br>&gt;&gt;   subscript(bounds: Range&lt;Index&gt;) -&gt; SubSequence { get }<br>&gt;&gt;   ^<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Range.swift:116:10: warning: subscript &#39;subscript&#39; nearly matches optional requirement &#39;subscript&#39; of protocol &#39;Collection&#39;<br>&gt;&gt;   public subscript(_: Element._DisabledRangeIndex) -&gt; Element {<br>&gt;&gt;          ^<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Range.swift:116:10: note: candidate has non-matching type &#39;Element._DisabledRangeIndex -&gt; Element&#39; [with Iterator = RangeIterator&lt;Element&gt;, SubSequence = Slice&lt;Range&lt;Element&gt;&gt;]<br>&gt;&gt;   public subscript(_: Element._DisabledRangeIndex) -&gt; Element {<br>&gt;&gt;          ^<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Range.swift:116:10: note: move &#39;subscript&#39; to an extension to silence this warning<br>&gt;&gt;   public subscript(_: Element._DisabledRangeIndex) -&gt; Element {<br>&gt;&gt;          ^<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Collection.swift:147:3: note: requirement &#39;subscript&#39; declared here<br>&gt;&gt;   subscript(bounds: Range&lt;Index&gt;) -&gt; SubSequence { get }<br>&gt;&gt;   ^<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/ExistentialCollection.swift.gyb:508:15: warning: instance method &#39;_distance(to:)&#39; nearly matches optional requirement &#39;distance(to:)&#39; of protocol &#39;ForwardIndex&#39;<br>&gt;&gt;   public func _distance(to other: AnyForwardIndex) -&gt; AnyForwardIndex.Distance {<br>&gt;&gt;               ^<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/ExistentialCollection.swift.gyb:508:15: note: rename to &#39;distance(to:)&#39; to satisfy this requirement [with _DisabledRangeIndex = _DisabledRangeIndex_]<br>&gt;&gt;   public func _distance(to other: AnyForwardIndex) -&gt; AnyForwardIndex.Distance {<br>&gt;&gt;               ^~~~~~~~~<br>&gt;&gt;               distance<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/ExistentialCollection.swift.gyb:508:15: note: move &#39;_distance(to:)&#39; to an extension to silence this warning<br>&gt;&gt;   public func _distance(to other: AnyForwardIndex) -&gt; AnyForwardIndex.Distance {<br>&gt;&gt;               ^<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Index.swift:180:8: note: requirement &#39;distance(to:)&#39; declared here<br>&gt;&gt;   func distance(to end: Self) -&gt; Distance<br>&gt;&gt;        ^<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/ExistentialCollection.swift.gyb:508:15: warning: instance method &#39;_distance(to:)&#39; nearly matches optional requirement &#39;distance(to:)&#39; of protocol &#39;ForwardIndex&#39;<br>&gt;&gt;   public func _distance(to other: AnyBidirectionalIndex) -&gt; AnyBidirectionalIndex.Distance {<br>&gt;&gt;               ^<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/ExistentialCollection.swift.gyb:508:15: note: rename to &#39;distance(to:)&#39; to satisfy this requirement [with _DisabledRangeIndex = _DisabledRangeIndex_]<br>&gt;&gt;   public func _distance(to other: AnyBidirectionalIndex) -&gt; AnyBidirectionalIndex.Distance {<br>&gt;&gt;               ^~~~~~~~~<br>&gt;&gt;               distance<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/ExistentialCollection.swift.gyb:508:15: note: move &#39;_distance(to:)&#39; to an extension to silence this warning<br>&gt;&gt;   public func _distance(to other: AnyBidirectionalIndex) -&gt; AnyBidirectionalIndex.Distance {<br>&gt;&gt;               ^<br>&gt;&gt; /Users/dgregor/Projects/swift/swift/stdlib/public/core/Index.swift:180:8: note: requirement &#39;distance(to:)&#39; declared here<br>&gt;&gt;   func distance(to end: Self) -&gt; Distance<br>&gt;&gt;        ^<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; It’s somewhat frustrating that these are *all* false positives. However, they seem like “reasonable” false positives, in the sense that they’re close enough to the requirement to be justifiable, and the suggested recovery strategies look acceptable.<br>&gt;&gt; <br>&gt;&gt; Thoughts? Should we turn this on?<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; &lt;default-impl-near-miss.patch&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/580af271/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-dev] RFC: &quot;Near-miss&quot; checking for defaulted protocol requirements</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>April 25, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Apr 25, 2016, at 13:13, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; * I believe &quot;near miss&quot; is less important than &quot;intentional override&quot;, requiring a signature of intent as in inheritance. <br></p><p>This is a bit of a tangent, but as far as I know no one has objected to this. It&#39;s just that no one has written up a proposal that includes retroactive modeling.<br></p><p>Having an &quot;intentionally implements a protocol&quot; keyword is good, but doesn&#39;t obviate the use for near-miss checking, particularly in migration from Swift 2.2.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/7de3972d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-dev] RFC: &quot;Near-miss&quot; checking for defaulted protocol requirements</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>April 25, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Apr 25, 2016, at 15:16, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 25, 2016, at 13:13, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; * I believe &quot;near miss&quot; is less important than &quot;intentional override&quot;, requiring a signature of intent as in inheritance. <br>&gt; <br>&gt; This is a bit of a tangent, but as far as I know no one has objected to this. It&#39;s just that no one has written up a proposal that includes retroactive modeling.<br></p><p>&quot;no one except Doug&quot;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/193007f3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
