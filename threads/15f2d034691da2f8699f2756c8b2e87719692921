<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch/plea] Recursive protocol constraints</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>November 13, 2016 at 02:00:00pm</p></header><div class="content"><p>Recursive protocol constraints is one small-looking feature that could greatly improve the standard library. The generics manifesto describes it this way:<br></p><p>&quot;Currently, an associated type cannot be required to conform to its enclosing protocol (or any protocol that inherits that protocol). For example, in the standard library SubSequence type of a Sequence should itself be a Sequence:<br></p><p>protocol Sequence { associatedtype Iterator : IteratorProtocol ... associatedtype SubSequence : Sequence // currently ill-formed, but should be possible }<br>The compiler currently rejects this protocol, which is unfortunate: it effectively pushes the SubSequence-must-be-a-Sequence requirement into every consumer of SubSequence, and does not communicate the intent of this abstraction well.&quot;<br></p><p><br>It&#39;s actually slightly worse than the above implies: the standard library has a pile of underscore-prefixed protocols (e.g., _Sequence) specifically to dodge this restriction. They are ugly, and we want them to go away. Many of these places are marked with an ABI FIXME in the standard library sources. <br></p><p>Would someone like to write up a proposal for this feature? The syntax and basic semantics are pretty direct, but a proposal should also capture the expected effects on the standard library, particularly when combined with where clauses on associated types.<br></p><p>I also have a nagging feeling that we will need some form of restrictions on this feature for implementation reasons, e.g., because some recursive constraints will form unsolvable systems.<br></p><p>For reference, we&#39;ve already been implementing this feature. Some information about the compiler internal issues is captured at:<br></p><p>  https://gist.github.com/DougGregor/e7c4e7bb4465d6f5fa2b59be72dbdba6<br></p><p>  - Doug<br></p><p><br></p><p>Sent from my iPhone<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161113/15f22921/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch/plea] Recursive protocol constraints</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>November 14, 2016 at 12:00:00am</p></header><div class="content"><p>I&#39;d be happy to put something together, unless someone else wants to take<br>it on.<br></p><p>Doug, I also owe you a PR adding a minor amendment to one of the accepted<br>proposals. I&#39;ll get to that this week.<br></p><p>Austin<br></p><p>On Sun, Nov 13, 2016 at 10:13 PM, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Recursive protocol constraints is one small-looking feature that could<br>&gt; greatly improve the standard library. The generics manifesto describes it<br>&gt; this way:<br>&gt;<br>&gt; &quot;Currently, an associated type cannot be required to conform to its<br>&gt; enclosing protocol (or any protocol that inherits that protocol). For<br>&gt; example, in the standard library SubSequence type of a Sequence should<br>&gt; itself be a Sequence:<br>&gt;<br>&gt; protocol Sequence {<br>&gt;   associatedtype Iterator : IteratorProtocol<br>&gt;   ...<br>&gt;   associatedtype SubSequence : Sequence   // currently ill-formed, but should be possible}<br>&gt;<br>&gt; The compiler currently rejects this protocol, which is unfortunate: it<br>&gt; effectively pushes the SubSequence-must-be-a-Sequence requirement into<br>&gt; every consumer of SubSequence, and does not communicate the intent of<br>&gt; this abstraction well.&quot;<br>&gt;<br>&gt; &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#nested-generics&gt;It&#39;s<br>&gt; actually slightly worse than the above implies: the standard library has a<br>&gt; pile of underscore-prefixed protocols (e.g., _Sequence) specifically to<br>&gt; dodge this restriction. They are ugly, and we want them to go away. Many of<br>&gt; these places are marked with an ABI FIXME in the standard library sources.<br>&gt;<br>&gt; Would someone like to write up a proposal for this feature? The syntax and<br>&gt; basic semantics are pretty direct, but a proposal should also capture the<br>&gt; expected effects on the standard library, particularly when combined with<br>&gt; where clauses on associated types.<br>&gt;<br>&gt; I also have a nagging feeling that we will need some form of restrictions<br>&gt; on this feature for implementation reasons, e.g., because some recursive<br>&gt; constraints will form unsolvable systems.<br>&gt;<br>&gt; For reference, we&#39;ve already been implementing this feature. Some<br>&gt; information about the compiler internal issues is captured at:<br>&gt;<br>&gt;   https://gist.github.com/DougGregor/e7c4e7bb4465d6f5fa2b59be72dbdba6<br>&gt;<br>&gt;   - Doug<br>&gt;<br>&gt;<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161114/62c8544a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch/plea] Recursive protocol constraints</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>November 13, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Nov 13, 2016, at 4:03 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; I&#39;d be happy to put something together, unless someone else wants to take it on.<br></p><p>Great, thanks!<br></p><p>&gt; <br>&gt; Doug, I also owe you a PR adding a minor amendment to one of the accepted proposals. I&#39;ll get to that this week.<br></p><p>Sounds great. <br></p><p>  - Doug<br></p><p>&gt; Austin<br>&gt; <br>&gt;&gt; On Sun, Nov 13, 2016 at 10:13 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Recursive protocol constraints is one small-looking feature that could greatly improve the standard library. The generics manifesto describes it this way:<br>&gt;&gt; <br>&gt;&gt; &quot;Currently, an associated type cannot be required to conform to its enclosing protocol (or any protocol that inherits that protocol). For example, in the standard library SubSequence type of a Sequence should itself be a Sequence:<br>&gt;&gt; <br>&gt;&gt; protocol Sequence { associatedtype Iterator : IteratorProtocol ... associatedtype SubSequence : Sequence // currently ill-formed, but should be possible }<br>&gt;&gt; The compiler currently rejects this protocol, which is unfortunate: it effectively pushes the SubSequence-must-be-a-Sequence requirement into every consumer of SubSequence, and does not communicate the intent of this abstraction well.&quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; It&#39;s actually slightly worse than the above implies: the standard library has a pile of underscore-prefixed protocols (e.g., _Sequence) specifically to dodge this restriction. They are ugly, and we want them to go away. Many of these places are marked with an ABI FIXME in the standard library sources. <br>&gt;&gt; <br>&gt;&gt; Would someone like to write up a proposal for this feature? The syntax and basic semantics are pretty direct, but a proposal should also capture the expected effects on the standard library, particularly when combined with where clauses on associated types.<br>&gt;&gt; <br>&gt;&gt; I also have a nagging feeling that we will need some form of restrictions on this feature for implementation reasons, e.g., because some recursive constraints will form unsolvable systems.<br>&gt;&gt; <br>&gt;&gt; For reference, we&#39;ve already been implementing this feature. Some information about the compiler internal issues is captured at:<br>&gt;&gt; <br>&gt;&gt;   https://gist.github.com/DougGregor/e7c4e7bb4465d6f5fa2b59be72dbdba6<br>&gt;&gt; <br>&gt;&gt;   - Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161113/3707d1f1/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
