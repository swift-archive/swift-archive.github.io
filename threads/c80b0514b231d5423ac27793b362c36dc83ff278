<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>[RFC] Toolchain based build process</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>June  1, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>The current build process for the overall Swift project (i.e., the compiler + associated projects like Foundation, XCTest, and SwiftPM) relies on each project having dependencies on the built artifacts of previously built projects. Those dependencies are currently communicated to each project in the chain through an ad hoc set of arguments to the individual project&#39;s build process. This has been painful to maintain, and makes it hard to reason about the environment that each of the associated projects are building within.<br></p><p>Instead, I would like to move towards what I have been calling a &quot;toolchain-based&quot; build process.<br></p><p>In this model:<br></p><p>1. The entire build process will be organized as a sequential, incremental construction of a complete toolchain.<br>	- Each individual project will build and copy its products into a staging area.<br>2. The build script will always create a composed toolchain.<br>	- It will start with an empty toolchain, and merge in the content from each project as it builds.<br>	- This will use rsync &amp; hard-links to avoid needing to stay fast.<br>3. Each individual project build will just use the composed toolchain to build.<br>	- This will replace the grab bag of options we use to communicate between the projects.<br>4. At the end of the build, we will have constructed a complete toolchain which can be installed (or used with Xcode).<br></p><p>Aside from simplifying the overall build process, this has a couple very nice upsides:<br></p><p>1. At the end of the build, the user has a complete toolchain. They can install it, or use it as they would a distributed snapshot. This is very beneficial for people who are only building the Swift project to get a more recent version of the compiler.<br></p><p>2. Each individual project can be built using the &quot;official&quot; build process with a downloaded snapshot (assuming it is of a new enough version). This is very beneficial for easing contribution to projects like Foundation, XCTest, and SwiftPM which are pure Swift and have fast build times, but which currently build in Swift CI using a very different process from the snapshot-based workflow.<br></p><p>Concrete details:<br></p><p>1. I do not plan to change the actual install process in the short term. The actual install process used today relies on the CMake-based install process for some projects (most importantly Swift) and isn&#39;t suitable for use in this fashion (where incremental development speed is of high importance). Instead, my plan is to teach the build script itself how to assemble the staging area for each individual project, with the long term goal of using that for the official install process instead of the CMake-based process.<br></p><p>2. My plan is that the build script would only support building one &quot;primary product&quot; (i.e. toolchain). That product may itself be a complete cross compiler toolchain with support for multiple platforms, but the expectation is that users would invoke the build script multiple times if building multiple toolchains. However, to support Canadian Cross [1] build scenarios the build script may need to manage the construction of two products, the primary toolchain and the intermediate (cross compiling) toolchain used to build the artifacts in the primary toolchain.<br></p><p>3. As a concrete example of a problem this solves, SwiftPM currently doesn&#39;t test its `swift-test` product in Swift CI, because that product requires using all of the toolchain stack (swift, Foundation, and XCTest), but the product itself is only intended to be used as part of a concrete toolchain. As such, it doesn&#39;t know how to operate correctly when given the piecemeal build products for each of those projects, and teaching it to do so would be very cumbersome for us to maintain.<br></p><p>Feedback welcome!<br></p><p> - Daniel<br></p><p>[1] https://en.wikipedia.org/wiki/Cross_compiler#Canadian_Cross<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/537cdf5303cfb8f536e251c89042cbfd?s=50"></div><header><strong>[swift-dev] [RFC] Toolchain based build process</strong> from <string>Saleem Abdulrasool</string> &lt;compnerd at compnerd.org&gt;<p>June  3, 2016 at 01:00:00pm</p></header><div class="content"><p>On Wed, Jun 1, 2016 at 2:18 PM, Daniel Dunbar via swift-dev &lt;<br>swift-dev at swift.org&gt; wrote:<br></p><p>&gt; Hi all,<br>&gt;<br>&gt; The current build process for the overall Swift project (i.e., the<br>&gt; compiler + associated projects like Foundation, XCTest, and SwiftPM) relies<br>&gt; on each project having dependencies on the built artifacts of previously<br>&gt; built projects. Those dependencies are currently communicated to each<br>&gt; project in the chain through an ad hoc set of arguments to the individual<br>&gt; project&#39;s build process. This has been painful to maintain, and makes it<br>&gt; hard to reason about the environment that each of the associated projects<br>&gt; are building within.<br>&gt;<br>&gt; Instead, I would like to move towards what I have been calling a<br>&gt; &quot;toolchain-based&quot; build process.<br>&gt;<br>&gt; In this model:<br>&gt;<br>&gt; 1. The entire build process will be organized as a sequential, incremental<br>&gt; construction of a complete toolchain.<br>&gt;         - Each individual project will build and copy its products into a<br>&gt; staging area.<br>&gt; 2. The build script will always create a composed toolchain.<br>&gt;         - It will start with an empty toolchain, and merge in the content<br>&gt; from each project as it builds.<br>&gt;         - This will use rsync &amp; hard-links to avoid needing to stay fast.<br>&gt; 3. Each individual project build will just use the composed toolchain to<br>&gt; build.<br>&gt;         - This will replace the grab bag of options we use to communicate<br>&gt; between the projects.<br>&gt; 4. At the end of the build, we will have constructed a complete toolchain<br>&gt; which can be installed (or used with Xcode).<br>&gt;<br>&gt; Aside from simplifying the overall build process, this has a couple very<br>&gt; nice upsides:<br>&gt;<br>&gt; 1. At the end of the build, the user has a complete toolchain. They can<br>&gt; install it, or use it as they would a distributed snapshot. This is very<br>&gt; beneficial for people who are only building the Swift project to get a more<br>&gt; recent version of the compiler.<br>&gt;<br>&gt; 2. Each individual project can be built using the &quot;official&quot; build process<br>&gt; with a downloaded snapshot (assuming it is of a new enough version). This<br>&gt; is very beneficial for easing contribution to projects like Foundation,<br>&gt; XCTest, and SwiftPM which are pure Swift and have fast build times, but<br>&gt; which currently build in Swift CI using a very different process from the<br>&gt; snapshot-based workflow.<br>&gt;<br>&gt; Concrete details:<br>&gt;<br>&gt; 1. I do not plan to change the actual install process in the short term.<br>&gt; The actual install process used today relies on the CMake-based install<br>&gt; process for some projects (most importantly Swift) and isn&#39;t suitable for<br>&gt; use in this fashion (where incremental development speed is of high<br>&gt; importance). Instead, my plan is to teach the build script itself how to<br>&gt; assemble the staging area for each individual project, with the long term<br>&gt; goal of using that for the official install process instead of the<br>&gt; CMake-based process.<br>&gt;<br>&gt; 2. My plan is that the build script would only support building one<br>&gt; &quot;primary product&quot; (i.e. toolchain). That product may itself be a complete<br>&gt; cross compiler toolchain with support for multiple platforms, but the<br>&gt; expectation is that users would invoke the build script multiple times if<br>&gt; building multiple toolchains. However, to support Canadian Cross [1] build<br>&gt; scenarios the build script may need to manage the construction of two<br>&gt; products, the primary toolchain and the intermediate (cross compiling)<br>&gt; toolchain used to build the artifacts in the primary toolchain.<br>&gt;<br>&gt; 3. As a concrete example of a problem this solves, SwiftPM currently<br>&gt; doesn&#39;t test its `swift-test` product in Swift CI, because that product<br>&gt; requires using all of the toolchain stack (swift, Foundation, and XCTest),<br>&gt; but the product itself is only intended to be used as part of a concrete<br>&gt; toolchain. As such, it doesn&#39;t know how to operate correctly when given the<br>&gt; piecemeal build products for each of those projects, and teaching it to do<br>&gt; so would be very cumbersome for us to maintain.<br>&gt;<br>&gt; Feedback welcome!<br>&gt;<br></p><p>Overall, I think that this would be a great change.<br></p><p>I am however slightly confused on why the build script needs to be<br>concerned about candian cross at all if it can be taught how to use a<br>specified toolchain.<br></p><p>Because these (standard at least as per auto tools) terms can be confusing:<br></p><p>[1] build - the platform where things are being built<br>[2] host - the platform where the generated binaries will be run<br>[3] target - the platform where the binaries generated by the compiler on<br>the host platform will run<br></p><p>It should be possible to shift the burden on the user.  They would be<br>responsible for the first stage of the canadian cross (to build a toolchain<br>capable of generating binaries for the host platform).  Then invoke the<br>build script a second time with the toolchain they just built to<br>cross-compile the cross-compiling toolchain.<br></p><p>Or did I completely misunderstand your detail point 2 and this is the<br>expectation?<br></p><p> - Daniel<br>&gt;<br>&gt; [1] https://en.wikipedia.org/wiki/Cross_compiler#Canadian_Cross<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p><br>-- <br>Saleem Abdulrasool<br>compnerd (at) compnerd (dot) org<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160603/e0ef6e85/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
