<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] Move @noescape</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March  3, 2016 at 02:00:00pm</p></header><div class="content"><p>Chris Eidhof noticed an emergent result of removing our currying syntax: it broke some useful code using @noescape, because we only allowed it on parameter declarations, not on general things-of-function-type.  This meant that manually curried code like this:<br></p><p>func curriedFlatMap&lt;A, B&gt;(x: [A]) -&gt; (@noescape A -&gt; [B]) -&gt; [B] {<br>    return { f in<br>        x.flatMap(f)<br>    }<br>}<br></p><p>Was rejected.  Fixing this was straight-forward (https://github.com/apple/swift/commit/c3c6beac72bc0368030f06d52c46b6444fc48dbd), but required @noescape being allowed on arbitrary function types.  Now that we have that, these two declarations are equivalent:<br></p><p>	func f(@noescape fn : () -&gt; ()) {}<br>	func f(fn : @noescape () -&gt; ()) {}<br></p><p>I propose that we remove the former syntax, migrating code to the later form.  This leads to better consistency between our declarations and types, and follows the precedent of inout.  @autoclosure should also probably move as well.<br></p><p>Thoughts?<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Pitch] Move @noescape</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March  4, 2016 at 09:00:00am</p></header><div class="content"><p>Good idea. The annotation is associated with the type not with the name or<br>label.<br></p><p>On Friday, 4 March 2016, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Chris Eidhof noticed an emergent result of removing our currying syntax:<br>&gt; it broke some useful code using @noescape, because we only allowed it on<br>&gt; parameter declarations, not on general things-of-function-type.  This meant<br>&gt; that manually curried code like this:<br>&gt;<br>&gt; func curriedFlatMap&lt;A, B&gt;(x: [A]) -&gt; (@noescape A -&gt; [B]) -&gt; [B] {<br>&gt;     return { f in<br>&gt;         x.flatMap(f)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Was rejected.  Fixing this was straight-forward (<br>&gt; https://github.com/apple/swift/commit/c3c6beac72bc0368030f06d52c46b6444fc48dbd),<br>&gt; but required @noescape being allowed on arbitrary function types.  Now that<br>&gt; we have that, these two declarations are equivalent:<br>&gt;<br>&gt;         func f(@noescape fn : () -&gt; ()) {}<br>&gt;         func f(fn : @noescape () -&gt; ()) {}<br>&gt;<br>&gt; I propose that we remove the former syntax, migrating code to the later<br>&gt; form.  This leads to better consistency between our declarations and types,<br>&gt; and follows the precedent of inout.  @autoclosure should also probably move<br>&gt; as well.<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/640c3cdb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Pitch] Move @noescape</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>March  3, 2016 at 05:00:00pm</p></header><div class="content"><p>Is @autoclosure type information? To me, it feels more like a parameter attribute, so I&#39;m happy to have it on the parameter name side.<br></p><p>Félix<br></p><p>&gt; Le 3 mars 2016 à 17:01:41, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Chris Eidhof noticed an emergent result of removing our currying syntax: it broke some useful code using @noescape, because we only allowed it on parameter declarations, not on general things-of-function-type.  This meant that manually curried code like this:<br>&gt; <br>&gt; func curriedFlatMap&lt;A, B&gt;(x: [A]) -&gt; (@noescape A -&gt; [B]) -&gt; [B] {<br>&gt;    return { f in<br>&gt;        x.flatMap(f)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; Was rejected.  Fixing this was straight-forward (https://github.com/apple/swift/commit/c3c6beac72bc0368030f06d52c46b6444fc48dbd), but required @noescape being allowed on arbitrary function types.  Now that we have that, these two declarations are equivalent:<br>&gt; <br>&gt; 	func f(@noescape fn : () -&gt; ()) {}<br>&gt; 	func f(fn : @noescape () -&gt; ()) {}<br>&gt; <br>&gt; I propose that we remove the former syntax, migrating code to the later form.  This leads to better consistency between our declarations and types, and follows the precedent of inout.  @autoclosure should also probably move as well.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/31d58223/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Pitch] Move @noescape</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>March  3, 2016 at 02:00:00pm</p></header><div class="content"><p>Will this allow me to write &quot;let myDispatchSync = dispatch_sync as!<br>@noescape () -&gt; Void&quot;  ? :-D<br></p><p>Sounds good to me, the old syntax is not necessary anymore.<br></p><p>Jacob<br></p><p>On Thu, Mar 3, 2016 at 2:01 PM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Chris Eidhof noticed an emergent result of removing our currying syntax:<br>&gt; it broke some useful code using @noescape, because we only allowed it on<br>&gt; parameter declarations, not on general things-of-function-type.  This meant<br>&gt; that manually curried code like this:<br>&gt;<br>&gt; func curriedFlatMap&lt;A, B&gt;(x: [A]) -&gt; (@noescape A -&gt; [B]) -&gt; [B] {<br>&gt;     return { f in<br>&gt;         x.flatMap(f)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Was rejected.  Fixing this was straight-forward (<br>&gt; https://github.com/apple/swift/commit/c3c6beac72bc0368030f06d52c46b6444fc48dbd),<br>&gt; but required @noescape being allowed on arbitrary function types.  Now that<br>&gt; we have that, these two declarations are equivalent:<br>&gt;<br>&gt;         func f(@noescape fn : () -&gt; ()) {}<br>&gt;         func f(fn : @noescape () -&gt; ()) {}<br>&gt;<br>&gt; I propose that we remove the former syntax, migrating code to the later<br>&gt; form.  This leads to better consistency between our declarations and types,<br>&gt; and follows the precedent of inout.  @autoclosure should also probably move<br>&gt; as well.<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/450cc432/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Pitch] Move @noescape</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>March  3, 2016 at 02:00:00pm</p></header><div class="content"><p>My enthusiasm got the better of me... of course I meant (@noescape () -&gt;<br>Void) -&gt; Void.<br></p><p>On Thu, Mar 3, 2016 at 2:14 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>wrote:<br></p><p>&gt; Will this allow me to write &quot;let myDispatchSync = dispatch_sync as!<br>&gt; @noescape () -&gt; Void&quot;  ? :-D<br>&gt;<br>&gt; Sounds good to me, the old syntax is not necessary anymore.<br>&gt;<br>&gt; Jacob<br>&gt;<br>&gt; On Thu, Mar 3, 2016 at 2:01 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Chris Eidhof noticed an emergent result of removing our currying syntax:<br>&gt;&gt; it broke some useful code using @noescape, because we only allowed it on<br>&gt;&gt; parameter declarations, not on general things-of-function-type.  This meant<br>&gt;&gt; that manually curried code like this:<br>&gt;&gt;<br>&gt;&gt; func curriedFlatMap&lt;A, B&gt;(x: [A]) -&gt; (@noescape A -&gt; [B]) -&gt; [B] {<br>&gt;&gt;     return { f in<br>&gt;&gt;         x.flatMap(f)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Was rejected.  Fixing this was straight-forward (<br>&gt;&gt; https://github.com/apple/swift/commit/c3c6beac72bc0368030f06d52c46b6444fc48dbd),<br>&gt;&gt; but required @noescape being allowed on arbitrary function types.  Now that<br>&gt;&gt; we have that, these two declarations are equivalent:<br>&gt;&gt;<br>&gt;&gt;         func f(@noescape fn : () -&gt; ()) {}<br>&gt;&gt;         func f(fn : @noescape () -&gt; ()) {}<br>&gt;&gt;<br>&gt;&gt; I propose that we remove the former syntax, migrating code to the later<br>&gt;&gt; form.  This leads to better consistency between our declarations and types,<br>&gt;&gt; and follows the precedent of inout.  @autoclosure should also probably move<br>&gt;&gt; as well.<br>&gt;&gt;<br>&gt;&gt; Thoughts?<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/1a44c595/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] Move @noescape</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March  3, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Mar 3, 2016, at 2:14 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; Will this allow me to write &quot;let myDispatchSync = dispatch_sync as! @noescape () -&gt; Void&quot;  ? :-D<br></p><p>Yes,  but you need to spell it like this:<br></p><p>	let myDispatchSync = dispatch_sync as! ((dispatch_queue_t, @noescape @convention(block) () -&gt; ()) -&gt; Void)<br></p><p>The right answer here is to add @noescape to the imported symbol of course.<br></p><p>-Chris<br></p><p><br>&gt; Sounds good to me, the old syntax is not necessary anymore.<br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Thu, Mar 3, 2016 at 2:01 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Chris Eidhof noticed an emergent result of removing our currying syntax: it broke some useful code using @noescape, because we only allowed it on parameter declarations, not on general things-of-function-type.  This meant that manually curried code like this:<br>&gt; <br>&gt; func curriedFlatMap&lt;A, B&gt;(x: [A]) -&gt; (@noescape A -&gt; [B]) -&gt; [B] {<br>&gt;     return { f in<br>&gt;         x.flatMap(f)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Was rejected.  Fixing this was straight-forward (https://github.com/apple/swift/commit/c3c6beac72bc0368030f06d52c46b6444fc48dbd &lt;https://github.com/apple/swift/commit/c3c6beac72bc0368030f06d52c46b6444fc48dbd&gt;), but required @noescape being allowed on arbitrary function types.  Now that we have that, these two declarations are equivalent:<br>&gt; <br>&gt;         func f(@noescape fn : () -&gt; ()) {}<br>&gt;         func f(fn : @noescape () -&gt; ()) {}<br>&gt; <br>&gt; I propose that we remove the former syntax, migrating code to the later form.  This leads to better consistency between our declarations and types, and follows the precedent of inout.  @autoclosure should also probably move as well.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/aa2c09e5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] Move @noescape</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March  3, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Mar 3, 2016, at 4:10 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 3, 2016, at 2:14 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Will this allow me to write &quot;let myDispatchSync = dispatch_sync as! @noescape () -&gt; Void&quot;  ? :-D<br>&gt; <br>&gt; Yes,  but you need to spell it like this:<br>&gt; <br>&gt; 	let myDispatchSync = dispatch_sync as! ((dispatch_queue_t, @noescape @convention(block) () -&gt; ()) -&gt; Void)<br></p><p>Ah, while this syntactically parses, but the cast is considered to fail at runtime given that it is not a safe conversion.  This is the domain of an unsafe cast.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/2a01550c/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Move @noescape</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  3, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; Chris Eidhof noticed an emergent result of removing our currying syntax: it broke some useful code using @noescape, because we only allowed it on parameter declarations, not on general things-of-function-type.  This meant that manually curried code like this:<br>&gt; <br>&gt; func curriedFlatMap&lt;A, B&gt;(x: [A]) -&gt; (@noescape A -&gt; [B]) -&gt; [B] {<br>&gt;    return { f in<br>&gt;        x.flatMap(f)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; Was rejected.  Fixing this was straight-forward (https://github.com/apple/swift/commit/c3c6beac72bc0368030f06d52c46b6444fc48dbd), but required @noescape being allowed on arbitrary function types.  Now that we have that, these two declarations are equivalent:<br>&gt; <br>&gt; 	func f(@noescape fn : () -&gt; ()) {}<br>&gt; 	func f(fn : @noescape () -&gt; ()) {}<br>&gt; <br>&gt; I propose that we remove the former syntax, migrating code to the later form.  This leads to better consistency between our declarations and types, and follows the precedent of inout.  @autoclosure should also probably move as well.<br>&gt; <br>&gt; Thoughts?<br></p><p>I suppose that makes sense.<br></p><p>While we&#39;re here, it actually occurred to me a while ago that `@noescape` could be applied to reference types as well as closures, indicating that the function doesn&#39;t keep them alive in the long run. Would that be useful information for the Swift compiler? I could imagine it helping the compiler to pin down the lifetimes of temporary objects, for instance.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Move @noescape</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  3, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; I suppose that makes sense.<br></p><p>Sorry to double-post, but I&#39;m actually rethinking @autoclosure.<br></p><p>My feeling is that we should only attach information to the *type* if it follows the value around and if, at least in principle, it would make sense in at least some other type-like contexts. @noescape fits the bill; I can easily see the semantics and utility of this:<br></p><p>	let closure: @noescape Foo -&gt; Bool = { $0.isBar }<br></p><p>But @autoclosure isn&#39;t the same way. It&#39;s concerned with the syntax used in the parameter list, not the semantics. Perhaps I would feel differently if it were an attribute that said &quot;make this a computed variable bound to an expression which changes every time you set it&quot;:<br></p><p>	var currentDate: @expression NSDate = NSDate()<br>	if useServerDate {<br>		time = server.currentDate()<br>	}<br></p><p>But that&#39;s not what @autoclosure does; it takes an expression, wraps it in a closure, and drops it into an otherwise perfectly normal variable. That just doesn&#39;t feel like functionality that should be attached to a type.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] Move @noescape</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March  3, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Mar 3, 2016, at 3:01 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; I suppose that makes sense.<br>&gt; <br>&gt; Sorry to double-post, but I&#39;m actually rethinking @autoclosure.<br>&gt; <br>&gt; My feeling is that we should only attach information to the *type* if it follows the value around and if, at least in principle, it would make sense in at least some other type-like contexts. <br></p><p>I think it does, and let me illustrate why.  Consider an autoclosure-taking function like this (one silly example):<br></p><p>	func f(@autoclosure a : () -&gt; ()) {}<br></p><p>You can use it as you’d expect, e.g.:<br></p><p>	f(print(&quot;hello”))<br></p><p>Of course, f is a first class value, and you can assign it:<br></p><p>	let x = f<br>	x(print(&quot;hello&quot;))<br></p><p>This works, because x has type &quot;(@autoclosure () -&gt; ()) -&gt; ()”.  You can see this if you force a type error:<br></p><p>	let y : Int = x<br>	// error: cannot convert value of type &#39;(@autoclosure () -&gt; ()) -&gt; ()&#39; to specified type &#39;Int&#39;<br></p><p>However, you can’t write this out explicitly:<br></p><p>	let x2 : (@autoclosure () -&gt; ()) -&gt; () = f<br>	// error: attribute can only be applied to declarations, not types<br></p><p>This seems dumb to me :-) you should be able to write the type for any declaration you can produce.  Once you do that, it makes sense to spell the original function as:<br></p><p>	func f(a : @autoclosure () -&gt; ()) {}<br></p><p>for consistency.  Yes, I totally get the irony of the fact that @autoclosure used to be on the type in swift 1.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Move @noescape</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  4, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt;&gt; My feeling is that we should only attach information to the *type* if it follows the value around and if, at least in principle, it would make sense in at least some other type-like contexts. <br>&gt; <br>&gt; I think it does, and let me illustrate why.  Consider an autoclosure-taking function like this (one silly example):<br>&gt; <br>&gt; 	func f(@autoclosure a : () -&gt; ()) {}<br>&gt; <br>&gt; You can use it as you’d expect, e.g.:<br>&gt; <br>&gt; 	f(print(&quot;hello”))<br>&gt; <br>&gt; Of course, f is a first class value, and you can assign it:<br>&gt; <br>&gt; 	let x = f<br>&gt; 	x(print(&quot;hello&quot;))<br>&gt; <br>&gt; This works, because x has type &quot;(@autoclosure () -&gt; ()) -&gt; ()”.  You can see this if you force a type error:<br>&gt; <br>&gt; 	let y : Int = x<br>&gt; 	// error: cannot convert value of type &#39;(@autoclosure () -&gt; ()) -&gt; ()&#39; to specified type &#39;Int&#39;<br>&gt; <br>&gt; However, you can’t write this out explicitly:<br>&gt; <br>&gt; 	let x2 : (@autoclosure () -&gt; ()) -&gt; () = f<br>&gt; 	// error: attribute can only be applied to declarations, not types<br>&gt; <br>&gt; This seems dumb to me :-) you should be able to write the type for any declaration you can produce.  Once you do that, it makes sense to spell the original function as:<br>&gt; <br>&gt; 	func f(a : @autoclosure () -&gt; ()) {}<br>&gt; <br>&gt; for consistency.  Yes, I totally get the irony of the fact that @autoclosure used to be on the type in swift 1.<br></p><p>How much sense does it really make to have a closure with an @autoclosure parameter, though? @autoclosure is meant to be syntactic sugar for when a function needs to control the evaluation of its parameters, like `&amp;&amp;` or `Result(try something())`. Does that feature make sense for closures? Even if it does, does it make sense for there to be a type error when you pass a `Foo -&gt; Bar` where an `@autoclosure Foo -&gt; Bar` is expected, or vice versa?<br></p><p>I think it might make more sense to think of your `f` as having the type `(() -&gt; ()) -&gt; Void` and have the @autoclosure-ness of particular parameters be something that&#39;s attached to `f` itself, not the function inside it. Just as a function&#39;s access level or @objc-ness isn&#39;t part of its type, nor is the @autoclosure-ness of its parameters.<br></p><p>Even if we decide we have to support @autoclosure on closures, if we turn parameter labels into a feature of the variable&#39;s name instead of its type (which I believe I&#39;ve seen discussed), we will have an opportunity to specify that:<br></p><p>	let x2(@autoclosure _:): (() -&gt; ()) -&gt; () = f		// no parameter label<br>	let x2(@autoclosure x:): (() -&gt; ()) -&gt; () = f		// adding a parameter label<br></p><p>Or you could just shed the autoclosure-ness of the parameter by writing any of these:<br></p><p>	let x2 = f									// inferring the type<br>	let x2: (() -&gt; ()) -&gt; () = f						// stating it explicitly<br>	let x2(x:): (() -&gt; ()) -&gt; () = f					// adding a parameter label<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] Move @noescape</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March  4, 2016 at 11:00:00pm</p></header><div class="content"><p>On Mar 4, 2016, at 9:32 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; This seems dumb to me :-) you should be able to write the type for any declaration you can produce.  Once you do that, it makes sense to spell the original function as:<br>&gt;&gt; <br>&gt;&gt; 	func f(a : @autoclosure () -&gt; ()) {}<br>&gt;&gt; <br>&gt;&gt; for consistency.  Yes, I totally get the irony of the fact that @autoclosure used to be on the type in swift 1.<br>&gt; <br>&gt; How much sense does it really make to have a closure with an @autoclosure parameter, though? @autoclosure is meant to be syntactic sugar for when a function needs to control the evaluation of its parameters, like `&amp;&amp;` or `Result(try something())`. Does that feature make sense for closures?<br></p><p>I don’t think that it is wildly “widely useful”, but yes, it certainly makes sense.  Not having it makes the language less orthogonal.<br></p><p>&gt; Even if it does, does it make sense for there to be a type error when you pass a `Foo -&gt; Bar` where an `@autoclosure Foo -&gt; Bar` is expected, or vice versa?<br></p><p>That is orthogonal to my proposal, but yes, these are different function types since they have different behaviors at the use site.<br></p><p>&gt; Even if we decide we have to support @autoclosure on closures, if we turn parameter labels into a feature of the variable&#39;s name instead of its type (which I believe I&#39;ve seen discussed),<br></p><p>I don’t expect that to happen (because, e.g. that would fundamentally change how currying methods works), but if it does, we can certainly re-evaluate this.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Pitch] Move @noescape</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March  6, 2016 at 07:00:00am</p></header><div class="content"><p>Another point. I prefer lines to be ordered from most important bit of<br>information to least. That is why I prefer trailing &#39;:&#39; type information to<br>C-style declarations. Therefore my preference would be:<br></p><p>    func f(a: () -&gt; () @autoclosure) {}<br></p><p>Since the name is the most important, the type the next most, and lastly<br>the annotation is the least important bit of information.<br></p><p>On Saturday, 5 March 2016, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Mar 4, 2016, at 9:32 PM, Brent Royal-Gordon &lt;brent at architechies.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt; This seems dumb to me :-) you should be able to write the type for any<br>&gt; declaration you can produce.  Once you do that, it makes sense to spell the<br>&gt; original function as:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;      func f(a : @autoclosure () -&gt; ()) {}<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; for consistency.  Yes, I totally get the irony of the fact that<br>&gt; @autoclosure used to be on the type in swift 1.<br>&gt; &gt;<br>&gt; &gt; How much sense does it really make to have a closure with an<br>&gt; @autoclosure parameter, though? @autoclosure is meant to be syntactic sugar<br>&gt; for when a function needs to control the evaluation of its parameters, like<br>&gt; `&amp;&amp;` or `Result(try something())`. Does that feature make sense for<br>&gt; closures?<br>&gt;<br>&gt; I don’t think that it is wildly “widely useful”, but yes, it certainly<br>&gt; makes sense.  Not having it makes the language less orthogonal.<br>&gt;<br>&gt; &gt; Even if it does, does it make sense for there to be a type error when<br>&gt; you pass a `Foo -&gt; Bar` where an `@autoclosure Foo -&gt; Bar` is expected, or<br>&gt; vice versa?<br>&gt;<br>&gt; That is orthogonal to my proposal, but yes, these are different function<br>&gt; types since they have different behaviors at the use site.<br>&gt;<br>&gt; &gt; Even if we decide we have to support @autoclosure on closures, if we<br>&gt; turn parameter labels into a feature of the variable&#39;s name instead of its<br>&gt; type (which I believe I&#39;ve seen discussed),<br>&gt;<br>&gt; I don’t expect that to happen (because, e.g. that would fundamentally<br>&gt; change how currying methods works), but if it does, we can certainly<br>&gt; re-evaluate this.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160306/d9c9a21c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Pitch] Move @noescape</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March  8, 2016 at 03:00:00pm</p></header><div class="content"><p>This is problematic when there are multiple levels of closure:<br></p><p>fn: (Int) -&gt; (Int) -&gt; (Int, Int) @convention(block)<br>// without the attribute, equivalent to<br>fn: (Int) -&gt; ((Int) -&gt; (Int, Int))<br></p><p>Of course neither @noescape nor @autoclosure can apply to an arbitrary function value, but @convention can.<br></p><p>It&#39;s also inconsistent with all other attributes in the language. I see the idea of most-to-least important, but I don&#39;t think it actually results in a more readable syntax here.<br></p><p>Jordan<br></p><p><br>&gt; On Mar 5, 2016, at 12:43, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Another point. I prefer lines to be ordered from most important bit of information to least. That is why I prefer trailing &#39;:&#39; type information to C-style declarations. Therefore my preference would be:<br>&gt; <br>&gt;     func f(a: () -&gt; () @autoclosure) {}<br>&gt; <br>&gt; Since the name is the most important, the type the next most, and lastly the annotation is the least important bit of information. <br>&gt; <br>&gt; On Saturday, 5 March 2016, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; On Mar 4, 2016, at 9:32 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt; This seems dumb to me :-) you should be able to write the type for any declaration you can produce.  Once you do that, it makes sense to spell the original function as:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;      func f(a : @autoclosure () -&gt; ()) {}<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; for consistency.  Yes, I totally get the irony of the fact that @autoclosure used to be on the type in swift 1.<br>&gt; &gt;<br>&gt; &gt; How much sense does it really make to have a closure with an @autoclosure parameter, though? @autoclosure is meant to be syntactic sugar for when a function needs to control the evaluation of its parameters, like `&amp;&amp;` or `Result(try something())`. Does that feature make sense for closures?<br>&gt; <br>&gt; I don’t think that it is wildly “widely useful”, but yes, it certainly makes sense.  Not having it makes the language less orthogonal.<br>&gt; <br>&gt; &gt; Even if it does, does it make sense for there to be a type error when you pass a `Foo -&gt; Bar` where an `@autoclosure Foo -&gt; Bar` is expected, or vice versa?<br>&gt; <br>&gt; That is orthogonal to my proposal, but yes, these are different function types since they have different behaviors at the use site.<br>&gt; <br>&gt; &gt; Even if we decide we have to support @autoclosure on closures, if we turn parameter labels into a feature of the variable&#39;s name instead of its type (which I believe I&#39;ve seen discussed),<br>&gt; <br>&gt; I don’t expect that to happen (because, e.g. that would fundamentally change how currying methods works), but if it does, we can certainly re-evaluate this.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; -- Howard.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/b6975e94/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Pitch] Move @noescape</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 10, 2016 at 03:00:00pm</p></header><div class="content"><p>You could use brackets, e.g.:<br></p><p>fn: (Int) -&gt; (Int) -&gt; (Int, Int) @convention(block)<br></p><p>// Is the same as:<br></p><p>fn: (Int) -&gt; ((Int) -&gt; (Int, Int)) @convention(block)<br>// Which is not the same as:<br>fn: (Int) -&gt; ((Int) -&gt; (Int, Int) @convention(block))<br></p><p><br></p><p>  -- Howard.<br></p><p>On 9 March 2016 at 10:16, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; This is problematic when there are multiple levels of closure:<br>&gt;<br>&gt; fn: (Int) -&gt; (Int) -&gt; (Int, Int) @convention(block)<br>&gt;<br>&gt; // without the attribute, equivalent to<br>&gt;<br>&gt; fn: (Int) -&gt; ((Int) -&gt; (Int, Int))<br>&gt;<br>&gt;<br>&gt; Of course neither @noescape nor @autoclosure can apply to an arbitrary<br>&gt; function value, but @convention can.<br>&gt;<br>&gt; It&#39;s also inconsistent with all other attributes in the language. I see<br>&gt; the idea of most-to-least important, but I don&#39;t think it actually results<br>&gt; in a more readable syntax here.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On Mar 5, 2016, at 12:43, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Another point. I prefer lines to be ordered from most important bit of<br>&gt; information to least. That is why I prefer trailing &#39;:&#39; type information<br>&gt; to C-style declarations. Therefore my preference would be:<br>&gt;<br>&gt;     func f(a: () -&gt; () @autoclosure) {}<br>&gt;<br>&gt; Since the name is the most important, the type the next most, and lastly<br>&gt; the annotation is the least important bit of information.<br>&gt;<br>&gt; On Saturday, 5 March 2016, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Mar 4, 2016, at 9:32 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt; This seems dumb to me :-) you should be able to write the type for any<br>&gt;&gt; declaration you can produce.  Once you do that, it makes sense to spell the<br>&gt;&gt; original function as:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;      func f(a : @autoclosure () -&gt; ()) {}<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; for consistency.  Yes, I totally get the irony of the fact that<br>&gt;&gt; @autoclosure used to be on the type in swift 1.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; How much sense does it really make to have a closure with an<br>&gt;&gt; @autoclosure parameter, though? @autoclosure is meant to be syntactic sugar<br>&gt;&gt; for when a function needs to control the evaluation of its parameters, like<br>&gt;&gt; `&amp;&amp;` or `Result(try something())`. Does that feature make sense for<br>&gt;&gt; closures?<br>&gt;&gt;<br>&gt;&gt; I don’t think that it is wildly “widely useful”, but yes, it certainly<br>&gt;&gt; makes sense.  Not having it makes the language less orthogonal.<br>&gt;&gt;<br>&gt;&gt; &gt; Even if it does, does it make sense for there to be a type error when<br>&gt;&gt; you pass a `Foo -&gt; Bar` where an `@autoclosure Foo -&gt; Bar` is expected, or<br>&gt;&gt; vice versa?<br>&gt;&gt;<br>&gt;&gt; That is orthogonal to my proposal, but yes, these are different function<br>&gt;&gt; types since they have different behaviors at the use site.<br>&gt;&gt;<br>&gt;&gt; &gt; Even if we decide we have to support @autoclosure on closures, if we<br>&gt;&gt; turn parameter labels into a feature of the variable&#39;s name instead of its<br>&gt;&gt; type (which I believe I&#39;ve seen discussed),<br>&gt;&gt;<br>&gt;&gt; I don’t expect that to happen (because, e.g. that would fundamentally<br>&gt;&gt; change how currying methods works), but if it does, we can certainly<br>&gt;&gt; re-evaluate this.<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; -- Howard.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/48434924/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] Move @noescape</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March  3, 2016 at 03:00:00pm</p></header><div class="content"><p>On Mar 3, 2016, at 2:48 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; I propose that we remove the former syntax, migrating code to the later form.  This leads to better consistency between our declarations and types, and follows the precedent of inout. @autoclosure should also probably move as well.<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt; <br>&gt; I suppose that makes sense.<br>&gt; <br>&gt; While we&#39;re here, it actually occurred to me a while ago that `@noescape` could be applied to reference types as well as closures, indicating that the function doesn&#39;t keep them alive in the long run. Would that be useful information for the Swift compiler? I could imagine it helping the compiler to pin down the lifetimes of temporary objects, for instance.<br></p><p>This proposal is merely a syntactic one, but there are a number of orthogonal functionality extensions that we could consider, e.g. allowing noescape members inside structs and enums, supporting noescape optional functions e.g.:<br></p><p>	func f(a : @noescape (()-&gt;())?) {…}<br></p><p>etc.  These sorts of proposals are all interesting and useful, but need to be individually motivated, to make sure the complexity burden added by them is justified.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
