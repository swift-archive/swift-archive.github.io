<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/389ea0cf26e2a2d4646bf580da2fb6b5?s=50"></div><header><strong>Type inference when assigning the result of reduce to a dictionary</strong> from <string>Martin R</string> &lt;martinr448 at gmail.com&gt;<p>October  4, 2016 at 02:00:00pm</p></header><div class="content"><p>I noticed the following when assigning the result of `reduce()` to a dictionary:<br></p><p>    let array = [1, 2, 3]<br>    var dict: [Int: Int] = [:]<br>    dict[0] = array.reduce(0, { $0 + $1 }) // (A)<br>    // error: binary operator &#39;+&#39; cannot be applied to operands of<br>type &#39;Int?&#39; and &#39;Int&#39;<br>    // dict[0] = array.reduce(0, { $0 + $1 })<br>    //                             ~~ ^ ~~<br></p><p>It seems that the compiler tries to make the RHS an `Int?` and<br>therefore infers the type of the initial value `0` and the<br>accumulating value `$0` as `Int?`.<br></p><p>That is in some sense correct, since the dictionary subscript setter<br>takes an optional as parameter, in this case `Int?`.<br></p><p>However, the code compiles (and runs as expected) if the trailing<br>closure syntax is used:<br></p><p>    dict[0] = array.reduce(0) { $0 + $1 } // (B)<br></p><p>and also if the initial value is given as `0` instead of `Int(0)`:<br></p><p>    dict[0] = array.reduce(Int(0), { $0 + $1 }) // (C)<br></p><p>My questions are:<br>- Should (A) compile?<br>- Why does it make a difference if the trailing closure syntax is used<br>(A vs. B)?<br>- Why does it make a difference if the initial value is given as `0`<br>or `Int(0)` (A vs. C)?<br></p><p>Regards,<br>Martin<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Type inference when assigning the result of reduce to a dictionary</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October  4, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Oct 4, 2016, at 5:20 AM, Martin R via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I noticed the following when assigning the result of `reduce()` to a dictionary:<br>&gt; <br>&gt;    let array = [1, 2, 3]<br>&gt;    var dict: [Int: Int] = [:]<br>&gt;    dict[0] = array.reduce(0, { $0 + $1 }) // (A)<br>&gt;    // error: binary operator &#39;+&#39; cannot be applied to operands of<br>&gt; type &#39;Int?&#39; and &#39;Int&#39;<br>&gt;    // dict[0] = array.reduce(0, { $0 + $1 })<br>&gt;    //                             ~~ ^ ~~<br>&gt; <br>&gt; It seems that the compiler tries to make the RHS an `Int?` and<br>&gt; therefore infers the type of the initial value `0` and the<br>&gt; accumulating value `$0` as `Int?`.<br>&gt; <br>&gt; That is in some sense correct, since the dictionary subscript setter<br>&gt; takes an optional as parameter, in this case `Int?`.<br>&gt; <br>&gt; However, the code compiles (and runs as expected) if the trailing<br>&gt; closure syntax is used:<br>&gt; <br>&gt;    dict[0] = array.reduce(0) { $0 + $1 } // (B)<br>&gt; <br>&gt; and also if the initial value is given as `0` instead of `Int(0)`:<br>&gt; <br>&gt;    dict[0] = array.reduce(Int(0), { $0 + $1 }) // (C)<br>&gt; <br>&gt; My questions are:<br>&gt; - Should (A) compile?<br>&gt; - Why does it make a difference if the trailing closure syntax is used<br>&gt; (A vs. B)?<br>&gt; - Why does it make a difference if the initial value is given as `0`<br>&gt; or `Int(0)` (A vs. C)?<br></p><p>No good reason. Got time to file a bug?<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/389ea0cf26e2a2d4646bf580da2fb6b5?s=50"></div><header><strong>Type inference when assigning the result of reduce to a dictionary</strong> from <string>Martin R</string> &lt;martinr448 at gmail.com&gt;<p>October  4, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 4 Oct 2016, at 21:42, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 4, 2016, at 5:20 AM, Martin R via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I noticed the following when assigning the result of `reduce()` to a dictionary:<br>&gt;&gt; <br>&gt;&gt;   let array = [1, 2, 3]<br>&gt;&gt;   var dict: [Int: Int] = [:]<br>&gt;&gt;   dict[0] = array.reduce(0, { $0 + $1 }) // (A)<br>&gt;&gt;   // error: binary operator &#39;+&#39; cannot be applied to operands of<br>&gt;&gt; type &#39;Int?&#39; and &#39;Int&#39;<br>&gt;&gt;   // dict[0] = array.reduce(0, { $0 + $1 })<br>&gt;&gt;   //                             ~~ ^ ~~<br>&gt;&gt; <br>&gt;&gt; It seems that the compiler tries to make the RHS an `Int?` and<br>&gt;&gt; therefore infers the type of the initial value `0` and the<br>&gt;&gt; accumulating value `$0` as `Int?`.<br>&gt;&gt; <br>&gt;&gt; That is in some sense correct, since the dictionary subscript setter<br>&gt;&gt; takes an optional as parameter, in this case `Int?`.<br>&gt;&gt; <br>&gt;&gt; However, the code compiles (and runs as expected) if the trailing<br>&gt;&gt; closure syntax is used:<br>&gt;&gt; <br>&gt;&gt;   dict[0] = array.reduce(0) { $0 + $1 } // (B)<br>&gt;&gt; <br>&gt;&gt; and also if the initial value is given as `0` instead of `Int(0)`:<br>&gt;&gt; <br>&gt;&gt;   dict[0] = array.reduce(Int(0), { $0 + $1 }) // (C)<br>&gt;&gt; <br>&gt;&gt; My questions are:<br>&gt;&gt; - Should (A) compile?<br>&gt;&gt; - Why does it make a difference if the trailing closure syntax is used<br>&gt;&gt; (A vs. B)?<br>&gt;&gt; - Why does it make a difference if the initial value is given as `0`<br>&gt;&gt; or `Int(0)` (A vs. C)?<br>&gt; <br>&gt; No good reason. Got time to file a bug?<br>&gt; <br>&gt; -Joe<br></p><p>Done: https://bugs.swift.org/browse/SR-2853 .<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Type inference when assigning the result of reduce to a dictionary</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October  4, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Oct 4, 2016, at 1:58 PM, Martin R &lt;martinr448 at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 4 Oct 2016, at 21:42, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 4, 2016, at 5:20 AM, Martin R via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I noticed the following when assigning the result of `reduce()` to a dictionary:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  let array = [1, 2, 3]<br>&gt;&gt;&gt;  var dict: [Int: Int] = [:]<br>&gt;&gt;&gt;  dict[0] = array.reduce(0, { $0 + $1 }) // (A)<br>&gt;&gt;&gt;  // error: binary operator &#39;+&#39; cannot be applied to operands of<br>&gt;&gt;&gt; type &#39;Int?&#39; and &#39;Int&#39;<br>&gt;&gt;&gt;  // dict[0] = array.reduce(0, { $0 + $1 })<br>&gt;&gt;&gt;  //                             ~~ ^ ~~<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems that the compiler tries to make the RHS an `Int?` and<br>&gt;&gt;&gt; therefore infers the type of the initial value `0` and the<br>&gt;&gt;&gt; accumulating value `$0` as `Int?`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is in some sense correct, since the dictionary subscript setter<br>&gt;&gt;&gt; takes an optional as parameter, in this case `Int?`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, the code compiles (and runs as expected) if the trailing<br>&gt;&gt;&gt; closure syntax is used:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  dict[0] = array.reduce(0) { $0 + $1 } // (B)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and also if the initial value is given as `0` instead of `Int(0)`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  dict[0] = array.reduce(Int(0), { $0 + $1 }) // (C)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My questions are:<br>&gt;&gt;&gt; - Should (A) compile?<br>&gt;&gt;&gt; - Why does it make a difference if the trailing closure syntax is used<br>&gt;&gt;&gt; (A vs. B)?<br>&gt;&gt;&gt; - Why does it make a difference if the initial value is given as `0`<br>&gt;&gt;&gt; or `Int(0)` (A vs. C)?<br>&gt;&gt; <br>&gt;&gt; No good reason. Got time to file a bug?<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br>&gt; Done: https://bugs.swift.org/browse/SR-2853 .<br></p><p>Thanks!<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
