<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ac24d28fde53d4a6f05a6dcbb781a002?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Nutchaphon Rewik</string> &lt;nRewik at outlook.com&gt;<p>December 18, 2015 at 07:00:00pm</p></header><div class="content"><p>I only see the benefits on this.<br></p><p>  1.  We don&#39;t have to store all states in one file. States can be stored separately. So, we can write code in more composition style.<br>  2.  We can add new states to the existing type. Not just NSObject subclass with associated object.<br></p><p>protocol Incrementer{<br></p><p>   func increase()<br>}<br></p><p>extension Incrementer{<br></p><p><br>   var count = 1 //<br> allows stored properties<br></p><p>    func increase(){<br></p><p>       print(count)<br>        count = count + 1<br></p><p>   }<br></p><p>}<br></p><p><br></p><p><br>&gt; On Dec 8, 2015, at 10:51 AM, Kevin Kachikian via swift-evolution &lt;swift-evolution at swift.org&lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;<br>&gt; I&#39;d like to proposal to the Swift community and discuss the advantages and disadvantages of adding modifiable properties to extensions (in addition to the already existing computed properties, instance methods, subscripts, etc.):<br>&gt;<br>&gt; extension SomeType {<br>&gt;<br>&gt;       var aNewProperty: Int<br>&gt;       var anotherVariable: String<br>&gt;       var aThirdOne: MyStruct<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/8cb2acb8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 18, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; I only see the benefits on this.<br>&gt; 	• We don&#39;t have to store all states in one file. States can be stored separately. So, we can write code in more composition style.<br>&gt; 	• We can add new states to the existing type. Not just NSObject subclass with associated object.<br></p><p>I think people generally want this; the question is how to implement it, and especially how to implement it *without* either limiting it to types in the same module, or dangling what amounts to a dictionary off every single object and struct. (Structs are more difficult than objects, because they don’t have stable identities.) Any ideas?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 18, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 12:49 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I only see the benefits on this.<br>&gt;&gt; 	• We don&#39;t have to store all states in one file. States can be stored separately. So, we can write code in more composition style.<br>&gt;&gt; 	• We can add new states to the existing type. Not just NSObject subclass with associated object.<br>&gt; <br>&gt; I think people generally want this; the question is how to implement it, and especially how to implement it *without* either limiting it to types in the same module, or dangling what amounts to a dictionary off every single object and struct. (Structs are more difficult than objects, because they don’t have stable identities.) Any ideas?<br></p><p>You could say that types whose conformance to the protocol lives in the same module as the type itself get the default property storage, but external extensions that introduce the conformance can&#39;t use the default stored property and have to supply their own implementation.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 18, 2015 at 03:00:00pm</p></header><div class="content"><p>On Fri, Dec 18, 2015, at 03:15 PM, Joe Groff via swift-evolution wrote:<br>&gt; <br>&gt; &gt; On Dec 18, 2015, at 12:49 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt;&gt; I only see the benefits on this.<br>&gt; &gt;&gt; 	• We don&#39;t have to store all states in one file. States can be stored separately. So, we can write code in more composition style.<br>&gt; &gt;&gt; 	• We can add new states to the existing type. Not just NSObject subclass with associated object.<br>&gt; &gt; <br>&gt; &gt; I think people generally want this; the question is how to implement it, and especially how to implement it *without* either limiting it to types in the same module, or dangling what amounts to a dictionary off every single object and struct. (Structs are more difficult than objects, because they don’t have stable identities.) Any ideas?<br>&gt; <br>&gt; You could say that types whose conformance to the protocol lives in the same module as the type itself get the default property storage, but external extensions that introduce the conformance can&#39;t use the default stored property and have to supply their own implementation.<br></p><p>AFAIK there&#39;s no precedent today for extensions in the same module being able to do things that extensions in other modules can&#39;t do (beyond accessing `internal` members of course). I&#39;m not completely opposed to the idea, but I would want to be very careful and make sure there&#39;s an extremely clear benefit to changing it so extensions in the same module can add extra storage.<br></p><p>One potentially large downside is you can no longer look at a type declaration and find out how large it is. For example, I could define<br></p><p>struct Foo {<br>    var x: Int<br>}<br></p><p>and it looks like a tiny struct, but I could then add an extension in a separate file that bloats that out to some ridiculously massive struct, and that wouldn&#39;t be obvious from looking at it.<br></p><p>That said, when looking at a definition imported from another module, you can&#39;t see which properties are computed and which are stored anyway, so it&#39;s maybe not a huge deal (although you can assume any property defined in an extension is computed). But it is still something to consider.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 18, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 3:24 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Fri, Dec 18, 2015, at 03:15 PM, Joe Groff via swift-evolution wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 18, 2015, at 12:49 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I only see the benefits on this.<br>&gt;&gt;&gt;&gt; 	• We don&#39;t have to store all states in one file. States can be stored separately. So, we can write code in more composition style.<br>&gt;&gt;&gt;&gt; 	• We can add new states to the existing type. Not just NSObject subclass with associated object.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think people generally want this; the question is how to implement it, and especially how to implement it *without* either limiting it to types in the same module, or dangling what amounts to a dictionary off every single object and struct. (Structs are more difficult than objects, because they don’t have stable identities.) Any ideas?<br>&gt;&gt; <br>&gt;&gt; You could say that types whose conformance to the protocol lives in the same module as the type itself get the default property storage, but external extensions that introduce the conformance can&#39;t use the default stored property and have to supply their own implementation.<br>&gt; <br>&gt; AFAIK there&#39;s no precedent today for extensions in the same module being able to do things that extensions in other modules can&#39;t do (beyond accessing `internal` members of course). I&#39;m not completely opposed to the idea, but I would want to be very careful and make sure there&#39;s an extremely clear benefit to changing it so extensions in the same module can add extra storage.<br>&gt; <br>&gt; One potentially large downside is you can no longer look at a type declaration and find out how large it is. For example, I could define<br>&gt; <br>&gt; struct Foo {<br>&gt;    var x: Int<br>&gt; }<br>&gt; <br>&gt; and it looks like a tiny struct, but I could then add an extension in a separate file that bloats that out to some ridiculously massive struct, and that wouldn&#39;t be obvious from looking at it.<br>&gt; <br>&gt; That said, when looking at a definition imported from another module, you can&#39;t see which properties are computed and which are stored anyway, so it&#39;s maybe not a huge deal (although you can assume any property defined in an extension is computed). But it is still something to consider.<br></p><p>True, this is a tradeoff. We&#39;ve discussed moving in the direction of allowing same-module extensions to do anything that can be done in the original type declaration, to allow freedom of organization without arbitrary rules about what must go in the type, but sizing instances was one of our concerns. (You could always peek at the LLVM IR if you want to know for sure what&#39;s getting generated.)<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/b7dc5fc1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 18, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 3:34 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 18, 2015, at 3:24 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; AFAIK there&#39;s no precedent today for extensions in the same module being able to do things that extensions in other modules can&#39;t do (beyond accessing `internal` members of course). I&#39;m not completely opposed to the idea, but I would want to be very careful and make sure there&#39;s an extremely clear benefit to changing it so extensions in the same module can add extra storage.<br>&gt;&gt; <br>&gt;&gt; One potentially large downside is you can no longer look at a type declaration and find out how large it is. For example, I could define<br>&gt;&gt; <br>&gt;&gt; struct Foo {<br>&gt;&gt;    var x: Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; and it looks like a tiny struct, but I could then add an extension in a separate file that bloats that out to some ridiculously massive struct, and that wouldn&#39;t be obvious from looking at it.<br>&gt;&gt; <br>&gt;&gt; That said, when looking at a definition imported from another module, you can&#39;t see which properties are computed and which are stored anyway, so it&#39;s maybe not a huge deal (although you can assume any property defined in an extension is computed). But it is still something to consider.<br>&gt; <br>&gt; True, this is a tradeoff. We&#39;ve discussed moving in the direction of allowing same-module extensions to do anything that can be done in the original type declaration, to allow freedom of organization without arbitrary rules about what must go in the type, but sizing instances was one of our concerns. (You could always peek at the LLVM IR if you want to know for sure what&#39;s getting generated.)<br></p><p><br>Have you considered using “partial” or “extendable&quot; for these types of definitions (similar to C# partials) to reduce this confusion?<br></p><p>extendable struct Foo {<br>   var x: Int<br>}<br></p><p>When the keyword is there, all bets are off that the layout of the struct only contains a single member. Then extensions, defined within the same module, could add to it.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/5bb2e89b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>December 18, 2015 at 04:00:00pm</p></header><div class="content"><p>+1 for &quot;[giving] same-module extensions to do anything that can be done in<br>the original type declaration&quot;, +1 for something akin to C#&#39;s &#39;partial&#39;.<br>I&#39;ve often wanted to organize my code for a single type within several<br>files, grouping methods and properties by purpose, but have been stymied by<br>both the way access control works and by the restriction on stored<br>properties.<br></p><p>Best,<br>Austin<br></p><p>On Fri, Dec 18, 2015 at 3:58 PM, David Owens II via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 18, 2015, at 3:34 PM, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Dec 18, 2015, at 3:24 PM, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; AFAIK there&#39;s no precedent today for extensions in the same module being<br>&gt; able to do things that extensions in other modules can&#39;t do (beyond<br>&gt; accessing `internal` members of course). I&#39;m not completely opposed to the<br>&gt; idea, but I would want to be very careful and make sure there&#39;s an<br>&gt; extremely clear benefit to changing it so extensions in the same module can<br>&gt; add extra storage.<br>&gt;<br>&gt; One potentially large downside is you can no longer look at a type<br>&gt; declaration and find out how large it is. For example, I could define<br>&gt;<br>&gt; struct Foo {<br>&gt;    var x: Int<br>&gt; }<br>&gt;<br>&gt; and it looks like a tiny struct, but I could then add an extension in a<br>&gt; separate file that bloats that out to some ridiculously massive struct, and<br>&gt; that wouldn&#39;t be obvious from looking at it.<br>&gt;<br>&gt; That said, when looking at a definition imported from another module, you<br>&gt; can&#39;t see which properties are computed and which are stored anyway, so<br>&gt; it&#39;s maybe not a huge deal (although you can assume any property defined in<br>&gt; an extension is computed). But it is still something to consider.<br>&gt;<br>&gt;<br>&gt; True, this is a tradeoff. We&#39;ve discussed moving in the direction of<br>&gt; allowing same-module extensions to do anything that can be done in the<br>&gt; original type declaration, to allow freedom of organization without<br>&gt; arbitrary rules about what must go in the type, but sizing instances was<br>&gt; one of our concerns. (You could always peek at the LLVM IR if you want to<br>&gt; know for sure what&#39;s getting generated.)<br>&gt;<br>&gt;<br>&gt;<br>&gt; Have you considered using “partial” or “extendable&quot; for these types of<br>&gt; definitions (similar to C# partials) to reduce this confusion?<br>&gt;<br>&gt; extendable struct Foo {<br>&gt;    var x: Int<br>&gt; }<br>&gt;<br>&gt;<br>&gt; When the keyword is there, all bets are off that the layout of the struct<br>&gt; only contains a single member. Then extensions, defined within the same<br>&gt; module, could add to it.<br>&gt;<br>&gt; -David<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/0f309229/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 18, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 3:24 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; On Fri, Dec 18, 2015, at 03:15 PM, Joe Groff via swift-evolution wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 18, 2015, at 12:49 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I only see the benefits on this.<br>&gt;&gt;&gt;&gt; 	• We don&#39;t have to store all states in one file. States can be stored separately. So, we can write code in more composition style.<br>&gt;&gt;&gt;&gt; 	• We can add new states to the existing type. Not just NSObject subclass with associated object.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think people generally want this; the question is how to implement it, and especially how to implement it *without* either limiting it to types in the same module, or dangling what amounts to a dictionary off every single object and struct. (Structs are more difficult than objects, because they don’t have stable identities.) Any ideas?<br>&gt;&gt; <br>&gt;&gt; You could say that types whose conformance to the protocol lives in the same module as the type itself get the default property storage, but external extensions that introduce the conformance can&#39;t use the default stored property and have to supply their own implementation.<br>&gt; <br>&gt; AFAIK there&#39;s no precedent today for extensions in the same module being able to do things that extensions in other modules can&#39;t do (beyond accessing `internal` members of course). I&#39;m not completely opposed to the idea, but I would want to be very careful and make sure there&#39;s an extremely clear benefit to changing it so extensions in the same module can add extra storage.<br>&gt; <br>&gt; One potentially large downside is you can no longer look at a type declaration and find out how large it is. For example, I could define<br>&gt; <br>&gt; struct Foo {<br>&gt;    var x: Int<br>&gt; }<br>&gt; <br>&gt; and it looks like a tiny struct, but I could then add an extension in a separate file that bloats that out to some ridiculously massive struct, and that wouldn&#39;t be obvious from looking at it.<br></p><p>I think any storage-in-extensions proposal ought to be a special feature of classes; I would not support the ability to add stored properties to structs in extensions, even from within the module.<br></p><p>John.<br></p><p>&gt; <br>&gt; That said, when looking at a definition imported from another module, you can&#39;t see which properties are computed and which are stored anyway, so it&#39;s maybe not a huge deal (although you can assume any property defined in an extension is computed). But it is still something to consider.<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 18, 2015 at 04:00:00pm</p></header><div class="content"><p>On Fri, Dec 18, 2015, at 04:11 PM, John McCall wrote:<br>&gt; I think any storage-in-extensions proposal ought to be a special feature of classes; I would not support the ability to add stored properties to structs in extensions, even from within the module.<br></p><p>Oh that&#39;s an interesting idea. My immediate reaction to &quot;I don&#39;t want unpredictable sizes&quot; was upon reflection something that only applies to structs. Classes are reference types already, so adding storage to them doesn&#39;t really have much consequence (structs get copied around so their size is important). Not only that, but we can already use associated objects with classes, so adding proper stored properties to them doesn&#39;t actually change the semantics of extensions, it just means avoiding the overhead of associated objects (and of value wrappers for associated objects) when the extension is part of the same module.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 18, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 4:19 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; On Fri, Dec 18, 2015, at 04:11 PM, John McCall wrote:<br>&gt;&gt; I think any storage-in-extensions proposal ought to be a special feature of classes; I would not support the ability to add stored properties to structs in extensions, even from within the module.<br>&gt; <br>&gt; Oh that&#39;s an interesting idea. My immediate reaction to &quot;I don&#39;t want unpredictable sizes&quot; was upon reflection something that only applies to structs. Classes are reference types already, so adding storage to them doesn&#39;t really have much consequence (structs get copied around so their size is important). Not only that, but we can already use associated objects with classes, so adding proper stored properties to them doesn&#39;t actually change the semantics of extensions, it just means avoiding the overhead of associated objects (and of value wrappers for associated objects) when the extension is part of the same module.<br></p><p>Right.  And I think we’d also want to support some way to explicitly request the out-of-line representation even within the module.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 18, 2015 at 05:00:00pm</p></header><div class="content"><p>On Fri, Dec 18, 2015, at 04:38 PM, John McCall wrote:<br>&gt; &gt; On Dec 18, 2015, at 4:19 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; &gt; On Fri, Dec 18, 2015, at 04:11 PM, John McCall wrote:<br>&gt; &gt;&gt; I think any storage-in-extensions proposal ought to be a special feature of classes; I would not support the ability to add stored properties to structs in extensions, even from within the module.<br>&gt; &gt; <br>&gt; &gt; Oh that&#39;s an interesting idea. My immediate reaction to &quot;I don&#39;t want unpredictable sizes&quot; was upon reflection something that only applies to structs. Classes are reference types already, so adding storage to them doesn&#39;t really have much consequence (structs get copied around so their size is important). Not only that, but we can already use associated objects with classes, so adding proper stored properties to them doesn&#39;t actually change the semantics of extensions, it just means avoiding the overhead of associated objects (and of value wrappers for associated objects) when the extension is part of the same module.<br>&gt; <br>&gt; Right.  And I think we’d also want to support some way to explicitly request the out-of-line representation even within the module.<br></p><p>Property behaviors could do out-of-line storage for classes (assuming property behaviors retain the ability to get at the owning class, which is something I mentioned as being problematic in my review). You could technically do out-of-line storage for structs by having an inline storage of object type and then using the lifetime of that object to manage the out-of-line storage, but that doesn&#39;t seem particularly great and it also breaks value semantics.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 18, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 5:43 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Fri, Dec 18, 2015, at 04:38 PM, John McCall wrote:<br>&gt;&gt;&gt; On Dec 18, 2015, at 4:19 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt; On Fri, Dec 18, 2015, at 04:11 PM, John McCall wrote:<br>&gt;&gt;&gt;&gt; I think any storage-in-extensions proposal ought to be a special feature of classes; I would not support the ability to add stored properties to structs in extensions, even from within the module.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Oh that&#39;s an interesting idea. My immediate reaction to &quot;I don&#39;t want unpredictable sizes&quot; was upon reflection something that only applies to structs. Classes are reference types already, so adding storage to them doesn&#39;t really have much consequence (structs get copied around so their size is important). Not only that, but we can already use associated objects with classes, so adding proper stored properties to them doesn&#39;t actually change the semantics of extensions, it just means avoiding the overhead of associated objects (and of value wrappers for associated objects) when the extension is part of the same module.<br>&gt;&gt; <br>&gt;&gt; Right.  And I think we’d also want to support some way to explicitly request the out-of-line representation even within the module.<br>&gt; <br>&gt; Property behaviors could do out-of-line storage for classes (assuming property behaviors retain the ability to get at the owning class, which is something I mentioned as being problematic in my review). You could technically do out-of-line storage for structs by having an inline storage of object type and then using the lifetime of that object to manage the out-of-line storage, but that doesn&#39;t seem particularly great and it also breaks value semantics.<br></p><p>A behavior should also be able to implement a copy-on-write policy on mutation in order to preserve value semantics in struct containers.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/d78f629d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 18, 2015 at 11:00:00pm</p></header><div class="content"><p>On Fri, Dec 18, 2015, at 05:45 PM, Joe Groff wrote:<br>&gt;<br>&gt;&gt; On Dec 18, 2015, at 5:43 PM, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Fri, Dec 18, 2015, at 04:38 PM, John McCall wrote:<br>&gt;&gt;&gt;&gt; On Dec 18, 2015, at 4:19 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote: On<br>&gt;&gt;&gt;&gt; Fri, Dec 18, 2015, at 04:11 PM, John McCall wrote:<br>&gt;&gt;&gt;&gt;&gt; I think any storage-in-extensions proposal ought to be a special<br>&gt;&gt;&gt;&gt;&gt; feature of classes; I would not support the ability to add stored<br>&gt;&gt;&gt;&gt;&gt; properties to structs in extensions, even from within the module.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Oh that&#39;s an interesting idea. My immediate reaction to &quot;I don&#39;t<br>&gt;&gt;&gt;&gt; want unpredictable sizes&quot; was upon reflection something that only<br>&gt;&gt;&gt;&gt; applies to structs. Classes are reference types already, so adding<br>&gt;&gt;&gt;&gt; storage to them doesn&#39;t really have much consequence (structs get<br>&gt;&gt;&gt;&gt; copied around so their size is important). Not only that, but we<br>&gt;&gt;&gt;&gt; can already use associated objects with classes, so adding proper<br>&gt;&gt;&gt;&gt; stored properties to them doesn&#39;t actually change the semantics of<br>&gt;&gt;&gt;&gt; extensions, it just means avoiding the overhead of associated<br>&gt;&gt;&gt;&gt; objects (and of value wrappers for associated objects) when the<br>&gt;&gt;&gt;&gt; extension is part of the same module.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Right.  And I think we’d also want to support some way to explicitly<br>&gt;&gt;&gt; request the out-of-line representation even within the module.<br>&gt;&gt;<br>&gt;&gt; Property behaviors could do out-of-line storage for classes (assuming<br>&gt;&gt; property behaviors retain the ability to get at the owning class,<br>&gt;&gt; which is something I mentioned as being problematic in my review).<br>&gt;&gt; You could technically do out-of-line storage for structs by having an<br>&gt;&gt; inline storage of object type and then using the lifetime of that<br>&gt;&gt; object to manage the out-of-line storage, but that doesn&#39;t seem<br>&gt;&gt; particularly great and it also breaks value semantics.<br>&gt;<br>&gt; A behavior should also be able to implement a copy-on-write policy on<br>&gt; mutation in order to preserve value semantics in struct containers.<br></p><p>I suppose that&#39;s true, if a class is used for out-of-line storage then<br>you can use the same uniqueness testing that the existing COW<br>containers use. I was originally thinking about using it like<br>associated objects, but it makes a lot more sense to use something like<br>ManagedBuffer instead.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/7dcf2591/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 18, 2015 at 08:00:00pm</p></header><div class="content"><p>On Dec 18, 2015, at 4:11 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; One potentially large downside is you can no longer look at a type declaration and find out how large it is. For example, I could define<br>&gt;&gt; <br>&gt;&gt; struct Foo {<br>&gt;&gt;   var x: Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; and it looks like a tiny struct, but I could then add an extension in a separate file that bloats that out to some ridiculously massive struct, and that wouldn&#39;t be obvious from looking at it.<br>&gt; <br>&gt; I think any storage-in-extensions proposal ought to be a special feature of classes; I would not support the ability to add stored properties to structs in extensions, even from within the module.<br></p><p>I agree.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 22, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 20:11 , Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Dec 18, 2015, at 4:11 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One potentially large downside is you can no longer look at a type declaration and find out how large it is. For example, I could define<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;  var x: Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and it looks like a tiny struct, but I could then add an extension in a separate file that bloats that out to some ridiculously massive struct, and that wouldn&#39;t be obvious from looking at it.<br>&gt;&gt; <br>&gt;&gt; I think any storage-in-extensions proposal ought to be a special feature of classes; I would not support the ability to add stored properties to structs in extensions, even from within the module.<br>&gt; <br>&gt; I agree.<br></p><p>I don&#39;t see why any reasons that apply to classes wouldn&#39;t apply to structs: code organization, making the property private, etc. But maybe it should be called out explicitly with &quot;@partial&quot; or similar for structs.<br></p><p>Jordan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 22, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 7:40 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt; On Dec 18, 2015, at 20:11 , Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Dec 18, 2015, at 4:11 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One potentially large downside is you can no longer look at a type declaration and find out how large it is. For example, I could define<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;&gt; var x: Int<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; and it looks like a tiny struct, but I could then add an extension in a separate file that bloats that out to some ridiculously massive struct, and that wouldn&#39;t be obvious from looking at it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think any storage-in-extensions proposal ought to be a special feature of classes; I would not support the ability to add stored properties to structs in extensions, even from within the module.<br>&gt;&gt; <br>&gt;&gt; I agree.<br>&gt; <br>&gt; I don&#39;t see why any reasons that apply to classes wouldn&#39;t apply to structs: code organization, making the property private, etc. But maybe it should be called out explicitly with &quot;@partial&quot; or similar for structs.<br></p><p>Classes have identity.  To the extent that identity is important to a design, it has to be preserved; you can try to break up the object’s state into a bunch of different types, but if they all need to know about the same identity, you haven’t really done much except add complexity and (probably) retain cycles.  In other words, to the extent that a single object with identity is central to a design, it kindof makes sense for it to become a “god object”.  Usually we consider those bad in OO designs, with good reason, but those good reasons are often actually language failings that don’t necessarily apply in Swift.  The main one is encapsulation: when you stuff a lot of functionality into a single class in most OO languages, there’s no real way to enforce its division into subsystems, because every method has direct access to every property and every other method.  In contrast, in Swift you can divide that class into distinct components with their own interface, state, and invariants, essentially making each component as good as its own type as far as encapsulation goes.  (The only interesting language problem here here is allowing non-nullary initialization of the extensions, and that certainly seems solvable.)  Of course, in the places where identity *isn’t* important, it will generally make more sense to organize things by composition; but sometimes identity is important everywhere.<br></p><p>In contrast, since value types lack that inherent notion of identity, it seems much more likely to me that you just wouldn’t ever develop multiple sub-systems within a single type like that.  There’s certainly nothing pressuring you in that direction in the same way, at least that I can see.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 23, 2015 at 09:00:00am</p></header><div class="content"><p>On Dec 22, 2015, at 10:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; when you stuff a lot of functionality into a single class in most OO languages, there’s no real way to enforce its division into subsystems, because every method has direct access to every property and every other method.  In contrast, in Swift you can divide that class into distinct components with their own interface, state, and invariants, essentially making each component as good as its own type as far as encapsulation goes.<br></p><p>Can you elaborate on this, John? Extensions and protocols in Swift today still don’t solve the problem that shared _private_ class state has to be centralized. Or were you speaking as if this “properties in extensions” proposal were already implemented?<br></p><p>Cheers,<br></p><p>Paul<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 23, 2015 at 03:00:00pm</p></header><div class="content"><p>I wouldn&#39;t mind it being treated just as a bunch of getters and setters.<br></p><p>On Wed, Dec 23, 2015 at 3:05 PM, Paul Cantrell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Dec 22, 2015, at 10:45 PM, John McCall via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; when you stuff a lot of functionality into a single class in most OO<br>&gt; languages, there’s no real way to enforce its division into subsystems,<br>&gt; because every method has direct access to every property and every other<br>&gt; method.  In contrast, in Swift you can divide that class into distinct<br>&gt; components with their own interface, state, and invariants, essentially<br>&gt; making each component as good as its own type as far as encapsulation goes.<br>&gt;<br>&gt; Can you elaborate on this, John? Extensions and protocols in Swift today<br>&gt; still don’t solve the problem that shared _private_ class state has to be<br>&gt; centralized. Or were you speaking as if this “properties in extensions”<br>&gt; proposal were already implemented?<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; Paul<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br> Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/5e178917/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 23, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 7:05 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt; On Dec 22, 2015, at 10:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; when you stuff a lot of functionality into a single class in most OO languages, there’s no real way to enforce its division into subsystems, because every method has direct access to every property and every other method.  In contrast, in Swift you can divide that class into distinct components with their own interface, state, and invariants, essentially making each component as good as its own type as far as encapsulation goes.<br>&gt; <br>&gt; Can you elaborate on this, John? Extensions and protocols in Swift today still don’t solve the problem that shared _private_ class state has to be centralized. Or were you speaking as if this “properties in extensions” proposal were already implemented?<br></p><p>Yes, that’s right.  I’m explaining why I think it makes sense to limit stored instance properties in extensions to class types: especially with some solution for private initialization of extensions, they enable intra-class encapsulation in a way that matters for classes and not really for other types.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 23, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 12:50 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 7:05 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt; On Dec 22, 2015, at 10:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; when you stuff a lot of functionality into a single class in most OO languages, there’s no real way to enforce its division into subsystems, because every method has direct access to every property and every other method.  In contrast, in Swift you can divide that class into distinct components with their own interface, state, and invariants, essentially making each component as good as its own type as far as encapsulation goes.<br>&gt;&gt; <br>&gt;&gt; Can you elaborate on this, John? Extensions and protocols in Swift today still don’t solve the problem that shared _private_ class state has to be centralized. Or were you speaking as if this “properties in extensions” proposal were already implemented?<br>&gt; <br>&gt; Yes, that’s right.  I’m explaining why I think it makes sense to limit stored instance properties in extensions to class types: especially with some solution for private initialization of extensions, they enable intra-class encapsulation in a way that matters for classes and not really for other types.<br>&gt; <br></p><p>How would private initialization of extensions work?<br></p><p>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 24, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 10:51 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 12:50 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 23, 2015, at 7:05 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt;&gt; On Dec 22, 2015, at 10:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; when you stuff a lot of functionality into a single class in most OO languages, there’s no real way to enforce its division into subsystems, because every method has direct access to every property and every other method.  In contrast, in Swift you can divide that class into distinct components with their own interface, state, and invariants, essentially making each component as good as its own type as far as encapsulation goes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can you elaborate on this, John? Extensions and protocols in Swift today still don’t solve the problem that shared _private_ class state has to be centralized. Or were you speaking as if this “properties in extensions” proposal were already implemented?<br>&gt;&gt; <br>&gt;&gt; Yes, that’s right.  I’m explaining why I think it makes sense to limit stored instance properties in extensions to class types: especially with some solution for private initialization of extensions, they enable intra-class encapsulation in a way that matters for classes and not really for other types.<br>&gt;&gt; <br>&gt; <br>&gt; How would private initialization of extensions work?<br></p><p>Just spit-balling, but something like:<br></p><p>  class A {<br>    init(numbers: [Int]) {<br>       // Definitive initialization requires initialization of all the extensions<br>       // in the module that declare partial inits before the call to super.init.<br>       self.init(counts: numbers)<br></p><p>       // Okay, now we super.init.<br>       super.init()<br></p><p>       // Fully initialized now.<br>     }<br>  }<br></p><p>  extension A {<br>    let counts: [Int]<br>    partial init(counts: [Int]) {<br>      // Definitive initialization requires a partial init to initialize all the stored properties<br>      // in this extension.  This all happens prior to the complete initialization of self,<br>      // so unlike a normal init, there is no point in this initializer when unrestricted<br>      // use of self is allowed.  If that’s required, it can be done with an ordinary method<br>      // call.<br>      //<br>      // To start, partial initializers would not be allowed to use properties from other<br>      // extensions or the main class.  We can consider ways to lift that restriction later.<br></p><p>      self.counts = counts<br>    }<br>  }<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 24, 2015 at 01:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Dec 24, 2015, at 1:31 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 10:51 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 23, 2015, at 12:50 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 23, 2015, at 7:05 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 10:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; when you stuff a lot of functionality into a single class in most OO languages, there’s no real way to enforce its division into subsystems, because every method has direct access to every property and every other method.  In contrast, in Swift you can divide that class into distinct components with their own interface, state, and invariants, essentially making each component as good as its own type as far as encapsulation goes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Can you elaborate on this, John? Extensions and protocols in Swift today still don’t solve the problem that shared _private_ class state has to be centralized. Or were you speaking as if this “properties in extensions” proposal were already implemented?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, that’s right.  I’m explaining why I think it makes sense to limit stored instance properties in extensions to class types: especially with some solution for private initialization of extensions, they enable intra-class encapsulation in a way that matters for classes and not really for other types.<br>&gt;&gt; <br>&gt;&gt; How would private initialization of extensions work?<br>&gt; <br>&gt; Just spit-balling, but something like:<br>&gt; <br>&gt;  class A {<br>&gt;    init(numbers: [Int]) {<br>&gt;       // Definitive initialization requires initialization of all the extensions<br>&gt;       // in the module that declare partial inits before the call to super.init.<br>&gt;       self.init(counts: numbers)<br>&gt; <br>&gt;       // Okay, now we super.init.<br>&gt;       super.init()<br>&gt; <br>&gt;       // Fully initialized now.<br>&gt;     }<br>&gt;  }<br>&gt; <br>&gt;  extension A {<br>&gt;    let counts: [Int]<br>&gt;    partial init(counts: [Int]) {<br>&gt;      // Definitive initialization requires a partial init to initialize all the stored properties<br>&gt;      // in this extension.  This all happens prior to the complete initialization of self,<br>&gt;      // so unlike a normal init, there is no point in this initializer when unrestricted<br>&gt;      // use of self is allowed.  If that’s required, it can be done with an ordinary method<br>&gt;      // call.<br>&gt;      //<br>&gt;      // To start, partial initializers would not be allowed to use properties from other<br>&gt;      // extensions or the main class.  We can consider ways to lift that restriction later.<br>&gt; <br>&gt;      self.counts = counts<br>&gt;    }<br>&gt;  }<br></p><p>I&#39;m really not sure I like this very much.  It seems to be exactly what I was concerned about.  The primary advantage this seems to provide is encapsulation for the extension.  Unfortunately it also means the extension has a ripple effect requiring initializers elsewhere in the project to be updated.  This doesn&#39;t feel like an &quot;extension&quot; as it actually seems to be pretty invasive.  It gives me an uneasy feeling at first glance.<br></p><p>I would like to see some concrete examples of problems this solves and compelling reasons why it is better than the alternatives. <br></p><p>Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 24, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 24, 2015, at 11:48 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; On Dec 24, 2015, at 1:31 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 23, 2015, at 10:51 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 12:50 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 7:05 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 10:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; when you stuff a lot of functionality into a single class in most OO languages, there’s no real way to enforce its division into subsystems, because every method has direct access to every property and every other method.  In contrast, in Swift you can divide that class into distinct components with their own interface, state, and invariants, essentially making each component as good as its own type as far as encapsulation goes.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Can you elaborate on this, John? Extensions and protocols in Swift today still don’t solve the problem that shared _private_ class state has to be centralized. Or were you speaking as if this “properties in extensions” proposal were already implemented?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, that’s right.  I’m explaining why I think it makes sense to limit stored instance properties in extensions to class types: especially with some solution for private initialization of extensions, they enable intra-class encapsulation in a way that matters for classes and not really for other types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How would private initialization of extensions work?<br>&gt;&gt; <br>&gt;&gt; Just spit-balling, but something like:<br>&gt;&gt; <br>&gt;&gt; class A {<br>&gt;&gt;   init(numbers: [Int]) {<br>&gt;&gt;      // Definitive initialization requires initialization of all the extensions<br>&gt;&gt;      // in the module that declare partial inits before the call to super.init.<br>&gt;&gt;      self.init(counts: numbers)<br>&gt;&gt; <br>&gt;&gt;      // Okay, now we super.init.<br>&gt;&gt;      super.init()<br>&gt;&gt; <br>&gt;&gt;      // Fully initialized now.<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension A {<br>&gt;&gt;   let counts: [Int]<br>&gt;&gt;   partial init(counts: [Int]) {<br>&gt;&gt;     // Definitive initialization requires a partial init to initialize all the stored properties<br>&gt;&gt;     // in this extension.  This all happens prior to the complete initialization of self,<br>&gt;&gt;     // so unlike a normal init, there is no point in this initializer when unrestricted<br>&gt;&gt;     // use of self is allowed.  If that’s required, it can be done with an ordinary method<br>&gt;&gt;     // call.<br>&gt;&gt;     //<br>&gt;&gt;     // To start, partial initializers would not be allowed to use properties from other<br>&gt;&gt;     // extensions or the main class.  We can consider ways to lift that restriction later.<br>&gt;&gt; <br>&gt;&gt;     self.counts = counts<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt; <br>&gt; I&#39;m really not sure I like this very much.  It seems to be exactly what I was concerned about.  The primary advantage this seems to provide is encapsulation for the extension.  Unfortunately it also means the extension has a ripple effect requiring initializers elsewhere in the project to be updated.  This doesn&#39;t feel like an &quot;extension&quot; as it actually seems to be pretty invasive.  It gives me an uneasy feeling at first glance.<br></p><p>Any proposal which allows stored properties with non-default initialization to be added in an extension is going to require source changes to the main class initializer(s).  My suggestion of partial inits achieves that without breaking encapsulation, which in my judgment would not be acceptable.  You could also just require all stored properties in extensions to have a default initializer, which is the rule we’d be forced to use outside the module anyway.  These are your options if you actually care about this feature.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 24, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 24, 2015, at 2:05 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 24, 2015, at 11:48 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; On Dec 24, 2015, at 1:31 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 23, 2015, at 10:51 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 12:50 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 7:05 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 10:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; when you stuff a lot of functionality into a single class in most OO languages, there’s no real way to enforce its division into subsystems, because every method has direct access to every property and every other method.  In contrast, in Swift you can divide that class into distinct components with their own interface, state, and invariants, essentially making each component as good as its own type as far as encapsulation goes.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Can you elaborate on this, John? Extensions and protocols in Swift today still don’t solve the problem that shared _private_ class state has to be centralized. Or were you speaking as if this “properties in extensions” proposal were already implemented?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, that’s right.  I’m explaining why I think it makes sense to limit stored instance properties in extensions to class types: especially with some solution for private initialization of extensions, they enable intra-class encapsulation in a way that matters for classes and not really for other types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How would private initialization of extensions work?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just spit-balling, but something like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class A {<br>&gt;&gt;&gt;  init(numbers: [Int]) {<br>&gt;&gt;&gt;     // Definitive initialization requires initialization of all the extensions<br>&gt;&gt;&gt;     // in the module that declare partial inits before the call to super.init.<br>&gt;&gt;&gt;     self.init(counts: numbers)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // Okay, now we super.init.<br>&gt;&gt;&gt;     super.init()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // Fully initialized now.<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension A {<br>&gt;&gt;&gt;  let counts: [Int]<br>&gt;&gt;&gt;  partial init(counts: [Int]) {<br>&gt;&gt;&gt;    // Definitive initialization requires a partial init to initialize all the stored properties<br>&gt;&gt;&gt;    // in this extension.  This all happens prior to the complete initialization of self,<br>&gt;&gt;&gt;    // so unlike a normal init, there is no point in this initializer when unrestricted<br>&gt;&gt;&gt;    // use of self is allowed.  If that’s required, it can be done with an ordinary method<br>&gt;&gt;&gt;    // call.<br>&gt;&gt;&gt;    //<br>&gt;&gt;&gt;    // To start, partial initializers would not be allowed to use properties from other<br>&gt;&gt;&gt;    // extensions or the main class.  We can consider ways to lift that restriction later.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    self.counts = counts<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I&#39;m really not sure I like this very much.  It seems to be exactly what I was concerned about.  The primary advantage this seems to provide is encapsulation for the extension.  Unfortunately it also means the extension has a ripple effect requiring initializers elsewhere in the project to be updated.  This doesn&#39;t feel like an &quot;extension&quot; as it actually seems to be pretty invasive.  It gives me an uneasy feeling at first glance.<br>&gt; <br>&gt; Any proposal which allows stored properties with non-default initialization to be added in an extension is going to require source changes to the main class initializer(s).  My suggestion of partial inits achieves that without breaking encapsulation, which in my judgment would not be acceptable.  You could also just require all stored properties in extensions to have a default initializer, which is the rule we’d be forced to use outside the module anyway.  These are your options if you actually care about this feature.<br></p><p>Understood.  I’m still trying to asses how I feel about the idea in general.  There are certainly advantages, but there are also drawbacks, particularly when the stored properties aren’t required to have defaults.<br></p><p>Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 24, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; On Dec 24, 2015, at 12:10 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; On Dec 24, 2015, at 2:05 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 24, 2015, at 11:48 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; On Dec 24, 2015, at 1:31 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 10:51 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 12:50 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 7:05 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 10:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; when you stuff a lot of functionality into a single class in most OO languages, there’s no real way to enforce its division into subsystems, because every method has direct access to every property and every other method.  In contrast, in Swift you can divide that class into distinct components with their own interface, state, and invariants, essentially making each component as good as its own type as far as encapsulation goes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Can you elaborate on this, John? Extensions and protocols in Swift today still don’t solve the problem that shared _private_ class state has to be centralized. Or were you speaking as if this “properties in extensions” proposal were already implemented?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, that’s right.  I’m explaining why I think it makes sense to limit stored instance properties in extensions to class types: especially with some solution for private initialization of extensions, they enable intra-class encapsulation in a way that matters for classes and not really for other types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; How would private initialization of extensions work?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Just spit-balling, but something like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class A {<br>&gt;&gt;&gt;&gt; init(numbers: [Int]) {<br>&gt;&gt;&gt;&gt;    // Definitive initialization requires initialization of all the extensions<br>&gt;&gt;&gt;&gt;    // in the module that declare partial inits before the call to super.init.<br>&gt;&gt;&gt;&gt;    self.init(counts: numbers)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    // Okay, now we super.init.<br>&gt;&gt;&gt;&gt;    super.init()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    // Fully initialized now.<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension A {<br>&gt;&gt;&gt;&gt; let counts: [Int]<br>&gt;&gt;&gt;&gt; partial init(counts: [Int]) {<br>&gt;&gt;&gt;&gt;   // Definitive initialization requires a partial init to initialize all the stored properties<br>&gt;&gt;&gt;&gt;   // in this extension.  This all happens prior to the complete initialization of self,<br>&gt;&gt;&gt;&gt;   // so unlike a normal init, there is no point in this initializer when unrestricted<br>&gt;&gt;&gt;&gt;   // use of self is allowed.  If that’s required, it can be done with an ordinary method<br>&gt;&gt;&gt;&gt;   // call.<br>&gt;&gt;&gt;&gt;   //<br>&gt;&gt;&gt;&gt;   // To start, partial initializers would not be allowed to use properties from other<br>&gt;&gt;&gt;&gt;   // extensions or the main class.  We can consider ways to lift that restriction later.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   self.counts = counts<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m really not sure I like this very much.  It seems to be exactly what I was concerned about.  The primary advantage this seems to provide is encapsulation for the extension.  Unfortunately it also means the extension has a ripple effect requiring initializers elsewhere in the project to be updated.  This doesn&#39;t feel like an &quot;extension&quot; as it actually seems to be pretty invasive.  It gives me an uneasy feeling at first glance.<br>&gt;&gt; <br>&gt;&gt; Any proposal which allows stored properties with non-default initialization to be added in an extension is going to require source changes to the main class initializer(s).  My suggestion of partial inits achieves that without breaking encapsulation, which in my judgment would not be acceptable.  You could also just require all stored properties in extensions to have a default initializer, which is the rule we’d be forced to use outside the module anyway.  These are your options if you actually care about this feature.<br>&gt; <br>&gt; Understood.  I’m still trying to asses how I feel about the idea in general.  There are certainly advantages, but there are also drawbacks, particularly when the stored properties aren’t required to have defaults.<br></p><p>Here’s the key argument for me.  What is the point of an extension of a concrete type within the defining module?  Extending a *protocol* has a lot of expressive power, sure.  Extending a *different* module’s type lets you avoid awkward workarounds and makes code feel more consistent, sure.  But extending your own type, when you could have just written that code in the main definition?  It would surely reduce language complexity if we disallowed that.  And yet, people still want to do it, even though the only reason to do so is code organization.   Something about the code in the extension feels like a logical grouping, which is verging on saying that it acts like a sub-system; and a sub-system is something that should be encapsulated.<br></p><p>I don’t think requiring properties in extensions to have default initializers is an acceptable end-game, although it might be okay as an incremental step.  It’s just like any other expressivity gap with initialization: it forces the programmer to compromise the invariants on their state, e.g. by making the property optional when it shouldn’t be.  Improving encapsulation isn’t really all that helpful if it leads to inferior invariants.<br></p><p>I feel like the strongest argument against allowing stored properties in extensions is the argument that it&#39;s poor design to have very complex types.  I have two responses to that; I apologize if this seems like straw-manning, because I know you haven’t raised this objection.<br></p><p>The first is that I’m always uncomfortable with abstract arguments against the complexity of other people’s code.  Judging technical designs on that level requires an awful lot of knowledge about the problem and the technical and implementation constraints on its solution.  I do not have that information.  (I have also worked with, and designed, many systems that feature complex types that would benefit from better internal encapsulation.  Swift’s parser, type checker, SIL generator, and IR generator are all like that.  Clang is similar, although that’s not a coincidence; still, most compilers seem to end up this way.)<br></p><p>The second is that this is a valuable tool for incrementally reducing that complexity.  No amount of language design is going to get programmers to always reach the best code design the first time.  So, great, now you&#39;ve got a complicated type.  It’s a simple first step to organize that complexity into separate extensions.  Once you’ve got those, it’s natural to want to make those extensions better encapsulated.  Once you’ve done that, maybe you recognize that some of those extensions can be extracted into an independent type.  It’s a lot harder to make the leap from extensions to independent types without encapsulating the state first.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 26, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 25, 2015, at 12:02 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 24, 2015, at 12:10 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; On Dec 24, 2015, at 2:05 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 24, 2015, at 11:48 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Dec 24, 2015, at 1:31 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 10:51 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 12:50 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 7:05 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 10:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; when you stuff a lot of functionality into a single class in most OO languages, there’s no real way to enforce its division into subsystems, because every method has direct access to every property and every other method.  In contrast, in Swift you can divide that class into distinct components with their own interface, state, and invariants, essentially making each component as good as its own type as far as encapsulation goes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Can you elaborate on this, John? Extensions and protocols in Swift today still don’t solve the problem that shared _private_ class state has to be centralized. Or were you speaking as if this “properties in extensions” proposal were already implemented?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, that’s right.  I’m explaining why I think it makes sense to limit stored instance properties in extensions to class types: especially with some solution for private initialization of extensions, they enable intra-class encapsulation in a way that matters for classes and not really for other types.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; How would private initialization of extensions work?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Just spit-balling, but something like:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class A {<br>&gt;&gt;&gt;&gt;&gt; init(numbers: [Int]) {<br>&gt;&gt;&gt;&gt;&gt;   // Definitive initialization requires initialization of all the extensions<br>&gt;&gt;&gt;&gt;&gt;   // in the module that declare partial inits before the call to super.init.<br>&gt;&gt;&gt;&gt;&gt;   self.init(counts: numbers)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   // Okay, now we super.init.<br>&gt;&gt;&gt;&gt;&gt;   super.init()<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   // Fully initialized now.<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension A {<br>&gt;&gt;&gt;&gt;&gt; let counts: [Int]<br>&gt;&gt;&gt;&gt;&gt; partial init(counts: [Int]) {<br>&gt;&gt;&gt;&gt;&gt;  // Definitive initialization requires a partial init to initialize all the stored properties<br>&gt;&gt;&gt;&gt;&gt;  // in this extension.  This all happens prior to the complete initialization of self,<br>&gt;&gt;&gt;&gt;&gt;  // so unlike a normal init, there is no point in this initializer when unrestricted<br>&gt;&gt;&gt;&gt;&gt;  // use of self is allowed.  If that’s required, it can be done with an ordinary method<br>&gt;&gt;&gt;&gt;&gt;  // call.<br>&gt;&gt;&gt;&gt;&gt;  //<br>&gt;&gt;&gt;&gt;&gt;  // To start, partial initializers would not be allowed to use properties from other<br>&gt;&gt;&gt;&gt;&gt;  // extensions or the main class.  We can consider ways to lift that restriction later.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  self.counts = counts<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m really not sure I like this very much.  It seems to be exactly what I was concerned about.  The primary advantage this seems to provide is encapsulation for the extension.  Unfortunately it also means the extension has a ripple effect requiring initializers elsewhere in the project to be updated.  This doesn&#39;t feel like an &quot;extension&quot; as it actually seems to be pretty invasive.  It gives me an uneasy feeling at first glance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any proposal which allows stored properties with non-default initialization to be added in an extension is going to require source changes to the main class initializer(s).  My suggestion of partial inits achieves that without breaking encapsulation, which in my judgment would not be acceptable.  You could also just require all stored properties in extensions to have a default initializer, which is the rule we’d be forced to use outside the module anyway.  These are your options if you actually care about this feature.<br>&gt;&gt; <br>&gt;&gt; Understood.  I’m still trying to asses how I feel about the idea in general.  There are certainly advantages, but there are also drawbacks, particularly when the stored properties aren’t required to have defaults.<br>&gt; <br>&gt; Here’s the key argument for me.  What is the point of an extension of a concrete type within the defining module? Extending a *protocol* has a lot of expressive power, sure.  Extending a *different* module’s type lets you avoid awkward workarounds and makes code feel more consistent, sure.  But extending your own type, when you could have just written that code in the main definition?  It would surely reduce language complexity if we disallowed that. And yet, people still want to do it, even though the only reason to do so is code organization.   Something about the code in the extension feels like a logical grouping, which is verging on saying that it acts like a sub-system; and a sub-system is something that should be encapsulated.<br>&gt; <br>&gt; I don’t think requiring properties in extensions to have default initializers is an acceptable end-game, although it might be okay as an incremental step.  It’s just like any other expressivity gap with initialization: it forces the programmer to compromise the invariants on their state, e.g. by making the property optional when it shouldn’t be. Improving encapsulation isn’t really all that helpful if it leads to inferior invariants.<br></p><p>If there are compelling uses for same-module extensions with non-default properties I agree with this wholeheartedly.  I’m just trying to think of with concrete examples of where this would be a better design than the alternatives and not coming up with any yet.<br></p><p>&gt; <br>&gt; I feel like the strongest argument against allowing stored properties in extensions is the argument that it&#39;s poor design to have very complex types.  I have two responses to that; I apologize if this seems like straw-manning, because I know you haven’t raised this objection.<br>&gt; <br>&gt; The first is that I’m always uncomfortable with abstract arguments against the complexity of other people’s code. Judging technical designs on that level requires an awful lot of knowledge about the problem and the technical and implementation constraints on its solution.  I do not have that information.  (I have also worked with, and designed, many systems that feature complex types that would benefit from better internal encapsulation.  Swift’s parser, type checker, SIL generator, and IR generator are all like that.  Clang is similar, although that’s not a coincidence; still, most compilers seem to end up this way.)<br>&gt; <br>&gt; The second is that this is a valuable tool for incrementally reducing that complexity.  No amount of language design is going to get programmers to always reach the best code design the first time.  So, great, now you&#39;ve got a complicated type.  It’s a simple first step to organize that complexity into separate extensions.  Once you’ve got those, it’s natural to want to make those extensions better encapsulated.  Once you’ve done that, maybe you recognize that some of those extensions can be extracted into an independent type.  It’s a lot harder to make the leap from extensions to independent types without encapsulating the state first.<br>&gt; <br></p><p>Hi John, thanks for responding.  <br></p><p>The example of using this as an intermediate state during a complex refactoring is interesting.  I can certainly see how a feature like this could be useful in that way.  That said, I’m not sure this use case alone is compelling to me.<br></p><p>I have a pretty open mind about this feature at the moment and am still trying to get my mind around the implications it might have.  I see very attractive aspects to it, but also some implications that make me a little bit uneasy as it might be an easy feature to over use.  So I’m not exactly making the argument you imply, but I you are on the right track in terms of what I’m thinking about.<br></p><p>I would really like to see some motivating examples of how same-module extensions with non-defaulted stored properties could enable better designs.  Without those I’m really not sure whether the added complexity is worth it.  I’ll continue to think about it.  If you know of any please share those as well.<br></p><p>I know you didn’t think too deeply about the initialization syntax yet.  One thing I think we would need to resolve is how the self.init calls are disambiguated if there are several extensions in the same module that all need to be initialized.<br></p><p>class A {<br>  init(numbers: [Int]) {<br>    // Definitive initialization requires initialization of all the extensions<br>    // in the module that declare partial inits before the call to super.init.<br>    // How do we disambiguate when there are multiple extensions <br>    // we need to initialize?<br>    // Hopefully something more than just the initializer signature is used...<br>    self.init(counts: numbers)<br>  <br>    // Okay, now we super.init.<br>    super.init()<br></p><p>    // Fully initialized now.<br>  }<br>}<br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151226/a0c9d6d9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 26, 2015 at 01:00:00pm</p></header><div class="content"><p>I’ve been giving this further thought today.<br></p><p>Thinking about extensions that require non-default initialization led to thinking about protocols that require non-default initialization.  <br></p><p>I can see significant value in allowing protocols to have stored properties that require non-default initialization.  This would effectively get us all the way to very robust, encapsulated mixin functionality.  It would enable design techniques that would not otherwise be possible.  <br></p><p>Once we have a concept of “partial initialization” of self in the language supporting it for same-module extensions starts to make more sense to me as a natural way to build on that.<br></p><p>As with extensions requiring non-default initialization, conformance of such protocols would only be supported in the module declaring the type itself, and perhaps only in the declaration itself. This being the case, storage could even be inline. <br></p><p>It might look something like this:<br></p><p>protocol P {<br>  // requirements of the protocol<br>  // ...<br></p><p>  stored let s: String<br>  protocol init(s: String) {<br>    // protocol cannot use self to reference any of its instance requirements yet<br>    // as self is not fully initialized<br>    self.s = s<br>  }<br>}<br></p><p>class C: P {<br>  let i: Int<br>  init() {<br>    i = 42<br>    P.init(“hello”)<br>  }<br>}<br></p><p>A few things to note.  <br></p><p>The protocol would need a way to indicate its initializer is a partial initializer that initializes the protocol’s storage rather than being an initializer requirement.  It would also need a way to indicate that specific properties are stored directly rather than specifying requirements.  I used `stored` and `protocol init` for this purpose in the above example but the syntax could look different in a final solution.  <br></p><p>The protocol may also wish to apply access control to its stored members as well.  <br></p><p>If we allow both the protocol and the type itself to have distinct properties with the same name they would need to have distinct storage.  The protocol’s stored property could not be treated as an overridable requirement of the protocol.  When accessing the type via its protocol interface the protocol’s storage would be used.  When accessing the type directly its storage would be used.  <br></p><p>I’m sure there are plenty more details to consider.  <br></p><p>Given its potential to enable robust mixins, I am really starting to warm to the idea of partial-self initialization.<br></p><p>Matthew<br></p><p>&gt; On Dec 26, 2015, at 9:10 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 25, 2015, at 12:02 AM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 24, 2015, at 12:10 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; On Dec 24, 2015, at 2:05 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 24, 2015, at 11:48 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 24, 2015, at 1:31 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 10:51 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 12:50 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 7:05 AM, Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 10:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; when you stuff a lot of functionality into a single class in most OO languages, there’s no real way to enforce its division into subsystems, because every method has direct access to every property and every other method.  In contrast, in Swift you can divide that class into distinct components with their own interface, state, and invariants, essentially making each component as good as its own type as far as encapsulation goes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Can you elaborate on this, John? Extensions and protocols in Swift today still don’t solve the problem that shared _private_ class state has to be centralized. Or were you speaking as if this “properties in extensions” proposal were already implemented?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, that’s right.  I’m explaining why I think it makes sense to limit stored instance properties in extensions to class types: especially with some solution for private initialization of extensions, they enable intra-class encapsulation in a way that matters for classes and not really for other types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; How would private initialization of extensions work?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Just spit-balling, but something like:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class A {<br>&gt;&gt;&gt;&gt;&gt;&gt; init(numbers: [Int]) {<br>&gt;&gt;&gt;&gt;&gt;&gt;   // Definitive initialization requires initialization of all the extensions<br>&gt;&gt;&gt;&gt;&gt;&gt;   // in the module that declare partial inits before the call to super.init.<br>&gt;&gt;&gt;&gt;&gt;&gt;   self.init(counts: numbers)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;   // Okay, now we super.init.<br>&gt;&gt;&gt;&gt;&gt;&gt;   super.init()<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;   // Fully initialized now.<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; extension A {<br>&gt;&gt;&gt;&gt;&gt;&gt; let counts: [Int]<br>&gt;&gt;&gt;&gt;&gt;&gt; partial init(counts: [Int]) {<br>&gt;&gt;&gt;&gt;&gt;&gt;  // Definitive initialization requires a partial init to initialize all the stored properties<br>&gt;&gt;&gt;&gt;&gt;&gt;  // in this extension.  This all happens prior to the complete initialization of self,<br>&gt;&gt;&gt;&gt;&gt;&gt;  // so unlike a normal init, there is no point in this initializer when unrestricted<br>&gt;&gt;&gt;&gt;&gt;&gt;  // use of self is allowed.  If that’s required, it can be done with an ordinary method<br>&gt;&gt;&gt;&gt;&gt;&gt;  // call.<br>&gt;&gt;&gt;&gt;&gt;&gt;  //<br>&gt;&gt;&gt;&gt;&gt;&gt;  // To start, partial initializers would not be allowed to use properties from other<br>&gt;&gt;&gt;&gt;&gt;&gt;  // extensions or the main class.  We can consider ways to lift that restriction later.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  self.counts = counts<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m really not sure I like this very much.  It seems to be exactly what I was concerned about.  The primary advantage this seems to provide is encapsulation for the extension.  Unfortunately it also means the extension has a ripple effect requiring initializers elsewhere in the project to be updated.  This doesn&#39;t feel like an &quot;extension&quot; as it actually seems to be pretty invasive.  It gives me an uneasy feeling at first glance.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Any proposal which allows stored properties with non-default initialization to be added in an extension is going to require source changes to the main class initializer(s).  My suggestion of partial inits achieves that without breaking encapsulation, which in my judgment would not be acceptable.  You could also just require all stored properties in extensions to have a default initializer, which is the rule we’d be forced to use outside the module anyway.  These are your options if you actually care about this feature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Understood.  I’m still trying to asses how I feel about the idea in general.  There are certainly advantages, but there are also drawbacks, particularly when the stored properties aren’t required to have defaults.<br>&gt;&gt; <br>&gt;&gt; Here’s the key argument for me.  What is the point of an extension of a concrete type within the defining module? Extending a *protocol* has a lot of expressive power, sure.  Extending a *different* module’s type lets you avoid awkward workarounds and makes code feel more consistent, sure.  But extending your own type, when you could have just written that code in the main definition?  It would surely reduce language complexity if we disallowed that. And yet, people still want to do it, even though the only reason to do so is code organization.   Something about the code in the extension feels like a logical grouping, which is verging on saying that it acts like a sub-system; and a sub-system is something that should be encapsulated.<br>&gt;&gt; <br>&gt;&gt; I don’t think requiring properties in extensions to have default initializers is an acceptable end-game, although it might be okay as an incremental step.  It’s just like any other expressivity gap with initialization: it forces the programmer to compromise the invariants on their state, e.g. by making the property optional when it shouldn’t be. Improving encapsulation isn’t really all that helpful if it leads to inferior invariants.<br>&gt; <br>&gt; If there are compelling uses for same-module extensions with non-default properties I agree with this wholeheartedly.  I’m just trying to think of with concrete examples of where this would be a better design than the alternatives and not coming up with any yet.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I feel like the strongest argument against allowing stored properties in extensions is the argument that it&#39;s poor design to have very complex types.  I have two responses to that; I apologize if this seems like straw-manning, because I know you haven’t raised this objection.<br>&gt;&gt; <br>&gt;&gt; The first is that I’m always uncomfortable with abstract arguments against the complexity of other people’s code. Judging technical designs on that level requires an awful lot of knowledge about the problem and the technical and implementation constraints on its solution.  I do not have that information.  (I have also worked with, and designed, many systems that feature complex types that would benefit from better internal encapsulation.  Swift’s parser, type checker, SIL generator, and IR generator are all like that.  Clang is similar, although that’s not a coincidence; still, most compilers seem to end up this way.)<br>&gt;&gt; <br>&gt;&gt; The second is that this is a valuable tool for incrementally reducing that complexity.  No amount of language design is going to get programmers to always reach the best code design the first time.  So, great, now you&#39;ve got a complicated type.  It’s a simple first step to organize that complexity into separate extensions.  Once you’ve got those, it’s natural to want to make those extensions better encapsulated.  Once you’ve done that, maybe you recognize that some of those extensions can be extracted into an independent type.  It’s a lot harder to make the leap from extensions to independent types without encapsulating the state first.<br>&gt;&gt; <br>&gt; <br>&gt; Hi John, thanks for responding.  <br>&gt; <br>&gt; The example of using this as an intermediate state during a complex refactoring is interesting.  I can certainly see how a feature like this could be useful in that way.  That said, I’m not sure this use case alone is compelling to me.<br>&gt; <br>&gt; I have a pretty open mind about this feature at the moment and am still trying to get my mind around the implications it might have.  I see very attractive aspects to it, but also some implications that make me a little bit uneasy as it might be an easy feature to over use.  So I’m not exactly making the argument you imply, but I you are on the right track in terms of what I’m thinking about.<br>&gt; <br>&gt; I would really like to see some motivating examples of how same-module extensions with non-defaulted stored properties could enable better designs.  Without those I’m really not sure whether the added complexity is worth it.  I’ll continue to think about it.  If you know of any please share those as well.<br>&gt; <br>&gt; I know you didn’t think too deeply about the initialization syntax yet.  One thing I think we would need to resolve is how the self.init calls are disambiguated if there are several extensions in the same module that all need to be initialized.<br>&gt; <br>&gt; class A {<br>&gt;   init(numbers: [Int]) {<br>&gt;     // Definitive initialization requires initialization of all the extensions<br>&gt;     // in the module that declare partial inits before the call to super.init.<br>&gt;     // How do we disambiguate when there are multiple extensions <br>&gt;     // we need to initialize?<br>&gt;     // Hopefully something more than just the initializer signature is used...<br>&gt;     self.init(counts: numbers)<br>&gt;   <br>&gt;     // Okay, now we super.init.<br>&gt;     super.init()<br>&gt; <br>&gt;     // Fully initialized now.<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Matthew<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151226/15cbd445/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January  1, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 25, 2015, at 12:02 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; when you stuff a lot of functionality into a single class in most OO languages, there’s no real way to enforce its division into subsystems, because every method has direct access to every property and every other method.  In contrast, in Swift you can divide that class into distinct components with their own interface, state, and invariants, essentially making each component as good as its own type as far as encapsulation goes.<br>&gt;&gt;&gt; …etc…<br>&gt; <br>&gt; I feel like the strongest argument against allowing stored properties in extensions is the argument that it&#39;s poor design to have very complex types.  I have two responses to that; I apologize if this seems like straw-manning, because I know you haven’t raised this objection.<br>&gt; <br>&gt; The first is that I’m always uncomfortable with abstract arguments against the complexity of other people’s code.<br>&gt; …<br>&gt; The second is that this is a valuable tool for incrementally reducing that complexity.<br></p><p>There’s a third good argument as well: it decouples API design from scoping of private state.<br></p><p>I find that readability at the point of API use often pulls against minimizing variable scope. A recent example: Siesta’s Resource class provides “latest best information” about the state of an HTTP resource, and lets you observe changes to that state. It’s nicest to work with the API when the same Resource class provides both of these things:<br></p><p>    activityIndicator.hidden = !resource.isLoading<br>    displayStuff(resource.latestData)<br>    <br>    resource.loadIfNeeded()<br></p><p>    resource.addObserver(self)<br></p><p>However, in the implementation, I would like to expose the set of observers only to the observer-related methods, i.e. the private observers property should be exposed to addObserver() but hidden from loadIfNeeded()).<br></p><p>Doing that using traditional methods gets ugly. I have to make a separate ResourceObservers type, and then … what? I can make it public, and force this API usage (which looks reasonable at first but rapidly gets awkward):<br></p><p>    resource.observers.add(self)<br></p><p>…or I can make the ResourceObservers type private and follow Demeter’s so-called law to its ugly conclusion, and have a bunch of forwarding methods on Resource.<br></p><p>Those API problems aside, I’m up a creek anyway: there’s _private_ state of Resource that both addObserver() and loadIfNeeded() need to see. Exposing that state to a separate ResourceObservers type is far messier than just letting the Resource class get a little bit bigger.<br></p><p>Some form of “properties in extensions” could help ease this problem, letting extension scope group methods with just the state they need, while still letting us design API based on what looks best from the outside.<br></p><p>This argument might even make the “extension properties” idea a little more compelling for structs.<br></p><p>Cheers,<br></p><p>Paul<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/5118dd73/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 23, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 12:50 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 7:05 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt; On Dec 22, 2015, at 10:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; when you stuff a lot of functionality into a single class in most OO languages, there’s no real way to enforce its division into subsystems, because every method has direct access to every property and every other method.  In contrast, in Swift you can divide that class into distinct components with their own interface, state, and invariants, essentially making each component as good as its own type as far as encapsulation goes.<br>&gt;&gt; <br>&gt;&gt; Can you elaborate on this, John? Extensions and protocols in Swift today still don’t solve the problem that shared _private_ class state has to be centralized. Or were you speaking as if this “properties in extensions” proposal were already implemented?<br>&gt; <br>&gt; Yes, that’s right.  I’m explaining why I think it makes sense to limit stored instance properties in extensions to class types: especially with some solution for private initialization of extensions, they enable intra-class encapsulation in a way that matters for classes and not really for other types.<br></p><p>OK, gotcha. It’s the “some solution for private initialization of extensions” part that’s missing. How do you imagine that playing out? If an extension can’t store a property, then what would “private initialization” mean?<br></p><p>P<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 23, 2015 at 07:00:00am</p></header><div class="content"><p>I like this proposal in theory.  The idea of localizing a member declaration inside the extension that actually uses that member certainly has advantages.  At the same time, I have concerns about allowing this.  <br></p><p>In some ways it makes code less readable because it isn’t possible to see all of the stored members of a type in one location.  IDEs and generated documentation can help with this, but the code itself suffers. <br></p><p>I am also concerned about how this would interact with initializers, especially when the member is not provided with an initial value.  Adding an extension that declares a new stored property is likely to have non-local effects.  If you might already need to visit another file to update the initializers when adding the member the value of allowing the member declaration to be elsewhere is somewhat reduced.<br></p><p>The initialization concern can at least be mitigated to some degree by providing an initial value and / or if we adopt the flexible memberwise initialization proposal and all initializers for the type are able to initialize the added member using memberwise initialization.  That reduces the concern but doesn’t completely eliminate it.<br></p><p>I think it would be worthwhile to carefully consider how allowing stored properties in extensions interact with initializers in the wild.  Is the value they provide sufficient to outweigh any initialization complexities they might introduce?  Do we need to include restrictions on stored properties in extensions in order to reduce those complexities (such as requiring an initial value)?<br></p><p>Matthew<br></p><p><br>&gt; On Dec 22, 2015, at 9:40 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 18, 2015, at 20:11 , Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Dec 18, 2015, at 4:11 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One potentially large downside is you can no longer look at a type declaration and find out how large it is. For example, I could define<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;&gt; var x: Int<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; and it looks like a tiny struct, but I could then add an extension in a separate file that bloats that out to some ridiculously massive struct, and that wouldn&#39;t be obvious from looking at it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think any storage-in-extensions proposal ought to be a special feature of classes; I would not support the ability to add stored properties to structs in extensions, even from within the module.<br>&gt;&gt; <br>&gt;&gt; I agree.<br>&gt; <br>&gt; I don&#39;t see why any reasons that apply to classes wouldn&#39;t apply to structs: code organization, making the property private, etc. But maybe it should be called out explicitly with &quot;@partial&quot; or similar for structs.<br>&gt; <br>&gt; Jordan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7452b650d9bd0dfeecb6b9830f0d892?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Dan Stenmark</string> &lt;daniel.j.stenmark at gmail.com&gt;<p>December 18, 2015 at 03:00:00pm</p></header><div class="content"><p>I’d +1 this proposal for extensions existing in the same module as the class declaration.  However, creating new properties for classes defined in other modules would likely involve side-table lookups, and my understanding is that it has some performance implications.  <br></p><p>In cases where you want to extend the storage of a class, consider if maybe a subclass is all you need.<br></p><p>Dan<br></p><p>&gt; On Dec 18, 2015, at 11:42 AM, Nutchaphon Rewik via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I only see the benefits on this.<br>&gt; We don&#39;t have to store all states in one file. States can be stored separately. So, we can write code in more composition style.<br>&gt; We can add new states to the existing type. Not just NSObject subclass with associated object.<br>&gt; <br>&gt; protocol Incrementer{<br>&gt;     func increase()<br>&gt; }<br>&gt; <br>&gt; extension Incrementer{<br>&gt; <br>&gt;     var count = 1 // allows stored properties<br>&gt;     <br>&gt;     func increase(){<br>&gt;         print(count)<br>&gt;         count = count + 1<br>&gt;     }<br>&gt;  <br>&gt; }<br>&gt; <br>&gt; <br>&gt; &gt; On Dec 8, 2015, at 10:51 AM, Kevin Kachikian via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; I’d like to proposal to the Swift community and discuss the advantages and disadvantages of adding modifiable properties to extensions (in addition to the already existing computed properties, instance methods, subscripts, etc.):<br>&gt; &gt; <br>&gt; &gt; extension SomeType {<br>&gt; &gt; 	<br>&gt; &gt; 	var aNewProperty: Int<br>&gt; &gt; 	var anotherVariable: String<br>&gt; &gt; 	var aThirdOne: MyStruct<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/edf4b6aa/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c673fa52f8aa5b3e9205e51230764ca?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Kevin Kachikian</string> &lt;kevyk at mac.com&gt;<p>December 18, 2015 at 03:00:00pm</p></header><div class="content"><p>I’m really glad to see some discussion about this. I think it is an extremely worth while addition to Swift. Chris L. also thought it was a good idea, in general.<br></p><p>If I get a chance I’ll make a formal request to consider it. Anyone else interested in offering it up, officially?<br></p><p>Thanks,<br>Kevin Kachikian<br></p><p><br>&gt; On Dec 18, 2015, at 11:42 AM, Nutchaphon Rewik &lt;nRewik at outlook.com&gt; wrote:<br>&gt; <br>&gt; I only see the benefits on this.<br>&gt; We don&#39;t have to store all states in one file. States can be stored separately. So, we can write code in more composition style.<br>&gt; We can add new states to the existing type. Not just NSObject subclass with associated object.<br>&gt; <br>&gt; protocol Incrementer{<br>&gt;     func increase()<br>&gt; }<br>&gt; <br>&gt; extension Incrementer{<br>&gt; <br>&gt;     var count = 1 // allows stored properties<br>&gt;     <br>&gt;     func increase(){<br>&gt;         print(count)<br>&gt;         count = count + 1<br>&gt;     }<br>&gt;  <br>&gt; }<br>&gt; <br>&gt; <br>&gt; &gt; On Dec 8, 2015, at 10:51 AM, Kevin Kachikian via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; I’d like to proposal to the Swift community and discuss the advantages and disadvantages of adding modifiable properties to extensions (in addition to the already existing computed properties, instance methods, subscripts, etc.):<br>&gt; &gt; <br>&gt; &gt; extension SomeType {<br>&gt; &gt; 	<br>&gt; &gt; 	var aNewProperty: Int<br>&gt; &gt; 	var anotherVariable: String<br>&gt; &gt; 	var aThirdOne: MyStruct<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/cd5652ab/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 23, 2015 at 12:00:00pm</p></header><div class="content"><p>+1/-1:<br></p><p>When the extension is in the same module, it&#39;s nice to be able to group all aspects of an extension in one place instead of being forced to declare properties in the definition.<br>But I guess the most important use case is to extend types that aren&#39;t in the same module, and I wouldn&#39;t like to see that hacking the runtime becomes a common thing to do.<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ac24d28fde53d4a6f05a6dcbb781a002?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Nutchaphon Rewik</string> &lt;nRewik at outlook.com&gt;<p>December 23, 2015 at 12:00:00pm</p></header><div class="content"><p>I agree. I think stored properties in extensions should only be visible in its scope. If we combine the idea with scope access modifier ( https://github.com/apple/swift-evolution/pull/64 ). We can make the rule that no stored property is allowed to expose from its extension.<br></p><p>Nutchaphon<br></p><p>________________________________________<br>From: Tino Heth &lt;2th at gmx.de&gt;<br>Sent: Wednesday, December 23, 2015 6:42 PM<br>To: Nutchaphon Rewik<br>Cc: kevyk at mac.com; swift-evolution at swift.org<br>Subject: Re: [swift-evolution] Proposal - Allow properties in Extensions<br></p><p>+1/-1:<br></p><p>When the extension is in the same module, it&#39;s nice to be able to group all aspects of an extension in one place instead of being forced to declare properties in the definition.<br>But I guess the most important use case is to extend types that aren&#39;t in the same module, and I wouldn&#39;t like to see that hacking the runtime becomes a common thing to do.<br></p><p>Tino<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c673fa52f8aa5b3e9205e51230764ca?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Kevin Kachikian</string> &lt;kevyk at mac.com&gt;<p>December 23, 2015 at 08:00:00am</p></header><div class="content"><p>I don’t think hacking the runtime is much of an issue, more that it might already be now. <br></p><p>However part of the thinking behind the idea of extending extensions to encompass property declarations, above and beyond grouping related code together, is to maintain orthogonality: Structs and classes can declare properties and so should extensions to such types be able to as well.<br></p><p>Kevin<br></p><p><br>&gt; On Dec 23, 2015, at 3:42 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; +1/-1:<br>&gt; <br>&gt; When the extension is in the same module, it&#39;s nice to be able to group all aspects of an extension in one place instead of being forced to declare properties in the definition.<br>&gt; But I guess the most important use case is to extend types that aren&#39;t in the same module, and I wouldn&#39;t like to see that hacking the runtime becomes a common thing to do.<br>&gt; <br>&gt; Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal - Allow properties in Extensions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 23, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 10:02 AM, Kevin Kachikian via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I don’t think hacking the runtime is much of an issue, more that it might already be now. <br>&gt; <br>&gt; However part of the thinking behind the idea of extending extensions to encompass property declarations, above and beyond grouping related code together, is to maintain orthogonality: Structs and classes can declare properties and so should extensions to such types be able to as well.<br></p><p>The problem I think we need to consider carefully is that introducing stored properties is not necessarily orthogonal.  It can have significant impact on all initializers.<br></p><p>&gt; <br>&gt; Kevin<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 3:42 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1/-1:<br>&gt;&gt; <br>&gt;&gt; When the extension is in the same module, it&#39;s nice to be able to group all aspects of an extension in one place instead of being forced to declare properties in the definition.<br>&gt;&gt; But I guess the most important use case is to extend types that aren&#39;t in the same module, and I wouldn&#39;t like to see that hacking the runtime becomes a common thing to do.<br>&gt;&gt; <br>&gt;&gt; Tino<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/c4972969/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
