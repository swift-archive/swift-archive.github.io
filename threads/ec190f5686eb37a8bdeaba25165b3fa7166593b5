<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>ABI in Layman&#39;s terms?</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>August 11, 2016 at 01:00:00am</p></header><div class="content"><p>Could someone explain in simple terms what the ABI is and what sorts of things might affect it?<br></p><p>I had thought it was the layout in memory of structs/classes/etc… and how the program knows where to go to find a particular field.  This seems to be incorrect though, as I have seen many features that I would assume have some affect on this layout ruled “out of scope for phase 1”.  For example, I would think that many generics features would have an impact on the ABI, or the idea of COW (via secret boxing) for structs, or even union types.<br></p><p>At the very least, I would think that mix-ins would have a fairly significant effect.<br></p><p>I am obviously missing something here, and I want to provide constructive effort to the community (as opposed to distracting from the task at hand), so I would appreciate some clarification/guidance...<br></p><p>Thanks,<br>Jon<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>ABI in Layman&#39;s terms?</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>August 11, 2016 at 02:00:00pm</p></header><div class="content"><p>2016-08-11 11:52 GMT+03:00 Jonathan Hull via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt; Could someone explain in simple terms what the ABI is and what sorts of<br>&gt; things might affect it?<br>&gt;<br>&gt; I had thought it was the layout in memory of structs/classes/etc… and how<br>&gt; the program knows where to go to find a particular field.  This seems to be<br>&gt; incorrect though, as I have seen many features that I would assume have<br>&gt; some affect on this layout ruled “out of scope for phase 1”.  For example,<br>&gt; I would think that many generics features would have an impact on the ABI,<br>&gt; or the idea of COW (via secret boxing) for structs, or even union types.<br>&gt;<br>&gt; At the very least, I would think that mix-ins would have a fairly<br>&gt; significant effect.<br></p><p><br>ABI stability means that changes will have to be backwards compatible after<br>a certain stage. If we can add mixins feature without modifying old code<br>(and its SIL and IR and whatever), then we are fine.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160811/bee1b474/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>ABI in Layman&#39;s terms?</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>August 11, 2016 at 01:00:00pm</p></header><div class="content"><p>I&#39;d also like to understand this more and this answer does not completely satisfy me. I understand backwards compatibility, especially in terms of source breaking changes.<br></p><p>I have more difficulties understanding what breaks or not the ABI and how to make educated guesses about what features will require breaking it.<br></p><p>&gt; On 11 Aug 2016, at 13:24, Anton Zhilin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 2016-08-11 11:52 GMT+03:00 Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; Could someone explain in simple terms what the ABI is and what sorts of things might affect it?<br>&gt;&gt; <br>&gt;&gt; I had thought it was the layout in memory of structs/classes/etc… and how the program knows where to go to find a particular field.  This seems to be incorrect though, as I have seen many features that I would assume have some affect on this layout ruled “out of scope for phase 1”.  For example, I would think that many generics features would have an impact on the ABI, or the idea of COW (via secret boxing) for structs, or even union types.<br>&gt;&gt; <br>&gt;&gt; At the very least, I would think that mix-ins would have a fairly significant effect.<br>&gt; <br>&gt; ABI stability means that changes will have to be backwards compatible after a certain stage. If we can add mixins feature without modifying old code (and its SIL and IR and whatever), then we are fine. <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160811/aea09348/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>ABI in Layman&#39;s terms?</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>August 11, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Aug 11, 2016, at 4:27 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;d also like to understand this more and this answer does not completely satisfy me. I understand backwards compatibility, especially in terms of source breaking changes.<br>&gt; <br>&gt; I have more difficulties understanding what breaks or not the ABI and how to make educated guesses about what features will require breaking it<br></p><p>This is hard to explain right now without detailed knowledge of IRGen and SILGen internals. However we are planning on relaxing the restrictions as much as possible, so that source-compatible changes remain binary compatible. For example, we would like to be able to add new fields to structs, change computed properties to stored and vice versa, insert new classes in a hierarchy, add cases to enums, and so on. This falls under the umbrella of &quot;resilience&quot;.<br></p><p>Here&#39;s a document outlining what will be ABI compatible and what will not -- keep in mind that a good chunk of this is not yet implemented:<br></p><p>https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst<br></p><p>&gt; <br>&gt; On 11 Aug 2016, at 13:24, Anton Zhilin via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; 2016-08-11 11:52 GMT+03:00 Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; Could someone explain in simple terms what the ABI is and what sorts of things might affect it?<br>&gt;&gt; <br>&gt;&gt; I had thought it was the layout in memory of structs/classes/etc… and how the program knows where to go to find a particular field.  This seems to be incorrect though, as I have seen many features that I would assume have some affect on this layout ruled “out of scope for phase 1”.  For example, I would think that many generics features would have an impact on the ABI, or the idea of COW (via secret boxing) for structs, or even union types.<br>&gt;&gt; <br>&gt;&gt; At the very least, I would think that mix-ins would have a fairly significant effect.<br>&gt;&gt; <br>&gt;&gt; ABI stability means that changes will have to be backwards compatible after a certain stage. If we can add mixins feature without modifying old code (and its SIL and IR and whatever), then we are fine. <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160811/2549242e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>ABI in Layman&#39;s terms?</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>August 11, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Aug 11, 2016, at 1:48 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Aug 11, 2016, at 4:27 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;d also like to understand this more and this answer does not completely satisfy me. I understand backwards compatibility, especially in terms of source breaking changes.<br>&gt;&gt; <br>&gt;&gt; I have more difficulties understanding what breaks or not the ABI and how to make educated guesses about what features will require breaking it<br>&gt; <br>&gt; This is hard to explain right now without detailed knowledge of IRGen and SILGen internals. However we are planning on relaxing the restrictions as much as possible, so that source-compatible changes remain binary compatible. For example, we would like to be able to add new fields to structs, change computed properties to stored and vice versa, insert new classes in a hierarchy, add cases to enums, and so on. This falls under the umbrella of &quot;resilience&quot;.<br>&gt; <br>&gt; Here&#39;s a document outlining what will be ABI compatible and what will not -- keep in mind that a good chunk of this is not yet implemented:<br>&gt; <br>&gt; https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst &lt;https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst&gt;<br>As a follow-up explanation, when we talk about the ABI, we&#39;re really talking about three orthogonal &quot;axes&quot; along which we would like to &quot;move&quot; without breaking compatibility with existing binaries:<br></p><p>- The first axis is the machine-level calling conventions and memory layout. For example, what registers to pass function arguments and returns in, the rules for alignment and padding of fields in an aggregate type, which entry points the Swift runtime exports and what their behavior should be. Once we commit to a stable ABI along this axis, you will get interoperability between *compiler versions* -- the same exact library built with one version of the compiler will remain compatible with clients after being recompiled with another version, because their conventions will match up. Note that this does not help you if the library itself changes in any way.<br></p><p>- The second axis is the resilience work I called out in my previous e-mail. Here, we&#39;re trying to define language features and implementation techniques that allow a library to evolve in a forward-compatible manner, as long as the developer follows certain guidelines. Here, the goal is if you should be able to compile your library, make some changes to add new APIs, and recompile it *with the same compiler*, without breaking downstream clients, as long as you follow the library evolution guidelines (Also, you can imagine one day having an &#39;ABI diff&#39; tool to automate this).<br></p><p>- The third axis is the standard library itself. Stability of runtime interfaces and the extra indirection to enable resilience is all great, but it won&#39;t help you as long as the standard library API is evolving in a non-backwards compatible manner -- for example, if we remove a method on String. So once the other two areas have been addressed, the last thing to lock down is the standard library interface itself.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; On 11 Aug 2016, at 13:24, Anton Zhilin via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; 2016-08-11 11:52 GMT+03:00 Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; Could someone explain in simple terms what the ABI is and what sorts of things might affect it?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I had thought it was the layout in memory of structs/classes/etc… and how the program knows where to go to find a particular field.  This seems to be incorrect though, as I have seen many features that I would assume have some affect on this layout ruled “out of scope for phase 1”.  For example, I would think that many generics features would have an impact on the ABI, or the idea of COW (via secret boxing) for structs, or even union types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; At the very least, I would think that mix-ins would have a fairly significant effect.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ABI stability means that changes will have to be backwards compatible after a certain stage. If we can add mixins feature without modifying old code (and its SIL and IR and whatever), then we are fine. <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160811/120c247f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>ABI in Layman&#39;s terms?</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>August 11, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Aug 11, 2016, at 1:57 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Here&#39;s a document outlining what will be ABI compatible and what will not -- keep in mind that a good chunk of this is not yet implemented:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst<br>&gt; <br>&gt; As a follow-up explanation, when we talk about the ABI, we&#39;re really talking about three orthogonal &quot;axes&quot; along which we would like to &quot;move&quot; without breaking compatibility with existing binaries:<br>&gt; <br>&gt; - The first axis is the machine-level calling conventions and memory layout. For example, what registers to pass function arguments and returns in, the rules for alignment and padding of fields in an aggregate type, which entry points the Swift runtime exports and what their behavior should be. Once we commit to a stable ABI along this axis, you will get interoperability between *compiler versions* -- the same exact library built with one version of the compiler will remain compatible with clients after being recompiled with another version, because their conventions will match up. Note that this does not help you if the library itself changes in any way.<br>&gt; <br>&gt; - The second axis is the resilience work I called out in my previous e-mail. Here, we&#39;re trying to define language features and implementation techniques that allow a library to evolve in a forward-compatible manner, as long as the developer follows certain guidelines. Here, the goal is if you should be able to compile your library, make some changes to add new APIs, and recompile it *with the same compiler*, without breaking downstream clients, as long as you follow the library evolution guidelines (Also, you can imagine one day having an &#39;ABI diff&#39; tool to automate this).<br>&gt; <br>&gt; - The third axis is the standard library itself. Stability of runtime interfaces and the extra indirection to enable resilience is all great, but it won&#39;t help you as long as the standard library API is evolving in a non-backwards compatible manner -- for example, if we remove a method on String. So once the other two areas have been addressed, the last thing to lock down is the standard library interface itself.<br></p><p>I think perhaps the other thing that might matter here is that we can always add to the ABI in backwards-compatible ways. So, for instance, we don&#39;t have to nail down all generics features immediately just because they affect the ABI; we just need to nail down the ABIs of existing features, plus any new features which will change the design of existing standard library features. If we ever add, say, higher-kinded types, they will certainly have some kind of representation in the ABI, but as long as they don&#39;t affect the binary representation of non-higher-kinded types, that won&#39;t really affect compatibility with existing code.<br></p><p>Similarly, there&#39;s a straightforward way to implement COWed structs in a backwards compatible way: treat them as a struct wrapping a reference to an object containing the data. As long as the compiler implements COWed structs in that fashion, or in any other way that&#39;s expressible in the existing ABI, COW structs are only an issue if we redesign inlineable parts of the standard library to use them.<br></p><p>(Correct me if I&#39;m wrong, because I might be, but that&#39;s the impression I have.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>ABI in Layman&#39;s terms?</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>August 12, 2016 at 06:00:00pm</p></header><div class="content"><p>Just to put in perspective: If we don&#39;t define now (probably we won&#39;t) how<br>to add storage properties to existing types and/or define storage<br>properties in protocols, we will never get this?<br></p><p>I remember long time ago, Greg Parker presented some new refcount<br>representation, and one of advantages is someday adding storage properties<br>into classes using side allocation.<br></p><p>Is this new refcount in swift?<br></p><p>(ref:<br>https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20160314/001424.html<br>)<br></p><p>Em qui, 11 de ago de 2016 às 17:57, Slava Pestov via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt; On Aug 11, 2016, at 1:48 PM, Slava Pestov via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Aug 11, 2016, at 4:27 AM, David Hart via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I&#39;d also like to understand this more and this answer does not completely<br>&gt; satisfy me. I understand backwards compatibility, especially in terms of<br>&gt; source breaking changes.<br>&gt;<br>&gt; I have more difficulties understanding what breaks or not the ABI and how<br>&gt; to make educated guesses about what features will require breaking it<br>&gt;<br>&gt;<br>&gt; This is hard to explain right now without detailed knowledge of IRGen and<br>&gt; SILGen internals. However we are planning on relaxing the restrictions as<br>&gt; much as possible, so that source-compatible changes remain binary<br>&gt; compatible. For example, we would like to be able to add new fields to<br>&gt; structs, change computed properties to stored and vice versa, insert new<br>&gt; classes in a hierarchy, add cases to enums, and so on. This falls under the<br>&gt; umbrella of &quot;resilience&quot;.<br>&gt;<br>&gt; Here&#39;s a document outlining what will be ABI compatible and what will not<br>&gt; -- keep in mind that a good chunk of this is not yet implemented:<br>&gt;<br>&gt; https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst<br>&gt;<br>&gt;<br>&gt; As a follow-up explanation, when we talk about the ABI, we&#39;re really<br>&gt; talking about three orthogonal &quot;axes&quot; along which we would like to &quot;move&quot;<br>&gt; without breaking compatibility with existing binaries:<br>&gt;<br>&gt; - The first axis is the machine-level calling conventions and memory<br>&gt; layout. For example, what registers to pass function arguments and returns<br>&gt; in, the rules for alignment and padding of fields in an aggregate type,<br>&gt; which entry points the Swift runtime exports and what their behavior should<br>&gt; be. Once we commit to a stable ABI along this axis, you will get<br>&gt; interoperability between *compiler versions* -- the same exact library<br>&gt; built with one version of the compiler will remain compatible with clients<br>&gt; after being recompiled with another version, because their conventions will<br>&gt; match up. Note that this does not help you if the library itself changes in<br>&gt; any way.<br>&gt;<br>&gt; - The second axis is the resilience work I called out in my previous<br>&gt; e-mail. Here, we&#39;re trying to define language features and implementation<br>&gt; techniques that allow a library to evolve in a forward-compatible manner,<br>&gt; as long as the developer follows certain guidelines. Here, the goal is if<br>&gt; you should be able to compile your library, make some changes to add new<br>&gt; APIs, and recompile it *with the same compiler*, without breaking<br>&gt; downstream clients, as long as you follow the library evolution guidelines<br>&gt; (Also, you can imagine one day having an &#39;ABI diff&#39; tool to automate this).<br>&gt;<br>&gt; - The third axis is the standard library itself. Stability of runtime<br>&gt; interfaces and the extra indirection to enable resilience is all great, but<br>&gt; it won&#39;t help you as long as the standard library API is evolving in a<br>&gt; non-backwards compatible manner -- for example, if we remove a method on<br>&gt; String. So once the other two areas have been addressed, the last thing to<br>&gt; lock down is the standard library interface itself.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On 11 Aug 2016, at 13:24, Anton Zhilin via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; 2016-08-11 11:52 GMT+03:00 Jonathan Hull via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt;&gt; Could someone explain in simple terms what the ABI is and what sorts of<br>&gt;&gt; things might affect it?<br>&gt;&gt;<br>&gt;&gt; I had thought it was the layout in memory of structs/classes/etc… and how<br>&gt;&gt; the program knows where to go to find a particular field.  This seems to be<br>&gt;&gt; incorrect though, as I have seen many features that I would assume have<br>&gt;&gt; some affect on this layout ruled “out of scope for phase 1”.  For example,<br>&gt;&gt; I would think that many generics features would have an impact on the ABI,<br>&gt;&gt; or the idea of COW (via secret boxing) for structs, or even union types.<br>&gt;&gt;<br>&gt;&gt; At the very least, I would think that mix-ins would have a fairly<br>&gt;&gt; significant effect.<br>&gt;<br>&gt;<br>&gt; ABI stability means that changes will have to be backwards compatible<br>&gt; after a certain stage. If we can add mixins feature without modifying old<br>&gt; code (and its SIL and IR and whatever), then we are fine.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160812/78aef213/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/42eca71033ece251f2f194b7e343c2ec?s=50"></div><header><strong>ABI in Layman&#39;s terms?</strong> from <string>Magnus Ahltorp</string> &lt;map at kth.se&gt;<p>August 13, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; 11 Aug. 2016 22:57 Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; - The first axis is the machine-level calling conventions and memory layout. For example, what registers to pass function arguments and returns in, the rules for alignment and padding of fields in an aggregate type, which entry points the Swift runtime exports and what their behavior should be. Once we commit to a stable ABI along this axis, you will get interoperability between *compiler versions* -- the same exact library built with one version of the compiler will remain compatible with clients after being recompiled with another version, because their conventions will match up. Note that this does not help you if the library itself changes in any way.<br></p><p>I would just like to add that one very important part of calling conventions is memory ownership.<br></p><p>All memory ownership conventions that end up in the stable ABI have to be supported after it has been declared stable. Adding new ways of transferring (or not transferring) ownership could be handled by adding new types of name mangling, I guess, but since old binaries would use the old model, everyone calling them would have to implement the old conventions as well.<br></p><p>If I&#39;m not totally wrong.<br></p><p>/Magnus<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>ABI in Layman&#39;s terms?</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>August 11, 2016 at 04:00:00am</p></header><div class="content"><p>Right, I understand that part.  ABI stability means that we can run past binaries without recompiling.<br></p><p>What I want to know is what sorts of things affect this stability and which things don’t.  I guess I want heuristics for knowing whether an idea will affect the ABI, and thus needs to be talked about now.  I don’t want to distract from the process by proposing features which can be tackled later, but at the same time I REALLY don’t want to wait until phase 2 and then be told the feature can never be added because it would break the ABI (and I should have proposed it during phase 1).<br></p><p>Thanks,<br>Jon<br></p><p>&gt; On Aug 11, 2016, at 4:24 AM, Anton Zhilin &lt;antonyzhilin at gmail.com&gt; wrote:<br>&gt; <br>&gt; 2016-08-11 11:52 GMT+03:00 Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; Could someone explain in simple terms what the ABI is and what sorts of things might affect it?<br>&gt; <br>&gt; I had thought it was the layout in memory of structs/classes/etc… and how the program knows where to go to find a particular field.  This seems to be incorrect though, as I have seen many features that I would assume have some affect on this layout ruled “out of scope for phase 1”.  For example, I would think that many generics features would have an impact on the ABI, or the idea of COW (via secret boxing) for structs, or even union types.<br>&gt; <br>&gt; At the very least, I would think that mix-ins would have a fairly significant effect.<br>&gt; <br>&gt; ABI stability means that changes will have to be backwards compatible after a certain stage. If we can add mixins feature without modifying old code (and its SIL and IR and whatever), then we are fine. <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160811/50ea13e0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>ABI in Layman&#39;s terms?</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>August 11, 2016 at 01:00:00pm</p></header><div class="content"><p>This article has helped me a lot:<br></p><p>https://github.com/apple/swift/blob/master/docs/ABI.rst &lt;https://github.com/apple/swift/blob/master/docs/ABI.rst&gt;<br></p><p>And generally all the documents in the docs folder will paint a nice picture of what to expect. Not that I would say that I fully understand the ABI, but I think that after reading all the docs I will have a better way of understanding what to expect.<br></p><p>&gt; On Aug 11, 2016, at 1:33 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Right, I understand that part.  ABI stability means that we can run past binaries without recompiling.<br>&gt; <br>&gt; What I want to know is what sorts of things affect this stability and which things don’t.  I guess I want heuristics for knowing whether an idea will affect the ABI, and thus needs to be talked about now.  I don’t want to distract from the process by proposing features which can be tackled later, but at the same time I REALLY don’t want to wait until phase 2 and then be told the feature can never be added because it would break the ABI (and I should have proposed it during phase 1).<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt;&gt; On Aug 11, 2016, at 4:24 AM, Anton Zhilin &lt;antonyzhilin at gmail.com &lt;mailto:antonyzhilin at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 2016-08-11 11:52 GMT+03:00 Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; Could someone explain in simple terms what the ABI is and what sorts of things might affect it?<br>&gt;&gt; <br>&gt;&gt; I had thought it was the layout in memory of structs/classes/etc… and how the program knows where to go to find a particular field.  This seems to be incorrect though, as I have seen many features that I would assume have some affect on this layout ruled “out of scope for phase 1”.  For example, I would think that many generics features would have an impact on the ABI, or the idea of COW (via secret boxing) for structs, or even union types.<br>&gt;&gt; <br>&gt;&gt; At the very least, I would think that mix-ins would have a fairly significant effect.<br>&gt;&gt; <br>&gt;&gt; ABI stability means that changes will have to be backwards compatible after a certain stage. If we can add mixins feature without modifying old code (and its SIL and IR and whatever), then we are fine. <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160811/e8ae9c31/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>ABI in Layman&#39;s terms?</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>August 11, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Aug 11, 2016, at 1:52 AM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Could someone explain in simple terms what the ABI is and what sorts of things might affect it?<br></p><p>The ABI for a compiled programming language is the set of rules for how all of its interoperating features are implemented in the compiled result.<br></p><p>For example, in Java the primary ABI is the JVM specification plus some common-sense rules about how language features are mapped to JVM features.  JVMs do not typically interoperate with other code at a direct binary level, and so the details of actual memory layout are not ABI.<br></p><p>Not all language features require interoperation, or only require it a certain kind of opaque interoperation.  For example:<br></p><p>  - Type aliases do not currently have any ABI impact because by design they are erased at compile time.  However, a complete reflection design might provide some mechanism for introspecting type-aliases at runtime, which would require information about type aliases to be present in the compiled output; the representation of that information would be ABI.<br></p><p>  - Closures in most programming languages do not allow external code to modify their captured values; only the closure&#39;s invocation function can access them, and that is generated together with the capturing code, so the exact methodology of performing a capture is not ABI.  However, arbitrary code can invoke the closure, and so the opaque representation of a closure value and the process for invoking it are ABI.<br></p><p>And so on.<br></p><p>John.<br></p><p>&gt; I had thought it was the layout in memory of structs/classes/etc… and how the program knows where to go to find a particular field.  This seems to be incorrect though, as I have seen many features that I would assume have some affect on this layout ruled “out of scope for phase 1”.  For example, I would think that many generics features would have an impact on the ABI, or the idea of COW (via secret boxing) for structs, or even union types.<br>&gt; <br>&gt; At the very least, I would think that mix-ins would have a fairly significant effect.<br>&gt; <br>&gt; I am obviously missing something here, and I want to provide constructive effort to the community (as opposed to distracting from the task at hand), so I would appreciate some clarification/guidance...<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>ABI in Layman&#39;s terms?</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>August 12, 2016 at 02:00:00pm</p></header><div class="content"><p>This is an excellent explanation!  I think I (mostly) understand.<br></p><p>Thanks,<br>Jon<br></p><p> <br>&gt; On Aug 11, 2016, at 9:16 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 11, 2016, at 1:52 AM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Could someone explain in simple terms what the ABI is and what sorts of things might affect it?<br>&gt; <br>&gt; The ABI for a compiled programming language is the set of rules for how all of its interoperating features are implemented in the compiled result.<br>&gt; <br>&gt; For example, in Java the primary ABI is the JVM specification plus some common-sense rules about how language features are mapped to JVM features.  JVMs do not typically interoperate with other code at a direct binary level, and so the details of actual memory layout are not ABI.<br>&gt; <br>&gt; Not all language features require interoperation, or only require it a certain kind of opaque interoperation.  For example:<br>&gt; <br>&gt;  - Type aliases do not currently have any ABI impact because by design they are erased at compile time.  However, a complete reflection design might provide some mechanism for introspecting type-aliases at runtime, which would require information about type aliases to be present in the compiled output; the representation of that information would be ABI.<br>&gt; <br>&gt;  - Closures in most programming languages do not allow external code to modify their captured values; only the closure&#39;s invocation function can access them, and that is generated together with the capturing code, so the exact methodology of performing a capture is not ABI.  However, arbitrary code can invoke the closure, and so the opaque representation of a closure value and the process for invoking it are ABI.<br>&gt; <br>&gt; And so on.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; I had thought it was the layout in memory of structs/classes/etc… and how the program knows where to go to find a particular field.  This seems to be incorrect though, as I have seen many features that I would assume have some affect on this layout ruled “out of scope for phase 1”.  For example, I would think that many generics features would have an impact on the ABI, or the idea of COW (via secret boxing) for structs, or even union types.<br>&gt;&gt; <br>&gt;&gt; At the very least, I would think that mix-ins would have a fairly significant effect.<br>&gt;&gt; <br>&gt;&gt; I am obviously missing something here, and I want to provide constructive effort to the community (as opposed to distracting from the task at hand), so I would appreciate some clarification/guidance...<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
