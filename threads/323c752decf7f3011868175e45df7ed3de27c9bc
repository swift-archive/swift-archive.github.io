<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April  6, 2016 at 03:00:00pm</p></header><div class="content"><p>on Wed Apr 06 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; From a purely numerically aesthetic point of view, I&#39;d much prefer ranges to be <br>&gt;&gt; openable and closable at both ends. <br>&gt;&gt; <br>&gt;&gt; My primary use-case has been teaching math using playgrounds but I&#39;m sure <br>&gt;&gt; there are lots of other real-world situations more specific to common numerical<br>&gt;&gt; method tasks.<br>&gt;<br>&gt; By coincidence, a Perl hacker I know commented on Twitter yesterday<br>&gt; that he thought 1-based arrays were the way to go in the 21st<br>&gt; century. Somebody replying to that suggestion linked to a note by<br>&gt; Dijkstra that&#39;s relevant to this conversation:<br>&gt; &lt;https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html&gt;<br>&gt;<br>&gt; I&#39;d suggest everyone in this discussion should read it—it&#39;s only about 700 words—but to summarize:<br>&gt;<br>&gt; 	1. The semantic Swift refers to as `..&lt;` is the most natural range convention.<br>&gt; 	2. Relatedly, zero-based indexing is the most natural indexing convention.<br>&gt;<br>&gt; If we agree with Dijkstra&#39;s logic, then the only reason to support<br>&gt; `&gt;..` is for ranges where start &gt; end—that is, when we&#39;re constructing<br>&gt; a reversed range. <br></p><p>I (am familiar with and) agree with Dijkstra&#39;s logic, but not with your<br>conclusion about it.  The fact that one representation is more natural<br>for most common computing tasks doesn&#39;t mean it&#39;s not worth supporting<br>the other representations.<br></p><p>&gt; But if we decide to support striding backwards by using a forward<br>&gt; range and a negative stride, then that covers the reverse use<br>&gt; case. Thus, we would need neither additional range operators, nor<br>&gt; reversed ranges.<br>&gt;<br>&gt; As for the `range.striding(by:)` vs `stride(over:by:)` question, my<br>&gt; concerns there are, to be honest, mainly aesthetic. The need for<br>&gt; parentheses around the range operator is more or less unavoidable, but<br>&gt; I think they make the construct very ugly. However, I also think that<br>&gt; the `stride(over:by:)` syntax (or, for that matter<br>&gt; `stride(from:to:by:)`) look more constructor-y (they are only *not*<br>&gt; constructors now because of the overloading), and I think it opens us<br>&gt; up to parallel constructs like the `induce(from:while:by:)` function<br>&gt; I&#39;ve been working on.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April  7, 2016 at 08:00:00am</p></header><div class="content"><p>Dijkstra specifically said that in Mesa it was a bad idea to include<br>anything other than `..&lt;` the relevent quote is:<br></p><p>&quot;Extensive experience with Mesa has shown that the use of the other three<br>conventions has been a constant source of clumsiness and mistakes, and on<br>account of that experience Mesa programmers are now strongly advised not to<br>use the latter three available features. I mention this experimental<br>evidence —for what it is worth— because some people feel uncomfortable with<br>conclusions that have not been confirmed in practice.&quot;<br></p><p>In the above quote the first convention is `..&lt;` and the other three are<br>`&lt;..`, `...`, and `&lt;.&lt;` respectively. Therefore he is suggesting that even<br>`...` should not be included.<br></p><p>Personally I would go against Dijksra&#39;s advice and include all 4 as<br>operators, however if Dijkstra is followed and only `..&lt;` remains then the<br>&#39;lesser&#39; cases could be covered with an init on Range:<br></p><p>    init Range(first: T, isFirstIncluded: Bool =<br>true, last: T, isLastIncluded: Bool = true, stride: Int = 1)<br></p><p>On Thursday, 7 April 2016, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Wed Apr 06 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; From a purely numerically aesthetic point of view, I&#39;d much prefer<br>&gt; ranges to be<br>&gt; &gt;&gt; openable and closable at both ends.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; My primary use-case has been teaching math using playgrounds but I&#39;m<br>&gt; sure<br>&gt; &gt;&gt; there are lots of other real-world situations more specific to common<br>&gt; numerical<br>&gt; &gt;&gt; method tasks.<br>&gt; &gt;<br>&gt; &gt; By coincidence, a Perl hacker I know commented on Twitter yesterday<br>&gt; &gt; that he thought 1-based arrays were the way to go in the 21st<br>&gt; &gt; century. Somebody replying to that suggestion linked to a note by<br>&gt; &gt; Dijkstra that&#39;s relevant to this conversation:<br>&gt; &gt; &lt;https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html&gt;<br>&gt; &gt;<br>&gt; &gt; I&#39;d suggest everyone in this discussion should read it—it&#39;s only about<br>&gt; 700 words—but to summarize:<br>&gt; &gt;<br>&gt; &gt;       1. The semantic Swift refers to as `..&lt;` is the most natural range<br>&gt; convention.<br>&gt; &gt;       2. Relatedly, zero-based indexing is the most natural indexing<br>&gt; convention.<br>&gt; &gt;<br>&gt; &gt; If we agree with Dijkstra&#39;s logic, then the only reason to support<br>&gt; &gt; `&gt;..` is for ranges where start &gt; end—that is, when we&#39;re constructing<br>&gt; &gt; a reversed range.<br>&gt;<br>&gt; I (am familiar with and) agree with Dijkstra&#39;s logic, but not with your<br>&gt; conclusion about it.  The fact that one representation is more natural<br>&gt; for most common computing tasks doesn&#39;t mean it&#39;s not worth supporting<br>&gt; the other representations.<br>&gt;<br>&gt; &gt; But if we decide to support striding backwards by using a forward<br>&gt; &gt; range and a negative stride, then that covers the reverse use<br>&gt; &gt; case. Thus, we would need neither additional range operators, nor<br>&gt; &gt; reversed ranges.<br>&gt; &gt;<br>&gt; &gt; As for the `range.striding(by:)` vs `stride(over:by:)` question, my<br>&gt; &gt; concerns there are, to be honest, mainly aesthetic. The need for<br>&gt; &gt; parentheses around the range operator is more or less unavoidable, but<br>&gt; &gt; I think they make the construct very ugly. However, I also think that<br>&gt; &gt; the `stride(over:by:)` syntax (or, for that matter<br>&gt; &gt; `stride(from:to:by:)`) look more constructor-y (they are only *not*<br>&gt; &gt; constructors now because of the overloading), and I think it opens us<br>&gt; &gt; up to parallel constructs like the `induce(from:while:by:)` function<br>&gt; &gt; I&#39;ve been working on.<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160407/640350a4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April  6, 2016 at 04:00:00pm</p></header><div class="content"><p>on Wed Apr 06 2016, Howard Lovatt &lt;howard.lovatt-AT-gmail.com&gt; wrote:<br></p><p>&gt; Dijkstra specifically said that in Mesa it was a bad idea to include anything<br>&gt; other than `..&lt;` the relevent quote is:<br>&gt;<br>&gt; &quot;Extensive experience with Mesa has shown that the use of the other three<br>&gt; conventions has been a constant source of clumsiness and mistakes, and on<br>&gt; account of that experience Mesa programmers are now strongly advised not to use<br>&gt; the latter three available features. I mention this experimental evidence —for<br>&gt; what it is worth— because some people feel uncomfortable with conclusions that<br>&gt; have not been confirmed in practice.&quot;<br>&gt;<br>&gt; In the above quote the first convention is `..&lt;` and the other three are `&lt;..`,<br>&gt; `...`, and `&lt;.&lt;` respectively. Therefore he is suggesting that even `...` should<br>&gt; not be included.<br></p><p>He was talking about ranges of integer indices, though, and even<br>more-specifically about how to address arrays.  Range&lt;Bound&gt; is a more<br>general concept that applies to much more than indices.  Once you<br>involve floating point (and rationals, and patterns for matching,<br>e.g. UnicodeScalar(&quot;a&quot;)...&quot;z&quot;), the conclusions no longer apply.<br></p><p><br>&gt; Personally I would go against Dijksra&#39;s advice and include all 4 as operators,<br>&gt; however if Dijkstra is followed and only `..&lt;` remains then the &#39;lesser&#39; cases<br>&gt; could be covered with an init on Range:<br>&gt;<br>&gt; init Range(first: T, isFirstIncluded: Bool = true, last: T, isLastIncluded: Bool<br>&gt; = true, stride: Int = 1)<br>&gt;<br>&gt; On Thursday, 7 April 2016, Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     on Wed Apr 06 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     &gt;&gt; From a purely numerically aesthetic point of view, I&#39;d much prefer ranges<br>&gt;     to be<br>&gt;     &gt;&gt; openable and closable at both ends.<br>&gt;     &gt;&gt;<br>&gt;     &gt;&gt; My primary use-case has been teaching math using playgrounds but I&#39;m sure<br>&gt;     &gt;&gt; there are lots of other real-world situations more specific to common<br>&gt;     numerical<br>&gt;     &gt;&gt; method tasks.<br>&gt;     &gt;<br>&gt;     &gt; By coincidence, a Perl hacker I know commented on Twitter yesterday<br>&gt;     &gt; that he thought 1-based arrays were the way to go in the 21st<br>&gt;     &gt; century. Somebody replying to that suggestion linked to a note by<br>&gt;     &gt; Dijkstra that&#39;s relevant to this conversation:<br>&gt;     &gt; &lt;https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html&gt;<br>&gt;     &gt;<br>&gt;     &gt; I&#39;d suggest everyone in this discussion should read it—it&#39;s only about 700<br>&gt;     words—but to summarize:<br>&gt;     &gt;<br>&gt;     &gt; 1. The semantic Swift refers to as `..&lt;` is the most natural range<br>&gt;     convention.<br>&gt;     &gt; 2. Relatedly, zero-based indexing is the most natural indexing convention.<br>&gt;     &gt;<br>&gt;     &gt; If we agree with Dijkstra&#39;s logic, then the only reason to support<br>&gt;     &gt; `&gt;..` is for ranges where start &gt; end—that is, when we&#39;re constructing<br>&gt;     &gt; a reversed range.<br>&gt;<br>&gt;     I (am familiar with and) agree with Dijkstra&#39;s logic, but not with your<br>&gt;     conclusion about it. The fact that one representation is more natural<br>&gt;     for most common computing tasks doesn&#39;t mean it&#39;s not worth supporting<br>&gt;     the other representations.<br>&gt;<br>&gt;     &gt; But if we decide to support striding backwards by using a forward<br>&gt;     &gt; range and a negative stride, then that covers the reverse use<br>&gt;     &gt; case. Thus, we would need neither additional range operators, nor<br>&gt;     &gt; reversed ranges.<br>&gt;     &gt;<br>&gt;     &gt; As for the `range.striding(by:)` vs `stride(over:by:)` question, my<br>&gt;     &gt; concerns there are, to be honest, mainly aesthetic. The need for<br>&gt;     &gt; parentheses around the range operator is more or less unavoidable, but<br>&gt;     &gt; I think they make the construct very ugly. However, I also think that<br>&gt;     &gt; the `stride(over:by:)` syntax (or, for that matter<br>&gt;     &gt; `stride(from:to:by:)`) look more constructor-y (they are only *not*<br>&gt;     &gt; constructors now because of the overloading), and I think it opens us<br>&gt;     &gt; up to parallel constructs like the `induce(from:while:by:)` function<br>&gt;     &gt; I&#39;ve been working on.<br>&gt;<br>&gt;     --<br>&gt;     Dave<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April  6, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; I (am familiar with and) agree with Dijkstra&#39;s logic, but not with your<br>&gt; conclusion about it.  The fact that one representation is more natural<br>&gt; for most common computing tasks doesn&#39;t mean it&#39;s not worth supporting<br>&gt; the other representations.<br></p><p>I&#39;m not saying that Dijkstra proves that we don&#39;t need any other range operators. Rather, I&#39;m saying that he demonstrates why supporting `..&lt;` but not `&lt;..` is not arbitrary or capricious. Dijkstra&#39;s argument *permits* us to privilege `..&lt;` as uniquely important, but doesn&#39;t *force* us to do so.<br></p><p>To another person just now, you said:<br></p><p>&gt; He was talking about ranges of integer indices, though, and even<br>&gt; more-specifically about how to address arrays.  Range&lt;Bound&gt; is a more<br>&gt; general concept that applies to much more than indices.  Once you<br>&gt; involve floating point (and rationals, and patterns for matching,<br>&gt; e.g. UnicodeScalar(&quot;a&quot;)...&quot;z&quot;), the conclusions no longer apply.<br></p><p>I actually think he was talking a little more broadly than that—essentially, he was discussing ordered, discrete types. In principle, the same argument applies to UnicodeScalars, but not to floating-point numbers (unless you use treat floats as a discrete type using `nextafter` as the `successor()` operation, which is coherent but not very useful in practice). Having said that, I *do* think that `...` is in practice quite useful for many types. I&#39;m less certain that `&lt;..` or `&lt;.&lt;` are.<br></p><p>* * *<br></p><p>By the way, another reason to have `stride` as a free function is that I think some types need a &quot;strider&quot;, an instance which performs the striding.<br></p><p>That was the conclusion I came to when I started experimenting with striding over NSDates a week or two ago. The best design I could come up with looked like this:<br></p><p>	calendar.using(.Day).stride(from: startDate, to: endDate, by: 1)<br></p><p>The `start` and `end` parameters could be grouped together into a single parameter to match `stride(over:by:)`, but you can&#39;t put the calendar or the unit into the stride—without them, there is no coherent way to calculate the distance between two dates.<br></p><p>So if some types need a strider, and will need to have the method structured as `strider.stride(something:by:)`, it seems like the free function version for types which *don&#39;t* need a strider ought to be `stride(something:by:)`. The `something.striding(by:)` design can&#39;t be easily adapted to this situation.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April  6, 2016 at 05:00:00pm</p></header><div class="content"><p>on Wed Apr 06 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br></p><p>&gt;&gt; I (am familiar with and) agree with Dijkstra&#39;s logic, but not with your<br>&gt;&gt; conclusion about it.  The fact that one representation is more natural<br>&gt;&gt; for most common computing tasks doesn&#39;t mean it&#39;s not worth supporting<br>&gt;&gt; the other representations.<br>&gt;<br>&gt; I&#39;m not saying that Dijkstra proves that we don&#39;t need any other range<br>&gt; operators. Rather, I&#39;m saying that he demonstrates why supporting<br>&gt; `..&lt;` but not `&lt;..` is not arbitrary or capricious. Dijkstra&#39;s<br>&gt; argument *permits* us to privilege `..&lt;` as uniquely important, but<br>&gt; doesn&#39;t *force* us to do so.<br></p><p>I agree.  And I still think it&#39;s uniquely important ;-).<br></p><p>&gt; To another person just now, you said:<br>&gt;<br>&gt;&gt; He was talking about ranges of integer indices, though, and even<br>&gt;&gt; more-specifically about how to address arrays.  Range&lt;Bound&gt; is a more<br>&gt;&gt; general concept that applies to much more than indices.  Once you<br>&gt;&gt; involve floating point (and rationals, and patterns for matching,<br>&gt;&gt; e.g. UnicodeScalar(&quot;a&quot;)...&quot;z&quot;), the conclusions no longer apply.<br>&gt;<br>&gt; I actually think he was talking a little more broadly than<br>&gt; that—essentially, he was discussing ordered, discrete types. In<br>&gt; principle, the same argument applies to UnicodeScalars, <br></p><p>Yes, but I don&#39;t know if he had such types.<br></p><p>&gt; but not to floating-point numbers (unless you use treat floats as a<br>&gt; discrete type using `nextafter` as the `successor()` operation, which<br>&gt; is coherent but not very useful in practice). Having said that, I *do*<br>&gt; think that `...` is in practice quite useful for many types. I&#39;m less<br>&gt; certain that `&lt;..` or `&lt;.&lt;` are.<br>&gt;<br>&gt; * * *<br>&gt;<br>&gt; By the way, another reason to have `stride` as a free function is that<br>&gt; I think some types need a &quot;strider&quot;, an instance which performs the<br>&gt; striding.<br>&gt;<br>&gt; That was the conclusion I came to when I started experimenting with<br>&gt; striding over NSDates a week or two ago. The best design I could come<br>&gt; up with looked like this:<br>&gt;<br>&gt; 	calendar.using(.Day).stride(from: startDate, to: endDate, by: 1)<br></p><p>&gt; The `start` and `end` parameters could be grouped together into a<br>&gt; single parameter to match `stride(over:by:)`, but you can&#39;t put the<br>&gt; calendar or the unit into the stride—without them, there is no<br>&gt; coherent way to calculate the distance between two dates.<br>&gt;<br>&gt; So if some types need a strider, and will need to have the method<br>&gt; structured as `strider.stride(something:by:)`, it seems like the free<br>&gt; function version for types which *don&#39;t* need a strider ought to be<br>&gt; `stride(something:by:)`. The `something.striding(by:)` design can&#39;t be<br>&gt; easily adapted to this situation.<br></p><p>  calendar[startDate..&lt;endDate].striding(by: .Day)<br></p><p>?<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April  7, 2016 at 11:00:00am</p></header><div class="content"><p>I like the idea that Array gains `strinding(by:)` but would also like Range<br>to be like an array, same interface, and hence also gain `strinding(by:)`,<br>hence:<br></p><p>calendar[(startDate ..&lt; endDate).striding(by: .Day)]<br></p><p><br>  -- Howard.<br></p><p>On 7 April 2016 at 10:53, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Wed Apr 06 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; I (am familiar with and) agree with Dijkstra&#39;s logic, but not with your<br>&gt; &gt;&gt; conclusion about it.  The fact that one representation is more natural<br>&gt; &gt;&gt; for most common computing tasks doesn&#39;t mean it&#39;s not worth supporting<br>&gt; &gt;&gt; the other representations.<br>&gt; &gt;<br>&gt; &gt; I&#39;m not saying that Dijkstra proves that we don&#39;t need any other range<br>&gt; &gt; operators. Rather, I&#39;m saying that he demonstrates why supporting<br>&gt; &gt; `..&lt;` but not `&lt;..` is not arbitrary or capricious. Dijkstra&#39;s<br>&gt; &gt; argument *permits* us to privilege `..&lt;` as uniquely important, but<br>&gt; &gt; doesn&#39;t *force* us to do so.<br>&gt;<br>&gt; I agree.  And I still think it&#39;s uniquely important ;-).<br>&gt;<br>&gt; &gt; To another person just now, you said:<br>&gt; &gt;<br>&gt; &gt;&gt; He was talking about ranges of integer indices, though, and even<br>&gt; &gt;&gt; more-specifically about how to address arrays.  Range&lt;Bound&gt; is a more<br>&gt; &gt;&gt; general concept that applies to much more than indices.  Once you<br>&gt; &gt;&gt; involve floating point (and rationals, and patterns for matching,<br>&gt; &gt;&gt; e.g. UnicodeScalar(&quot;a&quot;)...&quot;z&quot;), the conclusions no longer apply.<br>&gt; &gt;<br>&gt; &gt; I actually think he was talking a little more broadly than<br>&gt; &gt; that—essentially, he was discussing ordered, discrete types. In<br>&gt; &gt; principle, the same argument applies to UnicodeScalars,<br>&gt;<br>&gt; Yes, but I don&#39;t know if he had such types.<br>&gt;<br>&gt; &gt; but not to floating-point numbers (unless you use treat floats as a<br>&gt; &gt; discrete type using `nextafter` as the `successor()` operation, which<br>&gt; &gt; is coherent but not very useful in practice). Having said that, I *do*<br>&gt; &gt; think that `...` is in practice quite useful for many types. I&#39;m less<br>&gt; &gt; certain that `&lt;..` or `&lt;.&lt;` are.<br>&gt; &gt;<br>&gt; &gt; * * *<br>&gt; &gt;<br>&gt; &gt; By the way, another reason to have `stride` as a free function is that<br>&gt; &gt; I think some types need a &quot;strider&quot;, an instance which performs the<br>&gt; &gt; striding.<br>&gt; &gt;<br>&gt; &gt; That was the conclusion I came to when I started experimenting with<br>&gt; &gt; striding over NSDates a week or two ago. The best design I could come<br>&gt; &gt; up with looked like this:<br>&gt; &gt;<br>&gt; &gt;       calendar.using(.Day).stride(from: startDate, to: endDate, by: 1)<br>&gt;<br>&gt; &gt; The `start` and `end` parameters could be grouped together into a<br>&gt; &gt; single parameter to match `stride(over:by:)`, but you can&#39;t put the<br>&gt; &gt; calendar or the unit into the stride—without them, there is no<br>&gt; &gt; coherent way to calculate the distance between two dates.<br>&gt; &gt;<br>&gt; &gt; So if some types need a strider, and will need to have the method<br>&gt; &gt; structured as `strider.stride(something:by:)`, it seems like the free<br>&gt; &gt; function version for types which *don&#39;t* need a strider ought to be<br>&gt; &gt; `stride(something:by:)`. The `something.striding(by:)` design can&#39;t be<br>&gt; &gt; easily adapted to this situation.<br>&gt;<br>&gt;   calendar[startDate..&lt;endDate].striding(by: .Day)<br>&gt;<br>&gt; ?<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160407/7eeb8f9c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April  7, 2016 at 05:00:00am</p></header><div class="content"><p>&gt;&gt; 	calendar.using(.Day).stride(from: startDate, to: endDate, by: 1)<br>&gt; <br>&gt;&gt; The `start` and `end` parameters could be grouped together into a<br>&gt;&gt; single parameter to match `stride(over:by:)`, but you can&#39;t put the<br>&gt;&gt; calendar or the unit into the stride—without them, there is no<br>&gt;&gt; coherent way to calculate the distance between two dates.<br>&gt;&gt; <br>&gt;&gt; So if some types need a strider, and will need to have the method<br>&gt;&gt; structured as `strider.stride(something:by:)`, it seems like the free<br>&gt;&gt; function version for types which *don&#39;t* need a strider ought to be<br>&gt;&gt; `stride(something:by:)`. The `something.striding(by:)` design can&#39;t be<br>&gt;&gt; easily adapted to this situation.<br>&gt; <br>&gt;  calendar[startDate..&lt;endDate].striding(by: .Day)<br>&gt; <br>&gt; ?<br></p><p>Actually, it would need to be something like `calendar[startDate..&lt;endDate, unit: .Day].striding(by: 1)`, because NSCalendarUnit is not itself a stride, it is the *unit* of the stride. But even that doesn&#39;t quite help.<br></p><p>Here&#39;s the issue.<br></p><p>Take a look at today&#39;s Strideable. Stripped of comments and irrelevant annotations, you have:<br></p><p>	protocol Strideable : Comparable {<br>	    associatedtype Stride : SignedNumberType<br>	    func distanceTo(other: Self) -&gt; Stride<br>	    func advancedBy(n: Stride) -&gt; Self<br>	}<br></p><p>The problem is that there&#39;s no good way to get the calendar and unit into these methods. If you package them inside `Stride`, then `distanceTo` has no idea what calendar or unit it&#39;s supposed to return. If you package them inside `Self`, then `distanceTo` has two calendars and two units, and they might not agree (and the type system can&#39;t catch this issue). <br></p><p>To fix this, you need to have a single instance which performs the calculation. For simple Strideable types, this instance would not do very much, but for dates, it would factor in the calendar and unit.<br></p><p>For example, suppose you modify `Strideable` so that, instead of applying to the values participating in the striding, it applies to the instance containing those values:<br></p><p>	public protocol Strideable {<br>		associatedtype Element: Comparable<br>		associatedtype Stride: SignedNumber<br>		<br>		var start: Value<br>		var end: Value<br>		<br>		public func distance(from earlier: Element, to later: Element) -&gt; Stride<br>		public func advance(element: Element, by stride: Stride) -&gt; Element<br>	}<br></p><p>Now, with some *really* aggressive conditional conformance work, you could do this:<br></p><p>	extension Range: Strideable where Element == Int {<br>		typealias Stride = Int<br>		<br>		public func distance(from earlier: Int, to later: Int) -&gt; Int {<br>			return later - earlier<br>		}<br>		public func advance(element: Int, by stride: Int) {<br>			return value + stride<br>		}<br>	}<br>	extension Range: Strideable where Element == Double {<br>		// Ignoring the accumulation issue.<br>		typealias Stride = Double<br>		<br>		public func distance(from earlier: Int, to later: Int) -&gt; Int {<br>			return later - earlier<br>		}<br>		public func advance(element: Double, by stride: Double) {<br>			return element + stride<br>		}<br>	}<br>	// etc., for each type you care about.<br>	// <br>	// This could be automated by creating a `RangeStrideable` protocol similar to the old Strideable,<br>	// and having types with this automatic behavior conform to it. You could then have a single:<br>	// 	extension Range: Strideable where Element: RangeStrideable<br></p><p>It would not be possible to stride directly over a range of NSDates, but you could have a &quot;calendar range&quot; which could be `Strideable`, like so:<br></p><p>	struct NSCalendarRange {<br>		var start: NSDate<br>		var end: NSDate<br>		<br>		var calendar: NSCalendar<br>		var unit: NSCalendarUnit<br></p><p>		var options: NSCalendarOptions<br>		// This mainly contains rounding options. Interestingly, NSDate is like Double in that <br>		// it accumulates errors through repeated addition. To fix that, I have discovered <br>		// a truly marvelous design which this email is too small to contain.<br>	}<br>	extension NSCalendarRange: Strideable {<br>		typealias Value = NSDate<br>		typealias Stride = Int<br>		<br>		public func distance(from earlier: NSDate, to later: NSDate) -&gt; Int {<br>			let components = calendar.components(unit, from: earlier, to: later, options: options)<br>			return components.value(forComponent: unit)<br>		}<br>		public func advance(value: NSDate, by stride: Int) -&gt; NSDate {<br>			return calendar.date(byAdding: unit, value: distance, to: value, options: options)!<br>		}<br>	}<br></p><p>So I guess `striding(by:)` can be adapted to date arithmetic, but only if we adjust our conception of what a stride is striding over.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April  7, 2016 at 11:00:00am</p></header><div class="content"><p>on Thu Apr 07 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br></p><p>&gt;&gt;&gt; calendar.using(.Day).stride(from: startDate, to: endDate, by: 1)<br>&gt;&gt; <br>&gt;&gt;&gt; The `start` and `end` parameters could be grouped together into a<br>&gt;&gt;&gt; single parameter to match `stride(over:by:)`, but you can&#39;t put the<br>&gt;&gt;&gt; calendar or the unit into the stride—without them, there is no<br>&gt;<br>&gt;&gt;&gt; coherent way to calculate the distance between two dates.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So if some types need a strider, and will need to have the method<br>&gt;&gt;&gt; structured as `strider.stride(something:by:)`, it seems like the<br>&gt; free<br>&gt;&gt;&gt; function version for types which *don&#39;t* need a strider ought to be<br>&gt;&gt;&gt; `stride(something:by:)`. The `something.striding(by:)` design can&#39;t<br>&gt; be<br>&gt;&gt;&gt; easily adapted to this situation.<br>&gt;&gt; <br>&gt;&gt;  calendar[startDate..&lt;endDate].striding(by: .Day)<br>&gt;&gt; <br>&gt;&gt; ?<br>&gt;<br>&gt; Actually, it would need to be something like<br>&gt; `calendar[startDate..&lt;endDate, unit: .Day].striding(by: 1)`, because<br>&gt; NSCalendarUnit is not itself a stride, it is the *unit* of the<br>&gt; stride. <br></p><p>Maybe:<br></p><p>  calendar.days[startDate..&lt;endDate].striding(by: 1)<br></p><p>&gt; But even that doesn&#39;t quite help.<br>&gt;<br>&gt; Here&#39;s the issue.<br>&gt;<br>&gt; Take a look at today&#39;s Strideable. Stripped of comments and irrelevant<br>&gt; annotations, you have:<br>&gt;<br>&gt; 	protocol Strideable : Comparable {<br>&gt; 	    associatedtype Stride : SignedNumberType<br>&gt; 	    func distanceTo(other: Self) -&gt; Stride<br>&gt; 	    func advancedBy(n: Stride) -&gt; Self<br>&gt; 	}<br>&gt;<br>&gt; The problem is that there&#39;s no good way to get the calendar and unit<br>&gt; into these methods. If you package them inside `Stride`, then<br>&gt; `distanceTo` has no idea what calendar or unit it&#39;s supposed to<br>&gt; return. If you package them inside `Self`, then `distanceTo` has two<br>&gt; calendars and two units, and they might not agree (and the type system<br>&gt; can&#39;t catch this issue).<br>&gt;<br>&gt; To fix this, you need to have a single instance which performs the<br>&gt; calculation. For simple Strideable types, this instance would not do<br>&gt; very much, but for dates, it would factor in the calendar and unit.<br></p><p>I follow all the above; it&#39;s a good explanation of the problem.<br>However, it doesn&#39;t explain why<br></p><p>  calendar[startDate..&lt;endDate, unit: .Day].striding(by: 1)<br></p><p>“doesn&#39;t quite help.”  It seems to me that <br></p><p>  calendar[startDate..&lt;endDate, unit: .Day]<br></p><p>does factor in the calendar and unit.<br></p><p>&gt; For example, suppose you modify `Strideable` so that, instead of<br>&gt; applying to the values participating in the striding, it applies to<br>&gt; the instance containing those values:<br>&gt;<br>&gt; 	public protocol Strideable {<br>&gt; 		associatedtype Element: Comparable<br>&gt; 		associatedtype Stride: SignedNumber<br>&gt;<br>&gt; 		var start: Value<br>&gt; 		var end: Value<br>&gt;<br>&gt; 		public func distance(from earlier: Element, to later: Element) -&gt; Stride<br>&gt; 		public func advance(element: Element, by stride: Stride) -&gt; Element<br>&gt; 	}<br></p><p>Presumably you mean for Strideable to have a striding(by:_) method as well?<br></p><p>If so, how is this fundamentally different from Collection?  Shouldn&#39;t<br>every Collection support this?<br></p><p>&gt; Now, with some *really* aggressive conditional conformance work, you<br>&gt; could do this:<br>&gt;<br>&gt; 	extension Range: Strideable where Element == Int {<br>&gt; 		typealias Stride = Int<br>&gt;<br>&gt; 		public func distance(from earlier: Int, to later: Int)<br>&gt; -&gt; Int {<br>&gt; 			return later - earlier<br>&gt; 		}<br>&gt; 		public func advance(element: Int, by stride: Int) {<br>&gt; 			return value + stride<br>&gt; 		}<br>&gt; 	}<br>&gt; 	extension Range: Strideable where Element == Double {<br>&gt; 		// Ignoring the accumulation issue.<br>&gt; 		typealias Stride = Double<br>&gt;<br>&gt; 		public func distance(from earlier: Int, to later: Int) -&gt; Int {<br>&gt; 			return later - earlier<br>&gt; 		}<br>&gt; 		public func advance(element: Double, by stride: Double) {<br>&gt; 			return element + stride<br>&gt; 		}<br>&gt; 	}<br></p><p>Except we don&#39;t have that capability today.  Instead we&#39;d be using<br>overloads of ..&lt; and ... to produce more-capable range types, c.f.  <br>https://github.com/apple/swift/blob/swift-3-indexing-model/stdlib/public/core/Range.swift#L504<br>https://github.com/apple/swift/blob/swift-3-indexing-model/stdlib/public/core/Range.swift#L519<br></p><p>&gt; 	<br>&gt; 	// etc., for each type you care about.<br>&gt; 	// <br>&gt; 	// This could be automated by creating a `RangeStrideable` protocol similar to the old Strideable,<br>&gt; 	// and having types with this automatic behavior conform to it. You could then have a single:<br>&gt; 	// extension Range: Strideable where Element: RangeStrideable<br>&gt;<br>&gt; It would not be possible to stride directly over a range of NSDates,<br>&gt; but you could have a &quot;calendar range&quot; which could be `Strideable`,<br>&gt; like so:<br>&gt;<br>&gt; 	struct NSCalendarRange {<br>&gt; 		var start: NSDate<br>&gt; 		var end: NSDate<br>&gt;<br>&gt; 		var calendar: NSCalendar<br>&gt; 		var unit: NSCalendarUnit<br>&gt;<br>&gt; 		var options: NSCalendarOptions<br>&gt; 		// This mainly contains rounding options. Interestingly, NSDate is like Double in that<br>&gt; 		// it accumulates errors through repeated addition. To fix that, I have discovered<br>&gt; 		// a truly marvelous design which this email is too small to contain.<br>&gt; 	}<br>&gt; 	extension NSCalendarRange: Strideable {<br>&gt; 		typealias Value = NSDate<br>&gt; 		typealias Stride = Int<br>&gt;<br>&gt; 		public func distance(from earlier: NSDate, to later: NSDate) -&gt; Int {<br>&gt; 			let components = calendar.components(unit, from: earlier, to: later, options: options)<br>&gt; 			return components.value(forComponent: unit)<br>&gt; 		}<br>&gt; 		public func advance(value: NSDate, by stride: Int) -&gt; NSDate {<br>&gt; 			return calendar.date(byAdding: unit, value: distance, to: value, options: options)!<br>&gt; 		}<br>&gt; 	}<br>&gt;<br>&gt; So I guess `striding(by:)` can be adapted to date arithmetic, but only<br>&gt; if we adjust our conception of what a stride is striding over.<br></p><p><br>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April  7, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;&gt; Actually, it would need to be something like<br>&gt;&gt; `calendar[startDate..&lt;endDate, unit: .Day].striding(by: 1)`, because<br>&gt;&gt; NSCalendarUnit is not itself a stride, it is the *unit* of the<br>&gt;&gt; stride. <br>&gt; <br>&gt; Maybe:<br>&gt; <br>&gt;  calendar.days[startDate..&lt;endDate].striding(by: 1)<br></p><p>I&#39;ve been leaning towards parameters for additional flexibility, but the difference there is only slightly more than bikeshedding.<br></p><p>&gt; However, it doesn&#39;t explain why<br>&gt; <br>&gt;  calendar[startDate..&lt;endDate, unit: .Day].striding(by: 1)<br>&gt; <br>&gt; “doesn&#39;t quite help.”  It seems to me that <br>&gt; <br>&gt;  calendar[startDate..&lt;endDate, unit: .Day]<br>&gt; <br>&gt; does factor in the calendar and unit.<br></p><p>Yes, it does—as long as Strideable changes so that the instance created by this expression participates in the striding. My point is that, as long as the operations in Strideable are performed on one of the two strides, the &quot;range&quot; we&#39;re moving over can&#39;t be involved enough to help. Striding has to be done with the assistance of the instance owning the start and end, not just the start and end themselves.<br></p><p>Basically, what I&#39;m saying is that Strideable needs a redesign along the lines of the indexing system. We redesigned indexing so that the collection manipulates the indexes, rather than the indexes manipulating themselves, because the indexes don&#39;t always have enough information to do the job. We need to do the same thing with Strideable.<br></p><p>&gt;&gt; For example, suppose you modify `Strideable` so that, instead of<br>&gt;&gt; applying to the values participating in the striding, it applies to<br>&gt;&gt; the instance containing those values:<br>&gt;&gt; <br>&gt;&gt; 	public protocol Strideable {<br>&gt;&gt; 		associatedtype Element: Comparable<br>&gt;&gt; 		associatedtype Stride: SignedNumber<br>&gt;&gt; <br>&gt;&gt; 		var start: Value<br>&gt;&gt; 		var end: Value<br>&gt;&gt; <br>&gt;&gt; 		public func distance(from earlier: Element, to later: Element) -&gt; Stride<br>&gt;&gt; 		public func advance(element: Element, by stride: Stride) -&gt; Element<br>&gt;&gt; 	}<br>&gt; <br>&gt; Presumably you mean for Strideable to have a striding(by:_) method as well?<br></p><p>Yes, there would be an extension method like that (or there would be a `func stride&lt;StrideableType: Strideable&gt;(over: StrideableType, by: StrideableType.Stride) -&gt; …`, which is the same thing). I didn&#39;t include it because it&#39;s not a requirement imposed on the conforming type.<br></p><p>&gt; If so, how is this fundamentally different from Collection?  Shouldn&#39;t<br>&gt; every Collection support this?<br></p><p>Huh, interesting. Very, very interesting.<br></p><p>Strideable is more widely applicable than Collection; for instance, a Range&lt;Double&gt; can&#39;t be a Collection (except via `nextafter`), but it is Strideable. But every RandomAccessCollection can be Strideable. (So could any BidirectionalCollection, for that matter, although it would be slower.) `array.striding(by: 2)` is a coherent and useful operation.<br></p><p>So yes, I think every Collection (with a suitable index) could be Strideable. But there are Strideable things which aren&#39;t collections.<br></p><p>&gt; Except we don&#39;t have that capability today.  Instead we&#39;d be using<br>&gt; overloads of ..&lt; and ... to produce more-capable range types, c.f.  <br>&gt; https://github.com/apple/swift/blob/swift-3-indexing-model/stdlib/public/core/Range.swift#L504<br>&gt; https://github.com/apple/swift/blob/swift-3-indexing-model/stdlib/public/core/Range.swift#L519<br></p><p>That works too, I suppose. You would end up with a StrideableRange &quot;between&quot; your current CountableRange (which is a Collection) and Range (which is a glorified tuple).<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April  7, 2016 at 09:00:00pm</p></header><div class="content"><p>I&#39;m confused. There is an instance owning the start and end. It&#39;s called<br>StrideTo or StrideThrough, conforms to Sequence (with a FIXME comment that<br>it should conform to Collection) and is distinct from Range and from the<br>Strideable bounds themselves. Is that different from what you&#39;re describing?<br></p><p>If I&#39;m not misunderstanding, you&#39;re asking for a protocol common to<br>StrideTo and StrideThrough to which other types such as a hypothetical<br>NSDateStride could conform?<br></p><p>On Thu, Apr 7, 2016 at 5:25 PM Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt;&gt; Actually, it would need to be something like<br>&gt; &gt;&gt; `calendar[startDate..&lt;endDate, unit: .Day].striding(by: 1)`, because<br>&gt; &gt;&gt; NSCalendarUnit is not itself a stride, it is the *unit* of the<br>&gt; &gt;&gt; stride.<br>&gt; &gt;<br>&gt; &gt; Maybe:<br>&gt; &gt;<br>&gt; &gt;  calendar.days[startDate..&lt;endDate].striding(by: 1)<br>&gt;<br>&gt; I&#39;ve been leaning towards parameters for additional flexibility, but the<br>&gt; difference there is only slightly more than bikeshedding.<br>&gt;<br>&gt; &gt; However, it doesn&#39;t explain why<br>&gt; &gt;<br>&gt; &gt;  calendar[startDate..&lt;endDate, unit: .Day].striding(by: 1)<br>&gt; &gt;<br>&gt; &gt; “doesn&#39;t quite help.”  It seems to me that<br>&gt; &gt;<br>&gt; &gt;  calendar[startDate..&lt;endDate, unit: .Day]<br>&gt; &gt;<br>&gt; &gt; does factor in the calendar and unit.<br>&gt;<br>&gt; Yes, it does—as long as Strideable changes so that the instance created by<br>&gt; this expression participates in the striding. My point is that, as long as<br>&gt; the operations in Strideable are performed on one of the two strides, the<br>&gt; &quot;range&quot; we&#39;re moving over can&#39;t be involved enough to help. Striding has to<br>&gt; be done with the assistance of the instance owning the start and end, not<br>&gt; just the start and end themselves.<br>&gt;<br>&gt; Basically, what I&#39;m saying is that Strideable needs a redesign along the<br>&gt; lines of the indexing system. We redesigned indexing so that the collection<br>&gt; manipulates the indexes, rather than the indexes manipulating themselves,<br>&gt; because the indexes don&#39;t always have enough information to do the job. We<br>&gt; need to do the same thing with Strideable.<br>&gt;<br>&gt; &gt;&gt; For example, suppose you modify `Strideable` so that, instead of<br>&gt; &gt;&gt; applying to the values participating in the striding, it applies to<br>&gt; &gt;&gt; the instance containing those values:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;      public protocol Strideable {<br>&gt; &gt;&gt;              associatedtype Element: Comparable<br>&gt; &gt;&gt;              associatedtype Stride: SignedNumber<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;              var start: Value<br>&gt; &gt;&gt;              var end: Value<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;              public func distance(from earlier: Element, to later:<br>&gt; Element) -&gt; Stride<br>&gt; &gt;&gt;              public func advance(element: Element, by stride: Stride)<br>&gt; -&gt; Element<br>&gt; &gt;&gt;      }<br>&gt; &gt;<br>&gt; &gt; Presumably you mean for Strideable to have a striding(by:_) method as<br>&gt; well?<br>&gt;<br>&gt; Yes, there would be an extension method like that (or there would be a<br>&gt; `func stride&lt;StrideableType: Strideable&gt;(over: StrideableType, by:<br>&gt; StrideableType.Stride) -&gt; …`, which is the same thing). I didn&#39;t include it<br>&gt; because it&#39;s not a requirement imposed on the conforming type.<br>&gt;<br>&gt; &gt; If so, how is this fundamentally different from Collection?  Shouldn&#39;t<br>&gt; &gt; every Collection support this?<br>&gt;<br>&gt; Huh, interesting. Very, very interesting.<br>&gt;<br>&gt; Strideable is more widely applicable than Collection; for instance, a<br>&gt; Range&lt;Double&gt; can&#39;t be a Collection (except via `nextafter`), but it is<br>&gt; Strideable. But every RandomAccessCollection can be Strideable. (So could<br>&gt; any BidirectionalCollection, for that matter, although it would be slower.)<br>&gt; `array.striding(by: 2)` is a coherent and useful operation.<br>&gt;<br>&gt; So yes, I think every Collection (with a suitable index) could be<br>&gt; Strideable. But there are Strideable things which aren&#39;t collections.<br>&gt;<br>&gt; &gt; Except we don&#39;t have that capability today.  Instead we&#39;d be using<br>&gt; &gt; overloads of ..&lt; and ... to produce more-capable range types, c.f.<br>&gt; &gt;<br>&gt; https://github.com/apple/swift/blob/swift-3-indexing-model/stdlib/public/core/Range.swift#L504<br>&gt; &gt;<br>&gt; https://github.com/apple/swift/blob/swift-3-indexing-model/stdlib/public/core/Range.swift#L519<br>&gt;<br>&gt; That works too, I suppose. You would end up with a StrideableRange<br>&gt; &quot;between&quot; your current CountableRange (which is a Collection) and Range<br>&gt; (which is a glorified tuple).<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160407/89eedd71/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April  7, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; I&#39;m confused. There is an instance owning the start and end. It&#39;s called StrideTo or StrideThrough, conforms to Sequence (with a FIXME comment that it should conform to Collection) and is distinct from Range and from the Strideable bounds themselves. Is that different from what you&#39;re describing?<br></p><p>Yes, it is different. StrideTo and StrideThrough represent the sequence resulting from the striding operation. If there was only one of them, you would probably call it StrideSequence. They are the *result* of the `stride` function or `striding` method.<br></p><p>What I&#39;m talking about is a single instance which represents what you are striding *over*, but *not* the length of the stride. It is an *input* to the `stride` function or `striding` method.<br></p><p>Does that make sense?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April  7, 2016 at 11:00:00pm</p></header><div class="content"><p>Conceptually, maybe? But of course the sequence is lazily evaluated, so the<br>only state stored in an instance of StrideTo is one value for the current<br>iteration; all the other properties in a StrideTo are just the inputs to<br>the stride function, and no length is computed let alone stored. I get that<br>you want something that represents the input instead of the output, but<br>what do you gain from that type not achievable otherwise?<br>On Thu, Apr 7, 2016 at 6:59 PM Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; I&#39;m confused. There is an instance owning the start and end. It&#39;s called<br>&gt; StrideTo or StrideThrough, conforms to Sequence (with a FIXME comment that<br>&gt; it should conform to Collection) and is distinct from Range and from the<br>&gt; Strideable bounds themselves. Is that different from what you&#39;re describing?<br>&gt;<br>&gt; Yes, it is different. StrideTo and StrideThrough represent the sequence<br>&gt; resulting from the striding operation. If there was only one of them, you<br>&gt; would probably call it StrideSequence. They are the *result* of the<br>&gt; `stride` function or `striding` method.<br>&gt;<br>&gt; What I&#39;m talking about is a single instance which represents what you are<br>&gt; striding *over*, but *not* the length of the stride. It is an *input* to<br>&gt; the `stride` function or `striding` method.<br>&gt;<br>&gt; Does that make sense?<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160407/15ee7c2b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April  7, 2016 at 08:00:00pm</p></header><div class="content"><p>At the risk of asking one of those newbie questions, why bother with StrideTo and StrideThrough? Isn&#39;t a Generator or Array more to the point?<br>&gt; On Apr 7, 2016, at 5:59 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I&#39;m confused. There is an instance owning the start and end. It&#39;s called StrideTo or StrideThrough, conforms to Sequence (with a FIXME comment that it should conform to Collection) and is distinct from Range and from the Strideable bounds themselves. Is that different from what you&#39;re describing?<br>&gt; <br>&gt; Yes, it is different. StrideTo and StrideThrough represent the sequence resulting from the striding operation. If there was only one of them, you would probably call it StrideSequence. They are the *result* of the `stride` function or `striding` method.<br></p><p>- Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April  8, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; At the risk of asking one of those newbie questions, why bother with StrideTo and StrideThrough? Isn&#39;t a Generator or Array more to the point?<br></p><p>You don&#39;t want to return an Array because you want to generate the values lazily. If `stride(over: 1..&lt;1_000_000, by: 10)` returned an Array, you would have to allocate an array with 100,000 elements. A StrideTo, by contrast, is the size of roughly 3 elements; it creates the values on demand.<br></p><p>You can&#39;t return Generator because Generator is a protocol with no real behavior associated with it; you need a concrete type. StrideTo and StrideThrough conform to Sequence, a protocol whose main purpose is to return a Generator. (well, Iterator in Swift 3). So in essence, StrideTo and StrideThrough *are* how you return a Generator.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
