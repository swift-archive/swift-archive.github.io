<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 21, 2016 at 01:00:00pm</p></header><div class="content"><p>on Thu Jul 21 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Jul 21, 2016, at 12:47 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Thu Jul 21 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 to the first design.  I think this is a great solution that<br>&gt;&gt;&gt; balances the many considerations that have been raised on all sides of<br>&gt;&gt;&gt; this issue.  `open` is 2 characters shorter than `public` so<br>&gt;&gt;&gt; complaints about boilerplate are no longer valid.  `internal` is the<br>&gt;&gt;&gt; “default” - neither `public` nor `open` are privileged as a “default”<br>&gt;&gt;&gt; for publishing API outside of a module.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am interested in language enhancements such as exhaustive pattern<br>&gt;&gt;&gt; matching on classes and protocols which rely on knowledge of the full<br>&gt;&gt;&gt; class hierarchy.  Such enhancements will be far more useful if the<br>&gt;&gt;&gt; language supports non-open, non-final classes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are design techniques that would require additional boilerplate<br>&gt;&gt;&gt; if we cannot have non-open, non-final classes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Most importantly, requiring library authors to choose `public` or<br>&gt;&gt;&gt; `open` provides important documentation value.  Users of the library<br>&gt;&gt;&gt; will know whether the author intends to support subclasses or not.<br>&gt;&gt; <br>&gt;&gt; I think this reasoning is flawed.<br>&gt;&gt; <br>&gt;&gt; If you make any methods overridable outside your module (“open”),<br>&gt;&gt; obviously you mean to allow subclassing outside the module.  If you have<br>&gt;&gt; no open methods, there&#39;s absolutely nothing you need to do to “support<br>&gt;&gt; subclasses,” and from a design point-of-view, there&#39;s no reason to<br>&gt;&gt; restrict people from subclassing.<br>&gt;<br>&gt; I disagree.  As has been discussed when a class is not open the author<br>&gt; does not make a commitment to allow subclasses.  <br></p><p>Yes, but that argument is based on the *assumption* that disallowing<br>subclassing is somehow an important dimension of safety or preserving<br>API contracts, independent of overriding.  It isn&#39;t.<br></p><p>Demonstration: we don&#39;t make that argument about aggregation: you can&#39;t<br>prevent someone from making your public struct a stored property in a<br>type defined outside the module.  Judgements about programming style<br>aside, in the absence of overriding, subclassing and aggregation are<br>identical from an encapsulation point-of-view.<br></p><p>&gt; The right to make the class final is reserved for the future.  Maybe<br>&gt; this is the “nice point of control” you refer to and don’t find<br>&gt; compelling?  I would prefer to have library authors acknowledge that<br>&gt; they intend to allow subclasses and make that commitment explicit.<br></p><p>The question is, why?<br></p><p>&gt; For me it isn’t about control as much as it is about making the API<br>&gt; contract explicit and acknowledged.  I have wondered about the intent<br>&gt; of library authors enough times to find this explicit statement in the<br>&gt; language worthwhile.<br></p><p>Yeah, but we don&#39;t add language features to represent every possible<br>author intention, and there&#39;s a good argument that any intention that<br>can be violated without harm shouldn&#39;t be enforced.<br></p><p>&gt; I also think language features enabled by knowing the whole class<br>&gt; hierarchy will provide more value than “compositional subclasses” as<br>&gt; long as we gain better support for composition elsewhere in the<br>&gt; language.<br></p><p>I agree that there are better ways to solve the composition/API<br>forwarding problem.<br></p><p>&gt;&gt; The only reasons I can see for allowing people to prevent non-final<br>&gt;&gt; classes from being subclassed outside the module in which they are<br>&gt;&gt; defined are:<br>&gt;&gt; <br>&gt;&gt; 1. It feels like a nice point of control to have.<br>&gt;&gt; <br>&gt;&gt; 2. Marginal performance gains as noted in the proposal<br>&gt;&gt; <br>&gt;&gt; I personally don&#39;t find these to be convincing.  #1 in particular seems<br>&gt;&gt; like a poor way to make language design decisions.  If we decide to add<br>&gt;&gt; this point of control, I&#39;ll justify it to myself in terms of #2.<br>&gt;&gt; <br>&gt;&gt; P.S., I can live with either alternative; it&#39;s just important to me that<br>&gt;&gt; we understand the situation clearly when evaluating them.<br>&gt;<br>&gt; I agree with this.<br>&gt;<br>&gt;&gt; <br>&gt;&gt; HTH,<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[swift-evolution-announce] [Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 22, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; On 21 Jul 2016, at 22:13, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu Jul 21 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jul 21, 2016, at 12:47 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Thu Jul 21 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1 to the first design.  I think this is a great solution that<br>&gt;&gt;&gt;&gt; balances the many considerations that have been raised on all sides of<br>&gt;&gt;&gt;&gt; this issue.  `open` is 2 characters shorter than `public` so<br>&gt;&gt;&gt;&gt; complaints about boilerplate are no longer valid.  `internal` is the<br>&gt;&gt;&gt;&gt; “default” - neither `public` nor `open` are privileged as a “default”<br>&gt;&gt;&gt;&gt; for publishing API outside of a module.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I am interested in language enhancements such as exhaustive pattern<br>&gt;&gt;&gt;&gt; matching on classes and protocols which rely on knowledge of the full<br>&gt;&gt;&gt;&gt; class hierarchy.  Such enhancements will be far more useful if the<br>&gt;&gt;&gt;&gt; language supports non-open, non-final classes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are design techniques that would require additional boilerplate<br>&gt;&gt;&gt;&gt; if we cannot have non-open, non-final classes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Most importantly, requiring library authors to choose `public` or<br>&gt;&gt;&gt;&gt; `open` provides important documentation value.  Users of the library<br>&gt;&gt;&gt;&gt; will know whether the author intends to support subclasses or not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this reasoning is flawed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you make any methods overridable outside your module (“open”),<br>&gt;&gt;&gt; obviously you mean to allow subclassing outside the module.  If you have<br>&gt;&gt;&gt; no open methods, there&#39;s absolutely nothing you need to do to “support<br>&gt;&gt;&gt; subclasses,” and from a design point-of-view, there&#39;s no reason to<br>&gt;&gt;&gt; restrict people from subclassing.<br>&gt;&gt; <br>&gt;&gt; I disagree.  As has been discussed when a class is not open the author<br>&gt;&gt; does not make a commitment to allow subclasses.  <br>&gt; <br>&gt; Yes, but that argument is based on the *assumption* that disallowing<br>&gt; subclassing is somehow an important dimension of safety or preserving<br>&gt; API contracts, independent of overriding.  It isn&#39;t.<br>&gt; <br>&gt; Demonstration: we don&#39;t make that argument about aggregation: you can&#39;t<br>&gt; prevent someone from making your public struct a stored property in a<br>&gt; type defined outside the module.  Judgements about programming style<br>&gt; aside, in the absence of overriding, subclassing and aggregation are<br>&gt; identical from an encapsulation point-of-view.<br>&gt; <br></p><p>IMO, the safety of API contracts is secondary. This is about safety of implementation - my code is possibly not &quot;resilient&quot; enough (to to speak) to handle overriding arbitrary public members. Not all members are equally resilient to being overridden (an implementation detail). It is not driven by ideological considerations as much as practical considerations - writing good base classes is difficult, and lots of people get it wrong, and we could improve reason-ability for all parties involved if we just marked-up what is “open” and what isn’t.<br></p><p>That’s also why I think it should apply to internal subclasses as well. I’m not supporting this proposal for ideological reasons, but for practical ones. And in that sense, I’m -1 (or maybe -0.5) because I don’t think it goes far enough and leaves a feeling of inconsistency as a result.<br></p><p>Aggregation is not a problem because the aggregate type does not have an “is” relationship with its constituents.<br></p><p>&gt;&gt; The right to make the class final is reserved for the future.  Maybe<br>&gt;&gt; this is the “nice point of control” you refer to and don’t find<br>&gt;&gt; compelling?  I would prefer to have library authors acknowledge that<br>&gt;&gt; they intend to allow subclasses and make that commitment explicit.<br>&gt; <br>&gt; The question is, why?<br>&gt; <br>&gt;&gt; For me it isn’t about control as much as it is about making the API<br>&gt;&gt; contract explicit and acknowledged.  I have wondered about the intent<br>&gt;&gt; of library authors enough times to find this explicit statement in the<br>&gt;&gt; language worthwhile.<br>&gt; <br>&gt; Yeah, but we don&#39;t add language features to represent every possible<br>&gt; author intention, and there&#39;s a good argument that any intention that<br>&gt; can be violated without harm shouldn&#39;t be enforced.<br></p><p>It’s the “without harm” that’s debatable. It may not cause harm in a binary sense, but it may cause harm in another sense if you pass rogue objects around which look like my own objects but can define non-conforming behaviour. The only way I can prevent that right now is with “final”, but that prevents even myself from subclassing internally.<br></p><p>If we went with the first option (and assuming the library-internal optimisation potential in this situation is minor), we could have a flag which lets you override the checker and subclass non-open, non-final types in 3rd party libraries. We could continue to ensure that it is safe (from a binary perspective) to subclass and let you import libraries in an “unchecked” way similar to @testable.<br></p><p>So if I really, really need to subclass UINavigationController, and it isn’t ‘final’, I can still do it in a file which &quot;@unchecked imports UIKit” (or perhaps the attribute should be attached to the class declaration itself - e.g. “class FixedNavigationController : @unchecked UINavigationController” ).<br></p><p>While I am in favour of safe API access and reasonability, I’m not in favour of limiting flexibility where it isn’t absolutely necessary. 99% of library users will be safely living within the domains that I marked out as safe and tested, and those who need something customised can do so at their own risk.<br></p><p>&gt; <br>&gt;&gt; I also think language features enabled by knowing the whole class<br>&gt;&gt; hierarchy will provide more value than “compositional subclasses” as<br>&gt;&gt; long as we gain better support for composition elsewhere in the<br>&gt;&gt; language.<br>&gt; <br>&gt; I agree that there are better ways to solve the composition/API<br>&gt; forwarding problem.<br></p><p>+1<br></p><p>&gt; <br>&gt;&gt;&gt; The only reasons I can see for allowing people to prevent non-final<br>&gt;&gt;&gt; classes from being subclassed outside the module in which they are<br>&gt;&gt;&gt; defined are:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. It feels like a nice point of control to have.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Marginal performance gains as noted in the proposal<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I personally don&#39;t find these to be convincing.  #1 in particular seems<br>&gt;&gt;&gt; like a poor way to make language design decisions.  If we decide to add<br>&gt;&gt;&gt; this point of control, I&#39;ll justify it to myself in terms of #2.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; P.S., I can live with either alternative; it&#39;s just important to me that<br>&gt;&gt;&gt; we understand the situation clearly when evaluating them.<br>&gt;&gt; <br>&gt;&gt; I agree with this.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; HTH,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/ebc0cdf9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 22, 2016 at 01:00:00am</p></header><div class="content"><p>on Thu Jul 21 2016, Karl &lt;razielim-AT-gmail.com&gt; wrote:<br></p><p>&gt;&gt; On 21 Jul 2016, at 22:13, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Thu Jul 21 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Jul 21, 2016, at 12:47 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Thu Jul 21 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; +1 to the first design.  I think this is a great solution that<br>&gt;&gt;&gt;&gt;&gt; balances the many considerations that have been raised on all sides of<br>&gt;&gt;&gt;&gt;&gt; this issue.  `open` is 2 characters shorter than `public` so<br>&gt;&gt;&gt;&gt;&gt; complaints about boilerplate are no longer valid.  `internal` is the<br>&gt;&gt;&gt;&gt;&gt; “default” - neither `public` nor `open` are privileged as a “default”<br>&gt;&gt;&gt;&gt;&gt; for publishing API outside of a module.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I am interested in language enhancements such as exhaustive pattern<br>&gt;&gt;&gt;&gt;&gt; matching on classes and protocols which rely on knowledge of the full<br>&gt;&gt;&gt;&gt;&gt; class hierarchy.  Such enhancements will be far more useful if the<br>&gt;&gt;&gt;&gt;&gt; language supports non-open, non-final classes.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There are design techniques that would require additional boilerplate<br>&gt;&gt;&gt;&gt;&gt; if we cannot have non-open, non-final classes.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Most importantly, requiring library authors to choose `public` or<br>&gt;&gt;&gt;&gt;&gt; `open` provides important documentation value.  Users of the library<br>&gt;&gt;&gt;&gt;&gt; will know whether the author intends to support subclasses or not.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think this reasoning is flawed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you make any methods overridable outside your module (“open”),<br>&gt;&gt;&gt;&gt; obviously you mean to allow subclassing outside the module.  If you have<br>&gt;&gt;&gt;&gt; no open methods, there&#39;s absolutely nothing you need to do to “support<br>&gt;&gt;&gt;&gt; subclasses,” and from a design point-of-view, there&#39;s no reason to<br>&gt;&gt;&gt;&gt; restrict people from subclassing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I disagree.  As has been discussed when a class is not open the author<br>&gt;&gt;&gt; does not make a commitment to allow subclasses.  <br>&gt;&gt; <br>&gt;&gt; Yes, but that argument is based on the *assumption* that disallowing<br>&gt;&gt; subclassing is somehow an important dimension of safety or preserving<br>&gt;&gt; API contracts, independent of overriding.  It isn&#39;t.<br>                  ^^^^^^^^^^^^^^^^^^^^^^^^^<br>&gt;&gt; <br>&gt;&gt; Demonstration: we don&#39;t make that argument about aggregation: you can&#39;t<br>&gt;&gt; prevent someone from making your public struct a stored property in a<br>&gt;&gt; type defined outside the module.  Judgements about programming style<br>&gt;&gt; aside, in the absence of overriding, subclassing and aggregation are<br>&gt;&gt; identical from an encapsulation point-of-view.<br>&gt;&gt; <br>&gt;<br>&gt; IMO, the safety of API contracts is secondary. This is about safety of<br>&gt; implementation - my code is possibly not &quot;resilient&quot; enough (to to<br>&gt; speak) to handle overriding arbitrary public members. <br></p><p>I wrote that subclassability is not an important element of safety<br>**independent of overriding**.  If you don&#39;t allow any overriding,<br>your code is always “resilient” enough to handle subclassing.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4e98dd28e8af453c8c06c2536e913fc5?s=50"></div><header><strong>[swift-evolution-announce] [Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Wang LiMing</string> &lt;uomb at outlook.com&gt;<p>July 22, 2016 at 12:00:00pm</p></header><div class="content"><p>The problem is that: how to control/prevent the influence of customer’s code.<br></p><p>Question:<br>   How the customer’s code influence the library?<br></p><p>  For exam:<br>     func apiNNNN(v:SuperClass) { … }<br></p><p>     Customer call apiNNNN(v:aInstanceOfSubclass) { … }  /* some function of SuperClass be overrided */<br></p><p>  Is there any possibly for the following method:<br>    <br>     func apiNNNN(@denyOverridedSubclass v: SuperClass) { … }<br></p><p><br></p><p>&gt; 在 2016年7月22日，下午4:15，Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; 写道：<br>&gt; <br>&gt; <br>&gt; on Thu Jul 21 2016, Karl &lt;razielim-AT-gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On 21 Jul 2016, at 22:13, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Thu Jul 21 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 21, 2016, at 12:47 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Thu Jul 21 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; +1 to the first design.  I think this is a great solution that<br>&gt;&gt;&gt;&gt;&gt;&gt; balances the many considerations that have been raised on all sides of<br>&gt;&gt;&gt;&gt;&gt;&gt; this issue.  `open` is 2 characters shorter than `public` so<br>&gt;&gt;&gt;&gt;&gt;&gt; complaints about boilerplate are no longer valid.  `internal` is the<br>&gt;&gt;&gt;&gt;&gt;&gt; “default” - neither `public` nor `open` are privileged as a “default”<br>&gt;&gt;&gt;&gt;&gt;&gt; for publishing API outside of a module.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I am interested in language enhancements such as exhaustive pattern<br>&gt;&gt;&gt;&gt;&gt;&gt; matching on classes and protocols which rely on knowledge of the full<br>&gt;&gt;&gt;&gt;&gt;&gt; class hierarchy.  Such enhancements will be far more useful if the<br>&gt;&gt;&gt;&gt;&gt;&gt; language supports non-open, non-final classes.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There are design techniques that would require additional boilerplate<br>&gt;&gt;&gt;&gt;&gt;&gt; if we cannot have non-open, non-final classes.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Most importantly, requiring library authors to choose `public` or<br>&gt;&gt;&gt;&gt;&gt;&gt; `open` provides important documentation value.  Users of the library<br>&gt;&gt;&gt;&gt;&gt;&gt; will know whether the author intends to support subclasses or not.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think this reasoning is flawed.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If you make any methods overridable outside your module (“open”),<br>&gt;&gt;&gt;&gt;&gt; obviously you mean to allow subclassing outside the module.  If you have<br>&gt;&gt;&gt;&gt;&gt; no open methods, there&#39;s absolutely nothing you need to do to “support<br>&gt;&gt;&gt;&gt;&gt; subclasses,” and from a design point-of-view, there&#39;s no reason to<br>&gt;&gt;&gt;&gt;&gt; restrict people from subclassing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I disagree.  As has been discussed when a class is not open the author<br>&gt;&gt;&gt;&gt; does not make a commitment to allow subclasses.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, but that argument is based on the *assumption* that disallowing<br>&gt;&gt;&gt; subclassing is somehow an important dimension of safety or preserving<br>&gt;&gt;&gt; API contracts, independent of overriding.  It isn&#39;t.<br>&gt;                  ^^^^^^^^^^^^^^^^^^^^^^^^^<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Demonstration: we don&#39;t make that argument about aggregation: you can&#39;t<br>&gt;&gt;&gt; prevent someone from making your public struct a stored property in a<br>&gt;&gt;&gt; type defined outside the module.  Judgements about programming style<br>&gt;&gt;&gt; aside, in the absence of overriding, subclassing and aggregation are<br>&gt;&gt;&gt; identical from an encapsulation point-of-view.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; IMO, the safety of API contracts is secondary. This is about safety of<br>&gt;&gt; implementation - my code is possibly not &quot;resilient&quot; enough (to to<br>&gt;&gt; speak) to handle overriding arbitrary public members. <br>&gt; <br>&gt; I wrote that subclassability is not an important element of safety<br>&gt; **independent of overriding**.  If you don&#39;t allow any overriding,<br>&gt; your code is always “resilient” enough to handle subclassing.<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[swift-evolution-announce] [Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>July 22, 2016 at 04:00:00pm</p></header><div class="content"><p>On 22.07.2016 11:15, Dave Abrahams via swift-evolution wrote:<br>&gt;&gt;&gt;....skipped...<br>&gt;&gt;<br>&gt;&gt; IMO, the safety of API contracts is secondary. This is about safety of<br>&gt;&gt; implementation - my code is possibly not &quot;resilient&quot; enough (to to<br>&gt;&gt; speak) to handle overriding arbitrary public members.<br>&gt;<br>&gt; I wrote that subclassability is not an important element of safety<br>&gt; **independent of overriding**.  If you don&#39;t allow any overriding,<br>&gt; your code is always “resilient” enough to handle subclassing.<br>&gt;<br></p><p>I believe in this case the #2 approach, as formulated in proposal, just <br>can&#39;t work - base class of public class can have(and can add) `open` <br>methods/props, so for the author of such public class it is hard to know <br>what other methods (other than explicitly marked by him/her as `open`) <br>would be overridden.<br></p><p>So, seems like for #2 approach the proposal should be changed to not <br>implicitly open inherited `open` methords/props. Author of public class in <br>this case must explicitly mark as `open` each method/prop one wants to <br>export opened.<br></p><p>Then, in this case, we have a problem with *inherited* methods/props that <br>author *want* to open. In this case to remove boilerplate like &#39;public open <br>func f() { super.f()}&#39;, I don&#39;t see another way than adding new concept of <br>re-introducing of inherited method without its body :<br></p><p>public class B : A {<br>   public open *reintroduce* var property  // without type/details<br>   public open *reintroduce* func foo()  // without body<br></p><p>   public open override func bar()<br>   {<br>      //some code<br>      super.bar()<br>      //some code<br>   }<br></p><p>   public open func newFunc() {...}<br>   public func sealedFunc() {...}<br>}<br></p><p>(`reintroduce` as fast example of possible keyword for implementation of <br>such feature)<br></p><p>Am I missing something?<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[swift-evolution-announce] [Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>July 22, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 22, 2016, at 3:15 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I wrote that subclassability is not an important element of safety<br>&gt; **independent of overriding**.  If you don&#39;t allow any overriding,<br>&gt; your code is always “resilient” enough to handle subclassing.<br></p><p>Code can make assumptions about a type having a fixed set of subclasses known at compile time:<br></p><p>    switch foo {<br>        case is YinFoo:<br>            ...<br>        case is YangFoo:<br>            ...<br>        default:<br>            fatalError(&quot;only two kinds of Foo known&quot;)<br>    }<br></p><p>Granted, code like this is usually a sign of a flawed design. Reasonable uses for the “fixed, known set of subtypes” pattern are rare.<br></p><p>Design quality questions aside, however, it is not strictly true that preventing all member overrides guarantees that code is resilient to unexpected subclassing.<br></p><p>Cheers,<br></p><p>Paul<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/3f83f5ba/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
