<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] Terms of Art Swiftification</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 27, 2016 at 01:00:00pm</p></header><div class="content"><p>Under consideration is the resolution that  &quot;some terms of art while appropriate to many FP languages, may be better served by using Swift names.&quot;<br></p><p>Consider, for example, `filter(_:)`. Sean Heber writes,<br></p><p>&gt; Just tossing my vote in the hat for renaming .filter() to something like .select() since that better matches what it does, IMO. “Filter” is almost like the opposite word from what it should be since the closure returning true is what decides what is included in the results, not what is filtered *from* the results. I mean, yeah, I can kind of understand the logic either way, but it’s always been one of those strange mental gymnastics things.&quot;<br></p><p><br>When asked &quot;Shouldn&#39;t there be a term of art exemption for `filter(_:)`. Otherwise why not use `select(where:)`,&quot; Dave Abrahams replies:<br></p><p>&gt; Because `where(...)` is better.<br></p><p><br>Have at it.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/2a960e32/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Discussion] Terms of Art Swiftification</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June 27, 2016 at 03:00:00pm</p></header><div class="content"><p>Here’s a perhaps unlikely “what if” idea that is tangentially related to the problem that FP and mathematical names are sometimes weird in Swift and often don’t have a place to “live” that makes sense.<br></p><p>Let’s say we add an ability to declare a function on a struct/protocol/class/enum as a “functionalAlias” (for lack of a better name) which creates both a normal method, but also an effectively global function of the same (or an alternate given) name for use in functional scenarios.<br></p><p>Example:<br></p><p>struct Float {<br>  @functionalAlias(floor) func roundedDown() -&gt; Float { return … }<br>}<br></p><p>This would allow you to do this:<br></p><p>let value: Float = 42<br>let a = value.roundedDown()<br>let b = floor(value)<br></p><p>Essentially, the compiler generates something sort of like this for you:<br></p><p>extension Float {<br>  static func floor(_ v: Float) -&gt; Float { return v.roundedDown() }<br>}<br></p><p>When looking up a global function, the compiler would include these generated static functions as if they were top-level functions and proceed pretty much like normal. If there is any ambiguity, since the auto-generated function are effectively declared as a static inside of another type, you could always disambiguate with “Float.floor” if necessary.<br></p><p>Obviously this is just brainstorming/talking out loud. Maybe this is silly. Maybe it’s terrible. (Probably both.)<br></p><p>l8r<br>Sean<br></p><p><br></p><p>&gt; On Jun 27, 2016, at 2:31 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Under consideration is the resolution that  &quot;some terms of art while appropriate to many FP languages, may be better served by using Swift names.&quot;<br>&gt; <br>&gt; Consider, for example, `filter(_:)`. Sean Heber writes,<br>&gt; <br>&gt;&gt; Just tossing my vote in the hat for renaming .filter() to something like .select() since that better matches what it does, IMO. “Filter” is almost like the opposite word from what it should be since the closure returning true is what decides what is included in the results, not what is filtered *from* the results. I mean, yeah, I can kind of understand the logic either way, but it’s always been one of those strange mental gymnastics things.&quot;<br>&gt; <br>&gt; When asked &quot;Shouldn&#39;t there be a term of art exemption for `filter(_:)`. Otherwise why not use `select(where:)`,&quot; Dave Abrahams replies:<br>&gt; <br>&gt;&gt; Because `where(...)` is better.<br>&gt; <br>&gt; Have at it.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Discussion] Terms of Art Swiftification</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June 27, 2016 at 03:00:00pm</p></header><div class="content"><p>And along a similar line of thinking, what about a @termOfArt() attribute that similarly redefines or provides additional names for things. This way the name in the standard library/etc would be the “Swift” version of the name - but there’d be a way to use it and find it even if you’re familiar with other names for the same feature.<br></p><p>@termOfArt(filter) func where(…)<br></p><p>etc.<br></p><p>There could then be migration tools in Xcode (and others) which do things like transform all of your termsOfArt usages into the standard Swift nomenclature if you want to migrate/standardize.<br></p><p>Again, maybe this is silly. On the one hand, I’m not a fan of multiple names for the same things. On the other hand, sometimes the best name for a thing depends on context.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Jun 27, 2016, at 3:19 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; Here’s a perhaps unlikely “what if” idea that is tangentially related to the problem that FP and mathematical names are sometimes weird in Swift and often don’t have a place to “live” that makes sense.<br>&gt; <br>&gt; Let’s say we add an ability to declare a function on a struct/protocol/class/enum as a “functionalAlias” (for lack of a better name) which creates both a normal method, but also an effectively global function of the same (or an alternate given) name for use in functional scenarios.<br>&gt; <br>&gt; Example:<br>&gt; <br>&gt; struct Float {<br>&gt;  @functionalAlias(floor) func roundedDown() -&gt; Float { return … }<br>&gt; }<br>&gt; <br>&gt; This would allow you to do this:<br>&gt; <br>&gt; let value: Float = 42<br>&gt; let a = value.roundedDown()<br>&gt; let b = floor(value)<br>&gt; <br>&gt; Essentially, the compiler generates something sort of like this for you:<br>&gt; <br>&gt; extension Float {<br>&gt;  static func floor(_ v: Float) -&gt; Float { return v.roundedDown() }<br>&gt; }<br>&gt; <br>&gt; When looking up a global function, the compiler would include these generated static functions as if they were top-level functions and proceed pretty much like normal. If there is any ambiguity, since the auto-generated function are effectively declared as a static inside of another type, you could always disambiguate with “Float.floor” if necessary.<br>&gt; <br>&gt; Obviously this is just brainstorming/talking out loud. Maybe this is silly. Maybe it’s terrible. (Probably both.)<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 2:31 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Under consideration is the resolution that  &quot;some terms of art while appropriate to many FP languages, may be better served by using Swift names.&quot;<br>&gt;&gt; <br>&gt;&gt; Consider, for example, `filter(_:)`. Sean Heber writes,<br>&gt;&gt; <br>&gt;&gt;&gt; Just tossing my vote in the hat for renaming .filter() to something like .select() since that better matches what it does, IMO. “Filter” is almost like the opposite word from what it should be since the closure returning true is what decides what is included in the results, not what is filtered *from* the results. I mean, yeah, I can kind of understand the logic either way, but it’s always been one of those strange mental gymnastics things.&quot;<br>&gt;&gt; <br>&gt;&gt; When asked &quot;Shouldn&#39;t there be a term of art exemption for `filter(_:)`. Otherwise why not use `select(where:)`,&quot; Dave Abrahams replies:<br>&gt;&gt; <br>&gt;&gt;&gt; Because `where(...)` is better.<br>&gt;&gt; <br>&gt;&gt; Have at it.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d92e9730c561c120200f34e7e50ed46?s=50"></div><header><strong>[Discussion] Terms of Art Swiftification</strong> from <string>Jeff Kelley</string> &lt;slaunchaman at gmail.com&gt;<p>June 27, 2016 at 04:00:00pm</p></header><div class="content"><p>More generically, it could be something like @alias:<br></p><p>&gt; @alias(filter) func where(…)<br></p><p><br>This would allow this particular case to have another name, but also allow for things like alternate spellings.<br></p><p><br>Jeff Kelley<br></p><p>SlaunchaMan at gmail.com | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>&gt; On Jun 27, 2016, at 4:37 PM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; And along a similar line of thinking, what about a @termOfArt() attribute that similarly redefines or provides additional names for things. This way the name in the standard library/etc would be the “Swift” version of the name - but there’d be a way to use it and find it even if you’re familiar with other names for the same feature.<br>&gt; <br>&gt; @termOfArt(filter) func where(…)<br>&gt; <br>&gt; etc.<br>&gt; <br>&gt; There could then be migration tools in Xcode (and others) which do things like transform all of your termsOfArt usages into the standard Swift nomenclature if you want to migrate/standardize.<br>&gt; <br>&gt; Again, maybe this is silly. On the one hand, I’m not a fan of multiple names for the same things. On the other hand, sometimes the best name for a thing depends on context.<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 3:19 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Here’s a perhaps unlikely “what if” idea that is tangentially related to the problem that FP and mathematical names are sometimes weird in Swift and often don’t have a place to “live” that makes sense.<br>&gt;&gt; <br>&gt;&gt; Let’s say we add an ability to declare a function on a struct/protocol/class/enum as a “functionalAlias” (for lack of a better name) which creates both a normal method, but also an effectively global function of the same (or an alternate given) name for use in functional scenarios.<br>&gt;&gt; <br>&gt;&gt; Example:<br>&gt;&gt; <br>&gt;&gt; struct Float {<br>&gt;&gt; @functionalAlias(floor) func roundedDown() -&gt; Float { return … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This would allow you to do this:<br>&gt;&gt; <br>&gt;&gt; let value: Float = 42<br>&gt;&gt; let a = value.roundedDown()<br>&gt;&gt; let b = floor(value)<br>&gt;&gt; <br>&gt;&gt; Essentially, the compiler generates something sort of like this for you:<br>&gt;&gt; <br>&gt;&gt; extension Float {<br>&gt;&gt; static func floor(_ v: Float) -&gt; Float { return v.roundedDown() }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; When looking up a global function, the compiler would include these generated static functions as if they were top-level functions and proceed pretty much like normal. If there is any ambiguity, since the auto-generated function are effectively declared as a static inside of another type, you could always disambiguate with “Float.floor” if necessary.<br>&gt;&gt; <br>&gt;&gt; Obviously this is just brainstorming/talking out loud. Maybe this is silly. Maybe it’s terrible. (Probably both.)<br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 27, 2016, at 2:31 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Under consideration is the resolution that  &quot;some terms of art while appropriate to many FP languages, may be better served by using Swift names.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider, for example, `filter(_:)`. Sean Heber writes,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Just tossing my vote in the hat for renaming .filter() to something like .select() since that better matches what it does, IMO. “Filter” is almost like the opposite word from what it should be since the closure returning true is what decides what is included in the results, not what is filtered *from* the results. I mean, yeah, I can kind of understand the logic either way, but it’s always been one of those strange mental gymnastics things.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When asked &quot;Shouldn&#39;t there be a term of art exemption for `filter(_:)`. Otherwise why not use `select(where:)`,&quot; Dave Abrahams replies:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Because `where(...)` is better.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Have at it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/af43011f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Discussion] Terms of Art Swiftification</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June 27, 2016 at 03:00:00pm</p></header><div class="content"><p>I considered suggesting that at first - and maybe that’d be easier/better - but I liked the idea of preserving the *intent* of the alias in different scenerios. Not sure. That could be hammered out assuming people thought this was a good direction to even consider vs. just picking a single name for things and having that be that. :)<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Jun 27, 2016, at 3:44 PM, Jeff Kelley &lt;slaunchaman at gmail.com&gt; wrote:<br>&gt; <br>&gt; More generically, it could be something like @alias:<br>&gt; <br>&gt;&gt; @alias(filter) func where(…)<br>&gt; <br>&gt; This would allow this particular case to have another name, but also allow for things like alternate spellings.<br>&gt; <br>&gt; <br>&gt; Jeff Kelley<br>&gt; <br>&gt; SlaunchaMan at gmail.com | @SlaunchaMan | jeffkelley.org<br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 4:37 PM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; And along a similar line of thinking, what about a @termOfArt() attribute that similarly redefines or provides additional names for things. This way the name in the standard library/etc would be the “Swift” version of the name - but there’d be a way to use it and find it even if you’re familiar with other names for the same feature.<br>&gt;&gt; <br>&gt;&gt; @termOfArt(filter) func where(…)<br>&gt;&gt; <br>&gt;&gt; etc.<br>&gt;&gt; <br>&gt;&gt; There could then be migration tools in Xcode (and others) which do things like transform all of your termsOfArt usages into the standard Swift nomenclature if you want to migrate/standardize.<br>&gt;&gt; <br>&gt;&gt; Again, maybe this is silly. On the one hand, I’m not a fan of multiple names for the same things. On the other hand, sometimes the best name for a thing depends on context.<br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 27, 2016, at 3:19 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here’s a perhaps unlikely “what if” idea that is tangentially related to the problem that FP and mathematical names are sometimes weird in Swift and often don’t have a place to “live” that makes sense.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let’s say we add an ability to declare a function on a struct/protocol/class/enum as a “functionalAlias” (for lack of a better name) which creates both a normal method, but also an effectively global function of the same (or an alternate given) name for use in functional scenarios.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Float {<br>&gt;&gt;&gt; @functionalAlias(floor) func roundedDown() -&gt; Float { return … }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would allow you to do this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let value: Float = 42<br>&gt;&gt;&gt; let a = value.roundedDown()<br>&gt;&gt;&gt; let b = floor(value)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Essentially, the compiler generates something sort of like this for you:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Float {<br>&gt;&gt;&gt; static func floor(_ v: Float) -&gt; Float { return v.roundedDown() }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When looking up a global function, the compiler would include these generated static functions as if they were top-level functions and proceed pretty much like normal. If there is any ambiguity, since the auto-generated function are effectively declared as a static inside of another type, you could always disambiguate with “Float.floor” if necessary.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Obviously this is just brainstorming/talking out loud. Maybe this is silly. Maybe it’s terrible. (Probably both.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; l8r<br>&gt;&gt;&gt; Sean<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 27, 2016, at 2:31 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Under consideration is the resolution that  &quot;some terms of art while appropriate to many FP languages, may be better served by using Swift names.&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Consider, for example, `filter(_:)`. Sean Heber writes,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Just tossing my vote in the hat for renaming .filter() to something like .select() since that better matches what it does, IMO. “Filter” is almost like the opposite word from what it should be since the closure returning true is what decides what is included in the results, not what is filtered *from* the results. I mean, yeah, I can kind of understand the logic either way, but it’s always been one of those strange mental gymnastics things.&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When asked &quot;Shouldn&#39;t there be a term of art exemption for `filter(_:)`. Otherwise why not use `select(where:)`,&quot; Dave Abrahams replies:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Because `where(...)` is better.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Have at it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Discussion] Terms of Art Swiftification</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>June 27, 2016 at 07:00:00pm</p></header><div class="content"><p>I would support a rename of filter to the right name. This is a little silly but wouldn&#39;t select(…) become selecting(…) with the naming rules? I think where(…) would only make sense if it was lazy by default. <br>There probably needs to be a whole survey of names (seems kinda late for swift 3). <br>I would be afraid of a function type alias fractioning the language. Naming is hard. <br></p><p>&gt; On Jun 27, 2016, at 1:19 PM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Here’s a perhaps unlikely “what if” idea that is tangentially related to the problem that FP and mathematical names are sometimes weird in Swift and often don’t have a place to “live” that makes sense.<br>&gt; <br>&gt; Let’s say we add an ability to declare a function on a struct/protocol/class/enum as a “functionalAlias” (for lack of a better name) which creates both a normal method, but also an effectively global function of the same (or an alternate given) name for use in functional scenarios.<br>&gt; <br>&gt; Example:<br>&gt; <br>&gt; struct Float {<br>&gt;  @functionalAlias(floor) func roundedDown() -&gt; Float { return … }<br>&gt; }<br>&gt; <br>&gt; This would allow you to do this:<br>&gt; <br>&gt; let value: Float = 42<br>&gt; let a = value.roundedDown()<br>&gt; let b = floor(value)<br>&gt; <br>&gt; Essentially, the compiler generates something sort of like this for you:<br>&gt; <br>&gt; extension Float {<br>&gt;  static func floor(_ v: Float) -&gt; Float { return v.roundedDown() }<br>&gt; }<br>&gt; <br>&gt; When looking up a global function, the compiler would include these generated static functions as if they were top-level functions and proceed pretty much like normal. If there is any ambiguity, since the auto-generated function are effectively declared as a static inside of another type, you could always disambiguate with “Float.floor” if necessary.<br>&gt; <br>&gt; Obviously this is just brainstorming/talking out loud. Maybe this is silly. Maybe it’s terrible. (Probably both.)<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 2:31 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Under consideration is the resolution that  &quot;some terms of art while appropriate to many FP languages, may be better served by using Swift names.&quot;<br>&gt;&gt; <br>&gt;&gt; Consider, for example, `filter(_:)`. Sean Heber writes,<br>&gt;&gt; <br>&gt;&gt;&gt; Just tossing my vote in the hat for renaming .filter() to something like .select() since that better matches what it does, IMO. “Filter” is almost like the opposite word from what it should be since the closure returning true is what decides what is included in the results, not what is filtered *from* the results. I mean, yeah, I can kind of understand the logic either way, but it’s always been one of those strange mental gymnastics things.&quot;<br>&gt;&gt; <br>&gt;&gt; When asked &quot;Shouldn&#39;t there be a term of art exemption for `filter(_:)`. Otherwise why not use `select(where:)`,&quot; Dave Abrahams replies:<br>&gt;&gt; <br>&gt;&gt;&gt; Because `where(...)` is better.<br>&gt;&gt; <br>&gt;&gt; Have at it.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Discussion] Terms of Art Swiftification</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>June 28, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 27 Jun 2016, at 22:19, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Here’s a perhaps unlikely “what if” idea that is tangentially related to the problem that FP and mathematical names are sometimes weird in Swift and often don’t have a place to “live” that makes sense.<br>&gt; <br>&gt; Let’s say we add an ability to declare a function on a struct/protocol/class/enum as a “functionalAlias” (for lack of a better name) which creates both a normal method, but also an effectively global function of the same (or an alternate given) name for use in functional scenarios.<br>&gt; <br>&gt; Example:<br>&gt; <br>&gt; struct Float {<br>&gt;  @functionalAlias(floor) func roundedDown() -&gt; Float { return … }<br>&gt; }<br>&gt; <br>&gt; This would allow you to do this:<br>&gt; <br>&gt; let value: Float = 42<br>&gt; let a = value.roundedDown()<br>&gt; let b = floor(value)<br>&gt; <br>&gt; Essentially, the compiler generates something sort of like this for you:<br>&gt; <br>&gt; extension Float {<br>&gt;  static func floor(_ v: Float) -&gt; Float { return v.roundedDown() }<br>&gt; }<br>&gt; <br>&gt; When looking up a global function, the compiler would include these generated static functions as if they were top-level functions and proceed pretty much like normal. If there is any ambiguity, since the auto-generated function are effectively declared as a static inside of another type, you could always disambiguate with “Float.floor” if necessary.<br>&gt; <br>&gt; Obviously this is just brainstorming/talking out loud. Maybe this is silly. Maybe it’s terrible. (Probably both.)<br>&gt; <br>&gt; L8r<br>&gt; Sean<br>&gt; <br></p><p>This is kind of the reverse of how operators work, isn’t it? (Or used to work, I don’t know if they’ve changed since the last time I looked)<br></p><p>We’re definitely having lots of discussions about how the ‘swifty’ way to structure the stdlib would seem a bit alien to people from other languages. C developers wouldn’t discover `(4.4).floor()` or `(4.4).roundedDown()` because their primitive value types don’t have instance methods. At the same time, we seem to have resolved against global functions.<br></p><p>Is better documentation maybe the answer? Perhaps these could be examples in the Swift programming guide. When it comes to functions like `filter`, perhaps a glossary? The standard library is intentionally kept small, so it could be manageable to just keep a mapping of commonly-confused functions.<br></p><p>Ultimately, people are going to a) check code completion, and failing that b) google it. For things like ‘filter’, it’s a one-off friction of a handful of seconds. Maybe we should just be more ruthless; maybe we can afford to be these days.<br></p><p>Karl<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Discussion] Terms of Art Swiftification</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>June 28, 2016 at 12:00:00pm</p></header><div class="content"><p>I liked Brent Royal-Gordon’s suggestion of `every(where:)`. Select is too abstract and SQLish, whereas ‘every’ is a basic english word that would look familiar in a Swift Playground.<br></p><p>Or `where(_:)` I could live with.<br></p><p>Patrick<br></p><p>&gt; On 28 Jun 2016, at 5:31 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Under consideration is the resolution that  &quot;some terms of art while appropriate to many FP languages, may be better served by using Swift names.&quot;<br>&gt; <br>&gt; Consider, for example, `filter(_:)`. Sean Heber writes,<br>&gt; <br>&gt;&gt; Just tossing my vote in the hat for renaming .filter() to something like .select() since that better matches what it does, IMO. “Filter” is almost like the opposite word from what it should be since the closure returning true is what decides what is included in the results, not what is filtered *from* the results. I mean, yeah, I can kind of understand the logic either way, but it’s always been one of those strange mental gymnastics things.&quot;<br>&gt; <br>&gt; <br>&gt; When asked &quot;Shouldn&#39;t there be a term of art exemption for `filter(_:)`. Otherwise why not use `select(where:)`,&quot; Dave Abrahams replies:<br>&gt; <br>&gt;&gt; Because `where(...)` is better.<br>&gt; <br>&gt; <br>&gt; Have at it.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/6804307f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Discussion] Terms of Art Swiftification</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 28, 2016 at 07:00:00am</p></header><div class="content"><p>Erica had a nice list of various term-of-art usages among languages - it included filter, map, etc. - I just can&#39;t seem to find it anywhere. This nicely showed that there is only a few languages that name things differently, mostly C# and C++.<br></p><p>&quot;filter&quot; is nowadays quite a universal word that is in many languages - and I&#39;m talking both about programming and a natural language. And I don&#39;t think that it goes against what one might be expecting - when you open a filter in the UI, you don&#39;t tick things that you don&#39;t want to see, but items that you *do* want to see.<br></p><p>I don&#39;t think that changing those names will add any additional value to the Swift language. I&#39;ve personally had more issues with the naming of flatMap - it could have been called filterMap to stay in line of filtering by returning nil (flattening an array is in my head associated with flattening of an array of arrays). But it&#39;s a term of art and I got my head around it. <br></p><p>&gt; On Jun 27, 2016, at 9:31 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Under consideration is the resolution that  &quot;some terms of art while appropriate to many FP languages, may be better served by using Swift names.&quot;<br>&gt; <br>&gt; Consider, for example, `filter(_:)`. Sean Heber writes,<br>&gt; <br>&gt;&gt; Just tossing my vote in the hat for renaming .filter() to something like .select() since that better matches what it does, IMO. “Filter” is almost like the opposite word from what it should be since the closure returning true is what decides what is included in the results, not what is filtered *from* the results. I mean, yeah, I can kind of understand the logic either way, but it’s always been one of those strange mental gymnastics things.&quot;<br>&gt; <br>&gt; <br>&gt; When asked &quot;Shouldn&#39;t there be a term of art exemption for `filter(_:)`. Otherwise why not use `select(where:)`,&quot; Dave Abrahams replies:<br>&gt; <br>&gt;&gt; Because `where(...)` is better.<br>&gt; <br>&gt; <br>&gt; Have at it.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/0de3179c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15ed660cd9d971062f9dd5084932a698?s=50"></div><header><strong>[Discussion] Terms of Art Swiftification</strong> from <string>David Rönnqvist</string> &lt;david.ronnqvist at gmail.com&gt;<p>June 28, 2016 at 09:00:00am</p></header><div class="content"><p>Is this (below) the list you were referring to? (copied from: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160613/021301.html )<br></p><p>- David <br></p><p>——————————————————————————————<br></p><p>`map`, `filter`, and `reduce` are *the* higher-order functions. Almost anything with any kind of block/lambda/closure feature supports them (I&#39;m giving the side-eye to Foundation here), and all three names are backed by *very* strong conventions:<br></p><p>* `map` is by far the strongest. It is universally supported among languages with higher-order collection operations, and is almost always called `map`. In Wikipedia&#39;s list of 32 languages with a `map` &lt;https://en.wikipedia.org/wiki/Map_(higher-order_function)#Language_comparison &lt;https://en.wikipedia.org/wiki/Map_(higher-order_function)#Language_comparison&gt;&gt;, we find (grouping together similar names like `map` and `maplist`, and double-counting languages with several aliases):<br></p><p>	Map: 19<br>	Collect: 3<br>	Apply: 3<br>	Special syntax: 2<br>	Select: 1 (C#, which uses it in the SQL-inspired LINQ)<br>	Transform: 1 (C++, which uses a bizarre signature involving an out parameter)<br>	ForEach: 1 (XPath)<br></p><p>* `filter` is supported nearly as widely as `map`, and the name `filter` is used nearly as consistently as `map`. Wikipedia lists 27 languages supporting a `filter`-style function, and `filter` is by far the most common choice, arguably favored even more consistently than `map` &lt;https://en.wikipedia.org/wiki/Filter_(higher-order_function) &lt;https://en.wikipedia.org/wiki/Filter_(higher-order_function)&gt;&gt;:<br></p><p>	Filter: 17<br>	Select: 4<br>	Special syntax: 3<br>	FilteredArrayUsingPredicate: 1 (Foundation, doesn&#39;t actually take a closure)<br>	Where: 1 (C#, in LINQ)<br>	CopyIf: 1 (C++, bizarre signature)<br>	FindAll: 1<br>	Grep: 1<br>	RemoveIfNot: 1<br></p><p>* `reduce` is extremely popular among functional languages because it&#39;s a primitive list-handling operation, although it&#39;s a little less common among mainstream languages than the other two. It *does* actually have an alternate name, `fold`, which is nearly as common as `reduce`. However, languages using `fold` are usually those which support both leftward- and rightward-reducing versions of the operation, whereas languages using `reduce` usually don&#39;t. Swift falls into the second camp. From Wikipedia&#39;s 39-language list &lt;https://en.wikipedia.org/wiki/Fold_(higher-order_function) &lt;https://en.wikipedia.org/wiki/Fold_(higher-order_function)&gt;&gt;:<br></p><p>	Reduce: 20	(with both left and right: 4)<br>	Fold: 18	(with both left and right: 12)<br>	Inject: 3<br>	Special syntax: 3<br>	Aggregate: 1 (C#, in LINQ)<br>	Accumulate: 1 (C++, bizarre signature)<br>	Partition: 1<br>	ToIterator: 1<br></p><p><br>&gt; On 28 Jun 2016, at 07:31, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Erica had a nice list of various term-of-art usages among languages - it included filter, map, etc. - I just can&#39;t seem to find it anywhere. This nicely showed that there is only a few languages that name things differently, mostly C# and C++.<br>&gt; <br>&gt; &quot;filter&quot; is nowadays quite a universal word that is in many languages - and I&#39;m talking both about programming and a natural language. And I don&#39;t think that it goes against what one might be expecting - when you open a filter in the UI, you don&#39;t tick things that you don&#39;t want to see, but items that you *do* want to see.<br>&gt; <br>&gt; I don&#39;t think that changing those names will add any additional value to the Swift language. I&#39;ve personally had more issues with the naming of flatMap - it could have been called filterMap to stay in line of filtering by returning nil (flattening an array is in my head associated with flattening of an array of arrays). But it&#39;s a term of art and I got my head around it. <br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 9:31 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Under consideration is the resolution that  &quot;some terms of art while appropriate to many FP languages, may be better served by using Swift names.&quot;<br>&gt;&gt; <br>&gt;&gt; Consider, for example, `filter(_:)`. Sean Heber writes,<br>&gt;&gt; <br>&gt;&gt;&gt; Just tossing my vote in the hat for renaming .filter() to something like .select() since that better matches what it does, IMO. “Filter” is almost like the opposite word from what it should be since the closure returning true is what decides what is included in the results, not what is filtered *from* the results. I mean, yeah, I can kind of understand the logic either way, but it’s always been one of those strange mental gymnastics things.&quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; When asked &quot;Shouldn&#39;t there be a term of art exemption for `filter(_:)`. Otherwise why not use `select(where:)`,&quot; Dave Abrahams replies:<br>&gt;&gt; <br>&gt;&gt;&gt; Because `where(...)` is better.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Have at it.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/191c23d0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Discussion] Terms of Art Swiftification</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 28, 2016 at 09:00:00am</p></header><div class="content"><p>Yes. Sorry, it was composed by Brent - not sure why I thought it was Erica - that is why I couldn&#39;t find it. Thanks!<br></p><p>&gt; On Jun 28, 2016, at 9:11 AM, David Rönnqvist &lt;david.ronnqvist at gmail.com&gt; wrote:<br>&gt; <br>&gt; Is this (below) the list you were referring to? (copied from: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160613/021301.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160613/021301.html&gt; )<br>&gt; <br>&gt; - David <br>&gt; <br>&gt; ——————————————————————————————<br>&gt; <br>&gt; `map`, `filter`, and `reduce` are *the* higher-order functions. Almost anything with any kind of block/lambda/closure feature supports them (I&#39;m giving the side-eye to Foundation here), and all three names are backed by *very* strong conventions:<br>&gt; <br>&gt; * `map` is by far the strongest. It is universally supported among languages with higher-order collection operations, and is almost always called `map`. In Wikipedia&#39;s list of 32 languages with a `map` &lt;https://en.wikipedia.org/wiki/Map_(higher-order_function)#Language_comparison &lt;https://en.wikipedia.org/wiki/Map_(higher-order_function)#Language_comparison&gt;&gt;, we find (grouping together similar names like `map` and `maplist`, and double-counting languages with several aliases):<br>&gt; <br>&gt; 	Map: 19<br>&gt; 	Collect: 3<br>&gt; 	Apply: 3<br>&gt; 	Special syntax: 2<br>&gt; 	Select: 1 (C#, which uses it in the SQL-inspired LINQ)<br>&gt; 	Transform: 1 (C++, which uses a bizarre signature involving an out parameter)<br>&gt; 	ForEach: 1 (XPath)<br>&gt; <br>&gt; * `filter` is supported nearly as widely as `map`, and the name `filter` is used nearly as consistently as `map`. Wikipedia lists 27 languages supporting a `filter`-style function, and `filter` is by far the most common choice, arguably favored even more consistently than `map` &lt;https://en.wikipedia.org/wiki/Filter_(higher-order_function) &lt;https://en.wikipedia.org/wiki/Filter_(higher-order_function)&gt;&gt;:<br>&gt; <br>&gt; 	Filter: 17<br>&gt; 	Select: 4<br>&gt; 	Special syntax: 3<br>&gt; 	FilteredArrayUsingPredicate: 1 (Foundation, doesn&#39;t actually take a closure)<br>&gt; 	Where: 1 (C#, in LINQ)<br>&gt; 	CopyIf: 1 (C++, bizarre signature)<br>&gt; 	FindAll: 1<br>&gt; 	Grep: 1<br>&gt; 	RemoveIfNot: 1<br>&gt; <br>&gt; * `reduce` is extremely popular among functional languages because it&#39;s a primitive list-handling operation, although it&#39;s a little less common among mainstream languages than the other two. It *does* actually have an alternate name, `fold`, which is nearly as common as `reduce`. However, languages using `fold` are usually those which support both leftward- and rightward-reducing versions of the operation, whereas languages using `reduce` usually don&#39;t. Swift falls into the second camp. From Wikipedia&#39;s 39-language list &lt;https://en.wikipedia.org/wiki/Fold_(higher-order_function) &lt;https://en.wikipedia.org/wiki/Fold_(higher-order_function)&gt;&gt;:<br>&gt; <br>&gt; 	Reduce: 20	(with both left and right: 4)<br>&gt; 	Fold: 18	(with both left and right: 12)<br>&gt; 	Inject: 3<br>&gt; 	Special syntax: 3<br>&gt; 	Aggregate: 1 (C#, in LINQ)<br>&gt; 	Accumulate: 1 (C++, bizarre signature)<br>&gt; 	Partition: 1<br>&gt; 	ToIterator: 1<br>&gt; <br>&gt; <br>&gt;&gt; On 28 Jun 2016, at 07:31, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Erica had a nice list of various term-of-art usages among languages - it included filter, map, etc. - I just can&#39;t seem to find it anywhere. This nicely showed that there is only a few languages that name things differently, mostly C# and C++.<br>&gt;&gt; <br>&gt;&gt; &quot;filter&quot; is nowadays quite a universal word that is in many languages - and I&#39;m talking both about programming and a natural language. And I don&#39;t think that it goes against what one might be expecting - when you open a filter in the UI, you don&#39;t tick things that you don&#39;t want to see, but items that you *do* want to see.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think that changing those names will add any additional value to the Swift language. I&#39;ve personally had more issues with the naming of flatMap - it could have been called filterMap to stay in line of filtering by returning nil (flattening an array is in my head associated with flattening of an array of arrays). But it&#39;s a term of art and I got my head around it. <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 27, 2016, at 9:31 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Under consideration is the resolution that  &quot;some terms of art while appropriate to many FP languages, may be better served by using Swift names.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider, for example, `filter(_:)`. Sean Heber writes,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Just tossing my vote in the hat for renaming .filter() to something like .select() since that better matches what it does, IMO. “Filter” is almost like the opposite word from what it should be since the closure returning true is what decides what is included in the results, not what is filtered *from* the results. I mean, yeah, I can kind of understand the logic either way, but it’s always been one of those strange mental gymnastics things.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When asked &quot;Shouldn&#39;t there be a term of art exemption for `filter(_:)`. Otherwise why not use `select(where:)`,&quot; Dave Abrahams replies:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Because `where(...)` is better.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Have at it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/f9fb3244/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Discussion] Terms of Art Swiftification</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June 28, 2016 at 08:00:00am</p></header><div class="content"><p>The trouble with this line of reasoning, IMO, is that it is what led to the floppy disk becoming the “universal” save icon for years and years. Apple has spent considerable effort in macOS and iOS trying to show that you don’t really need a save button at all most of the time - it turns out that auto-save by default is what people expect. Flip the logic on it’s head!<br></p><p>I fear that by adhering strongly to terms of art, we could be looking at a floppy-save-icon scenario over time. What if there are simply better ways of doing these things? What if the names themselves are blinding us to other alternatives?<br></p><p>One of the purposes of my thought of having aliases for functions/methods is that it would give us an obvious primary location for a function - inside of the correct type or protocol - that feels Swifty. It would allow us to use “proper” Swift names that read fluently according to the guidelines even if they are perhaps more verbose or nontraditional or even unusual. Then by mapping those names to the existing common names, we can bring people along without too much initial pain while still allowing exploration of a new way to express things.<br></p><p>Swift already has a rather unusual rule in that statements are meant to read like english phrases. It is meant to have a kind of human language flow when read because code is read more than it is written. Virtually all existing terms of art were NOT created with that kind of consideration. How can Swift come into its own if it isn’t allowed to have its own names for things that work with its own rules? I mean, sure, not *every* name needs to change and not every word needs to change, but it feels to me like we’re just coming up with our own dialect of a “standard” language that’s no different than American english vs. British english when what I think we should be exploring is more along the lines of the differences between english vs. greek.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Jun 28, 2016, at 12:31 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Erica had a nice list of various term-of-art usages among languages - it included filter, map, etc. - I just can&#39;t seem to find it anywhere. This nicely showed that there is only a few languages that name things differently, mostly C# and C++.<br>&gt; <br>&gt; &quot;filter&quot; is nowadays quite a universal word that is in many languages - and I&#39;m talking both about programming and a natural language. And I don&#39;t think that it goes against what one might be expecting - when you open a filter in the UI, you don&#39;t tick things that you don&#39;t want to see, but items that you *do* want to see.<br>&gt; <br>&gt; I don&#39;t think that changing those names will add any additional value to the Swift language. I&#39;ve personally had more issues with the naming of flatMap - it could have been called filterMap to stay in line of filtering by returning nil (flattening an array is in my head associated with flattening of an array of arrays). But it&#39;s a term of art and I got my head around it. <br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 9:31 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Under consideration is the resolution that  &quot;some terms of art while appropriate to many FP languages, may be better served by using Swift names.&quot;<br>&gt;&gt; <br>&gt;&gt; Consider, for example, `filter(_:)`. Sean Heber writes,<br>&gt;&gt; <br>&gt;&gt;&gt; Just tossing my vote in the hat for renaming .filter() to something like .select() since that better matches what it does, IMO. “Filter” is almost like the opposite word from what it should be since the closure returning true is what decides what is included in the results, not what is filtered *from* the results. I mean, yeah, I can kind of understand the logic either way, but it’s always been one of those strange mental gymnastics things.&quot;<br>&gt;&gt; <br>&gt;&gt; When asked &quot;Shouldn&#39;t there be a term of art exemption for `filter(_:)`. Otherwise why not use `select(where:)`,&quot; Dave Abrahams replies:<br>&gt;&gt; <br>&gt;&gt;&gt; Because `where(...)` is better.<br>&gt;&gt; <br>&gt;&gt; Have at it.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Discussion] Terms of Art Swiftification</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>June 28, 2016 at 04:00:00pm</p></header><div class="content"><p>I also feel that Swift should be held &quot;hostage&quot; to a term of art especially<br>if the term is fairly badly named and/or unswifty. I feel the term of art<br>can incorporated in the API docs and possibly expressed by the alias<br>concept that has been discussed.<br></p><p>I strongly encourage going with a swiftly name for things first and only<br>then back peddling after considering the range of terms of art seen in<br>other languages.<br></p><p>-Shawn<br>On Tue, Jun 28, 2016 at 6:38 AM Sean Heber via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The trouble with this line of reasoning, IMO, is that it is what led to<br>&gt; the floppy disk becoming the “universal” save icon for years and years.<br>&gt; Apple has spent considerable effort in macOS and iOS trying to show that<br>&gt; you don’t really need a save button at all most of the time - it turns out<br>&gt; that auto-save by default is what people expect. Flip the logic on it’s<br>&gt; head!<br>&gt;<br>&gt; I fear that by adhering strongly to terms of art, we could be looking at a<br>&gt; floppy-save-icon scenario over time. What if there are simply better ways<br>&gt; of doing these things? What if the names themselves are blinding us to<br>&gt; other alternatives?<br>&gt;<br>&gt; One of the purposes of my thought of having aliases for functions/methods<br>&gt; is that it would give us an obvious primary location for a function -<br>&gt; inside of the correct type or protocol - that feels Swifty. It would allow<br>&gt; us to use “proper” Swift names that read fluently according to the<br>&gt; guidelines even if they are perhaps more verbose or nontraditional or even<br>&gt; unusual. Then by mapping those names to the existing common names, we can<br>&gt; bring people along without too much initial pain while still allowing<br>&gt; exploration of a new way to express things.<br>&gt;<br>&gt; Swift already has a rather unusual rule in that statements are meant to<br>&gt; read like english phrases. It is meant to have a kind of human language<br>&gt; flow when read because code is read more than it is written. Virtually all<br>&gt; existing terms of art were NOT created with that kind of consideration. How<br>&gt; can Swift come into its own if it isn’t allowed to have its own names for<br>&gt; things that work with its own rules? I mean, sure, not *every* name needs<br>&gt; to change and not every word needs to change, but it feels to me like we’re<br>&gt; just coming up with our own dialect of a “standard” language that’s no<br>&gt; different than American english vs. British english when what I think we<br>&gt; should be exploring is more along the lines of the differences between<br>&gt; english vs. greek.<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt;<br>&gt; &gt; On Jun 28, 2016, at 12:31 AM, Charlie Monroe via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Erica had a nice list of various term-of-art usages among languages - it<br>&gt; included filter, map, etc. - I just can&#39;t seem to find it anywhere. This<br>&gt; nicely showed that there is only a few languages that name things<br>&gt; differently, mostly C# and C++.<br>&gt; &gt;<br>&gt; &gt; &quot;filter&quot; is nowadays quite a universal word that is in many languages -<br>&gt; and I&#39;m talking both about programming and a natural language. And I don&#39;t<br>&gt; think that it goes against what one might be expecting - when you open a<br>&gt; filter in the UI, you don&#39;t tick things that you don&#39;t want to see, but<br>&gt; items that you *do* want to see.<br>&gt; &gt;<br>&gt; &gt; I don&#39;t think that changing those names will add any additional value to<br>&gt; the Swift language. I&#39;ve personally had more issues with the naming of<br>&gt; flatMap - it could have been called filterMap to stay in line of filtering<br>&gt; by returning nil (flattening an array is in my head associated with<br>&gt; flattening of an array of arrays). But it&#39;s a term of art and I got my head<br>&gt; around it.<br>&gt; &gt;<br>&gt; &gt;&gt; On Jun 27, 2016, at 9:31 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Under consideration is the resolution that  &quot;some terms of art while<br>&gt; appropriate to many FP languages, may be better served by using Swift<br>&gt; names.&quot;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Consider, for example, `filter(_:)`. Sean Heber writes,<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Just tossing my vote in the hat for renaming .filter() to something<br>&gt; like .select() since that better matches what it does, IMO. “Filter” is<br>&gt; almost like the opposite word from what it should be since the closure<br>&gt; returning true is what decides what is included in the results, not what is<br>&gt; filtered *from* the results. I mean, yeah, I can kind of understand the<br>&gt; logic either way, but it’s always been one of those strange mental<br>&gt; gymnastics things.&quot;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; When asked &quot;Shouldn&#39;t there be a term of art exemption for<br>&gt; `filter(_:)`. Otherwise why not use `select(where:)`,&quot; Dave Abrahams<br>&gt; replies:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Because `where(...)` is better.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Have at it.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -- E<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/20da01fe/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
