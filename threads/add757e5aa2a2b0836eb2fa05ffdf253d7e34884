<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March  3, 2016 at 04:00:00pm</p></header><div class="content"><p>on Wed Mar 02 2016, David Smith &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The choice of Equatable as an example for opening existentials is an<br>&gt; interesting one here, because it&#39;s one of the few cases I can think of<br>&gt; where differing dynamic types is actually fully defined: they&#39;re not<br>&gt; equal. In ObjC we express that by starting every -isEqual:<br>&gt; implementation with if (![other isKindOfClass:[self class]]) { return<br>&gt; NO; }, which while clunky and easy to forget, does neatly express the<br>&gt; desired semantics with no burden at the callsite.<br></p><p>It&#39;s a reasonable default, but it&#39;s not necessarily the right<br>implementation for every type.  One could imagine Polygons comparing<br>equal to Squares, for example.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  3, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt;&gt; The choice of Equatable as an example for opening existentials is an<br>&gt;&gt; interesting one here, because it&#39;s one of the few cases I can think of<br>&gt;&gt; where differing dynamic types is actually fully defined: they&#39;re not<br>&gt;&gt; equal. In ObjC we express that by starting every -isEqual:<br>&gt;&gt; implementation with if (![other isKindOfClass:[self class]]) { return<br>&gt;&gt; NO; }, which while clunky and easy to forget, does neatly express the<br>&gt;&gt; desired semantics with no burden at the callsite.<br>&gt; <br>&gt; It&#39;s a reasonable default, but it&#39;s not necessarily the right<br>&gt; implementation for every type.  One could imagine Polygons comparing<br>&gt; equal to Squares, for example.<br></p><p>If the &quot;open&quot; operation is sophisticated enough, when it&#39;s faced with mismatched concrete types but they both conform to a protocol with a existential that meets the requirements, it could return that existential.<br></p><p>That would mean that, in this scenario:<br></p><p>	protocol Shape: Equatable { ...}<br>	<br>	protocol Polygonal: Shape {<br>		var vertices: [Vertex]<br>	}<br>	struct Square: Polygonal { ... }<br>	struct Polygon: Polygonal { ... }<br></p><p>You could add this:<br></p><p>	extension Any&lt;Polygonal&gt;: Equatable {}<br>	<br>	func == (lhs: Any&lt;Polygonal&gt;, rhs: Any&lt;Polygonal&gt;) -&gt; Bool {<br>		for (lhsVertex, rhsVertex) in zip(lhs.vertices, rhs.vertices) {<br>			if lhsVertex != rhsVertex {<br>				return false<br>			}<br>		}<br>		return true<br>	}<br></p><p>And then, if `==(_: Any&lt;Equatable&gt;, _: Any&lt;Equatable&gt;)` were passed a Square and a Polygon, opening the `Any&lt;Equatable&gt;`s would give you a pair of `Any&lt;Polygonal&gt;`s.<br></p><p>This is obviously more complex than simply opening the existential, matching its concrete type against a requirement, and extracting the original value if it matches—it&#39;s looking at the concrete types of N existentials, simultaneously matching them *all* against a requirement to find a more specific type they can all be cast to, and then performing that cast. To do its job, it would need to see all of the operands at the same time and evaluate them together to find a type that would fit all of them.<br></p><p>That&#39;s what I was trying to get at when I wrote this example earlier in the thread:<br></p><p>	func == (e1: Any&lt;Equatable&gt;, e2: Any&lt;Equatable&gt;) -&gt; Bool {<br>		guard let concreteE1&lt;T: Equatable&gt; = e1 as? T, concreteE2 = e2 as? T else {<br>			return false<br>		}<br>		<br>		return concreteE1 == concreteE2<br>	}<br></p><p>If both parameters were `Square`s, then `T` would be a `Square`. But if one was a `Square` and the other a `Polygon`, `T` could be an `Any&lt;Polygonal&gt;`. Because you are simultaneously matching both values, you don&#39;t have to try the match both ways, and the operation is free to return a more specific protocol existential if that&#39;s the best it can do.<br></p><p>(And if there was no `Equatable` type they could be cast to that was more specific than `Any&lt;Equatable&gt;`, `T` would at least notionally be the bottom type and, since neither existential contains a value of the bottom type, both `as?` casts would return `nil`. `guard let` would then see those `nil`s and send you down the `else` branch.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March  4, 2016 at 07:00:00am</p></header><div class="content"><p>If I understand you right you are describing multiple dynamic dispatch as it was used e.g. in the Cecil language or Dylan and I think Clojure has it, too.<br></p><p>That would certainly be a nice and powerful addition to Swift but we would have to think carefully how to mesh this with single dispatch from OOP and POP.<br>Maybe we could introduce global multimethods.<br></p><p>-Thorsten <br></p><p><br>Am 04.03.2016 um 05:48 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p>&gt;&gt;&gt; The choice of Equatable as an example for opening existentials is an<br>&gt;&gt;&gt; interesting one here, because it&#39;s one of the few cases I can think of<br>&gt;&gt;&gt; where differing dynamic types is actually fully defined: they&#39;re not<br>&gt;&gt;&gt; equal. In ObjC we express that by starting every -isEqual:<br>&gt;&gt;&gt; implementation with if (![other isKindOfClass:[self class]]) { return<br>&gt;&gt;&gt; NO; }, which while clunky and easy to forget, does neatly express the<br>&gt;&gt;&gt; desired semantics with no burden at the callsite.<br>&gt;&gt; <br>&gt;&gt; It&#39;s a reasonable default, but it&#39;s not necessarily the right<br>&gt;&gt; implementation for every type.  One could imagine Polygons comparing<br>&gt;&gt; equal to Squares, for example.<br>&gt; <br>&gt; If the &quot;open&quot; operation is sophisticated enough, when it&#39;s faced with mismatched concrete types but they both conform to a protocol with a existential that meets the requirements, it could return that existential.<br>&gt; <br>&gt; That would mean that, in this scenario:<br>&gt; <br>&gt;    protocol Shape: Equatable { ...}<br>&gt;    <br>&gt;    protocol Polygonal: Shape {<br>&gt;        var vertices: [Vertex]<br>&gt;    }<br>&gt;    struct Square: Polygonal { ... }<br>&gt;    struct Polygon: Polygonal { ... }<br>&gt; <br>&gt; You could add this:<br>&gt; <br>&gt;    extension Any&lt;Polygonal&gt;: Equatable {}<br>&gt;    <br>&gt;    func == (lhs: Any&lt;Polygonal&gt;, rhs: Any&lt;Polygonal&gt;) -&gt; Bool {<br>&gt;        for (lhsVertex, rhsVertex) in zip(lhs.vertices, rhs.vertices) {<br>&gt;            if lhsVertex != rhsVertex {<br>&gt;                return false<br>&gt;            }<br>&gt;        }<br>&gt;        return true<br>&gt;    }<br>&gt; <br>&gt; And then, if `==(_: Any&lt;Equatable&gt;, _: Any&lt;Equatable&gt;)` were passed a Square and a Polygon, opening the `Any&lt;Equatable&gt;`s would give you a pair of `Any&lt;Polygonal&gt;`s.<br>&gt; <br>&gt; This is obviously more complex than simply opening the existential, matching its concrete type against a requirement, and extracting the original value if it matches—it&#39;s looking at the concrete types of N existentials, simultaneously matching them *all* against a requirement to find a more specific type they can all be cast to, and then performing that cast. To do its job, it would need to see all of the operands at the same time and evaluate them together to find a type that would fit all of them.<br>&gt; <br>&gt; That&#39;s what I was trying to get at when I wrote this example earlier in the thread:<br>&gt; <br>&gt;    func == (e1: Any&lt;Equatable&gt;, e2: Any&lt;Equatable&gt;) -&gt; Bool {<br>&gt;        guard let concreteE1&lt;T: Equatable&gt; = e1 as? T, concreteE2 = e2 as? T else {<br>&gt;            return false<br>&gt;        }<br>&gt;        <br>&gt;        return concreteE1 == concreteE2<br>&gt;    }<br>&gt; <br>&gt; If both parameters were `Square`s, then `T` would be a `Square`. But if one was a `Square` and the other a `Polygon`, `T` could be an `Any&lt;Polygonal&gt;`. Because you are simultaneously matching both values, you don&#39;t have to try the match both ways, and the operation is free to return a more specific protocol existential if that&#39;s the best it can do.<br>&gt; <br>&gt; (And if there was no `Equatable` type they could be cast to that was more specific than `Any&lt;Equatable&gt;`, `T` would at least notionally be the bottom type and, since neither existential contains a value of the bottom type, both `as?` casts would return `nil`. `guard let` would then see those `nil`s and send you down the `else` branch.)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
