<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a03106b2fbee9e0ada822057dfd0b6d3?s=50"></div><header><strong>Proposal for generic protocols</strong> from <string>Tal Atlas</string> &lt;me at tal.by&gt;<p>December  3, 2015 at 10:00:00pm</p></header><div class="content"><p>With the awesome expansion of protocol oriented programming that swift has<br>allowed, the lack of generic protocols has felt noticeably lacking and<br>painful in some cases. I made an in depth proposal here:<br>https://github.com/tal/swift-evolution/blob/tal/generic-protocol-proposal/proposals/NNNN-add-generic-protocols.md<br></p><p>But the tl;dr is this:<br></p><p>protocol Validator&lt;TypeToValidate&gt; {<br>  var value: TypeToValidate { get set }<br>  var valueIfValid: TypeToValidate? { get }<br>}<br></p><p>struct FooStringValidator: Validator&lt;String&gt; {<br>  //... implementation<br>}<br></p><p>let stringValidator: Validator&lt;String&gt;<br></p><p>Look forward to hearing some feedback.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/5a83e7f3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Proposal for generic protocols</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>December  3, 2015 at 11:00:00pm</p></header><div class="content"><p>I have been waiting a long time for something like this. I?m 100% behind this.<br></p><p>&gt; On 03 Dec 2015, at 23:12, Tal Atlas &lt;me at tal.by&gt; wrote:<br>&gt; <br>&gt; With the awesome expansion of protocol oriented programming that swift has allowed, the lack of generic protocols has felt noticeably lacking and painful in some cases. I made an in depth proposal here: https://github.com/tal/swift-evolution/blob/tal/generic-protocol-proposal/proposals/NNNN-add-generic-protocols.md &lt;https://github.com/tal/swift-evolution/blob/tal/generic-protocol-proposal/proposals/NNNN-add-generic-protocols.md&gt;<br>&gt; <br>&gt; But the tl;dr is this:<br>&gt; <br>&gt; protocol Validator&lt;TypeToValidate&gt; {<br>&gt;   var value: TypeToValidate { get set }<br>&gt;   var valueIfValid: TypeToValidate? { get }<br>&gt; }<br>&gt; <br>&gt; struct FooStringValidator: Validator&lt;String&gt; {<br>&gt;   //... implementation<br>&gt; }<br>&gt; <br>&gt; let stringValidator: Validator&lt;String&gt;<br>&gt; <br>&gt; Look forward to hearing some feedback.<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/54cf7352/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal for generic protocols</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  3, 2015 at 02:00:00pm</p></header><div class="content"><p>Changing all typealiases in protocols to generic arguments is a pretty<br>significant change to the language, with a very large impact on existing<br>code. It also opens the door to implementing the same protocol with<br>different types, which is something that Swift does not currently allow.<br></p><p>I think Rust&#39;s trait system is a good example of the right way to do<br>this. Rust traits are like Swift protocols, but they started out with<br>only generics, no associated types. Later on they gained associated<br>types as well (with the same limitation that Swift protocols have,<br>where any trait with an associated type cannot be used as a &quot;trait<br>object&quot;). The end result is Rust traits can have both generics and<br>associated types, and the choice of which to use depends on what it&#39;s<br>for. Also, a type in Rust can implement the same trait with different<br>generic parameters (but for any parameterized trait, it can only have<br>one implementation regardless of associated types). This is also how<br>Rust has implemented multi-dispatch (Rust does not have method<br>overloading in general). And the way you&#39;re supposed to think about<br>this is generic type parameters to a trait are &quot;input types&quot;, and<br>associated types are &quot;output types&quot;. So any given type can implement<br>the same protocol as many times as it wants with distinct input types,<br>but for every set of input types, there is only one set of output<br>types. And this works very well.<br></p><p>An example of how this is used is the trait that powers the + operator,<br>called std::ops::Add. It&#39;s defined as<br></p><p>pub trait Add&lt;RHS = Self&gt; {    type Output;    fn add[1](self, rhs: RHS)<br>-&gt; Self::Output[2]; }<br></p><p>(the `= Self` bit is a defaulted type parameter)<br></p><p>This means that for any given type T, it can support addition with any<br>number of other types, but for every pair of types (T,U), the expression<br>`T + U` can only ever have one return value. To demonstrate how this<br>would work in Swift, you can imagine supporting `+` with NSNumber<br>against different numeric types:<br></p><p>extension NSNumber: Add&lt;Int&gt; {? ? typealias Output = Int? ? func<br>add(rhs: Int) -&gt; Int {? ? ? ? return integerValue + rhs? ? } }<br></p><p>extension NSNumber: Add&lt;UInt&gt; {? ? typealias Output = UInt? ? func<br>add(rhs: UInt) -&gt; UInt {? ? ? ? return unsignedIntegerValue + rhs? ? } }<br></p><p>// etc...<br></p><p>Besides the clean distinction between &quot;input&quot; and &quot;output&quot; types, this<br>also allows various traits to have only one or the other. For example,<br>Rust&#39;s equivalent to Swift&#39;s Generator is std::iter::Iterator, which has<br>an associated type for the iterated element. And it makes a lot of sense<br>for Iterator to use an associated type for this instead of a type<br>parameter, because it&#39;s confusing to have a sequence that can yield<br>multiple different element types from a call to `seq.generate()` (or in<br>Rust&#39;s case, `seq.iter()`) which would require an explicit type<br>annotation. And it&#39;s even worse when you realize that most code that<br>iterates over sequences doesn&#39;t even care about the concrete generator<br>type, but the type annotation requires declaring that concrete type (the<br>alternative, declaring it as `GeneratorType&lt;T&gt;`, will wrap the concrete<br>type in a protocol object and incur the overhead of extra allocation +<br>dynamic function dispatch if the optimizer can&#39;t remove it).<br></p><p>tl;dr: I want both type parameters and associated types for protocols<br></p><p>-Kevin Ballard<br></p><p>On Thu, Dec 3, 2015, at 02:39 PM, David Hart wrote:<br>&gt; I have been waiting a long time for something like this. I?m 100%<br>&gt; behind this.<br>&gt;<br>&gt;&gt; On 03 Dec 2015, at 23:12, Tal Atlas &lt;me at tal.by&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; With the awesome expansion of protocol oriented programming that<br>&gt;&gt; swift has allowed, the lack of generic protocols has felt noticeably<br>&gt;&gt; lacking and painful in some cases. I made an in depth proposal here:<br>&gt;&gt; https://github.com/tal/swift-evolution/blob/tal/generic-protocol-proposal/proposals/NNNN-add-generic-protocols.md<br>&gt;&gt;<br>&gt;&gt; But the tl;dr is this:<br>&gt;&gt;<br>&gt;&gt; protocol Validator&lt;TypeToValidate&gt; {? var value: TypeToValidate { get<br>&gt;&gt; set }? var valueIfValid: TypeToValidate? { get } }<br>&gt;&gt;<br>&gt;&gt; struct FooStringValidator: Validator&lt;String&gt; {? //...<br>&gt;&gt; implementation }<br>&gt;&gt;<br>&gt;&gt; let stringValidator: Validator&lt;String&gt;<br>&gt;&gt;<br>&gt;&gt; Look forward to hearing some feedback.<br>&gt;&gt;<br>_______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>Links:<br></p><p>  1. https://doc.rust-lang.org/stable/std/ops/trait.Add.html#tymethod.add<br>  2. https://doc.rust-lang.org/stable/std/ops/trait.Add.html<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/e1684260/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal for generic protocols</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  3, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 3, 2015, at 2:12 PM, Tal Atlas &lt;me at tal.by&gt; wrote:<br>&gt; <br>&gt; With the awesome expansion of protocol oriented programming that swift has allowed, the lack of generic protocols has felt noticeably lacking and painful in some cases. I made an in depth proposal here: https://github.com/tal/swift-evolution/blob/tal/generic-protocol-proposal/proposals/NNNN-add-generic-protocols.md &lt;https://github.com/tal/swift-evolution/blob/tal/generic-protocol-proposal/proposals/NNNN-add-generic-protocols.md&gt;<br>&gt; <br>&gt; But the tl;dr is this:<br>&gt; <br>&gt; protocol Validator&lt;TypeToValidate&gt; {<br>&gt;   var value: TypeToValidate { get set }<br>&gt;   var valueIfValid: TypeToValidate? { get }<br>&gt; }<br>&gt; <br>&gt; struct FooStringValidator: Validator&lt;String&gt; {<br>&gt;   //... implementation<br>&gt; }<br>&gt; <br>&gt; let stringValidator: Validator&lt;String&gt;<br></p><p>The lack of protocol type erasure when associated types are involved is definitely a big problem, and one we&#39;d like to address. However, I don&#39;t think moving wholesale to modeling associated types this way is feasible. Many of the standard library protocols have a lot of associated types. &#39;CollectionType&#39; for instance has its &#39;Index&#39; type while also inheriting a &#39;Generator&#39; from SequenceType, and neither of these is what you typically want to parameterize a collection on?you&#39;d want &#39;CollectionType&lt;Int&gt;&#39; ideally to refer to a collection whose *Element* is Int without having to fully specify the generator and index if you don&#39;t care about them. Swift&#39;s protocols also support type system features that make some erased protocol types not actual models of their own protocols; `Equatable` is notorious for this, since a type being `Equatable` to its own values does not mean it can be equated to arbitrary other types; `1 == &quot;1&quot;` is nonsense for instance. We have a number of issues that need to be considered here; don&#39;t worry, we are considering them!<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/f5e92e56/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a03106b2fbee9e0ada822057dfd0b6d3?s=50"></div><header><strong>Proposal for generic protocols</strong> from <string>Tal Atlas</string> &lt;me at tal.by&gt;<p>December  4, 2015 at 02:00:00am</p></header><div class="content"><p>Thanks for the great info. I made this because I didn&#39;t see anything on the<br>current plan and I really hope that whatever comes out has the power and<br>ease of the proposal.<br></p><p>Thanks again for the great responses.<br></p><p>On Thu, Dec 3, 2015 at 5:43 PM Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 3, 2015, at 2:12 PM, Tal Atlas &lt;me at tal.by&gt; wrote:<br>&gt;<br>&gt; With the awesome expansion of protocol oriented programming that swift has<br>&gt; allowed, the lack of generic protocols has felt noticeably lacking and<br>&gt; painful in some cases. I made an in depth proposal here:<br>&gt; https://github.com/tal/swift-evolution/blob/tal/generic-protocol-proposal/proposals/NNNN-add-generic-protocols.md<br>&gt;<br>&gt; But the tl;dr is this:<br>&gt;<br>&gt; protocol Validator&lt;TypeToValidate&gt; {<br>&gt;   var value: TypeToValidate { get set }<br>&gt;   var valueIfValid: TypeToValidate? { get }<br>&gt; }<br>&gt;<br>&gt; struct FooStringValidator: Validator&lt;String&gt; {<br>&gt;   //... implementation<br>&gt; }<br>&gt;<br>&gt; let stringValidator: Validator&lt;String&gt;<br>&gt;<br>&gt;<br>&gt; The lack of protocol type erasure when associated types are involved is<br>&gt; definitely a big problem, and one we&#39;d like to address. However, I don&#39;t<br>&gt; think moving wholesale to modeling associated types this way is feasible.<br>&gt; Many of the standard library protocols have a lot of associated types.<br>&gt; &#39;CollectionType&#39; for instance has its &#39;Index&#39; type while also inheriting a<br>&gt; &#39;Generator&#39; from SequenceType, and neither of these is what you typically<br>&gt; want to parameterize a collection on?you&#39;d want &#39;CollectionType&lt;Int&gt;&#39;<br>&gt; ideally to refer to a collection whose *Element* is Int without having to<br>&gt; fully specify the generator and index if you don&#39;t care about them. Swift&#39;s<br>&gt; protocols also support type system features that make some erased protocol<br>&gt; types not actual models of their own protocols; `Equatable` is notorious<br>&gt; for this, since a type being `Equatable` to its own values does not mean it<br>&gt; can be equated to arbitrary other types; `1 == &quot;1&quot;` is nonsense for<br>&gt; instance. We have a number of issues that need to be considered here; don&#39;t<br>&gt; worry, we are considering them!<br>&gt;<br>&gt; -Joe<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/8c55520b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal for generic protocols</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  3, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 3, 2015, at 6:10 PM, Tal Atlas &lt;me at tal.by&gt; wrote:<br>&gt; <br>&gt; Thanks for the great info. I made this because I didn&#39;t see anything on the current plan and I really hope that whatever comes out has the power and ease of the proposal. <br>&gt; <br>&gt; Thanks again for the great responses. <br></p><p>No problem, thank you for writing this up! If you want to think about this more, some things you might consider:<br></p><p>- What changes would be necessary to the standard library to make the most of this feature? Some particular problems we&#39;d like to solve are to eliminate the need for the AnyGenerator/AnySequence/AnyCollection wrapper types, and to provide a solution for heterogeneous equality, so that protocols can inherit Equatable and Hashable without forfeiting the ability to be used dynamically. See Brent Simmons&#39; Swift diary posts at http://inessential.com/swiftdiary for an example of why the latter is important.<br>- A hybrid approach that allows for both generic parameters and associated types like Rust, as Kevin pointed out, or one where generic parameters are sugar for associated types, might be worth considering.<br></p><p>Thanks again!<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/237332f63cea8b49f59043a526dede04?s=50"></div><header><strong>Proposal for generic protocols</strong> from <string>Ken Ferry</string> &lt;kenferry at gmail.com&gt;<p>December  3, 2015 at 06:00:00pm</p></header><div class="content"><p>How about something along the lines of <br></p><p>	protocol Foo {<br>	    func doThing() -&gt; &lt;C:CollectionType, C.Generator.Element == Int&gt;C<br>	}<br></p><p>	let coll : &lt;MyColl&gt;MyColl = foo.doThing()<br>	print(&quot;got \(coll)!&quot;)<br></p><p>which compiles to be equivalent to <br></p><p>	protocol Foo {<br>	    func doThing(callback:FooDoThingCallback)<br>	}<br></p><p>	protocol FooDoThingCallback {<br>	    func callback&lt;C : CollectionType where C.Generator.Element == Int&gt;(coll:C)<br>	}<br></p><p>	    foo.doThing(MyCallback())<br>  	struct MyCallback : FooDoThingCallback {<br>            func callback&lt;C : CollectionType where C.Generator.Element == Int&gt;(coll:C) {<br>	        print(&quot;got \(coll)!&quot;)<br>	    }<br>	}<br></p><p>-ken<br></p><p>&gt; On Dec 3, 2015, at 6:19 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 3, 2015, at 6:10 PM, Tal Atlas &lt;me at tal.by&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks for the great info. I made this because I didn&#39;t see anything on the current plan and I really hope that whatever comes out has the power and ease of the proposal. <br>&gt;&gt; <br>&gt;&gt; Thanks again for the great responses. <br>&gt; <br>&gt; No problem, thank you for writing this up! If you want to think about this more, some things you might consider:<br>&gt; <br>&gt; - What changes would be necessary to the standard library to make the most of this feature? Some particular problems we&#39;d like to solve are to eliminate the need for the AnyGenerator/AnySequence/AnyCollection wrapper types, and to provide a solution for heterogeneous equality, so that protocols can inherit Equatable and Hashable without forfeiting the ability to be used dynamically. See Brent Simmons&#39; Swift diary posts at http://inessential.com/swiftdiary for an example of why the latter is important.<br>&gt; - A hybrid approach that allows for both generic parameters and associated types like Rust, as Kevin pointed out, or one where generic parameters are sugar for associated types, might be worth considering.<br>&gt; <br>&gt; Thanks again!<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/dc79ce2e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/237332f63cea8b49f59043a526dede04?s=50"></div><header><strong>Proposal for generic protocols</strong> from <string>Ken Ferry</string> &lt;kenferry at gmail.com&gt;<p>December  3, 2015 at 06:00:00pm</p></header><div class="content"><p>How about something along the lines of <br></p><p>	protocol Foo {<br>	    func doThing() -&gt; &lt;C:CollectionType, C.Generator.Element == Int&gt;C<br>	}<br></p><p>	let coll : &lt;MyColl&gt;MyColl = foo.doThing()<br>	print(&quot;got \(coll)!&quot;)<br></p><p>which compiles to be equivalent to <br></p><p>	protocol Foo {<br>	    func doThing(callback:FooDoThingCallback)<br>	}<br></p><p>	protocol FooDoThingCallback {<br>	    func callback&lt;C : CollectionType where C.Generator.Element == Int&gt;(coll:C)<br>	}<br></p><p>	    foo.doThing(MyCallback())<br>  	struct MyCallback : FooDoThingCallback {<br>            func callback&lt;C : CollectionType where C.Generator.Element == Int&gt;(coll:C) {<br>	        print(&quot;got \(coll)!&quot;)<br>	    }<br>	}<br></p><p>-ken<br></p><p>&gt; On Dec 3, 2015, at 6:19 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 3, 2015, at 6:10 PM, Tal Atlas &lt;me at tal.by &lt;mailto:me at tal.by&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks for the great info. I made this because I didn&#39;t see anything on the current plan and I really hope that whatever comes out has the power and ease of the proposal. <br>&gt;&gt; <br>&gt;&gt; Thanks again for the great responses. <br>&gt; <br>&gt; No problem, thank you for writing this up! If you want to think about this more, some things you might consider:<br>&gt; <br>&gt; - What changes would be necessary to the standard library to make the most of this feature? Some particular problems we&#39;d like to solve are to eliminate the need for the AnyGenerator/AnySequence/AnyCollection wrapper types, and to provide a solution for heterogeneous equality, so that protocols can inherit Equatable and Hashable without forfeiting the ability to be used dynamically. See Brent Simmons&#39; Swift diary posts at http://inessential.com/swiftdiary &lt;http://inessential.com/swiftdiary&gt; for an example of why the latter is important.<br>&gt; - A hybrid approach that allows for both generic parameters and associated types like Rust, as Kevin pointed out, or one where generic parameters are sugar for associated types, might be worth considering.<br>&gt; <br>&gt; Thanks again!<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/df77e5f8/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/237332f63cea8b49f59043a526dede04?s=50"></div><header><strong>Proposal for generic protocols</strong> from <string>Ken Ferry</string> &lt;kenferry at gmail.com&gt;<p>December  3, 2015 at 07:00:00pm</p></header><div class="content"><p>Oops, I messed that up a bit. I meant equivalent codegen to <br></p><p>protocol Foo {<br>    func doThing&lt;CB : FooDoThingCallback&gt;(callback:CB)<br>}<br></p><p>protocol FooDoThingCallback {<br>    func callback&lt;C : CollectionType where C.Generator.Element == Int&gt;(coll:C)<br>}<br></p><p>foo.doThing(Callback())<br>struct Callback : FooDoThingCallback {<br>    func callback&lt;C : CollectionType where C.Generator.Element == Int&gt;(coll:C) {<br>        print(&quot;got \(coll)!&quot;)<br>    }<br>}<br></p><p><br>&gt; On Dec 3, 2015, at 6:59 PM, Ken Ferry &lt;kenferry at gmail.com&gt; wrote:<br>&gt; <br>&gt; How about something along the lines of <br>&gt; <br>&gt; 	protocol Foo {<br>&gt; 	    func doThing() -&gt; &lt;C:CollectionType, C.Generator.Element == Int&gt;C<br>&gt; 	}<br>&gt; <br>&gt; 	let coll : &lt;MyColl&gt;MyColl = foo.doThing()<br>&gt; 	print(&quot;got \(coll)!&quot;)<br>&gt; <br>&gt; which compiles to be equivalent to <br>&gt; <br>&gt; 	protocol Foo {<br>&gt; 	    func doThing(callback:FooDoThingCallback)<br>&gt; 	}<br>&gt; <br>&gt; 	protocol FooDoThingCallback {<br>&gt; 	    func callback&lt;C : CollectionType where C.Generator.Element == Int&gt;(coll:C)<br>&gt; 	}<br>&gt; <br>&gt; 	    foo.doThing(MyCallback())<br>&gt;   	struct MyCallback : FooDoThingCallback {<br>&gt;             func callback&lt;C : CollectionType where C.Generator.Element == Int&gt;(coll:C) {<br>&gt; 	        print(&quot;got \(coll)!&quot;)<br>&gt; 	    }<br>&gt; 	}<br>&gt; <br>&gt; -ken<br>&gt; <br>&gt;&gt; On Dec 3, 2015, at 6:19 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 3, 2015, at 6:10 PM, Tal Atlas &lt;me at tal.by &lt;mailto:me at tal.by&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for the great info. I made this because I didn&#39;t see anything on the current plan and I really hope that whatever comes out has the power and ease of the proposal. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks again for the great responses. <br>&gt;&gt; <br>&gt;&gt; No problem, thank you for writing this up! If you want to think about this more, some things you might consider:<br>&gt;&gt; <br>&gt;&gt; - What changes would be necessary to the standard library to make the most of this feature? Some particular problems we&#39;d like to solve are to eliminate the need for the AnyGenerator/AnySequence/AnyCollection wrapper types, and to provide a solution for heterogeneous equality, so that protocols can inherit Equatable and Hashable without forfeiting the ability to be used dynamically. See Brent Simmons&#39; Swift diary posts at http://inessential.com/swiftdiary &lt;http://inessential.com/swiftdiary&gt; for an example of why the latter is important.<br>&gt;&gt; - A hybrid approach that allows for both generic parameters and associated types like Rust, as Kevin pointed out, or one where generic parameters are sugar for associated types, might be worth considering.<br>&gt;&gt; <br>&gt;&gt; Thanks again!<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/66e11ec2/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
