<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>Why does RangeReplaceableCollection require an empty initialiser?</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>July  6, 2016 at 04:00:00pm</p></header><div class="content"><p>You wouldn’t need an empty initialiser to remove all elements from a collection, right? You could just use `replaceRange` instead.<br></p><p>&gt; Now I understood you concerns. Have you ever thought of if a non-empty RangeReplaceableCollection being removed all of its elements, which makes the collection to be an empty collection. That shouldn&#39;t change theRangeReplaceableCollection to be a non-RangeReplaceableCollection. Sothe empty collection must also be aRangeReplaceableCollection.<br>&gt; <br>&gt; &gt; init()<br>&gt; (file:///Users/zhaoxin/Library/Application%20Support/Dash/DocSets/Apple_API_Reference/Apple_API_Reference.docset/Contents/Resources/Documents/developer.apple.com/reference/swift/rangereplaceablecollection/1641467-init.html)&gt; Creates a new, empty collection.<br>&gt; <br>&gt; Zhaoxin<br>&gt; <br>&gt; On Wed, Jul 6, 2016 at 9:09 PM, Tim Vermeulen&lt;tvermeulen at me.com(mailto:tvermeulen at me.com)&gt;wrote:<br>&gt; &gt; I’m not allowing generic subscripts. The collection is declared as `AnyIndexArray&lt;Index: Strideable, Element where Index.Stride == Int&gt;` and it can be subscripted with type `Index`.<br>&gt; &gt; <br>&gt; &gt; Either way, it’s not really important. I’m mostly wondering why RangeReplaceableCollection needs an empty initialiser.<br>&gt; &gt; <br>&gt; &gt; &gt;Then how you defined the index to conform toStrideable? Below code does work as it seams that you can&#39;t use generics in subscripts.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;subscript&lt;T:Strideable&gt;(index:T) -&gt;Element<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;Zhaoxin<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;On Wed, Jul 6, 2016 at 8:32 PM, Tim Vermeulen&lt;tvermeulen at me.com(mailto:tvermeulen at me.com)(mailto:tvermeulen at me.com)&gt;wrote:<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;On 6 Jul 2016, at 14:03, Zhao Xin&lt;owenzx at gmail.com(mailto:owenzx at gmail.com)(mailto:owenzx at gmail.com)&gt;wrote:<br>&gt; &gt; &gt;&gt;&gt;According to the document of Swift 3, Array has already conformed protocolRangeReplaceableCollection.<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;That’s exactly why I also want to conform my wrapper to that protocol? I think there’s a misunderstanding. I’m making a collection that can be subscripted with any index (that conforms to Strideable), but behaves like an array otherwise.<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;Zhaoxin<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;On Wed, Jul 6, 2016 at 7:09 PM, Tim Vermeulen via swift-users&lt;swift-users at swift.org(mailto:swift-users at swift.org)(mailto:swift-users at swift.org)&gt;wrote:<br>&gt; &gt; &gt;&gt;&gt;&gt;RangeReplaceableCollection has three initialisers: init(), init(_:) and init(repeating:count:). The latter two are implemented using the empty initialiser. But why are these initialisers part of this particular protocol? As far as I can tell, no other methods of this protocol depend on these initialisers. The requirement of the empty initialiser makes it impossible to have a collection conform to this protocol that needs additional data for its initialisation.<br>&gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;For instance, I was making an array that works with any Strideable indices, not just integers. A startIndex is needed for its initialisation, so I can’t really conform it to RangeReplaceableCollection. If I do it anyways (with a fatalError() in the required empty initialiser) everything seems to work just fine, except for the protocol’s three initialisers.<br>&gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;&gt;Perhaps these initialisers should be moved to a (possible new) different protocol?<br>&gt; &gt; &gt;&gt;&gt;&gt;_______________________________________________<br>&gt; &gt; &gt;&gt;&gt;&gt;swift-users mailing list<br>&gt; &gt; &gt;&gt;&gt;&gt;swift-users at swift.org(mailto:swift-users at swift.org)(mailto:swift-users at swift.org)<br>&gt; &gt; &gt;&gt;&gt;&gt;https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; <br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Why does RangeReplaceableCollection require an empty initialiser?</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>July  6, 2016 at 10:00:00pm</p></header><div class="content"><p>N<br>​o. You didn&#39;t catch what I meant. I meant it should be like an equation.<br>​If foo is a<br>​RangeReplaceableCollection,<br>​<br>foo<br> minus<br>foo<br> equates zero, zero means an empty collection. Both side of the equation<br>should be with the same unit, the unit is<br>RangeReplaceableCollection.<br>​ Below code also shows init() is useful in<br>RangeReplaceableCollection.<br>​​<br></p><p>var foo = Array&lt;Int&gt;()<br>&gt;<br>&gt; foo.append(contentsOf: [2,4,6,8])<br>&gt;<br></p><p>​Zhaoxin<br></p><p>On Wed, Jul 6, 2016 at 10:07 PM, Tim Vermeulen &lt;tvermeulen at me.com&gt; wrote:<br></p><p>&gt; You wouldn’t need an empty initialiser to remove all elements from a<br>&gt; collection, right? You could just use `replaceRange` instead.<br>&gt;<br>&gt; &gt; Now I understood you concerns. Have you ever thought of if a non-empty<br>&gt; RangeReplaceableCollection being removed all of its elements, which makes<br>&gt; the collection to be an empty collection. That shouldn&#39;t change<br>&gt; theRangeReplaceableCollection to be a non-RangeReplaceableCollection. Sothe<br>&gt; empty collection must also be aRangeReplaceableCollection.<br>&gt; &gt;<br>&gt; &gt; &gt; init()<br>&gt; &gt;<br>&gt; (file:///Users/zhaoxin/Library/Application%20Support/Dash/DocSets/Apple_API_Reference/Apple_API_Reference.docset/Contents/Resources/Documents/<br>&gt; developer.apple.com/reference/swift/rangereplaceablecollection/1641467-init.html)&gt;<br>&gt; Creates a new, empty collection.<br>&gt; &gt;<br>&gt; &gt; Zhaoxin<br>&gt; &gt;<br>&gt; &gt; On Wed, Jul 6, 2016 at 9:09 PM, Tim Vermeulen&lt;tvermeulen at me.com(mailto:<br>&gt; tvermeulen at me.com)&gt;wrote:<br>&gt; &gt; &gt; I’m not allowing generic subscripts. The collection is declared as<br>&gt; `AnyIndexArray&lt;Index: Strideable, Element where Index.Stride == Int&gt;` and<br>&gt; it can be subscripted with type `Index`.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Either way, it’s not really important. I’m mostly wondering why<br>&gt; RangeReplaceableCollection needs an empty initialiser.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;Then how you defined the index to conform toStrideable? Below code<br>&gt; does work as it seams that you can&#39;t use generics in subscripts.<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;subscript&lt;T:Strideable&gt;(index:T) -&gt;Element<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;Zhaoxin<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;On Wed, Jul 6, 2016 at 8:32 PM, Tim Vermeulen&lt;tvermeulen at me.com<br>&gt; (mailto:tvermeulen at me.com)(mailto:tvermeulen at me.com)&gt;wrote:<br>&gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;On 6 Jul 2016, at 14:03, Zhao Xin&lt;owenzx at gmail.com(mailto:<br>&gt; owenzx at gmail.com)(mailto:owenzx at gmail.com)&gt;wrote:<br>&gt; &gt; &gt; &gt;&gt;&gt;According to the document of Swift 3, Array has already conformed<br>&gt; protocolRangeReplaceableCollection.<br>&gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;That’s exactly why I also want to conform my wrapper to that<br>&gt; protocol? I think there’s a misunderstanding. I’m making a collection that<br>&gt; can be subscripted with any index (that conforms to Strideable), but<br>&gt; behaves like an array otherwise.<br>&gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;Zhaoxin<br>&gt; &gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;On Wed, Jul 6, 2016 at 7:09 PM, Tim Vermeulen via swift-users&lt;<br>&gt; swift-users at swift.org(mailto:swift-users at swift.org)(mailto:<br>&gt; swift-users at swift.org)&gt;wrote:<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;RangeReplaceableCollection has three initialisers: init(),<br>&gt; init(_:) and init(repeating:count:). The latter two are implemented using<br>&gt; the empty initialiser. But why are these initialisers part of this<br>&gt; particular protocol? As far as I can tell, no other methods of this<br>&gt; protocol depend on these initialisers. The requirement of the empty<br>&gt; initialiser makes it impossible to have a collection conform to this<br>&gt; protocol that needs additional data for its initialisation.<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;For instance, I was making an array that works with any Strideable<br>&gt; indices, not just integers. A startIndex is needed for its initialisation,<br>&gt; so I can’t really conform it to RangeReplaceableCollection. If I do it<br>&gt; anyways (with a fatalError() in the required empty initialiser) everything<br>&gt; seems to work just fine, except for the protocol’s three initialisers.<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;Perhaps these initialisers should be moved to a (possible new)<br>&gt; different protocol?<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;_______________________________________________<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;swift-users mailing list<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;swift-users at swift.org(mailto:swift-users at swift.org)(mailto:<br>&gt; swift-users at swift.org)<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; &gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160706/fc88d6ff/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>Why does RangeReplaceableCollection require an empty initialiser?</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>July  6, 2016 at 06:00:00pm</p></header><div class="content"><p>I never said a RangeReplaceableCollection shouldn’t be empty. I just think it’s strange that it requires an empty initialiser (while the Collection protocol doesn’t).<br></p><p>&gt; On 6 Jul 2016, at 16:33, Zhao Xin &lt;owenzx at gmail.com&gt; wrote:<br>&gt; <br>&gt; N​o. You didn&#39;t catch what I meant. I meant it should be like an equation. ​If foo is a ​RangeReplaceableCollection,​ foo minus foo equates zero, zero means an empty collection. Both side of the equation should be with the same unit, the unit is RangeReplaceableCollection.​ Below code also shows init() is useful in RangeReplaceableCollection.​​<br>&gt; <br>&gt; var foo = Array&lt;Int&gt;()<br>&gt; foo.append(contentsOf: [2,4,6,8])<br>&gt; <br>&gt; ​Zhaoxin<br>&gt; <br>&gt; On Wed, Jul 6, 2016 at 10:07 PM, Tim Vermeulen &lt;tvermeulen at me.com &lt;mailto:tvermeulen at me.com&gt;&gt; wrote:<br>&gt; You wouldn’t need an empty initialiser to remove all elements from a collection, right? You could just use `replaceRange` instead.<br>&gt; <br>&gt; &gt; Now I understood you concerns. Have you ever thought of if a non-empty RangeReplaceableCollection being removed all of its elements, which makes the collection to be an empty collection. That shouldn&#39;t change theRangeReplaceableCollection to be a non-RangeReplaceableCollection. Sothe empty collection must also be aRangeReplaceableCollection.<br>&gt; &gt;<br>&gt; &gt; &gt; init()<br>&gt; &gt; (file:///Users/zhaoxin/Library/Application%20Support/Dash/DocSets/Apple_API_Reference/Apple_API_Reference.docset/Contents/Resources/Documents/developer.apple.com/reference/swift/rangereplaceablecollection/1641467-init.html &lt;http://developer.apple.com/reference/swift/rangereplaceablecollection/1641467-init.html&gt;)&gt; Creates a new, empty collection.<br>&gt; &gt;<br>&gt; &gt; Zhaoxin<br>&gt; &gt;<br>&gt; &gt; On Wed, Jul 6, 2016 at 9:09 PM, Tim Vermeulen&lt;tvermeulen at me.com &lt;mailto:tvermeulen at me.com&gt;(mailto:tvermeulen at me.com &lt;mailto:tvermeulen at me.com&gt;)&gt;wrote:<br>&gt; &gt; &gt; I’m not allowing generic subscripts. The collection is declared as `AnyIndexArray&lt;Index: Strideable, Element where Index.Stride == Int&gt;` and it can be subscripted with type `Index`.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Either way, it’s not really important. I’m mostly wondering why RangeReplaceableCollection needs an empty initialiser.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;Then how you defined the index to conform toStrideable? Below code does work as it seams that you can&#39;t use generics in subscripts.<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;subscript&lt;T:Strideable&gt;(index:T) -&gt;Element<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;Zhaoxin<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;On Wed, Jul 6, 2016 at 8:32 PM, Tim Vermeulen&lt;tvermeulen at me.com &lt;mailto:tvermeulen at me.com&gt;(mailto:tvermeulen at me.com &lt;mailto:tvermeulen at me.com&gt;)(mailto:tvermeulen at me.com &lt;mailto:tvermeulen at me.com&gt;)&gt;wrote:<br>&gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;On 6 Jul 2016, at 14:03, Zhao Xin&lt;owenzx at gmail.com &lt;mailto:owenzx at gmail.com&gt;(mailto:owenzx at gmail.com &lt;mailto:owenzx at gmail.com&gt;)(mailto:owenzx at gmail.com &lt;mailto:owenzx at gmail.com&gt;)&gt;wrote:<br>&gt; &gt; &gt; &gt;&gt;&gt;According to the document of Swift 3, Array has already conformed protocolRangeReplaceableCollection.<br>&gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;That’s exactly why I also want to conform my wrapper to that protocol? I think there’s a misunderstanding. I’m making a collection that can be subscripted with any index (that conforms to Strideable), but behaves like an array otherwise.<br>&gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;Zhaoxin<br>&gt; &gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;On Wed, Jul 6, 2016 at 7:09 PM, Tim Vermeulen via swift-users&lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;(mailto:swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;)(mailto:swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;)&gt;wrote:<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;RangeReplaceableCollection has three initialisers: init(), init(_:) and init(repeating:count:). The latter two are implemented using the empty initialiser. But why are these initialisers part of this particular protocol? As far as I can tell, no other methods of this protocol depend on these initialisers. The requirement of the empty initialiser makes it impossible to have a collection conform to this protocol that needs additional data for its initialisation.<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;For instance, I was making an array that works with any Strideable indices, not just integers. A startIndex is needed for its initialisation, so I can’t really conform it to RangeReplaceableCollection. If I do it anyways (with a fatalError() in the required empty initialiser) everything seems to work just fine, except for the protocol’s three initialisers.<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;Perhaps these initialisers should be moved to a (possible new) different protocol?<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;_______________________________________________<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;swift-users mailing list<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;(mailto:swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;)(mailto:swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;)<br>&gt; &gt; &gt; &gt;&gt;&gt;&gt;https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt; &gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160706/be230fb9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Why does RangeReplaceableCollection require an empty initialiser?</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>July  7, 2016 at 01:00:00am</p></header><div class="content"><p>I am not a software scientist. I have to explain things with examples. For<br>example, in Framework headers.<br></p><p>extension Array : RangeReplaceableCollection {<br>&gt;     /// Creates a new, empty array.<br>&gt;     ///<br>&gt;     /// This is equivalent to initializing with an empty array literal.<br>&gt;     /// For example:<br>&gt;     ///<br>&gt;     ///     var emptyArray = Array&lt;Int&gt;()<br>&gt;     ///     print(emptyArray.isEmpty)<br>&gt;     ///     // Prints &quot;true&quot;<br>&gt;     ///<br>&gt;     ///     emptyArray = []<br>&gt;     ///     print(emptyArray.isEmpty)<br>&gt;     ///     // Prints &quot;true&quot;<br>&gt;     public init()<br></p><p><br>In Swift source code.<br></p><p>extension ${Self} : RangeReplaceableCollection, _ArrayProtocol {<br>&gt;   /// Creates a new, empty array.<br>&gt;   ///<br>&gt;   /// This is equivalent to initializing with an empty array literal.<br>&gt;   /// For example:<br>&gt;   ///<br>&gt;   ///     var emptyArray = Array&lt;Int&gt;()<br>&gt;   ///     print(emptyArray.isEmpty)<br>&gt;   ///     // Prints &quot;true&quot;<br>&gt;   ///<br>&gt;   ///     emptyArray = []<br>&gt;   ///     print(emptyArray.isEmpty)<br>&gt;   ///     // Prints &quot;true&quot;<br>&gt;   @_semantics(&quot;array.init&quot;)<br>&gt;   public init() {<br>&gt;     _buffer = _Buffer()<br>&gt;   }<br></p><p><br>​So I am confident to say, if there is no protocol limits on init() to be<br>empty. You can do what ever with Array&lt;Int&gt;(), maybe<br></p><p>l<br>&gt; ​et foo = Array&lt;Int&gt;() // means [1] is OK​, as there is no limitation<br>&gt; prohibits you to do so.<br>&gt;<br></p><p>​So there always must be a protocol saying init() to be an empty<br>collection. We just don&#39;t know why it is put in ​<br>RangeReplaceableCollection.<br>​at the moment.​<br></p><p>Conforming chains(collection part only):<br></p><p>Array:<br>MutableCollection<br>​:<br>Collection:<br>​<br>Sequence<br>​<br>Array:<br>RandomAccessCollection:<br>​​<br>BidirectionalCollection:<br>​​<br>Collection<br>​<br>:<br>​<br>Sequence<br>​<br>A​rray:<br>RangeReplaceableCollection:<br>​<br>Collection​:<br>​<br>Sequence<br>​<br></p><p>For Sequence protocol, there is no mutating functions.<br>​<br>For Collection protocol, the mutating functions are removeFirst(),<br>removeFirst(Int), split(_:_:_) and  popFirst(). As you can imaging, an<br>empty collection can call none of the functions.<br></p><p>For MutableCollection, BidirectionalCollection, RandomAccessCollection, the<br>situations are similar. They just don&#39;t have extra mutating functions nor<br>an empty collection can&#39;t call these mutating functions.<br></p><p>For RangeReplaceableCollection protocol, below mutating function works in<br>an empty collection<br></p><p>func append&lt;S&gt;(contentsOf: S)<br></p><p>func removeAll(keepingCapacity: Bool)<br></p><p><br>Maybe that is why the must have init() is put here.<br></p><p>Zhaoxin​<br></p><p><br>On Thu, Jul 7, 2016 at 12:10 AM, Tim Vermeulen &lt;tvermeulen at me.com&gt; wrote:<br></p><p>&gt; I never said a RangeReplaceableCollection shouldn’t be empty. I just think<br>&gt; it’s strange that it requires an empty initialiser (while the Collection<br>&gt; protocol doesn’t).<br>&gt;<br>&gt; On 6 Jul 2016, at 16:33, Zhao Xin &lt;owenzx at gmail.com&gt; wrote:<br>&gt;<br>&gt; N<br>&gt; ​o. You didn&#39;t catch what I meant. I meant it should be like an equation.<br>&gt; ​If foo is a<br>&gt; ​RangeReplaceableCollection,<br>&gt; ​<br>&gt; foo<br>&gt;  minus<br>&gt; foo<br>&gt;  equates zero, zero means an empty collection. Both side of the equation<br>&gt; should be with the same unit, the unit is<br>&gt; RangeReplaceableCollection.<br>&gt; ​ Below code also shows init() is useful in<br>&gt; RangeReplaceableCollection.<br>&gt; ​​<br>&gt;<br>&gt; var foo = Array&lt;Int&gt;()<br>&gt;&gt;<br>&gt;&gt; foo.append(contentsOf: [2,4,6,8])<br>&gt;&gt;<br>&gt;<br>&gt; ​Zhaoxin<br>&gt;<br>&gt; On Wed, Jul 6, 2016 at 10:07 PM, Tim Vermeulen &lt;tvermeulen at me.com&gt; wrote:<br>&gt;<br>&gt;&gt; You wouldn’t need an empty initialiser to remove all elements from a<br>&gt;&gt; collection, right? You could just use `replaceRange` instead.<br>&gt;&gt;<br>&gt;&gt; &gt; Now I understood you concerns. Have you ever thought of if a non-empty<br>&gt;&gt; RangeReplaceableCollection being removed all of its elements, which makes<br>&gt;&gt; the collection to be an empty collection. That shouldn&#39;t change<br>&gt;&gt; theRangeReplaceableCollection to be a non-RangeReplaceableCollection. Sothe<br>&gt;&gt; empty collection must also be aRangeReplaceableCollection.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; &gt; init()<br>&gt;&gt; &gt; (<br>&gt;&gt; file:///Users/zhaoxin/Library/Application%20Support/Dash/DocSets/Apple_API_Reference/Apple_API_Reference.docset/Contents/Resources/Documents/<br>&gt;&gt; developer.apple.com/reference/swift/rangereplaceablecollection/1641467-init.html)&gt;<br>&gt;&gt; Creates a new, empty collection.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Zhaoxin<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Wed, Jul 6, 2016 at 9:09 PM, Tim Vermeulen&lt;tvermeulen at me.com(mailto:<br>&gt;&gt; tvermeulen at me.com)&gt;wrote:<br>&gt;&gt; &gt; &gt; I’m not allowing generic subscripts. The collection is declared as<br>&gt;&gt; `AnyIndexArray&lt;Index: Strideable, Element where Index.Stride == Int&gt;` and<br>&gt;&gt; it can be subscripted with type `Index`.<br>&gt;&gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; Either way, it’s not really important. I’m mostly wondering why<br>&gt;&gt; RangeReplaceableCollection needs an empty initialiser.<br>&gt;&gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt;Then how you defined the index to conform toStrideable? Below code<br>&gt;&gt; does work as it seams that you can&#39;t use generics in subscripts.<br>&gt;&gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt;subscript&lt;T:Strideable&gt;(index:T) -&gt;Element<br>&gt;&gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt;Zhaoxin<br>&gt;&gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt;On Wed, Jul 6, 2016 at 8:32 PM, Tim Vermeulen&lt;tvermeulen at me.com<br>&gt;&gt; (mailto:tvermeulen at me.com)(mailto:tvermeulen at me.com)&gt;wrote:<br>&gt;&gt; &gt; &gt; &gt;&gt;<br>&gt;&gt; &gt; &gt; &gt;&gt;&gt;On 6 Jul 2016, at 14:03, Zhao Xin&lt;owenzx at gmail.com(mailto:<br>&gt;&gt; owenzx at gmail.com)(mailto:owenzx at gmail.com)&gt;wrote:<br>&gt;&gt; &gt; &gt; &gt;&gt;&gt;According to the document of Swift 3, Array has already conformed<br>&gt;&gt; protocolRangeReplaceableCollection.<br>&gt;&gt; &gt; &gt; &gt;&gt;<br>&gt;&gt; &gt; &gt; &gt;&gt;That’s exactly why I also want to conform my wrapper to that<br>&gt;&gt; protocol? I think there’s a misunderstanding. I’m making a collection that<br>&gt;&gt; can be subscripted with any index (that conforms to Strideable), but<br>&gt;&gt; behaves like an array otherwise.<br>&gt;&gt; &gt; &gt; &gt;&gt;<br>&gt;&gt; &gt; &gt; &gt;&gt;&gt;<br>&gt;&gt; &gt; &gt; &gt;&gt;&gt;Zhaoxin<br>&gt;&gt; &gt; &gt; &gt;&gt;&gt;<br>&gt;&gt; &gt; &gt; &gt;&gt;&gt;On Wed, Jul 6, 2016 at 7:09 PM, Tim Vermeulen via swift-users&lt;<br>&gt;&gt; swift-users at swift.org(mailto:swift-users at swift.org)(mailto:<br>&gt;&gt; swift-users at swift.org)&gt;wrote:<br>&gt;&gt; &gt; &gt; &gt;&gt;&gt;&gt;RangeReplaceableCollection has three initialisers: init(),<br>&gt;&gt; init(_:) and init(repeating:count:). The latter two are implemented using<br>&gt;&gt; the empty initialiser. But why are these initialisers part of this<br>&gt;&gt; particular protocol? As far as I can tell, no other methods of this<br>&gt;&gt; protocol depend on these initialisers. The requirement of the empty<br>&gt;&gt; initialiser makes it impossible to have a collection conform to this<br>&gt;&gt; protocol that needs additional data for its initialisation.<br>&gt;&gt; &gt; &gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt; &gt; &gt;&gt;&gt;&gt;For instance, I was making an array that works with any<br>&gt;&gt; Strideable indices, not just integers. A startIndex is needed for its<br>&gt;&gt; initialisation, so I can’t really conform it to RangeReplaceableCollection.<br>&gt;&gt; If I do it anyways (with a fatalError() in the required empty initialiser)<br>&gt;&gt; everything seems to work just fine, except for the protocol’s three<br>&gt;&gt; initialisers.<br>&gt;&gt; &gt; &gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt; &gt; &gt;&gt;&gt;&gt;Perhaps these initialisers should be moved to a (possible new)<br>&gt;&gt; different protocol?<br>&gt;&gt; &gt; &gt; &gt;&gt;&gt;&gt;_______________________________________________<br>&gt;&gt; &gt; &gt; &gt;&gt;&gt;&gt;swift-users mailing list<br>&gt;&gt; &gt; &gt; &gt;&gt;&gt;&gt;swift-users at swift.org(mailto:swift-users at swift.org)(mailto:<br>&gt;&gt; swift-users at swift.org)<br>&gt;&gt; &gt; &gt; &gt;&gt;&gt;&gt;https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt; &gt; &gt; &gt;&gt;&gt;<br>&gt;&gt; &gt; &gt; &gt;&gt;<br>&gt;&gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160707/fff41624/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
