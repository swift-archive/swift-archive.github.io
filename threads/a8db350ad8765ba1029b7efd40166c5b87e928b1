<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 12, 2016 at 03:00:00pm</p></header><div class="content"><p>on Tue Apr 12 2016, plx &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Aside: `indices` being irregular can be a benefit in the context of<br>&gt; auto-complete.<br>&gt;<br>&gt;     * What is your evaluation of the proposal?<br>&gt;<br>&gt; +1, very much.<br>&gt;<br>&gt; As a change from the current model, it’s an across-the-board improvement for me,<br>&gt; at least.<br>&gt;<br>&gt; In a bigger-picture sense I think Swift would be better off by going *further*<br>&gt; on certain aspects, but have said all that before.<br>&gt;<br>&gt;     * Is the problem being addressed significant enough to warrant a change to<br>&gt;     Swift?<br>&gt;<br>&gt; It is, again very much so.<br>&gt;<br>&gt;     * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; Depends on the framing of the question.<br>&gt;<br>&gt; Compared to the previous model, it’s an unqualified YES.<br>&gt;<br>&gt; As a general proposition, I think this design is a local optimum for overall<br>&gt; Swift-ness, but even so it’s creating a little un-Swifty pocket. It’s<br>&gt; “un-Swifty” in at least two ways:<br>&gt;<br>&gt; # 1: Relatively Unsafe, Pointer-Like Semantics<br>&gt;<br>&gt; Indices—unsurprisingly!—behave quite a bit like pointers, and similarly expose<br>&gt; *numerous* crashing combinations of `(value,operation)`:<br>&gt;<br>&gt; - self[endIndex]<br>&gt; - self[startIndex] // &lt;- when empty<br>&gt; - successor(of: endIndex)<br>&gt; - predecessor(of: startIndex)<br>&gt;<br>&gt; …etc., which is *very much* reminiscent of the hazards of pointers. (Technically<br>&gt; “undefined” not “crashing”, but being realistic “crashing&quot; is usually accurate).<br></p><p>No, these are unspecified in the general case, not undefined.  Unless<br>you&#39;re working with, e.g. `UnsafeMutableBufferPointer` (or you have a<br>data race), there&#39;s no undefined behavior.  The big problem with<br>pointers isn&#39;t what happens when they crash; it&#39;s what happens when they<br>*don&#39;t*.<br></p><p>&gt; Although Swift uses `Optional` to mitigate the hazards of `nil` pointers (etc.),<br>&gt; you’re still left to your own devices for handling indices.<br></p><p>`Optional` is not “mitigating hazards;” it&#39;s encoding the possibility of<br>null in the type system.  It&#39;s non-optional things that mitigate hazards.<br></p><p>&gt; This isn’t news to anyone here, I’m sure, and may even be unavoidable; I’m just<br>&gt; pointing it out as an uncharacteristically-unsafe area in Swift’s standard APIs,<br>&gt; and closer to how `!` and IOUs behave than otherwise typical.<br></p><p>Any time there&#39;s a required relationship between two things, e.g. a<br>receiver and an argument, you have a precondition.  The existence of a<br>precondition does not make something unsafe at all in the sense that<br>Swift uses the term.  Safety in swift is about type and memory safety in<br>the absence of data races, not about having APIs that respond sensibly<br>to every possible combination of arguments.  Int.max + 1 will trap, but<br>that doesn&#39;t make addition unsafe.<br></p><p>Saying that it&#39;s close to how `!` behaves is not at all far from the<br>truth, because `!` has a precondition that its argument is non-nil.<br></p><p>&gt; To help illustrate the claim, here’s a strawman “safe” API—for illustration<br>&gt; only, not advocacy!—that would be safer and thus perhaps more “Swift-y”:<br></p><p>I think there&#39;s a prevalent misunderstanding (IOW, I don&#39;t mean to<br>single out this post or this poster) about what “safe” means in Swift<br>and what the features of a Swifty API are and should be.  This<br>is a big topic worthy of much more time than I can devote here, but<br>here&#39;s a thought to start with:<br></p><p>A Swifty API helps you reason effectively about the correctness of your<br>code, and in part that means we provide enough preconditions on<br>arguments to avoid complicating result types, and code to handle<br>results, with optional-ness.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>April 13, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Apr 12, 2016, at 5:25 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Tue Apr 12 2016, plx &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Aside: `indices` being irregular can be a benefit in the context of<br>&gt;&gt; auto-complete.<br>&gt;&gt; <br>&gt;&gt;    * What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; +1, very much.<br>&gt;&gt; <br>&gt;&gt; As a change from the current model, it’s an across-the-board improvement for me,<br>&gt;&gt; at least.<br>&gt;&gt; <br>&gt;&gt; In a bigger-picture sense I think Swift would be better off by going *further*<br>&gt;&gt; on certain aspects, but have said all that before.<br>&gt;&gt; <br>&gt;&gt;    * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt;    Swift?<br>&gt;&gt; <br>&gt;&gt; It is, again very much so.<br>&gt;&gt; <br>&gt;&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; Depends on the framing of the question.<br>&gt;&gt; <br>&gt;&gt; Compared to the previous model, it’s an unqualified YES.<br>&gt;&gt; <br>&gt;&gt; As a general proposition, I think this design is a local optimum for overall<br>&gt;&gt; Swift-ness, but even so it’s creating a little un-Swifty pocket. It’s<br>&gt;&gt; “un-Swifty” in at least two ways:<br>&gt;&gt; <br>&gt;&gt; # 1: Relatively Unsafe, Pointer-Like Semantics<br>&gt;&gt; <br>&gt;&gt; Indices—unsurprisingly!—behave quite a bit like pointers, and similarly expose<br>&gt;&gt; *numerous* crashing combinations of `(value,operation)`:<br>&gt;&gt; <br>&gt;&gt; - self[endIndex]<br>&gt;&gt; - self[startIndex] // &lt;- when empty<br>&gt;&gt; - successor(of: endIndex)<br>&gt;&gt; - predecessor(of: startIndex)<br>&gt;&gt; <br>&gt;&gt; …etc., which is *very much* reminiscent of the hazards of pointers. (Technically<br>&gt;&gt; “undefined” not “crashing”, but being realistic “crashing&quot; is usually accurate).<br>&gt; <br>&gt; No, these are unspecified in the general case, not undefined.  Unless<br>&gt; you&#39;re working with, e.g. `UnsafeMutableBufferPointer` (or you have a<br>&gt; data race), there&#39;s no undefined behavior.  The big problem with<br>&gt; pointers isn&#39;t what happens when they crash; it&#39;s what happens when they<br>&gt; *don&#39;t*.<br>&gt; <br>&gt;&gt; Although Swift uses `Optional` to mitigate the hazards of `nil` pointers (etc.),<br>&gt;&gt; you’re still left to your own devices for handling indices.<br>&gt; <br>&gt; `Optional` is not “mitigating hazards;” it&#39;s encoding the possibility of<br>&gt; null in the type system.  It&#39;s non-optional things that mitigate hazards.<br>&gt; <br>&gt;&gt; This isn’t news to anyone here, I’m sure, and may even be unavoidable; I’m just<br>&gt;&gt; pointing it out as an uncharacteristically-unsafe area in Swift’s standard APIs,<br>&gt;&gt; and closer to how `!` and IOUs behave than otherwise typical.<br>&gt; <br>&gt; Any time there&#39;s a required relationship between two things, e.g. a<br>&gt; receiver and an argument, you have a precondition.  The existence of a<br>&gt; precondition does not make something unsafe at all in the sense that<br>&gt; Swift uses the term.  Safety in swift is about type and memory safety in<br>&gt; the absence of data races, not about having APIs that respond sensibly<br>&gt; to every possible combination of arguments.  Int.max + 1 will trap, but<br>&gt; that doesn&#39;t make addition unsafe.<br>&gt; <br>&gt; Saying that it&#39;s close to how `!` behaves is not at all far from the<br>&gt; truth, because `!` has a precondition that its argument is non-nil.<br></p><p>I meant it as a much more exact analogy.<br></p><p>In a collections-move-indices world, you *could* handle indices as pointers have been handled, bringing in support from the type-system:<br></p><p>  enum SaferIndex&lt;T:Comparable&gt; {<br>    case Position(T)<br>    case End<br>  }<br></p><p>…(yes, this is more-or-less `Optional` by another name).<br></p><p>The assumption above is `T` would be today’s “Index” types, w/o the value used for `endIndex` (e.g. 0..&lt;self.count for an array, the non-`endIndex` values of `DictionaryIndex` and `SetIndex`, and so on).<br></p><p>It would’ve been awkward to do this under the previous status quo—e.g. even for arrays your indices would have to have a back-reference to get the count, and thus couldn’t be plain integers—but the collection will now always be present to provide such info.<br></p><p>Cons:<br></p><p>- more overhead than “bare” indices<br>- doesn’t address invalidation (but what does, really?)<br></p><p>Pros:<br></p><p>- easier in some ways to handle things like e.g 0…Int.max<br>- the endIndex equivalent *never* invalidates <br>- compile-time help for end-index checking<br></p><p>Overall this *would* bring the treatment of indices closer to that for `?`—e.g., redefine the core type to omit the `nil`-like value, use an enum to reintroduce that value when necessary—than to `!`.<br></p><p>I don’t think the above is an *improvement* over the proposal, but it’s a route that could have been taken.<br></p><p>&gt;&gt; To help illustrate the claim, here’s a strawman “safe” API—for illustration<br>&gt;&gt; only, not advocacy!—that would be safer and thus perhaps more “Swift-y”:<br>&gt; <br>&gt; I think there&#39;s a prevalent misunderstanding (IOW, I don&#39;t mean to<br>&gt; single out this post or this poster) about what “safe” means in Swift<br>&gt; and what the features of a Swifty API are and should be.  This<br>&gt; is a big topic worthy of much more time than I can devote here, but<br>&gt; here&#39;s a thought to start with:<br>&gt; <br>&gt; A Swifty API helps you reason effectively about the correctness of your<br>&gt; code, and in part that means we provide enough preconditions on<br>&gt; arguments to avoid complicating result types, and code to handle<br>&gt; results, with optional-ness.<br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160413/818d2ed4/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
