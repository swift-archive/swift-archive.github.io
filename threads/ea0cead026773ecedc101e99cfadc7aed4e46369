<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>May 13, 2016 at 09:00:00am</p></header><div class="content"><p>Matthew Johnson via swift-evolution &lt;swift-evolution at ...&gt; writes:<br></p><p>&gt; Consider the following example, under the current system:<br>&gt; protocol StringCreatable {<br>&gt;     static func createWithString(s: String) -&gt; Self<br>&gt; }<br>&gt; <br>&gt; extension NSURL: StringCreatable {<br>&gt;  // cannot conform because NSURL is non-final<br>&gt;  // error: method &#39;createWithString&#39; in non-final class &#39;NSURL&#39; must<br>&gt; return `Self` to conform to protocol &#39;A&#39;<br>&gt; }Introducing a static, invariant version of Self permits the desired<br>&gt; conformance:<br>&gt; protocol StringCreatable {<br>&gt;     static func createWithString(s: String) -&gt; StaticSelf<br>&gt; }<br></p><p>I&#39;m not convinced by this example.<br></p><p>I think the problem to solve here is the interaction of protocols with<br>classes.<br>A related issue was illustrated by Tony Allevato here<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502<br>/016294.html<br></p><p>I think that before attempting to solve this specific problem introducing a<br>new notation, the general design of the interaction between protocols and<br>class inheritance should be reviewed.<br></p><p><br>Nicola<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 13, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; I&#39;m not convinced by this example.<br></p><p>Probably my &amp; Matthew&#39;s previous discussion in `[swift-evolution] [RFC] <br>#Self` topic will help you. I was trying there to find out (in primitive <br>examples) what Matthew is trying to achive with this `-&gt;StaticSelf` in <br>protocol.<br></p><p>In two words - he wants to achieve requirement &#39;return Self class or any of <br>base classes&#39;, as current `-&gt;Self` requires &#39;strictly return Self class&#39;<br></p><p>On 13.05.2016 12:46, Nicola Salmoria via swift-evolution wrote:<br>&gt; Matthew Johnson via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt;<br>&gt;&gt; Consider the following example, under the current system:<br>&gt;&gt; protocol StringCreatable {<br>&gt;&gt;     static func createWithString(s: String) -&gt; Self<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension NSURL: StringCreatable {<br>&gt;&gt;  // cannot conform because NSURL is non-final<br>&gt;&gt;  // error: method &#39;createWithString&#39; in non-final class &#39;NSURL&#39; must<br>&gt;&gt; return `Self` to conform to protocol &#39;A&#39;<br>&gt;&gt; }Introducing a static, invariant version of Self permits the desired<br>&gt;&gt; conformance:<br>&gt;&gt; protocol StringCreatable {<br>&gt;&gt;     static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt; }<br>&gt;<br>&gt; I&#39;m not convinced by this example.<br>&gt;<br>&gt; I think the problem to solve here is the interaction of protocols with<br>&gt; classes.<br>&gt; A related issue was illustrated by Tony Allevato here<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502<br>&gt; /016294.html<br>&gt;<br>&gt; I think that before attempting to solve this specific problem introducing a<br>&gt; new notation, the general design of the interaction between protocols and<br>&gt; class inheritance should be reviewed.<br>&gt;<br>&gt;<br>&gt; Nicola<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>May 13, 2016 at 08:00:00pm</p></header><div class="content"><p>On Fri, May 13, 2016 at 12:55 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br></p><p>&gt; &gt; I&#39;m not convinced by this example.<br>&gt;<br>&gt; Probably my &amp; Matthew&#39;s previous discussion in `[swift-evolution] [RFC]<br>&gt; #Self` topic will help you. I was trying there to find out (in primitive<br>&gt; examples) what Matthew is trying to achive with this `-&gt;StaticSelf` in<br>&gt; protocol.<br>&gt;<br>&gt; In two words - he wants to achieve requirement &#39;return Self class or any<br>&gt; of base classes&#39;, as current `-&gt;Self` requires &#39;strictly return Self class&#39;<br>&gt;<br></p><p>I think I understand what the request is, but I&#39;m not sure if it&#39;s a<br>problem worth solving, and if this would be the right solution.<br></p><p>Going back to the example, let&#39;s say you have the requested<br></p><p>protocol Fooable {<br>    func foo() -&gt; StaticSelf<br>}<br></p><p>class A: Fooable {<br>    func foo() -&gt; A { return A() }<br>}<br></p><p>class B: A {<br>}<br></p><p>How would you use foo() in generic code?<br></p><p>func bar&lt;T: Fooable&gt;(_ x: T) -&gt; X {<br>    return x.foo()<br>}<br></p><p>What does bar() return? What do you put in place of X in its declaration?<br>You can&#39;t use T, you can&#39;t use T.StaticSelf. So what&#39;s the purpose of<br>having a protocol if you can&#39;t use it in generic code?<br></p><p><br>Nicola<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/f33b31ad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 13, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 13, 2016, at 1:11 PM, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Fri, May 13, 2016 at 12:55 PM, Vladimir.S &lt;svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt; &gt; I&#39;m not convinced by this example.<br>&gt; <br>&gt; Probably my &amp; Matthew&#39;s previous discussion in `[swift-evolution] [RFC] #Self` topic will help you. I was trying there to find out (in primitive examples) what Matthew is trying to achive with this `-&gt;StaticSelf` in protocol.<br>&gt; <br>&gt; In two words - he wants to achieve requirement &#39;return Self class or any of base classes&#39;, as current `-&gt;Self` requires &#39;strictly return Self class&#39;<br>&gt; <br>&gt; I think I understand what the request is, but I&#39;m not sure if it&#39;s a problem worth solving, and if this would be the right solution.<br>&gt;  <br>&gt; Going back to the example, let&#39;s say you have the requested<br>&gt; <br>&gt; protocol Fooable {<br>&gt;     func foo() -&gt; StaticSelf<br>&gt; }<br>&gt; <br>&gt; class A: Fooable {<br>&gt;     func foo() -&gt; A { return A() }<br>&gt; }<br>&gt; <br>&gt; class B: A {<br>&gt; }<br>&gt; <br>&gt; How would you use foo() in generic code?<br>&gt; <br>&gt; func bar&lt;T: Fooable&gt;(_ x: T) -&gt; X {<br>&gt;     return x.foo()<br>&gt; }<br>&gt; <br>&gt; What does bar() return? What do you put in place of X in its declaration?<br>&gt; You can&#39;t use T, you can&#39;t use T.StaticSelf. So what&#39;s the purpose of having a protocol if you can&#39;t use it in generic code?<br></p><p>This is a good question.  Thank you very much for providing a concrete example along with the question.<br></p><p>Let’s look at an example of what some of us have in mind:<br></p><p>protocol StringCreatable {<br>    static func createWithString(s: String) -&gt; StaticSelf<br>}<br></p><p>extension NSURL: StringCreatable {<br>    static func createWithString(s: String) -&gt; StaticSelf { <br>        // ...<br>    }<br>}<br></p><p>func foo&lt;Result: StringCreatable&gt;(s: String) -&gt; Result {<br>    return Result.createWithString(s: s)<br>}<br></p><p>Obviously this will not work properly because we are not guaranteed that `createWithString` returns Result (that is only possible if the return type is Self).  We would have to do the following:<br></p><p>protocol StringCreatable {<br>    typealias ConformingType = StaticSelf<br>    static func createWithString(s: String) -&gt; StaticSelf<br>}<br></p><p>func foo&lt;Result: StringCreatable where Result.ConformingType == Result&gt;(s: String) -&gt; Result {<br>    return Result.createWithString(s: s)<br>}<br></p><p>This requires same type constraints.  I believe that is coming as part of “completing generics”.  <br></p><p>However, it also raises a question: if the conformance afforded to subclasses can’t actually be used in a useful manner they probably shouldn’t have that conformance in the first place.  If the conformance isn’t inherited then we don’t need StaticSelf at all (we can just use Self and still conform the visible class of a class cluster).  This is the point Joe has been making all along.  Working through the example has helped me understand this point of view better.<br></p><p>I wonder if anyone has any other examples where subclass conformance would actually be useful.  If so, please share.  Those who are supporting this proposal: how do you envision using StaticSelf in your code?  What are some examples where you have had trouble due to the current limitations of the language?<br></p><p>-Matthew<br></p><p><br>&gt; <br>&gt; <br>&gt; Nicola<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/faddc0a1/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
