<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2e51f5d1f79b09442f62eef9702b8316?s=50"></div><header><strong>proper syntax for inout array handling?</strong> from <string>Ken Burgett</string> &lt;kenb at iotone.io&gt;<p>June  9, 2016 at 01:00:00pm</p></header><div class="content"><p>I am converting a very dirty C program to Swift3, and their is plenty of <br>pointer arithmetic to be dealt with.  As part of the effort, I have <br>created a &#39;memcpy clone to help with some of the transformation.<br>Here is the output from the REPL:<br>================================<br>   1. var source = [UInt8](repeating: 0x1f, count: 32)<br>   2. var destination = [UInt8](repeating: 0, count: 64)<br>   3.<br>   4. func memcpy(dest: inout [UInt8], src: inout [UInt8], count: Int)<br>   5. {<br>   6.   for ix in 0...count-1<br>   7.   {<br>   8.     dest[ix] = src[ix]<br>   9.   }<br>  10. }<br>  11.<br>  12. memcpy(dest: &amp;destination, src: &amp;source, count: 32 )<br>  13.<br>  14. memcpy(dest: &amp;destination[3], src: &amp;source, count: 13)<br>error: repl.swift:14:26: error: cannot convert value of type &#39;UInt8&#39; to <br>expected argument type &#39;[UInt8]&#39;<br>memcpy(dest: &amp;destination[3], src: &amp;source, count: 13)<br>==================================<br>which shows me that the compiler does not like the form of <br>&amp;destination[13], and doesn&#39;t treat it as a [UInt8].<br></p><p>What is the correct syntax for using a base + offset as a source or <br>destination for a memory copy?<br></p><p><br>-- <br>Ken Burgett<br>Principal Software Engineer<br>Email: kenb at iotone.io<br>Office: 530.693.4449<br>Mobile: 831.332.6846<br>URL: www.iotone.co<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>proper syntax for inout array handling?</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>June 10, 2016 at 02:00:00am</p></header><div class="content"><p>Swift handling of Arrays isn’t like C (for which you can use UnsafePointer)-you<br>don’t access the pointer of the third element. Instead, you can use Array<br>slices, which makes it a one liner:<br></p><p>destination[destinationStartIndex..&lt;destinationStartIndex + count] =<br>source[sourceStartIndex..&lt;sourceStartIndex + count]<br></p><p>In your case,<br></p><p>destination[0..&lt;0 + 32] = source[0..&lt;0 + 32]<br>destination[3..3 + 13] = source[0..&lt;0 + 13]<br></p><p>As a function:<br></p><p>func memcpy(source: [UInt8], destination: inout [UInt8],<br>sourceStartIndex: Int = 0, destinationStartIndex: Int = 0, count: Int)<br>{<br>    destination[destinationStartIndex..&lt;destinationStartIndex + count]<br>= source[sourceStartIndex..&lt;sourceStartIndex + count]<br>}<br></p><p>memcpy(source: source, destination: &amp;destination, count: 32)<br></p><p>memcpy(source: source, destination: &amp;destination,<br>destinationStartIndex: 3, count: 13)<br></p><p><br></p><p>On Thu, Jun 9, 2016 at 1:38 PM Ken Burgett via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; I am converting a very dirty C program to Swift3, and their is plenty of<br>&gt; pointer arithmetic to be dealt with.  As part of the effort, I have<br>&gt; created a &#39;memcpy clone to help with some of the transformation.<br>&gt; Here is the output from the REPL:<br>&gt; ================================<br>&gt;    1. var source = [UInt8](repeating: 0x1f, count: 32)<br>&gt;    2. var destination = [UInt8](repeating: 0, count: 64)<br>&gt;    3.<br>&gt;    4. func memcpy(dest: inout [UInt8], src: inout [UInt8], count: Int)<br>&gt;    5. {<br>&gt;    6.   for ix in 0...count-1<br>&gt;    7.   {<br>&gt;    8.     dest[ix] = src[ix]<br>&gt;    9.   }<br>&gt;   10. }<br>&gt;   11.<br>&gt;   12. memcpy(dest: &amp;destination, src: &amp;source, count: 32 )<br>&gt;   13.<br>&gt;   14. memcpy(dest: &amp;destination[3], src: &amp;source, count: 13)<br>&gt; error: repl.swift:14:26: error: cannot convert value of type &#39;UInt8&#39; to<br>&gt; expected argument type &#39;[UInt8]&#39;<br>&gt; memcpy(dest: &amp;destination[3], src: &amp;source, count: 13)<br>&gt; ==================================<br>&gt; which shows me that the compiler does not like the form of<br>&gt; &amp;destination[13], and doesn&#39;t treat it as a [UInt8].<br>&gt;<br>&gt; What is the correct syntax for using a base + offset as a source or<br>&gt; destination for a memory copy?<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Ken Burgett<br>&gt; Principal Software Engineer<br>&gt; Email: kenb at iotone.io<br>&gt; Office: 530.693.4449<br>&gt; Mobile: 831.332.6846<br>&gt; URL: www.iotone.co<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>-- <br>-Saagar Jha<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160610/5826f61b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>proper syntax for inout array handling?</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>June 10, 2016 at 03:00:00am</p></header><div class="content"><p>Nevermind, I lied. Swift does allow direct pointer arithmetic:<br></p><p>import Foundation<br></p><p>var source = [UInt8](repeating: 0x1f, count: 32)<br>var destination = [UInt8](repeating: 0, count: 64)<br></p><p>memcpy(&amp;destination, source, 32) // the C function<br></p><p>memcpy(&amp;destination + 3, source, 13) // the + operator works to offset<br></p><p><br></p><p>On Thu, Jun 9, 2016 at 7:21 PM Saagar Jha &lt;saagarjha28 at gmail.com&gt; wrote:<br></p><p>&gt; Swift handling of Arrays isn’t like C (for which you can use UnsafePointer)-you<br>&gt; don’t access the pointer of the third element. Instead, you can use Array<br>&gt; slices, which makes it a one liner:<br>&gt;<br>&gt; destination[destinationStartIndex..&lt;destinationStartIndex + count] = source[sourceStartIndex..&lt;sourceStartIndex + count]<br>&gt;<br>&gt; In your case,<br>&gt;<br>&gt; destination[0..&lt;0 + 32] = source[0..&lt;0 + 32]<br>&gt; destination[3..3 + 13] = source[0..&lt;0 + 13]<br>&gt;<br>&gt; As a function:<br>&gt;<br>&gt; func memcpy(source: [UInt8], destination: inout [UInt8], sourceStartIndex: Int = 0, destinationStartIndex: Int = 0, count: Int) {<br>&gt;     destination[destinationStartIndex..&lt;destinationStartIndex + count] = source[sourceStartIndex..&lt;sourceStartIndex + count]<br>&gt; }<br>&gt;<br>&gt; memcpy(source: source, destination: &amp;destination, count: 32)<br>&gt;<br>&gt; memcpy(source: source, destination: &amp;destination, destinationStartIndex: 3, count: 13)<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Thu, Jun 9, 2016 at 1:38 PM Ken Burgett via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I am converting a very dirty C program to Swift3, and their is plenty of<br>&gt;&gt; pointer arithmetic to be dealt with.  As part of the effort, I have<br>&gt;&gt; created a &#39;memcpy clone to help with some of the transformation.<br>&gt;&gt; Here is the output from the REPL:<br>&gt;&gt; ================================<br>&gt;&gt;    1. var source = [UInt8](repeating: 0x1f, count: 32)<br>&gt;&gt;    2. var destination = [UInt8](repeating: 0, count: 64)<br>&gt;&gt;    3.<br>&gt;&gt;    4. func memcpy(dest: inout [UInt8], src: inout [UInt8], count: Int)<br>&gt;&gt;    5. {<br>&gt;&gt;    6.   for ix in 0...count-1<br>&gt;&gt;    7.   {<br>&gt;&gt;    8.     dest[ix] = src[ix]<br>&gt;&gt;    9.   }<br>&gt;&gt;   10. }<br>&gt;&gt;   11.<br>&gt;&gt;   12. memcpy(dest: &amp;destination, src: &amp;source, count: 32 )<br>&gt;&gt;   13.<br>&gt;&gt;   14. memcpy(dest: &amp;destination[3], src: &amp;source, count: 13)<br>&gt;&gt; error: repl.swift:14:26: error: cannot convert value of type &#39;UInt8&#39; to<br>&gt;&gt; expected argument type &#39;[UInt8]&#39;<br>&gt;&gt; memcpy(dest: &amp;destination[3], src: &amp;source, count: 13)<br>&gt;&gt; ==================================<br>&gt;&gt; which shows me that the compiler does not like the form of<br>&gt;&gt; &amp;destination[13], and doesn&#39;t treat it as a [UInt8].<br>&gt;&gt;<br>&gt;&gt; What is the correct syntax for using a base + offset as a source or<br>&gt;&gt; destination for a memory copy?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Ken Burgett<br>&gt;&gt; Principal Software Engineer<br>&gt;&gt; Email: kenb at iotone.io<br>&gt;&gt; Office: 530.693.4449<br>&gt;&gt; Mobile: 831.332.6846<br>&gt;&gt; URL: www.iotone.co<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;<br>&gt; --<br>&gt; -Saagar Jha<br>&gt;<br>-- <br>-Saagar Jha<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160610/690b0d2d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>proper syntax for inout array handling?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>June  9, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 8:39 PM, Saagar Jha via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Nevermind, I lied. Swift does allow direct pointer arithmetic:<br>&gt; <br>&gt; import Foundation<br>&gt; <br>&gt; var source = [UInt8](repeating: 0x1f, count: 32)<br>&gt; var destination = [UInt8](repeating: 0, count: 64)<br>&gt; <br>&gt; memcpy(&amp;destination, source, 32) // the C function<br>&gt; <br>&gt; memcpy(&amp;destination + 3, source, 13) // the + operator works to offset<br></p><p>Arrays can indeed be used as pointer parameters, but the second one only works by accident. The pointer bridging has the same semantics as an &#39;inout&#39; parameter, so the pointer is only valid for the duration of the immediate call, and since operators in Swift are also function calls, the pointer expires after the &#39;+&#39; operation. If you&#39;re doing anything with an array other than passing it off to a single C function, you should use withUnsafeMutableBufferPointer instead:<br></p><p>destination.withUnsafeMutableBufferPointer { p in<br>  memcpy(p.baseAddress, source, 32)<br>  memcpy(p.baseAddress + 3, source, 13)<br>}<br></p><p>In addition to not having undefined behavior, this will also probably be faster, since it&#39;ll only need to pin the array for pointer access once instead of twice.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2e51f5d1f79b09442f62eef9702b8316?s=50"></div><header><strong>proper syntax for inout array handling?</strong> from <string>Ken Burgett</string> &lt;kenb at iotone.io&gt;<p>June 10, 2016 at 07:00:00am</p></header><div class="content"><p>On 2016-06-09 21:37, Joe Groff wrote:<br>&gt;&gt; On Jun 9, 2016, at 8:39 PM, Saagar Jha via swift-users <br>&gt;&gt; &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Nevermind, I lied. Swift does allow direct pointer arithmetic:<br>&gt;&gt; <br>&gt;&gt; import Foundation<br>&gt;&gt; <br>&gt;&gt; var source = [UInt8](repeating: 0x1f, count: 32)<br>&gt;&gt; var destination = [UInt8](repeating: 0, count: 64)<br>&gt;&gt; <br>&gt;&gt; memcpy(&amp;destination, source, 32) // the C function<br>&gt;&gt; <br>&gt;&gt; memcpy(&amp;destination + 3, source, 13) // the + operator works to offset<br>&gt; <br>&gt; Arrays can indeed be used as pointer parameters, but the second one<br>&gt; only works by accident. The pointer bridging has the same semantics as<br>&gt; an &#39;inout&#39; parameter, so the pointer is only valid for the duration of<br>&gt; the immediate call, and since operators in Swift are also function<br>&gt; calls, the pointer expires after the &#39;+&#39; operation. If you&#39;re doing<br>&gt; anything with an array other than passing it off to a single C<br>&gt; function, you should use withUnsafeMutableBufferPointer instead:<br>&gt; <br>&gt; destination.withUnsafeMutableBufferPointer { p in<br>&gt;   memcpy(p.baseAddress, source, 32)<br>&gt;   memcpy(p.baseAddress + 3, source, 13)<br>&gt; }<br>&gt; <br>&gt; In addition to not having undefined behavior, this will also probably<br>&gt; be faster, since it&#39;ll only need to pin the array for pointer access<br>&gt; once instead of twice.<br>&gt; <br>&gt; -Joe<br></p><p>Thanks for the good answers, both Saager and Joe.  I like the way you <br>both developed solutions and then improved them, and for good reasons.<br></p><p>I do have a situation in the ugly C code I am porting to Swift where a <br>pointer gets passed down to a second function, so Joe&#39;s solution looks <br>like the right approach.<br></p><p>Thanks again.<br>-- <br>Ken Burgett<br>Principal Software Engineer<br>Email: kenb at iotone.io<br>Office: 530.693.4449<br>Mobile: 831.332.6846<br>URL: www.iotone.co<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
