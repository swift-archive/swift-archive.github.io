<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 24, 2016 at 07:00:00pm</p></header><div class="content"><p>MOTIVATION:<br></p><p>SE-0083 appears to be dead in the water, having been deferred until later in Swift 3 back in May and not having been heard from since then, with the Swift 3 release looming closer and closer. However, the predictability gains that would have been provided by this change remain desirable for cases where one needs to know the actual dynamic type of an entity before any bridging magic is involved. Additionally, performance-critical code may desire the ability to check something’s type quickly without incurring the overhead of Objective-C bridging code.<br></p><p>PROPOSED SOLUTION:<br></p><p>I propose the following operators: really_is, really_as, really_as?, and really_as!. These operators would only return a positive result if the type actually was what was being asked for, instead of something that might be able to bridge to that type.<br></p><p>DETAILED DESIGN:<br></p><p>let foo: Any = &quot;Foo&quot;<br>let bar: Any = NSString(string: &quot;Bar&quot;)<br></p><p>let fooIsString = foo is String                  // true<br>let fooReallyIsString = foo really_is String     // true<br></p><p>let fooIsNSString = foo is NSString              // true<br>let fooReallyIsNSString = foo really_is NSString // false<br></p><p>let barIsString = bar is String                  // true<br>let barReallyIsString = bar really_is String     // false<br></p><p>let barIsNSString = bar is NSString              // true<br>let barReallyIsNSString = bar really_is NSString // true<br></p><p>ALTERNATIVES CONSIDERED:<br></p><p>Stick with using an unholy combination of Mirror and unsafeBitCast when you need to know what you’ve actually got.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/9a81f453/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 25, 2016 at 12:00:00am</p></header><div class="content"><p>import Foundation<br></p><p>let foo: Any = &quot;Hello&quot;<br>type(of: foo) == String.self // true<br>type(of: foo) == NSString.self // false<br></p><p>let bar: Any = &quot;Hello&quot; as NSString<br>type(of: bar) == String.self // false<br>type(of: bar) == NSString.self // true<br></p><p>Why not this?<br></p><p><br>On Wed, Aug 24, 2016 at 19:09 Charles Srstka via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; MOTIVATION:<br>&gt;<br>&gt; SE-0083 appears to be dead in the water, having been deferred until later<br>&gt; in Swift 3 back in May and not having been heard from since then, with the<br>&gt; Swift 3 release looming closer and closer. However, the predictability<br>&gt; gains that would have been provided by this change remain desirable for<br>&gt; cases where one needs to know the actual dynamic type of an entity before<br>&gt; any bridging magic is involved. Additionally, performance-critical code may<br>&gt; desire the ability to check something’s type quickly without incurring the<br>&gt; overhead of Objective-C bridging code.<br>&gt;<br>&gt; PROPOSED SOLUTION:<br>&gt;<br>&gt; I propose the following operators: really_is, really_as, really_as?, and<br>&gt; really_as!. These operators would only return a positive result if the type<br>&gt; actually was what was being asked for, instead of something that might be<br>&gt; able to bridge to that type.<br>&gt;<br>&gt; DETAILED DESIGN:<br>&gt;<br>&gt; let foo: Any = &quot;Foo&quot;<br>&gt; let bar: Any = NSString(string: &quot;Bar&quot;)<br>&gt;<br>&gt; let fooIsString = foo is String                  // true<br>&gt; let fooReallyIsString = foo really_is String     // true<br>&gt;<br>&gt; let fooIsNSString = foo is NSString              // true<br>&gt; let fooReallyIsNSString = foo really_is NSString // false<br>&gt;<br>&gt; let barIsString = bar is String                  // true<br>&gt; let barReallyIsString = bar really_is String     // false<br>&gt;<br>&gt; let barIsNSString = bar is NSString              // true<br>&gt; let barReallyIsNSString = bar really_is NSString // true<br>&gt;<br>&gt; ALTERNATIVES CONSIDERED:<br>&gt;<br>&gt; Stick with using an unholy combination of Mirror and unsafeBitCast when<br>&gt; you need to know what you’ve actually got.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160825/8087bdb9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e95942f1fe843f007ef5430b9acff78b?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Jaden Geller</string> &lt;jaden.geller at gmail.com&gt;<p>August 24, 2016 at 06:00:00pm</p></header><div class="content"><p>Taking that suggestion a step further, it&#39;s pretty easy to define a function that performs this sort of casting without bridging.<br></p><p>func unbridgedCast&lt;T, U&gt;(_ x: T, to: U.Type) -&gt; U? {<br>    guard type(of: x) == U.self else { return nil }<br>    return unsafeBitCast(x, to: U.self)<br>}<br></p><p>&gt; On Aug 24, 2016, at 5:42 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; import Foundation<br>&gt; <br>&gt; let foo: Any = &quot;Hello&quot;<br>&gt; type(of: foo) == String.self // true<br>&gt; type(of: foo) == NSString.self // false<br>&gt; <br>&gt; let bar: Any = &quot;Hello&quot; as NSString<br>&gt; type(of: bar) == String.self // false<br>&gt; type(of: bar) == NSString.self // true<br>&gt; <br>&gt; Why not this?<br>&gt; <br>&gt; <br>&gt; On Wed, Aug 24, 2016 at 19:09 Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; MOTIVATION:<br>&gt; <br>&gt; SE-0083 appears to be dead in the water, having been deferred until later in Swift 3 back in May and not having been heard from since then, with the Swift 3 release looming closer and closer. However, the predictability gains that would have been provided by this change remain desirable for cases where one needs to know the actual dynamic type of an entity before any bridging magic is involved. Additionally, performance-critical code may desire the ability to check something’s type quickly without incurring the overhead of Objective-C bridging code.<br>&gt; <br>&gt; PROPOSED SOLUTION:<br>&gt; <br>&gt; I propose the following operators: really_is, really_as, really_as?, and really_as!. These operators would only return a positive result if the type actually was what was being asked for, instead of something that might be able to bridge to that type.<br>&gt; <br>&gt; DETAILED DESIGN:<br>&gt; <br>&gt; let foo: Any = &quot;Foo&quot;<br>&gt; let bar: Any = NSString(string: &quot;Bar&quot;)<br>&gt; <br>&gt; let fooIsString = foo is String                  // true<br>&gt; let fooReallyIsString = foo really_is String     // true<br>&gt; <br>&gt; let fooIsNSString = foo is NSString              // true<br>&gt; let fooReallyIsNSString = foo really_is NSString // false<br>&gt; <br>&gt; let barIsString = bar is String                  // true<br>&gt; let barReallyIsString = bar really_is String     // false<br>&gt; <br>&gt; let barIsNSString = bar is NSString              // true<br>&gt; let barReallyIsNSString = bar really_is NSString // true<br>&gt; <br>&gt; ALTERNATIVES CONSIDERED:<br>&gt; <br>&gt; Stick with using an unholy combination of Mirror and unsafeBitCast when you need to know what you’ve actually got.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/b7776a91/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e95942f1fe843f007ef5430b9acff78b?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Jaden Geller</string> &lt;jaden.geller at gmail.com&gt;<p>August 24, 2016 at 06:00:00pm</p></header><div class="content"><p>Actually, the code I proposed does not work. First of all, it doesn&#39;t work for subtype relations. This can easily be fixed though by changing `== U.self` to `is U`. More importantly though, it fails when `T` is an existential since `type(of:)` looks within the existential to determine the type. It would be useful if there were a way to determine the *actual* runtime representation of the value.<br></p><p>&gt; On Aug 24, 2016, at 6:00 PM, Jaden Geller &lt;jaden.geller at gmail.com&gt; wrote:<br>&gt; <br>&gt; Taking that suggestion a step further, it&#39;s pretty easy to define a function that performs this sort of casting without bridging.<br>&gt; <br>&gt; func unbridgedCast&lt;T, U&gt;(_ x: T, to: U.Type) -&gt; U? {<br>&gt;     guard type(of: x) == U.self else { return nil }<br>&gt;     return unsafeBitCast(x, to: U.self)<br>&gt; }<br>&gt; <br>&gt;&gt; On Aug 24, 2016, at 5:42 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; import Foundation<br>&gt;&gt; <br>&gt;&gt; let foo: Any = &quot;Hello&quot;<br>&gt;&gt; type(of: foo) == String.self // true<br>&gt;&gt; type(of: foo) == NSString.self // false<br>&gt;&gt; <br>&gt;&gt; let bar: Any = &quot;Hello&quot; as NSString<br>&gt;&gt; type(of: bar) == String.self // false<br>&gt;&gt; type(of: bar) == NSString.self // true<br>&gt;&gt; <br>&gt;&gt; Why not this?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Wed, Aug 24, 2016 at 19:09 Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; MOTIVATION:<br>&gt;&gt; <br>&gt;&gt; SE-0083 appears to be dead in the water, having been deferred until later in Swift 3 back in May and not having been heard from since then, with the Swift 3 release looming closer and closer. However, the predictability gains that would have been provided by this change remain desirable for cases where one needs to know the actual dynamic type of an entity before any bridging magic is involved. Additionally, performance-critical code may desire the ability to check something’s type quickly without incurring the overhead of Objective-C bridging code.<br>&gt;&gt; <br>&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt; <br>&gt;&gt; I propose the following operators: really_is, really_as, really_as?, and really_as!. These operators would only return a positive result if the type actually was what was being asked for, instead of something that might be able to bridge to that type.<br>&gt;&gt; <br>&gt;&gt; DETAILED DESIGN:<br>&gt;&gt; <br>&gt;&gt; let foo: Any = &quot;Foo&quot;<br>&gt;&gt; let bar: Any = NSString(string: &quot;Bar&quot;)<br>&gt;&gt; <br>&gt;&gt; let fooIsString = foo is String                  // true<br>&gt;&gt; let fooReallyIsString = foo really_is String     // true<br>&gt;&gt; <br>&gt;&gt; let fooIsNSString = foo is NSString              // true<br>&gt;&gt; let fooReallyIsNSString = foo really_is NSString // false<br>&gt;&gt; <br>&gt;&gt; let barIsString = bar is String                  // true<br>&gt;&gt; let barReallyIsString = bar really_is String     // false<br>&gt;&gt; <br>&gt;&gt; let barIsNSString = bar is NSString              // true<br>&gt;&gt; let barReallyIsNSString = bar really_is NSString // true<br>&gt;&gt; <br>&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt; <br>&gt;&gt; Stick with using an unholy combination of Mirror and unsafeBitCast when you need to know what you’ve actually got.<br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/9c983bbe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e95942f1fe843f007ef5430b9acff78b?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Jaden Geller</string> &lt;jaden.geller at gmail.com&gt;<p>August 24, 2016 at 06:00:00pm</p></header><div class="content"><p>Scratch that last message. Determining what&#39;s stored in `Any` was Charles&#39;s original goal, and what I said made no sense. This should work:<br></p><p>func unbridgedCast&lt;T, U&gt;(_ x: T, to: U.Type) -&gt; U? {<br>    guard type(of: x) is U.Type else { return nil }<br>    return x as! U<br>}<br></p><p>if let x = unbridgedCast(x, to: String.self) { ... }<br></p><p>&gt; On Aug 24, 2016, at 6:06 PM, Jaden Geller &lt;jaden.geller at gmail.com&gt; wrote:<br>&gt; <br>&gt; Actually, the code I proposed does not work. First of all, it doesn&#39;t work for subtype relations. This can easily be fixed though by changing `== U.self` to `is U`. More importantly though, it fails when `T` is an existential since `type(of:)` looks within the existential to determine the type. It would be useful if there were a way to determine the *actual* runtime representation of the value.<br>&gt; <br>&gt;&gt; On Aug 24, 2016, at 6:00 PM, Jaden Geller &lt;jaden.geller at gmail.com &lt;mailto:jaden.geller at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Taking that suggestion a step further, it&#39;s pretty easy to define a function that performs this sort of casting without bridging.<br>&gt;&gt; <br>&gt;&gt; func unbridgedCast&lt;T, U&gt;(_ x: T, to: U.Type) -&gt; U? {<br>&gt;&gt;     guard type(of: x) == U.self else { return nil }<br>&gt;&gt;     return unsafeBitCast(x, to: U.self)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 24, 2016, at 5:42 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; import Foundation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let foo: Any = &quot;Hello&quot;<br>&gt;&gt;&gt; type(of: foo) == String.self // true<br>&gt;&gt;&gt; type(of: foo) == NSString.self // false<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let bar: Any = &quot;Hello&quot; as NSString<br>&gt;&gt;&gt; type(of: bar) == String.self // false<br>&gt;&gt;&gt; type(of: bar) == NSString.self // true<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why not this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Aug 24, 2016 at 19:09 Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; MOTIVATION:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; SE-0083 appears to be dead in the water, having been deferred until later in Swift 3 back in May and not having been heard from since then, with the Swift 3 release looming closer and closer. However, the predictability gains that would have been provided by this change remain desirable for cases where one needs to know the actual dynamic type of an entity before any bridging magic is involved. Additionally, performance-critical code may desire the ability to check something’s type quickly without incurring the overhead of Objective-C bridging code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose the following operators: really_is, really_as, really_as?, and really_as!. These operators would only return a positive result if the type actually was what was being asked for, instead of something that might be able to bridge to that type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; DETAILED DESIGN:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let foo: Any = &quot;Foo&quot;<br>&gt;&gt;&gt; let bar: Any = NSString(string: &quot;Bar&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fooIsString = foo is String                  // true<br>&gt;&gt;&gt; let fooReallyIsString = foo really_is String     // true<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fooIsNSString = foo is NSString              // true<br>&gt;&gt;&gt; let fooReallyIsNSString = foo really_is NSString // false<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let barIsString = bar is String                  // true<br>&gt;&gt;&gt; let barReallyIsString = bar really_is String     // false<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let barIsNSString = bar is NSString              // true<br>&gt;&gt;&gt; let barReallyIsNSString = bar really_is NSString // true<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Stick with using an unholy combination of Mirror and unsafeBitCast when you need to know what you’ve actually got.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Charles<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/66d07916/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e95942f1fe843f007ef5430b9acff78b?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Jaden Geller</string> &lt;jaden.geller at gmail.com&gt;<p>August 24, 2016 at 06:00:00pm</p></header><div class="content"><p>Though this performs an *extra* check over just `x as! U`, it avoids bridging conversions. I don&#39;t think this extra check matters though because you wouldn&#39;t be using `Any` in code that&#39;s performance critical enough for this to matter, so I&#39;m currently -1 on this proposal.<br></p><p>&gt; On Aug 24, 2016, at 6:09 PM, Jaden Geller &lt;jaden.geller at gmail.com&gt; wrote:<br>&gt; <br>&gt; Scratch that last message. Determining what&#39;s stored in `Any` was Charles&#39;s original goal, and what I said made no sense. This should work:<br>&gt; <br>&gt; func unbridgedCast&lt;T, U&gt;(_ x: T, to: U.Type) -&gt; U? {<br>&gt;     guard type(of: x) is U.Type else { return nil }<br>&gt;     return x as! U<br>&gt; }<br>&gt; <br>&gt; if let x = unbridgedCast(x, to: String.self) { ... }<br>&gt; <br>&gt;&gt; On Aug 24, 2016, at 6:06 PM, Jaden Geller &lt;jaden.geller at gmail.com &lt;mailto:jaden.geller at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Actually, the code I proposed does not work. First of all, it doesn&#39;t work for subtype relations. This can easily be fixed though by changing `== U.self` to `is U`. More importantly though, it fails when `T` is an existential since `type(of:)` looks within the existential to determine the type. It would be useful if there were a way to determine the *actual* runtime representation of the value.<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 24, 2016, at 6:00 PM, Jaden Geller &lt;jaden.geller at gmail.com &lt;mailto:jaden.geller at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Taking that suggestion a step further, it&#39;s pretty easy to define a function that performs this sort of casting without bridging.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func unbridgedCast&lt;T, U&gt;(_ x: T, to: U.Type) -&gt; U? {<br>&gt;&gt;&gt;     guard type(of: x) == U.self else { return nil }<br>&gt;&gt;&gt;     return unsafeBitCast(x, to: U.self)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 24, 2016, at 5:42 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; import Foundation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let foo: Any = &quot;Hello&quot;<br>&gt;&gt;&gt;&gt; type(of: foo) == String.self // true<br>&gt;&gt;&gt;&gt; type(of: foo) == NSString.self // false<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let bar: Any = &quot;Hello&quot; as NSString<br>&gt;&gt;&gt;&gt; type(of: bar) == String.self // false<br>&gt;&gt;&gt;&gt; type(of: bar) == NSString.self // true<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Why not this?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Aug 24, 2016 at 19:09 Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; MOTIVATION:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; SE-0083 appears to be dead in the water, having been deferred until later in Swift 3 back in May and not having been heard from since then, with the Swift 3 release looming closer and closer. However, the predictability gains that would have been provided by this change remain desirable for cases where one needs to know the actual dynamic type of an entity before any bridging magic is involved. Additionally, performance-critical code may desire the ability to check something’s type quickly without incurring the overhead of Objective-C bridging code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I propose the following operators: really_is, really_as, really_as?, and really_as!. These operators would only return a positive result if the type actually was what was being asked for, instead of something that might be able to bridge to that type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; DETAILED DESIGN:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let foo: Any = &quot;Foo&quot;<br>&gt;&gt;&gt;&gt; let bar: Any = NSString(string: &quot;Bar&quot;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fooIsString = foo is String                  // true<br>&gt;&gt;&gt;&gt; let fooReallyIsString = foo really_is String     // true<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fooIsNSString = foo is NSString              // true<br>&gt;&gt;&gt;&gt; let fooReallyIsNSString = foo really_is NSString // false<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let barIsString = bar is String                  // true<br>&gt;&gt;&gt;&gt; let barReallyIsString = bar really_is String     // false<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let barIsNSString = bar is NSString              // true<br>&gt;&gt;&gt;&gt; let barReallyIsNSString = bar really_is NSString // true<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Stick with using an unholy combination of Mirror and unsafeBitCast when you need to know what you’ve actually got.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/5fd7e13f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0411520c60ef1131670f84bb42dc8949?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Swift)</string> &lt;swift-callionica at callionica.com (Callionica&gt;<p>August 24, 2016 at 06:00:00pm</p></header><div class="content"><p>I used this several months ago for extracting data from Any:<br></p><p>// Dynamic cast without bridging<br>func dynamicCast&lt;T&gt;(_ type: T.Type, _ v: Any)-&gt;T? {<br>    guard let result = v as? T where v.dynamicType is T.Type else {<br>        return nil;<br>    }<br>    return result<br>}<br></p><p>from http://www.callionica.com/developer/#any-equals<br></p><p>based on suggestion from Joe Groff<br></p><p><br>On Wed, Aug 24, 2016 at 6:11 PM, Jaden Geller via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Though this performs an *extra* check over just `x as! U`, it avoids<br>&gt; bridging conversions. I don&#39;t think this extra check matters though because<br>&gt; you wouldn&#39;t be using `Any` in code that&#39;s performance critical enough for<br>&gt; this to matter, so I&#39;m currently -1 on this proposal.<br>&gt;<br>&gt; On Aug 24, 2016, at 6:09 PM, Jaden Geller &lt;jaden.geller at gmail.com&gt; wrote:<br>&gt;<br>&gt; Scratch that last message. Determining what&#39;s stored in `Any` was<br>&gt; Charles&#39;s original goal, and what I said made no sense. This should work:<br>&gt;<br>&gt; func unbridgedCast&lt;T, U&gt;(_ x: T, to: U.Type) -&gt; U? {<br>&gt;     guard type(of: x) is U.Type else { return nil }<br>&gt;     return x as! U<br>&gt; }<br>&gt;<br>&gt; if let x = unbridgedCast(x, to: String.self) { ... }<br>&gt;<br>&gt; On Aug 24, 2016, at 6:06 PM, Jaden Geller &lt;jaden.geller at gmail.com&gt; wrote:<br>&gt;<br>&gt; Actually, the code I proposed does not work. First of all, it doesn&#39;t work<br>&gt; for subtype relations. This can easily be fixed though by changing `==<br>&gt; U.self` to `is U`. More importantly though, it fails when `T` is an<br>&gt; existential since `type(of:)` looks within the existential to determine the<br>&gt; type. It would be useful if there were a way to determine the *actual*<br>&gt; runtime representation of the value.<br>&gt;<br>&gt; On Aug 24, 2016, at 6:00 PM, Jaden Geller &lt;jaden.geller at gmail.com&gt; wrote:<br>&gt;<br>&gt; Taking that suggestion a step further, it&#39;s pretty easy to define a<br>&gt; function that performs this sort of casting without bridging.<br>&gt;<br>&gt; func unbridgedCast&lt;T, U&gt;(_ x: T, to: U.Type) -&gt; U? {<br>&gt;     guard type(of: x) == U.self else { return nil }<br>&gt;     return unsafeBitCast(x, to: U.self)<br>&gt; }<br>&gt;<br>&gt; On Aug 24, 2016, at 5:42 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; import Foundation<br>&gt;<br>&gt; let foo: Any = &quot;Hello&quot;<br>&gt; type(of: foo) == String.self // true<br>&gt; type(of: foo) == NSString.self // false<br>&gt;<br>&gt; let bar: Any = &quot;Hello&quot; as NSString<br>&gt; type(of: bar) == String.self // false<br>&gt; type(of: bar) == NSString.self // true<br>&gt;<br>&gt; Why not this?<br>&gt;<br>&gt;<br>&gt; On Wed, Aug 24, 2016 at 19:09 Charles Srstka via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; MOTIVATION:<br>&gt;&gt;<br>&gt;&gt; SE-0083 appears to be dead in the water, having been deferred until later<br>&gt;&gt; in Swift 3 back in May and not having been heard from since then, with the<br>&gt;&gt; Swift 3 release looming closer and closer. However, the predictability<br>&gt;&gt; gains that would have been provided by this change remain desirable for<br>&gt;&gt; cases where one needs to know the actual dynamic type of an entity before<br>&gt;&gt; any bridging magic is involved. Additionally, performance-critical code may<br>&gt;&gt; desire the ability to check something’s type quickly without incurring the<br>&gt;&gt; overhead of Objective-C bridging code.<br>&gt;&gt;<br>&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt;<br>&gt;&gt; I propose the following operators: really_is, really_as, really_as?, and<br>&gt;&gt; really_as!. These operators would only return a positive result if the type<br>&gt;&gt; actually was what was being asked for, instead of something that might be<br>&gt;&gt; able to bridge to that type.<br>&gt;&gt;<br>&gt;&gt; DETAILED DESIGN:<br>&gt;&gt;<br>&gt;&gt; let foo: Any = &quot;Foo&quot;<br>&gt;&gt; let bar: Any = NSString(string: &quot;Bar&quot;)<br>&gt;&gt;<br>&gt;&gt; let fooIsString = foo is String                  // true<br>&gt;&gt; let fooReallyIsString = foo really_is String     // true<br>&gt;&gt;<br>&gt;&gt; let fooIsNSString = foo is NSString              // true<br>&gt;&gt; let fooReallyIsNSString = foo really_is NSString // false<br>&gt;&gt;<br>&gt;&gt; let barIsString = bar is String                  // true<br>&gt;&gt; let barReallyIsString = bar really_is String     // false<br>&gt;&gt;<br>&gt;&gt; let barIsNSString = bar is NSString              // true<br>&gt;&gt; let barReallyIsNSString = bar really_is NSString // true<br>&gt;&gt;<br>&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt;<br>&gt;&gt; Stick with using an unholy combination of Mirror and unsafeBitCast when<br>&gt;&gt; you need to know what you’ve actually got.<br>&gt;&gt;<br>&gt;&gt; Charles<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/799a8297/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 24, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Aug 24, 2016, at 8:09 PM, Jaden Geller &lt;jaden.geller at gmail.com&gt; wrote:<br>&gt; <br>&gt; Scratch that last message. Determining what&#39;s stored in `Any` was Charles&#39;s original goal, and what I said made no sense. This should work:<br>&gt; <br>&gt; func unbridgedCast&lt;T, U&gt;(_ x: T, to: U.Type) -&gt; U? {<br>&gt;     guard type(of: x) is U.Type else { return nil }<br>&gt;     return x as! U<br>&gt; }<br>&gt; <br>&gt; if let x = unbridgedCast(x, to: String.self) { … }<br></p><p>Hmm, this one actually does seem to work. I had expected that type(of:) would be bridged as well. Thanks; this is definitely better than the Mirror workaround, at least.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/29320da5/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 24, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Aug 24, 2016, at 7:42 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; import Foundation<br>&gt; <br>&gt; let foo: Any = &quot;Hello&quot;<br>&gt; type(of: foo) == String.self // true<br>&gt; type(of: foo) == NSString.self // false<br>&gt; <br>&gt; let bar: Any = &quot;Hello&quot; as NSString<br>&gt; type(of: bar) == String.self // false<br>&gt; type(of: bar) == NSString.self // true<br>&gt; <br>&gt; Why not this?<br></p><p>Because if you actually try that, it doesn’t work. type(of: bar) == NSString.self actually returns false, not true, because the actual instance belongs to a private subclass of NSString, not NSString itself. type(of: bar) == NSClassFromString(“__NSCFString”) works, but that doesn’t really help us.<br></p><p>Charles<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/427314a1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 24, 2016 at 09:00:00pm</p></header><div class="content"><p>Works on Linux :)<br></p><p>On Wed, Aug 24, 2016 at 9:44 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Aug 24, 2016, at 7:42 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; import Foundation<br>&gt;<br>&gt; let foo: Any = &quot;Hello&quot;<br>&gt; type(of: foo) == String.self // true<br>&gt; type(of: foo) == NSString.self // false<br>&gt;<br>&gt; let bar: Any = &quot;Hello&quot; as NSString<br>&gt; type(of: bar) == String.self // false<br>&gt; type(of: bar) == NSString.self // true<br>&gt;<br>&gt; Why not this?<br>&gt;<br>&gt;<br>&gt; Because if you actually try that, it doesn’t work. type(of: bar) ==<br>&gt; NSString.self actually returns false, not true, because the actual instance<br>&gt; belongs to a private subclass of NSString, not NSString itself. type(of:<br>&gt; bar) == NSClassFromString(“__NSCFString”) works, but that doesn’t really<br>&gt; help us.<br>&gt;<br>&gt; Charles<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/9fb469f7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 24, 2016 at 09:00:00pm</p></header><div class="content"><p>On Wed, Aug 24, 2016 at 9:47 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; Works on Linux :)<br>&gt;<br></p><p>And besides, on any platform where `type(of: bar) != NSString`, why should<br>you expect `bar really_is NSString == true`? Isn&#39;t bar *not really*<br>NSString?<br></p><p>On Wed, Aug 24, 2016 at 9:44 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Aug 24, 2016, at 7:42 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; import Foundation<br>&gt;&gt;<br>&gt;&gt; let foo: Any = &quot;Hello&quot;<br>&gt;&gt; type(of: foo) == String.self // true<br>&gt;&gt; type(of: foo) == NSString.self // false<br>&gt;&gt;<br>&gt;&gt; let bar: Any = &quot;Hello&quot; as NSString<br>&gt;&gt; type(of: bar) == String.self // false<br>&gt;&gt; type(of: bar) == NSString.self // true<br>&gt;&gt;<br>&gt;&gt; Why not this?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Because if you actually try that, it doesn’t work. type(of: bar) ==<br>&gt;&gt; NSString.self actually returns false, not true, because the actual instance<br>&gt;&gt; belongs to a private subclass of NSString, not NSString itself. type(of:<br>&gt;&gt; bar) == NSClassFromString(“__NSCFString”) works, but that doesn’t really<br>&gt;&gt; help us.<br>&gt;&gt;<br>&gt;&gt; Charles<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/aa3b2340/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 24, 2016 at 09:00:00pm</p></header><div class="content"><p>On Wed, Aug 24, 2016 at 9:51 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; On Wed, Aug 24, 2016 at 9:47 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; Works on Linux :)<br>&gt;&gt;<br>&gt;<br>&gt; And besides, on any platform where `type(of: bar) != NSString`, why should<br>&gt; you expect `bar really_is NSString == true`? Isn&#39;t bar *not really*<br>&gt; NSString?<br>&gt;<br></p><p>Ack, I take that back. __NSCFString is a subclass of NSString. Thus, this<br>works on macOS, as expected:<br></p><p>```<br>type(of: bar) is NSString.Type // true<br>type(of: bar) is String.Type // false<br>```<br></p><p>On Wed, Aug 24, 2016 at 9:44 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Aug 24, 2016, at 7:42 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; import Foundation<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let foo: Any = &quot;Hello&quot;<br>&gt;&gt;&gt; type(of: foo) == String.self // true<br>&gt;&gt;&gt; type(of: foo) == NSString.self // false<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let bar: Any = &quot;Hello&quot; as NSString<br>&gt;&gt;&gt; type(of: bar) == String.self // false<br>&gt;&gt;&gt; type(of: bar) == NSString.self // true<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Why not this?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Because if you actually try that, it doesn’t work. type(of: bar) ==<br>&gt;&gt;&gt; NSString.self actually returns false, not true, because the actual instance<br>&gt;&gt;&gt; belongs to a private subclass of NSString, not NSString itself. type(of:<br>&gt;&gt;&gt; bar) == NSClassFromString(“__NSCFString”) works, but that doesn’t<br>&gt;&gt;&gt; really help us.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/4672d3a6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 24, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Aug 24, 2016, at 9:51 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Aug 24, 2016 at 9:47 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt; Works on Linux :)<br>&gt; <br>&gt; And besides, on any platform where `type(of: bar) != NSString`, why should you expect `bar really_is NSString == true`? Isn&#39;t bar *not really* NSString?<br></p><p>Because the pitch was for a version of ‘is’ which lacks the Objective-C bridging. The ‘is’ keyword matches subclasses of the type you specify as well as the type itself.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/2308c53e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 24, 2016 at 10:00:00pm</p></header><div class="content"><p>On Wed, Aug 24, 2016 at 9:58 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Aug 24, 2016, at 9:51 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Aug 24, 2016 at 9:47 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; Works on Linux :)<br>&gt;&gt;<br>&gt;<br>&gt; And besides, on any platform where `type(of: bar) != NSString`, why should<br>&gt; you expect `bar really_is NSString == true`? Isn&#39;t bar *not really*<br>&gt; NSString?<br>&gt;<br>&gt;<br>&gt; Because the pitch was for a version of ‘is’ which lacks the Objective-C<br>&gt; bridging. The ‘is’ keyword matches subclasses of the type you specify as<br>&gt; well as the type itself.<br>&gt;<br></p><p>Sorry, I corrected myself :) I neglected the part where you mentioned that<br>__NSCFString is a subclass of NSString (which I forgot was the case). But<br>as you can see, `type(of: bar) is NSString.Type` works just fine :)<br></p><p><br></p><p>&gt; Charles<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/0297f67e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 24, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Aug 24, 2016, at 10:00 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Aug 24, 2016 at 9:58 PM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt; On Aug 24, 2016, at 9:51 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Aug 24, 2016 at 9:47 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; Works on Linux :)<br>&gt;&gt; <br>&gt;&gt; And besides, on any platform where `type(of: bar) != NSString`, why should you expect `bar really_is NSString == true`? Isn&#39;t bar *not really* NSString?<br>&gt; <br>&gt; Because the pitch was for a version of ‘is’ which lacks the Objective-C bridging. The ‘is’ keyword matches subclasses of the type you specify as well as the type itself.<br>&gt; <br>&gt; Sorry, I corrected myself :) I neglected the part where you mentioned that __NSCFString is a subclass of NSString (which I forgot was the case). But as you can see, `type(of: bar) is NSString.Type` works just fine :)<br></p><p>Yeah, it does; thanks. I thought that ‘is’ on the type would be compromised in the same way as it normally is, so it’s good to know that there’s a way to make it honest. I still hate the bridging, and wish that SE-0083 were not apparently dead, but grumble grumble grumble, at least there’s a workaround. Is this documented anywhere?<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/bb2219f7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 24, 2016 at 10:00:00pm</p></header><div class="content"><p>On Wed, Aug 24, 2016 at 10:07 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Aug 24, 2016, at 10:00 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Wed, Aug 24, 2016 at 9:58 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>&gt;  wrote:<br>&gt;<br>&gt;&gt; On Aug 24, 2016, at 9:51 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Wed, Aug 24, 2016 at 9:47 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Works on Linux :)<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; And besides, on any platform where `type(of: bar) != NSString`, why<br>&gt;&gt; should you expect `bar really_is NSString == true`? Isn&#39;t bar *not really*<br>&gt;&gt; NSString?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Because the pitch was for a version of ‘is’ which lacks the Objective-C<br>&gt;&gt; bridging. The ‘is’ keyword matches subclasses of the type you specify as<br>&gt;&gt; well as the type itself.<br>&gt;&gt;<br>&gt;<br>&gt; Sorry, I corrected myself :) I neglected the part where you mentioned that<br>&gt; __NSCFString is a subclass of NSString (which I forgot was the case). But<br>&gt; as you can see, `type(of: bar) is NSString.Type` works just fine :)<br>&gt;<br>&gt;<br>&gt; Yeah, it does; thanks. I thought that ‘is’ on the type would be<br>&gt; compromised in the same way as it normally is, so it’s good to know that<br>&gt; there’s a way to make it honest. I still hate the bridging, and wish that<br>&gt; SE-0083 were not apparently dead, but grumble grumble grumble, at least<br>&gt; there’s a workaround. Is this documented anywhere?<br>&gt;<br></p><p>This is where I&#39;m out of my depth, but I&#39;ll take a stab at it:<br>I _think_ the metatype itself is bridgeable, but it can&#39;t lie about the<br>type-of-which-the-metatype-is-the-type.<br></p><p><br>&gt; Charles<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/2ad44218/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>August 24, 2016 at 07:00:00pm</p></header><div class="content"><p>I have 3 qualms with this proposal as it stands:<br></p><p>- type(of:) will never lie to you. <br></p><p>The only question it won’t answer to your satisfaction is the dynamic type of the NSString you boxed up as an Any.<br></p><p>- No more keywords without significant justification.  <br></p><p>I don’t buy the performance use case at all - if you were properly concerned about performance you would try to use as many of Swift’s static features as possible.<br></p><p>- Especially no more keywords that look like they belong in Rust or PHP!<br></p><p>There is no precedent for the spelling of these operations other than the suffixed punctuation. Given that they’re domain-specific, will definitely be hard to use (given that NSString(string: &quot;Bar”) may not “really” given you an NSString yet that’s what you asked us to check for “really&quot;), and will be obviated by the implementation of SE-0083, I can’t see a reason why we need any of this in the language proper.<br></p><p>~Robert Widmann<br></p><p>&gt; On Aug 24, 2016, at 5:08 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; MOTIVATION:<br>&gt; <br>&gt; SE-0083 appears to be dead in the water, having been deferred until later in Swift 3 back in May and not having been heard from since then, with the Swift 3 release looming closer and closer. However, the predictability gains that would have been provided by this change remain desirable for cases where one needs to know the actual dynamic type of an entity before any bridging magic is involved. Additionally, performance-critical code may desire the ability to check something’s type quickly without incurring the overhead of Objective-C bridging code.<br>&gt; <br>&gt; PROPOSED SOLUTION:<br>&gt; <br>&gt; I propose the following operators: really_is, really_as, really_as?, and really_as!. These operators would only return a positive result if the type actually was what was being asked for, instead of something that might be able to bridge to that type.<br>&gt; <br>&gt; DETAILED DESIGN:<br>&gt; <br>&gt; let foo: Any = &quot;Foo&quot;<br>&gt; let bar: Any = NSString(string: &quot;Bar&quot;)<br>&gt; <br>&gt; let fooIsString = foo is String                  // true<br>&gt; let fooReallyIsString = foo really_is String     // true<br>&gt; <br>&gt; let fooIsNSString = foo is NSString              // true<br>&gt; let fooReallyIsNSString = foo really_is NSString // false<br>&gt; <br>&gt; let barIsString = bar is String                  // true<br>&gt; let barReallyIsString = bar really_is String     // false<br>&gt; <br>&gt; let barIsNSString = bar is NSString              // true<br>&gt; let barReallyIsNSString = bar really_is NSString // true<br>&gt; <br>&gt; ALTERNATIVES CONSIDERED:<br>&gt; <br>&gt; Stick with using an unholy combination of Mirror and unsafeBitCast when you need to know what you’ve actually got.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/290122d3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>August 24, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Aug 24, 2016, at 9:09 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have 3 qualms with this proposal as it stands:<br>&gt; <br>&gt; - type(of:) will never lie to you. <br>&gt; <br>&gt; The only question it won’t answer to your satisfaction is the dynamic type of the NSString you boxed up as an Any.<br>&gt; <br>&gt; - No more keywords without significant justification.  <br>&gt; <br>&gt; I don’t buy the performance use case at all - if you were properly concerned about performance you would try to use as many of Swift’s static features as possible.<br>&gt; <br>&gt; - Especially no more keywords that look like they belong in Rust or PHP!<br>&gt; <br>&gt; There is no precedent for the spelling of these operations other than the suffixed punctuation. Given that they’re domain-specific, will definitely be hard to use (given that NSString(string: &quot;Bar”) may not “really” given you an NSString yet that’s what you asked us to check for “really&quot;), and will be obviated by the implementation of SE-0083, I can’t see a reason why we need any of this in the language proper.<br></p><p>One related topic to consider is exhaustive pattern matching for classes.  Now that SE-0117 has been accepted it will be possible to do this for many classes (I would say most if it weren’t for Objective-C classes being so common in Swift and are imported as `open`).  Supporting exhaustive pattern matching well would require some kind of syntax for matching the runtime type exactly.  I have imagined this as being “exact match” cast operators, which is what the `really_*` operators are.  Do you have an alternative in mind for exhaustive pattern matching if we do not introduce exact match cast operators?<br></p><p>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt;&gt; On Aug 24, 2016, at 5:08 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; MOTIVATION:<br>&gt;&gt; <br>&gt;&gt; SE-0083 appears to be dead in the water, having been deferred until later in Swift 3 back in May and not having been heard from since then, with the Swift 3 release looming closer and closer. However, the predictability gains that would have been provided by this change remain desirable for cases where one needs to know the actual dynamic type of an entity before any bridging magic is involved. Additionally, performance-critical code may desire the ability to check something’s type quickly without incurring the overhead of Objective-C bridging code.<br>&gt;&gt; <br>&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt; <br>&gt;&gt; I propose the following operators: really_is, really_as, really_as?, and really_as!. These operators would only return a positive result if the type actually was what was being asked for, instead of something that might be able to bridge to that type.<br>&gt;&gt; <br>&gt;&gt; DETAILED DESIGN:<br>&gt;&gt; <br>&gt;&gt; let foo: Any = &quot;Foo&quot;<br>&gt;&gt; let bar: Any = NSString(string: &quot;Bar&quot;)<br>&gt;&gt; <br>&gt;&gt; let fooIsString = foo is String                  // true<br>&gt;&gt; let fooReallyIsString = foo really_is String     // true<br>&gt;&gt; <br>&gt;&gt; let fooIsNSString = foo is NSString              // true<br>&gt;&gt; let fooReallyIsNSString = foo really_is NSString // false<br>&gt;&gt; <br>&gt;&gt; let barIsString = bar is String                  // true<br>&gt;&gt; let barReallyIsString = bar really_is String     // false<br>&gt;&gt; <br>&gt;&gt; let barIsNSString = bar is NSString              // true<br>&gt;&gt; let barReallyIsNSString = bar really_is NSString // true<br>&gt;&gt; <br>&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt; <br>&gt;&gt; Stick with using an unholy combination of Mirror and unsafeBitCast when you need to know what you’ve actually got.<br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/97321362/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 24, 2016 at 09:00:00pm</p></header><div class="content"><p>On Wed, Aug 24, 2016 at 9:25 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Aug 24, 2016, at 9:09 PM, Robert Widmann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I have 3 qualms with this proposal as it stands:<br>&gt;<br>&gt; - type(of:) will never lie to you.<br>&gt;<br>&gt; The only question it won’t answer to your satisfaction is the dynamic type<br>&gt; of the NSString you boxed up as an Any.<br>&gt;<br>&gt; - No more keywords without significant justification.<br>&gt;<br>&gt; I don’t buy the performance use case at all - if you were properly<br>&gt; concerned about performance you would try to use as many of Swift’s static<br>&gt; features as possible.<br>&gt;<br>&gt; - Especially no more keywords that look like they belong in Rust or PHP!<br>&gt;<br>&gt; There is no precedent for the spelling of these operations other than the<br>&gt; suffixed punctuation. Given that they’re domain-specific, will definitely<br>&gt; be hard to use (given that NSString(string: &quot;Bar”) may not “really” given<br>&gt; you an NSString yet that’s what you asked us to check for “*really*&quot;),<br>&gt; and will be obviated by the implementation of SE-0083, I can’t see a reason<br>&gt; why we need any of this in the language proper.<br>&gt;<br>&gt;<br>&gt; One related topic to consider is exhaustive pattern matching for classes.<br>&gt; Now that SE-0117 has been accepted it will be possible to do this for many<br>&gt; classes (I would say most if it weren’t for Objective-C classes being so<br>&gt; common in Swift and are imported as `open`).  Supporting exhaustive pattern<br>&gt; matching well would require some kind of syntax for matching the runtime<br>&gt; type exactly.  I have imagined this as being “exact match” cast operators,<br>&gt; which is what the `really_*` operators are.<br>&gt;<br></p><p>I don&#39;t understand. As pitched, these operators remove bridging magic, but<br>`Subclass really_is Superclass == true`. How would you use this for classes?<br></p><p><br>&gt; Do you have an alternative in mind for exhaustive pattern matching if we<br>&gt; do not introduce exact match cast operators?<br>&gt;<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt; On Aug 24, 2016, at 5:08 PM, Charles Srstka via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; MOTIVATION:<br>&gt;<br>&gt; SE-0083 appears to be dead in the water, having been deferred until later<br>&gt; in Swift 3 back in May and not having been heard from since then, with the<br>&gt; Swift 3 release looming closer and closer. However, the predictability<br>&gt; gains that would have been provided by this change remain desirable for<br>&gt; cases where one needs to know the actual dynamic type of an entity before<br>&gt; any bridging magic is involved. Additionally, performance-critical code may<br>&gt; desire the ability to check something’s type quickly without incurring the<br>&gt; overhead of Objective-C bridging code.<br>&gt;<br>&gt; PROPOSED SOLUTION:<br>&gt;<br>&gt; I propose the following operators: really_is, really_as, really_as?, and<br>&gt; really_as!. These operators would only return a positive result if the type<br>&gt; actually was what was being asked for, instead of something that might be<br>&gt; able to bridge to that type.<br>&gt;<br>&gt; DETAILED DESIGN:<br>&gt;<br>&gt; let foo: Any = &quot;Foo&quot;<br>&gt; let bar: Any = NSString(string: &quot;Bar&quot;)<br>&gt;<br>&gt; let fooIsString = foo is String                  // true<br>&gt; let fooReallyIsString = foo really_is String     // true<br>&gt;<br>&gt; let fooIsNSString = foo is NSString              // true<br>&gt; let fooReallyIsNSString = foo really_is NSString // false<br>&gt;<br>&gt; let barIsString = bar is String                  // true<br>&gt; let barReallyIsString = bar really_is String     // false<br>&gt;<br>&gt; let barIsNSString = bar is NSString              // true<br>&gt; let barReallyIsNSString = bar really_is NSString // true<br>&gt;<br>&gt; ALTERNATIVES CONSIDERED:<br>&gt;<br>&gt; Stick with using an unholy combination of Mirror and unsafeBitCast when<br>&gt; you need to know what you’ve actually got.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/d8827577/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>August 25, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Aug 24, 2016, at 9:33 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Aug 24, 2016 at 9:25 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 24, 2016, at 9:09 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have 3 qualms with this proposal as it stands:<br>&gt;&gt; <br>&gt;&gt; - type(of:) will never lie to you. <br>&gt;&gt; <br>&gt;&gt; The only question it won’t answer to your satisfaction is the dynamic type of the NSString you boxed up as an Any.<br>&gt;&gt; <br>&gt;&gt; - No more keywords without significant justification.  <br>&gt;&gt; <br>&gt;&gt; I don’t buy the performance use case at all - if you were properly concerned about performance you would try to use as many of Swift’s static features as possible.<br>&gt;&gt; <br>&gt;&gt; - Especially no more keywords that look like they belong in Rust or PHP!<br>&gt;&gt; <br>&gt;&gt; There is no precedent for the spelling of these operations other than the suffixed punctuation. Given that they’re domain-specific, will definitely be hard to use (given that NSString(string: &quot;Bar”) may not “really” given you an NSString yet that’s what you asked us to check for “really&quot;), and will be obviated by the implementation of SE-0083, I can’t see a reason why we need any of this in the language proper.<br>&gt; <br>&gt; One related topic to consider is exhaustive pattern matching for classes.  Now that SE-0117 has been accepted it will be possible to do this for many classes (I would say most if it weren’t for Objective-C classes being so common in Swift and are imported as `open`).  Supporting exhaustive pattern matching well would require some kind of syntax for matching the runtime type exactly.  I have imagined this as being “exact match” cast operators, which is what the `really_*` operators are.<br>&gt; <br>&gt; I don&#39;t understand. As pitched, these operators remove bridging magic, but `Subclass really_is Superclass == true`. How would you use this for classes?<br></p><p>Bridging is the use case motivating the pitch.  I am bringing up a related use case.<br></p><p>The pitch does not specify `Subclass really_is Superclass == true` and I would argue that this is not the semantics we would want.  My interpretation of the proposed solution is:<br></p><p>&quot;I propose the following operators: really_is, really_as, really_as?, and really_as!. These operators would only return a positive result if the type actually was what was being asked for, instead of something that might be able to bridge to that type or a superclass of that type.&quot;<br></p><p>We discussed the exhaustive pattern matching previously in this thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160523/018799.html where the “exact match” cast operators were called `isExactly` and `asExactly`.<br></p><p>I think the exhaustive pattern matching use case for classes (and protocols if / when we get sealed protocols) is an important one.  I also think doing it right requires the ability to match exact types (i.e. not match subclasses).  Maybe there is a better mechanism than a new operators but they would certainly do the job well.<br></p><p>&gt;  <br>&gt; Do you have an alternative in mind for exhaustive pattern matching if we do not introduce exact match cast operators?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 24, 2016, at 5:08 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; MOTIVATION:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; SE-0083 appears to be dead in the water, having been deferred until later in Swift 3 back in May and not having been heard from since then, with the Swift 3 release looming closer and closer. However, the predictability gains that would have been provided by this change remain desirable for cases where one needs to know the actual dynamic type of an entity before any bridging magic is involved. Additionally, performance-critical code may desire the ability to check something’s type quickly without incurring the overhead of Objective-C bridging code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose the following operators: really_is, really_as, really_as?, and really_as!. These operators would only return a positive result if the type actually was what was being asked for, instead of something that might be able to bridge to that type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; DETAILED DESIGN:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let foo: Any = &quot;Foo&quot;<br>&gt;&gt;&gt; let bar: Any = NSString(string: &quot;Bar&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fooIsString = foo is String                  // true<br>&gt;&gt;&gt; let fooReallyIsString = foo really_is String     // true<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fooIsNSString = foo is NSString              // true<br>&gt;&gt;&gt; let fooReallyIsNSString = foo really_is NSString // false<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let barIsString = bar is String                  // true<br>&gt;&gt;&gt; let barReallyIsString = bar really_is String     // false<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let barIsNSString = bar is NSString              // true<br>&gt;&gt;&gt; let barReallyIsNSString = bar really_is NSString // true<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Stick with using an unholy combination of Mirror and unsafeBitCast when you need to know what you’ve actually got.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Charles<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160825/ec7702bd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 25, 2016 at 09:00:00am</p></header><div class="content"><p>Charles clarified that indeed he was pitching casting operators that match<br>subclasses.<br></p><p>If the compiler knows that a class is sealed, why do you think there&#39;s a<br>new keyword needed for the compiler to prove exhaustiveness?<br></p><p>First, you can already match exact types by writing `type(of: instance) ==<br>Base.self` (which doesn&#39;t evaluate to true if instance is of a subclass of<br>Base).<br></p><p>Second, if your class hierarchy is Base &gt; A &gt; B &gt; C, then _even if_ there<br>existed no way to match exact types (which there is), you have the option<br>of switching over the type of an instance, providing cases that match in<br>the order C, B, A, Base in order to perform a different action for each.<br>This requires no additional knowledge at compile time beyond what you<br>already stipulated for your use case, namely that the entire class<br>hierarchy must be known at compile time.<br></p><p>Third, your motivating example in the previous thread already works.<br>Slightly renamed to match the examples above, the following compiles:<br></p><p>```<br>class Base { init() { } } class A1 : Base { } class A2 : Base { } func<br>foo(_ b: Base) -&gt; Int { switch b { case is A1: return 1 case is A2: return<br>2 case is Base: return 0 } }<br></p><p>let a = A1() let b = A2() foo(a) // 1 foo(b) // 2<br>```<br></p><p>There is a warning that `case is Base` is always true. Perhaps something<br>could be done about that diagnostic, since that is after all what you want<br>in a switch statement without a default case.<br></p><p>I&#39;m sure you were aware of all of these points, so I guess I&#39;m asking, what<br>exactly are you pitching?<br></p><p><br>On Thu, Aug 25, 2016 at 08:40 Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt; On Aug 24, 2016, at 9:33 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Aug 24, 2016 at 9:25 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Aug 24, 2016, at 9:09 PM, Robert Widmann via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I have 3 qualms with this proposal as it stands:<br>&gt;&gt;<br>&gt;&gt; - type(of:) will never lie to you.<br>&gt;&gt;<br>&gt;&gt; The only question it won’t answer to your satisfaction is the dynamic<br>&gt;&gt; type of the NSString you boxed up as an Any.<br>&gt;&gt;<br>&gt;&gt; - No more keywords without significant justification.<br>&gt;&gt;<br>&gt;&gt; I don’t buy the performance use case at all - if you were properly<br>&gt;&gt; concerned about performance you would try to use as many of Swift’s static<br>&gt;&gt; features as possible.<br>&gt;&gt;<br>&gt;&gt; - Especially no more keywords that look like they belong in Rust or PHP!<br>&gt;&gt;<br>&gt;&gt; There is no precedent for the spelling of these operations other than the<br>&gt;&gt; suffixed punctuation. Given that they’re domain-specific, will definitely<br>&gt;&gt; be hard to use (given that NSString(string: &quot;Bar”) may not “really”<br>&gt;&gt; given you an NSString yet that’s what you asked us to check for “*really*&quot;),<br>&gt;&gt; and will be obviated by the implementation of SE-0083, I can’t see a reason<br>&gt;&gt; why we need any of this in the language proper.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; One related topic to consider is exhaustive pattern matching for<br>&gt;&gt; classes.  Now that SE-0117 has been accepted it will be possible to do this<br>&gt;&gt; for many classes (I would say most if it weren’t for Objective-C classes<br>&gt;&gt; being so common in Swift and are imported as `open`).  Supporting<br>&gt;&gt; exhaustive pattern matching well would require some kind of syntax for<br>&gt;&gt; matching the runtime type exactly.  I have imagined this as being “exact<br>&gt;&gt; match” cast operators, which is what the `really_*` operators are.<br>&gt;&gt;<br>&gt;<br>&gt; I don&#39;t understand. As pitched, these operators remove bridging magic, but<br>&gt; `Subclass really_is Superclass == true`. How would you use this for classes?<br>&gt;<br>&gt;<br>&gt; Bridging is the use case motivating the pitch.  I am bringing up a related<br>&gt; use case.<br>&gt;<br>&gt; The pitch does not specify `Subclass really_is Superclass == true` and I<br>&gt; would argue that this is not the semantics we would want.  My<br>&gt; interpretation of the proposed solution is:<br>&gt;<br>&gt; &quot;I propose the following operators: really_is, really_as, really_as?, and<br>&gt; really_as!. These operators would only return a positive result if the type<br>&gt; actually was what was being asked for, instead of something that might be<br>&gt; able to bridge to that type *or a superclass of that type*.&quot;<br>&gt;<br>&gt; We discussed the exhaustive pattern matching previously in this thread:<br>&gt; https://lists.swift.org/pipermail/swift-evolution/<br>&gt; Week-of-Mon-20160523/018799.html where the “exact match” cast operators<br>&gt; were called `isExactly` and `asExactly`.<br>&gt;<br>&gt; I think the exhaustive pattern matching use case for classes (and<br>&gt; protocols if / when we get sealed protocols) is an important one.  I also<br>&gt; think doing it right requires the ability to match exact types (i.e. not<br>&gt; match subclasses).  Maybe there is a better mechanism than a new operators<br>&gt; but they would certainly do the job well.<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; Do you have an alternative in mind for exhaustive pattern matching if we<br>&gt;&gt; do not introduce exact match cast operators?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; ~Robert Widmann<br>&gt;&gt;<br>&gt;&gt; On Aug 24, 2016, at 5:08 PM, Charles Srstka via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; MOTIVATION:<br>&gt;&gt;<br>&gt;&gt; SE-0083 appears to be dead in the water, having been deferred until later<br>&gt;&gt; in Swift 3 back in May and not having been heard from since then, with the<br>&gt;&gt; Swift 3 release looming closer and closer. However, the predictability<br>&gt;&gt; gains that would have been provided by this change remain desirable for<br>&gt;&gt; cases where one needs to know the actual dynamic type of an entity before<br>&gt;&gt; any bridging magic is involved. Additionally, performance-critical code may<br>&gt;&gt; desire the ability to check something’s type quickly without incurring the<br>&gt;&gt; overhead of Objective-C bridging code.<br>&gt;&gt;<br>&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt;<br>&gt;&gt; I propose the following operators: really_is, really_as, really_as?, and<br>&gt;&gt; really_as!. These operators would only return a positive result if the type<br>&gt;&gt; actually was what was being asked for, instead of something that might be<br>&gt;&gt; able to bridge to that type.<br>&gt;&gt;<br>&gt;&gt; DETAILED DESIGN:<br>&gt;&gt;<br>&gt;&gt; let foo: Any = &quot;Foo&quot;<br>&gt;&gt; let bar: Any = NSString(string: &quot;Bar&quot;)<br>&gt;&gt;<br>&gt;&gt; let fooIsString = foo is String                  // true<br>&gt;&gt; let fooReallyIsString = foo really_is String     // true<br>&gt;&gt;<br>&gt;&gt; let fooIsNSString = foo is NSString              // true<br>&gt;&gt; let fooReallyIsNSString = foo really_is NSString // false<br>&gt;&gt;<br>&gt;&gt; let barIsString = bar is String                  // true<br>&gt;&gt; let barReallyIsString = bar really_is String     // false<br>&gt;&gt;<br>&gt;&gt; let barIsNSString = bar is NSString              // true<br>&gt;&gt; let barReallyIsNSString = bar really_is NSString // true<br>&gt;&gt;<br>&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt;<br>&gt;&gt; Stick with using an unholy combination of Mirror and unsafeBitCast when<br>&gt;&gt; you need to know what you’ve actually got.<br>&gt;&gt;<br>&gt;&gt; Charles<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160825/696531f7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>August 25, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Aug 25, 2016, at 9:37 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Charles clarified that indeed he was pitching casting operators that match subclasses.<br></p><p>Ok, I missed that.<br></p><p>&gt; <br>&gt; If the compiler knows that a class is sealed, why do you think there&#39;s a new keyword needed for the compiler to prove exhaustiveness?<br></p><p>I said I wasn’t sure if there was a different / better way to do it.  Just that this *would* do it.<br></p><p>&gt; <br>&gt; First, you can already match exact types by writing `type(of: instance) == Base.self` (which doesn&#39;t evaluate to true if instance is of a subclass of Base).<br></p><p>This might be an alternative if the compiler adds special knowledge of this syntax to prove exhaustiveness.<br></p><p>&gt; <br>&gt; Second, if your class hierarchy is Base &gt; A &gt; B &gt; C, then _even if_ there existed no way to match exact types (which there is), you have the option of switching over the type of an instance, providing cases that match in the order C, B, A, Base in order to perform a different action for each. This requires no additional knowledge at compile time beyond what you already stipulated for your use case, namely that the entire class hierarchy must be known at compile time.<br></p><p>This order requirement is fragile.  If you put Base first it will always match, which probably isn’t the intent.  I would like to see a solution that requires you to match each type in the hierarchy without being subject to bugs related to ordering of the cases.<br></p><p>&gt; <br>&gt; Third, your motivating example in the previous thread already works. Slightly renamed to match the examples above, the following compiles:<br>&gt; <br>&gt; ```<br>&gt; class Base {<br>&gt;   init() { }<br>&gt; }<br>&gt; class A1 : Base { }<br>&gt; class A2 : Base { }<br>&gt; <br>&gt; func foo(_ b: Base) -&gt; Int {<br>&gt;   switch b {<br>&gt;   case is A1: return 1<br>&gt;   case is A2: return 2<br>&gt;   case is Base: return 0<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; let a = A1()<br>&gt; let b = A2()<br>&gt; foo(a) // 1<br>&gt; foo(b) // 2<br>&gt; ```<br>&gt; <br>&gt; There is a warning that `case is Base` is always true. Perhaps something could be done about that diagnostic, since that is after all what you want in a switch statement without a default case.<br>&gt; <br>&gt; I&#39;m sure you were aware of all of these points, so I guess I&#39;m asking, what exactly are you pitching?<br></p><p>See above.  I am looking for a solution that avoids this warning precisely because it will *not* always be true.  The compiler gaining special knowledge of the `type(of: instance) == Base.self` pattern could be *part* of a solution but it still doesn’t bind a name the correct type.  For example, with the Base &gt; A &gt; B &gt; C hierarchy when I match `type(of: instance) == B.self` I also want a variable bound with a type of `B`.  This gets pretty verbose and requires the compiler to have special knowledge of pretty specific pattern:<br></p><p>func foo(_ b: Base) -&gt; Int {<br>  switch b {<br>  case let base as Base where type(of: instance) == Base.self: return 1<br>  case let a as A where type(of: instance) == A.self: return 2<br>  case let b as B where type(of: instance) == B.self: return 3<br>  case let c as C where type(of: instance) == C.self: return 4<br>  }<br>}<br></p><p>If the compiler could prove exhaustiveness here I would accept that solution.  But it seems like an exact match cast operator would be much more elegant.  <br></p><p>In any case, anything that requires matching every type in a hierarchy without being subject to case ordering bugs and doesn’t require a default clause would be acceptable to me.  That is the problem I would like to see solved.<br></p><p>&gt; <br>&gt; <br>&gt; On Thu, Aug 25, 2016 at 08:40 Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; On Aug 24, 2016, at 9:33 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Aug 24, 2016 at 9:25 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 24, 2016, at 9:09 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have 3 qualms with this proposal as it stands:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - type(of:) will never lie to you. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The only question it won’t answer to your satisfaction is the dynamic type of the NSString you boxed up as an Any.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - No more keywords without significant justification.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t buy the performance use case at all - if you were properly concerned about performance you would try to use as many of Swift’s static features as possible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Especially no more keywords that look like they belong in Rust or PHP!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is no precedent for the spelling of these operations other than the suffixed punctuation. Given that they’re domain-specific, will definitely be hard to use (given that NSString(string: &quot;Bar”) may not “really” given you an NSString yet that’s what you asked us to check for “really&quot;), and will be obviated by the implementation of SE-0083, I can’t see a reason why we need any of this in the language proper.<br>&gt;&gt; <br>&gt;&gt; One related topic to consider is exhaustive pattern matching for classes.  Now that SE-0117 has been accepted it will be possible to do this for many classes (I would say most if it weren’t for Objective-C classes being so common in Swift and are imported as `open`).  Supporting exhaustive pattern matching well would require some kind of syntax for matching the runtime type exactly.  I have imagined this as being “exact match” cast operators, which is what the `really_*` operators are.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t understand. As pitched, these operators remove bridging magic, but `Subclass really_is Superclass == true`. How would you use this for classes?<br>&gt; <br>&gt; Bridging is the use case motivating the pitch.  I am bringing up a related use case.<br>&gt; <br>&gt; The pitch does not specify `Subclass really_is Superclass == true` and I would argue that this is not the semantics we would want.  My interpretation of the proposed solution is:<br>&gt; <br>&gt; &quot;I propose the following operators: really_is, really_as, really_as?, and really_as!. These operators would only return a positive result if the type actually was what was being asked for, instead of something that might be able to bridge to that type or a superclass of that type.&quot;<br>&gt; <br>&gt; We discussed the exhaustive pattern matching previously in this thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160523/018799.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160523/018799.html&gt; where the “exact match” cast operators were called `isExactly` and `asExactly`.<br>&gt; <br>&gt; I think the exhaustive pattern matching use case for classes (and protocols if / when we get sealed protocols) is an important one.  I also think doing it right requires the ability to match exact types (i.e. not match subclasses).  Maybe there is a better mechanism than a new operators but they would certainly do the job well.<br>&gt; <br>&gt;&gt;  <br>&gt;&gt; Do you have an alternative in mind for exhaustive pattern matching if we do not introduce exact match cast operators?<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 24, 2016, at 5:08 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; MOTIVATION:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; SE-0083 appears to be dead in the water, having been deferred until later in Swift 3 back in May and not having been heard from since then, with the Swift 3 release looming closer and closer. However, the predictability gains that would have been provided by this change remain desirable for cases where one needs to know the actual dynamic type of an entity before any bridging magic is involved. Additionally, performance-critical code may desire the ability to check something’s type quickly without incurring the overhead of Objective-C bridging code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I propose the following operators: really_is, really_as, really_as?, and really_as!. These operators would only return a positive result if the type actually was what was being asked for, instead of something that might be able to bridge to that type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; DETAILED DESIGN:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let foo: Any = &quot;Foo&quot;<br>&gt;&gt;&gt;&gt; let bar: Any = NSString(string: &quot;Bar&quot;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fooIsString = foo is String                  // true<br>&gt;&gt;&gt;&gt; let fooReallyIsString = foo really_is String     // true<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fooIsNSString = foo is NSString              // true<br>&gt;&gt;&gt;&gt; let fooReallyIsNSString = foo really_is NSString // false<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let barIsString = bar is String                  // true<br>&gt;&gt;&gt;&gt; let barReallyIsString = bar really_is String     // false<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let barIsNSString = bar is NSString              // true<br>&gt;&gt;&gt;&gt; let barReallyIsNSString = bar really_is NSString // true<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Stick with using an unholy combination of Mirror and unsafeBitCast when you need to know what you’ve actually got.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160825/92cfa78c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 25, 2016 at 11:00:00am</p></header><div class="content"><p>On Thu, Aug 25, 2016 at 10:07 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Aug 25, 2016, at 9:37 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; Charles clarified that indeed he was pitching casting operators that match<br>&gt; subclasses.<br>&gt;<br>&gt;<br>&gt; Ok, I missed that.<br>&gt;<br>&gt;<br>&gt; If the compiler knows that a class is sealed, why do you think there&#39;s a<br>&gt; new keyword needed for the compiler to prove exhaustiveness?<br>&gt;<br>&gt;<br>&gt; I said I wasn’t sure if there was a different / better way to do it.  Just<br>&gt; that this *would* do it.<br>&gt;<br>&gt;<br>&gt; First, you can already match exact types by writing `type(of: instance) ==<br>&gt; Base.self` (which doesn&#39;t evaluate to true if instance is of a subclass of<br>&gt; Base).<br>&gt;<br>&gt;<br>&gt; This might be an alternative if the compiler adds special knowledge of<br>&gt; this syntax to prove exhaustiveness.<br>&gt;<br></p><p>I might be in favor of that. As it is, I can write this:<br></p><p>```<br>func ~= &lt;T, U&gt;(lhs: T.Type, rhs: U.Type) -&gt; Bool {<br>  return lhs == rhs<br>}<br></p><p>class Base {<br>  init() { }<br>}<br>class A1 : Base { }<br>class A2 : Base { }<br></p><p>let a = A1()<br></p><p>switch type(of: a) {<br>case A1.self:<br>  print(1)<br>case A2.self:<br>  print(2)<br>case Base.self:<br>  print(0)<br>default:<br>  fatalError()<br>}<br>```<br></p><p>It&#39;d be nice if the compiler would know about exhaustiveness (and if I<br>didn&#39;t have to define my own `~=`). This is, afaict, doable without any<br>additional syntax in the language.<br></p><p>Second, if your class hierarchy is Base &gt; A &gt; B &gt; C, then _even if_ there<br>&gt; existed no way to match exact types (which there is), you have the option<br>&gt; of switching over the type of an instance, providing cases that match in<br>&gt; the order C, B, A, Base in order to perform a different action for each.<br>&gt; This requires no additional knowledge at compile time beyond what you<br>&gt; already stipulated for your use case, namely that the entire class<br>&gt; hierarchy must be known at compile time.<br>&gt;<br>&gt;<br>&gt; This order requirement is fragile.  If you put Base first it will always<br>&gt; match, which probably isn’t the intent.  I would like to see a solution<br>&gt; that requires you to match each type in the hierarchy without being subject<br>&gt; to bugs related to ordering of the cases.<br>&gt;<br></p><p>Given that the hierarchy is known at compile-time, a solution that would<br>meet your criteria (not being subject to bugs related to ordering) would be<br>diagnostics for unreachable cases (i.e., if Base is matched before A, `case<br>is A` should be flagged as unreachable).<br></p><p><br>&gt; Third, your motivating example in the previous thread already works.<br>&gt; Slightly renamed to match the examples above, the following compiles:<br>&gt;<br>&gt;<br>&gt; ```<br>&gt; class Base { init() { } } class A1 : Base { } class A2 : Base { } func<br>&gt; foo(_ b: Base) -&gt; Int { switch b { case is A1: return 1 case is A2: return<br>&gt; 2 case is Base: return 0 } }<br>&gt;<br>&gt; let a = A1() let b = A2() foo(a) // 1 foo(b) // 2<br>&gt; ```<br>&gt;<br>&gt; There is a warning that `case is Base` is always true. Perhaps something<br>&gt; could be done about that diagnostic, since that is after all what you want<br>&gt; in a switch statement without a default case.<br>&gt;<br>&gt; I&#39;m sure you were aware of all of these points, so I guess I&#39;m asking,<br>&gt; what exactly are you pitching?<br>&gt;<br>&gt;<br>&gt; See above.  I am looking for a solution that avoids this warning precisely<br>&gt; because it will *not* always be true.  The compiler gaining special<br>&gt; knowledge of the `type(of: instance) == Base.self` pattern could be<br>&gt; *part* of a solution but it still doesn’t bind a name the correct type. For<br>&gt; example, with the Base &gt; A &gt; B &gt; C hierarchy when I match `type(of:<br>&gt; instance) == B.self` I also want a variable bound with a type of `B`. This<br>&gt; gets pretty verbose and requires the compiler to have special knowledge of<br>&gt; pretty specific pattern:<br>&gt;<br>&gt; func foo(_ b: Base) -&gt; Int {<br>&gt;   switch b {<br>&gt;   case let base as Base where type(of: instance) == Base.self: return 1<br>&gt;   case let a as A where type(of: instance) == A.self: return 2<br>&gt;   case let b as B where type(of: instance) == B.self: return 3<br>&gt;   case let c as C where type(of: instance) == C.self: return 4<br>&gt;   }<br>&gt; }<br>&gt;<br></p><p><br>&gt; If the compiler could prove exhaustiveness here I would accept that<br>&gt; solution.  But it seems like an exact match cast operator would be much<br>&gt; more elegant.<br>&gt;<br>&gt; In any case, anything that requires matching every type in a hierarchy<br>&gt; without being subject to case ordering bugs and doesn’t require a default<br>&gt; clause would be acceptable to me.  That is the problem I would like to see<br>&gt; solved.<br>&gt;<br></p><p>Looking back, it seems like diagnostics for unreachable cases would meet<br>your criteria exactly and would be the most straightforward. I don&#39;t think<br>it would even require an evolution proposal. I would love to see type(of:)<br>work with switch statements out-of-the-box, but that seems more esoteric.<br>None of this requires additional syntax, IMHO.<br></p><p><br>&gt;<br>&gt; On Thu, Aug 25, 2016 at 08:40 Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Aug 24, 2016, at 9:33 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Wed, Aug 24, 2016 at 9:25 PM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Aug 24, 2016, at 9:09 PM, Robert Widmann via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I have 3 qualms with this proposal as it stands:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - type(of:) will never lie to you.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The only question it won’t answer to your satisfaction is the dynamic<br>&gt;&gt;&gt; type of the NSString you boxed up as an Any.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - No more keywords without significant justification.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don’t buy the performance use case at all - if you were properly<br>&gt;&gt;&gt; concerned about performance you would try to use as many of Swift’s static<br>&gt;&gt;&gt; features as possible.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Especially no more keywords that look like they belong in Rust or PHP!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There is no precedent for the spelling of these operations other than<br>&gt;&gt;&gt; the suffixed punctuation. Given that they’re domain-specific, will<br>&gt;&gt;&gt; definitely be hard to use (given that NSString(string: &quot;Bar”) may not<br>&gt;&gt;&gt; “really” given you an NSString yet that’s what you asked us to check for “<br>&gt;&gt;&gt; *really*&quot;), and will be obviated by the implementation of SE-0083, I<br>&gt;&gt;&gt; can’t see a reason why we need any of this in the language proper.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; One related topic to consider is exhaustive pattern matching for<br>&gt;&gt;&gt; classes.  Now that SE-0117 has been accepted it will be possible to do this<br>&gt;&gt;&gt; for many classes (I would say most if it weren’t for Objective-C classes<br>&gt;&gt;&gt; being so common in Swift and are imported as `open`).  Supporting<br>&gt;&gt;&gt; exhaustive pattern matching well would require some kind of syntax for<br>&gt;&gt;&gt; matching the runtime type exactly.  I have imagined this as being “exact<br>&gt;&gt;&gt; match” cast operators, which is what the `really_*` operators are.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don&#39;t understand. As pitched, these operators remove bridging magic,<br>&gt;&gt; but `Subclass really_is Superclass == true`. How would you use this for<br>&gt;&gt; classes?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Bridging is the use case motivating the pitch.  I am bringing up a<br>&gt;&gt; related use case.<br>&gt;&gt;<br>&gt;&gt; The pitch does not specify `Subclass really_is Superclass == true` and I<br>&gt;&gt; would argue that this is not the semantics we would want.  My<br>&gt;&gt; interpretation of the proposed solution is:<br>&gt;&gt;<br>&gt;&gt; &quot;I propose the following operators: really_is, really_as, really_as?, and<br>&gt;&gt; really_as!. These operators would only return a positive result if the type<br>&gt;&gt; actually was what was being asked for, instead of something that might be<br>&gt;&gt; able to bridge to that type *or a superclass of that type*.&quot;<br>&gt;&gt;<br>&gt;&gt; We discussed the exhaustive pattern matching previously in this thread:<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/We<br>&gt;&gt; ek-of-Mon-20160523/018799.html where the “exact match” cast operators<br>&gt;&gt; were called `isExactly` and `asExactly`.<br>&gt;&gt;<br>&gt;&gt; I think the exhaustive pattern matching use case for classes (and<br>&gt;&gt; protocols if / when we get sealed protocols) is an important one.  I also<br>&gt;&gt; think doing it right requires the ability to match exact types (i.e. not<br>&gt;&gt; match subclasses).  Maybe there is a better mechanism than a new operators<br>&gt;&gt; but they would certainly do the job well.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; Do you have an alternative in mind for exhaustive pattern matching if we<br>&gt;&gt;&gt; do not introduce exact match cast operators?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Aug 24, 2016, at 5:08 PM, Charles Srstka via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; MOTIVATION:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; SE-0083 appears to be dead in the water, having been deferred until<br>&gt;&gt;&gt; later in Swift 3 back in May and not having been heard from since then,<br>&gt;&gt;&gt; with the Swift 3 release looming closer and closer. However, the<br>&gt;&gt;&gt; predictability gains that would have been provided by this change remain<br>&gt;&gt;&gt; desirable for cases where one needs to know the actual dynamic type of an<br>&gt;&gt;&gt; entity before any bridging magic is involved. Additionally,<br>&gt;&gt;&gt; performance-critical code may desire the ability to check something’s type<br>&gt;&gt;&gt; quickly without incurring the overhead of Objective-C bridging code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I propose the following operators: really_is, really_as, really_as?, and<br>&gt;&gt;&gt; really_as!. These operators would only return a positive result if the type<br>&gt;&gt;&gt; actually was what was being asked for, instead of something that might be<br>&gt;&gt;&gt; able to bridge to that type.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; DETAILED DESIGN:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let foo: Any = &quot;Foo&quot;<br>&gt;&gt;&gt; let bar: Any = NSString(string: &quot;Bar&quot;)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let fooIsString = foo is String                  // true<br>&gt;&gt;&gt; let fooReallyIsString = foo really_is String     // true<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let fooIsNSString = foo is NSString              // true<br>&gt;&gt;&gt; let fooReallyIsNSString = foo really_is NSString // false<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let barIsString = bar is String                  // true<br>&gt;&gt;&gt; let barReallyIsString = bar really_is String     // false<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let barIsNSString = bar is NSString              // true<br>&gt;&gt;&gt; let barReallyIsNSString = bar really_is NSString // true<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Stick with using an unholy combination of Mirror and unsafeBitCast when<br>&gt;&gt;&gt; you need to know what you’ve actually got.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160825/46be5ef6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>August 29, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Aug 24, 2016, at 5:08 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; MOTIVATION:<br>&gt; <br>&gt; SE-0083 appears to be dead in the water, having been deferred until later in Swift 3 back in May and not having been heard from since then, with the Swift 3 release looming closer and closer. However, the predictability gains that would have been provided by this change remain desirable for cases where one needs to know the actual dynamic type of an entity before any bridging magic is involved. Additionally, performance-critical code may desire the ability to check something’s type quickly without incurring the overhead of Objective-C bridging code.<br>&gt; <br>&gt; PROPOSED SOLUTION:<br>&gt; <br>&gt; I propose the following operators: really_is, really_as, really_as?, and really_as!. These operators would only return a positive result if the type actually was what was being asked for, instead of something that might be able to bridge to that type.<br>&gt; <br>&gt; DETAILED DESIGN:<br>&gt; <br>&gt; let foo: Any = &quot;Foo&quot;<br>&gt; let bar: Any = NSString(string: &quot;Bar&quot;)<br>&gt; <br>&gt; let fooIsString = foo is String                  // true<br>&gt; let fooReallyIsString = foo really_is String     // true<br>&gt; <br>&gt; let fooIsNSString = foo is NSString              // true<br>&gt; let fooReallyIsNSString = foo really_is NSString // false<br>&gt; <br>&gt; let barIsString = bar is String                  // true<br>&gt; let barReallyIsString = bar really_is String     // false<br>&gt; <br>&gt; let barIsNSString = bar is NSString              // true<br>&gt; let barReallyIsNSString = bar really_is NSString // true<br>&gt; <br>&gt; ALTERNATIVES CONSIDERED:<br>&gt; <br>&gt; Stick with using an unholy combination of Mirror and unsafeBitCast when you need to know what you’ve actually got.<br></p><p>It would be helpful to know why you want this. What are you trying to do?<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 29, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Aug 29, 2016, at 11:14 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Aug 24, 2016, at 5:08 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; MOTIVATION:<br>&gt;&gt; <br>&gt;&gt; SE-0083 appears to be dead in the water, having been deferred until later in Swift 3 back in May and not having been heard from since then, with the Swift 3 release looming closer and closer. However, the predictability gains that would have been provided by this change remain desirable for cases where one needs to know the actual dynamic type of an entity before any bridging magic is involved. Additionally, performance-critical code may desire the ability to check something’s type quickly without incurring the overhead of Objective-C bridging code.<br>&gt;&gt; <br>&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt; <br>&gt;&gt; I propose the following operators: really_is, really_as, really_as?, and really_as!. These operators would only return a positive result if the type actually was what was being asked for, instead of something that might be able to bridge to that type.<br>&gt;&gt; <br>&gt;&gt; DETAILED DESIGN:<br>&gt;&gt; <br>&gt;&gt; let foo: Any = &quot;Foo&quot;<br>&gt;&gt; let bar: Any = NSString(string: &quot;Bar&quot;)<br>&gt;&gt; <br>&gt;&gt; let fooIsString = foo is String                  // true<br>&gt;&gt; let fooReallyIsString = foo really_is String     // true<br>&gt;&gt; <br>&gt;&gt; let fooIsNSString = foo is NSString              // true<br>&gt;&gt; let fooReallyIsNSString = foo really_is NSString // false<br>&gt;&gt; <br>&gt;&gt; let barIsString = bar is String                  // true<br>&gt;&gt; let barReallyIsString = bar really_is String     // false<br>&gt;&gt; <br>&gt;&gt; let barIsNSString = bar is NSString              // true<br>&gt;&gt; let barReallyIsNSString = bar really_is NSString // true<br>&gt;&gt; <br>&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt; <br>&gt;&gt; Stick with using an unholy combination of Mirror and unsafeBitCast when you need to know what you’ve actually got.<br>&gt; <br>&gt; It would be helpful to know why you want this. What are you trying to do?<br></p><p>Custom bridging behavior. My specific use case is obsolete since SE-0112, but before that I had my own little hacky SE-0112 implementation, that looked kind of like this:<br></p><p>protocol CSErrorType: ErrorType {<br>    var userInfo: [NSObject : AnyObject] { get }<br>    func toNSError() -&gt; NSError<br>}<br></p><p>toNSError() had a default implementation that generated an appropriate NSError from the userInfo. This was pretty good, although I had to be diligent about always using .toNSError() rather than “as NSError”, so that the bridging behavior would be called. However, do/try/catch returns errors as ErrorType, which meant I had to do a dynamic check each time I caught an error, which was tedious. So, I decided to put an extension on ErrorType. The most convenient thing to do would be just to define a default implementation for toNSError() on ErrorType, but since there’s no way to make a method introduced by a protocol get dispatched dynamically, that would mean that CSErrorType’s implementation would never get called, even when it was appropriate. So I added a dynamic cast:<br></p><p>extension ErrorType {<br>    func toNSError() -&gt; NSError {<br>        if let csError = self as? CSErrorType {<br>            return csError.toNSError()<br>        } else {<br>            return self as NSError<br>        }<br>    }<br>}<br></p><p>However, NSError conformed to ErrorType, and the code in “as NSError” apparently didn’t dynamically check the type of the error, so now if you called .toNSError() on a _SwiftNativeNSError that was statically typed as ErrorType, it would end up double-wrapped inside *another* _SwiftNativeNSError, which then prevented such errors from unwrapping back to Swift errors properly. So, my first thought was to just check for that:<br></p><p>extension ErrorType {<br>    func toNSError() -&gt; NSError {<br>        if let ns = self as? NSError {<br>            return ns<br>        }<br></p><p>        if let csError = self as? CSErrorType {<br>            return csError.toNSError()<br>        } else {<br>            return self as NSError<br>        }<br>    }<br>}<br></p><p>But of course that will fail because “as? NSError” will always be true. Maybe “is” would be more honest?<br></p><p>extension ErrorType {<br>    func toNSError() -&gt; NSError {<br>        if self is NSError {<br>            return unsafeBitCast(self, NSError.self)<br>        }<br></p><p>        if let csError = self as? CSErrorType {<br>            return csError.toNSError()<br>        } else {<br>            return self as NSError<br>        }<br>    }<br>}<br></p><p>Nope, of course “is NSError” is always true as well.<br></p><p>What I ended up doing was using a horrible little hack using Mirror that I’m really quite un-proud of to figure out if the thing was really an NSError or not. Knowing from this thread that “is” actually becomes honest when used on type(of:), I could have used that instead (yes, this example mixes Swift 2 and Swift 3, so I would have used “dynamicType” at the time; it’s just an example):<br></p><p>extension ErrorType {<br>    func toNSError() -&gt; NSError {<br>        if type(of: self) is NSError.Type {<br>            return unsafeBitCast(self, NSError.self)<br>        }<br></p><p>        if let csError = self as? CSErrorType {<br>            return csError.toNSError()<br>        } else {<br>            return self as NSError<br>        }<br>    }<br>}<br></p><p>Unfortunately, the unsafeBitCast would probably have still been needed in order to avoid the bridging behavior when using “as!”.<br></p><p>While this particular use case isn’t really a “thing” anymore, someone else might have a different reason to bridge something in a custom way, and it’d be nice to have a way not to have to jump through all these hoops.<br></p><p>Charles<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>September 12, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Aug 29, 2016, at 11:14 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 24, 2016, at 5:08 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt; <br>&gt;&gt; I propose the following operators: really_is, really_as, really_as?, and really_as!. These operators would only return a positive result if the type actually was what was being asked for, instead of something that might be able to bridge to that type.<br>&gt;&gt; <br>&gt;&gt; DETAILED DESIGN:<br>&gt;&gt; <br>&gt;&gt; let foo: Any = &quot;Foo&quot;<br>&gt;&gt; let bar: Any = NSString(string: &quot;Bar&quot;)<br>&gt;&gt; <br>&gt;&gt; let fooIsString = foo is String                  // true<br>&gt;&gt; let fooReallyIsString = foo really_is String     // true<br>&gt;&gt; <br>&gt;&gt; let fooIsNSString = foo is NSString              // true<br>&gt;&gt; let fooReallyIsNSString = foo really_is NSString // false<br>&gt;&gt; <br>&gt;&gt; let barIsString = bar is String                  // true<br>&gt;&gt; let barReallyIsString = bar really_is String     // false<br>&gt;&gt; <br>&gt;&gt; let barIsNSString = bar is NSString              // true<br>&gt;&gt; let barReallyIsNSString = bar really_is NSString // true<br>&gt;&gt; <br>&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt; <br>&gt;&gt; Stick with using an unholy combination of Mirror and unsafeBitCast when you need to know what you’ve actually got.<br>&gt; <br>&gt; It would be helpful to know why you want this. What are you trying to do?<br></p><p>I’ve got one:<br></p><p>Siesta has a notion of “observer ownership,” whose semantics in a nutshell are “free the observer when its owners are all deallocated.” (Details here: http://bustoutsolutions.github.io/siesta/guide/memory/)<br></p><p>Never mind the details. The important thing is that owners must be objects because we care about the fact that they have an allocation lifecycle.<br></p><p>In Swift 2, this declaration ensured that callers used only objects as owners:<br></p><p>	func addObserver(observer: ResourceObserver, owner: AnyObject)<br></p><p>In Swift 3, however, an unsuspecting called can pass a struct as an owner. Swift helpfully wraps it in a _SwiftValue, the _SwiftValue is only weakly referenced so it’s immediately deallocated, and so the observer is immediately discarded. It’s nonsensical. The compiler should be able to detect &amp; prevent this.<br></p><p>What I want is:<br></p><p>	func addObserver(observer: ResourceObserver, owner: AnyObjectForRealNotJustAValueWrapper)<br></p><p>AFAIK, this is impossible in Swift 3. Or is it?<br></p><p>Cheers, P<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>September 12, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Sep 12, 2016, at 12:24 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 29, 2016, at 11:14 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 24, 2016, at 5:08 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose the following operators: really_is, really_as, really_as?, and really_as!. These operators would only return a positive result if the type actually was what was being asked for, instead of something that might be able to bridge to that type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; DETAILED DESIGN:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let foo: Any = &quot;Foo&quot;<br>&gt;&gt;&gt; let bar: Any = NSString(string: &quot;Bar&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fooIsString = foo is String                  // true<br>&gt;&gt;&gt; let fooReallyIsString = foo really_is String     // true<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fooIsNSString = foo is NSString              // true<br>&gt;&gt;&gt; let fooReallyIsNSString = foo really_is NSString // false<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let barIsString = bar is String                  // true<br>&gt;&gt;&gt; let barReallyIsString = bar really_is String     // false<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let barIsNSString = bar is NSString              // true<br>&gt;&gt;&gt; let barReallyIsNSString = bar really_is NSString // true<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Stick with using an unholy combination of Mirror and unsafeBitCast when you need to know what you’ve actually got.<br>&gt;&gt; <br>&gt;&gt; It would be helpful to know why you want this. What are you trying to do?<br>&gt; <br>&gt; I’ve got one:<br>&gt; <br>&gt; Siesta has a notion of “observer ownership,” whose semantics in a nutshell are “free the observer when its owners are all deallocated.” (Details here: http://bustoutsolutions.github.io/siesta/guide/memory/)<br>&gt; <br>&gt; Never mind the details. The important thing is that owners must be objects because we care about the fact that they have an allocation lifecycle.<br>&gt; <br>&gt; In Swift 2, this declaration ensured that callers used only objects as owners:<br>&gt; <br>&gt; 	func addObserver(observer: ResourceObserver, owner: AnyObject)<br>&gt; <br>&gt; In Swift 3, however, an unsuspecting called can pass a struct as an owner. Swift helpfully wraps it in a _SwiftValue, the _SwiftValue is only weakly referenced so it’s immediately deallocated, and so the observer is immediately discarded. It’s nonsensical. The compiler should be able to detect &amp; prevent this.<br>&gt; <br>&gt; What I want is:<br>&gt; <br>&gt; 	func addObserver(observer: ResourceObserver, owner: AnyObjectForRealNotJustAValueWrapper)<br>&gt; <br>&gt; AFAIK, this is impossible in Swift 3. Or is it?<br></p><p>If you declare the API as taking AnyObject in Swift, this should work *better* in Swift 3, since it is no longer possible to pass non-object value types to an AnyObject API by implicit conversion. If the API came from Objective-C, and uses `id` there, you could perhaps hide the `Any` version that gets imported and drop an AnyObject-taking version on top of it in a Swift overlay. I agree that we ought to have a more general feature in ObjC to say &quot;no, really, this needs to be a reference type&quot;, but I think that&#39;s orthogonal to Charles&#39; original request.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Pitch: really_is and really_as operators</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>September 12, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Sep 12, 2016, at 4:01 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 12, 2016, at 12:24 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In Swift 2, this declaration ensured that callers used only objects as owners:<br>&gt;&gt; <br>&gt;&gt; 	func addObserver(observer: ResourceObserver, owner: AnyObject)<br>&gt;&gt; <br>&gt;&gt; In Swift 3, however, an unsuspecting called can pass a struct as an owner. Swift helpfully wraps it in a _SwiftValue, the _SwiftValue is only weakly referenced so it’s immediately deallocated, and so the observer is immediately discarded. It’s nonsensical. The compiler should be able to detect &amp; prevent this.<br>&gt;&gt; <br>&gt;&gt; What I want is:<br>&gt;&gt; <br>&gt;&gt; 	func addObserver(observer: ResourceObserver, owner: AnyObjectForRealNotJustAValueWrapper)<br>&gt;&gt; <br>&gt;&gt; AFAIK, this is impossible in Swift 3. Or is it?<br>&gt; <br>&gt; If you declare the API as taking AnyObject in Swift, this should work *better* in Swift 3, since it is no longer possible to pass non-object value types to an AnyObject API by implicit conversion. If the API came from Objective-C, and uses `id` there, you could perhaps hide the `Any` version that gets imported and drop an AnyObject-taking version on top of it in a Swift overlay. I agree that we ought to have a more general feature in ObjC to say &quot;no, really, this needs to be a reference type&quot;, but I think that&#39;s orthogonal to Charles&#39; original request.<br></p><p>Ah, you’re quite right. Verified it, and it works exactly as you describe. Of course. I’ve been worrying my little head over nothing. Thanks for clearing that up!<br></p><p>On investigating, turns out I’d misunderstood the larger situation from a more localized Swift 3 change in an internal utility class:<br></p><p>    /**<br>      A reference that can switched between behaving as a strong or a weak ref to an object,<br>      and can also hold a non-object type.<br></p><p>      - If the value is an object, then...<br>        - ...if strong == true, then StrongOrWeakRef holds a strong reference to value.<br>        - ...if strong == false, then StrongOrWeakRef holds a weak reference to value.<br></p><p>      - If the value is of a value type, then...<br>        - ...if strong == true, then StrongOrWeakRef holds the structure.<br>        - ...if strong == false, then StrongOrWeakRef immediately discards the structure.<br>    */<br>    internal struct StrongOrWeakRef&lt;T&gt; {<br>        private var strongRef: T?<br>        private weak var weakRef: AnyObject?<br>        var value: T? {<br>            return strongRef ?? (weakRef as? T)<br>        }<br></p><p>        init(_ value: T) {<br>            strongRef = value<br>            weakRef = value as AnyObject?   // ← was `as? AnyObject` in Swift 2<br>        }<br></p><p>        var strong: Bool {<br>            get { return strongRef != nil }<br>            set { strongRef = newValue ? value : nil }<br>        }<br>    }<br></p><p>The marked line used to be able to just leave weakRef nil when given a value type. Now, because the as AnyObject? coercion always succeeds, it performs an unnecessary heap allocation (I think?) for a _SwiftValue that’s instantly discarded. The semantics don’t change, just the performance penalty.<br></p><p>That’s a case for Charles’s “is it really an object?” Unless I’m off in the weeds again. Hardly the end of the world though!<br></p><p>Cheers, P<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160912/6484cfad/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
