<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February  3, 2016 at 02:00:00pm</p></header><div class="content"><p>on Tue Feb 02 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; 1. If and only if the first argument could complete a sentence*<br>&gt;&gt;   beginning in the base name and describing the primary semantics of<br>&gt;&gt;   the call, it gets no argument label:<br>&gt;&gt; <br>&gt;&gt;     a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;<br>&gt;&gt;     a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt;&gt; <br>&gt;&gt;     a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but <br>&gt;&gt;                            // doesn&#39;t describe the semantics at all, <br>&gt;&gt;                            // thus we add a label for b.<br>&gt;&gt; <br>&gt;&gt;     a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence <br>&gt;&gt;                              // but doesn&#39;t describe the primary <br>&gt;&gt;                              // semantics, which are to move in both<br>&gt;&gt;                              // x and y.  Thus, x gets a label.<br>&gt;&gt; <br>&gt;&gt;     a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;&gt;                              // the primary semantics, so u gets no<br>&gt;&gt;                              // label. b is an<br>&gt;&gt;                              // option that tunes the primary<br>&gt;&gt;                              // semantics<br>&gt;&gt; <br>&gt;&gt;   [Note that this covers all the direct object cases and, I believe,<br>&gt;&gt;   all the default argument cases too, so maybe that exception can be<br>&gt;&gt;   dropped.  We still need the exceptions for full-width type<br>&gt;&gt;   conversions and indistinguishable peers]<br>&gt;&gt; <br>&gt;&gt;   Note: when there is a noun in the base name describing the role of the<br>&gt;&gt;   first argument, we skip it in considering this criterion:<br>&gt;&gt; <br>&gt;&gt;      a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing <br>&gt;&gt;                       // the semantics.  &quot;Observer&quot; is omitted in <br>&gt;&gt;                       // making this determination.<br>&gt;&gt; <br>&gt;&gt; * We could say &quot;clause&quot; here but I think making it an *independent*<br>&gt;&gt;  clause doesn&#39;t rule out any important use-cases (see<br>&gt;&gt;  https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that<br>&gt;&gt;  point, you might as well say &quot;sentence,&quot; which is a more<br>&gt;&gt;  universally-understood term.<br>&gt;<br>&gt; I&#39;ve been considering this for a bit, and I&#39;d like to suggest a<br>&gt; different way of thinking about things. This is kind of high-level and<br>&gt; may need to be translated into concrete guidelines, but it&#39;s guided my<br>&gt; thinking about good Swift method names recently.<br>&gt;<br>&gt; You can broadly separate parameters into operands and<br>&gt; options. Operands slot into the &quot;sentence&quot; formed by the method name;<br>&gt; options generally do not.<br>&gt;<br>&gt; Operands should generally *not* be labeled explicitly with the name of<br>&gt; what&#39;s being passed in that slot; the name should fall out by<br>&gt; grammatical implication. For instance, in:<br>&gt;<br>&gt; 	foo.remove(bar)<br>&gt;<br>&gt; The only sensible way of reading that is that `bar` will be removed<br>&gt; from `foo`. If it were the other way around, it would have to be:<br>&gt;<br>&gt; 	foo.removeFrom(bar)<br>&gt;<br>&gt; A second operand should usually be labeled, but not explicitly—only by<br>&gt; grammatical implication. Again, this is because the structure of the<br>&gt; &quot;sentence&quot; should imply the role of each operand. So when we want to<br>&gt; insert into an array, which has two operands, we say:<br>&gt;<br>&gt; 	foo.insert(bar, at: 0)<br>&gt;<br>&gt; The grammar used to label the first parameter, however, should be<br>&gt; included in the method name itself. In a sense, the method&#39;s name<br>&gt; should be thought of as &quot;insert at&quot;, but the constraints of Swift<br>&gt; syntax demands we use a parameter label for the &quot;at&quot;.<br>&gt;<br>&gt; (There are, of course, the twin exceptions of omitting completely<br>&gt; vacuous labels and labeling the meaning of operands whose type is not<br>&gt; specific enough to imply their meaning. Both of these are at work in<br>&gt; `reduce(_:combine:)`; it should theoretically be something like<br>&gt; `reduce(_:with:)`, but `with` is vacuous and the type of the parameter<br>&gt; is not strong enough to imply its meaning and it needs to be labeled<br>&gt; `combine`.)<br>&gt;<br>&gt; Options, on the other hand, *are* explicitly labeled with the meaning<br>&gt; of the parameter, because they aren&#39;t as directly connected to the<br>&gt; sentence and it would be difficult to imply their role. Hence, in<br>&gt; something like:<br>&gt;<br>&gt; 	foo.lexicographicalCompare(foo2, isOrderedBefore: &lt;)<br>&gt;<br>&gt; The second parameter is an option and has to be explicitly labeled<br>&gt; with its meaning. Options *often* have default values, but not always;<br>&gt; for instance, the `animated` parameter in many UIKit methods is an<br>&gt; option, but Swift does not give it a default value.<br>&gt;<br>&gt; Because options should be explicitly labeled with their meaning but<br>&gt; operands should have their meaning implied, options usually have the<br>&gt; same label and variable name, while operands usually have different<br>&gt; labels and variable names. This is not *always* the case, but it&#39;s a<br>&gt; pretty strong hint.<br>&gt;<br>&gt; *Usually* the first parameter is an operand and the other parameters<br>&gt; are options, and so by default, Swift gives the first parameter an<br>&gt; empty label and the remaining parameters a label matching their<br>&gt; variable name. But you may have to override that in either direction<br>&gt; if your method doesn&#39;t quite fit that norm.<br>&gt;<br>&gt; Incidentally, I would like to suggest one small change based on this<br>&gt; conception: the `min` and `max` free functions should be called<br>&gt; `minOf` and `maxOf`. This both reads slightly better and gives them<br>&gt; distinct names from the `Collection` methods.<br></p><p>I believe everything you&#39;ve written here is actually expressed, in<br>practice, by the guidelines I&#39;ve suggested.  I went through many of the<br>same thought processes in working the guidelines out.  The trick is to<br>capture these thoughts in something simply stated that has the right<br>effect.  If you think the guideline I suggested doesn&#39;t have the right<br>effect, please demonstrate a case where your thought process would lead<br>to a different API choice.<br></p><p>&gt; * * *<br>&gt;<br>&gt; As long as I&#39;m here, a word about method names.<br>&gt;<br>&gt; I&#39;ve seen some suggestions that method names should be only verbs, and<br>&gt; so `-addSubview:` should be `add(subview:)`. I don&#39;t think this is<br>&gt; useful or appropriate.<br>&gt;<br>&gt; What you need to understand about this is that the `Subview` in<br>&gt; `-addSubview:` is not really labeling the parameter. It&#39;s connecting<br>&gt; the method to the `subviews` collection. <br></p><p>Exactly.  adding a subview is different, *in its primary semantics* from<br>adding, say, a gesture recognizer.<br></p><p>&gt; Similarly, in `-addObserver:forKeyPath:options:context:`, the<br>&gt; `Observer` is connecting the method to the (private,<br>&gt; side-table-stored) observer list. This also reflects the fact that,<br>&gt; even though these two operations both &quot;add&quot; something, they are<br>&gt; massively different—`addObserver` and `addSubview` have almost nothing<br>&gt; in common.<br>&gt;<br>&gt; Importing `-addSubview:` as `add(subview:)` would be like importing<br>&gt; `-setNeedsDisplayInRect:` as `set(needsDisplayInRect:)`. The method<br>&gt; name quite simply no longer describes the operation being performed.<br></p><p>Technically the required labels are part of the method name, but I think<br>we all recognize that the base name of the method (the part before the<br>opening parenthesis) is naturally more important to a person reading<br>swift code.  The idea of these guidelines is that the primary semantics<br>of the method should, whenever possible, be expressed in the base name<br>and the first parameter, and when the first parameter either not not<br>part of the primary semantics, or (with the base name) not enough to<br>express the primary semantics, it should be labeled.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February  4, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; I believe everything you&#39;ve written here is actually expressed, in<br>&gt; practice, by the guidelines I&#39;ve suggested.  I went through many of the<br>&gt; same thought processes in working the guidelines out.  The trick is to<br>&gt; capture these thoughts in something simply stated that has the right<br>&gt; effect.  If you think the guideline I suggested doesn&#39;t have the right<br>&gt; effect, please demonstrate a case where your thought process would lead<br>&gt; to a different API choice.<br></p><p>I think our positions are basically compatible; I simply find an explanation like this useful to understand *why* the rules are as they are. Many of the objections and alternative proposals I&#39;ve been seeing don&#39;t seem to be informed by this philosophy.<br></p><p>I&#39;m wondering if we should write up a rationale for the API guidelines as a design document that people can optionally read to help them understand the guiding philosophy behind the API guidelines.<br></p><p>(I also wonder if introducing the concept of an option in a more explicit way might clarify some rules; for instance, the rule about giving the first parameter a label if it&#39;s defaulted is really about giving it a label if it&#39;s an *option*.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February  4, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Feb 4, 2016, at 12:10 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; I believe everything you&#39;ve written here is actually expressed, in<br>&gt;&gt; practice, by the guidelines I&#39;ve suggested.  I went through many of the<br>&gt;&gt; same thought processes in working the guidelines out.  The trick is to<br>&gt;&gt; capture these thoughts in something simply stated that has the right<br>&gt;&gt; effect.  If you think the guideline I suggested doesn&#39;t have the right<br>&gt;&gt; effect, please demonstrate a case where your thought process would lead<br>&gt;&gt; to a different API choice.<br>&gt; <br>&gt; I think our positions are basically compatible; I simply find an explanation like this useful to understand *why* the rules are as they are. Many of the objections and alternative proposals I&#39;ve been seeing don&#39;t seem to be informed by this philosophy.<br>&gt; <br>&gt; I&#39;m wondering if we should write up a rationale for the API guidelines as a design document that people can optionally read to help them understand the guiding philosophy behind the API guidelines.<br></p><p>Yeah, or there can be a section in the guidelines, or we can find another way to integrate rationale.  That should definitely be available somehow if people find it helpful.<br></p><p>&gt; (I also wonder if introducing the concept of an option in a more explicit way might clarify some rules; for instance, the rule about giving the first parameter a label if it&#39;s defaulted is really about giving it a label if it&#39;s an *option*.)<br></p><p>I think it would possibly clarify the *rationale* behind some rules, but that&#39;s not the same as stating the rule clearly.  The fewer specific guidelines and angles you&#39;re required to use to analyze any given API design scenario, the better.  If we can clearly define what &quot;option&quot; means and replace some other criterion with that one, then it could be an improvement, but I don&#39;t see a clear path from here to there.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February  5, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Am 04.02.2016 um 17:55 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Feb 4, 2016, at 12:10 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I believe everything you&#39;ve written here is actually expressed, in<br>&gt;&gt;&gt; practice, by the guidelines I&#39;ve suggested.  I went through many of the<br>&gt;&gt;&gt; same thought processes in working the guidelines out.  The trick is to<br>&gt;&gt;&gt; capture these thoughts in something simply stated that has the right<br>&gt;&gt;&gt; effect.  If you think the guideline I suggested doesn&#39;t have the right<br>&gt;&gt;&gt; effect, please demonstrate a case where your thought process would lead<br>&gt;&gt;&gt; to a different API choice.<br>&gt;&gt; <br>&gt;&gt; I think our positions are basically compatible; I simply find an explanation like this useful to understand *why* the rules are as they are. Many of the objections and alternative proposals I&#39;ve been seeing don&#39;t seem to be informed by this philosophy.<br>&gt;&gt; <br>&gt;&gt; I&#39;m wondering if we should write up a rationale for the API guidelines as a design document that people can optionally read to help them understand the guiding philosophy behind the API guidelines.<br>&gt; <br>&gt; Yeah, or there can be a section in the guidelines, or we can find another way to integrate rationale.  That should definitely be available somehow if people find it helpful.<br></p><p>That would be great! I always find it helpful to read a rationale for rules or design decisions to better understand them.<br></p><p><br>&gt;&gt; (I also wonder if introducing the concept of an option in a more explicit way might clarify some rules; for instance, the rule about giving the first parameter a label if it&#39;s defaulted is really about giving it a label if it&#39;s an *option*.)<br>&gt; <br>&gt; I think it would possibly clarify the *rationale* behind some rules, but that&#39;s not the same as stating the rule clearly.  The fewer specific guidelines and angles you&#39;re required to use to analyze any given API design scenario, the better.  <br></p><p>I totally agree (though the rationale would still be valuable).<br></p><p>-Thorsten <br></p><p><br>&gt; If we can clearly define what &quot;option&quot; means and replace some other criterion with that one, then it could be an improvement, but I don&#39;t see a clear path from here to there.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
