<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/27cba2e668c6c6fb1f1d4669b1474397?s=50"></div><header><strong>Proposal for Passing Arrays to Variadic Functions</strong> from <string>Arthur Ariel Sabintsev</string> &lt;arthur at sabintsev.com&gt;<p>December 12, 2015 at 01:00:00am</p></header><div class="content"><p>Hi,<br></p><p>I have put together a proposal for passing arrays to variadic functions (along the lines of Ruby’s Splay operator). <br></p><p>Proposal: https://github.com/ArtSabintsev/swift-evolution/blob/master/proposals/array-variadic-function.md<br>Pull Request: https://github.com/apple/swift-evolution/pull/52<br>Bug Report: https://bugs.swift.org/browse/SR-128 which led to this proposal<br></p><p><br>Best,<br></p><p>Arthur / Sabintsev.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/d37801f4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal for Passing Arrays to Variadic Functions</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 11, 2015 at 10:00:00pm</p></header><div class="content"><p>You can&#39;t use * as suggested, because that conflicts with * as a<br>prefix operator.<br></p><p>You could probably get away with using a trailing ... in the call, as in<br></p><p>func foo(xs: [Int]...) {    bar(xs...) }<br></p><p>I also wonder whether there&#39;s a reason Swift doesn&#39;t already support<br>this. Maybe there&#39;s some desired future change to variadic arguments to<br>improve performance (i.e. to avoid having to allocate an array) that<br>wouldn&#39;t be compatible? Although I&#39;m not sure what that would be. Maybe<br>there&#39;s actually no barrier at all and it was just something that wasn&#39;t<br>prioritized. It would be good to know either way.<br></p><p>-Kevin<br></p><p>On Fri, Dec 11, 2015, at 10:43 PM, Arthur Sabintsev via swift-evolution wrote:<br>&gt; Hi,<br>&gt;<br>&gt; I have put together a proposal for passing arrays to variadic<br>&gt; functions (along the lines of Ruby’s Splay operator).<br>&gt;<br>&gt; Proposal:<br>&gt; https://github.com/ArtSabintsev/swift-evolution/blob/master/proposals/array-variadic-function.md<br>&gt; Pull Request: https://github.com/apple/swift-evolution/pull/52 Bug<br>&gt; Report: https://bugs.swift.org/browse/SR-128 which led to this<br>&gt; proposal<br>&gt;<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt; Arthur / Sabintsev.com[1]<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>Links:<br></p><p>  1. http://sabintsev.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/4dd64b58/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/27cba2e668c6c6fb1f1d4669b1474397?s=50"></div><header><strong>Proposal for Passing Arrays to Variadic Functions</strong> from <string>Arthur Ariel Sabintsev</string> &lt;arthur at sabintsev.com&gt;<p>December 12, 2015 at 02:00:00am</p></header><div class="content"><p>Thanks for your response.<br></p><p>The reason this doesn&#39;t work is due to Swift&#39;s generic system as it allows<br>a type T to be a anything, including arrays. The example that was used to<br>delineate this concept to me was that of &quot;Any...&quot;, which from within the<br>variadic function, could be interpreted as T or [T]. The result is<br>ambiguous in the current implementation, which is why some identifier<br>syntax needs be passed along with an array to get this to work properly.<br></p><p>As for the choice of operator, I&#39;m open to suggestions. I wanted to use one<br>that was familiar to other developers, so I chose the one that Ruby uses.<br></p><p>Maybe a ~ would be better, or a keyword like @variadic?<br></p><p><br>Best,<br></p><p>Arthur / Sabintsev.com &lt;http://sabintsev.com/&gt;<br></p><p>On Sat, Dec 12, 2015 at 1:54 AM, Kevin Ballard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; You can&#39;t use * as suggested, because that conflicts with * as a prefix<br>&gt; operator.<br>&gt;<br>&gt; You could probably get away with using a trailing ... in the call, as in<br>&gt;<br>&gt; func foo(xs: [Int]...) {<br>&gt;     bar(xs...)<br>&gt; }<br>&gt;<br>&gt; I also wonder whether there&#39;s a reason Swift doesn&#39;t already support this.<br>&gt; Maybe there&#39;s some desired future change to variadic arguments to improve<br>&gt; performance (i.e. to avoid having to allocate an array) that wouldn&#39;t be<br>&gt; compatible? Although I&#39;m not sure what that would be. Maybe there&#39;s<br>&gt; actually no barrier at all and it was just something that wasn&#39;t<br>&gt; prioritized. It would be good to know either way.<br>&gt;<br>&gt; -Kevin<br>&gt;<br>&gt; On Fri, Dec 11, 2015, at 10:43 PM, Arthur Sabintsev via swift-evolution<br>&gt; wrote:<br>&gt;<br>&gt; Hi,<br>&gt;<br>&gt; I have put together a proposal for passing arrays to variadic functions<br>&gt; (along the lines of Ruby’s Splay operator).<br>&gt;<br>&gt; Proposal:<br>&gt; https://github.com/ArtSabintsev/swift-evolution/blob/master/proposals/array-variadic-function.md<br>&gt; Pull Request: https://github.com/apple/swift-evolution/pull/52<br>&gt; Bug Report: https://bugs.swift.org/browse/SR-128 which led to this<br>&gt; proposal<br>&gt;<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt; Arthur / Sabintsev.com &lt;http://sabintsev.com&gt;<br>&gt;<br>&gt; *_______________________________________________*<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/5838b21a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal for Passing Arrays to Variadic Functions</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 11, 2015 at 11:00:00pm</p></header><div class="content"><p>Using any operator at all is a problem. The only way that can work<br>without conflict is if the operator returns some special type that is<br>known to the compiler to represent a variadic call, but that doesn&#39;t<br>seem like a great idea. What do you think of the ... suffix? That can&#39;t<br>conflict with operators, and it matches the variadic function<br>declaration.<br></p><p>-Kevin<br></p><p>On Fri, Dec 11, 2015, at 11:12 PM, Arthur Ariel Sabintsev wrote:<br>&gt; Thanks for your response.<br>&gt;<br>&gt; The reason this doesn&#39;t work is due to Swift&#39;s generic system as it<br>&gt; allows a type T to be a anything, including arrays. The example that<br>&gt; was used to delineate this concept to me was that of &quot;Any...&quot;, which<br>&gt; from within the variadic function, could be interpreted as T or [T].<br>&gt; The result is ambiguous in the current implementation, which is why<br>&gt; some identifier syntax needs be passed along with an array to get this<br>&gt; to work properly.<br>&gt;<br>&gt; As for the choice of operator, I&#39;m open to suggestions. I wanted to<br>&gt; use one that was familiar to other developers, so I chose the one that<br>&gt; Ruby uses.<br>&gt;<br>&gt; Maybe a ~ would be better, or a keyword like @variadic?<br>&gt;<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt; Arthur / Sabintsev.com[1]<br>&gt;<br>&gt; On Sat, Dec 12, 2015 at 1:54 AM, Kevin Ballard via swift-evolution &lt;swift-<br>&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt; __<br>&gt;&gt; You can&#39;t use * as suggested, because that conflicts with * as a<br>&gt;&gt; prefix operator.<br>&gt;&gt;<br>&gt;&gt; You could probably get away with using a trailing ... in the<br>&gt;&gt; call, as in<br>&gt;&gt;<br>&gt;&gt; func foo(xs: [Int]...) {    bar(xs...) }<br>&gt;&gt;<br>&gt;&gt; I also wonder whether there&#39;s a reason Swift doesn&#39;t already<br>&gt;&gt; support this. Maybe there&#39;s some desired future change to variadic<br>&gt;&gt; arguments to improve performance (i.e. to avoid having to allocate<br>&gt;&gt; an array) that wouldn&#39;t be compatible? Although I&#39;m not sure what<br>&gt;&gt; that would be. Maybe there&#39;s actually no barrier at all and it was<br>&gt;&gt; just something that wasn&#39;t prioritized. It would be good to know<br>&gt;&gt; either way.<br>&gt;&gt;<br>&gt;&gt; -Kevin<br>&gt;&gt;<br>&gt;&gt; On Fri, Dec 11, 2015, at 10:43 PM, Arthur Sabintsev via swift-<br>&gt;&gt; evolution wrote:<br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I have put together a proposal for passing arrays to variadic<br>&gt;&gt;&gt; functions (along the lines of Ruby’s Splay operator).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Proposal:<br>&gt;&gt;&gt; https://github.com/ArtSabintsev/swift-evolution/blob/master/proposals/array-variadic-function.md<br>&gt;&gt;&gt; Pull Request: https://github.com/apple/swift-evolution/pull/52 Bug<br>&gt;&gt;&gt; Report: https://bugs.swift.org/browse/SR-128 which led to this<br>&gt;&gt;&gt; proposal<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Arthur / Sabintsev.com[2]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _________________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt;<br>swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p><p><br></p><p>Links:<br></p><p>  1. http://sabintsev.com/<br>  2. http://sabintsev.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/7efcd2c0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/27cba2e668c6c6fb1f1d4669b1474397?s=50"></div><header><strong>Proposal for Passing Arrays to Variadic Functions</strong> from <string>Arthur Ariel Sabintsev</string> &lt;arthur at sabintsev.com&gt;<p>December 12, 2015 at 02:00:00am</p></header><div class="content"><p>Just to make sure we&#39;re on the same page, your suggestion is the following:<br></p><p>// Declaration<br>func myFunc(v: T...) {}<br></p><p>// Call<br>myFunc([T]...)<br></p><p>That seems quite ugly, no? I&#39;d prefer the use of a keyword at that point,<br>kind of like we have @autoclosure, but instead of declaring the keyword in<br>the function definition, we use the keyword (e.g., @variadic) in the<br>function call.<br></p><p>Thoughts on that?<br></p><p>Best,<br></p><p>Arthur / Sabintsev.com &lt;http://sabintsev.com/&gt;<br></p><p>On Sat, Dec 12, 2015 at 2:15 AM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br></p><p>&gt; Using any operator at all is a problem. The only way that can work without<br>&gt; conflict is if the operator returns some special type that is known to the<br>&gt; compiler to represent a variadic call, but that doesn&#39;t seem like a great<br>&gt; idea. What do you think of the ... suffix? That can&#39;t conflict with<br>&gt; operators, and it matches the variadic function declaration.<br>&gt;<br>&gt; -Kevin<br>&gt;<br>&gt; On Fri, Dec 11, 2015, at 11:12 PM, Arthur Ariel Sabintsev wrote:<br>&gt;<br>&gt; Thanks for your response.<br>&gt;<br>&gt; The reason this doesn&#39;t work is due to Swift&#39;s generic system as it allows<br>&gt; a type T to be a anything, including arrays. The example that was used to<br>&gt; delineate this concept to me was that of &quot;Any...&quot;, which from within the<br>&gt; variadic function, could be interpreted as T or [T]. The result is<br>&gt; ambiguous in the current implementation, which is why some identifier<br>&gt; syntax needs be passed along with an array to get this to work properly.<br>&gt;<br>&gt; As for the choice of operator, I&#39;m open to suggestions. I wanted to use<br>&gt; one that was familiar to other developers, so I chose the one that Ruby<br>&gt; uses.<br>&gt;<br>&gt; Maybe a ~ would be better, or a keyword like @variadic?<br>&gt;<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt; Arthur / Sabintsev.com &lt;http://sabintsev.com/&gt;<br>&gt;<br>&gt; On Sat, Dec 12, 2015 at 1:54 AM, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; You can&#39;t use * as suggested, because that conflicts with * as a prefix<br>&gt; operator.<br>&gt;<br>&gt; You could probably get away with using a trailing ... in the call, as in<br>&gt;<br>&gt; func foo(xs: [Int]...) {<br>&gt;     bar(xs...)<br>&gt; }<br>&gt;<br>&gt; I also wonder whether there&#39;s a reason Swift doesn&#39;t already support this.<br>&gt; Maybe there&#39;s some desired future change to variadic arguments to improve<br>&gt; performance (i.e. to avoid having to allocate an array) that wouldn&#39;t be<br>&gt; compatible? Although I&#39;m not sure what that would be. Maybe there&#39;s<br>&gt; actually no barrier at all and it was just something that wasn&#39;t<br>&gt; prioritized. It would be good to know either way.<br>&gt;<br>&gt; -Kevin<br>&gt;<br>&gt; On Fri, Dec 11, 2015, at 10:43 PM, Arthur Sabintsev via swift-evolution<br>&gt; wrote:<br>&gt;<br>&gt; Hi,<br>&gt;<br>&gt; I have put together a proposal for passing arrays to variadic functions<br>&gt; (along the lines of Ruby’s Splay operator).<br>&gt;<br>&gt; Proposal:<br>&gt; https://github.com/ArtSabintsev/swift-evolution/blob/master/proposals/array-variadic-function.md<br>&gt; Pull Request: https://github.com/apple/swift-evolution/pull/52<br>&gt; Bug Report: https://bugs.swift.org/browse/SR-128 which led to this<br>&gt; proposal<br>&gt;<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt; Arthur / Sabintsev.com &lt;http://sabintsev.com&gt;<br>&gt;<br>&gt; *_______________________________________________*<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/94d7cbe5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal for Passing Arrays to Variadic Functions</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 12, 2015 at 12:00:00am</p></header><div class="content"><p>Yeah, except you&#39;d never actually write myFunc([T]...), because you can<br>just say myFunc(T) in that case. So it would really be used like<br>myFunc(args...)<br></p><p>@autoclosure isn&#39;t a keyword, it&#39;s an attribute. AFAIK we have no<br>precedence for attributes on expressions, only on declarations. And I&#39;d<br>think we&#39;d need to have a really compelling reason to start putting<br>attributes on expressions, since that&#39;s kind of weird.<br></p><p>-Kevin<br></p><p>On Fri, Dec 11, 2015, at 11:20 PM, Arthur Ariel Sabintsev wrote:<br>&gt; Just to make sure we&#39;re on the same page, your suggestion is the<br>&gt; following:<br>&gt;<br>&gt; // Declaration func myFunc(v: T...) {}<br>&gt;<br>&gt; // Call myFunc([T]...)<br>&gt;<br>&gt; That seems quite ugly, no? I&#39;d prefer the use of a keyword at that<br>&gt; point, kind of like we have @autoclosure, but instead of declaring the<br>&gt; keyword in the function definition, we use the keyword (e.g.,<br>&gt; @variadic) in the function call.<br>&gt;<br>&gt; Thoughts on that?<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt; Arthur / Sabintsev.com[1]<br>&gt;<br>&gt; On Sat, Dec 12, 2015 at 2:15 AM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt; __<br>&gt;&gt; Using any operator at all is a problem. The only way that can work<br>&gt;&gt; without conflict is if the operator returns some special type that is<br>&gt;&gt; known to the compiler to represent a variadic call, but that doesn&#39;t<br>&gt;&gt; seem like a great idea. What do you think of the ... suffix? That<br>&gt;&gt; can&#39;t conflict with operators, and it matches the variadic function<br>&gt;&gt; declaration.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; -Kevin<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Fri, Dec 11, 2015, at 11:12 PM, Arthur Ariel Sabintsev wrote:<br>&gt;&gt;&gt; Thanks for your response.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The reason this doesn&#39;t work is due to Swift&#39;s generic system as it<br>&gt;&gt;&gt; allows a type T to be a anything, including arrays. The example that<br>&gt;&gt;&gt; was used to delineate this concept to me was that of &quot;Any...&quot;, which<br>&gt;&gt;&gt; from within the variadic function, could be interpreted as T or [T].<br>&gt;&gt;&gt; The result is ambiguous in the current implementation, which is why<br>&gt;&gt;&gt; some identifier syntax needs be passed along with an array to get<br>&gt;&gt;&gt; this to work properly.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As for the choice of operator, I&#39;m open to suggestions. I wanted to<br>&gt;&gt;&gt; use one that was familiar to other developers, so I chose the one<br>&gt;&gt;&gt; that Ruby uses.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Maybe a ~ would be better, or a keyword like @variadic?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Arthur / Sabintsev.com[2]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sat, Dec 12, 2015 at 1:54 AM, Kevin Ballard via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; __<br>&gt;&gt;&gt;&gt; You can&#39;t use * as suggested, because that conflicts with * as a<br>&gt;&gt;&gt;&gt; prefix operator.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; You could probably get away with using a trailing ... in the call,<br>&gt;&gt;&gt;&gt; as in<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func foo(xs: [Int]...) {    bar(xs...) }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I also wonder whether there&#39;s a reason Swift doesn&#39;t already<br>&gt;&gt;&gt;&gt; support this. Maybe there&#39;s some desired future change to variadic<br>&gt;&gt;&gt;&gt; arguments to improve performance (i.e. to avoid having to allocate<br>&gt;&gt;&gt;&gt; an array) that wouldn&#39;t be compatible? Although I&#39;m not sure what<br>&gt;&gt;&gt;&gt; that would be. Maybe there&#39;s actually no barrier at all and it was<br>&gt;&gt;&gt;&gt; just something that wasn&#39;t prioritized. It would be good to know<br>&gt;&gt;&gt;&gt; either way.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Kevin<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Fri, Dec 11, 2015, at 10:43 PM, Arthur Sabintsev via swift-<br>&gt;&gt;&gt;&gt; evolution wrote:<br>&gt;&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I have put together a proposal for passing arrays to variadic<br>&gt;&gt;&gt;&gt;&gt; functions (along the lines of Ruby’s Splay operator).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Proposal:<br>&gt;&gt;&gt;&gt;&gt; https://github.com/ArtSabintsev/swift-evolution/blob/master/proposals/array-variadic-function.md<br>&gt;&gt;&gt;&gt;&gt; Pull Request: https://github.com/apple/swift-evolution/pull/52 Bug<br>&gt;&gt;&gt;&gt;&gt; Report: https://bugs.swift.org/browse/SR-128 which led to this<br>&gt;&gt;&gt;&gt;&gt; proposal<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Arthur / Sabintsev.com[3]<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _________________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;<br></p><p><br></p><p>Links:<br></p><p>  1. http://sabintsev.com/<br>  2. http://sabintsev.com/<br>  3. http://sabintsev.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/ac96134c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal for Passing Arrays to Variadic Functions</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 12, 2015 at 11:00:00am</p></header><div class="content"><p>Why not omit the operator:<br></p><p>myFunc([T])<br></p><p>and only require it to disambiguate cases like &quot;Any...&quot;:<br></p><p>myFunc([T]...)<br></p><p>Ambiguous cases should be rather uncommon anyway.<br></p><p>On Sat, Dec 12, 2015 at 9:03 AM, Kevin Ballard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Yeah, except you&#39;d never actually write myFunc([T]...), because you can<br>&gt; just say myFunc(T) in that case. So it would really be used like<br>&gt; myFunc(args...)<br>&gt;<br>&gt; @autoclosure isn&#39;t a keyword, it&#39;s an attribute. AFAIK we have no<br>&gt; precedence for attributes on expressions, only on declarations. And I&#39;d<br>&gt; think we&#39;d need to have a really compelling reason to start putting<br>&gt; attributes on expressions, since that&#39;s kind of weird.<br>&gt;<br>&gt; -Kevin<br>&gt;<br>&gt; On Fri, Dec 11, 2015, at 11:20 PM, Arthur Ariel Sabintsev wrote:<br>&gt;<br>&gt; Just to make sure we&#39;re on the same page, your suggestion is the following:<br>&gt;<br>&gt; // Declaration<br>&gt; func myFunc(v: T...) {}<br>&gt;<br>&gt; // Call<br>&gt; myFunc([T]...)<br>&gt;<br>&gt; That seems quite ugly, no? I&#39;d prefer the use of a keyword at that point,<br>&gt; kind of like we have @autoclosure, but instead of declaring the keyword in<br>&gt; the function definition, we use the keyword (e.g., @variadic) in the<br>&gt; function call.<br>&gt;<br>&gt; Thoughts on that?<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt; Arthur / Sabintsev.com &lt;http://sabintsev.com/&gt;<br>&gt;<br>&gt; On Sat, Dec 12, 2015 at 2:15 AM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Using any operator at all is a problem. The only way that can work without<br>&gt; conflict is if the operator returns some special type that is known to the<br>&gt; compiler to represent a variadic call, but that doesn&#39;t seem like a great<br>&gt; idea. What do you think of the ... suffix? That can&#39;t conflict with<br>&gt; operators, and it matches the variadic function declaration.<br>&gt;<br>&gt;<br>&gt; -Kevin<br>&gt;<br>&gt;<br>&gt; On Fri, Dec 11, 2015, at 11:12 PM, Arthur Ariel Sabintsev wrote:<br>&gt;<br>&gt; Thanks for your response.<br>&gt;<br>&gt; The reason this doesn&#39;t work is due to Swift&#39;s generic system as it allows<br>&gt; a type T to be a anything, including arrays. The example that was used to<br>&gt; delineate this concept to me was that of &quot;Any...&quot;, which from within the<br>&gt; variadic function, could be interpreted as T or [T]. The result is<br>&gt; ambiguous in the current implementation, which is why some identifier<br>&gt; syntax needs be passed along with an array to get this to work properly.<br>&gt;<br>&gt; As for the choice of operator, I&#39;m open to suggestions. I wanted to use<br>&gt; one that was familiar to other developers, so I chose the one that Ruby<br>&gt; uses.<br>&gt;<br>&gt; Maybe a ~ would be better, or a keyword like @variadic?<br>&gt;<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt; Arthur / Sabintsev.com &lt;http://sabintsev.com/&gt;<br>&gt;<br>&gt; On Sat, Dec 12, 2015 at 1:54 AM, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; You can&#39;t use * as suggested, because that conflicts with * as a prefix<br>&gt; operator.<br>&gt;<br>&gt; You could probably get away with using a trailing ... in the call, as in<br>&gt;<br>&gt; func foo(xs: [Int]...) {<br>&gt;     bar(xs...)<br>&gt; }<br>&gt;<br>&gt; I also wonder whether there&#39;s a reason Swift doesn&#39;t already support this.<br>&gt; Maybe there&#39;s some desired future change to variadic arguments to improve<br>&gt; performance (i.e. to avoid having to allocate an array) that wouldn&#39;t be<br>&gt; compatible? Although I&#39;m not sure what that would be. Maybe there&#39;s<br>&gt; actually no barrier at all and it was just something that wasn&#39;t<br>&gt; prioritized. It would be good to know either way.<br>&gt;<br>&gt; -Kevin<br>&gt;<br>&gt; On Fri, Dec 11, 2015, at 10:43 PM, Arthur Sabintsev via swift-evolution<br>&gt; wrote:<br>&gt;<br>&gt; Hi,<br>&gt;<br>&gt; I have put together a proposal for passing arrays to variadic functions<br>&gt; (along the lines of Ruby’s Splay operator).<br>&gt;<br>&gt; Proposal:<br>&gt; https://github.com/ArtSabintsev/swift-evolution/blob/master/proposals/array-variadic-function.md<br>&gt; Pull Request: https://github.com/apple/swift-evolution/pull/52<br>&gt; Bug Report: https://bugs.swift.org/browse/SR-128 which led to this<br>&gt; proposal<br>&gt;<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt; Arthur / Sabintsev.com &lt;http://sabintsev.com&gt;<br>&gt;<br>&gt; *_______________________________________________*<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/97f36b39/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/27cba2e668c6c6fb1f1d4669b1474397?s=50"></div><header><strong>Proposal for Passing Arrays to Variadic Functions</strong> from <string>Arthur Ariel Sabintsev</string> &lt;arthur at sabintsev.com&gt;<p>December 12, 2015 at 02:00:00pm</p></header><div class="content"><p>You’re right, it’s an attribute. My mistake.<br></p><p>I’d actually prefer to only have to use an operator when the compiler throws a warning stating that the input is ambiguous, as is the case with Any, [Any], AnyObject, and [AnyObject].<br></p><p>Best,<br></p><p>Arthur / Sabintsev.com<br></p><p>On December 12, 2015 at 5:44:16 AM, Marc Knaup (marc at knaup.koeln) wrote:<br></p><p>Why not omit the operator:<br></p><p>myFunc([T])<br></p><p>and only require it to disambiguate cases like &quot;Any...&quot;:<br></p><p>myFunc([T]...)<br></p><p>Ambiguous cases should be rather uncommon anyway.<br></p><p>On Sat, Dec 12, 2015 at 9:03 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>Yeah, except you&#39;d never actually write myFunc([T]...), because you can just say myFunc(T) in that case. So it would really be used like myFunc(args...)<br> <br>@autoclosure isn&#39;t a keyword, it&#39;s an attribute. AFAIK we have no precedence for attributes on expressions, only on declarations. And I&#39;d think we&#39;d need to have a really compelling reason to start putting attributes on expressions, since that&#39;s kind of weird.<br> <br>-Kevin<br> <br>On Fri, Dec 11, 2015, at 11:20 PM, Arthur Ariel Sabintsev wrote:<br>Just to make sure we&#39;re on the same page, your suggestion is the following:<br> <br>// Declaration<br>func myFunc(v: T...) {}<br> <br>// Call<br>myFunc([T]...)<br> <br>That seems quite ugly, no? I&#39;d prefer the use of a keyword at that point, kind of like we have @autoclosure, but instead of declaring the keyword in the function definition, we use the keyword (e.g., @variadic) in the function call.<br> <br>Thoughts on that?<br> <br>Best,<br> <br>Arthur / Sabintsev.com<br> <br>On Sat, Dec 12, 2015 at 2:15 AM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br></p><p>Using any operator at all is a problem. The only way that can work without conflict is if the operator returns some special type that is known to the compiler to represent a variadic call, but that doesn&#39;t seem like a great idea. What do you think of the ... suffix? That can&#39;t conflict with operators, and it matches the variadic function declaration.<br> <br> <br>-Kevin<br> <br> <br>On Fri, Dec 11, 2015, at 11:12 PM, Arthur Ariel Sabintsev wrote:<br>Thanks for your response. <br> <br>The reason this doesn&#39;t work is due to Swift&#39;s generic system as it allows a type T to be a anything, including arrays. The example that was used to delineate this concept to me was that of &quot;Any...&quot;, which from within the variadic function, could be interpreted as T or [T]. The result is ambiguous in the current implementation, which is why some identifier syntax needs be passed along with an array to get this to work properly.<br> <br>As for the choice of operator, I&#39;m open to suggestions. I wanted to use one that was familiar to other developers, so I chose the one that Ruby uses. <br> <br>Maybe a ~ would be better, or a keyword like @variadic?<br> <br> <br>Best,<br> <br>Arthur / Sabintsev.com<br> <br>On Sat, Dec 12, 2015 at 1:54 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>You can&#39;t use * as suggested, because that conflicts with * as a prefix operator.<br> <br>You could probably get away with using a trailing ... in the call, as in<br> <br>func foo(xs: [Int]...) {<br>    bar(xs...)<br>}<br> <br>I also wonder whether there&#39;s a reason Swift doesn&#39;t already support this. Maybe there&#39;s some desired future change to variadic arguments to improve performance (i.e. to avoid having to allocate an array) that wouldn&#39;t be compatible? Although I&#39;m not sure what that would be. Maybe there&#39;s actually no barrier at all and it was just something that wasn&#39;t prioritized. It would be good to know either way.<br> <br>-Kevin<br> <br>On Fri, Dec 11, 2015, at 10:43 PM, Arthur Sabintsev via swift-evolution wrote:<br>Hi,<br> <br>I have put together a proposal for passing arrays to variadic functions (along the lines of Ruby’s Splay operator). <br> <br>Proposal: https://github.com/ArtSabintsev/swift-evolution/blob/master/proposals/array-variadic-function.md<br>Pull Request: https://github.com/apple/swift-evolution/pull/52<br>Bug Report: https://bugs.swift.org/browse/SR-128 which led to this proposal<br> <br> <br>Best,<br> <br>Arthur / Sabintsev.com<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br> <br></p><p> <br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br> <br> <br> <br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/9bf5d449/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal for Passing Arrays to Variadic Functions</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 12, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 12, 2015, at 12:12 AM, Arthur Ariel Sabintsev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks for your response. <br>&gt; <br>&gt; The reason this doesn&#39;t work is due to Swift&#39;s generic system as it allows a type T to be a anything, including arrays. The example that was used to delineate this concept to me was that of &quot;Any...&quot;, which from within the variadic function, could be interpreted as T or [T]. The result is ambiguous in the current implementation, which is why some identifier syntax needs be passed along with an array to get this to work properly.<br>&gt; <br>&gt; As for the choice of operator, I&#39;m open to suggestions. I wanted to use one that was familiar to other developers, so I chose the one that Ruby uses. <br>&gt; <br>&gt; Maybe a ~ would be better, or a keyword like @variadic?<br>&gt; <br></p><p>I was thinking of a second type (VariadicArray&lt;T&gt;, perhaps) which you received in the body of your function instead of Array, and which was not supported via … sequence (so no args: VariadicArray&lt;T&gt;… allowed). However, it looks like this type would have to be fixed, not allowing for protocol compliance (including Any)<br></p><p>Would it be possible to automatically take a function which uses T… and generate the [T] argument version of the function? Today, I just implement the [T] variant and have the T… function do nothing but call it.<br></p><p>-DW<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/27cba2e668c6c6fb1f1d4669b1474397?s=50"></div><header><strong>Proposal for Passing Arrays to Variadic Functions</strong> from <string>Arthur Ariel Sabintsev</string> &lt;arthur at sabintsev.com&gt;<p>December 12, 2015 at 02:00:00pm</p></header><div class="content"><p>Hmm, a VariadicArray&lt;T&gt; sounds like an interesting solution, however, it would break existing implementation. I’m trying to avoid having to do that.<br></p><p>I think the previously discussed solutions, and/or your proposal for strict-typing (e.g., disallowing Any), are steps in the right direction, as they introduce new functionality without breaking existing implementations. <br></p><p>Just my 0.02.<br></p><p>Best,<br></p><p>Arthur / Sabintsev.com<br></p><p>On December 12, 2015 at 2:39:26 PM, David Waite (david at alkaline-solutions.com) wrote:<br></p><p><br>&gt; On Dec 12, 2015, at 12:12 AM, Arthur Ariel Sabintsev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:  <br>&gt;  <br>&gt; Thanks for your response.  <br>&gt;  <br>&gt; The reason this doesn&#39;t work is due to Swift&#39;s generic system as it allows a type T to be a anything, including arrays. The example that was used to delineate this concept to me was that of &quot;Any...&quot;, which from within the variadic function, could be interpreted as T or [T]. The result is ambiguous in the current implementation, which is why some identifier syntax needs be passed along with an array to get this to work properly.  <br>&gt;  <br>&gt; As for the choice of operator, I&#39;m open to suggestions. I wanted to use one that was familiar to other developers, so I chose the one that Ruby uses.  <br>&gt;  <br>&gt; Maybe a ~ would be better, or a keyword like @variadic?  <br>&gt;  <br></p><p>I was thinking of a second type (VariadicArray&lt;T&gt;, perhaps) which you received in the body of your function instead of Array, and which was not supported via … sequence (so no args: VariadicArray&lt;T&gt;… allowed). However, it looks like this type would have to be fixed, not allowing for protocol compliance (including Any)  <br></p><p>Would it be possible to automatically take a function which uses T… and generate the [T] argument version of the function? Today, I just implement the [T] variant and have the T… function do nothing but call it.  <br></p><p>-DW<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/8e65b19d/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal for Passing Arrays to Variadic Functions</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 12, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 10:54 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; You can&#39;t use * as suggested, because that conflicts with * as a prefix operator.<br>&gt;  <br>&gt; You could probably get away with using a trailing ... in the call, as in<br>&gt;  <br>&gt; func foo(xs: [Int]...) {<br>&gt;     bar(xs...)<br>&gt; }<br>&gt;  <br>&gt; I also wonder whether there&#39;s a reason Swift doesn&#39;t already support this. Maybe there&#39;s some desired future change to variadic arguments to improve performance (i.e. to avoid having to allocate an array) that wouldn&#39;t be compatible? Although I&#39;m not sure what that would be. Maybe there&#39;s actually no barrier at all and it was just something that wasn&#39;t prioritized. It would be good to know either way.<br></p><p>No fundamental reason, just haven&#39;t gotten around to it. We are however planning to rework the type system model for functions not to be tuple-based, since it causes problems with unconstrained polymorphism, default arguments, inout parameters, and other function features. We&#39;ll need a replacement feature to support forwarding argument tuples if we do this. cc&#39;ing Chris Willmore, who has been working a plan here.<br></p><p>-Joe<br></p><p>&gt; -Kevin<br>&gt;  <br>&gt; On Fri, Dec 11, 2015, at 10:43 PM, Arthur Sabintsev via swift-evolution wrote:<br>&gt;&gt; Hi,<br>&gt;&gt;  <br>&gt;&gt; I have put together a proposal for passing arrays to variadic functions (along the lines of Ruby’s Splay operator). <br>&gt;&gt;  <br>&gt;&gt; Proposal: https://github.com/ArtSabintsev/swift-evolution/blob/master/proposals/array-variadic-function.md &lt;https://github.com/ArtSabintsev/swift-evolution/blob/master/proposals/array-variadic-function.md&gt;<br>&gt;&gt; Pull Request: https://github.com/apple/swift-evolution/pull/52 &lt;https://github.com/apple/swift-evolution/pull/52&gt;<br>&gt;&gt; Bug Report: https://bugs.swift.org/browse/SR-128 &lt;https://bugs.swift.org/browse/SR-128&gt; which led to this proposal<br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt; Best,<br>&gt;&gt;  <br>&gt;&gt; Arthur / Sabintsev.com &lt;http://sabintsev.com/&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/8da69617/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Proposal for Passing Arrays to Variadic Functions</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 13, 2015 at 02:00:00am</p></header><div class="content"><p>To summarize, there are 4 options used by other languages:<br></p><p>func(*args) — Ruby &amp; Python<br></p><p>func(args...) — Go<br></p><p>func(...args) — CoffeeScript, I believe (it&#39;s been a while)<br></p><p>func(args) — C# does this, I think, and probably some others<br></p><p><br>I personally believe that:<br></p><p>1. passing an array as a variadic argument list definitely requires some annotation at the call site<br></p><p>2.  func(args...) looks awesome and matches the existing declaration syntax, so it should be a clear winner in Swift.<br></p><p><br>A.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/27cba2e668c6c6fb1f1d4669b1474397?s=50"></div><header><strong>Proposal for Passing Arrays to Variadic Functions</strong> from <string>Arthur Ariel Sabintsev</string> &lt;arthur at sabintsev.com&gt;<p>December 12, 2015 at 03:00:00pm</p></header><div class="content"><p>I think it’s a postfix in coffeescript.<br></p><p>Anyway,  I’m with you on both points! As much as I think func(args…) is ugly, it works, and fits the current paradigm.<br></p><p>Best,<br></p><p>Arthur / Sabintsev.com<br></p><p>On December 12, 2015 at 3:25:48 PM, Andrey Tarantsov via swift-evolution (swift-evolution at swift.org) wrote:<br></p><p>To summarize, there are 4 options used by other languages:<br></p><p>func(*args) — Ruby &amp; Python<br></p><p>func(args...) — Go<br></p><p>func(...args) — CoffeeScript, I believe (it&#39;s been a while)<br></p><p>func(args) — C# does this, I think, and probably some others<br></p><p><br>I personally believe that:<br></p><p>1. passing an array as a variadic argument list definitely requires some annotation at the call site<br></p><p>2. func(args...) looks awesome and matches the existing declaration syntax, so it should be a clear winner in Swift.<br></p><p><br>A.<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/a529fa14/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal for Passing Arrays to Variadic Functions</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 13, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 10:54 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; You can&#39;t use * as suggested, because that conflicts with * as a prefix operator.<br>&gt;  <br>&gt; You could probably get away with using a trailing ... in the call, as in<br>&gt;  <br>&gt; func foo(xs: [Int]...) {<br>&gt;     bar(xs...)<br>&gt; }<br>&gt;  <br>&gt; I also wonder whether there&#39;s a reason Swift doesn&#39;t already support this. Maybe there&#39;s some desired future change to variadic arguments to improve performance (i.e. to avoid having to allocate an array) that wouldn&#39;t be compatible? Although I&#39;m not sure what that would be. Maybe there&#39;s actually no barrier at all and it was just something that wasn&#39;t prioritized. It would be good to know either way.<br></p><p>This hasn’t been done just because it has never risen to the highest priority, not because we’re against it.  In addition to Joe Groff’s downstream comment, one change we need to discuss: requiring the formation of a formal Array is somewhat unfortunate from a performance perspective.  It would make more sense to pass varargs by allocating the array as a fixed size buffer in the callers stack, and passing a pointer+length down to the callee.  The callee could then wrap that up and vend it with a formal type of Array or perhaps just SequenceType.  In the case where the sequence doesn’t escape, this would allow the allocation/deallocation + copy to the heap to be eliminated.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal for Passing Arrays to Variadic Functions</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 13, 2015 at 03:00:00pm</p></header><div class="content"><p>On Sun, Dec 13, 2015, at 03:00 PM, Chris Lattner wrote:<br>&gt; <br>&gt; &gt; On Dec 11, 2015, at 10:54 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; You can&#39;t use * as suggested, because that conflicts with * as a prefix operator.<br>&gt; &gt;  <br>&gt; &gt; You could probably get away with using a trailing ... in the call, as in<br>&gt; &gt;  <br>&gt; &gt; func foo(xs: [Int]...) {<br>&gt; &gt;     bar(xs...)<br>&gt; &gt; }<br>&gt; &gt;  <br>&gt; &gt; I also wonder whether there&#39;s a reason Swift doesn&#39;t already support this. Maybe there&#39;s some desired future change to variadic arguments to improve performance (i.e. to avoid having to allocate an array) that wouldn&#39;t be compatible? Although I&#39;m not sure what that would be. Maybe there&#39;s actually no barrier at all and it was just something that wasn&#39;t prioritized. It would be good to know either way.<br>&gt; <br>&gt; This hasn’t been done just because it has never risen to the highest priority, not because we’re against it.  In addition to Joe Groff’s downstream comment, one change we need to discuss: requiring the formation of a formal Array is somewhat unfortunate from a performance perspective.  It would make more sense to pass varargs by allocating the array as a fixed size buffer in the callers stack, and passing a pointer+length down to the callee.  The callee could then wrap that up and vend it with a formal type of Array or perhaps just SequenceType.  In the case where the sequence doesn’t escape, this would allow the allocation/deallocation + copy to the heap to be eliminated.<br></p><p>It would actually be pretty neat if we could do this not as a special case of variadic arguments, but as a general case of passing an array to any function. If the array never escapes the function call and it only reads from it, then having the array point to the stack frame of the caller would be great. Even mutation that doesn&#39;t increase the array size could be done in-place on the stack. Any action that might cause the array to escape the function (or any mutation that increases its size) could then move it to the heap. Mutation doesn&#39;t even need special handling; since the capacity is equal to the size, it&#39;ll move to the heap on any size increase automatically (and size decreases is fine, as the array will manage destruction of the elements). All the compiler really has to do is insert a call that forces a move-to-heap prior to any action that may cause the array to escape the function (e.g. assigning to a property, or capturing in an escaping closure).<br></p><p>If that function call is sufficiently cheap (and it should basically just be testing a boolean flag), then hopefully it&#39;s cheap enough to use everywhere for arrays passed as parameters to functions. If it turns out to actually be an issue then maybe we could use an attribute to annotate array parameters that allow for stack allocation, but that would mean it&#39;s used pretty rarely as people will usually not bother (except when it&#39;s automatically added for varargs).<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal for Passing Arrays to Variadic Functions</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 13, 2015 at 07:00:00pm</p></header><div class="content"><p>On Dec 13, 2015, at 3:53 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt; This hasn’t been done just because it has never risen to the highest priority, not because we’re against it.  In addition to Joe Groff’s downstream comment, one change we need to discuss: requiring the formation of a formal Array is somewhat unfortunate from a performance perspective.  It would make more sense to pass varargs by allocating the array as a fixed size buffer in the callers stack, and passing a pointer+length down to the callee.  The callee could then wrap that up and vend it with a formal type of Array or perhaps just SequenceType.  In the case where the sequence doesn’t escape, this would allow the allocation/deallocation + copy to the heap to be eliminated.<br>&gt; <br>&gt; It would actually be pretty neat if we could do this not as a special case of variadic arguments, but as a general case of passing an array to any function. If the array never escapes the function call and it only reads from it, then having the array point to the stack frame of the caller would be great. Even mutation that doesn&#39;t increase the array size could be done in-place on the stack. Any action that might cause the array to escape the function (or any mutation that increases its size) could then move it to the heap. Mutation doesn&#39;t even need special handling; since the capacity is equal to the size, it&#39;ll move to the heap on any size increase automatically (and size decreases is fine, as the array will manage destruction of the elements). All the compiler really has to do is insert a call that forces a move-to-heap prior to any action that may cause the array to escape the function (e.g. assigning to a property, or capturing in an escaping closure).<br>&gt; <br>&gt; If that function call is sufficiently cheap (and it should basically just be testing a boolean flag), then hopefully it&#39;s cheap enough to use everywhere for arrays passed as parameters to functions. If it turns out to actually be an issue then maybe we could use an attribute to annotate array parameters that allow for stack allocation, but that would mean it&#39;s used pretty rarely as people will usually not bother (except when it&#39;s automatically added for varargs).<br></p><p>Yes, there is some form of this that could be possible to do.  The trick with varargs though is that the caller always (at least without the “forwarding” case) knows the number of arguments that will be passed.  This means that the buffer allocated on the stack in the caller is a fixed and obviously known size, which is usually very small.  <br></p><p>A similar optimization could be done when passing down an array literal, but the calling convention would have to support passing down an array value obtained in other ways (e.g. passed down to the caller or loaded from memory).  In that case, it is hard to beat the performance of a single retain: no copy of the elements are implied.  Doing the optimization for general unknown number of elements also isn’t profitable in general because the stack is a very finite resource, so you’d have to handle the “large” case somehow.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal for Passing Arrays to Variadic Functions</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 14, 2015 at 01:00:00pm</p></header><div class="content"><p>On Sun, Dec 13, 2015, at 07:42 PM, Chris Lattner wrote:<br>&gt; On Dec 13, 2015, at 3:53 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; &gt;&gt; This hasn’t been done just because it has never risen to the highest priority, not because we’re against it.  In addition to Joe Groff’s downstream comment, one change we need to discuss: requiring the formation of a formal Array is somewhat unfortunate from a performance perspective.  It would make more sense to pass varargs by allocating the array as a fixed size buffer in the callers stack, and passing a pointer+length down to the callee.  The callee could then wrap that up and vend it with a formal type of Array or perhaps just SequenceType.  In the case where the sequence doesn’t escape, this would allow the allocation/deallocation + copy to the heap to be eliminated.<br>&gt; &gt; <br>&gt; &gt; It would actually be pretty neat if we could do this not as a special case of variadic arguments, but as a general case of passing an array to any function. If the array never escapes the function call and it only reads from it, then having the array point to the stack frame of the caller would be great. Even mutation that doesn&#39;t increase the array size could be done in-place on the stack. Any action that might cause the array to escape the function (or any mutation that increases its size) could then move it to the heap. Mutation doesn&#39;t even need special handling; since the capacity is equal to the size, it&#39;ll move to the heap on any size increase automatically (and size decreases is fine, as the array will manage destruction of the elements). All the compiler really has to do is insert a call that forces a move-to-heap prior to any action that may cause the array to escape the function (e.g. assigning to a property, or capturing in an escaping closure).<br>&gt; &gt; <br>&gt; &gt; If that function call is sufficiently cheap (and it should basically just be testing a boolean flag), then hopefully it&#39;s cheap enough to use everywhere for arrays passed as parameters to functions. If it turns out to actually be an issue then maybe we could use an attribute to annotate array parameters that allow for stack allocation, but that would mean it&#39;s used pretty rarely as people will usually not bother (except when it&#39;s automatically added for varargs).<br>&gt; <br>&gt; Yes, there is some form of this that could be possible to do.  The trick with varargs though is that the caller always (at least without the “forwarding” case) knows the number of arguments that will be passed.  This means that the buffer allocated on the stack in the caller is a fixed and obviously known size, which is usually very small.  <br>&gt; <br>&gt; A similar optimization could be done when passing down an array literal, but the calling convention would have to support passing down an array value obtained in other ways (e.g. passed down to the caller or loaded from memory).  In that case, it is hard to beat the performance of a single retain: no copy of the elements are implied.  Doing the optimization for general unknown number of elements also isn’t profitable in general because the stack is a very finite resource, so you’d have to handle the “large” case somehow.<br></p><p>Oh sure, when I said doing it in the general case, I just meant for arrays created from array literals (or possibly even arrays constructed using .append(), if the optimizer really wants to go ahead and figure out how many elements the resulting array has). And I was thinking that the calling convention is just pass an array, and instead Array will have the flag internally in its native storage that says &quot;my buffer is on the stack&quot; (as well as having a special method to construct an array from a stack buffer that the compiler will use for array literals / varargs). The biggest complication is having the compiler insert calls to array.moveToHeapIfCurrentlyOnStack() whenever an array parameter escapes the function (arrays returned from functions can&#39;t be on the stack, and arrays created in the function can skip the stack if it&#39;s known to escape), and the question there is whether this call will have meaningful performance implications.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal for Passing Arrays to Variadic Functions</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 14, 2015 at 10:00:00pm</p></header><div class="content"><p>On Dec 14, 2015, at 1:13 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt; A similar optimization could be done when passing down an array literal, but the calling convention would have to support passing down an array value obtained in other ways (e.g. passed down to the caller or loaded from memory).  In that case, it is hard to beat the performance of a single retain: no copy of the elements are implied.  Doing the optimization for general unknown number of elements also isn’t profitable in general because the stack is a very finite resource, so you’d have to handle the “large” case somehow.<br>&gt; <br>&gt; Oh sure, when I said doing it in the general case, I just meant for arrays created from array literals (or possibly even arrays constructed using .append(), if the optimizer really wants to go ahead and figure out how many elements the resulting array has). And I was thinking that the calling convention is just pass an array, and instead Array will have the flag internally in its native storage that says &quot;my buffer is on the stack&quot; (as well as having a special method to construct an array from a stack buffer that the compiler will use for array literals / varargs). The biggest complication is having the compiler insert calls to array.moveToHeapIfCurrentlyOnStack() whenever an array parameter escapes the function (arrays returned from functions can&#39;t be on the stack, and arrays created in the function can skip the stack if it&#39;s known to escape), and the question there is whether this call will have meaningful performance implications.<br></p><p>Ah, I understand the model you’re envisioning.<br></p><p>We’re *extremely* reticent to make the hot paths of Array any slow (things like subscript for example), particularly when you may be talking about [Float] or [Int], because those are types that are important to get vectorized.  Right now, the only slowdown vs C that you get on those hot paths on arrays of structs are the array bounds check, and that check is often hoisted out of loops.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
