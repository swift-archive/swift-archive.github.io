<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February  5, 2016 at 11:00:00am</p></header><div class="content"><p>on Fri Feb 05 2016, Craig Cruden &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Swift reduce has a starting value and likely is just a fold, not a<br>&gt; reduce (at least when it is compared to Scala; not sure about when it<br>&gt; comes to big data).<br></p><p>IME fold and reduce have always been synonyms.  Did I miss some memo?<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Proposal: Pattern Matching Partial Function (#111)</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February  6, 2016 at 02:00:00am</p></header><div class="content"><p>Actually with Scala (and from what I gather from Big Data) — reduce and fold from the outside look like synonyms — BUT they are not.  <br></p><p>inline from http://stackoverflow.com/questions/25158780/difference-between-reduce-and-foldleft-fold-in-functional-programming-particula &lt;http://stackoverflow.com/questions/25158780/difference-between-reduce-and-foldleft-fold-in-functional-programming-particula&gt;<br></p><p>reduce vs foldLeft<br></p><p>A big big difference, not mentioned in any other stackoverflow answer relating to this topic clearly, is that reduce should be given a commutative monoid, i.e. an operation that is both commutative and associative. This means the operation can be parallelized.<br></p><p>This distinction is very important for Big Data / MPP / distributed computing, and the entire reason why reduce even exists. The collection can be chopped up and the reduce can operate on each chunk, then the reduce can operate on the results of each chunk - in fact the level of chunking need not stop one level deep. We could chop up each chunk too. This is why summing integers in a list is O(log N) if given an infinite number of CPUs.<br></p><p>If you just look at the signatures there is no reason for reduce to exist because you can achieve everything you can with reduce with a foldLeft. The functionality of foldLeft is a greater than the functionality of reduce.<br></p><p>But you cannot parallelize a foldLeft, so its runtime is always O(N) (even if you feed in a commutative monoid). This is because it&#39;s assumed the operation is not a commutative monoid and so the cumulated value will be computed by a series of sequential aggregations.<br></p><p>foldLeft does not assume commutativity nor associativity. It&#39;s associativity that gives the ability to chop up the collection, and it&#39;s commutativity that makes cumulating easy because order is not important (so it doesn&#39;t matter which order to aggregate each of the results from each of the chunks). Strictly speaking commutativity is not necessary for parallelization, for example distributed sorting algorithms, it just makes the logic easier because you don&#39;t need to give your chunks an ordering.<br></p><p>If you have a look at the Spark documentation for reduce it specifically says &quot;... commutative and associative binary operator&quot;<br></p><p>http://spark.apache.org/docs/1.0.0/api/scala/index.html#org.apache.spark.rdd.RDD &lt;http://spark.apache.org/docs/1.0.0/api/scala/index.html#org.apache.spark.rdd.RDD&gt;<br>Here is proof that reduce is NOT just a special case of foldLeft<br></p><p>scala&gt; val intParList: ParSeq[Int] = (1 to 100000).map(_ =&gt; scala.util.Random.nextInt()).par<br></p><p>scala&gt; timeMany(1000, intParList.reduce(_ + _))<br>Took 462.395867 milli seconds<br></p><p>scala&gt; timeMany(1000, intParList.foldLeft(0)(_ + _))<br>Took 2589.363031 milli seconds<br>reduce vs fold<br></p><p>Now this is where it gets a little closer to the FP Category Theory roots, and a little trickier to explain.<br></p><p>There is no fold method in Scalding because under the (strict) Map Reduce programming model we cannot define fold because chunks do not have an ordering and fold only requires associativity, not commutativity. Spark does have fold because its framework is a super-set of the Map Reduce programming model and can order its chunks. Well you can actually do this in Hadoop too, but Scalding doesn&#39;t seem to expose this functionality in the version I&#39;m familiar with.<br></p><p>Put simply, reduce works without an order of cumulation, fold requires an order of cumulation and it is that order of cumulation that necessitates a zero value NOT the existence of the zero value that distinguishes them. Strictly speaking reduce should work on an empty collection, because its zero value can by deduced by taking an arbitrary value x and then solving x op y = x, but that doesn&#39;t work with a non-commutative operation as there can exist a left and right zero value that are distinct (i.e. x op y != y op x). Of course Scala doesn&#39;t bother to work out what this zero value is as that would require doing some mathematics (which are probably uncomputable), so just throws an exception.<br></p><p>This difference between reduce* and fold* is a FP historical convention and has its roots in Category Theory. I hope now this deep difference relating to parallelization will no longer go unnoticed :)<br></p><p><br></p><p><br>&gt; On 2016-02-06, at 2:30:01, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Feb 05 2016, Craig Cruden &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Swift reduce has a starting value and likely is just a fold, not a<br>&gt;&gt; reduce (at least when it is compared to Scala; not sure about when it<br>&gt;&gt; comes to big data).<br>&gt; <br>&gt; IME fold and reduce have always been synonyms.  Did I miss some memo?<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160206/072dcc68/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
