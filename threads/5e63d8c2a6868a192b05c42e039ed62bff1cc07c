<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/50a236e50d72e5e32f294d62dc57b5ba?s=50"></div><header><strong>Sketch: Teach init a &#39;defer&#39;-like ability to deinit</strong> from <string>Graham Perks</string> &lt;grahamperks at mac.com&gt;<p>June  8, 2016 at 11:00:00am</p></header><div class="content"><p>Teach init a &#39;defer&#39;-like ability to deinit<br></p><p>&#39;defer&#39; is a great way to ensure some clean up code is run; it&#39;s declaritive locality to the resource acquisition is a boon to clarity.<br></p><p>Swift offers no support for resources acquired during &#39;init&#39;.<br></p><p>For an example, from https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html<br></p><p>init(count: Int = 0, ptr: UnsafeMutablePointer&lt;T&gt; = nil) {<br>    self.count = count<br>    self.space = count<br></p><p>    self.ptr = UnsafeMutablePointer&lt;T&gt;.alloc(count)<br>    self.ptr.initializeFrom(ptr, count: count)<br>}<br></p><p>deinit {<br>    ptr.destroy(...)<br>    ptr.dealloc(...)<br>}<br></p><p>Another &#39;resource&#39; might be adding an NSNotificationCenter observer, and wanting to unobserve in deinit (no need in OS X 10.11, iOS 9, but for earlier releases this is a valid example).<br></p><p>Changing the above code to use a &#39;defer&#39; style deinit block might look like:<br></p><p>init(count: Int = 0, ptr: UnsafeMutablePointer&lt;T&gt; = nil) {<br>    self.count = count<br>    self.space = count<br></p><p>    self.ptr = UnsafeMutablePointer&lt;T&gt;.alloc(count)<br>    self.ptr.initializeFrom(ptr, count: count)<br></p><p>    deinit {<br>        ptr.destroy(...)<br>        ptr.dealloc(...)<br>    }<br></p><p>    // NSNotificationCenter example too<br>    NSNotificationCenter.defaultCenter().addObserver(...)<br>    deinit { <br>        NSNotificationCenter.defaultCenter().removeObserver(...)<br>    }<br>}<br></p><p>The need to provide a separate implemention of deinit is gone. Reasoning for &#39;defer&#39; applies here. There is good locality between what was initialized and what needs cleaning up.<br></p><p>Considerations:<br>1. Should deinit blocks be invoked before or after code in an explicit deinit method?<br>2. Should deinit blocks be allowed in other methods; e.g. viewDidLoad()?<br>3. How should deinit blocks be prevented from strongly capturing self (thus preventing themselves from ever running!)?<br></p><p><br>Cheers,<br>Graham Perks.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/5e63c07c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Sketch: Teach init a &#39;defer&#39;-like ability to deinit</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June  8, 2016 at 03:00:00pm</p></header><div class="content"><p>I really like this idea. Spatially moving cleanup next to unsafe operations is good practice.<br></p><p>In normal code, I want my cleanup to follow as closely as possible to my unsafe act:<br></p><p>let buffer: UnsafeMutablePointer&lt;CChar&gt; = UnsafeMutablePointer(allocatingCapacity: chunkSize)<br>    defer { buffer.deallocateCapacity(chunkSize) }<br></p><p>(Sorry for the horrible example, but it&#39;s the best I could grep up with on a moment&#39;s notice)<br></p><p>I like your idea but what I want to see is not the deinit child closure in init you propose but a new keyword that means defer-on-deinit-cleanup<br></p><p>self.ptr = UnsafeMutablePointer&lt;T&gt;(allocatingCapacity: count)<br>    deferringDeInit { self.ptr.deallocateCapacity(count) }<br></p><p>Or something.<br></p><p>-- E<br>p.s. Normally I put them on the same line with a semicolon but dang these things can be long<br></p><p>&gt; On Jun 8, 2016, at 10:54 AM, Graham Perks via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Teach init a &#39;defer&#39;-like ability to deinit<br>&gt; <br>&gt; &#39;defer&#39; is a great way to ensure some clean up code is run; it&#39;s declaritive locality to the resource acquisition is a boon to clarity.<br>&gt; <br>&gt; Swift offers no support for resources acquired during &#39;init&#39;.<br>&gt; <br>&gt; For an example, from https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html &lt;https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html&gt;<br>&gt; <br>&gt; init(count: Int = 0, ptr: UnsafeMutablePointer&lt;T&gt; = nil) {<br>&gt;     self.count = count<br>&gt;     self.space = count<br>&gt; <br>&gt;     self.ptr = UnsafeMutablePointer&lt;T&gt;.alloc(count)<br>&gt;     self.ptr.initializeFrom(ptr, count: count)<br>&gt; }<br>&gt; <br>&gt; deinit {<br>&gt;     ptr.destroy(...)<br>&gt;     ptr.dealloc(...)<br>&gt; }<br>&gt; <br>&gt; Another &#39;resource&#39; might be adding an NSNotificationCenter observer, and wanting to unobserve in deinit (no need in OS X 10.11, iOS 9, but for earlier releases this is a valid example).<br>&gt; <br>&gt; Changing the above code to use a &#39;defer&#39; style deinit block might look like:<br>&gt; <br>&gt; init(count: Int = 0, ptr: UnsafeMutablePointer&lt;T&gt; = nil) {<br>&gt;     self.count = count<br>&gt;     self.space = count<br>&gt; <br>&gt;     self.ptr = UnsafeMutablePointer&lt;T&gt;.alloc(count)<br>&gt;     self.ptr.initializeFrom(ptr, count: count)<br>&gt; <br>&gt;     deinit {<br>&gt;         ptr.destroy(...)<br>&gt;         ptr.dealloc(...)<br>&gt;     }<br>&gt; <br>&gt;     // NSNotificationCenter example too<br>&gt;     NSNotificationCenter.defaultCenter().addObserver(...)<br>&gt;     deinit { <br>&gt;         NSNotificationCenter.defaultCenter().removeObserver(...)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; The need to provide a separate implemention of deinit is gone. Reasoning for &#39;defer&#39; applies here. There is good locality between what was initialized and what needs cleaning up.<br>&gt; <br>&gt; Considerations:<br>&gt; 1. Should deinit blocks be invoked before or after code in an explicit deinit method?<br>&gt; 2. Should deinit blocks be allowed in other methods; e.g. viewDidLoad()?<br>&gt; 3. How should deinit blocks be prevented from strongly capturing self (thus preventing themselves from ever running!)?<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/ca9f5457/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Sketch: Teach init a &#39;defer&#39;-like ability to deinit</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 10, 2016 at 05:00:00pm</p></header><div class="content"><p>Twitter tl;dr: <br>&gt; Brent: So each instance must remember which init was used for it and then run the matching deinit code at deinit time?<br>&gt; Me: In my version, the constructive act and destructive act are always paired, even redundantly, using a stack if needed<br>&gt; Graham: so all your deferredDeinit blocks would run, no matter which init was invoked?<br>&gt; Brent: Closure stack in the worst case. Might be able to optimize to something cheaper if no captures.  Degenerate case: `for i in 0..&lt;10 { deinit { print(i) } <br></p><p>So continuing on from Twitter, assuming the compiler cannot optimize in the case of multiple inits, and init-redirections, how about allowing traditional deinit as well, and introduce compile-time optimization into traditional de-init if the compiler finds only one initialization path per class? We can also warn anyone using my version in a complicated degenerate way that it can be costly through education, manual, etc. It would also help if (especially in Cocoa), you could legally use shared initialization setup closures.<br></p><p>If I create an observer, I want to be able to handle its end-of-life at that point. If I allocate memory, ditto. Etc etc. Surely Swift should be able to support doing this.<br></p><p>-- E<br></p><p>&gt; On Jun 8, 2016, at 3:43 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I really like this idea. Spatially moving cleanup next to unsafe operations is good practice.<br>&gt; <br>&gt; In normal code, I want my cleanup to follow as closely as possible to my unsafe act:<br>&gt; <br>&gt; let buffer: UnsafeMutablePointer&lt;CChar&gt; = UnsafeMutablePointer(allocatingCapacity: chunkSize)<br>&gt;     defer { buffer.deallocateCapacity(chunkSize) }<br>&gt; <br>&gt; (Sorry for the horrible example, but it&#39;s the best I could grep up with on a moment&#39;s notice)<br>&gt; <br>&gt; I like your idea but what I want to see is not the deinit child closure in init you propose but a new keyword that means defer-on-deinit-cleanup<br>&gt; <br>&gt; self.ptr = UnsafeMutablePointer&lt;T&gt;(allocatingCapacity: count)<br>&gt;     deferringDeInit { self.ptr.deallocateCapacity(count) }<br>&gt; <br>&gt; Or something.<br>&gt; <br>&gt; -- E<br>&gt; p.s. Normally I put them on the same line with a semicolon but dang these things can be long<br>&gt; <br>&gt;&gt; On Jun 8, 2016, at 10:54 AM, Graham Perks via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Teach init a &#39;defer&#39;-like ability to deinit<br>&gt;&gt; <br>&gt;&gt; &#39;defer&#39; is a great way to ensure some clean up code is run; it&#39;s declaritive locality to the resource acquisition is a boon to clarity.<br>&gt;&gt; <br>&gt;&gt; Swift offers no support for resources acquired during &#39;init&#39;.<br>&gt;&gt; <br>&gt;&gt; For an example, from https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html &lt;https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html&gt;<br>&gt;&gt; <br>&gt;&gt; init(count: Int = 0, ptr: UnsafeMutablePointer&lt;T&gt; = nil) {<br>&gt;&gt;     self.count = count<br>&gt;&gt;     self.space = count<br>&gt;&gt; <br>&gt;&gt;     self.ptr = UnsafeMutablePointer&lt;T&gt;.alloc(count)<br>&gt;&gt;     self.ptr.initializeFrom(ptr, count: count)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; deinit {<br>&gt;&gt;     ptr.destroy(...)<br>&gt;&gt;     ptr.dealloc(...)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Another &#39;resource&#39; might be adding an NSNotificationCenter observer, and wanting to unobserve in deinit (no need in OS X 10.11, iOS 9, but for earlier releases this is a valid example).<br>&gt;&gt; <br>&gt;&gt; Changing the above code to use a &#39;defer&#39; style deinit block might look like:<br>&gt;&gt; <br>&gt;&gt; init(count: Int = 0, ptr: UnsafeMutablePointer&lt;T&gt; = nil) {<br>&gt;&gt;     self.count = count<br>&gt;&gt;     self.space = count<br>&gt;&gt; <br>&gt;&gt;     self.ptr = UnsafeMutablePointer&lt;T&gt;.alloc(count)<br>&gt;&gt;     self.ptr.initializeFrom(ptr, count: count)<br>&gt;&gt; <br>&gt;&gt;     deinit {<br>&gt;&gt;         ptr.destroy(...)<br>&gt;&gt;         ptr.dealloc(...)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     // NSNotificationCenter example too<br>&gt;&gt;     NSNotificationCenter.defaultCenter().addObserver(...)<br>&gt;&gt;     deinit { <br>&gt;&gt;         NSNotificationCenter.defaultCenter().removeObserver(...)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The need to provide a separate implemention of deinit is gone. Reasoning for &#39;defer&#39; applies here. There is good locality between what was initialized and what needs cleaning up.<br>&gt;&gt; <br>&gt;&gt; Considerations:<br>&gt;&gt; 1. Should deinit blocks be invoked before or after code in an explicit deinit method?<br>&gt;&gt; 2. Should deinit blocks be allowed in other methods; e.g. viewDidLoad()?<br>&gt;&gt; 3. How should deinit blocks be prevented from strongly capturing self (thus preventing themselves from ever running!)?<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160610/f6696899/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>Sketch: Teach init a &#39;defer&#39;-like ability to deinit</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>June 11, 2016 at 02:00:00pm</p></header><div class="content"><p>I like the idea, I don’t like the potential to capture anything else though, or for instances to store closure references. It should offer similar performance to a standard `deinit`.<br></p><p>Instead, what about a sibling to `willSet`, `didSet` etc?<br></p><p>class Foo&lt;T&gt; {<br>  var ptr: UnsafeMutablePointer&lt;T&gt; {<br>    deinit {<br>      ptr.destroy(...)<br>      ptr.dealloc(...)<br>    }<br>  }<br></p><p>  init(count: Int = 0, ptr: UnsafeMutablePointer&lt;T&gt; = nil) {<br>    self.count = count<br>    self.space = count<br></p><p>    self.ptr = UnsafeMutablePointer&lt;T&gt;.alloc(count)<br>    self.ptr.initializeFrom(ptr, count: count)<br>  }<br>}<br></p><p>That way you can have as many initializers as you like. It would be called when the object deinitializes only, and not when changing the property.<br></p><p>This could also hopefully be possible with property behaviours.<br></p><p>Patrick<br></p><p>&gt; On 11 Jun 2016, at 9:45 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Twitter tl;dr: <br>&gt;&gt; Brent: So each instance must remember which init was used for it and then run the matching deinit code at deinit time?<br>&gt;&gt; Me: In my version, the constructive act and destructive act are always paired, even redundantly, using a stack if needed<br>&gt;&gt; Graham: so all your deferredDeinit blocks would run, no matter which init was invoked?<br>&gt;&gt; Brent: Closure stack in the worst case. Might be able to optimize to something cheaper if no captures.  Degenerate case: `for i in 0..&lt;10 { deinit { print(i) } <br>&gt; <br>&gt; So continuing on from Twitter, assuming the compiler cannot optimize in the case of multiple inits, and init-redirections, how about allowing traditional deinit as well, and introduce compile-time optimization into traditional de-init if the compiler finds only one initialization path per class? We can also warn anyone using my version in a complicated degenerate way that it can be costly through education, manual, etc. It would also help if (especially in Cocoa), you could legally use shared initialization setup closures.<br>&gt; <br>&gt; If I create an observer, I want to be able to handle its end-of-life at that point. If I allocate memory, ditto. Etc etc. Surely Swift should be able to support doing this.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt;&gt; On Jun 8, 2016, at 3:43 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I really like this idea. Spatially moving cleanup next to unsafe operations is good practice.<br>&gt;&gt; <br>&gt;&gt; In normal code, I want my cleanup to follow as closely as possible to my unsafe act:<br>&gt;&gt; <br>&gt;&gt; let buffer: UnsafeMutablePointer&lt;CChar&gt; = UnsafeMutablePointer(allocatingCapacity: chunkSize)<br>&gt;&gt;     defer { buffer.deallocateCapacity(chunkSize) }<br>&gt;&gt; <br>&gt;&gt; (Sorry for the horrible example, but it&#39;s the best I could grep up with on a moment&#39;s notice)<br>&gt;&gt; <br>&gt;&gt; I like your idea but what I want to see is not the deinit child closure in init you propose but a new keyword that means defer-on-deinit-cleanup<br>&gt;&gt; <br>&gt;&gt; self.ptr = UnsafeMutablePointer&lt;T&gt;(allocatingCapacity: count)<br>&gt;&gt;     deferringDeInit { self.ptr.deallocateCapacity(count) }<br>&gt;&gt; <br>&gt;&gt; Or something.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; p.s. Normally I put them on the same line with a semicolon but dang these things can be long<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 8, 2016, at 10:54 AM, Graham Perks via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Teach init a &#39;defer&#39;-like ability to deinit<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &#39;defer&#39; is a great way to ensure some clean up code is run; it&#39;s declaritive locality to the resource acquisition is a boon to clarity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift offers no support for resources acquired during &#39;init&#39;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For an example, from https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html &lt;https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; init(count: Int = 0, ptr: UnsafeMutablePointer&lt;T&gt; = nil) {<br>&gt;&gt;&gt;     self.count = count<br>&gt;&gt;&gt;     self.space = count<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     self.ptr = UnsafeMutablePointer&lt;T&gt;.alloc(count)<br>&gt;&gt;&gt;     self.ptr.initializeFrom(ptr, count: count)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; deinit {<br>&gt;&gt;&gt;     ptr.destroy(...)<br>&gt;&gt;&gt;     ptr.dealloc(...)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another &#39;resource&#39; might be adding an NSNotificationCenter observer, and wanting to unobserve in deinit (no need in OS X 10.11, iOS 9, but for earlier releases this is a valid example).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Changing the above code to use a &#39;defer&#39; style deinit block might look like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; init(count: Int = 0, ptr: UnsafeMutablePointer&lt;T&gt; = nil) {<br>&gt;&gt;&gt;     self.count = count<br>&gt;&gt;&gt;     self.space = count<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     self.ptr = UnsafeMutablePointer&lt;T&gt;.alloc(count)<br>&gt;&gt;&gt;     self.ptr.initializeFrom(ptr, count: count)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     deinit {<br>&gt;&gt;&gt;         ptr.destroy(...)<br>&gt;&gt;&gt;         ptr.dealloc(...)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // NSNotificationCenter example too<br>&gt;&gt;&gt;     NSNotificationCenter.defaultCenter().addObserver(...)<br>&gt;&gt;&gt;     deinit { <br>&gt;&gt;&gt;         NSNotificationCenter.defaultCenter().removeObserver(...)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The need to provide a separate implemention of deinit is gone. Reasoning for &#39;defer&#39; applies here. There is good locality between what was initialized and what needs cleaning up.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Considerations:<br>&gt;&gt;&gt; 1. Should deinit blocks be invoked before or after code in an explicit deinit method?<br>&gt;&gt;&gt; 2. Should deinit blocks be allowed in other methods; e.g. viewDidLoad()?<br>&gt;&gt;&gt; 3. How should deinit blocks be prevented from strongly capturing self (thus preventing themselves from ever running!)?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160611/3209efaf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Sketch: Teach init a &#39;defer&#39;-like ability to deinit</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 11, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; class Foo&lt;T&gt; {<br>&gt;   var ptr: UnsafeMutablePointer&lt;T&gt; {<br>&gt;     deinit {<br>&gt;       ptr.destroy(...)<br>&gt;       ptr.dealloc(...)<br>&gt;     }<br>&gt;   }<br>&gt; <br>&gt;   init(count: Int = 0, ptr: UnsafeMutablePointer&lt;T&gt; = nil) {<br>&gt;     self.count = count<br>&gt;     self.space = count<br>&gt; <br>&gt;     self.ptr = UnsafeMutablePointer&lt;T&gt;.alloc(count)<br>&gt;     self.ptr.initializeFrom(ptr, count: count)<br>&gt;   }<br>&gt; }<br></p><p>I don&#39;t think this would address the stated goal of pairing initialization and deinitialization code so that one could not happen without the other.<br></p><p>On the other hand, I could imagine the *init* code also being moved into the accessor block, and then calling the init would implicitly schedule the deinit. For instance, suppose you said:<br></p><p>class Foo&lt;T&gt; {<br>  var count: Int, space: Int<br>  var ptr: UnsafeMutablePointer&lt;T&gt; {<br>    init(count: Int, ptr: UnsafeMutablePointer&lt;T&gt;) {<br>      self.ptr = UnsafeMutablePointer&lt;T&gt;.alloc(count)<br>      self.ptr.initializeFrom(ptr, count: count)<br>    }<br>    deinit {<br>      ptr.destroy(count)<br>      ptr.dealloc(space)<br>    }<br>  }<br></p><p>  init(count: Int = 0, ptr: UnsafeMutablePointer&lt;T&gt; = nil) {<br>    self.count = count<br>    self.space = count<br>    <br>    // Swift guarantees that, after a property&#39;s init returns, its deinit will always be called.<br>    // #property() is a placeholder for whatever syntax we use to call behavior-created methods.<br>    #property(self.ptr).init(count: count, ptr: ptr)<br>  }<br>}<br></p><p>Advantages include:<br></p><p>1. Initialization is broken up into per-property units, and deinitialization is paired with those units.<br>2. If a failable init returns during Phase 1, Swift can tell which properties have been initialized and need their deinits run. (I believe it&#39;s already doing this kind of tracking for non-custom stuff, like releasing.)<br>3. After phase 1, all inits have been run and all deinits are enabled, so there&#39;s no need to track anything anymore.<br>4. This could be used to allow stored properties in same-module extensions; we would just need to make an exception to access control so that the properties&#39; initializers would be visible to designated initializers (and their deinits visible to the type&#39;s deinit), even outside their normal scope. Concerns would not be *quite* as separated as we might like, but it&#39;s a lot better than the &quot;all stored properties in one file&quot; status quo.<br>5. This could be used to...well, you&#39;ll see.<br></p><p>Disadvantages include:<br></p><p>1. Property inits do not know which other properties will have already been initialized, so they can&#39;t access them.<br>2. There is nothing to indicate the order in which property deinits should be run.<br>3. You can probably write multiple inits for a single property, but they&#39;ll still have to share one deinit, so this improves but does not fully solve the original problem.<br>4. Not as flexible as partial inits.<br>5. Not as flexible as a deinit that can schedule arbitrary code blocks which could vary between inits, and might even be able to be used in other methods.<br></p><p>Disadvantages 1 and 2 might be addressable by introducing a mechanism to constrain property init ordering. For instance, you could declare dependencies between properties:<br></p><p>class Foo&lt;T&gt; {<br>  var count: Int, space: Int<br>  <br>  // This property&#39;s init and deinit can access `count` and `space`, but it can only be inited<br>  // after them and deinited before them.<br>  @depends(upon: count, space)<br>  var ptr: UnsafeMutablePointer&lt;T&gt; {<br>    init(ptr: UnsafeMutablePointer&lt;T&gt;) {<br>      self.ptr = UnsafeMutablePointer&lt;T&gt;.alloc(space)<br>      self.ptr.initializeFrom(ptr, count: count)<br>    }<br>    deinit {<br>      ptr.destroy(count)<br>      ptr.dealloc(space)<br>    }<br>  }<br></p><p>  init(count: Int = 0, ptr: UnsafeMutablePointer&lt;T&gt; = nil) {<br>    self.count = count<br>    self.space = count<br>    <br>    #property(self.ptr).init(ptr: ptr)<br>  }<br>}<br></p><p>When compiling a designated initializer, the compiler would simply need to make sure these ordering rules were not violated. When synthesizing a `deinit`, the compiler would have to build a property dependency graph and then write code compatible with it.<br></p><p>(I suppose it would probably still be possible to write a `deinit` by hand; you would then have to write `#property(self.ptr).deinit()` yourself, and the compiler would enforce dependencies in reverse.)<br></p><p>It&#39;s even possible that *all* properties would have initializers—`count` and `space` would have `init(count:)` and `init(space:)` initializers, respectively. Assigning to those properties while uninitialized would just be syntactic sugar for calling the property initializers, just as assigning to any other property is syntactic sugar for calling its setter.<br></p><p>	* * *<br></p><p>Let&#39;s take this further.<br></p><p>It might be possible to use this to synthesize designated initializers, essentially gaining more control over memberwise inits. For instance, if you wrote this class:<br></p><p>class Foo&lt;T&gt; {<br>  var count: Int {<br>    init(count: Int = 0) {<br>      self.count = count<br>    }<br>  }<br>  <br>  @depends(upon: count) var space: Int {<br>    init() {<br>      space = count<br>    }<br>  }<br>  <br>  @depends(upon: count, space)		// `count` here is probably redundant.<br>  var ptr: UnsafeMutablePointer&lt;T&gt; {<br>    init(ptr: UnsafeMutablePointer&lt;T&gt; = nil) {<br>      self.ptr = UnsafeMutablePointer&lt;T&gt;.alloc(space)<br>      self.ptr.initializeFrom(ptr, count: count)<br>    }<br>    deinit {<br>      ptr.destroy(count)<br>      ptr.dealloc(space)<br>    }<br>  }<br>}<br></p><p>The compiler might be able to look at the three property initializers:<br></p><p>	init(count: Int = 0)<br>	init()<br>	init(ptr: UnsafeMutablePointer&lt;T&gt; = nil)<br></p><p>And combine their signatures to create `init(count: Int = 0, ptr: UnsafeMutablePointer&lt;T&gt; = nil)`, then look at the dependency order to synthesize:<br></p><p>	init(count: Int = 0, ptr: UnsafeMutablePointer&lt;T&gt; = nil) {<br>		#property(self.count).init(count: count)<br>		#property(self.space).init()<br>		#property(self.ptr).init(ptr: ptr)<br>	}<br></p><p>By extending the rules for synthesizing property inits, this could be taken further:<br></p><p>1. A property with an initial value would get an `init()`. If that property had dependencies, it could use those dependencies in the initial value.<br>2. A property with an initial value, but marked with `@initable`, would get an `init(propertyName: Type = defaultValue)`.<br></p><p>(These rules could be reversed so that you mark the non-initable properties instead.)<br></p><p>To make the `init()` easier to use, it would be called automatically if necessary when you try to initialize another property that depends on it.<br></p><p>With all that in place, we can now write:<br></p><p>class Foo&lt;T&gt; {<br>  @initable var count = 0<br>  @depends(upon: count) var space = count<br>  <br>  @depends(upon: count, space)<br>  var ptr: UnsafeMutablePointer&lt;T&gt; {<br>    init(ptr: UnsafeMutablePointer&lt;T&gt; = nil) {<br>      self.ptr = UnsafeMutablePointer&lt;T&gt;.alloc(space)<br>      self.ptr.initializeFrom(ptr, count: count)<br>    }<br>    deinit {<br>      ptr.destroy(count)<br>      ptr.dealloc(space)<br>    }<br>  }<br>  <br>  // Synthesized for us:<br>  // <br>  // init(count: Int = 0, ptr: UnsafeMutablePointer&lt;T&gt; = nil) {<br>  //   self.count = count<br>  //   self.ptr = ptr<br>  // }<br>  // <br>  // Or, more explicitly:<br>  // <br>  // init(count: Int = 0, ptr: UnsafeMutablePointer&lt;T&gt; = nil) {<br>  //   #property(self.count).init(count: count)<br>  //   #property(self.space).init()<br>  //   #property(self.ptr).init(ptr: ptr)<br>  // }<br>}<br></p><p>Which is kind of a startling amount of functionality, given where we started.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
