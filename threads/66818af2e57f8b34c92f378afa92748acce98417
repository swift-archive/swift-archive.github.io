<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 29, 2016 at 12:00:00pm</p></header><div class="content"><p>https://github.com/apple/swift-evolution/pull/127 &lt;https://github.com/apple/swift-evolution/pull/127&gt;<br></p><p>Adjusting inout Declarations for Type Decoration<br></p><p>Proposal: TBD<br>Author(s): Joe Groff &lt;https://github.com/jckarter&gt;, Erica Sadun &lt;http://github.com/erica&gt;<br>Status: TBD<br>Review manager: TBD<br>Introduction<br></p><p>The inout keyword indicates copy-in/copy-out argument behavior. In its current implementation<br>the keyword prepands argument names. We propose to move the inout keyword to the right<br>side of the colon to decorate the type instead of the parameter label. <br></p><p>The initial Swift-Evolution discussion of this topic took place in the “Replace ‘inout’ with &amp;” thread.<br></p><p>Motivation<br></p><p>In Swift 2, the inout parameter lives on the label side rather than the type side of the colon<br>although the keyword isn’t modifying the label but its type. Decorating<br>types instead of labels offers identifiable advantages: <br></p><p>It enables the inout keyword to properly integrate into full type syntax, for example: <br>(x: inout T) -&gt; U // =&gt; (inout T) -&gt; U<br>It avoids notational similarity with arguments labeled inout, for example:<br>func foo(inOut x: T) // foo(inOut:), type (T) -&gt; Void<br>func foo(inout x: T) // foo(_:), type (inout T) -&gt; Void<br>It better matches similar patterns in other languages such as borrowing in Rust, that may be later introduced back to Swift <br>Detailed design<br></p><p>parameter → external-parameter-name optlocal-parameter-name : type-annotation<br>type-annotation → inout type-annotation<br>Alternatives Considered<br></p><p>Decorations using @inout (either @inout(T) or @inout T) were considered and discarded<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/66818417/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 29, 2016 at 11:00:00am</p></header><div class="content"><p>+1<br>&gt; On Jan 29, 2016, at 11:37, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/pull/127 &lt;https://github.com/apple/swift-evolution/pull/127&gt;<br>&gt; <br>&gt; Adjusting inout Declarations for Type Decoration<br>&gt; <br>&gt; Proposal: TBD<br>&gt; Author(s): Joe Groff &lt;https://github.com/jckarter&gt;, Erica Sadun &lt;http://github.com/erica&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; The inout keyword indicates copy-in/copy-out argument behavior. In its current implementation<br>&gt; the keyword prepands argument names. We propose to move the inout keyword to the right<br>&gt; side of the colon to decorate the type instead of the parameter label. <br>&gt; <br>&gt; The initial Swift-Evolution discussion of this topic took place in the “Replace ‘inout’ with &amp;” thread.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; In Swift 2, the inout parameter lives on the label side rather than the type side of the colon<br>&gt; although the keyword isn’t modifying the label but its type. Decorating<br>&gt; types instead of labels offers identifiable advantages: <br>&gt; <br>&gt; It enables the inout keyword to properly integrate into full type syntax, for example: <br>&gt; (x: inout T) -&gt; U // =&gt; (inout T) -&gt; U<br>&gt; It avoids notational similarity with arguments labeled inout, for example:<br>&gt; func foo(inOut x: T) // foo(inOut:), type (T) -&gt; Void<br>&gt; func foo(inout x: T) // foo(_:), type (inout T) -&gt; Void<br>&gt; It better matches similar patterns in other languages such as borrowing in Rust, that may be later introduced back to Swift <br>&gt; Detailed design<br>&gt; <br>&gt; parameter → external-parameter-name optlocal-parameter-name : type-annotation<br>&gt; type-annotation → inout type-annotation<br>&gt; Alternatives Considered<br>&gt; <br>&gt; Decorations using @inout (either @inout(T) or @inout T) were considered and discarded<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/d50b8887/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>January 29, 2016 at 02:00:00pm</p></header><div class="content"><p>+1<br></p><p>I would also like to change the call site to use inout as well.<br></p><p>foo(inout myVariable)<br></p><p>On Fri, Jan 29, 2016 at 2:40 PM, Dave via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1<br>&gt;<br>&gt; On Jan 29, 2016, at 11:37, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/pull/127<br>&gt;<br>&gt; Adjusting inout Declarations for Type Decoration<br>&gt;<br>&gt;    - Proposal: TBD<br>&gt;    - Author(s): Joe Groff &lt;https://github.com/jckarter&gt;, Erica Sadun<br>&gt;    &lt;http://github.com/erica&gt;<br>&gt;    - Status: TBD<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; The inout keyword indicates copy-in/copy-out argument behavior. In its<br>&gt; current implementation<br>&gt; the keyword prepands argument names. We propose to move the inout keyword<br>&gt; to the right<br>&gt; side of the colon to decorate the type instead of the parameter label.<br>&gt;<br>&gt; *The initial Swift-Evolution discussion of this topic took place in the<br>&gt; “Replace ‘inout’ with &amp;” thread.*<br>&gt; Motivation<br>&gt;<br>&gt; In Swift 2, the inout parameter lives on the label side rather than the<br>&gt; type side of the colon<br>&gt; although the keyword isn’t modifying the label but its type. Decorating<br>&gt; types instead of labels offers identifiable advantages:<br>&gt;<br>&gt;    - It enables the inout keyword to properly integrate into full type<br>&gt;    syntax, for example:<br>&gt;<br>&gt;    (x: inout T) -&gt; U // =&gt; (inout T) -&gt; U<br>&gt;<br>&gt;    - It avoids notational similarity with arguments labeled inout, for<br>&gt;    example:<br>&gt;<br>&gt;    func foo(inOut x: T) // foo(inOut:), type (T) -&gt; Void<br>&gt;    func foo(inout x: T) // foo(_:), type (inout T) -&gt; Void<br>&gt;<br>&gt;    - It better matches similar patterns in other languages such as<br>&gt;    borrowing in Rust, that may be later introduced back to Swift<br>&gt;<br>&gt; Detailed design<br>&gt;<br>&gt; parameter → external-parameter-name optlocal-parameter-name : type-annotationtype-annotation → inout type-annotation<br>&gt;<br>&gt; Alternatives Considered<br>&gt;<br>&gt; Decorations using @inout (either @inout(T) or @inout T) were considered<br>&gt; and discarded<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/39cb03a3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 29, 2016 at 02:00:00pm</p></header><div class="content"><p>I like this because it removes another C-like artifact that can be misunderstood (&quot;&amp; creates a pointer to this object&quot;) but I defer to Joe to make the call.<br></p><p>-- E<br></p><p>&gt; On Jan 29, 2016, at 12:47 PM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt; <br>&gt; +1<br>&gt; <br>&gt; I would also like to change the call site to use inout as well.<br>&gt; <br>&gt; foo(inout myVariable)<br>&gt; <br>&gt; On Fri, Jan 29, 2016 at 2:40 PM, Dave via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; +1<br>&gt;&gt; On Jan 29, 2016, at 11:37, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/pull/127 &lt;https://github.com/apple/swift-evolution/pull/127&gt;<br>&gt;&gt; <br>&gt;&gt; Adjusting inout Declarations for Type Decoration<br>&gt;&gt; <br>&gt;&gt; Proposal: TBD<br>&gt;&gt; Author(s): Joe Groff &lt;https://github.com/jckarter&gt;, Erica Sadun &lt;http://github.com/erica&gt;<br>&gt;&gt; Status: TBD<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; The inout keyword indicates copy-in/copy-out argument behavior. In its current implementation<br>&gt;&gt; the keyword prepands argument names. We propose to move the inout keyword to the right<br>&gt;&gt; side of the colon to decorate the type instead of the parameter label. <br>&gt;&gt; <br>&gt;&gt; The initial Swift-Evolution discussion of this topic took place in the “Replace ‘inout’ with &amp;” thread.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; In Swift 2, the inout parameter lives on the label side rather than the type side of the colon<br>&gt;&gt; although the keyword isn’t modifying the label but its type. Decorating<br>&gt;&gt; types instead of labels offers identifiable advantages: <br>&gt;&gt; <br>&gt;&gt; It enables the inout keyword to properly integrate into full type syntax, for example: <br>&gt;&gt; (x: inout T) -&gt; U // =&gt; (inout T) -&gt; U<br>&gt;&gt; It avoids notational similarity with arguments labeled inout, for example:<br>&gt;&gt; func foo(inOut x: T) // foo(inOut:), type (T) -&gt; Void<br>&gt;&gt; func foo(inout x: T) // foo(_:), type (inout T) -&gt; Void<br>&gt;&gt; It better matches similar patterns in other languages such as borrowing in Rust, that may be later introduced back to Swift <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; parameter → external-parameter-name optlocal-parameter-name : type-annotation<br>&gt;&gt; type-annotation → inout type-annotation<br>&gt;&gt; Alternatives Considered<br>&gt;&gt; <br>&gt;&gt; Decorations using @inout (either @inout(T) or @inout T) were considered and discarded<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/2df23383/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 29, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 29, 2016, at 1:45 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; I like this because it removes another C-like artifact that can be misunderstood (&quot;&amp; creates a pointer to this object&quot;) but I defer to Joe to make the call.<br></p><p>Seems reasonable to me, worth its own discussion thread.<br></p><p>-Joe<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 29, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 29, 2016, at 1:45 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I like this because it removes another C-like artifact that can be misunderstood (&quot;&amp; creates a pointer to this object&quot;) but I defer to Joe to make the call.<br></p><p>Independent of whether this is a good idea or not, I’d strongly suggest making it be a different proposal.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>January 29, 2016 at 04:00:00pm</p></header><div class="content"><p>Makes sense. I can write that up and start a new thread.<br></p><p>On Fri, Jan 29, 2016 at 4:47 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jan 29, 2016, at 1:45 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I like this because it removes another C-like artifact that can be<br>&gt; misunderstood (&quot;&amp; creates a pointer to this object&quot;) but I defer to Joe to<br>&gt; make the call.<br>&gt;<br>&gt; Independent of whether this is a good idea or not, I’d strongly suggest<br>&gt; making it be a different proposal.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/f2b80834/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>January 29, 2016 at 07:00:00pm</p></header><div class="content"><p>Surely inout isn’t a modifier of the type either, but rather a modifier of the parameter as a whole, not the label specifically. Couldn’t we just allow the label to be omitted for closures such as in your (inout T) -&gt; U example?<br></p><p>I don’t suppose it really matters if we’re considering getting rid of var on parameters (so they’re all immutable by default if not inout), so it could go anywhere, I just think that it’s a bit strange to associate with the type specifically when it’s not really specific to that either IMO.<br></p><p>&gt; On 29 Jan 2016, at 19:40, Dave via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1<br>&gt;&gt; On Jan 29, 2016, at 11:37, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/pull/127 &lt;https://github.com/apple/swift-evolution/pull/127&gt;<br>&gt;&gt; <br>&gt;&gt; Adjusting inout Declarations for Type Decoration<br>&gt;&gt; <br>&gt;&gt; Proposal: TBD<br>&gt;&gt; Author(s): Joe Groff &lt;https://github.com/jckarter&gt;, Erica Sadun &lt;http://github.com/erica&gt;<br>&gt;&gt; Status: TBD<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; The inout keyword indicates copy-in/copy-out argument behavior. In its current implementation<br>&gt;&gt; the keyword prepands argument names. We propose to move the inout keyword to the right<br>&gt;&gt; side of the colon to decorate the type instead of the parameter label. <br>&gt;&gt; <br>&gt;&gt; The initial Swift-Evolution discussion of this topic took place in the “Replace ‘inout’ with &amp;” thread.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; In Swift 2, the inout parameter lives on the label side rather than the type side of the colon<br>&gt;&gt; although the keyword isn’t modifying the label but its type. Decorating<br>&gt;&gt; types instead of labels offers identifiable advantages: <br>&gt;&gt; <br>&gt;&gt; It enables the inout keyword to properly integrate into full type syntax, for example: <br>&gt;&gt; (x: inout T) -&gt; U // =&gt; (inout T) -&gt; U<br>&gt;&gt; It avoids notational similarity with arguments labeled inout, for example:<br>&gt;&gt; func foo(inOut x: T) // foo(inOut:), type (T) -&gt; Void<br>&gt;&gt; func foo(inout x: T) // foo(_:), type (inout T) -&gt; Void<br>&gt;&gt; It better matches similar patterns in other languages such as borrowing in Rust, that may be later introduced back to Swift <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; parameter → external-parameter-name optlocal-parameter-name : type-annotation<br>&gt;&gt; type-annotation → inout type-annotation<br>&gt;&gt; Alternatives Considered<br>&gt;&gt; <br>&gt;&gt; Decorations using @inout (either @inout(T) or @inout T) were considered and discarded<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/691ec448/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5818a8a9211c31af95d6db8974457683?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Joseph Lord</string> &lt;Joseph at human-friendly.com&gt;<p>January 29, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 29 Jan 2016, at 20:55, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Surely inout isn’t a modifier of the type either, but rather a modifier of the parameter as a whole, not the label specifically. Couldn’t we just allow the label to be omitted for closures such as in your (inout T) -&gt; U example?<br></p><p>It works for me because I think of the mutability of a variable being part of the type of the variable<br></p><p>I do like the proposal although I haven&#39;t had cause to make use of inout arguments much recently.<br></p><p>Joseph<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/d6b65c14/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 29, 2016 at 02:00:00pm</p></header><div class="content"><p>+1.  The original thread also discussed using `inout` rather than `&amp;` at the call site.  Are you thinking of following this up with a proposal to change that so usage matches declaration better?<br></p><p>&gt; On Jan 29, 2016, at 1:37 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/pull/127 &lt;https://github.com/apple/swift-evolution/pull/127&gt;<br>&gt; <br>&gt; Adjusting inout Declarations for Type Decoration<br>&gt; <br>&gt; Proposal: TBD<br>&gt; Author(s): Joe Groff &lt;https://github.com/jckarter&gt;, Erica Sadun &lt;http://github.com/erica&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; The inout keyword indicates copy-in/copy-out argument behavior. In its current implementation<br>&gt; the keyword prepands argument names. We propose to move the inout keyword to the right<br>&gt; side of the colon to decorate the type instead of the parameter label. <br>&gt; <br>&gt; The initial Swift-Evolution discussion of this topic took place in the “Replace ‘inout’ with &amp;” thread.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; In Swift 2, the inout parameter lives on the label side rather than the type side of the colon<br>&gt; although the keyword isn’t modifying the label but its type. Decorating<br>&gt; types instead of labels offers identifiable advantages: <br>&gt; <br>&gt; It enables the inout keyword to properly integrate into full type syntax, for example: <br>&gt; (x: inout T) -&gt; U // =&gt; (inout T) -&gt; U<br>&gt; It avoids notational similarity with arguments labeled inout, for example:<br>&gt; func foo(inOut x: T) // foo(inOut:), type (T) -&gt; Void<br>&gt; func foo(inout x: T) // foo(_:), type (inout T) -&gt; Void<br>&gt; It better matches similar patterns in other languages such as borrowing in Rust, that may be later introduced back to Swift <br>&gt; Detailed design<br>&gt; <br>&gt; parameter → external-parameter-name optlocal-parameter-name : type-annotation<br>&gt; type-annotation → inout type-annotation<br>&gt; Alternatives Considered<br>&gt; <br>&gt; Decorations using @inout (either @inout(T) or @inout T) were considered and discarded<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/0b0c0b8b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 29, 2016 at 01:00:00pm</p></header><div class="content"><p>This makes sense to me, but why shouldn&#39;t it also apply to things like<br>@noescape? I can understand that @autoclosure is really more an annotation<br>of the function signature than it is of the type, but it seems like the<br>same arguments for inout could be used for @noescape.<br></p><p>Jacob<br></p><p>On Fri, Jan 29, 2016 at 11:37 AM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; https://github.com/apple/swift-evolution/pull/127<br>&gt;<br>&gt; Adjusting inout Declarations for Type Decoration<br>&gt;<br>&gt;    - Proposal: TBD<br>&gt;    - Author(s): Joe Groff &lt;https://github.com/jckarter&gt;, Erica Sadun<br>&gt;    &lt;http://github.com/erica&gt;<br>&gt;    - Status: TBD<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; The inout keyword indicates copy-in/copy-out argument behavior. In its<br>&gt; current implementation<br>&gt; the keyword prepands argument names. We propose to move the inout keyword<br>&gt; to the right<br>&gt; side of the colon to decorate the type instead of the parameter label.<br>&gt;<br>&gt; *The initial Swift-Evolution discussion of this topic took place in the<br>&gt; “Replace ‘inout’ with &amp;” thread.*<br>&gt; Motivation<br>&gt;<br>&gt; In Swift 2, the inout parameter lives on the label side rather than the<br>&gt; type side of the colon<br>&gt; although the keyword isn’t modifying the label but its type. Decorating<br>&gt; types instead of labels offers identifiable advantages:<br>&gt;<br>&gt;    - It enables the inout keyword to properly integrate into full type<br>&gt;    syntax, for example:<br>&gt;<br>&gt;    (x: inout T) -&gt; U // =&gt; (inout T) -&gt; U<br>&gt;<br>&gt;    - It avoids notational similarity with arguments labeled inout, for<br>&gt;    example:<br>&gt;<br>&gt;    func foo(inOut x: T) // foo(inOut:), type (T) -&gt; Void<br>&gt;    func foo(inout x: T) // foo(_:), type (inout T) -&gt; Void<br>&gt;<br>&gt;    - It better matches similar patterns in other languages such as<br>&gt;    borrowing in Rust, that may be later introduced back to Swift<br>&gt;<br>&gt; Detailed design<br>&gt;<br>&gt; parameter → external-parameter-name optlocal-parameter-name : type-annotationtype-annotation → inout type-annotation<br>&gt;<br>&gt; Alternatives Considered<br>&gt;<br>&gt; Decorations using @inout (either @inout(T) or @inout T) were considered<br>&gt; and discarded<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/419e7522/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>January 29, 2016 at 02:00:00pm</p></header><div class="content"><p>The one downside I see to this is that it puts the ‘inout’ in a less prominent position. It looks fine after an argument name like ‘x’, but if the argument is named ‘textRepresentation’ or something longer like that, the ‘inout’ isn’t quite as noticeable as it is now, particularly if it’s in a long parameter list. In cases where the the inout parameter is the first one in the function call, the current position for ‘inout’ allows it to stand out nicely at the head of the line.<br></p><p>So a +/-1 for me.<br></p><p>The related idea of replacing ‘&amp;’ with ‘inout’ at the call site seems completely contradictory to this proposal. Developers would then have to remember that the ‘inout’ goes before the argument at the call site but after it in the function definition. That seems like a constant source of mis-typings and something that would be viewed as an inconsistency in the language. Or do people want to put it after the argument name at the call site too? It seems a little like change just for the sake of change, IMO.<br></p><p>—CK<br></p><p>&gt; On Jan 29, 2016, at 11:37 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/pull/127 &lt;https://github.com/apple/swift-evolution/pull/127&gt;<br>&gt; <br>&gt; Adjusting inout Declarations for Type Decoration<br>&gt; <br>&gt; Proposal: TBD<br>&gt; Author(s): Joe Groff &lt;https://github.com/jckarter&gt;, Erica Sadun &lt;http://github.com/erica&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; The inout keyword indicates copy-in/copy-out argument behavior. In its current implementation<br>&gt; the keyword prepands argument names. We propose to move the inout keyword to the right<br>&gt; side of the colon to decorate the type instead of the parameter label. <br>&gt; <br>&gt; The initial Swift-Evolution discussion of this topic took place in the “Replace ‘inout’ with &amp;” thread.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; In Swift 2, the inout parameter lives on the label side rather than the type side of the colon<br>&gt; although the keyword isn’t modifying the label but its type. Decorating<br>&gt; types instead of labels offers identifiable advantages: <br>&gt; <br>&gt; It enables the inout keyword to properly integrate into full type syntax, for example: <br>&gt; (x: inout T) -&gt; U // =&gt; (inout T) -&gt; U<br>&gt; It avoids notational similarity with arguments labeled inout, for example:<br>&gt; func foo(inOut x: T) // foo(inOut:), type (T) -&gt; Void<br>&gt; func foo(inout x: T) // foo(_:), type (inout T) -&gt; Void<br>&gt; It better matches similar patterns in other languages such as borrowing in Rust, that may be later introduced back to Swift <br>&gt; Detailed design<br>&gt; <br>&gt; parameter → external-parameter-name optlocal-parameter-name : type-annotation<br>&gt; type-annotation → inout type-annotation<br>&gt; Alternatives Considered<br>&gt; <br>&gt; Decorations using @inout (either @inout(T) or @inout T) were considered and discarded<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/1d0f76d3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 29, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 29, 2016, at 3:04 PM, Charles Kissinger &lt;crk at akkyra.com&gt; wrote:<br>&gt; The related idea of replacing ‘&amp;’ with ‘inout’ at the call site seems completely contradictory to this proposal. Developers would then have to remember that the ‘inout’ goes before the argument at the call site but after it in the function definition. That seems like a constant source of mis-typings and something that would be viewed as an inconsistency in the language. Or do people want to put it after the argument name at the call site too? It seems a little like change just for the sake of change, IMO.<br></p><p>If you have a function<br></p><p>f(x: Int) {}<br></p><p>you call it with f(8), and potentially f(x: 8). Even when labeled, the 8 value is to the right of the colon.<br></p><p>Now consider<br></p><p>f(x: inout Int) {}<br></p><p>you call it with f(&amp;y) or f(inout y), and with a label, you&#39;d call it f(x: &amp;y) or f(x: inout y).<br></p><p>It seems  consistent to me.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/6cffa34b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>January 29, 2016 at 03:00:00pm</p></header><div class="content"><p>Sorry, I wasn’t clear at all there. I was thinking of the most common case where there is either only one parameter or the inout parameter is the first one. Then there will typically be no argument label involved at the call site. In that case ‘inout’ will be the first word inside the parens at the call site (assuming it replaces ‘&amp;’). If it also is kept in its current position in function declarations, it will be in that same leading position in declarations and (I’m assuming) people will have an easy time remembering where to put it.<br></p><p>When there is a label involved, it is a different story. I was implicitly, and probably wrongly, assuming that would be a much less common case in practice. A poorly worded, and probably poorly reasoned, argument on my part, though I still don’t see any great advantage to replacing ‘&amp;&#39;.<br></p><p>—CK<br></p><p>&gt; On Jan 29, 2016, at 2:13 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 29, 2016, at 3:04 PM, Charles Kissinger &lt;crk at akkyra.com &lt;mailto:crk at akkyra.com&gt;&gt; wrote:<br>&gt;&gt; The related idea of replacing ‘&amp;’ with ‘inout’ at the call site seems completely contradictory to this proposal. Developers would then have to remember that the ‘inout’ goes before the argument at the call site but after it in the function definition. That seems like a constant source of mis-typings and something that would be viewed as an inconsistency in the language. Or do people want to put it after the argument name at the call site too? It seems a little like change just for the sake of change, IMO.<br>&gt; <br>&gt; If you have a function<br>&gt; <br>&gt; f(x: Int) {}<br>&gt; <br>&gt; you call it with f(8), and potentially f(x: 8). Even when labeled, the 8 value is to the right of the colon.<br>&gt; <br>&gt; Now consider<br>&gt; <br>&gt; f(x: inout Int) {}<br>&gt; <br>&gt; you call it with f(&amp;y) or f(inout y), and with a label, you&#39;d call it f(x: &amp;y) or f(x: inout y).<br>&gt; <br>&gt; It seems  consistent to me.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/9037ad02/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 29, 2016 at 04:00:00pm</p></header><div class="content"><p>The great advantages are:<br></p><p>1. It removes a potentially confusing overlap with C-style expectations. People see &amp; and think &quot;POINTERS!&quot;, which is not how things work in Swift with copy-back.<br>(2. It eventually frees up &amp;, so we can have more Rust)<br></p><p>-- E<br></p><p>&gt; On Jan 29, 2016, at 4:42 PM, Charles Kissinger &lt;crk at akkyra.com&gt; wrote:<br>&gt; <br>&gt; Sorry, I wasn’t clear at all there. I was thinking of the most common case where there is either only one parameter or the inout parameter is the first one. Then there will typically be no argument label involved at the call site. In that case ‘inout’ will be the first word inside the parens at the call site (assuming it replaces ‘&amp;’). If it also is kept in its current position in function declarations, it will be in that same leading position in declarations and (I’m assuming) people will have an easy time remembering where to put it.<br>&gt; <br>&gt; When there is a label involved, it is a different story. I was implicitly, and probably wrongly, assuming that would be a much less common case in practice. A poorly worded, and probably poorly reasoned, argument on my part, though I still don’t see any great advantage to replacing ‘&amp;&#39;.<br>&gt; <br>&gt; —CK<br>&gt; <br>&gt;&gt; On Jan 29, 2016, at 2:13 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 29, 2016, at 3:04 PM, Charles Kissinger &lt;crk at akkyra.com &lt;mailto:crk at akkyra.com&gt;&gt; wrote:<br>&gt;&gt;&gt; The related idea of replacing ‘&amp;’ with ‘inout’ at the call site seems completely contradictory to this proposal. Developers would then have to remember that the ‘inout’ goes before the argument at the call site but after it in the function definition. That seems like a constant source of mis-typings and something that would be viewed as an inconsistency in the language. Or do people want to put it after the argument name at the call site too? It seems a little like change just for the sake of change, IMO.<br>&gt;&gt; <br>&gt;&gt; If you have a function<br>&gt;&gt; <br>&gt;&gt; f(x: Int) {}<br>&gt;&gt; <br>&gt;&gt; you call it with f(8), and potentially f(x: 8). Even when labeled, the 8 value is to the right of the colon.<br>&gt;&gt; <br>&gt;&gt; Now consider<br>&gt;&gt; <br>&gt;&gt; f(x: inout Int) {}<br>&gt;&gt; <br>&gt;&gt; you call it with f(&amp;y) or f(inout y), and with a label, you&#39;d call it f(x: &amp;y) or f(x: inout y).<br>&gt;&gt; <br>&gt;&gt; It seems  consistent to me.<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/aaf266fa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5059668772aad67a346ad23a786be31b?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Allen Ding</string> &lt;allen at snappymob.com&gt;<p>January 30, 2016 at 08:00:00am</p></header><div class="content"><p>1. Is there some data or real world story to support (1)? I&#39;ve never had<br>the same expectations even when first encountering Swift and definitely<br>less so after reading the documentation, because the concept and syntax for<br>inout and &amp; is not really profound. And even if I did *pointers!*, I would<br>figure things out rather quickly because nothing else would work.<br></p><p>(2. I don&#39;t have experience with Rust, so there would need to be some<br>details on why being more Rust like is a good thing :)<br></p><p>On Sat, Jan 30, 2016 at 7:50 AM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The great advantages are:<br>&gt;<br>&gt; 1. It removes a potentially confusing overlap with C-style expectations.<br>&gt; People see &amp; and think &quot;POINTERS!&quot;, which is not how things work in Swift<br>&gt; with copy-back.<br>&gt; (2. It eventually frees up &amp;, so we can have more Rust)<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; On Jan 29, 2016, at 4:42 PM, Charles Kissinger &lt;crk at akkyra.com&gt; wrote:<br>&gt;<br>&gt; Sorry, I wasn’t clear at all there. I was thinking of the most common case<br>&gt; where there is either only one parameter or the inout parameter is the<br>&gt; first one. Then there will typically be no argument label involved at the<br>&gt; call site. In that case ‘inout’ will be the first word inside the parens at<br>&gt; the call site (assuming it replaces ‘&amp;’). If it also is kept in its current<br>&gt; position in function declarations, it will be in that same leading position<br>&gt; in declarations and (I’m assuming) people will have an easy time<br>&gt; remembering where to put it.<br>&gt;<br>&gt; When there is a label involved, it is a different story. I was implicitly,<br>&gt; and probably wrongly, assuming that would be a much less common case in<br>&gt; practice. A poorly worded, and probably poorly reasoned, argument on my<br>&gt; part, though I still don’t see any great advantage to replacing ‘&amp;&#39;.<br>&gt;<br>&gt; —CK<br>&gt;<br>&gt; On Jan 29, 2016, at 2:13 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jan 29, 2016, at 3:04 PM, Charles Kissinger &lt;crk at akkyra.com&gt; wrote:<br>&gt; The related idea of replacing ‘&amp;’ with ‘inout’ at the call site seems<br>&gt; completely contradictory to this proposal. Developers would then have to<br>&gt; remember that the ‘inout’ goes before the argument at the call site but<br>&gt; after it in the function definition. That seems like a constant source of<br>&gt; mis-typings and something that would be viewed as an inconsistency in the<br>&gt; language. Or do people want to put it after the argument name at the call<br>&gt; site too? It seems a little like change just for the sake of change, IMO.<br>&gt;<br>&gt;<br>&gt; If you have a function<br>&gt;<br>&gt; f(x: Int) {}<br>&gt;<br>&gt; you call it with f(8), and potentially f(x: 8). Even when labeled, the 8<br>&gt; value is to the right of the colon.<br>&gt;<br>&gt; Now consider<br>&gt;<br>&gt; f(x: inout Int) {}<br>&gt;<br>&gt; you call it with f(&amp;y) or f(inout y), and with a label, you&#39;d call it f(x:<br>&gt; &amp;y) or f(x: inout y).<br>&gt;<br>&gt; It seems  consistent to me.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/5bac1232/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 29, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 29, 2016, at 5:14 PM, Allen Ding &lt;allen at snappymob.com&gt; wrote:<br>&gt; <br>&gt; 1. Is there some data or real world story to support (1)? I&#39;ve never had the same expectations even when first encountering Swift and definitely less so after reading the documentation, because the concept and syntax for inout and &amp; is not really profound. And even if I did *pointers!*, I would figure things out rather quickly because nothing else would work.<br></p><p>Going from personal experience?<br></p><p>http://ericasadun.com/2015/04/10/swift-var-parameters/ &lt;http://ericasadun.com/2015/04/10/swift-var-parameters/&gt;<br></p><p>-- E, &quot;professionally dense&quot;<br></p><p>&gt; <br>&gt; (2. I don&#39;t have experience with Rust, so there would need to be some details on why being more Rust like is a good thing :)<br>&gt; <br>&gt; On Sat, Jan 30, 2016 at 7:50 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; The great advantages are:<br>&gt; <br>&gt; 1. It removes a potentially confusing overlap with C-style expectations. People see &amp; and think &quot;POINTERS!&quot;, which is not how things work in Swift with copy-back.<br>&gt; (2. It eventually frees up &amp;, so we can have more Rust)<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt;&gt; On Jan 29, 2016, at 4:42 PM, Charles Kissinger &lt;crk at akkyra.com &lt;mailto:crk at akkyra.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sorry, I wasn’t clear at all there. I was thinking of the most common case where there is either only one parameter or the inout parameter is the first one. Then there will typically be no argument label involved at the call site. In that case ‘inout’ will be the first word inside the parens at the call site (assuming it replaces ‘&amp;’). If it also is kept in its current position in function declarations, it will be in that same leading position in declarations and (I’m assuming) people will have an easy time remembering where to put it.<br>&gt;&gt; <br>&gt;&gt; When there is a label involved, it is a different story. I was implicitly, and probably wrongly, assuming that would be a much less common case in practice. A poorly worded, and probably poorly reasoned, argument on my part, though I still don’t see any great advantage to replacing ‘&amp;&#39;.<br>&gt;&gt; <br>&gt;&gt; —CK<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 29, 2016, at 2:13 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 29, 2016, at 3:04 PM, Charles Kissinger &lt;crk at akkyra.com &lt;mailto:crk at akkyra.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; The related idea of replacing ‘&amp;’ with ‘inout’ at the call site seems completely contradictory to this proposal. Developers would then have to remember that the ‘inout’ goes before the argument at the call site but after it in the function definition. That seems like a constant source of mis-typings and something that would be viewed as an inconsistency in the language. Or do people want to put it after the argument name at the call site too? It seems a little like change just for the sake of change, IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you have a function<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; f(x: Int) {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; you call it with f(8), and potentially f(x: 8). Even when labeled, the 8 value is to the right of the colon.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now consider<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; f(x: inout Int) {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; you call it with f(&amp;y) or f(inout y), and with a label, you&#39;d call it f(x: &amp;y) or f(x: inout y).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems  consistent to me.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/599b36fa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5059668772aad67a346ad23a786be31b?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Allen Ding</string> &lt;allen at snappymob.com&gt;<p>January 30, 2016 at 08:00:00am</p></header><div class="content"><p>Thanks Erica. I just read the post and I still can&#39;t help wonder if things<br>are that bad?<br></p><p>The post doesn&#39;t mention much about C-pointers other than calling<br>inOutParameter parameter a pointer (it isn&#39;t) that doesn&#39;t need to be<br>dereferenced. It does seem like the compiler helps catch any usage errors<br>as intended. But I don&#39;t see how something detrimental, whether in terms of<br>grokking Swift or an unintended usage consequence arises in this scenario.<br></p><p>- Allen Ding<br></p><p><br>On Sat, Jan 30, 2016 at 8:25 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 29, 2016, at 5:14 PM, Allen Ding &lt;allen at snappymob.com&gt; wrote:<br>&gt;<br>&gt; 1. Is there some data or real world story to support (1)? I&#39;ve never had<br>&gt; the same expectations even when first encountering Swift and definitely<br>&gt; less so after reading the documentation, because the concept and syntax for<br>&gt; inout and &amp; is not really profound. And even if I did *pointers!*, I would<br>&gt; figure things out rather quickly because nothing else would work.<br>&gt;<br>&gt;<br>&gt; Going from personal experience?<br>&gt;<br>&gt; http://ericasadun.com/2015/04/10/swift-var-parameters/<br>&gt;<br>&gt; -- E, &quot;professionally dense&quot;<br>&gt;<br>&gt;<br>&gt; (2. I don&#39;t have experience with Rust, so there would need to be some<br>&gt; details on why being more Rust like is a good thing :)<br>&gt;<br>&gt; On Sat, Jan 30, 2016 at 7:50 AM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; The great advantages are:<br>&gt;&gt;<br>&gt;&gt; 1. It removes a potentially confusing overlap with C-style expectations.<br>&gt;&gt; People see &amp; and think &quot;POINTERS!&quot;, which is not how things work in Swift<br>&gt;&gt; with copy-back.<br>&gt;&gt; (2. It eventually frees up &amp;, so we can have more Rust)<br>&gt;&gt;<br>&gt;&gt; -- E<br>&gt;&gt;<br>&gt;&gt; On Jan 29, 2016, at 4:42 PM, Charles Kissinger &lt;crk at akkyra.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Sorry, I wasn’t clear at all there. I was thinking of the most common<br>&gt;&gt; case where there is either only one parameter or the inout parameter is the<br>&gt;&gt; first one. Then there will typically be no argument label involved at the<br>&gt;&gt; call site. In that case ‘inout’ will be the first word inside the parens at<br>&gt;&gt; the call site (assuming it replaces ‘&amp;’). If it also is kept in its current<br>&gt;&gt; position in function declarations, it will be in that same leading position<br>&gt;&gt; in declarations and (I’m assuming) people will have an easy time<br>&gt;&gt; remembering where to put it.<br>&gt;&gt;<br>&gt;&gt; When there is a label involved, it is a different story. I was<br>&gt;&gt; implicitly, and probably wrongly, assuming that would be a much less common<br>&gt;&gt; case in practice. A poorly worded, and probably poorly reasoned, argument<br>&gt;&gt; on my part, though I still don’t see any great advantage to replacing ‘&amp;&#39;.<br>&gt;&gt;<br>&gt;&gt; —CK<br>&gt;&gt;<br>&gt;&gt; On Jan 29, 2016, at 2:13 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 29, 2016, at 3:04 PM, Charles Kissinger &lt;crk at akkyra.com&gt; wrote:<br>&gt;&gt; The related idea of replacing ‘&amp;’ with ‘inout’ at the call site seems<br>&gt;&gt; completely contradictory to this proposal. Developers would then have to<br>&gt;&gt; remember that the ‘inout’ goes before the argument at the call site but<br>&gt;&gt; after it in the function definition. That seems like a constant source of<br>&gt;&gt; mis-typings and something that would be viewed as an inconsistency in the<br>&gt;&gt; language. Or do people want to put it after the argument name at the call<br>&gt;&gt; site too? It seems a little like change just for the sake of change, IMO.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If you have a function<br>&gt;&gt;<br>&gt;&gt; f(x: Int) {}<br>&gt;&gt;<br>&gt;&gt; you call it with f(8), and potentially f(x: 8). Even when labeled, the 8<br>&gt;&gt; value is to the right of the colon.<br>&gt;&gt;<br>&gt;&gt; Now consider<br>&gt;&gt;<br>&gt;&gt; f(x: inout Int) {}<br>&gt;&gt;<br>&gt;&gt; you call it with f(&amp;y) or f(inout y), and with a label, you&#39;d call it<br>&gt;&gt; f(x: &amp;y) or f(x: inout y).<br>&gt;&gt;<br>&gt;&gt; It seems  consistent to me.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/9febbea2/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>January 29, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 29, 2016, at 3:50 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; The great advantages are:<br>&gt; <br>&gt; 1. It removes a potentially confusing overlap with C-style expectations. People see &amp; and think &quot;POINTERS!&quot;, which is not how things work in Swift with copy-back.<br></p><p>Yes, I’ve seen the argument. I just don’t have any idea if that leads to any bad developer decisions.<br></p><p>&gt; (2. It eventually frees up &amp;, so we can have more Rust)<br>&gt; <br></p><p>I’m just going to go ahead and assume that’s a good thing.<br></p><p>—CK<br></p><p>&gt; -- E<br>&gt; <br>&gt;&gt; On Jan 29, 2016, at 4:42 PM, Charles Kissinger &lt;crk at akkyra.com &lt;mailto:crk at akkyra.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sorry, I wasn’t clear at all there. I was thinking of the most common case where there is either only one parameter or the inout parameter is the first one. Then there will typically be no argument label involved at the call site. In that case ‘inout’ will be the first word inside the parens at the call site (assuming it replaces ‘&amp;’). If it also is kept in its current position in function declarations, it will be in that same leading position in declarations and (I’m assuming) people will have an easy time remembering where to put it.<br>&gt;&gt; <br>&gt;&gt; When there is a label involved, it is a different story. I was implicitly, and probably wrongly, assuming that would be a much less common case in practice. A poorly worded, and probably poorly reasoned, argument on my part, though I still don’t see any great advantage to replacing ‘&amp;&#39;.<br>&gt;&gt; <br>&gt;&gt; —CK<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 29, 2016, at 2:13 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 29, 2016, at 3:04 PM, Charles Kissinger &lt;crk at akkyra.com &lt;mailto:crk at akkyra.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; The related idea of replacing ‘&amp;’ with ‘inout’ at the call site seems completely contradictory to this proposal. Developers would then have to remember that the ‘inout’ goes before the argument at the call site but after it in the function definition. That seems like a constant source of mis-typings and something that would be viewed as an inconsistency in the language. Or do people want to put it after the argument name at the call site too? It seems a little like change just for the sake of change, IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you have a function<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; f(x: Int) {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; you call it with f(8), and potentially f(x: 8). Even when labeled, the 8 value is to the right of the colon.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now consider<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; f(x: inout Int) {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; you call it with f(&amp;y) or f(inout y), and with a label, you&#39;d call it f(x: &amp;y) or f(x: inout y).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems  consistent to me.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/07fdc47d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January 29, 2016 at 04:00:00pm</p></header><div class="content"><p>As far as I understand it, the Rust Dream™ is one day being able to pass<br>around classes and certain other types without the overhead of ARC, thanks<br>to compile-time borrow checking. This would be handy for<br>resource-constrained platforms and performance critical use cases.<br></p><p>In order to support this sort of feature we&#39;d probably need to be able to<br>annotate parameters to functions (like &#39;inout&#39;) to indicate e.g. whether<br>&#39;ownership&#39; of a variable opting into this system is being transferred or<br>not. Rust&#39;s system is described here:<br>https://doc.rust-lang.org/book/ownership.html<br></p><p>Best,<br>Austin<br></p><p><br>On Fri, Jan 29, 2016 at 4:22 PM, Charles Kissinger via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 29, 2016, at 3:50 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;<br>&gt; The great advantages are:<br>&gt;<br>&gt; 1. It removes a potentially confusing overlap with C-style expectations.<br>&gt; People see &amp; and think &quot;POINTERS!&quot;, which is not how things work in Swift<br>&gt; with copy-back.<br>&gt;<br>&gt;<br>&gt; Yes, I’ve seen the argument. I just don’t have any idea if that leads to<br>&gt; any bad developer decisions.<br>&gt;<br>&gt; (2. It eventually frees up &amp;, so we can have more Rust)<br>&gt;<br>&gt;<br>&gt; I’m just going to go ahead and assume that’s a good thing.<br>&gt;<br>&gt; —CK<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; On Jan 29, 2016, at 4:42 PM, Charles Kissinger &lt;crk at akkyra.com&gt; wrote:<br>&gt;<br>&gt; Sorry, I wasn’t clear at all there. I was thinking of the most common case<br>&gt; where there is either only one parameter or the inout parameter is the<br>&gt; first one. Then there will typically be no argument label involved at the<br>&gt; call site. In that case ‘inout’ will be the first word inside the parens at<br>&gt; the call site (assuming it replaces ‘&amp;’). If it also is kept in its current<br>&gt; position in function declarations, it will be in that same leading position<br>&gt; in declarations and (I’m assuming) people will have an easy time<br>&gt; remembering where to put it.<br>&gt;<br>&gt; When there is a label involved, it is a different story. I was implicitly,<br>&gt; and probably wrongly, assuming that would be a much less common case in<br>&gt; practice. A poorly worded, and probably poorly reasoned, argument on my<br>&gt; part, though I still don’t see any great advantage to replacing ‘&amp;&#39;.<br>&gt;<br>&gt; —CK<br>&gt;<br>&gt; On Jan 29, 2016, at 2:13 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jan 29, 2016, at 3:04 PM, Charles Kissinger &lt;crk at akkyra.com&gt; wrote:<br>&gt; The related idea of replacing ‘&amp;’ with ‘inout’ at the call site seems<br>&gt; completely contradictory to this proposal. Developers would then have to<br>&gt; remember that the ‘inout’ goes before the argument at the call site but<br>&gt; after it in the function definition. That seems like a constant source of<br>&gt; mis-typings and something that would be viewed as an inconsistency in the<br>&gt; language. Or do people want to put it after the argument name at the call<br>&gt; site too? It seems a little like change just for the sake of change, IMO.<br>&gt;<br>&gt;<br>&gt; If you have a function<br>&gt;<br>&gt; f(x: Int) {}<br>&gt;<br>&gt; you call it with f(8), and potentially f(x: 8). Even when labeled, the 8<br>&gt; value is to the right of the colon.<br>&gt;<br>&gt; Now consider<br>&gt;<br>&gt; f(x: inout Int) {}<br>&gt;<br>&gt; you call it with f(&amp;y) or f(inout y), and with a label, you&#39;d call it f(x:<br>&gt; &amp;y) or f(x: inout y).<br>&gt;<br>&gt; It seems  consistent to me.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/c60b638c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>January 30, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 29, 2016, at 4:30 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; As far as I understand it, the Rust Dream™ is one day being able to pass around classes and certain other types without the overhead of ARC, thanks to compile-time borrow checking. This would be handy for resource-constrained platforms and performance critical use cases.<br></p><p>I see. This would, I assume, provide the ‘correct’ approach in situations where I’m using inout now.<br></p><p>I hope Swift gets this.<br></p><p>—CK<br></p><p>&gt; <br>&gt; In order to support this sort of feature we&#39;d probably need to be able to annotate parameters to functions (like &#39;inout&#39;) to indicate e.g. whether &#39;ownership&#39; of a variable opting into this system is being transferred or not. Rust&#39;s system is described here: https://doc.rust-lang.org/book/ownership.html &lt;https://doc.rust-lang.org/book/ownership.html&gt;<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; <br>&gt; On Fri, Jan 29, 2016 at 4:22 PM, Charles Kissinger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 29, 2016, at 3:50 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The great advantages are:<br>&gt;&gt; <br>&gt;&gt; 1. It removes a potentially confusing overlap with C-style expectations. People see &amp; and think &quot;POINTERS!&quot;, which is not how things work in Swift with copy-back.<br>&gt; <br>&gt; Yes, I’ve seen the argument. I just don’t have any idea if that leads to any bad developer decisions.<br>&gt; <br>&gt;&gt; (2. It eventually frees up &amp;, so we can have more Rust)<br>&gt;&gt; <br>&gt; <br>&gt; I’m just going to go ahead and assume that’s a good thing.<br>&gt; <br>&gt; —CK<br>&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 29, 2016, at 4:42 PM, Charles Kissinger &lt;crk at akkyra.com &lt;mailto:crk at akkyra.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, I wasn’t clear at all there. I was thinking of the most common case where there is either only one parameter or the inout parameter is the first one. Then there will typically be no argument label involved at the call site. In that case ‘inout’ will be the first word inside the parens at the call site (assuming it replaces ‘&amp;’). If it also is kept in its current position in function declarations, it will be in that same leading position in declarations and (I’m assuming) people will have an easy time remembering where to put it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When there is a label involved, it is a different story. I was implicitly, and probably wrongly, assuming that would be a much less common case in practice. A poorly worded, and probably poorly reasoned, argument on my part, though I still don’t see any great advantage to replacing ‘&amp;&#39;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; —CK<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 29, 2016, at 2:13 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 29, 2016, at 3:04 PM, Charles Kissinger &lt;crk at akkyra.com &lt;mailto:crk at akkyra.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; The related idea of replacing ‘&amp;’ with ‘inout’ at the call site seems completely contradictory to this proposal. Developers would then have to remember that the ‘inout’ goes before the argument at the call site but after it in the function definition. That seems like a constant source of mis-typings and something that would be viewed as an inconsistency in the language. Or do people want to put it after the argument name at the call site too? It seems a little like change just for the sake of change, IMO.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you have a function<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; f(x: Int) {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; you call it with f(8), and potentially f(x: 8). Even when labeled, the 8 value is to the right of the colon.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now consider<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; f(x: inout Int) {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; you call it with f(&amp;y) or f(inout y), and with a label, you&#39;d call it f(x: &amp;y) or f(x: inout y).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems  consistent to me.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/79ed7687/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>January 29, 2016 at 06:00:00pm</p></header><div class="content"><p>Please see my proposal and the associated discussion thread at &quot;[Proposal]<br>Use inout at function call sites&quot;.<br></p><p>On Fri, Jan 29, 2016 at 6:42 PM, Charles Kissinger via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Sorry, I wasn’t clear at all there. I was thinking of the most common case<br>&gt; where there is either only one parameter or the inout parameter is the<br>&gt; first one. Then there will typically be no argument label involved at the<br>&gt; call site. In that case ‘inout’ will be the first word inside the parens at<br>&gt; the call site (assuming it replaces ‘&amp;’). If it also is kept in its current<br>&gt; position in function declarations, it will be in that same leading position<br>&gt; in declarations and (I’m assuming) people will have an easy time<br>&gt; remembering where to put it.<br>&gt;<br>&gt; When there is a label involved, it is a different story. I was implicitly,<br>&gt; and probably wrongly, assuming that would be a much less common case in<br>&gt; practice. A poorly worded, and probably poorly reasoned, argument on my<br>&gt; part, though I still don’t see any great advantage to replacing ‘&amp;&#39;.<br>&gt;<br>&gt; —CK<br>&gt;<br>&gt; On Jan 29, 2016, at 2:13 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jan 29, 2016, at 3:04 PM, Charles Kissinger &lt;crk at akkyra.com&gt; wrote:<br>&gt; The related idea of replacing ‘&amp;’ with ‘inout’ at the call site seems<br>&gt; completely contradictory to this proposal. Developers would then have to<br>&gt; remember that the ‘inout’ goes before the argument at the call site but<br>&gt; after it in the function definition. That seems like a constant source of<br>&gt; mis-typings and something that would be viewed as an inconsistency in the<br>&gt; language. Or do people want to put it after the argument name at the call<br>&gt; site too? It seems a little like change just for the sake of change, IMO.<br>&gt;<br>&gt;<br>&gt; If you have a function<br>&gt;<br>&gt; f(x: Int) {}<br>&gt;<br>&gt; you call it with f(8), and potentially f(x: 8). Even when labeled, the 8<br>&gt; value is to the right of the colon.<br>&gt;<br>&gt; Now consider<br>&gt;<br>&gt; f(x: inout Int) {}<br>&gt;<br>&gt; you call it with f(&amp;y) or f(inout y), and with a label, you&#39;d call it f(x:<br>&gt; &amp;y) or f(x: inout y).<br>&gt;<br>&gt; It seems  consistent to me.<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/73982a6c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 29, 2016 at 07:00:00pm</p></header><div class="content"><p>[ Proposal link: https://github.com/apple/swift-evolution/pull/127 &lt;https://github.com/apple/swift-evolution/pull/127&gt; ]<br></p><p>+1. As has been noted elsewhere, inout isn&#39;t just part of the parameter (since it appears in function types), and it&#39;s not part of the parameter&#39;s type (since within the body there&#39;s no inout-ness, and you can&#39;t put &#39;inout&#39; in a typealias on its own). To me, that means neither side of the colon is inherently &quot;correct&quot;, and therefore I prefer the slight consistency with function types and with call sites, and the removal of the possibility for typos becoming external parameter names.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/1051dbdb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 30, 2016 at 05:00:00pm</p></header><div class="content"><p>+1 for me including changing the call site to match, IE:<br></p><p>    func add(number n: inout Int)<br>    add(number: inout n)<br></p><p>On Saturday, 30 January 2016, Jordan Rose via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; [ Proposal link: https://github.com/apple/swift-evolution/pull/127 ]<br>&gt;<br>&gt; +1. As has been noted elsewhere, inout isn&#39;t *just* part of the parameter<br>&gt; (since it appears in function types), and it&#39;s not part of the parameter&#39;s<br>&gt; type (since within the body there&#39;s no inout-ness, and you can&#39;t put<br>&gt; &#39;inout&#39; in a typealias on its own). To me, that means neither side of the<br>&gt; colon is inherently &quot;correct&quot;, and therefore I prefer the slight<br>&gt; consistency with function types and with call sites, and the removal of the<br>&gt; possibility for typos becoming external parameter names.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br></p><p>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/dff61dd1/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>January 30, 2016 at 03:00:00pm</p></header><div class="content"><p>+1<br></p><p>This is very reasonable and clarifies usage.<br></p><p>&gt; On Jan 29, 2016, at 2:37 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/pull/127 &lt;https://github.com/apple/swift-evolution/pull/127&gt;<br>&gt; <br>&gt; Adjusting inout Declarations for Type Decoration<br>&gt; <br>&gt; Proposal: TBD<br>&gt; Author(s): Joe Groff &lt;https://github.com/jckarter&gt;, Erica Sadun &lt;http://github.com/erica&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; The inout keyword indicates copy-in/copy-out argument behavior. In its current implementation<br>&gt; the keyword prepands argument names. We propose to move the inout keyword to the right<br>&gt; side of the colon to decorate the type instead of the parameter label. <br>&gt; <br>&gt; The initial Swift-Evolution discussion of this topic took place in the “Replace ‘inout’ with &amp;” thread.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; In Swift 2, the inout parameter lives on the label side rather than the type side of the colon<br>&gt; although the keyword isn’t modifying the label but its type. Decorating<br>&gt; types instead of labels offers identifiable advantages: <br>&gt; <br>&gt; It enables the inout keyword to properly integrate into full type syntax, for example: <br>&gt; (x: inout T) -&gt; U // =&gt; (inout T) -&gt; U<br>&gt; It avoids notational similarity with arguments labeled inout, for example:<br>&gt; func foo(inOut x: T) // foo(inOut:), type (T) -&gt; Void<br>&gt; func foo(inout x: T) // foo(_:), type (inout T) -&gt; Void<br>&gt; It better matches similar patterns in other languages such as borrowing in Rust, that may be later introduced back to Swift <br>&gt; Detailed design<br>&gt; <br>&gt; parameter → external-parameter-name optlocal-parameter-name : type-annotation<br>&gt; type-annotation → inout type-annotation<br>&gt; Alternatives Considered<br>&gt; <br>&gt; Decorations using @inout (either @inout(T) or @inout T) were considered and discarded<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/a5515eba/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>January 30, 2016 at 11:00:00pm</p></header><div class="content"><p>I really like this proposal, so its a +1 from me. It really clarifies that inout is implemented via an implicit reference type that wraps the original value. To make thinks more consistent, one could also think about adding generic reference types to the language (inout T then becomes syntactic sugar for Reference&lt;T&gt;), however, I am not sure that such an addition would be that valuable. But this proposal would certainly open up a path for introducing references, if deemed reasonable at some point. <br></p><p>— Taras<br></p><p><br>&gt; On 30 Jan 2016, at 21:28, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1<br>&gt; <br>&gt; This is very reasonable and clarifies usage.<br>&gt; <br>&gt;&gt; On Jan 29, 2016, at 2:37 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/pull/127 &lt;https://github.com/apple/swift-evolution/pull/127&gt;<br>&gt;&gt; <br>&gt;&gt; Adjusting inout Declarations for Type Decoration<br>&gt;&gt; <br>&gt;&gt; Proposal: TBD<br>&gt;&gt; Author(s): Joe Groff &lt;https://github.com/jckarter&gt;, Erica Sadun &lt;http://github.com/erica&gt;<br>&gt;&gt; Status: TBD<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; The inout keyword indicates copy-in/copy-out argument behavior. In its current implementation<br>&gt;&gt; the keyword prepands argument names. We propose to move the inout keyword to the right<br>&gt;&gt; side of the colon to decorate the type instead of the parameter label. <br>&gt;&gt; <br>&gt;&gt; The initial Swift-Evolution discussion of this topic took place in the “Replace ‘inout’ with &amp;” thread.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; In Swift 2, the inout parameter lives on the label side rather than the type side of the colon<br>&gt;&gt; although the keyword isn’t modifying the label but its type. Decorating<br>&gt;&gt; types instead of labels offers identifiable advantages: <br>&gt;&gt; <br>&gt;&gt; It enables the inout keyword to properly integrate into full type syntax, for example: <br>&gt;&gt; (x: inout T) -&gt; U // =&gt; (inout T) -&gt; U<br>&gt;&gt; It avoids notational similarity with arguments labeled inout, for example:<br>&gt;&gt; func foo(inOut x: T) // foo(inOut:), type (T) -&gt; Void<br>&gt;&gt; func foo(inout x: T) // foo(_:), type (inout T) -&gt; Void<br>&gt;&gt; It better matches similar patterns in other languages such as borrowing in Rust, that may be later introduced back to Swift <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; parameter → external-parameter-name optlocal-parameter-name : type-annotation<br>&gt;&gt; type-annotation → inout type-annotation<br>&gt;&gt; Alternatives Considered<br>&gt;&gt; <br>&gt;&gt; Decorations using @inout (either @inout(T) or @inout T) were considered and discarded<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/4ffa3fe6/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>February  3, 2016 at 01:00:00pm</p></header><div class="content"><p>+1<br>It&#39;s better than the current form — but imho there is alternative that is worth being discussed:<br></p><p>(inout T) is a type on its own, right? (I guess although everyone seems to avoid the word, it is actually implemented as a pointer ;-)<br></p><p>Building on this, type &quot;inout T&quot; is associated with T, and it could be expressed using established syntax:<br>T.Inout (or T.Reference…)<br></p><p>I&#39;m not sure which choice I like better, but as long as there are no other type modifiers, I have a preference for replacing special syntax with something that is there anyway.<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/122a6891/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Proposal] Adjusting `inout` Declarations for Type Decoration</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February  3, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Feb 3, 2016, at 4:16, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1<br>&gt; It&#39;s better than the current form — but imho there is alternative that is worth being discussed:<br>&gt; <br>&gt; (inout T) is a type on its own, right? (I guess although everyone seems to avoid the word, it is actually implemented as a pointer ;-)<br></p><p>(inout T) is not a type on its own*, and it is not equivalent to a pointer. If it were, you could have local variables of type &quot;inout T&quot;, and you wouldn&#39;t be able to use computed properties with inout.<br></p><p>* The compiler represents &quot;inout T&quot; as a distinct type, but it also represents &quot;lvalue T&quot; and &quot;weak T&quot; and &quot;generic T without any bound generic arguments&quot; as types, so it&#39;s not really relevant here.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/88f2b35c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
