<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Failable arithmetic</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  4, 2015 at 02:00:00pm</p></header><div class="content"><p>Currently, Swift has three ways to handle potential overflows and other errors in arithmetic:<br></p><p>	// 1: Crashes<br>	Int.max + 1<br></p><p>	// 2: Returns the wrong answer (Int.min in this case)<br>	Int.max &amp;+ 1<br></p><p>	// 3: Returns a tuple with the value of &amp;+ and a boolean indicating whether it overflowed<br>	Int.addWithOverflow(Int.max, 1)<br></p><p>The problem is, if you want to handle overflows in some simple way, none of these are very good. 1 terminates your app, 2 gives the wrong answer, and 3 is very awkward to use. If you’re, for instance, working with numbers input by the user or downloaded from the Internet, you don’t want 1 or 2, and 3 is a major pain. You’re not looking to figure out exactly what went wrong; you just want to show the user “Arithmetic error” or something, rather than crashing or giving a wildly incorrect answer.<br></p><p>Therefore, I propose that we add failable arithmetic operators (e.g. +?). These return nil on overflow and the result on non-overflow.<br></p><p>	1 +? 1			// =&gt; Optional(1)<br>	Int.max +? 1		// =&gt; nil<br></p><p>	1 -? 1			// =&gt; Optional(0)<br>	Int.min -? 1		// =&gt; nil<br></p><p>	1 /? 1			// =&gt; Optional(1)<br>	1 /? 0			// =&gt; nil<br></p><p>One important consideration is that you ought to be able to chain such operations together into expressions like &quot;m *? x +? c”. The simplest way to do this would be to make these operators take optional arguments; then the implementations would all look something like this:<br></p><p>	func +? &lt;Integer: IntegerArithmeticType&gt;(lhs: Integer?, rhs: Integer?) -&gt; Integer? {<br>	    guard let lhs = lhs, rhs = rhs else {<br>	        return nil<br>	    }<br>    <br>	    let (result, overflowed) = Integer.addWithOverflow(lhs, rhs)<br>	    if overflowed {<br>	        return nil<br>	    }<br>	    else {<br>	        return result<br>	    }<br>	}<br></p><p>However, that might encourage people to misuse these operators to simply perform arithmetic on optional integers even when they don’t want nil-on-overflow. There may be some clever way to get these operators to allow chaining from other failable operators, but prevent the use of other nil-returning expressions; I’m not sure how that would be done, but I wouldn’t mind if Swift forced that sort of hygiene on this feature.<br></p><p>An alternative approach might be to write throwing variants of these operators which require the use of “try&quot;. These would have a few advantages: they would naturally short-circuit, they wouldn’t form an attractive nuisance for people trying to do arithmetic with optional integers, and the errors they throw could provide additional detail. However, unlike the association of Optional with ?, there’s no obvious way to associate these operators with the idea of trying and throwing. For this example, I’ve used “+!” purely for lack of a better idea:<br></p><p>	do {<br>	    print(try 1 +! 2 +! Int.max)<br>	}<br>	catch let error as IntegerArithmeticError {	// or perhaps IntegerArithmeticError&lt;Int&gt;<br>	    print(error)		// AdditionOverflow, or perhaps even AdditionOverflow(3, 9223372036854775807)<br>	}<br></p><p>Of course, if you really did just want an optional, you could always use “try?” with this.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Failable arithmetic</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  4, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 2:40 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt; Currently, Swift has three ways to handle potential overflows and other errors in arithmetic:<br>&gt; <br>&gt; 	// 1: Crashes<br>&gt; 	Int.max + 1<br>&gt; <br>&gt; 	// 2: Returns the wrong answer (Int.min in this case)<br>&gt; 	Int.max &amp;+ 1<br>&gt; <br>&gt; 	// 3: Returns a tuple with the value of &amp;+ and a boolean indicating whether it overflowed<br>&gt; 	Int.addWithOverflow(Int.max, 1)<br>&gt; <br>&gt; The problem is, if you want to handle overflows in some simple way, none of these are very good. 1 terminates your app, 2 gives the wrong answer, and 3 is very awkward to use. If you’re, for instance, working with numbers input by the user or downloaded from the Internet, you don’t want 1 or 2, and 3 is a major pain. You’re not looking to figure out exactly what went wrong; you just want to show the user “Arithmetic error” or something, rather than crashing or giving a wildly incorrect answer.<br>&gt; <br>&gt; Therefore, I propose that we add failable arithmetic operators (e.g. +?). These return nil on overflow and the result on non-overflow.<br>&gt; <br>&gt; 	1 +? 1			// =&gt; Optional(1)<br>&gt; 	Int.max +? 1		// =&gt; nil<br>&gt; <br>&gt; 	1 -? 1			// =&gt; Optional(0)<br>&gt; 	Int.min -? 1		// =&gt; nil<br>&gt; <br>&gt; 	1 /? 1			// =&gt; Optional(1)<br>&gt; 	1 /? 0			// =&gt; nil<br>&gt; <br>&gt; One important consideration is that you ought to be able to chain such operations together into expressions like &quot;m *? x +? c”. The simplest way to do this would be to make these operators take optional arguments; then the implementations would all look something like this:<br></p><p>This is similar to the request for a “force unwrap” operator that is catch’able.  If we were to do something along these lines, I’d rather see these be modeled as operators that can throw, rather than operators that produce an optional.  This will allow them to chain properly and compose correctly with other operations.  <br></p><p>There are other questions in this family: we’ve discussed adding saturating integer arithmetic operators as a way to handle this.  We have also discussed the idea of having “-ffast-math” floating point operators as well.  If you take this to the logical conclusion, you end up with large families of operators, all distinguished by magic sigil families that no one can remember :-)<br></p><p>Another way to think about this as a need to modify the behavior of failing operators.  This is not intended as a syntax proposal (just to get the idea across), but wouldn’t it be cool to be able to do:<br></p><p>  {<br>      #pragma failure_should_throw    // again, #pragma is really not the right way to spell this :-)<br>      try t = m * x + c<br>  }<br></p><p>and have the operators magically do the right thing?  Then you could generalize the behavior to support other families by using an english word to describe the semantics.  <br></p><p>-Chris<br></p><p><br></p><p>&gt; <br>&gt; 	func +? &lt;Integer: IntegerArithmeticType&gt;(lhs: Integer?, rhs: Integer?) -&gt; Integer? {<br>&gt; 	    guard let lhs = lhs, rhs = rhs else {<br>&gt; 	        return nil<br>&gt; 	    }<br>&gt; <br>&gt; 	    let (result, overflowed) = Integer.addWithOverflow(lhs, rhs)<br>&gt; 	    if overflowed {<br>&gt; 	        return nil<br>&gt; 	    }<br>&gt; 	    else {<br>&gt; 	        return result<br>&gt; 	    }<br>&gt; 	}<br>&gt; <br>&gt; However, that might encourage people to misuse these operators to simply perform arithmetic on optional integers even when they don’t want nil-on-overflow. There may be some clever way to get these operators to allow chaining from other failable operators, but prevent the use of other nil-returning expressions; I’m not sure how that would be done, but I wouldn’t mind if Swift forced that sort of hygiene on this feature.<br>&gt; <br>&gt; An alternative approach might be to write throwing variants of these operators which require the use of “try&quot;. These would have a few advantages: they would naturally short-circuit, they wouldn’t form an attractive nuisance for people trying to do arithmetic with optional integers, and the errors they throw could provide additional detail. However, unlike the association of Optional with ?, there’s no obvious way to associate these operators with the idea of trying and throwing. For this example, I’ve used “+!” purely for lack of a better idea:<br>&gt; <br>&gt; 	do {<br>&gt; 	    print(try 1 +! 2 +! Int.max)<br>&gt; 	}<br>&gt; 	catch let error as IntegerArithmeticError {	// or perhaps IntegerArithmeticError&lt;Int&gt;<br>&gt; 	    print(error)		// AdditionOverflow, or perhaps even AdditionOverflow(3, 9223372036854775807)<br>&gt; 	}<br>&gt; <br>&gt; Of course, if you really did just want an optional, you could always use “try?” with this.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Failable arithmetic</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  4, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 4:13 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 4, 2015, at 2:40 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Currently, Swift has three ways to handle potential overflows and other errors in arithmetic:<br>&gt;&gt; <br>&gt;&gt; 	// 1: Crashes<br>&gt;&gt; 	Int.max + 1<br>&gt;&gt; <br>&gt;&gt; 	// 2: Returns the wrong answer (Int.min in this case)<br>&gt;&gt; 	Int.max &amp;+ 1<br>&gt;&gt; <br>&gt;&gt; 	// 3: Returns a tuple with the value of &amp;+ and a boolean indicating whether it overflowed<br>&gt;&gt; 	Int.addWithOverflow(Int.max, 1)<br>&gt;&gt; <br>&gt;&gt; The problem is, if you want to handle overflows in some simple way, none of these are very good. 1 terminates your app, 2 gives the wrong answer, and 3 is very awkward to use. If you’re, for instance, working with numbers input by the user or downloaded from the Internet, you don’t want 1 or 2, and 3 is a major pain. You’re not looking to figure out exactly what went wrong; you just want to show the user “Arithmetic error” or something, rather than crashing or giving a wildly incorrect answer.<br>&gt;&gt; <br>&gt;&gt; Therefore, I propose that we add failable arithmetic operators (e.g. +?). These return nil on overflow and the result on non-overflow.<br>&gt;&gt; <br>&gt;&gt; 	1 +? 1			// =&gt; Optional(1)<br>&gt;&gt; 	Int.max +? 1		// =&gt; nil<br>&gt;&gt; <br>&gt;&gt; 	1 -? 1			// =&gt; Optional(0)<br>&gt;&gt; 	Int.min -? 1		// =&gt; nil<br>&gt;&gt; <br>&gt;&gt; 	1 /? 1			// =&gt; Optional(1)<br>&gt;&gt; 	1 /? 0			// =&gt; nil<br>&gt;&gt; <br>&gt;&gt; One important consideration is that you ought to be able to chain such operations together into expressions like &quot;m *? x +? c”. The simplest way to do this would be to make these operators take optional arguments; then the implementations would all look something like this:<br>&gt; <br>&gt; This is similar to the request for a “force unwrap” operator that is catch’able.  If we were to do something along these lines, I’d rather see these be modeled as operators that can throw, rather than operators that produce an optional.  This will allow them to chain properly and compose correctly with other operations.  <br>&gt; <br>&gt; There are other questions in this family: we’ve discussed adding saturating integer arithmetic operators as a way to handle this.  We have also discussed the idea of having “-ffast-math” floating point operators as well.  If you take this to the logical conclusion, you end up with large families of operators, all distinguished by magic sigil families that no one can remember :-)<br>&gt; <br>&gt; Another way to think about this as a need to modify the behavior of failing operators.  This is not intended as a syntax proposal (just to get the idea across), but wouldn’t it be cool to be able to do:<br>&gt; <br>&gt;  {<br>&gt;      #pragma failure_should_throw    // again, #pragma is really not the right way to spell this :-)<br>&gt;      try t = m * x + c<br>&gt;  }<br>&gt; <br>&gt; and have the operators magically do the right thing?  Then you could generalize the behavior to support other families by using an english word to describe the semantics.  <br></p><p>This is a place where scoped `import` might help too. For instance, you could import a module with throwing variants of the operators:<br></p><p>{<br>  import ThrowingOnOverflow<br>  try t = m * x + c<br>}<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/a3e20348/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Failable arithmetic</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  4, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; Another way to think about this as a need to modify the behavior of failing operators.  This is not intended as a syntax proposal (just to get the idea across), but wouldn’t it be cool to be able to do:<br>&gt; <br>&gt;  {<br>&gt;      #pragma failure_should_throw    // again, #pragma is really not the right way to spell this :-)<br>&gt;      try t = m * x + c<br>&gt;  }<br>&gt; <br>&gt; and have the operators magically do the right thing?  Then you could generalize the behavior to support other families by using an english word to describe the semantics.  <br></p><p>I like the idea of having multiple semantics and selecting the one you want for an entire expression, rather than dangling sigils on all your operators.<br></p><p>This is, of course, easy to do if you introduce enough abstraction: &lt;https://gist.github.com/brentdax/6fc5d717f7c85e159ec7&gt; I assume this would be very slow as written, but perhaps the optimizer could do something along the lines of constant folding to convert the operation tree into straight-line code.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
