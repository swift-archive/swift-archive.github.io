<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a8c5aceede03294627b62ceb893670a6?s=50"></div><header><strong>What is &quot;binding&quot; memory?</strong> from <string>Manfred Schubert</string> &lt;dev at schubert-it.com&gt;<p>November  1, 2016 at 07:00:00pm</p></header><div class="content"><p>The &quot;UnsafeRawPointer Migration&quot; guide talks about &quot;binding memory to a type“ as if that was a well known term. I have never heard of it yet though, and googling it returns no relevant results. I do not understand what binding memory is supposed to do.<br></p><p>The migration guide says &quot;Binding uninitialized memory to a type prepares the memory to store values of that type“, but clearly raw memory does not need to be prepared (and cannot be) to hold any arbitrary type and value.<br></p><p>So what is this for, what does it actually do, and to whom is it done (the raw pointer, or the typed pointer which is returned, or the raw memory)?<br></p><p><br>Manfred<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>What is &quot;binding&quot; memory?</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>November  1, 2016 at 08:00:00pm</p></header><div class="content"><p>The way I understand it, it prepares a memory structure that refers to the ‘raw memory’ such that it can be used to access the referenced memory according to the type ‘bound’ to.<br> <br>Regards,<br>Rien<br></p><p>Site: http://balancingrock.nl<br>Blog: http://swiftrien.blogspot.com<br>Github: http://github.com/Swiftrien<br>Project: http://swiftfire.nl<br></p><p><br></p><p><br>&gt; On 01 Nov 2016, at 19:55, Manfred Schubert via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; The &quot;UnsafeRawPointer Migration&quot; guide talks about &quot;binding memory to a type“ as if that was a well known term. I have never heard of it yet though, and googling it returns no relevant results. I do not understand what binding memory is supposed to do.<br>&gt; <br>&gt; The migration guide says &quot;Binding uninitialized memory to a type prepares the memory to store values of that type“, but clearly raw memory does not need to be prepared (and cannot be) to hold any arbitrary type and value.<br>&gt; <br>&gt; So what is this for, what does it actually do, and to whom is it done (the raw pointer, or the typed pointer which is returned, or the raw memory)?<br>&gt; <br>&gt; <br>&gt; Manfred<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>What is &quot;binding&quot; memory?</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>November  1, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Nov 1, 2016, at 11:55 AM, Manfred Schubert via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; The &quot;UnsafeRawPointer Migration&quot; guide talks about &quot;binding memory to a type“ as if that was a well known term. I have never heard of it yet though, and googling it returns no relevant results. I do not understand what binding memory is supposed to do.<br>&gt; <br>&gt; The migration guide says &quot;Binding uninitialized memory to a type prepares the memory to store values of that type“, but clearly raw memory does not need to be prepared (and cannot be) to hold any arbitrary type and value.<br>&gt; <br>&gt; So what is this for, what does it actually do, and to whom is it done (the raw pointer, or the typed pointer which is returned, or the raw memory)?<br>&gt; <br>&gt; <br>&gt; Manfred<br></p><p>Hi Manfred,<br></p><p>At the top of the migration guide is a link to the memory model explanation:<br>https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md#memory-model-explanation<br></p><p>&quot;A memory location&#39;s bound type is an abstract, dynamic property of the memory used to formalize type safety.”<br></p><p>I’m not sure I like the “prepares the memory” language myself. Binding memory communicates to the compiler that the memory locations are safe for typed access. Nothing happens at runtime--until someone writes a type safety sanitizer. It affects the abstract state of the memory location, independent of the pointer variable used to access that memory. Binding memory returns a typed pointer for convenience and clarity, but there’s nothing special about that particular pointer value.<br></p><p>Initialized memory is always bound to some type. A rawpointer can be used to access that memory without knowing its bound type.<br></p><p>-Andy<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a8c5aceede03294627b62ceb893670a6?s=50"></div><header><strong>What is &quot;binding&quot; memory?</strong> from <string>Manfred Schubert</string> &lt;dev at schubert-it.com&gt;<p>November  2, 2016 at 06:00:00pm</p></header><div class="content"><p>Am 01.11.2016 um 21:40 schrieb Andrew Trick &lt;atrick at apple.com&gt;:<br>&gt; <br>&gt; I’m not sure I like the “prepares the memory” language myself. Binding memory communicates to the compiler that the memory locations are safe for typed access. Nothing happens at runtime--until someone writes a type safety sanitizer.<br></p><p>So nothing happens at runtime, and also nothing appears to happen at compile time. If I try this code:<br></p><p>&gt; var rawPtr = UnsafeMutableRawPointer.allocate(bytes: 2, alignedTo: 0)<br>&gt; <br>&gt; var widePtr = rawPtr.bindMemory(to: Int16.self, capacity: 1)<br>&gt; <br>&gt; widePtr.pointee = 32<br>&gt; <br>&gt; var narrowPtr = rawPtr.bindMemory(to: UInt8.self, capacity: 2)<br>&gt; <br>&gt; narrowPtr[0] = 16<br>&gt; narrowPtr[1] = 255<br>&gt; <br>&gt; print(widePtr.pointee)<br></p><p>This compiles and runs as expected, but it should not be allowed if I understand things correctly. So shouldn’t it be a compile time error or crash at runtime? If not, what do I get over how it was before where I was casting to a typed pointer?<br></p><p>&gt; It affects the abstract state of the memory location, independent of the pointer variable used to access that memory. Binding memory returns a typed pointer for convenience and clarity, but there’s nothing special about that particular pointer value.<br></p><p>If it were not returning a typed pointer, what would it actually do?<br></p><p><br>Manfred<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>What is &quot;binding&quot; memory?</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>November  2, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On 02 Nov 2016, at 18:07, Manfred Schubert via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Am 01.11.2016 um 21:40 schrieb Andrew Trick &lt;atrick at apple.com&gt;:<br>&gt;&gt; <br>&gt;&gt; I’m not sure I like the “prepares the memory” language myself. Binding memory communicates to the compiler that the memory locations are safe for typed access. Nothing happens at runtime--until someone writes a type safety sanitizer.<br>&gt; <br>&gt; So nothing happens at runtime, and also nothing appears to happen at compile time. If I try this code:<br>&gt; <br>&gt;&gt; var rawPtr = UnsafeMutableRawPointer.allocate(bytes: 2, alignedTo: 0)<br>&gt;&gt; <br>&gt;&gt; var widePtr = rawPtr.bindMemory(to: Int16.self, capacity: 1)<br>&gt;&gt; <br>&gt;&gt; widePtr.pointee = 32<br>&gt;&gt; <br>&gt;&gt; var narrowPtr = rawPtr.bindMemory(to: UInt8.self, capacity: 2)<br>&gt;&gt; <br>&gt;&gt; narrowPtr[0] = 16<br>&gt;&gt; narrowPtr[1] = 255<br>&gt;&gt; <br>&gt;&gt; print(widePtr.pointee)<br>&gt; <br>&gt; This compiles and runs as expected, but it should not be allowed if I understand things correctly. So shouldn’t it be a compile time error or crash at runtime? If not, what do I get over how it was before where I was casting to a typed pointer?<br></p><p>Why do you think it should not be allowed.<br>AFAICS everything is correct.<br>Are you referring to the multiple interpretation of the raw memory? That is entirely intentional, indeed one of the main purposes.<br></p><p>Rien.<br></p><p>&gt; <br>&gt;&gt; It affects the abstract state of the memory location, independent of the pointer variable used to access that memory. Binding memory returns a typed pointer for convenience and clarity, but there’s nothing special about that particular pointer value.<br>&gt; <br>&gt; If it were not returning a typed pointer, what would it actually do?<br>&gt; <br>&gt; <br>&gt; Manfred<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a8c5aceede03294627b62ceb893670a6?s=50"></div><header><strong>What is &quot;binding&quot; memory?</strong> from <string>Manfred Schubert</string> &lt;dev at schubert-it.com&gt;<p>November  3, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Am 02.11.2016 um 18:37 schrieb Rien &lt;Rien at Balancingrock.nl&gt;:<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var rawPtr = UnsafeMutableRawPointer.allocate(bytes: 2, alignedTo: 0)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var widePtr = rawPtr.bindMemory(to: Int16.self, capacity: 1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; widePtr.pointee = 32<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var narrowPtr = rawPtr.bindMemory(to: UInt8.self, capacity: 2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; narrowPtr[0] = 16<br>&gt;&gt;&gt; narrowPtr[1] = 255<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(widePtr.pointee)<br>&gt;&gt; <br>&gt;&gt; This compiles and runs as expected, but it should not be allowed if I understand things correctly. So shouldn’t it be a compile time error or crash at runtime? If not, what do I get over how it was before where I was casting to a typed pointer?<br>&gt; <br>&gt; Why do you think it should not be allowed.<br>&gt; AFAICS everything is correct.<br></p><p>If I understand the documentation correctly, this should not be allowed, because it’s not allowed to access memory as different types at the same time. It needs to be „bound“ to the type first, and can only be bound to one type at a time, so all access as another type must be encapsulated within a closure.<br></p><p><br>Manfred<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>What is &quot;binding&quot; memory?</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>November  3, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On 03 Nov 2016, at 15:16, Manfred Schubert via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 02.11.2016 um 18:37 schrieb Rien &lt;Rien at Balancingrock.nl&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var rawPtr = UnsafeMutableRawPointer.allocate(bytes: 2, alignedTo: 0)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var widePtr = rawPtr.bindMemory(to: Int16.self, capacity: 1)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; widePtr.pointee = 32<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var narrowPtr = rawPtr.bindMemory(to: UInt8.self, capacity: 2)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; narrowPtr[0] = 16<br>&gt;&gt;&gt;&gt; narrowPtr[1] = 255<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; print(widePtr.pointee)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This compiles and runs as expected, but it should not be allowed if I understand things correctly. So shouldn’t it be a compile time error or crash at runtime? If not, what do I get over how it was before where I was casting to a typed pointer?<br>&gt;&gt; <br>&gt;&gt; Why do you think it should not be allowed.<br>&gt;&gt; AFAICS everything is correct.<br>&gt; <br>&gt; If I understand the documentation correctly, this should not be allowed, because it’s not allowed to access memory as different types at the same time. It needs to be „bound“ to the type first, and can only be bound to one type at a time, so all access as another type must be encapsulated within a closure.<br>&gt; <br></p><p>Ah, but that is not the case.<br></p><p>It is important to differentiate between the “gateway” to the memory and the memory area itself.<br>Different programming languages/compilers have different approaches, but I believe that Swift allocates a struct for every gateway.<br>widePtr and narrowPtr are two different gateways. They refer to different struct&#39;s. But the struct for each of them refers to the same memory area.<br></p><p>Example: widePtr can be located at address 0x1000, narrowPtr can be allocated at address 0x2000 while the memory area both refer to (the raw memory) can be at address 0x3000<br></p><p>Every access to the raw memory via a gateway must follow the rules for that gateway.<br></p><p>Note: Some compilers may only create ephemeral gateways, but as long as the compiler checks that the acces follows the correct rules, that is not a problem.<br></p><p>This is not only very useful, but it also opens the door to better interfaces to some low level Unix APIs.<br></p><p><br>&gt; <br>&gt; Manfred<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>Regards,<br>Rien<br></p><p>Site: http://balancingrock.nl<br>Blog: http://swiftrien.blogspot.com<br>Github: http://github.com/Swiftrien<br>Project: http://swiftfire.nl<br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161103/0473aecd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a8c5aceede03294627b62ceb893670a6?s=50"></div><header><strong>What is &quot;binding&quot; memory?</strong> from <string>Manfred Schubert</string> &lt;dev at schubert-it.com&gt;<p>November  3, 2016 at 11:00:00pm</p></header><div class="content"><p>Am 03.11.2016 um 15:41 schrieb Rien &lt;Rien at Balancingrock.nl&gt;:<br>&gt; <br>&gt; Ah, but that is not the case.<br>&gt; <br>&gt; It is important to differentiate between the “gateway” to the memory and the memory area itself.<br>&gt; Different programming languages/compilers have different approaches, but I believe that Swift allocates a struct for every gateway.<br>&gt; widePtr and narrowPtr are two different gateways. They refer to different struct&#39;s. But the struct for each of them refers to the same memory area.<br></p><p>When you have a look at the Swift memory model explanation<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md#memory-model-explanation<br></p><p>it looks like memory can only be bound to one type at a time. In particular in the third example where a pointer of type T is used to initialize memory which is bound to type U, it says that the behavior is undefined.<br></p><p>There is also withMemoryRebound(to:capacity:) which binds memory to another type, executes the code that accesses the memory as this type in a closure, and the restores the old type binding.<br></p><p>That makes me think that it is not allowed to have multiple „gateways“ to the same memory area at the same time.<br></p><p><br>Manfred<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>What is &quot;binding&quot; memory?</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>November  4, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 03 Nov 2016, at 23:58, Manfred Schubert via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Am 03.11.2016 um 15:41 schrieb Rien &lt;Rien at Balancingrock.nl&gt;:<br>&gt;&gt; <br>&gt;&gt; Ah, but that is not the case.<br>&gt;&gt; <br>&gt;&gt; It is important to differentiate between the “gateway” to the memory and the memory area itself.<br>&gt;&gt; Different programming languages/compilers have different approaches, but I believe that Swift allocates a struct for every gateway.<br>&gt;&gt; widePtr and narrowPtr are two different gateways. They refer to different struct&#39;s. But the struct for each of them refers to the same memory area.<br>&gt; <br>&gt; When you have a look at the Swift memory model explanation<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md#memory-model-explanation<br>&gt; <br>&gt; it looks like memory can only be bound to one type at a time. In particular in the third example where a pointer of type T is used to initialize memory which is bound to type U, it says that the behavior is undefined.<br>&gt; <br>&gt; There is also withMemoryRebound(to:capacity:) which binds memory to another type, executes the code that accesses the memory as this type in a closure, and the restores the old type binding.<br>&gt; <br>&gt; That makes me think that it is not allowed to have multiple „gateways“ to the same memory area at the same time.<br>&gt; <br></p><p>It only means that memory access must be typed, not existence.<br></p><p>&gt; <br>&gt; Manfred<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>Regards,<br>Rien<br></p><p>Site: http://balancingrock.nl<br>Blog: http://swiftrien.blogspot.com<br>Github: http://github.com/Swiftrien<br>Project: http://swiftfire.nl<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>What is &quot;binding&quot; memory?</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>November  3, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Nov 3, 2016, at 7:41 AM, Rien via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On 03 Nov 2016, at 15:16, Manfred Schubert via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 02.11.2016 um 18:37 schrieb Rien &lt;Rien at Balancingrock.nl &lt;mailto:Rien at balancingrock.nl&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; var rawPtr = UnsafeMutableRawPointer.allocate(bytes: 2, alignedTo: 0)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; var widePtr = rawPtr.bindMemory(to: Int16.self, capacity: 1)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; widePtr.pointee = 32<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; var narrowPtr = rawPtr.bindMemory(to: UInt8.self, capacity: 2)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; narrowPtr[0] = 16<br>&gt;&gt;&gt;&gt;&gt; narrowPtr[1] = 255<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; print(widePtr.pointee)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This compiles and runs as expected, but it should not be allowed if I understand things correctly. So shouldn’t it be a compile time error or crash at runtime? If not, what do I get over how it was before where I was casting to a typed pointer?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why do you think it should not be allowed.<br>&gt;&gt;&gt; AFAICS everything is correct.<br>&gt;&gt; <br>&gt;&gt; If I understand the documentation correctly, this should not be allowed, because it’s not allowed to access memory as different types at the same time. It needs to be „bound“ to the type first, and can only be bound to one type at a time, so all access as another type must be encapsulated within a closure.<br>&gt;&gt; <br>&gt; <br>&gt; Ah, but that is not the case.<br>&gt; <br>&gt; It is important to differentiate between the “gateway” to the memory and the memory area itself.<br>&gt; Different programming languages/compilers have different approaches, but I believe that Swift allocates a struct for every gateway.<br>&gt; widePtr and narrowPtr are two different gateways. They refer to different struct&#39;s. But the struct for each of them refers to the same memory area.<br></p><p>In the Swift memory model, a pointer value is substitutable with any other pointer of the same value. And for efficiency, pointer values are implemented as addresses. This was an intentional design decision. For example, this is well-defined:<br></p><p>func foo&lt;T: Equatable&gt;(rawPtr: UnsafeRawPointer, ptrT: UnsafePointer&lt;T&gt;) {<br>  if rawPtr == UnsafeRawPointer(ptrT) {<br>    assert(rawPtr.assumingMemoryBound(to: T.self).pointee == ptrT.pointee)<br>  }<br>}<br></p><p>Note that assumingMemoryBound(to:) is essentially a nice way of doing unsafeBitCast, but intentional and verifiable.<br></p><p>&gt; Example: widePtr can be located at address 0x1000, narrowPtr can be allocated at address 0x2000 while the memory area both refer to (the raw memory) can be at address 0x3000<br></p><p>Swift strict aliasing means that unrelated typed accesses to memory cannot overlap in their underlying raw memory.<br></p><p>Our UnsafePointer value representation is not realistically ever going to depend on the Pointee type.<br></p><p>&gt; Every access to the raw memory via a gateway must follow the rules for that gateway.<br></p><p>&gt; Note: Some compilers may only create ephemeral gateways, but as long as the compiler checks that the acces follows the correct rules, that is not a problem.<br>&gt; <br>&gt; This is not only very useful, but it also opens the door to better interfaces to some low level Unix APIs.<br></p><p>I think we would want a Swift interface on top of those APIs that doesn’t rely on type punning.<br></p><p>A Swift pointer value itself doesn’t provide a gateway. It is really bindMemory(to:capacity:) or withMemoryRebound(to:capacity:) that control whether typed access is well-defined at some point in the program.<br></p><p>In native Swift code, interacting with the memory binding APIs will be extremely rare. Type punning is not a “normal” activity outside of use cases like network I/O and binary file formats. In those cases it probably makes more sense to use a raw pointer directly rather than binding memory to a type.<br></p><p>-Andy<br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Manfred<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br>&gt; Regards,<br>&gt; Rien<br>&gt; <br>&gt; Site: http://balancingrock.nl &lt;http://balancingrock.nl/&gt;<br>&gt; Blog: http://swiftrien.blogspot.com &lt;http://swiftrien.blogspot.com/&gt;<br>&gt; Github: http://github.com/Swiftrien &lt;http://github.com/Swiftrien&gt;<br>&gt; Project: http://swiftfire.nl &lt;http://swiftfire.nl/&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161103/7e86d0a9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>What is &quot;binding&quot; memory?</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>November  4, 2016 at 08:00:00am</p></header><div class="content"><p>Thanks Any, most informative.<br></p><p>So the pointer “gateway’s” are in fact ephemeral. That is good for performance.<br></p><p>As to the low level interfaces, are you aware of any effort that addresses the POSIX socket functions?<br>(Things like ‘addrinfo&#39;)<br></p><p>Regards,<br>Rien<br></p><p>Site: http://balancingrock.nl<br>Blog: http://swiftrien.blogspot.com<br>Github: http://github.com/Swiftrien<br>Project: http://swiftfire.nl<br></p><p><br></p><p><br>&gt; On 04 Nov 2016, at 06:24, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Nov 3, 2016, at 7:41 AM, Rien via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 03 Nov 2016, at 15:16, Manfred Schubert via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 02.11.2016 um 18:37 schrieb Rien &lt;Rien at Balancingrock.nl&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; var rawPtr = UnsafeMutableRawPointer.allocate(bytes: 2, alignedTo: 0)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; var widePtr = rawPtr.bindMemory(to: Int16.self, capacity: 1)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; widePtr.pointee = 32<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; var narrowPtr = rawPtr.bindMemory(to: UInt8.self, capacity: 2)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; narrowPtr[0] = 16<br>&gt;&gt;&gt;&gt;&gt;&gt; narrowPtr[1] = 255<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; print(widePtr.pointee)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This compiles and runs as expected, but it should not be allowed if I understand things correctly. So shouldn’t it be a compile time error or crash at runtime? If not, what do I get over how it was before where I was casting to a typed pointer?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Why do you think it should not be allowed.<br>&gt;&gt;&gt;&gt; AFAICS everything is correct.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If I understand the documentation correctly, this should not be allowed, because it’s not allowed to access memory as different types at the same time. It needs to be „bound“ to the type first, and can only be bound to one type at a time, so all access as another type must be encapsulated within a closure.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Ah, but that is not the case.<br>&gt;&gt; <br>&gt;&gt; It is important to differentiate between the “gateway” to the memory and the memory area itself.<br>&gt;&gt; Different programming languages/compilers have different approaches, but I believe that Swift allocates a struct for every gateway.<br>&gt;&gt; widePtr and narrowPtr are two different gateways. They refer to different struct&#39;s. But the struct for each of them refers to the same memory area.<br>&gt; <br>&gt; In the Swift memory model, a pointer value is substitutable with any other pointer of the same value. And for efficiency, pointer values are implemented as addresses. This was an intentional design decision. For example, this is well-defined:<br>&gt; <br>&gt; func foo&lt;T: Equatable&gt;(rawPtr: UnsafeRawPointer, ptrT: UnsafePointer&lt;T&gt;) {<br>&gt;   if rawPtr == UnsafeRawPointer(ptrT) {<br>&gt;     assert(rawPtr.assumingMemoryBound(to: T.self).pointee == ptrT.pointee)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Note that assumingMemoryBound(to:) is essentially a nice way of doing unsafeBitCast, but intentional and verifiable.<br>&gt; <br>&gt;&gt; Example: widePtr can be located at address 0x1000, narrowPtr can be allocated at address 0x2000 while the memory area both refer to (the raw memory) can be at address 0x3000<br>&gt; <br>&gt; Swift strict aliasing means that unrelated typed accesses to memory cannot overlap in their underlying raw memory.<br>&gt; <br>&gt; Our UnsafePointer value representation is not realistically ever going to depend on the Pointee type.<br>&gt; <br>&gt;&gt; Every access to the raw memory via a gateway must follow the rules for that gateway.<br>&gt; <br>&gt;&gt; Note: Some compilers may only create ephemeral gateways, but as long as the compiler checks that the acces follows the correct rules, that is not a problem.<br>&gt;&gt; <br>&gt;&gt; This is not only very useful, but it also opens the door to better interfaces to some low level Unix APIs.<br>&gt; <br>&gt; I think we would want a Swift interface on top of those APIs that doesn’t rely on type punning.<br>&gt; <br>&gt; A Swift pointer value itself doesn’t provide a gateway. It is really bindMemory(to:capacity:) or withMemoryRebound(to:capacity:) that control whether typed access is well-defined at some point in the program.<br>&gt; <br>&gt; In native Swift code, interacting with the memory binding APIs will be extremely rare. Type punning is not a “normal” activity outside of use cases like network I/O and binary file formats. In those cases it probably makes more sense to use a raw pointer directly rather than binding memory to a type.<br>&gt; <br>&gt; -Andy<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Manfred<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt; <br>&gt;&gt; Regards,<br>&gt;&gt; Rien<br>&gt;&gt; <br>&gt;&gt; Site: http://balancingrock.nl<br>&gt;&gt; Blog: http://swiftrien.blogspot.com<br>&gt;&gt; Github: http://github.com/Swiftrien<br>&gt;&gt; Project: http://swiftfire.nl<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>What is &quot;binding&quot; memory?</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>November  4, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Nov 4, 2016, at 12:16 AM, Rien &lt;Rien at Balancingrock.nl&gt; wrote:<br>&gt; <br>&gt; Thanks Any, most informative.<br>&gt; <br>&gt; So the pointer “gateway’s” are in fact ephemeral. That is good for performance.<br>&gt; <br>&gt; As to the low level interfaces, are you aware of any effort that addresses the POSIX socket functions?<br>&gt; (Things like ‘addrinfo&#39;)<br></p><p>I&#39;ve seen some discussion on mailing lists and forums.  I included a little blurb in the 3.0 migration guide.  Search for socket API helpers in this page. <br></p><p>https://swift.org/migration-guide/se-0107-migrate.html#common-use-cases<br></p><p>Andy<br></p><p>&gt; <br>&gt; Regards,<br>&gt; Rien<br>&gt; <br>&gt; Site: http://balancingrock.nl<br>&gt; Blog: http://swiftrien.blogspot.com<br>&gt; Github: http://github.com/Swiftrien<br>&gt; Project: http://swiftfire.nl<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt;&gt; On 04 Nov 2016, at 06:24, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Nov 3, 2016, at 7:41 AM, Rien via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 03 Nov 2016, at 15:16, Manfred Schubert via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 02.11.2016 um 18:37 schrieb Rien &lt;Rien at Balancingrock.nl&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var rawPtr = UnsafeMutableRawPointer.allocate(bytes: 2, alignedTo: 0)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var widePtr = rawPtr.bindMemory(to: Int16.self, capacity: 1)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; widePtr.pointee = 32<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var narrowPtr = rawPtr.bindMemory(to: UInt8.self, capacity: 2)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; narrowPtr[0] = 16<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; narrowPtr[1] = 255<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; print(widePtr.pointee)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This compiles and runs as expected, but it should not be allowed if I understand things correctly. So shouldn’t it be a compile time error or crash at runtime? If not, what do I get over how it was before where I was casting to a typed pointer?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Why do you think it should not be allowed.<br>&gt;&gt;&gt;&gt;&gt; AFAICS everything is correct.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If I understand the documentation correctly, this should not be allowed, because it’s not allowed to access memory as different types at the same time. It needs to be „bound“ to the type first, and can only be bound to one type at a time, so all access as another type must be encapsulated within a closure.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ah, but that is not the case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is important to differentiate between the “gateway” to the memory and the memory area itself.<br>&gt;&gt;&gt; Different programming languages/compilers have different approaches, but I believe that Swift allocates a struct for every gateway.<br>&gt;&gt;&gt; widePtr and narrowPtr are two different gateways. They refer to different struct&#39;s. But the struct for each of them refers to the same memory area.<br>&gt;&gt; <br>&gt;&gt; In the Swift memory model, a pointer value is substitutable with any other pointer of the same value. And for efficiency, pointer values are implemented as addresses. This was an intentional design decision. For example, this is well-defined:<br>&gt;&gt; <br>&gt;&gt; func foo&lt;T: Equatable&gt;(rawPtr: UnsafeRawPointer, ptrT: UnsafePointer&lt;T&gt;) {<br>&gt;&gt;  if rawPtr == UnsafeRawPointer(ptrT) {<br>&gt;&gt;    assert(rawPtr.assumingMemoryBound(to: T.self).pointee == ptrT.pointee)<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Note that assumingMemoryBound(to:) is essentially a nice way of doing unsafeBitCast, but intentional and verifiable.<br>&gt;&gt; <br>&gt;&gt;&gt; Example: widePtr can be located at address 0x1000, narrowPtr can be allocated at address 0x2000 while the memory area both refer to (the raw memory) can be at address 0x3000<br>&gt;&gt; <br>&gt;&gt; Swift strict aliasing means that unrelated typed accesses to memory cannot overlap in their underlying raw memory.<br>&gt;&gt; <br>&gt;&gt; Our UnsafePointer value representation is not realistically ever going to depend on the Pointee type.<br>&gt;&gt; <br>&gt;&gt;&gt; Every access to the raw memory via a gateway must follow the rules for that gateway.<br>&gt;&gt; <br>&gt;&gt;&gt; Note: Some compilers may only create ephemeral gateways, but as long as the compiler checks that the acces follows the correct rules, that is not a problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is not only very useful, but it also opens the door to better interfaces to some low level Unix APIs.<br>&gt;&gt; <br>&gt;&gt; I think we would want a Swift interface on top of those APIs that doesn’t rely on type punning.<br>&gt;&gt; <br>&gt;&gt; A Swift pointer value itself doesn’t provide a gateway. It is really bindMemory(to:capacity:) or withMemoryRebound(to:capacity:) that control whether typed access is well-defined at some point in the program.<br>&gt;&gt; <br>&gt;&gt; In native Swift code, interacting with the memory binding APIs will be extremely rare. Type punning is not a “normal” activity outside of use cases like network I/O and binary file formats. In those cases it probably makes more sense to use a raw pointer directly rather than binding memory to a type.<br>&gt;&gt; <br>&gt;&gt; -Andy<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Manfred<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt; Rien<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Site: http://balancingrock.nl<br>&gt;&gt;&gt; Blog: http://swiftrien.blogspot.com<br>&gt;&gt;&gt; Github: http://github.com/Swiftrien<br>&gt;&gt;&gt; Project: http://swiftfire.nl<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161104/00f5fcb6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>What is &quot;binding&quot; memory?</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>November  3, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Nov 3, 2016, at 7:16 AM, Manfred Schubert via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 02.11.2016 um 18:37 schrieb Rien &lt;Rien at Balancingrock.nl&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var rawPtr = UnsafeMutableRawPointer.allocate(bytes: 2, alignedTo: 0)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var widePtr = rawPtr.bindMemory(to: Int16.self, capacity: 1)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; widePtr.pointee = 32<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var narrowPtr = rawPtr.bindMemory(to: UInt8.self, capacity: 2)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; narrowPtr[0] = 16<br>&gt;&gt;&gt;&gt; narrowPtr[1] = 255<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; print(widePtr.pointee)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This compiles and runs as expected, but it should not be allowed if I understand things correctly. So shouldn’t it be a compile time error or crash at runtime? If not, what do I get over how it was before where I was casting to a typed pointer?<br>&gt;&gt; <br>&gt;&gt; Why do you think it should not be allowed.<br>&gt;&gt; AFAICS everything is correct.<br>&gt; <br>&gt; If I understand the documentation correctly, this should not be allowed, because it’s not allowed to access memory as different types at the same time. It needs to be „bound“ to the type first, and can only be bound to one type at a time, so all access as another type must be encapsulated within a closure.<br></p><p>Yes, this would work<br></p><p>  withMemoryRebound(to: UInt16.self, capacity: 1) { print($0.pointee) }<br></p><p>So would this<br></p><p>  rawPtr.bindMemory(to: Int16.self, capacity: 1)<br>  print(widePtr.pointee)<br></p><p>Or this<br></p><p>  rawPtr.load(as: UInt16.self)<br></p><p>-Andy<br></p><p>&gt; <br>&gt; <br>&gt; Manfred<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>What is &quot;binding&quot; memory?</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>November  3, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Nov 2, 2016, at 10:37 AM, Rien via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; var rawPtr = UnsafeMutableRawPointer.allocate(bytes: 2, alignedTo: 0)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var widePtr = rawPtr.bindMemory(to: Int16.self, capacity: 1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; widePtr.pointee = 32<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var narrowPtr = rawPtr.bindMemory(to: UInt8.self, capacity: 2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; narrowPtr[0] = 16<br>&gt;&gt;&gt; narrowPtr[1] = 255<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(widePtr.pointee)<br>&gt;&gt; <br>&gt;&gt; This compiles and runs as expected, but it should not be allowed if I understand things correctly. So shouldn’t it be a compile time error or crash at runtime? If not, what do I get over how it was before where I was casting to a typed pointer?<br>&gt; <br>&gt; Why do you think it should not be allowed.<br>&gt; AFAICS everything is correct.<br>&gt; Are you referring to the multiple interpretation of the raw memory? That is entirely intentional, indeed one of the main purposes.<br></p><p>Allowing type punning is one of the main purposes of raw memory access (via a raw pointer). But in this code, widePtr.pointee is a typed UInt16 load from memory that is bound to UInt8. Loading a UInt16 without rebinding memory first requires a raw load such as:<br></p><p>rawPtr.load(as: UInt16.self)<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161103/fb54657e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>What is &quot;binding&quot; memory?</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>November  3, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Nov 2, 2016, at 10:07 AM, Manfred Schubert via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Am 01.11.2016 um 21:40 schrieb Andrew Trick &lt;atrick at apple.com&gt;:<br>&gt;&gt; <br>&gt;&gt; I’m not sure I like the “prepares the memory” language myself. Binding memory communicates to the compiler that the memory locations are safe for typed access. Nothing happens at runtime--until someone writes a type safety sanitizer.<br>&gt; <br>&gt; So nothing happens at runtime, and also nothing appears to happen at compile time.<br></p><p>Nothing observable happens at the call to ptrT = bindMemory(to: T.self, …). It&#39;s effect on the program is making the subsequent ptrT.pointee a well-defined operation.<br></p><p>&gt; If I try this code:<br>&gt; <br>&gt;&gt; var rawPtr = UnsafeMutableRawPointer.allocate(bytes: 2, alignedTo: 0)<br>&gt;&gt; <br>&gt;&gt; var widePtr = rawPtr.bindMemory(to: Int16.self, capacity: 1)<br>&gt;&gt; <br>&gt;&gt; widePtr.pointee = 32<br>&gt;&gt; <br>&gt;&gt; var narrowPtr = rawPtr.bindMemory(to: UInt8.self, capacity: 2)<br>&gt;&gt; <br>&gt;&gt; narrowPtr[0] = 16<br>&gt;&gt; narrowPtr[1] = 255<br>&gt;&gt; <br>&gt;&gt; print(widePtr.pointee)<br>&gt; <br>&gt; This compiles and runs as expected, but it should not be allowed if I understand things correctly. So shouldn’t it be a compile time error or crash at runtime? If not, what do I get over how it was before where I was casting to a typed pointer?<br></p><p>print(widePtr.pointee) is undefined. It may execute just the way you expect. In practice, it may also be reordered with the assignments to narrowPtr. Our optimizer is designed to do that but by chance isn’t in this version of the compiler. In theory anything can happen.<br></p><p>The real danger of undefined behavior of course is that the program will behave as you expect without warning when you develop the code, and future versions of the compiler may change the behavior in unpredictable ways.<br></p><p>This API will make it easier to develop static diagnostics that catch undefined behavior and much easier to write a runtime sanitizer. Neither of those things exist yet. It might be easy to catch obvious cases like this, but the value of catching just the obvious cases is limited.<br></p><p>&gt;&gt; It affects the abstract state of the memory location, independent of the pointer variable used to access that memory. Binding memory returns a typed pointer for convenience and clarity, but there’s nothing special about that particular pointer value.<br>&gt; <br>&gt; If it were not returning a typed pointer, what would it actually do?<br></p><p>It would bind memory. Returning a typed pointer actually has nothing to do with its semantics.<br></p><p>That fact that it’s one of the only ways to get a typed pointer from a raw pointer forces the programmer to bind the memory’s type before performing typed access on the memory.<br></p><p>-Andy<br></p><p>&gt; <br>&gt; <br>&gt; Manfred<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8dfc6932943f38e7a7de48be3194f13c?s=50"></div><header><strong>What is &quot;binding&quot; memory?</strong> from <string>Michael Ilseman</string> &lt;milseman at apple.com&gt;<p>November  1, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Nov 1, 2016, at 11:55 AM, Manfred Schubert via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; The &quot;UnsafeRawPointer Migration&quot; guide talks about &quot;binding memory to a type“ as if that was a well known term. I have never heard of it yet though, and googling it returns no relevant results. I do not understand what binding memory is supposed to do.<br>&gt; <br>&gt; The migration guide says &quot;Binding uninitialized memory to a type prepares the memory to store values of that type“, but clearly raw memory does not need to be prepared (and cannot be) to hold any arbitrary type and value.<br>&gt; <br>&gt; So what is this for, what does it actually do, and to whom is it done (the raw pointer, or the typed pointer which is returned, or the raw memory)?<br>&gt; <br></p><p>This is more so a semantic distinction rather than some kind of physical operation. The memory is not altered, but all reads and writes to that memory location have to be through the “bound type”. If it’s “bound” to some type T, you must only read and write through values of type T, and not some unrelated type. This is in order to honor Swift&#39;s memory model while still exposing access to raw memory (see [1]), and to do so one must be careful about how they treat that memory so as to not violate “strict aliasing” (see [2]). This is similar to the notion of strict aliasing in C (see [3]). <br></p><p>[1] https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md#memory-model-explanation &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md#memory-model-explanation&gt;<br>[2] https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md#strict-aliasing<br>[3] http://blog.regehr.org/archives/1307<br></p><p><br>&gt; <br>&gt; Manfred<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161101/a04aef60/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a8c5aceede03294627b62ceb893670a6?s=50"></div><header><strong>What is &quot;binding&quot; memory?</strong> from <string>Manfred Schubert</string> &lt;dev at schubert-it.com&gt;<p>November  2, 2016 at 06:00:00pm</p></header><div class="content"><p>Am 01.11.2016 um 21:43 schrieb Michael Ilseman &lt;milseman at apple.com&gt;:<br>&gt; <br>&gt; This is more so a semantic distinction rather than some kind of physical operation. The memory is not altered, but all reads and writes to that memory location have to be through the “bound type”. If it’s “bound” to some type T, you must only read and write through values of type T, and not some unrelated type.<br></p><p>So is „binding memory to a type“ like declaring the intent to the compiler that this memory is accessed as a certain type?<br></p><p>&gt; [1] https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md#memory-model-explanation<br></p><p>Re-reading this, I guess I don’t even understand the need for memory being initialized and deinitialized. I understand that it is useful to have a defined initial value, but why is that a requirement for raw memory? If I receive raw memory from outside of Swift, would this already be „bound“ and „initialized“? Many raw data can be interpreted in multiple ways, so it cannot be bound to any particular type, but it is initialized with meaningful data already.<br>And what does deinitialize actually do? How could a row of Ints be deinitialized for example? Or is it zeroing the raw bytes of the memory?<br></p><p><br>Manfred<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>What is &quot;binding&quot; memory?</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>November  3, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Nov 2, 2016, at 10:32 AM, Manfred Schubert via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Am 01.11.2016 um 21:43 schrieb Michael Ilseman &lt;milseman at apple.com&gt;:<br>&gt;&gt; <br>&gt;&gt; This is more so a semantic distinction rather than some kind of physical operation. The memory is not altered, but all reads and writes to that memory location have to be through the “bound type”. If it’s “bound” to some type T, you must only read and write through values of type T, and not some unrelated type.<br>&gt; <br>&gt; So is „binding memory to a type“ like declaring the intent to the compiler that this memory is accessed as a certain type?<br></p><p>Yes.<br></p><p>&gt;&gt; [1] https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md#memory-model-explanation<br>&gt; <br>&gt; Re-reading this, I guess I don’t even understand the need for memory being initialized and deinitialized. I understand that it is useful to have a defined initial value, but why is that a requirement for raw memory?<br></p><p>Memory is initialized whenever it holds a value. Memory does not need an “initial” value, so I’m not sure I understand the question.<br></p><p>API’s for reading memory do require that the memory be initialized. After all, they claim to return a valid value.<br></p><p>Deferring initialization is convenient for some contiguous data structures, but generally dealing with uninitialized memory is expected to be rare. About the only things you can do with uninitialized memory are initialize it, deallocate it, or copy it with C memcpy.<br></p><p>&gt; If I receive raw memory from outside of Swift, would this already be „bound“ and „initialized“? Many raw data can be interpreted in multiple ways, so it cannot be bound to any particular type, but it is initialized with meaningful data already.<br></p><p>If a C interface returns a pointer to uninitialized memory (e.g. malloc), then Swift code cannot assume that memory is bound to any type.<br></p><p>If a C interface returns a pointer to initialized memory, then it will be returning a typed pointer and indicating the capacity. Swift code can safely assume the memory is bound to that type.<br></p><p>There is a subtle issue here. I’m reluctant to bring it up because it really isn’t the user’s job to understand. But since we’re on the topic… It’s theoretically possible for a C interface to return a pointer to the same memory as different, unrelated, types via different functions. This is valid in C because of language-specific rules regarding aliasing and layout of structs, but would not otherwise be valid in Swift. For this reason, the compiler will be more conservative about aliasing of imported C types. Again, it’s not something the user needs to worry about.<br></p><p>&gt; And what does deinitialize actually do? How could a row of Ints be deinitialized for example? Or is it zeroing the raw bytes of the memory?<br></p><p>By definition, deinitializing a value of trivial type, such as Int, does absolutely nothing other than semantically “mark” the memory as deinitialized (it’s a nop in the implementation).<br></p><p>Deinitializing nontrivial values decrements reference counts, runs deinitializers, and what not.<br></p><p>-Andy<br></p><p>&gt; Manfred<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
