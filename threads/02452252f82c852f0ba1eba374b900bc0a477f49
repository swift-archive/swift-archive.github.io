<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April  6, 2016 at 01:00:00pm</p></header><div class="content"><p>on Wed Apr 06 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Apr 6, 2016, at 12:43 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed Apr 06 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;    On Apr 6, 2016, at 12:16 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;    &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;    (0..&lt;199).striding(by: -2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    are even or odd.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (0..&lt;199).striding(by: -2): 0..&lt;199 == 0...198 Even<br>&gt;&gt;&gt; (1..&lt;199).striding(by: -2): 1..&lt;199 == 1...198 Even<br>&gt;&gt; <br>&gt;&gt; I understand the logic that got you there, but I find it incredibly<br>&gt;&gt; counter-intuitive that striding by 2s over a range with odd endpoints<br>&gt;&gt; should produce even numbers... I can&#39;t imagine any way I&#39;d be convinced<br>&gt;&gt; that was a good idea.<br>&gt;<br>&gt; Guidance:<br>&gt;<br>&gt; When using odd integer literals to produce an even number sequence,<br>&gt; prefer the `...` operator to the `..&lt;` operator and change your ending<br>&gt; literal to an even number.<br></p><p>I don&#39;t think you can fix counterintuitive behavior with guidance.  <br></p><p>(1..&lt;199).striding(by: -2) is the first way I&#39;d reach for to express<br>197, 195, ..., 3, 1<br></p><p>&gt;<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; (0..&lt;198).striding(by: -2): 1..&lt;198 == 0...197 Odd<br>&gt;&gt;&gt; (1..&lt;198).striding(by: -2): 1..&lt;198 == 1...197 Odd<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>April  6, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 06 Apr 2016, at 23:17, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I don&#39;t think you can fix counterintuitive behavior with guidance.  <br>&gt; <br>&gt; (1..&lt;199).striding(by: -2) is the first way I&#39;d reach for to express<br>&gt; 197, 195, ..., 3, 1<br></p><p>I think a sensible specification would be that with a positive step size, the count starts from the lower bound, and with a negative one, it starts from the upper bound (inclusive or exclusive). Thus, the following examples should cover all the corner cases:<br></p><p>    (0 ... 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>    (0 ..&lt; 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>    (0 &lt;.. 9).striding(by: 2) ==    [2, 4, 6, 8]<br>    (0 &lt;.&lt; 9).striding(by: 2) ==    [2, 4, 6, 8]<br></p><p>    (0 ... 9).striding(by: 3) == [0, 3, 6, 9]<br>    (0 ..&lt; 9).striding(by: 3) == [0, 3, 6]<br>    (0 &lt;.. 9).striding(by: 3) ==    [3, 6, 9]<br>    (0 &lt;.&lt; 9).striding(by: 3) ==    [3, 6]<br></p><p>    (0 ... 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>    (0 ..&lt; 9).striding(by: -2) ==    [7, 5, 3, 1]<br>    (0 &lt;.. 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>    (0 &lt;.&lt; 9).striding(by: -2) ==    [7, 5, 3, 1]<br></p><p>    (0 ... 9).striding(by: -3) == [9, 6, 3, 0]<br>    (0 ..&lt; 9).striding(by: -3) ==    [6, 3, 0]<br>    (0 &lt;.. 9).striding(by: -3) == [9, 6, 3]<br>    (0 &lt;.&lt; 9).striding(by: -3) ==    [6, 3]<br></p><p>Lastly, if you want the positive stride reversed, you&#39;d do just that:<br></p><p>    (0 ... 9).striding(by: 2).reverse() == [8, 6, 4, 2, 0]<br></p><p>â€” Pyry<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/892a4411/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>April  6, 2016 at 08:00:00pm</p></header><div class="content"><p>On Wed, Apr 6, 2016 at 1:29 PM Pyry Jahkola via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 06 Apr 2016, at 23:17, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I don&#39;t think you can fix counterintuitive behavior with guidance.<br>&gt;<br>&gt; (1..&lt;199).striding(by: -2) is the first way I&#39;d reach for to express<br>&gt; 197, 195, ..., 3, 1<br>&gt;<br>&gt;<br>&gt; I think a sensible specification would be that with a positive step size,<br>&gt; the count starts from the lower bound, and with a negative one, it starts<br>&gt; from the upper bound (inclusive or exclusive). Thus, the following examples<br>&gt; should cover all the corner cases:<br>&gt;<br>&gt;     (0 ... 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>&gt;     (0 ..&lt; 9).striding(by: 2) == [0, 2, 4, 6, 8]<br>&gt;     (0 &lt;.. 9).striding(by: 2) ==    [2, 4, 6, 8]<br>&gt;     (0 &lt;.&lt; 9).striding(by: 2) ==    [2, 4, 6, 8]<br>&gt;<br>&gt;     (0 ... 9).striding(by: 3) == [0, 3, 6, 9]<br>&gt;     (0 ..&lt; 9).striding(by: 3) == [0, 3, 6]<br>&gt;     (0 &lt;.. 9).striding(by: 3) ==    [3, 6, 9]<br>&gt;     (0 &lt;.&lt; 9).striding(by: 3) ==    [3, 6]<br>&gt;<br>&gt;     (0 ... 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>&gt;     (0 ..&lt; 9).striding(by: -2) ==    [7, 5, 3, 1]<br>&gt;     (0 &lt;.. 9).striding(by: -2) == [9, 7, 5, 3, 1]<br>&gt;     (0 &lt;.&lt; 9).striding(by: -2) ==    [7, 5, 3, 1]<br>&gt;<br>&gt;     (0 ... 9).striding(by: -3) == [9, 6, 3, 0]<br>&gt;     (0 ..&lt; 9).striding(by: -3) ==    [6, 3, 0]<br>&gt;     (0 &lt;.. 9).striding(by: -3) == [9, 6, 3]<br>&gt;     (0 &lt;.&lt; 9).striding(by: -3) ==    [6, 3]<br>&gt;<br>&gt; Lastly, if you want the positive stride reversed, you&#39;d do just that:<br>&gt;<br>&gt;     (0 ... 9).striding(by: 2).reverse() == [8, 6, 4, 2, 0]<br>&gt;<br></p><p>I have always desired for a complete set of range variants like you<br>outlined above. I don&#39;t have current examples warranting a complete set but<br>I could easily see having to work on a data set that may be best done by<br>having a complete set of range variants so you don&#39;t need to transform the<br>data set to get it to work with the language you happen to be using. It<br>also better supports floating point ranges which may not have easy ways to<br>transform the data.<br></p><p>I also like the suggestion of how striding and reverse should work.<br></p><p>-Shawn<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/2f9bcef4/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  6, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 2:17 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Guidance:<br>&gt;&gt; <br>&gt;&gt; When using odd integer literals to produce an even number sequence,<br>&gt;&gt; prefer the `...` operator to the `..&lt;` operator and change your ending<br>&gt;&gt; literal to an even number.<br>&gt; <br>&gt; I don&#39;t think you can fix counterintuitive behavior with guidance.  <br>&gt; <br>&gt; (1..&lt;199).striding(by: -2) is the first way I&#39;d reach for to express<br>&gt; 197, 195, ..., 3, 1<br></p><p>Yes, but you can with warnings and fixits. <br></p><p>* The compiler should issue a warning for any use of <br></p><p>(n..&lt;m).striding(by: v | v &lt; 0) | n, m, v : Integer<br></p><p>with a fixit of &quot;replace  (n..&lt;m) with (n...m - 1)&quot; regardless of<br>whether n or m is known at compile time <br></p><p>* If v cannot be known at compile time, I think the compiler should<br>always prefer ... to ..&lt;.<br></p><p>* The compiler should not allow<br></p><p>(n..&lt;m).striding(by: v | v &lt; 0) | n, m, v: floating point types<br></p><p>where v is known at compile time to be a negative constant. There should <br>also be a runtime precondition that raises a fatal error should a negative <br>v be used with a half-open interval.<br></p><p>-- E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/118b4fd8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  6, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 2:35 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yes, but you can with warnings and fixits. <br>&gt; <br>&gt; * The compiler should issue a warning for any use of <br>&gt; <br>&gt; (n..&lt;m).striding(by: v | v &lt; 0) | n, m, v : Integer<br>&gt; <br>&gt; with a fixit of &quot;replace  (n..&lt;m) with (n...m - 1)&quot; regardless of<br>&gt; whether n or m is known at compile time <br>&gt; <br>&gt; * If v cannot be known at compile time, I think the compiler should<br>&gt; always prefer ... to ..&lt;.<br>&gt; <br>&gt; * The compiler should not allow<br>&gt; <br>&gt; (n..&lt;m).striding(by: v | v &lt; 0) | n, m, v: floating point types<br>&gt; <br>&gt; where v is known at compile time to be a negative constant. There should <br>&gt; also be a runtime precondition that raises a fatal error should a negative <br>&gt; v be used with a half-open interval.<br>&gt; <br>&gt; -- E<br></p><p>Following up to myself, this can easily be expanded to the other cases just<br>brought up by Xiaodi Wu<br></p><p>-- E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/87d1bddc/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
