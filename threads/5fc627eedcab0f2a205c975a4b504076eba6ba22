<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Shouldn&#39;t the optimizer make this manual loop-unrolling unnecessary?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>December 11, 2015 at 08:00:00am</p></header><div class="content"><p>I&#39;ve been doing a lot of performance testing related to generic value types<br>and SIMD lately, and I&#39;ve built Swift from sources in order to get an idea<br>of what&#39;s coming up optimizerwise. Things have improved and the optimizer<br>is impressive overall. But I still see no improvement in the case<br>exemplified below.<br></p><p>Manually unrolling the simple for loop will make it ~ 4 times faster (and<br>exactly the same as when SIMD float4):<br></p><p>struct V4&lt;T&gt; {<br>    var elements: (T, T, T, T)<br>    /.../<br>    subscript(index: Int) -&gt; T { /.../ }<br>    /.../<br>    func addedTo(other: V4) -&gt; V4 {<br>        var r = V4()<br>        // Manually unrolling makes code ~ 4 times faster:<br>        // for i in 0 ..&lt; 4 { r[i] = self[i] + other[i] }<br>        r[0] = self[0] + other[0]<br>        r[1] = self[1] + other[1]<br>        r[2] = self[2] + other[2]<br>        r[3] = self[3] + other[3]<br>        return r<br>    }<br>    /.../<br>}<br></p><p>Shouldn&#39;t the optimizer be able to handle that for loop and make the manual<br>unrolling unnecessary?<br></p><p>(compiled the test with -O -whole-module-optimizations, also tried<br>-Ounchecked but with same results.)<br></p><p>/Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151211/5fc6ba22/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Shouldn&#39;t the optimizer make this manual loop-unrolling unnecessary?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>December 11, 2015 at 03:00:00pm</p></header><div class="content"><p>Correction: The test I&#39;m running is actually using V4&lt;V4&lt;Float&gt;&gt;.<br>Manually unrolling the loop makes adding V4&lt;V4&lt;Float&gt;&gt; as fast as adding<br>SIMD float4x4.<br>Using the (un-unrolled) for loop will be about 4 times slower.<br>My question is still: Shouldn&#39;t the optimizer be able to handle that for<br>loop / make my manual unrolling unnecessary?<br>/Jens<br></p><p>On Fri, Dec 11, 2015 at 8:28 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br></p><p>&gt; I&#39;ve been doing a lot of performance testing related to generic value<br>&gt; types and SIMD lately, and I&#39;ve built Swift from sources in order to get an<br>&gt; idea of what&#39;s coming up optimizerwise. Things have improved and the<br>&gt; optimizer is impressive overall. But I still see no improvement in the case<br>&gt; exemplified below.<br>&gt;<br>&gt; Manually unrolling the simple for loop will make it ~ 4 times faster (and<br>&gt; exactly the same as when SIMD float4):<br>&gt;<br>&gt; struct V4&lt;T&gt; {<br>&gt;     var elements: (T, T, T, T)<br>&gt;     /.../<br>&gt;     subscript(index: Int) -&gt; T { /.../ }<br>&gt;     /.../<br>&gt;     func addedTo(other: V4) -&gt; V4 {<br>&gt;         var r = V4()<br>&gt;         // Manually unrolling makes code ~ 4 times faster:<br>&gt;         // for i in 0 ..&lt; 4 { r[i] = self[i] + other[i] }<br>&gt;         r[0] = self[0] + other[0]<br>&gt;         r[1] = self[1] + other[1]<br>&gt;         r[2] = self[2] + other[2]<br>&gt;         r[3] = self[3] + other[3]<br>&gt;         return r<br>&gt;     }<br>&gt;     /.../<br>&gt; }<br>&gt;<br>&gt; Shouldn&#39;t the optimizer be able to handle that for loop and make the<br>&gt; manual unrolling unnecessary?<br>&gt;<br>&gt; (compiled the test with -O -whole-module-optimizations, also tried<br>&gt; -Ounchecked but with same results.)<br>&gt;<br>&gt; /Jens<br>&gt;<br>&gt;<br></p><p><br>-- <br>bitCycle AB | Smedjegatan 12 | 742 32 Ã–sthammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151211/6f33523f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8e77369a540cf4d35924683e176c7a9c?s=50"></div><header><strong>Shouldn&#39;t the optimizer make this manual loop-unrolling unnecessary?</strong> from <string>Mark Lacey</string> &lt;mark.lacey at apple.com&gt;<p>December 11, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 6:05 AM, Jens Persson via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Correction: The test I&#39;m running is actually using V4&lt;V4&lt;Float&gt;&gt;.<br>&gt; Manually unrolling the loop makes adding V4&lt;V4&lt;Float&gt;&gt; as fast as adding SIMD float4x4.<br>&gt; Using the (un-unrolled) for loop will be about 4 times slower.<br>&gt; My question is still: Shouldn&#39;t the optimizer be able to handle that for loop / make my manual unrolling unnecessary?<br>&gt; /Jens<br>&gt; <br>&gt; On Fri, Dec 11, 2015 at 8:28 AM, Jens Persson &lt;jens at bitcycle.com &lt;mailto:jens at bitcycle.com&gt;&gt; wrote:<br>&gt; I&#39;ve been doing a lot of performance testing related to generic value types and SIMD lately, and I&#39;ve built Swift from sources in order to get an idea of what&#39;s coming up optimizerwise. Things have improved and the optimizer is impressive overall. But I still see no improvement in the case exemplified below.<br>&gt; <br>&gt; Manually unrolling the simple for loop will make it ~ 4 times faster (and exactly the same as when SIMD float4):<br>&gt; <br>&gt; struct V4&lt;T&gt; {<br>&gt;     var elements: (T, T, T, T)<br>&gt;     /.../<br>&gt;     subscript(index: Int) -&gt; T { /.../ }<br>&gt;     /.../<br>&gt;     func addedTo(other: V4) -&gt; V4 {<br>&gt;         var r = V4()<br>&gt;         // Manually unrolling makes code ~ 4 times faster:<br>&gt;         // for i in 0 ..&lt; 4 { r[i] = self[i] + other[i] }<br>&gt;         r[0] = self[0] + other[0]<br>&gt;         r[1] = self[1] + other[1]<br>&gt;         r[2] = self[2] + other[2]<br>&gt;         r[3] = self[3] + other[3]<br>&gt;         return r<br>&gt;     }<br>&gt;     /.../<br>&gt; }<br>&gt; <br>&gt; Shouldn&#39;t the optimizer be able to handle that for loop and make the manual unrolling unnecessary?<br></p><p>In theory, yes. In practice there are some fairly complex phase ordering issues in the SIL optimizer, and certain optimizations (like general loop unrolling) that are only done in the LLVM optimizer. The LLVM optimizer runs after all the SIL-level optimizations, which may mean that SIL-level optimization opportunities are exposed by the LLVM optimizer but by then it is too late to do anything about them.<br></p><p>&gt; (compiled the test with -O -whole-module-optimizations, also tried -Ounchecked but with same results.)<br></p><p>Would you mind opening an issue on https://bugs.swift.org &lt;https://bugs.swift.org/&gt; will a small stand-alone test case that compiles successfully, and report your results there?<br></p><p>Mark<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151211/f3f3c4b8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Shouldn&#39;t the optimizer make this manual loop-unrolling unnecessary?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>December 12, 2015 at 03:00:00pm</p></header><div class="content"><p>Thank you. I&#39;ve filed:<br>https://bugs.swift.org/browse/SR-203<br></p><p>On Fri, Dec 11, 2015 at 7:04 PM, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 11, 2015, at 6:05 AM, Jens Persson via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt;<br>&gt; Correction: The test I&#39;m running is actually using V4&lt;V4&lt;Float&gt;&gt;.<br>&gt; Manually unrolling the loop makes adding V4&lt;V4&lt;Float&gt;&gt; as fast as adding<br>&gt; SIMD float4x4.<br>&gt; Using the (un-unrolled) for loop will be about 4 times slower.<br>&gt; My question is still: Shouldn&#39;t the optimizer be able to handle that for<br>&gt; loop / make my manual unrolling unnecessary?<br>&gt; /Jens<br>&gt;<br>&gt; On Fri, Dec 11, 2015 at 8:28 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;<br>&gt;&gt; I&#39;ve been doing a lot of performance testing related to generic value<br>&gt;&gt; types and SIMD lately, and I&#39;ve built Swift from sources in order to get an<br>&gt;&gt; idea of what&#39;s coming up optimizerwise. Things have improved and the<br>&gt;&gt; optimizer is impressive overall. But I still see no improvement in the case<br>&gt;&gt; exemplified below.<br>&gt;&gt;<br>&gt;&gt; Manually unrolling the simple for loop will make it ~ 4 times faster (and<br>&gt;&gt; exactly the same as when SIMD float4):<br>&gt;&gt;<br>&gt;&gt; struct V4&lt;T&gt; {<br>&gt;&gt;     var elements: (T, T, T, T)<br>&gt;&gt;     /.../<br>&gt;&gt;     subscript(index: Int) -&gt; T { /.../ }<br>&gt;&gt;     /.../<br>&gt;&gt;     func addedTo(other: V4) -&gt; V4 {<br>&gt;&gt;         var r = V4()<br>&gt;&gt;         // Manually unrolling makes code ~ 4 times faster:<br>&gt;&gt;         // for i in 0 ..&lt; 4 { r[i] = self[i] + other[i] }<br>&gt;&gt;         r[0] = self[0] + other[0]<br>&gt;&gt;         r[1] = self[1] + other[1]<br>&gt;&gt;         r[2] = self[2] + other[2]<br>&gt;&gt;         r[3] = self[3] + other[3]<br>&gt;&gt;         return r<br>&gt;&gt;     }<br>&gt;&gt;     /.../<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Shouldn&#39;t the optimizer be able to handle that for loop and make the<br>&gt;&gt; manual unrolling unnecessary?<br>&gt;&gt;<br>&gt;<br>&gt; In theory, yes. In practice there are some fairly complex phase ordering<br>&gt; issues in the SIL optimizer, and certain optimizations (like general loop<br>&gt; unrolling) that are only done in the LLVM optimizer. The LLVM optimizer<br>&gt; runs after all the SIL-level optimizations, which may mean that SIL-level<br>&gt; optimization opportunities are exposed by the LLVM optimizer but by then it<br>&gt; is too late to do anything about them.<br>&gt;<br>&gt; (compiled the test with -O -whole-module-optimizations, also tried<br>&gt;&gt; -Ounchecked but with same results.)<br>&gt;&gt;<br>&gt;<br>&gt; Would you mind opening an issue on https://bugs.swift.org will a small<br>&gt; stand-alone test case that compiles successfully, and report your results<br>&gt; there?<br>&gt;<br>&gt; Mark<br>&gt;<br>&gt;<br></p><p><br>-- <br>bitCycle AB | Smedjegatan 12 | 742 32 Ã–sthammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151212/0cb7274e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
