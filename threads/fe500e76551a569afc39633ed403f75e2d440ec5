<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Allow @objc(name) on enum declarations</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  9, 2015 at 03:00:00pm</p></header><div class="content"><p>Swift allows for placing @objc on an enum that has an Int raw type in order to expose it to Obj-C. But it doesn&#39;t currently let you rename the enum when exposing it to Obj-C. This is particularly problematic when exposing a Swift enum that&#39;s nested in a struct/class, as the nesting resolves ambiguity in Swift but is not present in Obj-C.<br></p><p>Example:<br></p><p>import Foundation<br></p><p>class Foo: NSObject {<br>    @objc enum Bar: Int {<br>        case One, Two<br>    }<br>}<br></p><p>This generates the following:<br></p><p>SWIFT_CLASS(&quot;_TtC7unnamed3Foo&quot;)<br>@interface Foo : NSObject<br>- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;<br>@end<br></p><p>typedef SWIFT_ENUM(NSInteger, Bar) {<br>  BarOne = 0,<br>  BarTwo = 1,<br>};<br></p><p>I&#39;d like to resolve this by saying @objc(FooBar) but that emits an error.<br></p><p>I&#39;m also going to submit a separate proposal saying we should change the default naming here so the enum is named FooBar, but these two proposals go hand-in-hand (there are cases where you might want to rename a root-level enum, to add a prefix for disambiguation in Obj-C, or you may want to selectively opt out of the proposed renaming rules by forcing your nested enum to use just its name in Obj-C).<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: Allow @objc(name) on enum declarations</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December  9, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 15:18, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Swift allows for placing @objc on an enum that has an Int raw type in order to expose it to Obj-C. But it doesn&#39;t currently let you rename the enum when exposing it to Obj-C. This is particularly problematic when exposing a Swift enum that&#39;s nested in a struct/class, as the nesting resolves ambiguity in Swift but is not present in Obj-C.<br>&gt; <br>&gt; Example:<br>&gt; <br>&gt; import Foundation<br>&gt; <br>&gt; class Foo: NSObject {<br>&gt;    @objc enum Bar: Int {<br>&gt;        case One, Two<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; This generates the following:<br>&gt; <br>&gt; SWIFT_CLASS(&quot;_TtC7unnamed3Foo&quot;)<br>&gt; @interface Foo : NSObject<br>&gt; - (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;<br>&gt; @end<br>&gt; <br>&gt; typedef SWIFT_ENUM(NSInteger, Bar) {<br>&gt;  BarOne = 0,<br>&gt;  BarTwo = 1,<br>&gt; };<br>&gt; <br>&gt; I&#39;d like to resolve this by saying @objc(FooBar) but that emits an error.<br>&gt; <br>&gt; I&#39;m also going to submit a separate proposal saying we should change the default naming here so the enum is named FooBar, but these two proposals go hand-in-hand (there are cases where you might want to rename a root-level enum, to add a prefix for disambiguation in Obj-C, or you may want to selectively opt out of the proposed renaming rules by forcing your nested enum to use just its name in Obj-C).<br></p><p>+1 to being able to rename @objc enums. I&#39;m a little surprised we even allow exposing nested types to Objective-C, and am not at all sure the printer is set up to handle that correctly, but the renaming is independently useful.<br></p><p>Jordan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Allow @objc(name) on enum declarations</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  9, 2015 at 10:00:00pm</p></header><div class="content"><p>Does it make sense to put @objc(name) on enum cases? Such as<br></p><p>@objc enum Foo: Int {<br>    @objc(kFooOne) case One<br>    @objc(kFooTwo) case Two<br>}<br></p><p>The only real problem here is what do we do if you say<br></p><p>@objc(kFooOne) case One, Two<br></p><p>Either we just apply it to the One variant and ignore the Two variant, possibly with a warning, or we emit an error.<br></p><p>-Kevin<br></p><p>On Wed, Dec 9, 2015, at 06:01 PM, Jordan Rose wrote:<br>&gt; <br>&gt; &gt; On Dec 9, 2015, at 15:18, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; Swift allows for placing @objc on an enum that has an Int raw type in order to expose it to Obj-C. But it doesn&#39;t currently let you rename the enum when exposing it to Obj-C. This is particularly problematic when exposing a Swift enum that&#39;s nested in a struct/class, as the nesting resolves ambiguity in Swift but is not present in Obj-C.<br>&gt; &gt; <br>&gt; &gt; Example:<br>&gt; &gt; <br>&gt; &gt; import Foundation<br>&gt; &gt; <br>&gt; &gt; class Foo: NSObject {<br>&gt; &gt;    @objc enum Bar: Int {<br>&gt; &gt;        case One, Two<br>&gt; &gt;    }<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; This generates the following:<br>&gt; &gt; <br>&gt; &gt; SWIFT_CLASS(&quot;_TtC7unnamed3Foo&quot;)<br>&gt; &gt; @interface Foo : NSObject<br>&gt; &gt; - (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;<br>&gt; &gt; @end<br>&gt; &gt; <br>&gt; &gt; typedef SWIFT_ENUM(NSInteger, Bar) {<br>&gt; &gt;  BarOne = 0,<br>&gt; &gt;  BarTwo = 1,<br>&gt; &gt; };<br>&gt; &gt; <br>&gt; &gt; I&#39;d like to resolve this by saying @objc(FooBar) but that emits an error.<br>&gt; &gt; <br>&gt; &gt; I&#39;m also going to submit a separate proposal saying we should change the default naming here so the enum is named FooBar, but these two proposals go hand-in-hand (there are cases where you might want to rename a root-level enum, to add a prefix for disambiguation in Obj-C, or you may want to selectively opt out of the proposed renaming rules by forcing your nested enum to use just its name in Obj-C).<br>&gt; <br>&gt; +1 to being able to rename @objc enums. I&#39;m a little surprised we even allow exposing nested types to Objective-C, and am not at all sure the printer is set up to handle that correctly, but the renaming is independently useful.<br>&gt; <br>&gt; Jordan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8ae34e6aaf28c0e1fe929f36897d107e?s=50"></div><header><strong>Proposal: Allow @objc(name) on enum declarations</strong> from <string>Harlan Haskins</string> &lt;harlan at harlanhaskins.com&gt;<p>December 10, 2015 at 10:00:00am</p></header><div class="content"><p>An error seems reasonable here.<br></p><p>Error: Ambiguous Objective-C case name for ‘.Two’.<br></p><p>And then the Fix-It is just to put the second case on a new line and provide the @objc(&lt;#name#&gt;) completion.<br></p><p>&gt; On Dec 10, 2015, at 1:56 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Does it make sense to put @objc(name) on enum cases? Such as<br>&gt; <br>&gt; @objc enum Foo: Int {<br>&gt;    @objc(kFooOne) case One<br>&gt;    @objc(kFooTwo) case Two<br>&gt; }<br>&gt; <br>&gt; The only real problem here is what do we do if you say<br>&gt; <br>&gt; @objc(kFooOne) case One, Two<br>&gt; <br>&gt; Either we just apply it to the One variant and ignore the Two variant, possibly with a warning, or we emit an error.<br>&gt; <br>&gt; -Kevin<br>&gt; <br>&gt; On Wed, Dec 9, 2015, at 06:01 PM, Jordan Rose wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 9, 2015, at 15:18, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift allows for placing @objc on an enum that has an Int raw type in order to expose it to Obj-C. But it doesn&#39;t currently let you rename the enum when exposing it to Obj-C. This is particularly problematic when exposing a Swift enum that&#39;s nested in a struct/class, as the nesting resolves ambiguity in Swift but is not present in Obj-C.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; import Foundation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Foo: NSObject {<br>&gt;&gt;&gt;   @objc enum Bar: Int {<br>&gt;&gt;&gt;       case One, Two<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This generates the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; SWIFT_CLASS(&quot;_TtC7unnamed3Foo&quot;)<br>&gt;&gt;&gt; @interface Foo : NSObject<br>&gt;&gt;&gt; - (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;<br>&gt;&gt;&gt; @end<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; typedef SWIFT_ENUM(NSInteger, Bar) {<br>&gt;&gt;&gt; BarOne = 0,<br>&gt;&gt;&gt; BarTwo = 1,<br>&gt;&gt;&gt; };<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like to resolve this by saying @objc(FooBar) but that emits an error.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m also going to submit a separate proposal saying we should change the default naming here so the enum is named FooBar, but these two proposals go hand-in-hand (there are cases where you might want to rename a root-level enum, to add a prefix for disambiguation in Obj-C, or you may want to selectively opt out of the proposed renaming rules by forcing your nested enum to use just its name in Obj-C).<br>&gt;&gt; <br>&gt;&gt; +1 to being able to rename @objc enums. I&#39;m a little surprised we even allow exposing nested types to Objective-C, and am not at all sure the printer is set up to handle that correctly, but the renaming is independently useful.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/4aa9ac82/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Allow @objc(name) on enum declarations</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 10, 2015 at 11:00:00am</p></header><div class="content"><p>Do we have any attributes that are valid on enum cases today? If so, how<br>do they handle this scenario?<br></p><p>I&#39;m inclined to agree with you that it should be an error. It&#39;s<br>reasonable to assume that an attribute on the declaration applies to all<br>cases in the declaration, which is fine for most attributes, it just<br>doesn&#39;t work for @objc(name) because it produces a name collision.<br></p><p>I suspect the simplest approach here is to just figure out what the<br>error message will be if you say<br></p><p>@objc(Foo) case Foo @objc(Foo) case Bar<br></p><p>and use the same error if you say<br></p><p>@objc(Foo) case Foo, Bar<br></p><p>-Kevin Ballard<br></p><p>On Thu, Dec 10, 2015, at 07:22 AM, Harlan Haskins wrote:<br>&gt; An error seems reasonable here.<br>&gt;<br>&gt; Error: Ambiguous Objective-C case name for ‘.Two’.<br>&gt;<br>&gt; And then the Fix-It is just to put the second case on a new line and<br>&gt; provide the @objc(&lt;#name#&gt;) completion.<br>&gt;<br>&gt;&gt; On Dec 10, 2015, at 1:56 AM, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Does it make sense to put @objc(name) on enum cases? Such as<br>&gt;&gt;<br>&gt;&gt; @objc enum Foo: Int {    @objc(kFooOne) case One    @objc(kFooTwo)<br>&gt;&gt; case Two }<br>&gt;&gt;<br>&gt;&gt; The only real problem here is what do we do if you say<br>&gt;&gt;<br>&gt;&gt; @objc(kFooOne) case One, Two<br>&gt;&gt;<br>&gt;&gt; Either we just apply it to the One variant and ignore the Two<br>&gt;&gt; variant, possibly with a warning, or we emit an error.<br>&gt;&gt;<br>&gt;&gt; -Kevin<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 9, 2015, at 06:01 PM, Jordan Rose wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Dec 9, 2015, at 15:18, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Swift allows for placing @objc on an enum that has an Int raw type<br>&gt;&gt;&gt;&gt; in order to expose it to Obj-C. But it doesn&#39;t currently let you<br>&gt;&gt;&gt;&gt; rename the enum when exposing it to Obj-C. This is particularly<br>&gt;&gt;&gt;&gt; problematic when exposing a Swift enum that&#39;s nested in a<br>&gt;&gt;&gt;&gt; struct/class, as the nesting resolves ambiguity in Swift but is not<br>&gt;&gt;&gt;&gt; present in Obj-C.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Example:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; import Foundation<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; class Foo: NSObject {   @objc enum Bar: Int {       case One,<br>&gt;&gt;&gt;&gt; Two   } }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This generates the following:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; SWIFT_CLASS(&quot;_TtC7unnamed3Foo&quot;) @interface Foo : NSObject<br>&gt;&gt;&gt;&gt; - (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER; @end<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; typedef SWIFT_ENUM(NSInteger, Bar) { BarOne = 0, BarTwo = 1, };<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I&#39;d like to resolve this by saying @objc(FooBar) but that emits an<br>&gt;&gt;&gt;&gt; error.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I&#39;m also going to submit a separate proposal saying we should<br>&gt;&gt;&gt;&gt; change the default naming here so the enum is named FooBar, but<br>&gt;&gt;&gt;&gt; these two proposals go hand-in-hand (there are cases where you<br>&gt;&gt;&gt;&gt; might want to rename a root-level enum, to add a prefix for<br>&gt;&gt;&gt;&gt; disambiguation in Obj-C, or you may want to selectively opt out of<br>&gt;&gt;&gt;&gt; the proposed renaming rules by forcing your nested enum to use just<br>&gt;&gt;&gt;&gt; its name in Obj-C).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; +1 to being able to rename @objc enums. I&#39;m a little surprised we<br>&gt;&gt;&gt; even allow exposing nested types to Objective-C, and am not at all<br>&gt;&gt;&gt; sure the printer is set up to handle that correctly, but the<br>&gt;&gt;&gt; renaming is independently useful.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jordan<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/fe7e5211/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: Allow @objc(name) on enum declarations</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 10, 2015 at 05:00:00pm</p></header><div class="content"><p>I don&#39;t think we have any enum case attributes, but we do allow @objc on properties:<br></p><p>import Foundation<br></p><p>class Test : NSObject {<br>  @objc(foo) var foo, bar : Int<br>}<br></p><p>…it looks like it ends up applying to both of them, and then erroring that you get two of the same (via the selector conflict diagnostics). We can probably make this more principled (both for cases and in general).<br></p><p>Jordan<br></p><p><br>&gt; On Dec 10, 2015, at 11:30, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; Do we have any attributes that are valid on enum cases today? If so, how do they handle this scenario?<br>&gt;  <br>&gt; I&#39;m inclined to agree with you that it should be an error. It&#39;s reasonable to assume that an attribute on the declaration applies to all cases in the declaration, which is fine for most attributes, it just doesn&#39;t work for @objc(name) because it produces a name collision.<br>&gt;  <br>&gt; I suspect the simplest approach here is to just figure out what the error message will be if you say<br>&gt;  <br>&gt; @objc(Foo) case Foo<br>&gt; @objc(Foo) case Bar<br>&gt;  <br>&gt; and use the same error if you say<br>&gt;  <br>&gt; @objc(Foo) case Foo, Bar<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; On Thu, Dec 10, 2015, at 07:22 AM, Harlan Haskins wrote:<br>&gt;&gt; An error seems reasonable here.<br>&gt;&gt;  <br>&gt;&gt; Error: Ambiguous Objective-C case name for ‘.Two’.<br>&gt;&gt;  <br>&gt;&gt; And then the Fix-It is just to put the second case on a new line and provide the @objc(&lt;#name#&gt;) completion.<br>&gt;&gt;  <br>&gt;&gt;&gt; On Dec 10, 2015, at 1:56 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Does it make sense to put @objc(name) on enum cases? Such as<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; @objc enum Foo: Int {<br>&gt;&gt;&gt;    @objc(kFooOne) case One<br>&gt;&gt;&gt;    @objc(kFooTwo) case Two<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; The only real problem here is what do we do if you say<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; @objc(kFooOne) case One, Two<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Either we just apply it to the One variant and ignore the Two variant, possibly with a warning, or we emit an error.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; -Kevin<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; On Wed, Dec 9, 2015, at 06:01 PM, Jordan Rose wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On Dec 9, 2015, at 15:18, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Swift allows for placing @objc on an enum that has an Int raw type in order to expose it to Obj-C. But it doesn&#39;t currently let you rename the enum when exposing it to Obj-C. This is particularly problematic when exposing a Swift enum that&#39;s nested in a struct/class, as the nesting resolves ambiguity in Swift but is not present in Obj-C.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Example:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; import Foundation<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; class Foo: NSObject {<br>&gt;&gt;&gt;&gt;&gt;   @objc enum Bar: Int {<br>&gt;&gt;&gt;&gt;&gt;       case One, Two<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; This generates the following:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; SWIFT_CLASS(&quot;_TtC7unnamed3Foo&quot;)<br>&gt;&gt;&gt;&gt;&gt; @interface Foo : NSObject<br>&gt;&gt;&gt;&gt;&gt; - (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;<br>&gt;&gt;&gt;&gt;&gt; @end<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; typedef SWIFT_ENUM(NSInteger, Bar) {<br>&gt;&gt;&gt;&gt;&gt; BarOne = 0,<br>&gt;&gt;&gt;&gt;&gt; BarTwo = 1,<br>&gt;&gt;&gt;&gt;&gt; };<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; I&#39;d like to resolve this by saying @objc(FooBar) but that emits an error.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; I&#39;m also going to submit a separate proposal saying we should change the default naming here so the enum is named FooBar, but these two proposals go hand-in-hand (there are cases where you might want to rename a root-level enum, to add a prefix for disambiguation in Obj-C, or you may want to selectively opt out of the proposed renaming rules by forcing your nested enum to use just its name in Obj-C).<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; +1 to being able to rename @objc enums. I&#39;m a little surprised we even allow exposing nested types to Objective-C, and am not at all sure the printer is set up to handle that correctly, but the renaming is independently useful.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/01010c53/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Allow @objc(name) on enum declarations</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 10, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 3:18 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Swift allows for placing @objc on an enum that has an Int raw type in order to expose it to Obj-C. But it doesn&#39;t currently let you rename the enum when exposing it to Obj-C. This is particularly problematic when exposing a Swift enum that&#39;s nested in a struct/class, as the nesting resolves ambiguity in Swift but is not present in Obj-C.<br></p><p>+1 to this idea.<br></p><p>-Chris<br></p><p><br>&gt; <br>&gt; Example:<br>&gt; <br>&gt; import Foundation<br>&gt; <br>&gt; class Foo: NSObject {<br>&gt;    @objc enum Bar: Int {<br>&gt;        case One, Two<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; This generates the following:<br>&gt; <br>&gt; SWIFT_CLASS(&quot;_TtC7unnamed3Foo&quot;)<br>&gt; @interface Foo : NSObject<br>&gt; - (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;<br>&gt; @end<br>&gt; <br>&gt; typedef SWIFT_ENUM(NSInteger, Bar) {<br>&gt;  BarOne = 0,<br>&gt;  BarTwo = 1,<br>&gt; };<br>&gt; <br>&gt; I&#39;d like to resolve this by saying @objc(FooBar) but that emits an error.<br>&gt; <br>&gt; I&#39;m also going to submit a separate proposal saying we should change the default naming here so the enum is named FooBar, but these two proposals go hand-in-hand (there are cases where you might want to rename a root-level enum, to add a prefix for disambiguation in Obj-C, or you may want to selectively opt out of the proposed renaming rules by forcing your nested enum to use just its name in Obj-C).<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Allow @objc(name) on enum declarations</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 11, 2015 at 01:00:00pm</p></header><div class="content"><p>I&#39;ve now submitted this proposal as a PR: https://github.com/apple/swift-evolution/pull/50<br></p><p>I listed one open question:<br></p><p>Should the generated Obj-C declarations use the swift_name attribute to indicate the Swift type it came from? Proposal SE-0005 generalizes swift_name to apply to any arbitrary C or Obj-C entity, so it will be legal to put on enums.<br></p><p>Labelling it makes it clear to the reader what the Swift equivalent is, but I&#39;m unsure if there&#39;s any downsides to doing this.<br></p><p>-Kevin Ballard<br></p><p>On Thu, Dec 10, 2015, at 09:45 PM, Chris Lattner wrote:<br>&gt; <br>&gt; &gt; On Dec 9, 2015, at 3:18 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; Swift allows for placing @objc on an enum that has an Int raw type in order to expose it to Obj-C. But it doesn&#39;t currently let you rename the enum when exposing it to Obj-C. This is particularly problematic when exposing a Swift enum that&#39;s nested in a struct/class, as the nesting resolves ambiguity in Swift but is not present in Obj-C.<br>&gt; <br>&gt; +1 to this idea.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; &gt; <br>&gt; &gt; Example:<br>&gt; &gt; <br>&gt; &gt; import Foundation<br>&gt; &gt; <br>&gt; &gt; class Foo: NSObject {<br>&gt; &gt;    @objc enum Bar: Int {<br>&gt; &gt;        case One, Two<br>&gt; &gt;    }<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; This generates the following:<br>&gt; &gt; <br>&gt; &gt; SWIFT_CLASS(&quot;_TtC7unnamed3Foo&quot;)<br>&gt; &gt; @interface Foo : NSObject<br>&gt; &gt; - (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;<br>&gt; &gt; @end<br>&gt; &gt; <br>&gt; &gt; typedef SWIFT_ENUM(NSInteger, Bar) {<br>&gt; &gt;  BarOne = 0,<br>&gt; &gt;  BarTwo = 1,<br>&gt; &gt; };<br>&gt; &gt; <br>&gt; &gt; I&#39;d like to resolve this by saying @objc(FooBar) but that emits an error.<br>&gt; &gt; <br>&gt; &gt; I&#39;m also going to submit a separate proposal saying we should change the default naming here so the enum is named FooBar, but these two proposals go hand-in-hand (there are cases where you might want to rename a root-level enum, to add a prefix for disambiguation in Obj-C, or you may want to selectively opt out of the proposed renaming rules by forcing your nested enum to use just its name in Obj-C).<br>&gt; &gt; <br>&gt; &gt; -Kevin Ballard<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Proposal: Allow @objc(name) on enum declarations</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 11, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 1:19 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve now submitted this proposal as a PR: https://github.com/apple/swift-evolution/pull/50 &lt;https://github.com/apple/swift-evolution/pull/50&gt;<br></p><p>Thanks for writing this up!<br></p><p>I was actually surprised that this didn’t already work; @objc is supposed to be able to rename effectively anything at this point. Given that, and that another core team member has already +1’d, we can skip the evolution process and call this a bug fix. Want to contribute a fix?<br></p><p>&gt; I listed one open question:<br>&gt; <br>&gt; Should the generated Obj-C declarations use the swift_name attribute to indicate the Swift type it came from? Proposal SE-0005 generalizes swift_name to apply to any arbitrary C or Obj-C entity, so it will be legal to put on enums.<br>&gt; <br>&gt; Labelling it makes it clear to the reader what the Swift equivalent is, but I&#39;m unsure if there&#39;s any downsides to doing this.<br></p><p>Yes, it makes sense to use the swift_name attribute here. If you’re implementing your proposal, check out lib/PrintAsObjC/PrintAsObjC.cpp and how we use the SWIFT_COMPILE_NAME macro for this in the generated header.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; On Thu, Dec 10, 2015, at 09:45 PM, Chris Lattner wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 9, 2015, at 3:18 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift allows for placing @objc on an enum that has an Int raw type in order to expose it to Obj-C. But it doesn&#39;t currently let you rename the enum when exposing it to Obj-C. This is particularly problematic when exposing a Swift enum that&#39;s nested in a struct/class, as the nesting resolves ambiguity in Swift but is not present in Obj-C.<br>&gt;&gt; <br>&gt;&gt; +1 to this idea.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; import Foundation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Foo: NSObject {<br>&gt;&gt;&gt;   @objc enum Bar: Int {<br>&gt;&gt;&gt;       case One, Two<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This generates the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; SWIFT_CLASS(&quot;_TtC7unnamed3Foo&quot;)<br>&gt;&gt;&gt; @interface Foo : NSObject<br>&gt;&gt;&gt; - (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;<br>&gt;&gt;&gt; @end<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; typedef SWIFT_ENUM(NSInteger, Bar) {<br>&gt;&gt;&gt; BarOne = 0,<br>&gt;&gt;&gt; BarTwo = 1,<br>&gt;&gt;&gt; };<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like to resolve this by saying @objc(FooBar) but that emits an error.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m also going to submit a separate proposal saying we should change the default naming here so the enum is named FooBar, but these two proposals go hand-in-hand (there are cases where you might want to rename a root-level enum, to add a prefix for disambiguation in Obj-C, or you may want to selectively opt out of the proposed renaming rules by forcing your nested enum to use just its name in Obj-C).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/036eab10/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Allow @objc(name) on enum declarations</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 11, 2015 at 09:00:00pm</p></header><div class="content"><p>On Fri, Dec 11, 2015, at 02:39 PM, Douglas Gregor wrote:<br>&gt;<br>&gt;&gt; On Dec 11, 2015, at 1:19 PM, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I&#39;ve now submitted this proposal as a PR:<br>&gt;&gt; https://github.com/apple/swift-evolution/pull/50<br>&gt;<br>&gt; Thanks for writing this up!<br>&gt;<br>&gt; I was actually surprised that this didn’t already work; @objc is<br>&gt; supposed to be able to rename effectively anything at this point.<br>&gt; Given that, and that another core team member has already +1’d, we<br>&gt; can skip the evolution process and call this a bug fix. Want to<br>&gt; contribute a fix?<br></p><p>I&#39;d love to! I&#39;ll start working on one over the weekend.<br></p><p>&gt;&gt; I listed one open question:<br>&gt;&gt;<br>&gt;&gt; Should the generated Obj-C declarations use the swift_name attribute<br>&gt;&gt; to indicate the Swift type it came from? Proposal SE-0005 generalizes<br>&gt;&gt; swift_name to apply to any arbitrary C or Obj-C entity, so it will be<br>&gt;&gt; legal to put on enums.<br>&gt;&gt;<br>&gt;&gt; Labelling it makes it clear to the reader what the Swift equivalent<br>&gt;&gt; is, but I&#39;m unsure if there&#39;s any downsides to doing this.<br>&gt;<br>&gt; Yes, it makes sense to use the swift_name attribute here. If you’re<br>&gt; implementing your proposal, check out<br>&gt; lib/PrintAsObjC/PrintAsObjC.cpp and how we use the<br>&gt; SWIFT_COMPILE_NAME macro for this in the generated header.<br></p><p>Will do. My worry with using swift_name is that, at least in the clang<br>that ships with Xcode 7.2, you can&#39;t actually put the swift_name<br>attribute on an enum. I assume that will change with SE-0005, but I also<br>assume this hasn&#39;t been implemented yet. And even when it is<br>implemented, emitting it will be a backwards-compatibility hazard if the<br>generated header needs to work with older clangs. Is there any way to<br>suppress the error?<br></p><p>I&#39;m also not sure offhand where you actually put the attribute on an<br>enum, since the enum definition is actually 2 declarations, one for the<br>typedef and one for the enum itself. Would it go after the `enum`<br>keyword, in the place where SWIFT_ENUM_EXTRA is?<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/139c9030/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Proposal: Allow @objc(name) on enum declarations</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 11, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 9:40 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Fri, Dec 11, 2015, at 02:39 PM, Douglas Gregor wrote:<br>&gt;&gt;  <br>&gt;&gt;&gt; On Dec 11, 2015, at 1:19 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I&#39;ve now submitted this proposal as a PR: https://github.com/apple/swift-evolution/pull/50 &lt;https://github.com/apple/swift-evolution/pull/50&gt;<br>&gt;&gt;  <br>&gt;&gt; Thanks for writing this up!<br>&gt;&gt;  <br>&gt;&gt; I was actually surprised that this didn’t already work; @objc is supposed to be able to rename effectively anything at this point. Given that, and that another core team member has already +1’d, we can skip the evolution process and call this a bug fix. Want to contribute a fix?<br>&gt;  <br>&gt; I&#39;d love to! I&#39;ll start working on one over the weekend.<br>&gt;  <br>&gt;&gt;&gt; I listed one open question:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Should the generated Obj-C declarations use the swift_name attribute to indicate the Swift type it came from? Proposal SE-0005 generalizes swift_name to apply to any arbitrary C or Obj-C entity, so it will be legal to put on enums.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Labelling it makes it clear to the reader what the Swift equivalent is, but I&#39;m unsure if there&#39;s any downsides to doing this.<br>&gt;&gt;  <br>&gt;&gt; Yes, it makes sense to use the swift_name attribute here. If you’re implementing your proposal, check out lib/PrintAsObjC/PrintAsObjC.cpp and how we use the SWIFT_COMPILE_NAME macro for this in the generated header.<br>&gt;  <br>&gt; Will do. My worry with using swift_name is that, at least in the clang that ships with Xcode 7.2, you can&#39;t actually put the swift_name attribute on an enum. I assume that will change with SE-0005, but I also assume this hasn&#39;t been implemented yet. And even when it is implemented, emitting it will be a backwards-compatibility hazard if the generated header needs to work with older clangs. Is there any way to suppress the error?<br></p><p>Hrm, that’s a good point. The generalized swift_name support is implemented in upstream Clang, but you’re right that Xcode 7.2 won’t be able to parse it. We can add a “__has_feature” entry for generalized swift_name in Clang and wrap this particular use of swift_name in<br></p><p>	#if __has_feature(generalized_swift_name)<br>	// ...<br>	#endif<br></p><p>&gt; I&#39;m also not sure offhand where you actually put the attribute on an enum, since the enum definition is actually 2 declarations, one for the typedef and one for the enum itself. Would it go after the `enum` keyword, in the place where SWIFT_ENUM_EXTRA is? <br></p><p>Yes, that’s correct.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/db10c02d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Allow @objc(name) on enum declarations</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 11, 2015 at 10:00:00pm</p></header><div class="content"><p>On Fri, Dec 11, 2015, at 10:05 PM, Douglas Gregor wrote:<br>&gt;<br>&gt;&gt; On Dec 11, 2015, at 9:40 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Will do. My worry with using swift_name is that, at least in the<br>&gt;&gt; clang that ships with Xcode 7.2, you can&#39;t actually put the<br>&gt;&gt; swift_name attribute on an enum. I assume that will change with SE-<br>&gt;&gt; 0005, but I also assume this hasn&#39;t been implemented yet. And even<br>&gt;&gt; when it is implemented, emitting it will be a backwards-compatibility<br>&gt;&gt; hazard if the generated header needs to work with older clangs. Is<br>&gt;&gt; there any way to suppress the error?<br>&gt;<br>&gt; Hrm, that’s a good point. The generalized swift_name support is<br>&gt; implemented in upstream Clang, but you’re right that Xcode 7.2 won’t<br>&gt; be able to parse it. We can add a “__has_feature” entry for<br>&gt; generalized swift_name in Clang and wrap this particular use of<br>&gt; swift_name in<br>&gt;<br>&gt; #if __has_feature(generalized_swift_name) // ... #endif<br></p><p>That works for me. Can I assume this will get added by someone who&#39;s<br>familiar with clang, or should I try and figure out how to do this<br>myself and submit a patch?<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/15ae31a8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Proposal: Allow @objc(name) on enum declarations</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 12, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 10:33 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Fri, Dec 11, 2015, at 10:05 PM, Douglas Gregor wrote:<br>&gt;&gt;  <br>&gt;&gt;&gt; On Dec 11, 2015, at 9:40 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Will do. My worry with using swift_name is that, at least in the clang that ships with Xcode 7.2, you can&#39;t actually put the swift_name attribute on an enum. I assume that will change with SE-0005, but I also assume this hasn&#39;t been implemented yet. And even when it is implemented, emitting it will be a backwards-compatibility hazard if the generated header needs to work with older clangs. Is there any way to suppress the error?<br>&gt;&gt;  <br>&gt;&gt; Hrm, that’s a good point. The generalized swift_name support is implemented in upstream Clang, but you’re right that Xcode 7.2 won’t be able to parse it. We can add a “__has_feature” entry for generalized swift_name in Clang and wrap this particular use of swift_name in<br>&gt;&gt;  <br>&gt;&gt; #if __has_feature(generalized_swift_name)<br>&gt;&gt; // ...<br>&gt;&gt; #endif<br>&gt;  <br>&gt; That works for me. Can I assume this will get added by someone who&#39;s familiar with clang, or should I try and figure out how to do this myself and submit a patch?<br></p><p>I went ahead and did this in<br></p><p>	https://github.com/apple/swift-clang/commit/f66c5bb67b9a1016b51d2eff0f497d4528dacc0a &lt;https://github.com/apple/swift-clang/commit/f66c5bb67b9a1016b51d2eff0f497d4528dacc0a&gt;<br></p><p>and it’s cherry-picks.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/df8d23a6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
