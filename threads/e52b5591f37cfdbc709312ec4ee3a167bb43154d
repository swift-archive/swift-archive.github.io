<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>[swift-evolution] Proposal: Conforming NSDate to Comparable</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>December  6, 2015 at 02:00:00am</p></header><div class="content"><p>&gt; It is simply not the case that *all* arithmetic on NSDates is incorrect unless it involves NSCalendar and NSDateComponents.<br>But then the same logic would follow that String must have all sorts of convenient but incorrect API on it, because it is simply not the case that all character transformations are incorrect unless they involve Unicode translation. The standard libraries should not go out of their way to make flawed code look easy.<br></p><p>Zachary Waldowski<br>zach at waldowski.me<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151206/e52b154d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[swift-evolution] Proposal: Conforming NSDate to Comparable</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  6, 2015 at 12:00:00am</p></header><div class="content"><p>On Sat, Dec 5, 2015, at 11:29 PM, Zachary Waldowski via swift-corelibs-dev wrote:<br>&gt;&gt; It is simply not the case that *all* arithmetic on NSDates is<br>&gt;&gt; incorrect unless it involves NSCalendar and NSDateComponents.<br>&gt; But then the same logic would follow that String must have all sorts<br>&gt; of convenient but incorrect API on it, because it is simply not the<br>&gt; case that all character transformations are incorrect unless they<br>&gt; involve Unicode translation. The standard libraries should not go out<br>&gt; of their way to make flawed code look easy.<br></p><p>This doesn&#39;t make sense.<br></p><p>NSDate exists independently of calendars. It represents a point in time,<br>no more, no less. It has no notion of days or hours or anything else<br>larger than 1 second. It has methods to advance by a given interval, and<br>to calculate an interval from two dates. It also has methods for<br>comparing dates. All of this is perfectly valid and correct and using<br>them is not flawed.<br></p><p>I can think of no reason why declaring conformance on NSDate for<br>Comparable or Strideable should change any of this. All it does is<br>provide the standardized API that calls through to the methods that<br>already exist. Strideable and Comparable do not have any inherent notion<br>of calendars either.<br></p><p>It&#39;s certainly true that it is an error for a programmer to add 86400<br>seconds to a given NSDate and expect to get the exact same time in the<br>following day. But that holds true whether they&#39;re calling<br>.advancedBy() or whether they&#39;re calling .dateByAddingTimeInterval().<br>And there&#39;s plenty of valid use-cases for performing arithmetic on<br>dates beyond adding and subtracting days. If you want to do day<br>calculations, by all means use NSCalendar. That&#39;s what it&#39;s for. But<br>that shouldn&#39;t stop anyone else from doing their own time calculations<br>using the standard API.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151206/48a1c966/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0f5e460daedc625457bc16580ecdbc04?s=50"></div><header><strong>[swift-evolution] Proposal: Conforming NSDate to Comparable</strong> from <string>Davide De Franceschi</string> &lt;defrenz98 at hotmail.com&gt;<p>December  6, 2015 at 09:00:00am</p></header><div class="content"><p>I agree that it makes perfect sense for NSDate to implement Strideable. I actually do that already in my extensions.<br>The concept of NSDate and NSTimeInterval fit with the concept, the chance of misusing it doesn&#39;t increase too much with more utilities as a developer either knows what it represent or it doesn&#39;t (if it doesn&#39;t search for it).<br>This shouldn&#39;t be used for date computations (and here I could say the name is ambiguous), but for time computations.<br></p><p>&gt; On 6 Dec 2015, at 08:01, Kevin Ballard via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; On Sat, Dec 5, 2015, at 11:29 PM, Zachary Waldowski via swift-corelibs-dev wrote:<br>&gt;&gt;&gt; It is simply not the case that *all* arithmetic on NSDates is incorrect unless it involves NSCalendar and NSDateComponents.<br>&gt;&gt; <br>&gt;&gt; But then the same logic would follow that String must have all sorts of convenient but incorrect API on it, because it is simply not the case that all character transformations are incorrect unless they involve Unicode translation. The standard libraries should not go out of their way to make flawed code look easy.<br>&gt;  <br>&gt; This doesn&#39;t make sense.<br>&gt;  <br>&gt; NSDate exists independently of calendars. It represents a point in time, no more, no less. It has no notion of days or hours or anything else larger than 1 second. It has methods to advance by a given interval, and to calculate an interval from two dates. It also has methods for comparing dates. All of this is perfectly valid and correct and using them is not flawed.<br>&gt;  <br>&gt; I can think of no reason why declaring conformance on NSDate for Comparable or Strideable should change any of this. All it does is provide the standardized API that calls through to the methods that already exist. Strideable and Comparable do not have any inherent notion of calendars either.<br>&gt;  <br>&gt; It&#39;s certainly true that it is an error for a programmer to add 86400 seconds to a given NSDate and expect to get the exact same time in the following day. But that holds true whether they&#39;re calling .advancedBy() or whether they&#39;re calling .dateByAddingTimeInterval(). And there&#39;s plenty of valid use-cases for performing arithmetic on dates beyond adding and subtracting days. If you want to do day calculations, by all means use NSCalendar. That&#39;s what it&#39;s for. But that shouldn&#39;t stop anyone else from doing their own time calculations using the standard API.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151206/0d197586/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution] Proposal: Conforming NSDate to Comparable</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  6, 2015 at 02:00:00am</p></header><div class="content"><p>&gt; I agree that it makes perfect sense for NSDate to implement Strideable. I actually do that already in my extensions.<br>&gt; The concept of NSDate and NSTimeInterval fit with the concept, the chance of misusing it doesn&#39;t increase too much with more utilities as a developer either knows what it represent or it doesn&#39;t (if it doesn&#39;t search for it).<br>&gt; This shouldn&#39;t be used for date computations (and here I could say the name is ambiguous), but for time computations.<br></p><p>I obviously agree. But I’d also add that it might make sense to emit a compiler warning for things that look like date math instead of time math—for instance, constants divisible by 86400 (24 hours), or maybe even 3600 (60 minutes).<br></p><p>Actually, this might be a good idea even when no time APIs are obviously involved. What are the chances your literal 86400 doesn’t have something to do with a date?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6f4c2cdf314c4a67b3dc67dcd4078832?s=50"></div><header><strong>[swift-evolution] Proposal: Conforming NSDate to Comparable</strong> from <string>Alexander Kolov</string> &lt;me at alexkolov.com&gt;<p>December  6, 2015 at 01:00:00pm</p></header><div class="content"><p>I also agree, since all methods already exist in NSDate. Conforming it to Comparable and Strideable is just making interface more in line with Swift spirit.<br></p><p>&gt; On Dec 6, 2015, at 11:05 AM, Brent Royal-Gordon via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I agree that it makes perfect sense for NSDate to implement Strideable. I actually do that already in my extensions.<br>&gt;&gt; The concept of NSDate and NSTimeInterval fit with the concept, the chance of misusing it doesn&#39;t increase too much with more utilities as a developer either knows what it represent or it doesn&#39;t (if it doesn&#39;t search for it).<br>&gt;&gt; This shouldn&#39;t be used for date computations (and here I could say the name is ambiguous), but for time computations.<br>&gt; <br>&gt; I obviously agree. But I’d also add that it might make sense to emit a compiler warning for things that look like date math instead of time math—for instance, constants divisible by 86400 (24 hours), or maybe even 3600 (60 minutes).<br>&gt; <br>&gt; Actually, this might be a good idea even when no time APIs are obviously involved. What are the chances your literal 86400 doesn’t have something to do with a date?<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
