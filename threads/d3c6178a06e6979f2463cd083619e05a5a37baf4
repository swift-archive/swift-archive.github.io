<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] remove(at: Set&lt;Index&gt;)</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>June 19, 2016 at 06:00:00am</p></header><div class="content"><p>So like most good pitches, this one comes about because of a bug I recently fixed which seems common and subtle enough that I think it would be nice to include in the standard library.<br></p><p>Removing a collection of elements at once from a collection. You might want to do this in some kind of advanced filtering code. In my case, our code was merging adjacent elements in-place, and storing a list of indexes that were no longer required because they were now part of a merged element, and then we cleaned up the duplicates by removing those indexes.<br></p><p>A näive implementation might look like this:<br></p><p>for index in indexesToRemove {<br>    myArray.remove(at: index)<br>}<br></p><p>However, as the array is mutated, those indexes won’t make sense any more. You’ll end up with invalid results - for example, if you have the array [0,1,2] and indexesToRemove is [0,1], your resulting array will actually be [1] (not [2], as expected). Actually removing a batch of indexes is subtly more complex. Here’s my generic implementation:<br></p><p>extension RangeReplaceableCollection where Index:Hashable, Self:BidirectionalIndexable {<br></p><p>	mutating func remove(at indexes: Set&lt;Index&gt;) {<br>		var removed : IndexDistance = 0<br>		for idx in indexes.sorted() {<br>			remove(at: index(idx, offsetBy: -removed))<br>			removed = removed.advanced(by: 1)<br>		}<br>	}<br>}<br></p><p>I think it would be nice to have this in the standard library. I think it’s a reasonably common problem and it’d be nice to make it easier for people.<br></p><p>Karl<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Pitch] remove(at: Set&lt;Index&gt;)</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>June 18, 2016 at 09:00:00pm</p></header><div class="content"><p>On Sat, Jun 18, 2016 at 9:09 PM, Karl via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; So like most good pitches, this one comes about because of a bug I recently fixed which seems common and subtle enough that I think it would be nice to include in the standard library.<br>&gt;<br>&gt; Removing a collection of elements at once from a collection. You might want to do this in some kind of advanced filtering code. In my case, our code was merging adjacent elements in-place, and storing a list of indexes that were no longer required because they were now part of a merged element, and then we cleaned up the duplicates by removing those indexes.<br>&gt;<br>&gt; A näive implementation might look like this:<br>&gt;<br>&gt; for index in indexesToRemove {<br>&gt;     myArray.remove(at: index)<br>&gt; }<br>&gt;<br>&gt; However, as the array is mutated, those indexes won’t make sense any more. You’ll end up with invalid results - for example, if you have the array [0,1,2] and indexesToRemove is [0,1], your resulting array will actually be [1] (not [2], as expected). Actually removing a batch of indexes is subtly more complex. Here’s my generic implementation:<br>&gt;<br>&gt; extension RangeReplaceableCollection where Index:Hashable, Self:BidirectionalIndexable {<br>&gt;<br>&gt;         mutating func remove(at indexes: Set&lt;Index&gt;) {<br></p><p>Hi Karl,<br></p><p>This sounds like a good idea to me.  You can make this method even<br>more useful by making it generic over collections of appropriate<br>indices.  Then you can drop the Hashable requirement for indices.<br></p><p>&gt;                 var removed : IndexDistance = 0<br>&gt;                 for idx in indexes.sorted() {<br>&gt;                         remove(at: index(idx, offsetBy: -removed))<br>&gt;                         removed = removed.advanced(by: 1)<br></p><p>This implementation will not work correctly for all collections, since<br>removing an element at the beginning of the collection invalidates the<br>indices pointing at the tail.  Adjusting the index by &quot;-removed&quot; won&#39;t<br>help, the indices are invalidated already.  (Consider what happens in<br>a UnicodeScalar String view where indices have to jump over variable<br>number of code units in the underlying storage.)<br></p><p>You can make it correct (and work even faster, in O(n)) by walking<br>from the start, and moving the elements into place, and then<br>truncating the collection.  You will need to require<br>MutableCollection.<br></p><p>You can make a variant that works for collections that are not<br>MutableCollections, but then the runtime will be O(n^2).  You will<br>need to remove elements one by one walking from the end and shifting<br>the tail of the collection.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>[Pitch] remove(at: Set&lt;Index&gt;)</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>June 19, 2016 at 04:00:00am</p></header><div class="content"><p>This isn’t actually that complex, especially if you ditch the “C-style” for<br>loop algorithm and switch it to, as you mentioned, “filtering code”. filter,<br>enumerated (to get indices), and map (to go back to elements) are more than<br>up to the task. Plus, this is much more efficient.<br></p><p>var myArray = [0, 1, 2]<br>let indices: Set = [0, 1]<br>myArray = myArray.enumerated().filter {<br>    return !indices.contains($0.offset)<br>}.map {<br>    return $0.element // to get the elements back<br>}<br>print(myArray) // prints “[2]&quot;<br></p><p>Adding it to the standard library might be useful, but it’s not as hard as<br>it looks.<br></p><p><br>On Sat, Jun 18, 2016 at 9:09 PM Karl via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; So like most good pitches, this one comes about because of a bug I<br>&gt; recently fixed which seems common and subtle enough that I think it would<br>&gt; be nice to include in the standard library.<br>&gt;<br>&gt; Removing a collection of elements at once from a collection. You might<br>&gt; want to do this in some kind of advanced filtering code. In my case, our<br>&gt; code was merging adjacent elements in-place, and storing a list of indexes<br>&gt; that were no longer required because they were now part of a merged<br>&gt; element, and then we cleaned up the duplicates by removing those indexes.<br>&gt;<br>&gt; A näive implementation might look like this:<br>&gt;<br>&gt; for index in indexesToRemove {<br>&gt;     myArray.remove(at: index)<br>&gt; }<br>&gt;<br>&gt; However, as the array is mutated, those indexes won’t make sense any more.<br>&gt; You’ll end up with invalid results - for example, if you have the array<br>&gt; [0,1,2] and indexesToRemove is [0,1], your resulting array will actually be<br>&gt; [1] (not [2], as expected). Actually removing a batch of indexes is subtly<br>&gt; more complex. Here’s my generic implementation:<br>&gt;<br>&gt; extension RangeReplaceableCollection where Index:Hashable,<br>&gt; Self:BidirectionalIndexable {<br>&gt;<br>&gt;         mutating func remove(at indexes: Set&lt;Index&gt;) {<br>&gt;                 var removed : IndexDistance = 0<br>&gt;                 for idx in indexes.sorted() {<br>&gt;                         remove(at: index(idx, offsetBy: -removed))<br>&gt;                         removed = removed.advanced(by: 1)<br>&gt;                 }<br>&gt;         }<br>&gt; }<br>&gt;<br>&gt; I think it would be nice to have this in the standard library. I think<br>&gt; it’s a reasonably common problem and it’d be nice to make it easier for<br>&gt; people.<br>&gt;<br>&gt; Karl<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>-Saagar Jha<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160619/1b44a6c9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] remove(at: Set&lt;Index&gt;)</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>June 19, 2016 at 07:00:00am</p></header><div class="content"><p>What exactly are the guarantees for index safety across mutations? Both Collection and Indexable stop short of making any kind of guarantees about what happens to indexes after you mutate. For example, popFirst() has the potential to invalidate all stored indexes, but you wouldn’t know that if you were just working in terms of Collection.<br></p><p>If we can guarantee tail-end removal is safe, a minimalist’s solution could be:<br></p><p>extension RangeReplaceableCollection {<br></p><p>	mutating func remove&lt;S:Sequence where S.Iterator.Element == Index&gt;(at indexes: S) {<br></p><p>		for idx in indexes.sorted(isOrderedBefore: &gt;) {<br>			remove(at: idx)<br>		}<br>	}<br>}<br></p><p>Maybe with Array having a more optimal implementation if those sorted indexes form a continuous range.<br></p><p>Karl<br></p><p><br></p><p>&gt; On 19 Jun 2016, at 06:58, Saagar Jha &lt;saagarjha28 at gmail.com&gt; wrote:<br>&gt; <br>&gt; This isn’t actually that complex, especially if you ditch the “C-style” for loop algorithm and switch it to, as you mentioned, “filtering code”. filter, enumerated (to get indices), and map (to go back to elements) are more than up to the task. Plus, this is much more efficient.<br>&gt; <br>&gt; var myArray = [0, 1, 2]<br>&gt; let indices: Set = [0, 1]<br>&gt; myArray = myArray.enumerated().filter {<br>&gt;     return !indices.contains($0.offset)<br>&gt; }.map {<br>&gt;     return $0.element // to get the elements back<br>&gt; }<br>&gt; print(myArray) // prints “[2]&quot;<br>&gt; Adding it to the standard library might be useful, but it’s not as hard as it looks.<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Sat, Jun 18, 2016 at 9:09 PM Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; So like most good pitches, this one comes about because of a bug I recently fixed which seems common and subtle enough that I think it would be nice to include in the standard library.<br>&gt; <br>&gt; Removing a collection of elements at once from a collection. You might want to do this in some kind of advanced filtering code. In my case, our code was merging adjacent elements in-place, and storing a list of indexes that were no longer required because they were now part of a merged element, and then we cleaned up the duplicates by removing those indexes.<br>&gt; <br>&gt; A näive implementation might look like this:<br>&gt; <br>&gt; for index in indexesToRemove {<br>&gt;     myArray.remove(at: index)<br>&gt; }<br>&gt; <br>&gt; However, as the array is mutated, those indexes won’t make sense any more. You’ll end up with invalid results - for example, if you have the array [0,1,2] and indexesToRemove is [0,1], your resulting array will actually be [1] (not [2], as expected). Actually removing a batch of indexes is subtly more complex. Here’s my generic implementation:<br>&gt; <br>&gt; extension RangeReplaceableCollection where Index:Hashable, Self:BidirectionalIndexable {<br>&gt; <br>&gt;         mutating func remove(at indexes: Set&lt;Index&gt;) {<br>&gt;                 var removed : IndexDistance = 0<br>&gt;                 for idx in indexes.sorted() {<br>&gt;                         remove(at: index(idx, offsetBy: -removed))<br>&gt;                         removed = removed.advanced(by: 1)<br>&gt;                 }<br>&gt;         }<br>&gt; }<br>&gt; <br>&gt; I think it would be nice to have this in the standard library. I think it’s a reasonably common problem and it’d be nice to make it easier for people.<br>&gt; <br>&gt; Karl<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; -- <br>&gt; -Saagar Jha<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160619/b5e7472f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Pitch] remove(at: Set&lt;Index&gt;)</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>June 18, 2016 at 11:00:00pm</p></header><div class="content"><p>On Sat, Jun 18, 2016 at 10:59 PM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt; What exactly are the guarantees for index safety across mutations? Both<br>&gt; Collection and Indexable stop short of making any kind of guarantees about<br>&gt; what happens to indexes after you mutate. For example, popFirst() has the<br>&gt; potential to invalidate all stored indexes, but you wouldn’t know that if<br>&gt; you were just working in terms of Collection.<br></p><p>https://github.com/apple/swift/blob/master/docs/IndexInvalidation.rst<br></p><p>Mutating a collection invalidates all indices.  Specific types and<br>protocols relax this:<br></p><p>- Replacing an element in a MutableCollection does not invalidate any indices.<br></p><p>- RangeReplaceableCollection only invalidates indices after the one<br>where the structural mutation happened.  For example,<br>replaceRange(a..&lt;b, ...) invalidates &quot;a&quot; and all indices after it.<br></p><p>Collections in stdlib/private/StdlibCollectionUnittest/MinimalCollections.swift.gyb<br>check these rules.<br></p><p>&gt; If we can guarantee tail-end removal is safe, a minimalist’s solution could<br>&gt; be:<br>&gt;<br>&gt; extension RangeReplaceableCollection {<br>&gt;<br>&gt; mutating func remove&lt;S:Sequence where S.Iterator.Element == Index&gt;(at<br>&gt; indexes: S) {<br>&gt;<br>&gt; for idx in indexes.sorted(isOrderedBefore: &gt;) {<br>&gt; remove(at: idx)<br>&gt; }<br>&gt; }<br>&gt; }<br></p><p>Yes, this works, but it is O(n^2).  We can do better.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] remove(at: Set&lt;Index&gt;)</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>June 19, 2016 at 08:00:00am</p></header><div class="content"><p>Scratch that: it should still be a Set and Index should still be Hashable. Otherwise the order of the indexes could be important and there may be duplicates. That’s a level of sophistication where you should know how about index invalidation while mutating and can do it manually.<br></p><p>extension RangeReplaceableCollection where Index : Hashable {<br></p><p>	mutating func remove(at indexes: Set&lt;Index&gt;) {<br></p><p>		for idx in indexes.sorted(isOrderedBefore: &gt;) {<br>			remove(at: idx)<br>		}<br>	}<br>}<br></p><p>It’s not actually O(n^2) - it’s O(m*n), where m is never larger than n, and likely much smaller if n is large. Otherwise, you should probably use an inclusive filter and create a new instance, rather than than removing most of your large numbers of elements in-place.<br></p><p>So it’s probably better to loop over m. Given that, I’m not sure how we’d improve on the O(n) remove-at-index. That said, I’m seeing lots of weirdness in Xcode 8 (which may just be my machine), so I’m not really certain what MutableCollection even provides — apparently it supports in-place ’sort’ (via CMD+click), but it’s not in auto-complete and trying to use it is a compile error.<br></p><p>Karl<br></p><p>&gt; On 19 Jun 2016, at 07:59, Karl &lt;raziel.im+swift-evo at gmail.com&gt; wrote:<br>&gt; <br>&gt; What exactly are the guarantees for index safety across mutations? Both Collection and Indexable stop short of making any kind of guarantees about what happens to indexes after you mutate. For example, popFirst() has the potential to invalidate all stored indexes, but you wouldn’t know that if you were just working in terms of Collection.<br>&gt; <br>&gt; If we can guarantee tail-end removal is safe, a minimalist’s solution could be:<br>&gt; <br>&gt; extension RangeReplaceableCollection {<br>&gt; <br>&gt; 	mutating func remove&lt;S:Sequence where S.Iterator.Element == Index&gt;(at indexes: S) {<br>&gt; <br>&gt; 		for idx in indexes.sorted(isOrderedBefore: &gt;) {<br>&gt; 			remove(at: idx)<br>&gt; 		}<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; Maybe with Array having a more optimal implementation if those sorted indexes form a continuous range.<br>&gt; <br>&gt; Karl<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On 19 Jun 2016, at 06:58, Saagar Jha &lt;saagarjha28 at gmail.com &lt;mailto:saagarjha28 at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This isn’t actually that complex, especially if you ditch the “C-style” for loop algorithm and switch it to, as you mentioned, “filtering code”. filter, enumerated (to get indices), and map (to go back to elements) are more than up to the task. Plus, this is much more efficient.<br>&gt;&gt; <br>&gt;&gt; var myArray = [0, 1, 2]<br>&gt;&gt; let indices: Set = [0, 1]<br>&gt;&gt; myArray = myArray.enumerated().filter {<br>&gt;&gt;     return !indices.contains($0.offset)<br>&gt;&gt; }.map {<br>&gt;&gt;     return $0.element // to get the elements back<br>&gt;&gt; }<br>&gt;&gt; print(myArray) // prints “[2]&quot;<br>&gt;&gt; Adding it to the standard library might be useful, but it’s not as hard as it looks.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Sat, Jun 18, 2016 at 9:09 PM Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; So like most good pitches, this one comes about because of a bug I recently fixed which seems common and subtle enough that I think it would be nice to include in the standard library.<br>&gt;&gt; <br>&gt;&gt; Removing a collection of elements at once from a collection. You might want to do this in some kind of advanced filtering code. In my case, our code was merging adjacent elements in-place, and storing a list of indexes that were no longer required because they were now part of a merged element, and then we cleaned up the duplicates by removing those indexes.<br>&gt;&gt; <br>&gt;&gt; A näive implementation might look like this:<br>&gt;&gt; <br>&gt;&gt; for index in indexesToRemove {<br>&gt;&gt;     myArray.remove(at: index)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; However, as the array is mutated, those indexes won’t make sense any more. You’ll end up with invalid results - for example, if you have the array [0,1,2] and indexesToRemove is [0,1], your resulting array will actually be [1] (not [2], as expected). Actually removing a batch of indexes is subtly more complex. Here’s my generic implementation:<br>&gt;&gt; <br>&gt;&gt; extension RangeReplaceableCollection where Index:Hashable, Self:BidirectionalIndexable {<br>&gt;&gt; <br>&gt;&gt;         mutating func remove(at indexes: Set&lt;Index&gt;) {<br>&gt;&gt;                 var removed : IndexDistance = 0<br>&gt;&gt;                 for idx in indexes.sorted() {<br>&gt;&gt;                         remove(at: index(idx, offsetBy: -removed))<br>&gt;&gt;                         removed = removed.advanced(by: 1)<br>&gt;&gt;                 }<br>&gt;&gt;         }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I think it would be nice to have this in the standard library. I think it’s a reasonably common problem and it’d be nice to make it easier for people.<br>&gt;&gt; <br>&gt;&gt; Karl<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; -- <br>&gt;&gt; -Saagar Jha<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160619/7bf791b0/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pitch] remove(at: Set&lt;Index&gt;)</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>June 19, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 19 Jun 2016, at 05:58, Saagar Jha via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This isn’t actually that complex, especially if you ditch the “C-style” for loop algorithm and switch it to, as you mentioned, “filtering code”. filter, enumerated (to get indices), and map (to go back to elements) are more than up to the task. Plus, this is much more efficient.<br>&gt; <br>&gt; var myArray = [0, 1, 2]<br>&gt; let indices: Set = [0, 1]<br>&gt; myArray = myArray.enumerated().filter {<br>&gt;     return !indices.contains($0.offset)<br>&gt; }.map {<br>&gt;     return $0.element // to get the elements back<br>&gt; }<br>&gt; print(myArray) // prints “[2]&quot;<br>&gt; Adding it to the standard library might be useful, but it’s not as hard as it looks.<br>&gt; <br></p><p>Has .enumerated() been changed to use the collection’s internal Index type? Last time I tried something like this it failed because .enumerated() only returns numeric offsets, but the index type of a collection may not necessary be compatible (not all indices are just a plain numeric value, consider a type that returns AnyIndex). So this will only work when your indices are integers starting from zero.<br></p><p>I think the following should work for the generic case, and is pretty similar:<br></p><p>extension MutableCollection {<br>	public mutating func remove(indices: Set&lt;Index&gt;) {<br>		var index = self.startIndex<br>		self = self.filter {<br>			let result = indices.contains(index)<br>			self.formIndex(after: &amp;index)<br>			return result<br>		}<br>	}<br>}<br></p><p>(note: I&#39;m not in a position to test this just now so it may not work exactly as written, but that’s the gist of how to do it safely I think)<br></p><p>The main question I have is how do you get into a situation where you’ve generated the indices, but could not put the same code into a call to .filter? For example:<br></p><p>	var indicesToRemove:Set&lt;Index&gt; = []<br>	for eachIndex in myArray.indices {<br>		if someCondition(myArray[eachIndex]) { indicesToRemove.insert(eachIndex) }<br>	}<br>	myArray.remove(indices: indicesToRemove)<br></p><p>Could be rewritten as:<br></p><p>	myArray = myArray.filter { someCondition($0) }<br></p><p>If what we want is in-place removal then I think what we need is some kind of MutatingIteratorProtocol which includes a .remove() method; this method would remove the last element retrieved without invalidating the iterator or skipping an element, allowing us to do the following:<br></p><p>	var iterator = myArray.makeIterator() // Conforms to MutatingIteratorProtocol<br>	while let eachElement = iterator.next() {<br>		if someCondition(eachElement) { iterator.remove() }<br>	}<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160619/56d817c1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pitch] remove(at: Set&lt;Index&gt;)</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>June 19, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On 19 Jun 2016, at 11:12, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think the following should work for the generic case, and is pretty similar:<br>&gt; <br>&gt; extension MutableCollection {<br>&gt; 	public mutating func remove(indices: Set&lt;Index&gt;) {<br>&gt; 		var index = self.startIndex<br>&gt; 		self = self.filter {<br>&gt; 			let result = indices.contains(index)<br>&gt; 			self.formIndex(after: &amp;index)<br>&gt; 			return result<br>&gt; 		}<br>&gt; 	}<br>&gt; }<br></p><p>Apologies for the double-post but I’m honour bound to follow up that my generic method is a load of nonsense at the moment; it’s missing some kind of constructor (I don’t recall if there’s a common option that will satisfy this), also, due to the way .filter {} currently works even in its lazy form it can end up calling the filter closure more than once per item, so advancing the index currently won’t work as expected (elements are skipped, children murdered, it’s just the worst).<br></p><p>So yeah, best option to do this right now is with a proper loop over self.indices, but it still requires some kind constructor to build a new copy of the correct type.<br></p><p>For arrays this is a bit simpler as you *can* safely remove indices in reverse order, since later indices cannot invalidate earlier ones, but this is reliant on the array’s indices being integers (reasonable enough, but not really correct in the strictest sense), so like so:<br></p><p>	extension Array {<br>		public mutating func remove(indices: Set&lt;Index&gt;) {<br>			for eachIndex in indices.sort(&gt;) { // greater than should give descending order<br>				self.remove(at: eachIndex)<br>			}<br>		}<br>	}<br></p><p>But yeah, this is only safe on types where removing later items does not change the order of earlier ones, though this should be true on Array, Dictionary and Set since none of these shrink as elements are removed, it’s not strictly a good idea to rely on this behaviour as it’s implementation dependent, even though it’s unlikely this will change.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160619/6d5bd957/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
