<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 11, 2015 at 05:00:00pm</p></header><div class="content"><p>Looking for feedback on crafting a proposal adding generator functions to Swift. I understand this will likely be a very involved proposal at the language level, although I actually don’t know the complexity of the change within the Swift compiler itself.<br></p><p>This would be a function which returns multiple values, which is converted by the compiler to a function returning a SequenceType<br></p><p>A very basic syntax would be to add generator as a modifier to func, and likely involve a new keyword ‘yield’ to differentiate from the flow control behavior of ‘return’.<br></p><p>So for example:<br></p><p>generator func helloGenerator(name:String?) -&gt; String {<br>    yield “Hello”<br>    yield name ?? “World”<br>}<br></p><p>Would have the following expected usage:<br></p><p>for str in helloGenerator(“David&quot;) {<br>   print str<br>// prints:<br>//    Hello<br>//    David<br>}<br></p><p>And for those unfamiliar to these sorts of simple cases, would have equivalent behavior to the following code:<br></p><p> 45&gt; func helloGenerator(name:String?) -&gt; HelloGenerator { <br> 46.   return HelloGenerator(name) <br> 47. } <br> 48.  <br> 49. struct HelloGenerator : GeneratorType, SequenceType { <br> 50.    var position:Int = 0 <br> 51.    let name:String? <br> 52.  <br> 53.    private init(_ name:String?) { <br> 54.       self.name = name <br> 55.    } <br> 56.     <br> 57.    func generator() -&gt; HelloGenerator {<br> 58.        return self <br> 59.    } <br> 60.      <br> 61.    mutating func next() -&gt; String? { <br> 62.       switch position { <br> 63.       case 0: <br> 64.           position = 1 <br> 65.           return &quot;Hello&quot; <br> 66.       case 1: <br> 67.           position = 2 <br> 68.           return name ?? &quot;World&quot; <br> 69.       default: <br> 70.           return nil <br> 71.       } <br> 72.    } <br> 73. } <br></p><p>This syntax has at a bare minimum issues with generator closures and for a terse syntax for yielding over another sequence type within a generator function vs. using a loop. (possibly “yield in sequenceName”)<br></p><p>The interaction with the error system might involve disallowing throws from generator functions, or having the Element type be a Result&lt;T&gt; rather than T, as the GeneratorType next() method is not declared as throwing.<br></p><p>This could pair well to make for-in loops more comprehensive, especially if C-style for loops are eliminated.<br></p><p>This would possibly be a first step toward a coroutine-based concurrency system, although I am not proposing that sort of usage or scope here. The goal would be to emit an object compatible with SequenceType<br></p><p>-David Waite (DW)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/38903c75/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>December 11, 2015 at 06:00:00pm</p></header><div class="content"><p>+1.<br></p><p>I make extensive use of generators in Python, particularly for lazy evaluation, and their absence in Swift is unfortunate.<br></p><p>In a typical ARC-based iOS scenario<br></p><p>for photo in photoGenerator() {<br>    //something with photo<br>}<br></p><p>is  (&quot;should be specified to be&quot;) more memory efficient than<br></p><p>for photo in something.buildArrayOfPhotos() {<br>  //something with photo<br>}<br></p><p>which likely entails an OOM crash and is a common source of noob programmer error.<br></p><p>Reducing the friction of SequenceType in such cases is an improvement entirely orthogonal to coroutines (of which I am much more skeptical).<br></p><p>Drew<br></p><p><br>&gt; On Dec 11, 2015, at 6:21 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Looking for feedback on crafting a proposal adding generator functions to Swift. I understand this will likely be a very involved proposal at the language level, although I actually don’t know the complexity of the change within the Swift compiler itself.<br>&gt; <br>&gt; This would be a function which returns multiple values, which is converted by the compiler to a function returning a SequenceType<br>&gt; <br>&gt; A very basic syntax would be to add generator as a modifier to func, and likely involve a new keyword ‘yield’ to differentiate from the flow control behavior of ‘return’.<br>&gt; <br>&gt; So for example:<br>&gt; <br>&gt; generator func helloGenerator(name:String?) -&gt; String {<br>&gt;     yield “Hello”<br>&gt;     yield name ?? “World”<br>&gt; }<br>&gt; <br>&gt; Would have the following expected usage:<br>&gt; <br>&gt; for str in helloGenerator(“David&quot;) {<br>&gt;    print str<br>&gt; // prints:<br>&gt; //    Hello<br>&gt; //    David<br>&gt; }<br>&gt; <br>&gt; And for those unfamiliar to these sorts of simple cases, would have equivalent behavior to the following code:<br>&gt; <br>&gt;  45&gt; func helloGenerator(name:String?) -&gt; HelloGenerator { <br>&gt;  46.   return HelloGenerator(name) <br>&gt;  47. } <br>&gt;  48.  <br>&gt;  49. struct HelloGenerator : GeneratorType, SequenceType { <br>&gt;  50.    var position:Int = 0 <br>&gt;  51.    let name:String? <br>&gt;  52.  <br>&gt;  53.    private init(_ name:String?) { <br>&gt;  54.       self.name = name <br>&gt;  55.    } <br>&gt;  56.     <br>&gt;  57.    func generator() -&gt; HelloGenerator {<br>&gt;  58.        return self <br>&gt;  59.    } <br>&gt;  60.      <br>&gt;  61.    mutating func next() -&gt; String? { <br>&gt;  62.       switch position { <br>&gt;  63.       case 0: <br>&gt;  64.           position = 1 <br>&gt;  65.           return &quot;Hello&quot; <br>&gt;  66.       case 1: <br>&gt;  67.           position = 2 <br>&gt;  68.           return name ?? &quot;World&quot; <br>&gt;  69.       default: <br>&gt;  70.           return nil <br>&gt;  71.       } <br>&gt;  72.    } <br>&gt;  73. } <br>&gt; <br>&gt; This syntax has at a bare minimum issues with generator closures and for a terse syntax for yielding over another sequence type within a generator function vs. using a loop. (possibly “yield in sequenceName”)<br>&gt; <br>&gt; The interaction with the error system might involve disallowing throws from generator functions, or having the Element type be a Result&lt;T&gt; rather than T, as the GeneratorType next() method is not declared as throwing.<br>&gt; <br>&gt; This could pair well to make for-in loops more comprehensive, especially if C-style for loops are eliminated.<br>&gt; <br>&gt; This would possibly be a first step toward a coroutine-based concurrency system, although I am not proposing that sort of usage or scope here. The goal would be to emit an object compatible with SequenceType<br>&gt; <br>&gt; -David Waite (DW)<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/1332df2c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December 11, 2015 at 04:00:00pm</p></header><div class="content"><p>Presumably, this could work with (or replace) GeneratorType, since all<br>generators as they currently exist could be implemented this way.<br></p><p>On Fri, Dec 11, 2015 at 4:36 PM, Drew Crawford via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1.<br>&gt;<br>&gt; I make extensive use of generators in Python, particularly for lazy<br>&gt; evaluation, and their absence in Swift is unfortunate.<br>&gt;<br>&gt; In a typical ARC-based iOS scenario<br>&gt;<br>&gt; for photo in photoGenerator() {<br>&gt;     //something with photo<br>&gt; }<br>&gt;<br>&gt;<br>&gt; is  (&quot;should be specified to be&quot;) more memory efficient than<br>&gt;<br>&gt; for photo in something.buildArrayOfPhotos() {<br>&gt;   //something with photo<br>&gt; }<br>&gt;<br>&gt; which likely entails an OOM crash and is a common source of noob<br>&gt; programmer error.<br>&gt;<br>&gt; Reducing the friction of SequenceType in such cases is an improvement<br>&gt; entirely orthogonal to coroutines (of which I am much more skeptical).<br>&gt;<br>&gt; Drew<br>&gt;<br>&gt;<br>&gt; On Dec 11, 2015, at 6:21 PM, David Waite via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Looking for feedback on crafting a proposal adding generator functions to<br>&gt; Swift. I understand this will likely be a very involved proposal at the<br>&gt; language level, although I actually don’t know the complexity of the change<br>&gt; within the Swift compiler itself.<br>&gt;<br>&gt; This would be a function which returns multiple values, which is converted<br>&gt; by the compiler to a function returning a SequenceType<br>&gt;<br>&gt; A very basic syntax would be to add generator as a modifier to func, and<br>&gt; likely involve a new keyword ‘yield’ to differentiate from the flow control<br>&gt; behavior of ‘return’.<br>&gt;<br>&gt; So for example:<br>&gt;<br>&gt; generator func helloGenerator(name:String?) -&gt; String {<br>&gt;     yield “Hello”<br>&gt;     yield name ?? “World”<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Would have the following expected usage:<br>&gt;<br>&gt; for str in helloGenerator(“David&quot;) {<br>&gt;    print str<br>&gt; // prints:<br>&gt;<br>&gt; //    Hello<br>&gt; //    David<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; And for those unfamiliar to these sorts of simple cases, would have<br>&gt; equivalent behavior to the following code:<br>&gt;<br>&gt;  45&gt; func helloGenerator(name:String?) -&gt; HelloGenerator {<br>&gt;  46.   return HelloGenerator(name)<br>&gt;  47. }<br>&gt;  48.<br>&gt;  49. struct HelloGenerator : GeneratorType, SequenceType {<br>&gt;  50.    var position:Int = 0<br>&gt;  51.    let name:String?<br>&gt;  52.<br>&gt;  53.    private init(_ name:String?) {<br>&gt;  54.       self.name = name<br>&gt;  55.    }<br>&gt;  56.<br>&gt;  57.    func generator() -&gt; HelloGenerator {<br>&gt;  58.        return self<br>&gt;  59.    }<br>&gt;  60.<br>&gt;  61.    mutating func next() -&gt; String? {<br>&gt;  62.       switch position {<br>&gt;  63.       case 0:<br>&gt;  64.           position = 1<br>&gt;  65.           return &quot;Hello&quot;<br>&gt;  66.       case 1:<br>&gt;  67.           position = 2<br>&gt;  68.           return name ?? &quot;World&quot;<br>&gt;  69.       default:<br>&gt;  70.           return nil<br>&gt;  71.       }<br>&gt;  72.    }<br>&gt;  73. }<br>&gt;<br>&gt; This syntax has at a bare minimum issues with generator closures and for a<br>&gt; terse syntax for yielding over another sequence type within a generator<br>&gt; function vs. using a loop. (possibly “yield in sequenceName”)<br>&gt;<br>&gt; The interaction with the error system might involve disallowing throws<br>&gt; from generator functions, or having the Element type be a Result&lt;T&gt; rather<br>&gt; than T, as the GeneratorType next() method is not declared as throwing.<br>&gt;<br>&gt; This could pair well to make for-in loops more comprehensive, especially<br>&gt; if C-style for loops are eliminated.<br>&gt;<br>&gt; This would possibly be a first step toward a coroutine-based concurrency<br>&gt; system, although I am not proposing that sort of usage or scope here. The<br>&gt; goal would be to emit an object compatible with SequenceType<br>&gt;<br>&gt; -David Waite (DW)<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/03ffb029/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4548eb4f3cff0c2a1cd388161f0ba001?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>Kametrixom Tikara</string> &lt;kametrixom at icloud.com&gt;<p>December 12, 2015 at 02:00:00am</p></header><div class="content"><p>What exactly is the difference to just returning a sequence?<br></p><p>func helloGenerator(name : String?) -&gt; [String] {<br>    return [<br>        &quot;Hello&quot;,<br>        name ?? &quot;World&quot;<br>    ]<br>}<br></p><p>for str in helloGenerator(&quot;David&quot;) {<br>    print(str)<br>}<br></p><p>And if you want if lazy:<br></p><p>func helloGenerator(name : String?) -&gt; LazyCollection&lt;[String]&gt; {<br>    return [<br>        &quot;Hello&quot;,<br>        name ?? &quot;World&quot;<br>    ].lazy<br>}<br></p><p>Seems like exactly the same, except it doesn’t need two new keywords nor revamping of SequenceType/GeneratorType<br></p><p>&gt; On 12 Dec 2015, at 01:21, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Looking for feedback on crafting a proposal adding generator functions to Swift. I understand this will likely be a very involved proposal at the language level, although I actually don’t know the complexity of the change within the Swift compiler itself.<br>&gt; <br>&gt; This would be a function which returns multiple values, which is converted by the compiler to a function returning a SequenceType<br>&gt; <br>&gt; A very basic syntax would be to add generator as a modifier to func, and likely involve a new keyword ‘yield’ to differentiate from the flow control behavior of ‘return’.<br>&gt; <br>&gt; So for example:<br>&gt; <br>&gt; generator func helloGenerator(name:String?) -&gt; String {<br>&gt;     yield “Hello”<br>&gt;     yield name ?? “World”<br>&gt; }<br>&gt; <br>&gt; Would have the following expected usage:<br>&gt; <br>&gt; for str in helloGenerator(“David&quot;) {<br>&gt;    print str<br>&gt; // prints:<br>&gt; //    Hello<br>&gt; //    David<br>&gt; }<br>&gt; <br>&gt; And for those unfamiliar to these sorts of simple cases, would have equivalent behavior to the following code:<br>&gt; <br>&gt;  45&gt; func helloGenerator(name:String?) -&gt; HelloGenerator { <br>&gt;  46.   return HelloGenerator(name) <br>&gt;  47. } <br>&gt;  48.  <br>&gt;  49. struct HelloGenerator : GeneratorType, SequenceType { <br>&gt;  50.    var position:Int = 0 <br>&gt;  51.    let name:String? <br>&gt;  52.  <br>&gt;  53.    private init(_ name:String?) { <br>&gt;  54.       self.name = name <br>&gt;  55.    } <br>&gt;  56.     <br>&gt;  57.    func generator() -&gt; HelloGenerator {<br>&gt;  58.        return self <br>&gt;  59.    } <br>&gt;  60.      <br>&gt;  61.    mutating func next() -&gt; String? { <br>&gt;  62.       switch position { <br>&gt;  63.       case 0: <br>&gt;  64.           position = 1 <br>&gt;  65.           return &quot;Hello&quot; <br>&gt;  66.       case 1: <br>&gt;  67.           position = 2 <br>&gt;  68.           return name ?? &quot;World&quot; <br>&gt;  69.       default: <br>&gt;  70.           return nil <br>&gt;  71.       } <br>&gt;  72.    } <br>&gt;  73. } <br>&gt; <br>&gt; This syntax has at a bare minimum issues with generator closures and for a terse syntax for yielding over another sequence type within a generator function vs. using a loop. (possibly “yield in sequenceName”)<br>&gt; <br>&gt; The interaction with the error system might involve disallowing throws from generator functions, or having the Element type be a Result&lt;T&gt; rather than T, as the GeneratorType next() method is not declared as throwing.<br>&gt; <br>&gt; This could pair well to make for-in loops more comprehensive, especially if C-style for loops are eliminated.<br>&gt; <br>&gt; This would possibly be a first step toward a coroutine-based concurrency system, although I am not proposing that sort of usage or scope here. The goal would be to emit an object compatible with SequenceType<br>&gt; <br>&gt; -David Waite (DW)<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/8e821a8d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>December 11, 2015 at 07:00:00pm</p></header><div class="content"><p>One difference is the memory usage:<br></p><p>func helloGenerator() -&gt; LazyCollection&lt;[String]&gt; {<br>    return [<br>        1GBAllocation(),<br>        1GBAllocation()<br>    ].lazy<br>}<br></p><p>vs<br></p><p>func helloGenerator() -&gt; SequenceType {<br>	yield 1GBAllocation()<br>	//allocation released<br>	yield 1GBAllocation()<br>}<br></p><p><br>&gt; On Dec 11, 2015, at 7:38 PM, Kametrixom Tikara via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What exactly is the difference to just returning a sequence?<br>&gt; <br>&gt; func helloGenerator(name : String?) -&gt; [String] {<br>&gt;     return [<br>&gt;         &quot;Hello&quot;,<br>&gt;         name ?? &quot;World&quot;<br>&gt;     ]<br>&gt; }<br>&gt; <br>&gt; for str in helloGenerator(&quot;David&quot;) {<br>&gt;     print(str)<br>&gt; }<br>&gt; <br>&gt; And if you want if lazy:<br>&gt; <br>&gt; func helloGenerator(name : String?) -&gt; LazyCollection&lt;[String]&gt; {<br>&gt;     return [<br>&gt;         &quot;Hello&quot;,<br>&gt;         name ?? &quot;World&quot;<br>&gt;     ].lazy<br>&gt; }<br>&gt; <br>&gt; Seems like exactly the same, except it doesn’t need two new keywords nor revamping of SequenceType/GeneratorType<br>&gt; <br>&gt;&gt; On 12 Dec 2015, at 01:21, David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Looking for feedback on crafting a proposal adding generator functions to Swift. I understand this will likely be a very involved proposal at the language level, although I actually don’t know the complexity of the change within the Swift compiler itself.<br>&gt;&gt; <br>&gt;&gt; This would be a function which returns multiple values, which is converted by the compiler to a function returning a SequenceType<br>&gt;&gt; <br>&gt;&gt; A very basic syntax would be to add generator as a modifier to func, and likely involve a new keyword ‘yield’ to differentiate from the flow control behavior of ‘return’.<br>&gt;&gt; <br>&gt;&gt; So for example:<br>&gt;&gt; <br>&gt;&gt; generator func helloGenerator(name:String?) -&gt; String {<br>&gt;&gt;     yield “Hello”<br>&gt;&gt;     yield name ?? “World”<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Would have the following expected usage:<br>&gt;&gt; <br>&gt;&gt; for str in helloGenerator(“David&quot;) {<br>&gt;&gt;    print str<br>&gt;&gt; // prints:<br>&gt;&gt; //    Hello<br>&gt;&gt; //    David<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; And for those unfamiliar to these sorts of simple cases, would have equivalent behavior to the following code:<br>&gt;&gt; <br>&gt;&gt;  45&gt; func helloGenerator(name:String?) -&gt; HelloGenerator { <br>&gt;&gt;  46.   return HelloGenerator(name) <br>&gt;&gt;  47. } <br>&gt;&gt;  48.  <br>&gt;&gt;  49. struct HelloGenerator : GeneratorType, SequenceType { <br>&gt;&gt;  50.    var position:Int = 0 <br>&gt;&gt;  51.    let name:String? <br>&gt;&gt;  52.  <br>&gt;&gt;  53.    private init(_ name:String?) { <br>&gt;&gt;  54.       self.name = name <br>&gt;&gt;  55.    } <br>&gt;&gt;  56.     <br>&gt;&gt;  57.    func generator() -&gt; HelloGenerator {<br>&gt;&gt;  58.        return self <br>&gt;&gt;  59.    } <br>&gt;&gt;  60.      <br>&gt;&gt;  61.    mutating func next() -&gt; String? { <br>&gt;&gt;  62.       switch position { <br>&gt;&gt;  63.       case 0: <br>&gt;&gt;  64.           position = 1 <br>&gt;&gt;  65.           return &quot;Hello&quot; <br>&gt;&gt;  66.       case 1: <br>&gt;&gt;  67.           position = 2 <br>&gt;&gt;  68.           return name ?? &quot;World&quot; <br>&gt;&gt;  69.       default: <br>&gt;&gt;  70.           return nil <br>&gt;&gt;  71.       } <br>&gt;&gt;  72.    } <br>&gt;&gt;  73. } <br>&gt;&gt; <br>&gt;&gt; This syntax has at a bare minimum issues with generator closures and for a terse syntax for yielding over another sequence type within a generator function vs. using a loop. (possibly “yield in sequenceName”)<br>&gt;&gt; <br>&gt;&gt; The interaction with the error system might involve disallowing throws from generator functions, or having the Element type be a Result&lt;T&gt; rather than T, as the GeneratorType next() method is not declared as throwing.<br>&gt;&gt; <br>&gt;&gt; This could pair well to make for-in loops more comprehensive, especially if C-style for loops are eliminated.<br>&gt;&gt; <br>&gt;&gt; This would possibly be a first step toward a coroutine-based concurrency system, although I am not proposing that sort of usage or scope here. The goal would be to emit an object compatible with SequenceType<br>&gt;&gt; <br>&gt;&gt; -David Waite (DW)<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/fb0e0b15/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a59b0df1d55761e4d340da93232790ea?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>Kevin Wooten</string> &lt;kdubb at me.com&gt;<p>December 11, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 6:38 PM, Kametrixom Tikara via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What exactly is the difference to just returning a sequence?<br>&gt; <br>&gt; func helloGenerator(name : String?) -&gt; [String] {<br>&gt;     return [<br>&gt;         &quot;Hello&quot;,<br>&gt;         name ?? &quot;World&quot;<br>&gt;     ]<br>&gt; }<br>&gt; <br>&gt; for str in helloGenerator(&quot;David&quot;) {<br>&gt;     print(str)<br>&gt; }<br>&gt; <br>&gt; And if you want if lazy:<br>&gt; <br>&gt; func helloGenerator(name : String?) -&gt; LazyCollection&lt;[String]&gt; {<br>&gt;     return [<br>&gt;         &quot;Hello&quot;,<br>&gt;         name ?? &quot;World&quot;<br>&gt;     ].lazy<br>&gt; }<br>&gt; <br></p><p>Imagine reading images from a directory and returning them lazily.  I don’t think anybody is arguing that you cannot implement it now with a special lazy collection (your version actually materializes the array fully first) but here’s how simple it could be:<br></p><p>func readAllImagesInDirectory(path: String) -&gt; GeneratorType&lt;Image&gt; {<br>	let imagePaths = listImagesInDirectory(path)<br>	return generator func generatorImage() -&gt; Image {<br>		for imagePath in imagePaths {<br>			yield readImageAtPath(image<br>		}<br>	}<br>}<br></p><p>(Please forgive any errant syntax in my contrived example).  Point is it could be a very fast/compact way to create generators; although it’s possible today.<br></p><p>&gt; Seems like exactly the same, except it doesn’t need two new keywords nor revamping of SequenceType/GeneratorType<br>&gt; <br>&gt;&gt; On 12 Dec 2015, at 01:21, David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Looking for feedback on crafting a proposal adding generator functions to Swift. I understand this will likely be a very involved proposal at the language level, although I actually don’t know the complexity of the change within the Swift compiler itself.<br>&gt;&gt; <br>&gt;&gt; This would be a function which returns multiple values, which is converted by the compiler to a function returning a SequenceType<br>&gt;&gt; <br>&gt;&gt; A very basic syntax would be to add generator as a modifier to func, and likely involve a new keyword ‘yield’ to differentiate from the flow control behavior of ‘return’.<br>&gt;&gt; <br>&gt;&gt; So for example:<br>&gt;&gt; <br>&gt;&gt; generator func helloGenerator(name:String?) -&gt; String {<br>&gt;&gt;     yield “Hello”<br>&gt;&gt;     yield name ?? “World”<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Would have the following expected usage:<br>&gt;&gt; <br>&gt;&gt; for str in helloGenerator(“David&quot;) {<br>&gt;&gt;    print str<br>&gt;&gt; // prints:<br>&gt;&gt; //    Hello<br>&gt;&gt; //    David<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; And for those unfamiliar to these sorts of simple cases, would have equivalent behavior to the following code:<br>&gt;&gt; <br>&gt;&gt;  45&gt; func helloGenerator(name:String?) -&gt; HelloGenerator { <br>&gt;&gt;  46.   return HelloGenerator(name) <br>&gt;&gt;  47. } <br>&gt;&gt;  48.  <br>&gt;&gt;  49. struct HelloGenerator : GeneratorType, SequenceType { <br>&gt;&gt;  50.    var position:Int = 0 <br>&gt;&gt;  51.    let name:String? <br>&gt;&gt;  52.  <br>&gt;&gt;  53.    private init(_ name:String?) { <br>&gt;&gt;  54.       self.name = name <br>&gt;&gt;  55.    } <br>&gt;&gt;  56.     <br>&gt;&gt;  57.    func generator() -&gt; HelloGenerator {<br>&gt;&gt;  58.        return self <br>&gt;&gt;  59.    } <br>&gt;&gt;  60.      <br>&gt;&gt;  61.    mutating func next() -&gt; String? { <br>&gt;&gt;  62.       switch position { <br>&gt;&gt;  63.       case 0: <br>&gt;&gt;  64.           position = 1 <br>&gt;&gt;  65.           return &quot;Hello&quot; <br>&gt;&gt;  66.       case 1: <br>&gt;&gt;  67.           position = 2 <br>&gt;&gt;  68.           return name ?? &quot;World&quot; <br>&gt;&gt;  69.       default: <br>&gt;&gt;  70.           return nil <br>&gt;&gt;  71.       } <br>&gt;&gt;  72.    } <br>&gt;&gt;  73. } <br>&gt;&gt; <br>&gt;&gt; This syntax has at a bare minimum issues with generator closures and for a terse syntax for yielding over another sequence type within a generator function vs. using a loop. (possibly “yield in sequenceName”)<br>&gt;&gt; <br>&gt;&gt; The interaction with the error system might involve disallowing throws from generator functions, or having the Element type be a Result&lt;T&gt; rather than T, as the GeneratorType next() method is not declared as throwing.<br>&gt;&gt; <br>&gt;&gt; This could pair well to make for-in loops more comprehensive, especially if C-style for loops are eliminated.<br>&gt;&gt; <br>&gt;&gt; This would possibly be a first step toward a coroutine-based concurrency system, although I am not proposing that sort of usage or scope here. The goal would be to emit an object compatible with SequenceType<br>&gt;&gt; <br>&gt;&gt; -David Waite (DW)<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/d10b28be/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4548eb4f3cff0c2a1cd388161f0ba001?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>Kametrixom Tikara</string> &lt;kametrixom at icloud.com&gt;<p>December 12, 2015 at 02:00:00am</p></header><div class="content"><p>My mistake, here is a truly lazy version (it gets a little ugly yes):<br></p><p>func helloGenerator(name : String?) -&gt; LazyMapCollection&lt;[() -&gt; String], String&gt; {<br>    return [<br>        { &quot;Hello&quot; },<br>        { name ?? &quot;World&quot; }<br>    ].lazy.map{ $0() }<br>}<br></p><p>I agree that this would make it very convenient. I’m +.5 on this, because I don’t like adding two more keywords for a single feature, but it seems like it has good applications<br></p><p>&gt; On 12 Dec 2015, at 02:50, Kevin Wooten &lt;kdubb at me.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 11, 2015, at 6:38 PM, Kametrixom Tikara via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What exactly is the difference to just returning a sequence?<br>&gt;&gt; <br>&gt;&gt; func helloGenerator(name : String?) -&gt; [String] {<br>&gt;&gt;     return [<br>&gt;&gt;         &quot;Hello&quot;,<br>&gt;&gt;         name ?? &quot;World&quot;<br>&gt;&gt;     ]<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; for str in helloGenerator(&quot;David&quot;) {<br>&gt;&gt;     print(str)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; And if you want if lazy:<br>&gt;&gt; <br>&gt;&gt; func helloGenerator(name : String?) -&gt; LazyCollection&lt;[String]&gt; {<br>&gt;&gt;     return [<br>&gt;&gt;         &quot;Hello&quot;,<br>&gt;&gt;         name ?? &quot;World&quot;<br>&gt;&gt;     ].lazy<br>&gt;&gt; }<br>&gt;&gt; <br>&gt; <br>&gt; Imagine reading images from a directory and returning them lazily.  I don’t think anybody is arguing that you cannot implement it now with a special lazy collection (your version actually materializes the array fully first) but here’s how simple it could be:<br>&gt; <br>&gt; func readAllImagesInDirectory(path: String) -&gt; GeneratorType&lt;Image&gt; {<br>&gt; 	let imagePaths = listImagesInDirectory(path)<br>&gt; 	return generator func generatorImage() -&gt; Image {<br>&gt; 		for imagePath in imagePaths {<br>&gt; 			yield readImageAtPath(image<br>&gt; 		}<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; (Please forgive any errant syntax in my contrived example).  Point is it could be a very fast/compact way to create generators; although it’s possible today.<br>&gt; <br>&gt;&gt; Seems like exactly the same, except it doesn’t need two new keywords nor revamping of SequenceType/GeneratorType<br>&gt;&gt; <br>&gt;&gt;&gt; On 12 Dec 2015, at 01:21, David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Looking for feedback on crafting a proposal adding generator functions to Swift. I understand this will likely be a very involved proposal at the language level, although I actually don’t know the complexity of the change within the Swift compiler itself.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would be a function which returns multiple values, which is converted by the compiler to a function returning a SequenceType<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A very basic syntax would be to add generator as a modifier to func, and likely involve a new keyword ‘yield’ to differentiate from the flow control behavior of ‘return’.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So for example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; generator func helloGenerator(name:String?) -&gt; String {<br>&gt;&gt;&gt;     yield “Hello”<br>&gt;&gt;&gt;     yield name ?? “World”<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would have the following expected usage:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for str in helloGenerator(“David&quot;) {<br>&gt;&gt;&gt;    print str<br>&gt;&gt;&gt; // prints:<br>&gt;&gt;&gt; //    Hello<br>&gt;&gt;&gt; //    David<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And for those unfamiliar to these sorts of simple cases, would have equivalent behavior to the following code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  45&gt; func helloGenerator(name:String?) -&gt; HelloGenerator { <br>&gt;&gt;&gt;  46.   return HelloGenerator(name) <br>&gt;&gt;&gt;  47. } <br>&gt;&gt;&gt;  48.  <br>&gt;&gt;&gt;  49. struct HelloGenerator : GeneratorType, SequenceType { <br>&gt;&gt;&gt;  50.    var position:Int = 0 <br>&gt;&gt;&gt;  51.    let name:String? <br>&gt;&gt;&gt;  52.  <br>&gt;&gt;&gt;  53.    private init(_ name:String?) { <br>&gt;&gt;&gt;  54.       self.name = name <br>&gt;&gt;&gt;  55.    } <br>&gt;&gt;&gt;  56.     <br>&gt;&gt;&gt;  57.    func generator() -&gt; HelloGenerator {<br>&gt;&gt;&gt;  58.        return self <br>&gt;&gt;&gt;  59.    } <br>&gt;&gt;&gt;  60.      <br>&gt;&gt;&gt;  61.    mutating func next() -&gt; String? { <br>&gt;&gt;&gt;  62.       switch position { <br>&gt;&gt;&gt;  63.       case 0: <br>&gt;&gt;&gt;  64.           position = 1 <br>&gt;&gt;&gt;  65.           return &quot;Hello&quot; <br>&gt;&gt;&gt;  66.       case 1: <br>&gt;&gt;&gt;  67.           position = 2 <br>&gt;&gt;&gt;  68.           return name ?? &quot;World&quot; <br>&gt;&gt;&gt;  69.       default: <br>&gt;&gt;&gt;  70.           return nil <br>&gt;&gt;&gt;  71.       } <br>&gt;&gt;&gt;  72.    } <br>&gt;&gt;&gt;  73. } <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This syntax has at a bare minimum issues with generator closures and for a terse syntax for yielding over another sequence type within a generator function vs. using a loop. (possibly “yield in sequenceName”)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The interaction with the error system might involve disallowing throws from generator functions, or having the Element type be a Result&lt;T&gt; rather than T, as the GeneratorType next() method is not declared as throwing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This could pair well to make for-in loops more comprehensive, especially if C-style for loops are eliminated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would possibly be a first step toward a coroutine-based concurrency system, although I am not proposing that sort of usage or scope here. The goal would be to emit an object compatible with SequenceType<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -David Waite (DW)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/ea9c2df2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 12, 2015 at 08:00:00am</p></header><div class="content"><p>Do we actually need the &quot;generator&quot; keyword? Why can&#39;t the compiler figure it out by the presence of yield?<br></p><p>And &quot;yield&quot; is a fairly standard keyword across languages, so no harm in claiming it, IMO.<br></p><p>+1 on the proposal.<br></p><p>A.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>December 11, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 6:03 PM, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Do we actually need the &quot;generator&quot; keyword? Why can&#39;t the compiler figure it out by the presence of yield?<br></p><p>I think you need some explicit marker. Consider the following:<br></p><p>    func f() -&gt; Int {<br>        return<br>    }<br></p><p>Is this (1) a generator that returns without yielding anything, or (2) an ordinary function that incorrectly fails to return a value?<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 12, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; I think you need some explicit marker. Consider the following:<br>&gt; <br>&gt;    func f() -&gt; Int {<br>&gt;        return<br>&gt;    }<br>&gt; <br>&gt; Is this (1) a generator that returns without yielding anything, or (2) an ordinary function that incorrectly fails to return a value?<br></p><p>Perhaps that&#39;s too much magic, and generator functions should explicitly declare the return type of GeneratorType&lt;Xxx&gt;. Being a generator is an implementation detail, after all.<br></p><p>Also, I&#39;m not sure than a statically empty generator function is a useful concept. You could just say that without a yield, it&#39;s not a generator, period.<br></p><p>A.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 11, 2015 at 06:00:00pm</p></header><div class="content"><p>It&#39;s desireable for the signature of a function to be fully checkable without looking at the body, for a number of reasons. It&#39;s also something clients of a library will want to know, so it needs to be displayed in the library&#39;s interface somehow.<br></p><p>Jordan<br></p><p><br>&gt; On Dec 11, 2015, at 18:03 , Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Do we actually need the &quot;generator&quot; keyword? Why can&#39;t the compiler figure it out by the presence of yield?<br>&gt; <br>&gt; And &quot;yield&quot; is a fairly standard keyword across languages, so no harm in claiming it, IMO.<br>&gt; <br>&gt; +1 on the proposal.<br>&gt; <br>&gt; A.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/8adffa5c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 11, 2015 at 06:00:00pm</p></header><div class="content"><p>Another possible syntax, inspired by &quot;throws&quot;.<br></p><p>func foo() yield -&gt; String<br></p><p>I&#39;m not sure what happens if a function both yields and throws. I guess that can&#39;t happen right now because generators are required not to throw when producing their next() value.<br></p><p>Jordan<br></p><p>&gt; On Dec 11, 2015, at 18:14 , Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; It&#39;s desireable for the signature of a function to be fully checkable without looking at the body, for a number of reasons. It&#39;s also something clients of a library will want to know, so it needs to be displayed in the library&#39;s interface somehow.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 18:03 , Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Do we actually need the &quot;generator&quot; keyword? Why can&#39;t the compiler figure it out by the presence of yield?<br>&gt;&gt; <br>&gt;&gt; And &quot;yield&quot; is a fairly standard keyword across languages, so no harm in claiming it, IMO.<br>&gt;&gt; <br>&gt;&gt; +1 on the proposal.<br>&gt;&gt; <br>&gt;&gt; A.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/9ae72931/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 12, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; Another possible syntax, inspired by &quot;throws&quot;.<br>&gt; <br>&gt; func foo() yield -&gt; String<br></p><p>Well, again, yielding is an implementation detail. What&#39;s the advantage vs returning Generator&lt;String&gt;? I don&#39;t think that lying about the return type is useful for anyone.<br></p><p>&gt; I&#39;m not sure what happens if a function both yields and throws.<br></p><p>An excellent question. We&#39;d need another generator type with &quot;next() throws&quot;.<br></p><p>A.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/cfec423a/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 11, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 18:20 , Andrey Tarantsov &lt;andrey at tarantsov.com&gt; wrote:<br>&gt; <br>&gt;&gt; Another possible syntax, inspired by &quot;throws&quot;.<br>&gt;&gt; <br>&gt;&gt; func foo() yield -&gt; String<br>&gt; <br>&gt; Well, again, yielding is an implementation detail. What&#39;s the advantage vs returning Generator&lt;String&gt;? I don&#39;t think that lying about the return type is useful for anyone.<br></p><p>Well, just returning &quot;Generator&lt;String&gt;&quot; doesn&#39;t distinguish this from a normal function that just returns a generator. Also, &quot;Generator&quot; is a protocol with an associated type, so you can&#39;t use it as a value type (yet?). Today you&#39;d have to manually type-erase using the AnyGenerator wrapper. That also makes it harder to optimize, since clients won&#39;t know what kind of generator you&#39;re using. (Maybe that&#39;s a feature, though; it lets you change the implementation in the future. I guess it could make sense to have the interface show the &quot;real&quot; generator return type even if the source shows the element type.)<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/aeff7d3c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/61411a09f1846dd6533e84dca60232aa?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>Jonathan Hise Kaldma</string> &lt;info at hisekaldma.com&gt;<p>December 12, 2015 at 03:00:00am</p></header><div class="content"><p>Shouldn&#39;t it be:<br></p><p>func foo() yields -&gt; String<br></p><p>Also +1 on the idea.<br></p><p>/Jonathan<br></p><p>&gt; 12 dec. 2015 kl. 03:18 skrev Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Another possible syntax, inspired by &quot;throws&quot;.<br>&gt; <br>&gt; func foo() yield -&gt; String<br>&gt; <br>&gt; I&#39;m not sure what happens if a function both yields and throws. I guess that can&#39;t happen right now because generators are required not to throw when producing their next() value.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 18:14 , Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It&#39;s desireable for the signature of a function to be fully checkable without looking at the body, for a number of reasons. It&#39;s also something clients of a library will want to know, so it needs to be displayed in the library&#39;s interface somehow.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 11, 2015, at 18:03 , Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Do we actually need the &quot;generator&quot; keyword? Why can&#39;t the compiler figure it out by the presence of yield?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And &quot;yield&quot; is a fairly standard keyword across languages, so no harm in claiming it, IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 on the proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/8a2fc924/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 11, 2015 at 06:00:00pm</p></header><div class="content"><p>Eh, I was trying to avoid grabbing another keyword, but I guess it&#39;s context-sensitive anyway.<br></p><p>&gt; On Dec 11, 2015, at 18:26 , Jonathan Hise Kaldma &lt;info at hisekaldma.com&gt; wrote:<br>&gt; <br>&gt; Shouldn&#39;t it be:<br>&gt; <br>&gt; func foo() yields -&gt; String<br>&gt; <br>&gt; Also +1 on the idea.<br>&gt; <br>&gt; /Jonathan<br>&gt; <br>&gt; 12 dec. 2015 kl. 03:18 skrev Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; Another possible syntax, inspired by &quot;throws&quot;.<br>&gt;&gt; <br>&gt;&gt; func foo() yield -&gt; String<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure what happens if a function both yields and throws. I guess that can&#39;t happen right now because generators are required not to throw when producing their next() value.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 11, 2015, at 18:14 , Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s desireable for the signature of a function to be fully checkable without looking at the body, for a number of reasons. It&#39;s also something clients of a library will want to know, so it needs to be displayed in the library&#39;s interface somehow.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 11, 2015, at 18:03 , Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Do we actually need the &quot;generator&quot; keyword? Why can&#39;t the compiler figure it out by the presence of yield?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And &quot;yield&quot; is a fairly standard keyword across languages, so no harm in claiming it, IMO.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1 on the proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/83bf8441/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 11, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 6:26 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Eh, I was trying to avoid grabbing another keyword, but I guess it&#39;s context-sensitive anyway.<br></p><p>I&#39;ve thought about this some. It might not have to be a keyword, if this were a generalized language feature. Anything that interrupts control flow and optionally resumes it later, such as &#39;throws&#39;, &#39;yields&#39;, and potentially also &#39;async&#39;, could be implemented as instances of algebraic effects. As a rough sketch of an idea, you could declare an effect and its operations:<br></p><p>effect throws { @noreturn operation throw (ErrorType) -&gt; () }<br>effect yields&lt;T&gt; { operation yield (T) -&gt; () }<br>effect awaits { operation await&lt;T&gt; (Promise&lt;T&gt;) -&gt; T }<br></p><p>and &#39;catch&#39; could be generalized to let you handle any effect operations that might be performed in the body of a block:<br></p><p>class Generator&lt;T&gt; {<br>	var generator: () yields&lt;T&gt; -&gt; ()<br>	func next() -&gt; T? {<br>		do {<br>  			generator()<br>			return nil<br>		} catch yield (let x) {<br>			generator = currentContinuation<br>			return x<br>		}<br>	}<br>}<br></p><p>See Eff (http://www.eff-lang.org) for an example of a language with this already implemented.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/73ab3cf9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a1cec0edd417a75c5809cae4cd1feaa7?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>Alex Gordon</string> &lt;alextgordon at gmail.com&gt;<p>December 12, 2015 at 03:00:00am</p></header><div class="content"><p>IMO the yields should be literally *in* the return type. The present state<br>of things is<br></p><p>fn countToTen() -&gt; CountToTenGenerator<br></p><p>Generator functions are normal functions. What is special about them is<br>that instead of returning a named type such as &quot;CountToTenGenerator&quot;, the<br>compiler replaces the return type with an anonymous type conforming to<br>GeneratorType. So conceptually it&#39;s the return type that is special, not<br>the function.<br></p><p>Try either one of these for size<br></p><p>fn countToTen() -&gt; yields Int {<br>fn countToTen() -&gt; yields&lt;Int&gt; {<br></p><p>- Alex<br></p><p>On Sat, Dec 12, 2015 at 3:17 AM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 11, 2015, at 6:26 PM, Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Eh, I was trying to avoid grabbing another keyword, but I guess it&#39;s<br>&gt; context-sensitive anyway.<br>&gt;<br>&gt;<br>&gt; I&#39;ve thought about this some. It might not have to be a keyword, if this<br>&gt; were a generalized language feature. Anything that interrupts control flow<br>&gt; and optionally resumes it later, such as &#39;throws&#39;, &#39;yields&#39;, and<br>&gt; potentially also &#39;async&#39;, could be implemented as instances of algebraic<br>&gt; effects. As a rough sketch of an idea, you could declare an effect and its<br>&gt; operations:<br>&gt;<br>&gt; effect throws { @noreturn operation throw (ErrorType) -&gt; () }<br>&gt; effect yields&lt;T&gt; { operation yield (T) -&gt; () }<br>&gt; effect awaits { operation await&lt;T&gt; (Promise&lt;T&gt;) -&gt; T }<br>&gt;<br>&gt; and &#39;catch&#39; could be generalized to let you handle any effect operations<br>&gt; that might be performed in the body of a block:<br>&gt;<br>&gt; class Generator&lt;T&gt; {<br>&gt; var generator: () yields&lt;T&gt; -&gt; ()<br>&gt; func next() -&gt; T? {<br>&gt; do {<br>&gt;    generator()<br>&gt; return nil<br>&gt; } catch yield (let x) {<br>&gt; generator = currentContinuation<br>&gt; return x<br>&gt; }<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; See Eff (http://www.eff-lang.org) for an example of a language with this<br>&gt; already implemented.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/08e9c753/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a59b0df1d55761e4d340da93232790ea?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>Kevin Wooten</string> &lt;kdubb at me.com&gt;<p>December 11, 2015 at 10:00:00pm</p></header><div class="content"><p>I really like this form…  <br></p><p>    func countToTen() -&gt; yields Int { yield 1; yield 2 }<br></p><p>It reads well and states clearly what it’s intent is.<br></p><p>Works/reads well with ‘throws’...<br></p><p>    func countToTen() throws -&gt; yields Int {}<br></p><p>And there must be some advantage to claiming two keywords that are nearly identical, ‘yield’ &amp; ‘yields’.<br></p><p>&gt; On Dec 11, 2015, at 8:45 PM, Alex Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; IMO the yields should be literally *in* the return type. The present state of things is<br>&gt; <br>&gt; fn countToTen() -&gt; CountToTenGenerator<br>&gt; <br>&gt; Generator functions are normal functions. What is special about them is that instead of returning a named type such as &quot;CountToTenGenerator&quot;, the compiler replaces the return type with an anonymous type conforming to GeneratorType. So conceptually it&#39;s the return type that is special, not the function.<br>&gt; <br>&gt; Try either one of these for size<br>&gt; <br>&gt; fn countToTen() -&gt; yields Int {<br>&gt; fn countToTen() -&gt; yields&lt;Int&gt; {<br>&gt; <br>&gt; - Alex<br>&gt; <br>&gt; On Sat, Dec 12, 2015 at 3:17 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 6:26 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Eh, I was trying to avoid grabbing another keyword, but I guess it&#39;s context-sensitive anyway.<br>&gt; <br>&gt; I&#39;ve thought about this some. It might not have to be a keyword, if this were a generalized language feature. Anything that interrupts control flow and optionally resumes it later, such as &#39;throws&#39;, &#39;yields&#39;, and potentially also &#39;async&#39;, could be implemented as instances of algebraic effects. As a rough sketch of an idea, you could declare an effect and its operations:<br>&gt; <br>&gt; effect throws { @noreturn operation throw (ErrorType) -&gt; () }<br>&gt; effect yields&lt;T&gt; { operation yield (T) -&gt; () }<br>&gt; effect awaits { operation await&lt;T&gt; (Promise&lt;T&gt;) -&gt; T }<br>&gt; <br>&gt; and &#39;catch&#39; could be generalized to let you handle any effect operations that might be performed in the body of a block:<br>&gt; <br>&gt; class Generator&lt;T&gt; {<br>&gt; 	var generator: () yields&lt;T&gt; -&gt; ()<br>&gt; 	func next() -&gt; T? {<br>&gt; 		do {<br>&gt;   			generator()<br>&gt; 			return nil<br>&gt; 		} catch yield (let x) {<br>&gt; 			generator = currentContinuation<br>&gt; 			return x<br>&gt; 		}<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; See Eff (http://www.eff-lang.org &lt;http://www.eff-lang.org/&gt;) for an example of a language with this already implemented.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/9932a68c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>December 12, 2015 at 12:00:00pm</p></header><div class="content"><p>This feature (set) as sketched here by Joe is worthwhile, in my opinion.<br>The use of catch fits in and effect neatly captures this class of behaviors.<br>+1 for `effect`<br>---<br>TJ<br></p><p>On Sat, Dec 12, 2015 at 4:17 AM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 11, 2015, at 6:26 PM, Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Eh, I was trying to avoid grabbing another keyword, but I guess it&#39;s<br>&gt; context-sensitive anyway.<br>&gt;<br>&gt;<br>&gt; I&#39;ve thought about this some. It might not have to be a keyword, if this<br>&gt; were a generalized language feature. Anything that interrupts control flow<br>&gt; and optionally resumes it later, such as &#39;throws&#39;, &#39;yields&#39;, and<br>&gt; potentially also &#39;async&#39;, could be implemented as instances of algebraic<br>&gt; effects. As a rough sketch of an idea, you could declare an effect and its<br>&gt; operations:<br>&gt;<br>&gt; effect throws { @noreturn operation throw (ErrorType) -&gt; () }<br>&gt; effect yields&lt;T&gt; { operation yield (T) -&gt; () }<br>&gt; effect awaits { operation await&lt;T&gt; (Promise&lt;T&gt;) -&gt; T }<br>&gt;<br>&gt; and &#39;catch&#39; could be generalized to let you handle any effect operations<br>&gt; that might be performed in the body of a block:<br>&gt;<br>&gt; class Generator&lt;T&gt; {<br>&gt; var generator: () yields&lt;T&gt; -&gt; ()<br>&gt; func next() -&gt; T? {<br>&gt; do {<br>&gt;    generator()<br>&gt; return nil<br>&gt; } catch yield (let x) {<br>&gt; generator = currentContinuation<br>&gt; return x<br>&gt; }<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; See Eff (http://www.eff-lang.org) for an example of a language with this<br>&gt; already implemented.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/bc9afe69/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December 12, 2015 at 11:00:00pm</p></header><div class="content"><p>I like this idea, as long as it is kept small in scope, only the<br>introduction of a yield implemented as something conforming to SequenceType.<br></p><p>You can get fairly concise syntax already with anySequence and AnyGenerator:<br></p><p>func fibonacci() -&gt; AnySequence&lt;Int&gt; {<br></p><p>    return AnySequence&lt;Int&gt; { () -&gt; AnyGenerator&lt;Int&gt; in<br></p><p>        var (i, j) = (0, 1)<br></p><p>        return anyGenerator {<br></p><p>            (i, j) = (j, i + j)<br></p><p>            return i<br></p><p>        }<br></p><p>    }<br></p><p>}<br></p><p><br>But state management is more involved.<br></p><p>To implement this I guess you&#39;d have to look at each yield statement and<br>work out what state it can have, something like this:<br></p><p>func test() -&gt; AnySequence&lt;Int&gt; {<br></p><p>    var j = 0<br></p><p>    for i in 1 ... 5 {<br></p><p>        j += i<br></p><p>        yield j<br></p><p>    }<br></p><p>    yield j<br></p><p>    return j+1<br></p><p>}<br></p><p><br>becomes:<br></p><p><br>func test() -&gt; AnySequence&lt;Int&gt; {<br></p><p>    return AnySequence&lt;Int&gt; { () -&gt; AnyGenerator&lt;Int&gt; in<br></p><p>        var state: YieldState_test = .Yield0(j: 0, i: 1)<br></p><p>        return anyGenerator { () -&gt; Int? in<br></p><p>            switch state {<br></p><p>            case let .Yield0(j: j, i: i):<br></p><p>                let j_ = i + j, i_ = i+1<br></p><p>                state = (i_ &lt;= 5) ? .Yield0(j: j_, i: i_) : .Yield1(j: j_)<br></p><p>                return j_<br></p><p>            case let .Yield1(j: j):<br></p><p>                state = .Return0(j)<br></p><p>                return j<br></p><p>            case let .Return0(r):<br></p><p>                state = .Complete<br></p><p>                return r+1<br></p><p>            case .Complete:<br></p><p>                return nil<br></p><p>            }<br></p><p>        }<br></p><p>    }<br></p><p>}<br></p><p><br></p><p>On Sat, Dec 12, 2015 at 10:20 PM, T.J. Usiyan via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This feature (set) as sketched here by Joe is worthwhile, in my opinion.<br>&gt; The use of catch fits in and effect neatly captures this class of behaviors.<br>&gt; +1 for `effect`<br>&gt; ---<br>&gt; TJ<br>&gt;<br>&gt; On Sat, Dec 12, 2015 at 4:17 AM, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 11, 2015, at 6:26 PM, Jordan Rose via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Eh, I was trying to avoid grabbing another keyword, but I guess it&#39;s<br>&gt;&gt; context-sensitive anyway.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;ve thought about this some. It might not have to be a keyword, if this<br>&gt;&gt; were a generalized language feature. Anything that interrupts control flow<br>&gt;&gt; and optionally resumes it later, such as &#39;throws&#39;, &#39;yields&#39;, and<br>&gt;&gt; potentially also &#39;async&#39;, could be implemented as instances of algebraic<br>&gt;&gt; effects. As a rough sketch of an idea, you could declare an effect and its<br>&gt;&gt; operations:<br>&gt;&gt;<br>&gt;&gt; effect throws { @noreturn operation throw (ErrorType) -&gt; () }<br>&gt;&gt; effect yields&lt;T&gt; { operation yield (T) -&gt; () }<br>&gt;&gt; effect awaits { operation await&lt;T&gt; (Promise&lt;T&gt;) -&gt; T }<br>&gt;&gt;<br>&gt;&gt; and &#39;catch&#39; could be generalized to let you handle any effect operations<br>&gt;&gt; that might be performed in the body of a block:<br>&gt;&gt;<br>&gt;&gt; class Generator&lt;T&gt; {<br>&gt;&gt; var generator: () yields&lt;T&gt; -&gt; ()<br>&gt;&gt; func next() -&gt; T? {<br>&gt;&gt; do {<br>&gt;&gt;    generator()<br>&gt;&gt; return nil<br>&gt;&gt; } catch yield (let x) {<br>&gt;&gt; generator = currentContinuation<br>&gt;&gt; return x<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; See Eff (http://www.eff-lang.org) for an example of a language with this<br>&gt;&gt; already implemented.<br>&gt;&gt;<br>&gt;&gt; -Joe<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/e18c1798/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 11, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 7:18 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Another possible syntax, inspired by &quot;throws&quot;.<br>&gt; <br>&gt; func foo() yield -&gt; String<br></p><p>Yes, I also suspect that would play better with generators from closures. <br></p><p>&gt; I&#39;m not sure what happens if a function both yields and throws. I guess that can&#39;t happen right now because generators are required not to throw when producing their next() value.<br></p><p>The only way I’ve thought of so far is to have the next iteration return Either a correct value or an ErrorType - probably through a Result enum. Unlike Optional however, there doesn’t seem to be a monadic way to represent possibly errored states - you are meant to use do/try/throw/catch. <br></p><p>-DW<br></p><p>&gt; <br>&gt; Jordan<br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 18:14 , Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It&#39;s desireable for the signature of a function to be fully checkable without looking at the body, for a number of reasons. It&#39;s also something clients of a library will want to know, so it needs to be displayed in the library&#39;s interface somehow.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 11, 2015, at 18:03 , Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Do we actually need the &quot;generator&quot; keyword? Why can&#39;t the compiler figure it out by the presence of yield?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And &quot;yield&quot; is a fairly standard keyword across languages, so no harm in claiming it, IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 on the proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/dd8b02d9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 11, 2015 at 10:00:00pm</p></header><div class="content"><p>I’d be more than happy with alternative syntax (and would be surprised if there aren’t several proposals from this list worth consideration), but thats perhaps more of a bike shed issue compared to whether or not the feature itself is desired and in scope.<br></p><p>-DW<br></p><p>&gt; On Dec 11, 2015, at 6:58 PM, Kametrixom Tikara &lt;kametrixom at icloud.com&gt; wrote:<br>&gt; <br>&gt; I agree that this would make it very convenient. I’m +.5 on this, because I don’t like adding two more keywords for a single feature, but it seems like it has good applications<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 11, 2015 at 10:00:00pm</p></header><div class="content"><p>It is tough to give examples which are suitably approachable, illustrative, and complex. Perhaps the Fibonacci sequence:<br></p><p>generator func fibonacci() -&gt; Int {<br>   var = 0, j = 1<br>   repeat {<br>      (i, j) = (j, i + j)<br>      yield i<br>   }<br>}<br></p><p>In addition to being a more complex problem, the sequence is also infinite. Luckily the functional influences on sequences let you deal with that without issue:<br></p><p>// print the first 25 numbers in the fibonacci sequence<br>fibonacci().prefix(25).forEach { print($0) }<br></p><p>-DW<br></p><p>&gt; On Dec 11, 2015, at 6:38 PM, Kametrixom Tikara &lt;kametrixom at icloud.com&gt; wrote:<br>&gt; <br>&gt; What exactly is the difference to just returning a sequence?<br>&gt; <br>&gt; func helloGenerator(name : String?) -&gt; [String] {<br>&gt;     return [<br>&gt;         &quot;Hello&quot;,<br>&gt;         name ?? &quot;World&quot;<br>&gt;     ]<br>&gt; }<br>&gt; <br>&gt; for str in helloGenerator(&quot;David&quot;) {<br>&gt;     print(str)<br>&gt; }<br>&gt; <br>&gt; And if you want if lazy:<br>&gt; <br>&gt; func helloGenerator(name : String?) -&gt; LazyCollection&lt;[String]&gt; {<br>&gt;     return [<br>&gt;         &quot;Hello&quot;,<br>&gt;         name ?? &quot;World&quot;<br>&gt;     ].lazy<br>&gt; }<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/0fb12aad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 12, 2015 at 01:00:00pm</p></header><div class="content"><p>I&#39;m still not sold on the generate keyword; this syntax (once it works)<br>seems clear enough for me:<br></p><p>func fibonacci() -&gt; SequenceType&lt;Int&gt; {<br>   var (i, j) = (0, 1)<br>   repeat {<br>      (i, j) = (j, i + j)<br>      yield i<br>   }<br>}<br></p><p>The intent is hard to miss: this function returns something that satisfies<br>a specialization of SequenceType to type Int. The function can do this<br>either<br></p><p>(1) by returning a valid SequenceType struct/class object,<br>(2) by doing a simple return, in which case compiler impements an empty<br>sequence behind the scenes, or<br>(3) by inserting a few yield operators before doing (1) or (2), in which<br>case the compiler creates an appropriate generator struct<br></p><p>Whether the function goes the route (1), (2) or (3) is an implementation<br>detail of no import to its users.<br></p><p>On Sat, Dec 12, 2015 at 8:46 AM, David Waite via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; It is tough to give examples which are suitably approachable,<br>&gt; illustrative, and complex. Perhaps the Fibonacci sequence:<br>&gt;<br>&gt; generator func fibonacci() -&gt; Int {<br>&gt;    var = 0, j = 1<br>&gt;    repeat {<br>&gt;       (i, j) = (j, i + j)<br>&gt;       yield i<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; In addition to being a more complex problem, the sequence is also<br>&gt; infinite. Luckily the functional influences on sequences let you deal with<br>&gt; that without issue:<br>&gt;<br>&gt; // print the first 25 numbers in the fibonacci sequence<br>&gt;<br>&gt; fibonacci().prefix(25).forEach { print($0) }<br>&gt;<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt; On Dec 11, 2015, at 6:38 PM, Kametrixom Tikara &lt;kametrixom at icloud.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; What exactly is the difference to just returning a sequence?<br>&gt;<br>&gt; func helloGenerator(name : String?) -&gt; [String] {<br>&gt;     return [<br>&gt;         &quot;Hello&quot;,<br>&gt;         name ?? &quot;World&quot;<br>&gt;     ]<br>&gt; }<br>&gt;<br>&gt; for str in helloGenerator(&quot;David&quot;) {<br>&gt;     print(str)<br>&gt; }<br>&gt;<br>&gt; And if you want if lazy:<br>&gt;<br>&gt; func helloGenerator(name : String?) -&gt; LazyCollection&lt;[String]&gt; {<br>&gt;     return [<br>&gt;         &quot;Hello&quot;,<br>&gt;         name ?? &quot;World&quot;<br>&gt;     ].lazy<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/ec637aff/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 11, 2015 at 10:00:00pm</p></header><div class="content"><p>I&#39;d love to have first-class support for generators like this, but it&#39;s<br>a *lot* of work. It&#39;s a lot easier to do this sort of thing in a<br>scripting language like Python than it is to do in a language like<br>Swift, because it requires reifying the stack into a data structure that<br>can be passed around. And I suspect there&#39;s a lot of non-trivial<br>questions that have to get answered before you can even propose an<br>implementation for this.<br></p><p>For context, this sort of thing is something that people have been<br>talking about doing in Rust for quite a while, and it keeps getting<br>punted because of the amount of work and the unanswered questions about<br>how it would actually be implemented.<br></p><p>So I&#39;ll give this a general +1, but I think it should also be deferred<br>until after Swift 3 at the earliest.<br></p><p>-Kevin<br></p><p>On Fri, Dec 11, 2015, at 04:21 PM, David Waite via swift-evolution wrote:<br>&gt; Looking for feedback on crafting a proposal adding generator functions<br>&gt; to Swift. I understand this will likely be a very involved proposal at<br>&gt; the language level, although I actually don’t know the complexity of<br>&gt; the change within the Swift compiler itself.<br>&gt;<br>&gt; This would be a function which returns multiple values, which is<br>&gt; converted by the compiler to a function returning a SequenceType<br>&gt;<br>&gt; A very basic syntax would be to add generator as a modifier to func,<br>&gt; and likely involve a new keyword ‘yield’ to differentiate from the<br>&gt; flow control behavior of ‘return’.<br>&gt;<br>&gt; So for example:<br>&gt;<br>&gt;&gt; generator func helloGenerator(name:String?) -&gt; String {    yield<br>&gt;&gt; “Hello”    yield name ?? “World” }<br>&gt;<br>&gt; Would have the following expected usage:<br>&gt;<br>&gt;&gt; for str in helloGenerator(“David&quot;) {   print str // prints: //<br>&gt;&gt; Hello //    David }<br>&gt;<br>&gt; And for those unfamiliar to these sorts of simple cases, would have<br>&gt; equivalent behavior to the following code:<br>&gt;<br>&gt;&gt; 45&gt; func helloGenerator(name:String?) -&gt; HelloGenerator { 46.<br>&gt;&gt; return HelloGenerator(name) 47. } 48. 49. struct HelloGenerator :<br>&gt;&gt; GeneratorType, SequenceType { 50.    var position:Int = 0 51.    let<br>&gt;&gt; name:String? 52. 53.    private init(_ name:String?) { 54.<br>&gt;&gt; self.name = name 55.    } 56. 57.    func generator() -&gt;<br>&gt;&gt; HelloGenerator { 58.        return self 59.    } 60. 61.    mutating<br>&gt;&gt; func next() -&gt; String? { 62.       switch position { 63.       case<br>&gt;&gt; 0: 64.           position = 1 65.           return &quot;Hello&quot; 66.<br>&gt;&gt; case 1: 67.           position = 2 68.           return name ??<br>&gt;&gt; &quot;World&quot; 69.       default: 70.           return nil 71.       } 72.<br>&gt;&gt; } 73. }<br>&gt;&gt;<br>&gt; This syntax has at a bare minimum issues with generator closures and<br>&gt; for a terse syntax for yielding over another sequence type within a<br>&gt; generator function vs. using a loop. (possibly “yield in<br>&gt; sequenceName”)<br>&gt;<br>&gt; The interaction with the error system might involve disallowing throws<br>&gt; from generator functions, or having the Element type be a Result&lt;T&gt;<br>&gt; rather than T, as the GeneratorType next() method is not declared as<br>&gt; throwing.<br>&gt;<br>&gt; This could pair well to make for-in loops more comprehensive,<br>&gt; especially if C-style for loops are eliminated.<br>&gt;<br>&gt; This would possibly be a first step toward a coroutine-based<br>&gt; concurrency system, although I am not proposing that sort of usage or<br>&gt; scope here. The goal would be to emit an object compatible with<br>&gt; SequenceType<br>&gt;<br>&gt; -David Waite (DW)<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/d7930a2d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 12, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 10:48 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;d love to have first-class support for generators like this, but it&#39;s a lot of work. It&#39;s a lot easier to do this sort of thing in a scripting language like Python than it is to do in a language like Swift, because it requires reifying the stack into a data structure that can be passed around. And I suspect there&#39;s a lot of non-trivial questions that have to get answered before you can even propose an implementation for this.<br>&gt;  <br>&gt; For context, this sort of thing is something that people have been talking about doing in Rust for quite a while, and it keeps getting punted because of the amount of work and the unanswered questions about how it would actually be implemented.<br>&gt;  <br>&gt; So I&#39;ll give this a general +1, but I think it should also be deferred until after Swift 3 at the earliest.<br></p><p>Right. This is a major add-on feature that doesn’t fit in with the stated goals for Swift 3 (README of https://github.com/apple/swift-evolution &lt;https://github.com/apple/swift-evolution&gt;), so I think we should proactively defer it.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/6d511491/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 12, 2015 at 02:00:00pm</p></header><div class="content"><p>I proposed it because <br>- Only a few named language features (like Concurrency) were explicit non-goals<br>- Its a feature I’m willing to try to implement (although I would probably want to work on several smaller changes to get up to speed first on SIL and the codebase)<br></p><p>Is there a possibility for larger features like this or macros to be done in parallel with the 2.2/3.0 development effort? Or perhaps a desire to have this sort of working group approach (similar to C++’s Technical Subcommittees), but not until 3.0 is released?<br></p><p>-DW<br></p><p>&gt; On Dec 12, 2015, at 1:35 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 10:48 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;d love to have first-class support for generators like this, but it&#39;s a lot of work. It&#39;s a lot easier to do this sort of thing in a scripting language like Python than it is to do in a language like Swift, because it requires reifying the stack into a data structure that can be passed around. And I suspect there&#39;s a lot of non-trivial questions that have to get answered before you can even propose an implementation for this.<br>&gt;&gt;  <br>&gt;&gt; For context, this sort of thing is something that people have been talking about doing in Rust for quite a while, and it keeps getting punted because of the amount of work and the unanswered questions about how it would actually be implemented.<br>&gt;&gt;  <br>&gt;&gt; So I&#39;ll give this a general +1, but I think it should also be deferred until after Swift 3 at the earliest.<br>&gt; <br>&gt; Right. This is a major add-on feature that doesn’t fit in with the stated goals for Swift 3 (README of https://github.com/apple/swift-evolution &lt;https://github.com/apple/swift-evolution&gt;), so I think we should proactively defer it.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/d82411f3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a1cec0edd417a75c5809cae4cd1feaa7?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>Alex Gordon</string> &lt;alextgordon at gmail.com&gt;<p>December 13, 2015 at 04:00:00am</p></header><div class="content"><p>&gt; Is there a possibility for larger features like this or macros to be done<br>in parallel with the 2.2/3.0 development effort? Or perhaps a desire to<br>have this sort of working group approach (similar to C++’s Technical<br>Subcommittees), but not until 3.0 is released?<br></p><p>It&#39;s open source! Just make a public fork on GitHub, then other people can<br>contribute if they desire. Discussion can take place on a separate GitHub<br>issues if it would be too speculative for this list (can anything be too<br>speculative for this list?).<br></p><p>The main problem right now seems to be that nobody has any clue how to even<br>implement it.<br></p><p>- Alex<br></p><p>On Sat, Dec 12, 2015 at 9:36 PM, David Waite via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I proposed it because<br>&gt; - Only a few named language features (like Concurrency) were explicit<br>&gt; non-goals<br>&gt; - Its a feature I’m willing to try to implement (although I would probably<br>&gt; want to work on several smaller changes to get up to speed first on SIL and<br>&gt; the codebase)<br>&gt;<br>&gt; Is there a possibility for larger features like this or macros to be done<br>&gt; in parallel with the 2.2/3.0 development effort? Or perhaps a desire to<br>&gt; have this sort of working group approach (similar to C++’s Technical<br>&gt; Subcommittees), but not until 3.0 is released?<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt; On Dec 12, 2015, at 1:35 PM, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Dec 11, 2015, at 10:48 PM, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I&#39;d love to have first-class support for generators like this, but it&#39;s a<br>&gt; *lot* of work. It&#39;s a lot easier to do this sort of thing in a scripting<br>&gt; language like Python than it is to do in a language like Swift, because it<br>&gt; requires reifying the stack into a data structure that can be passed<br>&gt; around. And I suspect there&#39;s a lot of non-trivial questions that have to<br>&gt; get answered before you can even propose an implementation for this.<br>&gt;<br>&gt; For context, this sort of thing is something that people have been talking<br>&gt; about doing in Rust for quite a while, and it keeps getting punted because<br>&gt; of the amount of work and the unanswered questions about how it would<br>&gt; actually be implemented.<br>&gt;<br>&gt; So I&#39;ll give this a general +1, but I think it should also be deferred<br>&gt; until after Swift 3 at the earliest.<br>&gt;<br>&gt;<br>&gt; Right. This is a major add-on feature that doesn’t fit in with the stated<br>&gt; goals for Swift 3 (README of https://github.com/apple/swift-evolution),<br>&gt; so I think we should proactively defer it.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/559a37af/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 14, 2015 at 03:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>On Dec 12, 2015, at 1:36 PM, David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt; wrote:<br></p><p>&gt; I proposed it because <br>&gt; - Only a few named language features (like Concurrency) were explicit non-goals<br>&gt; - Its a feature I’m willing to try to implement (although I would probably want to work on several smaller changes to get up to speed first on SIL and the codebase)<br>&gt; <br>&gt; Is there a possibility for larger features like this or macros to be done in parallel with the 2.2/3.0 development effort?<br></p><p>Yes, design and experimental implementation can certainly proceed on the side. However, we are bandwidth-constrained on how much design we can do, so (for example) the core team may not be able to engage as deeply as we would like and we would not be able to bring a proposal for a review until time permits. Swift 3 is pretty ambitious as is, and losing focus can be a serious problem for a release.<br></p><p>&gt; Or perhaps a desire to have this sort of working group approach (similar to C++’s Technical Subcommittees), but not until 3.0 is released?<br></p><p>We can evaluate this again at some point, but I don&#39;t want to &quot;fan out&quot; to having multiple working groups until we&#39;ve had more experience with this process through Swift 3. In part, this is because of my experiences with the ISO C++ process. Particularly now, where there are a significant number of active subgroups in the C++ committee, it is very hard to even keep track of all of the different pieces under discussion, much less establish and maintain a coherent vision going forward. And that’s in a fairly mature language (C++) where the community has had a longer time to get a feel for what the language is; it’s harder for a younger language like Swift where the philosophy isn’t as widely understood.<br></p><p>  - Doug<br></p><p>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On Dec 12, 2015, at 1:35 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 11, 2015, at 10:48 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d love to have first-class support for generators like this, but it&#39;s a lot of work. It&#39;s a lot easier to do this sort of thing in a scripting language like Python than it is to do in a language like Swift, because it requires reifying the stack into a data structure that can be passed around. And I suspect there&#39;s a lot of non-trivial questions that have to get answered before you can even propose an implementation for this.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; For context, this sort of thing is something that people have been talking about doing in Rust for quite a while, and it keeps getting punted because of the amount of work and the unanswered questions about how it would actually be implemented.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; So I&#39;ll give this a general +1, but I think it should also be deferred until after Swift 3 at the earliest.<br>&gt;&gt; <br>&gt;&gt; Right. This is a major add-on feature that doesn’t fit in with the stated goals for Swift 3 (README of https://github.com/apple/swift-evolution &lt;https://github.com/apple/swift-evolution&gt;), so I think we should proactively defer it.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/11385d33/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 14, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 14, 2015, at 4:59 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; We can evaluate this again at some point, but I don&#39;t want to &quot;fan out&quot; to having multiple working groups until we&#39;ve had more experience with this process through Swift 3. In part, this is because of my experiences with the ISO C++ process. Particularly now, where there are a significant number of active subgroups in the C++ committee, it is very hard to even keep track of all of the different pieces under discussion, much less establish and maintain a coherent vision going forward. And that’s in a fairly mature language (C++) where the community has had a longer time to get a feel for what the language is; it’s harder for a younger language like Swift where the philosophy isn’t as widely understood.<br></p><p>Understood. C++ being more mature has more restrictions on what its subcommittees can really propose as changes to the language. This may make proposals harder, but likely helps them proceed in parallel. Swift likely has several more revolutionary releases ahead of it, and that makes it important to pool design into a few areas to try to increase their usefulness and composability.<br></p><p>-DW<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/59558007/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 13, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 12, 2015, at 12:35 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 10:48 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;d love to have first-class support for generators like this, but it&#39;s a lot of work. It&#39;s a lot easier to do this sort of thing in a scripting language like Python than it is to do in a language like Swift, because it requires reifying the stack into a data structure that can be passed around. And I suspect there&#39;s a lot of non-trivial questions that have to get answered before you can even propose an implementation for this.<br>&gt;&gt;  <br>&gt;&gt; For context, this sort of thing is something that people have been talking about doing in Rust for quite a while, and it keeps getting punted because of the amount of work and the unanswered questions about how it would actually be implemented.<br>&gt;&gt;  <br>&gt;&gt; So I&#39;ll give this a general +1, but I think it should also be deferred until after Swift 3 at the earliest.<br>&gt; <br>&gt; Right. This is a major add-on feature that doesn’t fit in with the stated goals for Swift 3 (README of https://github.com/apple/swift-evolution &lt;https://github.com/apple/swift-evolution&gt;), so I think we should proactively defer it.<br></p><p>I agree with both of you.  I’m very interested in this, but it is clearly out of scope for Swift 3.  It should also be considered alongside whatever async/concurrency approach we tackle (likely in swift 4).<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/4d8e5a36/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
