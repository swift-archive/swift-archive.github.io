<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eed60bdfc964ec62cc48aa6020a03d7b?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Alexander Regueiro</string> &lt;alexreg at gmail.com&gt;<p>December 21, 2015 at 07:00:00pm</p></header><div class="content"><p>Does anyone not like the current syntax for this?<br></p><p>I would propose changing it from:<br></p><p>{ (param_list) -&gt; return_type in … }<br></p><p>to something cleaner like:<br></p><p>(param_list) -&gt; return_type =&gt; { … }<br></p><p>where I’m not so bothered about the `=&gt;` separator (could be `:`, `,`, or indeed `in`).<br></p><p>The braces being around the type specifier as well as function body rather bothers me. Surely it would be more consistent just to have the braces around the function body, and then the type specifier preceding this?<br></p><p>Alternate syntaxes welcome, but I think the suggestion above already represents a significant improvement.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 21, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 11:20 AM, Alexander Regueiro via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Does anyone not like the current syntax for this?<br>&gt; <br>&gt; I would propose changing it from:<br>&gt; <br>&gt; { (param_list) -&gt; return_type in … }<br>&gt; <br>&gt; to something cleaner like:<br>&gt; <br>&gt; (param_list) -&gt; return_type =&gt; { … }<br>&gt; <br>&gt; where I’m not so bothered about the `=&gt;` separator (could be `:`, `,`, or indeed `in`).<br>&gt; <br>&gt; The braces being around the type specifier as well as function body rather bothers me. Surely it would be more consistent just to have the braces around the function body, and then the type specifier preceding this?<br></p><p>Hi Alexander,<br></p><p>We’re open in principle to replacing closure syntax with something better, but A) it needs to be actually better, and B) it needs to fit with the swift grammar.  If you’re interested in pushing forward in this area, please familiarize yourself with the structure of the grammar and propose what you’re thinking in terms of a diff to it.  Thanks,<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eed60bdfc964ec62cc48aa6020a03d7b?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Alexander Regueiro</string> &lt;alexreg at gmail.com&gt;<p>December 21, 2015 at 09:00:00pm</p></header><div class="content"><p>Hi Chris,<br></p><p>Don’t you think the suggestion is better? I’m happy to formula it in terms of an E(BNF) grammar if you like. Is this published/available anywhere, for the current version of Swift?<br></p><p>Thanks.<br></p><p>&gt; On 21 Dec 2015, at 19:22, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 21, 2015, at 11:20 AM, Alexander Regueiro via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Does anyone not like the current syntax for this?<br>&gt;&gt; <br>&gt;&gt; I would propose changing it from:<br>&gt;&gt; <br>&gt;&gt; { (param_list) -&gt; return_type in … }<br>&gt;&gt; <br>&gt;&gt; to something cleaner like:<br>&gt;&gt; <br>&gt;&gt; (param_list) -&gt; return_type =&gt; { … }<br>&gt;&gt; <br>&gt;&gt; where I’m not so bothered about the `=&gt;` separator (could be `:`, `,`, or indeed `in`).<br>&gt;&gt; <br>&gt;&gt; The braces being around the type specifier as well as function body rather bothers me. Surely it would be more consistent just to have the braces around the function body, and then the type specifier preceding this?<br>&gt; <br>&gt; Hi Alexander,<br>&gt; <br>&gt; We’re open in principle to replacing closure syntax with something better, but A) it needs to be actually better, and B) it needs to fit with the swift grammar.  If you’re interested in pushing forward in this area, please familiarize yourself with the structure of the grammar and propose what you’re thinking in terms of a diff to it.  Thanks,<br>&gt; <br>&gt; -Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 21, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 1:33 PM, Alexander Regueiro &lt;alexreg at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hi Chris,<br>&gt; <br>&gt; Don’t you think the suggestion is better? I’m happy to formula it in terms of an E(BNF) grammar if you like. Is this published/available anywhere, for the current version of Swift?<br></p><p>My personal opinion is “no”, because it will look very weird in trailing closure, in the argument lists for function calls, etc.<br></p><p>Further, it would not permit dropping ()’s on closure arguments, you wouldn’t be able to write this:<br></p><p>foo({ lhs, rhs in … })<br></p><p>because the  comma would be exposed out to the function call.<br></p><p>The grammar is described in the reference section of TSPL:<br>https://swift.org/documentation/<br></p><p>In addition to proposing EBNF, please consider the existing grammar so that the new proposal isn’t completely ambiguous.  What you are proposing would be an extremely tricky thing to do.<br></p><p>-Chris<br></p><p><br>&gt; <br>&gt; Thanks.<br>&gt; <br>&gt;&gt; On 21 Dec 2015, at 19:22, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 21, 2015, at 11:20 AM, Alexander Regueiro via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Does anyone not like the current syntax for this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would propose changing it from:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; { (param_list) -&gt; return_type in … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; to something cleaner like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (param_list) -&gt; return_type =&gt; { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; where I’m not so bothered about the `=&gt;` separator (could be `:`, `,`, or indeed `in`).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The braces being around the type specifier as well as function body rather bothers me. Surely it would be more consistent just to have the braces around the function body, and then the type specifier preceding this?<br>&gt;&gt; <br>&gt;&gt; Hi Alexander,<br>&gt;&gt; <br>&gt;&gt; We’re open in principle to replacing closure syntax with something better, but A) it needs to be actually better, and B) it needs to fit with the swift grammar.  If you’re interested in pushing forward in this area, please familiarize yourself with the structure of the grammar and propose what you’re thinking in terms of a diff to it.  Thanks,<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eed60bdfc964ec62cc48aa6020a03d7b?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Alexander Regueiro</string> &lt;alexreg at gmail.com&gt;<p>December 21, 2015 at 10:00:00pm</p></header><div class="content"><p>Thanks for clarifying.<br></p><p>In that case, I would propose grammar for capture expressions, which should drop in without modifications elsewhere (I say tentatively):<br></p><p> closure-expression → “func&quot; closure-signature_opt { statements }<br>‌ closure-signature → parameter-clause function-result_opt<br>‌ closure-signature → identifier-list function-result_opt<br>‌ closure-signature → capture-list parameter-clause function-result_opt<br>‌ closure-signature → capture-list identifier-list function-result_opt<br>‌ closure-signature → capture-list<br>‌ capture-list → [ capture-list-items ]<br>‌ capture-list-items → capture-list-item | capture-list-item , capture-list-items<br>‌ capture-list-item → capture-specifier_opt expression<br>‌ capture-specifier → weak | unowned | unowned(safe) | unowned(unsafe)<br></p><p>I am open to whether the introducing keyword is “func” (overloading the existing keyword but in an evidently separate context, and unambiguously I believe) – or “lambda” (like Python), or “\” (like Haskell) – or even something like “cl” (for Closure). Note that the aforementioned adds an additional keyword, but also removes the the “in” keyword. For reasons mentioned in my previous message, I believe this syntax is both clearer and more consistent. It’s also more in line with other widespread languages (in my experience).<br></p><p>For reference, the current grammar is:<br></p><p> closure-expression → { closure-signature_opt statements }<br>‌ closure-signature → parameter-clause function-result_opt “in&quot;<br>‌ closure-signature → identifier-list function-result_opt “in&quot;<br>‌ closure-signature → capture-list parameter-clause function-result_opt “in&quot;<br>‌ closure-signature → capture-list identifier-list function-result_opt &quot;in&quot;<br>‌ closure-signature → capture-list “in&quot;<br>‌ capture-list → [ capture-list-items ]<br>‌ capture-list-items → capture-list-item | capture-list-item , capture-list-items<br>‌ capture-list-item → capture-specifier_opt expression<br>‌ capture-specifier → weak | unowned | unowned(safe) | unowned(unsafe)<br></p><p>Also, I didn’t bother making braces optional, since I hear that the original language designers wanted to avoid the problems that optional braces have the potential to introduce (e.g. in C-style languages). There are no round brackets used in my above syntax either, which is consistent with their absence in expressions in conditional and loop statements.<br></p><p>Thoughts?<br></p><p>&gt; On 21 Dec 2015, at 21:47, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 21, 2015, at 1:33 PM, Alexander Regueiro &lt;alexreg at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Chris,<br>&gt;&gt; <br>&gt;&gt; Don’t you think the suggestion is better? I’m happy to formula it in terms of an E(BNF) grammar if you like. Is this published/available anywhere, for the current version of Swift?<br>&gt; <br>&gt; My personal opinion is “no”, because it will look very weird in trailing closure, in the argument lists for function calls, etc.<br>&gt; <br>&gt; Further, it would not permit dropping ()’s on closure arguments, you wouldn’t be able to write this:<br>&gt; <br>&gt; foo({ lhs, rhs in … })<br>&gt; <br>&gt; because the  comma would be exposed out to the function call.<br>&gt; <br>&gt; The grammar is described in the reference section of TSPL:<br>&gt; https://swift.org/documentation/<br>&gt; <br>&gt; In addition to proposing EBNF, please consider the existing grammar so that the new proposal isn’t completely ambiguous.  What you are proposing would be an extremely tricky thing to do.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Thanks.<br>&gt;&gt; <br>&gt;&gt;&gt; On 21 Dec 2015, at 19:22, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 21, 2015, at 11:20 AM, Alexander Regueiro via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Does anyone not like the current syntax for this?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would propose changing it from:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; { (param_list) -&gt; return_type in … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; to something cleaner like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (param_list) -&gt; return_type =&gt; { … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; where I’m not so bothered about the `=&gt;` separator (could be `:`, `,`, or indeed `in`).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The braces being around the type specifier as well as function body rather bothers me. Surely it would be more consistent just to have the braces around the function body, and then the type specifier preceding this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Alexander,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We’re open in principle to replacing closure syntax with something better, but A) it needs to be actually better, and B) it needs to fit with the swift grammar.  If you’re interested in pushing forward in this area, please familiarize yourself with the structure of the grammar and propose what you’re thinking in terms of a diff to it.  Thanks,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 21, 2015 at 02:00:00pm</p></header><div class="content"><p>On Dec 21, 2015, at 2:26 PM, Alexander Regueiro &lt;alexreg at gmail.com&gt; wrote:<br>&gt; Thanks for clarifying.<br>&gt; <br>&gt; In that case, I would propose grammar for capture expressions, which should drop in without modifications elsewhere (I say tentatively):<br>&gt; <br>&gt; closure-expression → “func&quot; closure-signature_opt { statements }<br></p><p>If you dig through (very early) history you’ll see that we had this.  There are a couple of problems with it:<br></p><p>1) It punishes simple cases like “X.sort { $1 &lt; $0 }”, along with lots of simple map and filter closures.<br>2) It reads really weird in trailing closure cases.<br></p><p>Lets step back: What problems are you trying to solve with the current closure syntax?<br></p><p>-Chris<br></p><p><br></p><p>&gt; ‌ closure-signature → parameter-clause function-result_opt<br>&gt; ‌ closure-signature → identifier-list function-result_opt<br>&gt; ‌ closure-signature → capture-list parameter-clause function-result_opt<br>&gt; ‌ closure-signature → capture-list identifier-list function-result_opt<br>&gt; ‌ closure-signature → capture-list<br>&gt; ‌ capture-list → [ capture-list-items ]<br>&gt; ‌ capture-list-items → capture-list-item | capture-list-item , capture-list-items<br>&gt; ‌ capture-list-item → capture-specifier_opt expression<br>&gt; ‌ capture-specifier → weak | unowned | unowned(safe) | unowned(unsafe)<br>&gt; <br>&gt; I am open to whether the introducing keyword is “func” (overloading the existing keyword but in an evidently separate context, and unambiguously I believe) – or “lambda” (like Python), or “\” (like Haskell) – or even something like “cl” (for Closure). Note that the aforementioned adds an additional keyword, but also removes the the “in” keyword. For reasons mentioned in my previous message, I believe this syntax is both clearer and more consistent. It’s also more in line with other widespread languages (in my experience).<br>&gt; <br>&gt; For reference, the current grammar is:<br>&gt; <br>&gt; closure-expression → { closure-signature_opt statements }<br>&gt; ‌ closure-signature → parameter-clause function-result_opt “in&quot;<br>&gt; ‌ closure-signature → identifier-list function-result_opt “in&quot;<br>&gt; ‌ closure-signature → capture-list parameter-clause function-result_opt “in&quot;<br>&gt; ‌ closure-signature → capture-list identifier-list function-result_opt &quot;in&quot;<br>&gt; ‌ closure-signature → capture-list “in&quot;<br>&gt; ‌ capture-list → [ capture-list-items ]<br>&gt; ‌ capture-list-items → capture-list-item | capture-list-item , capture-list-items<br>&gt; ‌ capture-list-item → capture-specifier_opt expression<br>&gt; ‌ capture-specifier → weak | unowned | unowned(safe) | unowned(unsafe)<br>&gt; <br>&gt; Also, I didn’t bother making braces optional, since I hear that the original language designers wanted to avoid the problems that optional braces have the potential to introduce (e.g. in C-style languages). There are no round brackets used in my above syntax either, which is consistent with their absence in expressions in conditional and loop statements.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt;&gt; On 21 Dec 2015, at 21:47, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 21, 2015, at 1:33 PM, Alexander Regueiro &lt;alexreg at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Chris,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Don’t you think the suggestion is better? I’m happy to formula it in terms of an E(BNF) grammar if you like. Is this published/available anywhere, for the current version of Swift?<br>&gt;&gt; <br>&gt;&gt; My personal opinion is “no”, because it will look very weird in trailing closure, in the argument lists for function calls, etc.<br>&gt;&gt; <br>&gt;&gt; Further, it would not permit dropping ()’s on closure arguments, you wouldn’t be able to write this:<br>&gt;&gt; <br>&gt;&gt; foo({ lhs, rhs in … })<br>&gt;&gt; <br>&gt;&gt; because the  comma would be exposed out to the function call.<br>&gt;&gt; <br>&gt;&gt; The grammar is described in the reference section of TSPL:<br>&gt;&gt; https://swift.org/documentation/<br>&gt;&gt; <br>&gt;&gt; In addition to proposing EBNF, please consider the existing grammar so that the new proposal isn’t completely ambiguous.  What you are proposing would be an extremely tricky thing to do.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 21 Dec 2015, at 19:22, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 21, 2015, at 11:20 AM, Alexander Regueiro via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Does anyone not like the current syntax for this?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would propose changing it from:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; { (param_list) -&gt; return_type in … }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; to something cleaner like:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (param_list) -&gt; return_type =&gt; { … }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; where I’m not so bothered about the `=&gt;` separator (could be `:`, `,`, or indeed `in`).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The braces being around the type specifier as well as function body rather bothers me. Surely it would be more consistent just to have the braces around the function body, and then the type specifier preceding this?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Alexander,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We’re open in principle to replacing closure syntax with something better, but A) it needs to be actually better, and B) it needs to fit with the swift grammar.  If you’re interested in pushing forward in this area, please familiarize yourself with the structure of the grammar and propose what you’re thinking in terms of a diff to it.  Thanks,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eed60bdfc964ec62cc48aa6020a03d7b?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Alexander Regueiro</string> &lt;alexreg at gmail.com&gt;<p>December 21, 2015 at 10:00:00pm</p></header><div class="content"><p>Okay, I assume you are aware this essentially the same syntax as used in languages like C# and Python, yes? I’m not sure there are any problems in those languages with it.<br></p><p>&gt; If you dig through (very early) history you’ll see that we had this.  There are a couple of problems with it:<br>&gt; <br>&gt; 1) It punishes simple cases like “X.sort { $1 &lt; $0 }”, along with lots of simple map and filter closures.<br></p><p>Not really. The above example would just be `X.sort func { $1 &lt; $0 }” or &quot;X.sort \ { $1 &lt; $0 }` in my proposed syntax. Also, it would be nice to have all operators implicitly convertible to functions, or at the very least have corresponding function definitions for all built-in &amp; standard library operators. Haskell does this really nicely (functions and operators are basically interchangeable, and either can be used in prefix or infix mode). Anyway, your above example might look something like `X.sort (&gt;)` (since `(&lt;)` would take arguments in the opposite order).<br></p><p>&gt; 2) It reads really weird in trailing closure cases.<br></p><p>Honestly, I strongly dislike trailing closures. I don’t think they add much, and moreover they use a confusing syntax that make the whole function call look superficially like a function declaration (or indeed the whole thing being a closure).<br></p><p>&gt; Lets step back: What problems are you trying to solve with the current closure syntax?<br></p><p>Readability, mainly. I think this is a big improvement. Also, consistency of semantics. Everything else between curly braces represents a list of statements and is conceptually the “body” of something (a function, a conditional, a loop). The current closure syntax rather embeds the head into the body! Then there’s similarity with other languages, which is minor, but nice. I don’t know any language that uses a syntax like the current one of Swift.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 21, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 2:44 PM, Alexander Regueiro &lt;alexreg at gmail.com&gt; wrote:<br>&gt; <br>&gt; Okay, I assume you are aware this essentially the same syntax as used in languages like C# and Python, yes? I’m not sure there are any problems in those languages with it.<br>&gt; <br>&gt;&gt; If you dig through (very early) history you’ll see that we had this.  There are a couple of problems with it:<br>&gt;&gt; <br>&gt;&gt; 1) It punishes simple cases like “X.sort { $1 &lt; $0 }”, along with lots of simple map and filter closures.<br>&gt; <br>&gt; Not really. The above example would just be `X.sort func { $1 &lt; $0 }” or &quot;X.sort \ { $1 &lt; $0 }` in my proposed syntax. Also, it would be nice to have all operators implicitly convertible to functions, or at the very least have corresponding function definitions for all built-in &amp; standard library operators. Haskell does this really nicely (functions and operators are basically interchangeable, and either can be used in prefix or infix mode). Anyway, your above example might look something like `X.sort (&gt;)` (since `(&lt;)` would take arguments in the opposite order).<br></p><p>Swift already supports this.  X.sort(&gt;) works fine today.  I don’t think that that detracts from the point, since there are lots of other simple closures :-)<br></p><p>&gt; <br>&gt;&gt; 2) It reads really weird in trailing closure cases.<br>&gt; <br>&gt; Honestly, I strongly dislike trailing closures. I don’t think they add much, and moreover they use a confusing syntax that make the whole function call look superficially like a function declaration (or indeed the whole thing being a closure).<br></p><p>Ok, but you’re going to have to grapple with the fact that they are an important aspect of swift design.  If you want your proposal to be seriously considered, it needs to consider them.<br></p><p>&gt;&gt; Lets step back: What problems are you trying to solve with the current closure syntax?<br>&gt; <br>&gt; Readability, mainly. I think this is a big improvement. Also, consistency of semantics. Everything else between curly braces represents a list of statements and is conceptually the “body” of something (a function, a conditional, a loop). The current closure syntax rather embeds the head into the body! Then there’s similarity with other languages, which is minor, but nice. I don’t know any language that uses a syntax like the current one of Swift.<br></p><p>Since your recent proposal has serious tradeoffs, you should explain how each of the changes it forces measures on this.<br></p><p>Further, keep in mind that swift supports nested functions, which yield a very similar experience to what you’re proposing.<br></p><p>-Chris<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 22, 2015 at 07:00:00am</p></header><div class="content"><p>Well, I&#39;m actually happy with the current closure syntax as it allows very succinct simple cases and trailing closures as Chris has already pointed out.<br></p><p>&gt; Am 21.12.2015 um 23:44 schrieb Alexander Regueiro via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Okay, I assume you are aware this essentially the same syntax as used in languages like C# and Python, yes? I’m not sure there are any problems in those languages with it.<br>&gt; <br>&gt;&gt; If you dig through (very early) history you’ll see that we had this.  There are a couple of problems with it:<br>&gt;&gt; <br>&gt;&gt; 1) It punishes simple cases like “X.sort { $1 &lt; $0 }”, along with lots of simple map and filter closures.<br>&gt; <br>&gt; Not really. The above example would just be `X.sort func { $1 &lt; $0 }” or &quot;X.sort \ { $1 &lt; $0 }` in my proposed syntax. Also, it would be nice to have all operators implicitly<br></p><p>Having &quot;func&quot; or the backslash crammed in there is really ugly and unreadable IMHO.<br></p><p>And in Haskell you don&#39;t have braces for the body to begin with and you would have to enclose the closure in parenthesis if it is part of an expression like your examples so in effect it would look quite similar, i.e. having the parameters within the parenthesis (sure, the semantics are different, but I made argument just to demonstrate that what looks good in one syntactic environment might not look good in another).<br></p><p>&gt;&gt; 2) It reads really weird in trailing closure cases.<br>&gt; <br>&gt; Honestly, I strongly dislike trailing closures. I don’t think they add much, and moreover they use a confusing syntax that make the whole function call look superficially like a function declaration (or indeed the whole thing being a closure).<br></p><p>Trailing closures are a great feature IMHO because they make the code much more readable by allowing constructs to look similar to control flow statements.<br>This allows creating very readable DSLs.<br></p><p><br>&gt;&gt; Lets step back: What problems are you trying to solve with the current closure syntax?<br>&gt; <br>&gt; Readability, mainly. I think this is a big improvement. <br></p><p>Well, I think it&#39;s the opposite for the simple cases and for trailing closures. <br></p><p><br>&gt; Then there’s similarity with other languages, which is minor, but nice. I don’t know any language that uses a syntax like the current one of Swift.<br></p><p>Smalltalk and Ruby immediately come to mind and I&#39;m sure there are others.<br></p><p>Scala has a trailing closure syntax which is similar to Swift&#39;s syntax as well.<br></p><p>-Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d5c03d71ebd1813a9c856bff896009b7?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Daniel Valls Estella</string> &lt;daniel at upzzle.com&gt;<p>December 22, 2015 at 10:00:00am</p></header><div class="content"><p>Just to add my point of view as language user. I don’t know so much about compilers and neither have many familiarity with language grammars. I like to  learn, and this list helps.<br></p><p>I think clousures are strangely written and break some coherence. I agree with Alexander on that.<br>But I don’t like the proposed solution.<br></p><p>In the other side, I think trailing closures are a really a great feature, I like a lot.<br>But I feel it’s a bit confusing in some way, as Alexander pointed. As if it was the body definition of the called function.<br></p><p>To throw an idea, the with keyword:<br></p><p><br>with (  parameters ) -&gt; return_type {<br>    statements<br>}<br></p><p><br>sorted = names.sort( with(s1: String, s2: String) -&gt; Bool {<br>    return s1 &gt; s2<br>})<br></p><p><br>sorted = names.sort( with(s1, s2){  return s1 &gt; s2 } )<br></p><p><br>reversed = names.sort( with(s1, s2){ s1 &gt; s2 } )<br></p><p><br>reversed = names.sort( { $0 &gt; $1 } )   <br>OR? reversed = names.sort( with{ $0 &gt; $1 } )<br></p><p><br>reversed = names.sort(&gt;)<br>OR? reversed = names.sort(with &gt;)<br></p><p><br>reversed = names.sort()  with { $0 &gt; $1 }   // I think clarifies it is an input to exeute not a definition<br></p><p><br>reversed = names.sort with { $0 &gt; $1 }  // I think clarifies it is an input to exeute not a definition<br></p><p><br>Thanks!<br></p><p><br>Daniel<br></p><p><br>Daniel Valls Estella · tel. 659.910.830 · daniel at upzzle.com<br></p><p>&gt; El 22 des 2015, a les 7:57, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; va escriure:<br>&gt; <br>&gt; Well, I&#39;m actually happy with the current closure syntax as it allows very succinct simple cases and trailing closures as Chris has already pointed out.<br>&gt; <br>&gt;&gt; Am 21.12.2015 um 23:44 schrieb Alexander Regueiro via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; Okay, I assume you are aware this essentially the same syntax as used in languages like C# and Python, yes? I’m not sure there are any problems in those languages with it.<br>&gt;&gt; <br>&gt;&gt;&gt; If you dig through (very early) history you’ll see that we had this.  There are a couple of problems with it:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) It punishes simple cases like “X.sort { $1 &lt; $0 }”, along with lots of simple map and filter closures.<br>&gt;&gt; <br>&gt;&gt; Not really. The above example would just be `X.sort func { $1 &lt; $0 }” or &quot;X.sort \ { $1 &lt; $0 }` in my proposed syntax. Also, it would be nice to have all operators implicitly<br>&gt; <br>&gt; Having &quot;func&quot; or the backslash crammed in there is really ugly and unreadable IMHO.<br>&gt; <br>&gt; And in Haskell you don&#39;t have braces for the body to begin with and you would have to enclose the closure in parenthesis if it is part of an expression like your examples so in effect it would look quite similar, i.e. having the parameters within the parenthesis (sure, the semantics are different, but I made argument just to demonstrate that what looks good in one syntactic environment might not look good in another).<br>&gt; <br>&gt;&gt;&gt; 2) It reads really weird in trailing closure cases.<br>&gt;&gt; <br>&gt;&gt; Honestly, I strongly dislike trailing closures. I don’t think they add much, and moreover they use a confusing syntax that make the whole function call look superficially like a function declaration (or indeed the whole thing being a closure).<br>&gt; <br>&gt; Trailing closures are a great feature IMHO because they make the code much more readable by allowing constructs to look similar to control flow statements.<br>&gt; This allows creating very readable DSLs.<br>&gt; <br>&gt; <br>&gt;&gt;&gt; Lets step back: What problems are you trying to solve with the current closure syntax?<br>&gt;&gt; <br>&gt;&gt; Readability, mainly. I think this is a big improvement. <br>&gt; <br>&gt; Well, I think it&#39;s the opposite for the simple cases and for trailing closures. <br>&gt; <br>&gt; <br>&gt;&gt; Then there’s similarity with other languages, which is minor, but nice. I don’t know any language that uses a syntax like the current one of Swift.<br>&gt; <br>&gt; Smalltalk and Ruby immediately come to mind and I&#39;m sure there are others.<br>&gt; <br>&gt; Scala has a trailing closure syntax which is similar to Swift&#39;s syntax as well.<br>&gt; <br>&gt; -Thorsten <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/5be3950e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>December 22, 2015 at 02:00:00am</p></header><div class="content"><p>When I started using Swift, and wanted to learn the syntax for closures, I<br>found the &quot;in&quot; token very confusing. I probably would have figured it out<br>at least a half hour sooner, if it had been a different word, or an<br>operator. I kept thinking &quot;that can&#39;t be right, I must be misinterpreting<br>the documentation&quot;<br></p><p>Once you learn the syntax once, it&#39;s not a practical issue ever again.<br>Still, it&#39;s kinder to new learners, and reads better, if the syntax uses<br>something other than &quot;in&quot;<br></p><p><br>On Tue, Dec 22, 2015 at 1:54 AM, Daniel Valls Estella via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Just to add my point of view as language user. I don’t know so much about<br>&gt; compilers and neither have many familiarity with language grammars. I like<br>&gt; to  learn, and this list helps.<br>&gt;<br>&gt; I think clousures are strangely written and break some coherence. I agree<br>&gt; with Alexander on that.<br>&gt; But I don’t like the proposed solution.<br>&gt;<br>&gt; In the other side, I think trailing closures are a really a great feature,<br>&gt; I like a lot.<br>&gt; But I feel it’s a bit confusing in some way, as Alexander pointed. As if<br>&gt; it was the body definition of the called function.<br>&gt;<br>&gt; To throw an idea, the *with* keyword:<br>&gt;<br>&gt;<br>&gt; with (  *parameters* ) -&gt; *return_type* {<br>&gt;     *statements*<br>&gt; }<br>&gt;<br>&gt;<br>&gt; sorted = names.sort( *with*(s1: String, s2: String) -&gt; Bool {<br>&gt;     return s1 &gt; s2<br>&gt; })<br>&gt;<br>&gt;<br>&gt; sorted = names.sort( *with*(s1, s2){  return s1 &gt; s2 } )<br>&gt;<br>&gt;<br>&gt; reversed = names.sort( *with*(s1, s2){ s1 &gt; s2 } )<br>&gt;<br>&gt;<br>&gt; reversed = names.sort( { $0 &gt; $1 } )<br>&gt; OR? reversed = names.sort( *with*{ $0 &gt; $1 } )<br>&gt;<br>&gt;<br>&gt; reversed = names.sort(&gt;)<br>&gt; OR? reversed = names.sort(*with* &gt;)<br>&gt;<br>&gt;<br>&gt; reversed = names.sort()  *with* { $0 &gt; $1 }   // I think clarifies it is<br>&gt; an input to exeute not a definition<br>&gt;<br>&gt;<br>&gt; reversed = names.sort *with* { $0 &gt; $1 }  // I think clarifies it is an<br>&gt; input to exeute not a definition<br>&gt;<br>&gt;<br>&gt; Thanks!<br>&gt;<br>&gt;<br>&gt; Daniel<br>&gt;<br>&gt;<br>&gt; Daniel Valls Estella · tel. 659.910.830 · daniel at upzzle.com<br>&gt;<br>&gt; El 22 des 2015, a les 7:57, Thorsten Seitz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; va escriure:<br>&gt;<br>&gt; Well, I&#39;m actually happy with the current closure syntax as it allows very<br>&gt; succinct simple cases and trailing closures as Chris has already pointed<br>&gt; out.<br>&gt;<br>&gt; Am 21.12.2015 um 23:44 schrieb Alexander Regueiro via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; Okay, I assume you are aware this essentially the same syntax as used in<br>&gt; languages like C# and Python, yes? I’m not sure there are any problems in<br>&gt; those languages with it.<br>&gt;<br>&gt; If you dig through (very early) history you’ll see that we had this.<br>&gt; There are a couple of problems with it:<br>&gt;<br>&gt; 1) It punishes simple cases like “X.sort { $1 &lt; $0 }”, along with lots of<br>&gt; simple map and filter closures.<br>&gt;<br>&gt;<br>&gt; Not really. The above example would just be `X.sort func { $1 &lt; $0 }” or<br>&gt; &quot;X.sort \ { $1 &lt; $0 }` in my proposed syntax. Also, it would be nice to<br>&gt; have all operators implicitly<br>&gt;<br>&gt;<br>&gt; Having &quot;func&quot; or the backslash crammed in there is really ugly and<br>&gt; unreadable IMHO.<br>&gt;<br>&gt; And in Haskell you don&#39;t have braces for the body to begin with and you<br>&gt; would have to enclose the closure in parenthesis if it is part of an<br>&gt; expression like your examples so in effect it would look quite similar,<br>&gt; i.e. having the parameters within the parenthesis (sure, the semantics are<br>&gt; different, but I made argument just to demonstrate that what looks good in<br>&gt; one syntactic environment might not look good in another).<br>&gt;<br>&gt; 2) It reads really weird in trailing closure cases.<br>&gt;<br>&gt;<br>&gt; Honestly, I strongly dislike trailing closures. I don’t think they add<br>&gt; much, and moreover they use a confusing syntax that make the whole function<br>&gt; call look superficially like a function declaration (or indeed the whole<br>&gt; thing being a closure).<br>&gt;<br>&gt;<br>&gt; Trailing closures are a great feature IMHO because they make the code much<br>&gt; more readable by allowing constructs to look similar to control flow<br>&gt; statements.<br>&gt; This allows creating very readable DSLs.<br>&gt;<br>&gt;<br>&gt; Lets step back: What problems are you trying to solve with the current<br>&gt; closure syntax?<br>&gt;<br>&gt;<br>&gt; Readability, mainly. I think this is a big improvement.<br>&gt;<br>&gt;<br>&gt; Well, I think it&#39;s the opposite for the simple cases and for trailing<br>&gt; closures.<br>&gt;<br>&gt;<br>&gt; Then there’s similarity with other languages, which is minor, but nice. I<br>&gt; don’t know any language that uses a syntax like the current one of Swift.<br>&gt;<br>&gt;<br>&gt; Smalltalk and Ruby immediately come to mind and I&#39;m sure there are others.<br>&gt;<br>&gt; Scala has a trailing closure syntax which is similar to Swift&#39;s syntax as<br>&gt; well.<br>&gt;<br>&gt; -Thorsten<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/07a17fed/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eed60bdfc964ec62cc48aa6020a03d7b?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Alexander Regueiro</string> &lt;alexreg at gmail.com&gt;<p>December 22, 2015 at 11:00:00pm</p></header><div class="content"><p>Sorry, but I don’t think you could be more wrong on every point. I’ve clearly detailed why my solution is superior (both factually and in my opinion), and I can only see subjective “dislike this”.<br></p><p>Using “func” or “lambda” outside is uglier than “in” inside the braes? Really? That just boggles my mind. Sure, maybe Ruby does, but the vast majority of languages shun this approach. C# for example has a lovely, crystal clear syntax for lambda expressions. So does Haskell, like I’ve mentioned.<br></p><p>I’ve also explained the big problem with trailing closures already. And closures are really *not* control flow statements, so treating like them is just a fallacy and source of confusion. There are other arguments against it too, like it doesn’t generalise well (at all) to multiple closure arguments.<br></p><p>Ultimately, the key points when judging how worthwhile a feature are 1) how big a feature is it? 2) how much does it add?. I’d say that for trailing closures, the answer to 1) is “moderate”, and 2) is “next to nothing”.<br></p><p>&gt; On 22 Dec 2015, at 06:57, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; Well, I&#39;m actually happy with the current closure syntax as it allows very succinct simple cases and trailing closures as Chris has already pointed out.<br>&gt; <br>&gt;&gt; Am 21.12.2015 um 23:44 schrieb Alexander Regueiro via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; Okay, I assume you are aware this essentially the same syntax as used in languages like C# and Python, yes? I’m not sure there are any problems in those languages with it.<br>&gt;&gt; <br>&gt;&gt;&gt; If you dig through (very early) history you’ll see that we had this. There are a couple of problems with it:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) It punishes simple cases like “X.sort { $1 &lt; $0 }”, along with lots of simple map and filter closures.<br>&gt;&gt; <br>&gt;&gt; Not really. The above example would just be `X.sort func { $1 &lt; $0 }” or &quot;X.sort \ { $1 &lt; $0 }` in my proposed syntax. Also, it would be nice to have all operators implicitly<br>&gt; <br>&gt; Having &quot;func&quot; or the backslash crammed in there is really ugly and unreadable IMHO.<br>&gt; <br>&gt; And in Haskell you don&#39;t have braces for the body to begin with and you would have to enclose the closure in parenthesis if it is part of an expression like your examples so in effect it would look quite similar, i.e. having the parameters within the parenthesis (sure, the semantics are different, but I made argument just to demonstrate that what looks good in one syntactic environment might not look good in another).<br>&gt; <br>&gt;&gt;&gt; 2) It reads really weird in trailing closure cases.<br>&gt;&gt; <br>&gt;&gt; Honestly, I strongly dislike trailing closures. I don’t think they add much, and moreover they use a confusing syntax that make the whole function call look superficially like a function declaration (or indeed the whole thing being a closure).<br>&gt; <br>&gt; Trailing closures are a great feature IMHO because they make the code much more readable by allowing constructs to look similar to control flow statements.<br>&gt; This allows creating very readable DSLs.<br>&gt; <br>&gt; <br>&gt;&gt;&gt; Lets step back: What problems are you trying to solve with the current closure syntax?<br>&gt;&gt; <br>&gt;&gt; Readability, mainly. I think this is a big improvement. <br>&gt; <br>&gt; Well, I think it&#39;s the opposite for the simple cases and for trailing closures. <br>&gt; <br>&gt; <br>&gt;&gt; Then there’s similarity with other languages, which is minor, but nice. I don’t know any language that uses a syntax like the current one of Swift.<br>&gt; <br>&gt; Smalltalk and Ruby immediately come to mind and I&#39;m sure there are others.<br>&gt; <br>&gt; Scala has a trailing closure syntax which is similar to Swift&#39;s syntax as well.<br>&gt; <br>&gt; -Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>December 22, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 3:45 PM, Alexander Regueiro via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’ve also explained the big problem with trailing closures already. And closures are really *not* control flow statements, so treating like them is just a fallacy and source of confusion.<br></p><p>Trailing closures allow you to write constructs that look and act as if they were control flow statements, which in practice is quite useful.<br></p><p>Closures do have control flow ramifications when reading code: the meaning of `return` inside a closure is different from its meaning in nearby code.<br></p><p>I personally favored `func` as the introducer for closures for precisely that reason. The presence of `func` would make it easier to recognize that there is something additional going on here, such as variable captures and `return` hijacking. Be warned that I lost that argument internally long ago.<br></p><p><br>&gt; There are other arguments against it too, like it doesn’t generalise well (at all) to multiple closure arguments.<br></p><p>The argument that a feature does not generalize becomes much weaker when the special case is important enough. Single-closure argument lists like map and dispatch… and with… are common enough that special treatment is warranted.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eed60bdfc964ec62cc48aa6020a03d7b?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Alexander Regueiro</string> &lt;alexreg at gmail.com&gt;<p>December 23, 2015 at 12:00:00am</p></header><div class="content"><p>&gt;&gt; I’ve also explained the big problem with trailing closures already. And closures are really *not* control flow statements, so treating like them is just a fallacy and source of confusion.<br>&gt; <br>&gt; Trailing closures allow you to write constructs that look and act as if they were control flow statements, which in practice is quite useful.<br></p><p>It really just means you put the close bracket for a function call (parameter list) before the actual parameters end. Which not only doesn’t save any real space (2 characters if you’re lucky, but quite often 0), but it belies the semantics of passing arguments to function, at such trifling benefit.<br></p><p>&gt; Closures do have control flow ramifications when reading code: the meaning of `return` inside a closure is different from its meaning in nearby code.<br></p><p>Sure, but that doesn’t mean closures are control-flow elements or statements. Also, I think my above point makes this rather irrelevant anyway.<br></p><p>&gt; I personally favored `func` as the introducer for closures for precisely that reason. The presence of `func` would make it easier to recognize that there is something additional going on here, such as variable captures and `return` hijacking. Be warned that I lost that argument internally long ago.<br></p><p>Did you have anyone else on that side? :) I think if another public support can be drummed up, it should be on the cards again.<br></p><p>&gt; <br>&gt;&gt; There are other arguments against it too, like it doesn’t generalise well (at all) to multiple closure arguments.<br>&gt; <br>&gt; The argument that a feature does not generalize becomes much weaker when the special case is important enough. Single-closure argument lists like map and dispatch… and with… are common enough that special treatment is warranted.<br></p><p>Sure, but then what&#39;s the benefit for single-closure argument lists in the first place? I still don’t say any. Honestly, it just looks like a confusing way to put the brackets in another place, at the cost of confusing people and making your function call look like a function definition. (Great!)<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 23, 2015 at 08:00:00am</p></header><div class="content"><p>Can&#39;t help commenting...<br></p><p>&gt; I can only see subjective “dislike this”.<br></p><p>The feel of the language is very important. We&#39;re talking about improving the syntax to look better here, so of course the subjective look of it matters most.<br></p><p>&gt; Using “func” or “lambda” outside is uglier than “in” inside the braes? Really?<br></p><p>A thousand times yes. &quot;in&quot; is unfortunate, but adding a keyword would be... backwards doesn&#39;t quite capture it. It would destroy a big portion of the fun of the entire language.<br></p><p>&gt; And closures are really *not* control flow statements, so treating like them is just a fallacy and source of confusion.<br></p><p>...but it looks and reads very good. ;-)<br></p><p><br>The only thing that I find wrong is &quot;in&quot;. It just doesn&#39;t look delimited enough. foo.map { bar in bar.boz} is heavy on the eyes, while foo.map { |bar| bar.boz } would be ideal.<br></p><p>A man can dream, right?<br></p><p>Honestly, I think I understand the tradeoffs involved, so I&#39;m fine with letting that &quot;in&quot; be.<br></p><p>A.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eed60bdfc964ec62cc48aa6020a03d7b?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Alexander Regueiro</string> &lt;alexreg at gmail.com&gt;<p>December 23, 2015 at 02:00:00am</p></header><div class="content"><p>Disagree, disagree, disagree. Don’t see any logic to that.<br></p><p>On 23 Dec 2015, at 02:10, Andrey Tarantsov &lt;andrey at tarantsov.com&gt; wrote:<br>&gt; <br>&gt; Can&#39;t help commenting...<br>&gt; <br>&gt;&gt; I can only see subjective “dislike this”.<br>&gt; <br>&gt; The feel of the language is very important. We&#39;re talking about improving the syntax to look better here, so of course the subjective look of it matters most.<br>&gt; <br>&gt;&gt; Using “func” or “lambda” outside is uglier than “in” inside the braes? Really?<br>&gt; <br>&gt; A thousand times yes. &quot;in&quot; is unfortunate, but adding a keyword would be... backwards doesn&#39;t quite capture it. It would destroy a big portion of the fun of the entire language.<br>&gt; <br>&gt;&gt; And closures are really *not* control flow statements, so treating like them is just a fallacy and source of confusion.<br>&gt; <br>&gt; ...but it looks and reads very good. ;-)<br>&gt; <br>&gt; <br>&gt; The only thing that I find wrong is &quot;in&quot;. It just doesn&#39;t look delimited enough. foo.map { bar in bar.boz} is heavy on the eyes, while foo.map { |bar| bar.boz } would be ideal.<br>&gt; <br>&gt; A man can dream, right?<br>&gt; <br>&gt; Honestly, I think I understand the tradeoffs involved, so I&#39;m fine with letting that &quot;in&quot; be.<br>&gt; <br>&gt; A.<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 23, 2015 at 08:00:00am</p></header><div class="content"><p>So I believe the opinion of the core team and the community would be generally in opposition to the style you want. I understand your arguments, but somehow they are against the entire experience of me (and, presumably, others) as developers.<br></p><p>To continue our friendly banter, though, do you mind sharing your background? When I read this, I wasn&#39;t sure if you&#39;re serious or trolling:<br></p><p>&gt; I would propose changing it from:<br>&gt; <br>&gt; { (param_list) -&gt; return_type in … }<br>&gt; <br>&gt; to something cleaner like:<br>&gt; <br>&gt; (param_list) -&gt; return_type =&gt; { … }<br></p><p>I wonder if doing something like Haskel a lot makes you more used to that sort of arrow constructs?<br></p><p>This is written in good faith; I hope I used the right tone to indicate that.<br></p><p>A.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eed60bdfc964ec62cc48aa6020a03d7b?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Alexander Regueiro</string> &lt;alexreg at gmail.com&gt;<p>December 23, 2015 at 02:00:00am</p></header><div class="content"><p>This was my first proposal, and was changed my second, but this syntax is inspired by C#, where a lambda expression is of one of the following forms:<br></p><p>(Type1 param1, …) =&gt; foo // single-statement expression<br>(Type1 param1, …) =&gt; { …; return foo; } // multi-statement expression<br></p><p>Haskell also uses syntax closer to this than to Swift, not to mention ML/F#.<br></p><p>&gt; On 23 Dec 2015, at 02:30, Andrey Tarantsov &lt;andrey at tarantsov.com&gt; wrote:<br>&gt; <br>&gt; So I believe the opinion of the core team and the community would be generally in opposition to the style you want. I understand your arguments, but somehow they are against the entire experience of me (and, presumably, others) as developers.<br>&gt; <br>&gt; To continue our friendly banter, though, do you mind sharing your background? When I read this, I wasn&#39;t sure if you&#39;re serious or trolling:<br>&gt; <br>&gt;&gt; I would propose changing it from:<br>&gt;&gt; <br>&gt;&gt; { (param_list) -&gt; return_type in … }<br>&gt;&gt; <br>&gt;&gt; to something cleaner like:<br>&gt;&gt; <br>&gt;&gt; (param_list) -&gt; return_type =&gt; { … }<br>&gt; <br>&gt; I wonder if doing something like Haskel a lot makes you more used to that sort of arrow constructs?<br>&gt; <br>&gt; This is written in good faith; I hope I used the right tone to indicate that.<br>&gt; <br>&gt; A.<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 23, 2015 at 08:00:00am</p></header><div class="content"><p>One thing I&#39;m really bothered by in C# and ES6 are no-argument methods:<br></p><p>() =&gt; { foo() }   // GROSS<br></p><p>The syntax of C# isn&#39;t so bad, though, when there&#39;s no return type:<br></p><p>foo.map((bar) =&gt; bar.boz)<br></p><p>but those double-parens bother me and my eyes a bit, so this definitely looks better:<br></p><p>foo.map { (bar) =&gt; bar.boz }<br></p><p>I think I&#39;d even prefer that to:<br></p><p>foo.map { (bar) in bar.boz }<br></p><p><br>What if we just agreed to replace &quot;in&quot; with &quot;=&gt;&quot;? Would that be an improvement in your eyes? I could stand behind that proposal.<br></p><p>(btw Chris &amp; team — THANK YOU for the Ruby-style trailing closure syntax, it was such a treat to see it last summer!)<br></p><p>A.<br></p><p><br>&gt; On Dec 23, 2015, at 8:33 AM, Alexander Regueiro &lt;alexreg at gmail.com&gt; wrote:<br>&gt; <br>&gt; This was my first proposal, and was changed my second, but this syntax is inspired by C#, where a lambda expression is of one of the following forms:<br>&gt; <br>&gt; (Type1 param1, …) =&gt; foo // single-statement expression<br>&gt; (Type1 param1, …) =&gt; { …; return foo; } // multi-statement expression<br>&gt; <br>&gt; Haskell also uses syntax closer to this than to Swift, not to mention ML/F#.<br>&gt; <br>&gt;&gt; On 23 Dec 2015, at 02:30, Andrey Tarantsov &lt;andrey at tarantsov.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; So I believe the opinion of the core team and the community would be generally in opposition to the style you want. I understand your arguments, but somehow they are against the entire experience of me (and, presumably, others) as developers.<br>&gt;&gt; <br>&gt;&gt; To continue our friendly banter, though, do you mind sharing your background? When I read this, I wasn&#39;t sure if you&#39;re serious or trolling:<br>&gt;&gt; <br>&gt;&gt;&gt; I would propose changing it from:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; { (param_list) -&gt; return_type in … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; to something cleaner like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (param_list) -&gt; return_type =&gt; { … }<br>&gt;&gt; <br>&gt;&gt; I wonder if doing something like Haskel a lot makes you more used to that sort of arrow constructs?<br>&gt;&gt; <br>&gt;&gt; This is written in good faith; I hope I used the right tone to indicate that.<br>&gt;&gt; <br>&gt;&gt; A.<br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>December 23, 2015 at 09:00:00am</p></header><div class="content"><p>I am joining this discussion a little late - so I would not be surprised if discussed earlier.<br></p><p>but:  <br></p><p>My preference would be:<br></p><p>foo.map( bar =&gt; bar.boz) // single line<br></p><p>or <br></p><p>foo.map { bar =&gt;<br>                 ….<br>              } <br></p><p>if more than one line<br></p><p>if there are multiple values then:<br></p><p>foo.map { (x, y) =&gt; x * 5 + y }<br></p><p><br></p><p><br>&gt; On 2015-12-23, at 9:39:03, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; One thing I&#39;m really bothered by in C# and ES6 are no-argument methods:<br>&gt; <br>&gt; () =&gt; { foo() }   // GROSS<br>&gt; <br>&gt; The syntax of C# isn&#39;t so bad, though, when there&#39;s no return type:<br>&gt; <br>&gt; foo.map((bar) =&gt; bar.boz)<br>&gt; <br>&gt; but those double-parens bother me and my eyes a bit, so this definitely looks better:<br>&gt; <br>&gt; foo.map { (bar) =&gt; bar.boz }<br>&gt; <br>&gt; I think I&#39;d even prefer that to:<br>&gt; <br>&gt; foo.map { (bar) in bar.boz }<br>&gt; <br>&gt; <br>&gt; What if we just agreed to replace &quot;in&quot; with &quot;=&gt;&quot;? Would that be an improvement in your eyes? I could stand behind that proposal.<br>&gt; <br>&gt; (btw Chris &amp; team — THANK YOU for the Ruby-style trailing closure syntax, it was such a treat to see it last summer!)<br>&gt; <br>&gt; A.<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 8:33 AM, Alexander Regueiro &lt;alexreg at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This was my first proposal, and was changed my second, but this syntax is inspired by C#, where a lambda expression is of one of the following forms:<br>&gt;&gt; <br>&gt;&gt; (Type1 param1, …) =&gt; foo // single-statement expression<br>&gt;&gt; (Type1 param1, …) =&gt; { …; return foo; } // multi-statement expression<br>&gt;&gt; <br>&gt;&gt; Haskell also uses syntax closer to this than to Swift, not to mention ML/F#.<br>&gt;&gt; <br>&gt;&gt;&gt; On 23 Dec 2015, at 02:30, Andrey Tarantsov &lt;andrey at tarantsov.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So I believe the opinion of the core team and the community would be generally in opposition to the style you want. I understand your arguments, but somehow they are against the entire experience of me (and, presumably, others) as developers.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To continue our friendly banter, though, do you mind sharing your background? When I read this, I wasn&#39;t sure if you&#39;re serious or trolling:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would propose changing it from:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; { (param_list) -&gt; return_type in … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; to something cleaner like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (param_list) -&gt; return_type =&gt; { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I wonder if doing something like Haskel a lot makes you more used to that sort of arrow constructs?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is written in good faith; I hope I used the right tone to indicate that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eed60bdfc964ec62cc48aa6020a03d7b?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Alexander Regueiro</string> &lt;alexreg at gmail.com&gt;<p>December 23, 2015 at 02:00:00am</p></header><div class="content"><p>Why not curly braces for single-line and multi-line cases? About the brackets around multiple parameters: like I said before, no strong opinion either way.<br></p><p>&gt; On 23 Dec 2015, at 02:46, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt; <br>&gt; I am joining this discussion a little late - so I would not be surprised if discussed earlier.<br>&gt; <br>&gt; but:  <br>&gt; <br>&gt; My preference would be:<br>&gt; <br>&gt; foo.map( bar =&gt; bar.boz) // single line<br>&gt; <br>&gt; or <br>&gt; <br>&gt; foo.map { bar =&gt;<br>&gt;                 ….<br>&gt;              } <br>&gt; <br>&gt; if more than one line<br>&gt; <br>&gt; if there are multiple values then:<br>&gt; <br>&gt; foo.map { (x, y) =&gt; x * 5 + y }<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On 2015-12-23, at 9:39:03, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; One thing I&#39;m really bothered by in C# and ES6 are no-argument methods:<br>&gt;&gt; <br>&gt;&gt; () =&gt; { foo() }   // GROSS<br>&gt;&gt; <br>&gt;&gt; The syntax of C# isn&#39;t so bad, though, when there&#39;s no return type:<br>&gt;&gt; <br>&gt;&gt; foo.map((bar) =&gt; bar.boz)<br>&gt;&gt; <br>&gt;&gt; but those double-parens bother me and my eyes a bit, so this definitely looks better:<br>&gt;&gt; <br>&gt;&gt; foo.map { (bar) =&gt; bar.boz }<br>&gt;&gt; <br>&gt;&gt; I think I&#39;d even prefer that to:<br>&gt;&gt; <br>&gt;&gt; foo.map { (bar) in bar.boz }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; What if we just agreed to replace &quot;in&quot; with &quot;=&gt;&quot;? Would that be an improvement in your eyes? I could stand behind that proposal.<br>&gt;&gt; <br>&gt;&gt; (btw Chris &amp; team — THANK YOU for the Ruby-style trailing closure syntax, it was such a treat to see it last summer!)<br>&gt;&gt; <br>&gt;&gt; A.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 23, 2015, at 8:33 AM, Alexander Regueiro &lt;alexreg at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This was my first proposal, and was changed my second, but this syntax is inspired by C#, where a lambda expression is of one of the following forms:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Type1 param1, …) =&gt; foo // single-statement expression<br>&gt;&gt;&gt; (Type1 param1, …) =&gt; { …; return foo; } // multi-statement expression<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Haskell also uses syntax closer to this than to Swift, not to mention ML/F#.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 23 Dec 2015, at 02:30, Andrey Tarantsov &lt;andrey at tarantsov.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So I believe the opinion of the core team and the community would be generally in opposition to the style you want. I understand your arguments, but somehow they are against the entire experience of me (and, presumably, others) as developers.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To continue our friendly banter, though, do you mind sharing your background? When I read this, I wasn&#39;t sure if you&#39;re serious or trolling:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would propose changing it from:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; { (param_list) -&gt; return_type in … }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; to something cleaner like:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (param_list) -&gt; return_type =&gt; { … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I wonder if doing something like Haskel a lot makes you more used to that sort of arrow constructs?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is written in good faith; I hope I used the right tone to indicate that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>December 23, 2015 at 09:00:00am</p></header><div class="content"><p>It would not prevent curly brackets for single-line cases…. just the difference between a map function call map() vs infix with scope.<br></p><p><br></p><p><br></p><p>&gt; On 2015-12-23, at 9:48:24, Alexander Regueiro &lt;alexreg at gmail.com&gt; wrote:<br>&gt; <br>&gt; Why not curly braces for single-line and multi-line cases? About the brackets around multiple parameters: like I said before, no strong opinion either way.<br>&gt; <br>&gt;&gt; On 23 Dec 2015, at 02:46, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I am joining this discussion a little late - so I would not be surprised if discussed earlier.<br>&gt;&gt; <br>&gt;&gt; but:  <br>&gt;&gt; <br>&gt;&gt; My preference would be:<br>&gt;&gt; <br>&gt;&gt; foo.map( bar =&gt; bar.boz) // single line<br>&gt;&gt; <br>&gt;&gt; or <br>&gt;&gt; <br>&gt;&gt; foo.map { bar =&gt;<br>&gt;&gt;                ….<br>&gt;&gt;             } <br>&gt;&gt; <br>&gt;&gt; if more than one line<br>&gt;&gt; <br>&gt;&gt; if there are multiple values then:<br>&gt;&gt; <br>&gt;&gt; foo.map { (x, y) =&gt; x * 5 + y }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 2015-12-23, at 9:39:03, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One thing I&#39;m really bothered by in C# and ES6 are no-argument methods:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; () =&gt; { foo() }   // GROSS<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The syntax of C# isn&#39;t so bad, though, when there&#39;s no return type:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; foo.map((bar) =&gt; bar.boz)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; but those double-parens bother me and my eyes a bit, so this definitely looks better:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; foo.map { (bar) =&gt; bar.boz }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think I&#39;d even prefer that to:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; foo.map { (bar) in bar.boz }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What if we just agreed to replace &quot;in&quot; with &quot;=&gt;&quot;? Would that be an improvement in your eyes? I could stand behind that proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (btw Chris &amp; team — THANK YOU for the Ruby-style trailing closure syntax, it was such a treat to see it last summer!)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 23, 2015, at 8:33 AM, Alexander Regueiro &lt;alexreg at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This was my first proposal, and was changed my second, but this syntax is inspired by C#, where a lambda expression is of one of the following forms:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (Type1 param1, …) =&gt; foo // single-statement expression<br>&gt;&gt;&gt;&gt; (Type1 param1, …) =&gt; { …; return foo; } // multi-statement expression<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Haskell also uses syntax closer to this than to Swift, not to mention ML/F#.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 23 Dec 2015, at 02:30, Andrey Tarantsov &lt;andrey at tarantsov.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So I believe the opinion of the core team and the community would be generally in opposition to the style you want. I understand your arguments, but somehow they are against the entire experience of me (and, presumably, others) as developers.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To continue our friendly banter, though, do you mind sharing your background? When I read this, I wasn&#39;t sure if you&#39;re serious or trolling:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I would propose changing it from:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; { (param_list) -&gt; return_type in … }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; to something cleaner like:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; (param_list) -&gt; return_type =&gt; { … }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I wonder if doing something like Haskel a lot makes you more used to that sort of arrow constructs?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is written in good faith; I hope I used the right tone to indicate that.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 23, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; foo.map( bar =&gt; bar.boz) // single line<br></p><p>Well how important is it to use () instead of {} here?<br></p><p>If you make it<br></p><p>foo.map { bar =&gt; bar.boz }<br></p><p>then it&#39;s like it is now, but with &quot;in&quot; replace by &quot;=&gt;&quot;.<br></p><p>&gt; foo.map { (x, y) =&gt; x * 5 + y }<br></p><p>I actually like the bare version:<br></p><p>foo.map { x, y =&gt; x * 5 + y }<br></p><p>but not in your example (here it looks atrocious). Take this real code, though:<br></p><p><br>        constrain(topBlock, tableView, view) { top, tbl, sup in<br>            top.left  == sup.left + horizPadding<br>            top.right == sup.right - horizPadding<br>            top.top   == sup.top  + topPadding<br></p><p>            tbl.top    == top.bottom + 16<br>            tbl.bottom == sup.bottom<br></p><p>            tbl.left  == sup.left + horizPadding - horizTableHang<br>            tbl.right == sup.right - horizPadding + horizTableHang<br>        }<br></p><p>I think the lack of parens is beneficial in reducing the visual noise here.<br></p><p>&gt; And yes, I certainly would prefer `=&gt;` rather than `in`.<br></p><p>It seems like the community can actually agree on this.<br></p><p>Does anyone know if it has any parsing problems / grammar implications right now? <br></p><p>&gt; I think a big problem with `in` is that it’s textual, and doesn’t provide a clear visual separation from keywords/names at the start of the body or the end of the type specifier.<br></p><p>Yes, agreed. “Not delimited enough”.<br></p><p>&gt; (Are the [parentheses] around `bar` in your example required? I’m ambivalent to them.)<br></p><p>No, they are not, as shown above.<br></p><p>&gt; To be clear, I’m still not a fan of the Ruby syntax. I think it makes the parsing easier for a compiler but harder for a human…<br></p><p>Depends on the human. To this specific human, the Ruby-style one is the easiest to parse (and mind you, I had very limited experience with Ruby compared to other languages, so it&#39;s not just being used to it, but rather an honest love and preference).<br></p><p>A.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/9de281d0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>December 23, 2015 at 10:00:00am</p></header><div class="content"><p>It has probably been 6 months since I have had time to do anything interesting (JDK6 + Oracle SQL recently for contracts recently) so if I am messing up terminology or syntax - please excuse me.  I messed a few things up and had to open up an old Scala project to remind me what I was doing.<br></p><p><br>The standard map syntax for Scala is:<br></p><p>	a.map(x =&gt; x + 5)<br></p><p>or using a placeholder (very limited shorthand - cannot use a placeholder twice for the same value):<br></p><p>	a.map(_ + 5)<br></p><p>if it is a tuple then<br></p><p>	a.map(x =&gt; f(x._1, x._2))<br></p><p>or you can pass in a function block (with pattern matching case)<br></p><p>	a.map { case (x, y) =&gt; (y, x) }<br></p><p>there might be some mathematical reason behind the “in” keyword - but it is lost on me as well (it has been a good 30 years since University) and gets lost on me.  If I had more time I might get use to it.<br></p><p>I hope I did not mess up those examples as bad.<br></p><p><br> <br></p><p>&gt; On 2015-12-23, at 9:52:46, Andrey Tarantsov &lt;andrey at tarantsov.com&gt; wrote:<br>&gt; <br>&gt;&gt; foo.map( bar =&gt; bar.boz) // single line<br>&gt; <br>&gt; Well how important is it to use () instead of {} here?<br>&gt; <br>&gt; If you make it<br>&gt; <br>&gt; foo.map { bar =&gt; bar.boz }<br>&gt; <br>&gt; then it&#39;s like it is now, but with &quot;in&quot; replace by &quot;=&gt;&quot;.<br>&gt; <br>&gt;&gt; foo.map { (x, y) =&gt; x * 5 + y }<br>&gt; <br>&gt; I actually like the bare version:<br>&gt; <br>&gt; foo.map { x, y =&gt; x * 5 + y }<br>&gt; <br>&gt; but not in your example (here it looks atrocious). Take this real code, though:<br>&gt; <br>&gt; <br>&gt;         constrain(topBlock, tableView, view) { top, tbl, sup in<br>&gt;             top.left  == sup.left + horizPadding<br>&gt;             top.right == sup.right - horizPadding<br>&gt;             top.top   == sup.top  + topPadding<br>&gt; <br>&gt;             tbl.top    == top.bottom + 16<br>&gt;             tbl.bottom == sup.bottom<br>&gt; <br>&gt;             tbl.left  == sup.left + horizPadding - horizTableHang<br>&gt;             tbl.right == sup.right - horizPadding + horizTableHang<br>&gt;         }<br>&gt; <br>&gt; I think the lack of parens is beneficial in reducing the visual noise here.<br>&gt; <br>&gt;&gt; And yes, I certainly would prefer `=&gt;` rather than `in`.<br>&gt; <br>&gt; It seems like the community can actually agree on this.<br>&gt; <br>&gt; Does anyone know if it has any parsing problems / grammar implications right now? <br>&gt; <br>&gt;&gt; I think a big problem with `in` is that it’s textual, and doesn’t provide a clear visual separation from keywords/names at the start of the body or the end of the type specifier.<br>&gt; <br>&gt; Yes, agreed. “Not delimited enough”.<br>&gt; <br>&gt;&gt; (Are the [parentheses] around `bar` in your example required? I’m ambivalent to them.)<br>&gt; <br>&gt; No, they are not, as shown above.<br>&gt; <br>&gt;&gt; To be clear, I’m still not a fan of the Ruby syntax. I think it makes the parsing easier for a compiler but harder for a human…<br>&gt; <br>&gt; Depends on the human. To this specific human, the Ruby-style one is the easiest to parse (and mind you, I had very limited experience with Ruby compared to other languages, so it&#39;s not just being used to it, but rather an honest love and preference).<br>&gt; <br>&gt; A.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/7c5ada1a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eed60bdfc964ec62cc48aa6020a03d7b?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Alexander Regueiro</string> &lt;alexreg at gmail.com&gt;<p>December 23, 2015 at 03:00:00am</p></header><div class="content"><p>The standard map syntax is directly inspired by that of C#.<br></p><p>For Swift, I’d be relatively happy with something like the following (repeating what’s already been said I believe)<br></p><p>map ({ x =&gt; x + 5 })<br></p><p>or using trailing closure<br></p><p>map { x =&gt; x + 5 }<br></p><p>with the possibility of an additional single-line option:<br></p><p>map ( x =&gt; x + 5 )<br></p><p>(which is useful in the case of non-trailing-closure expressions).<br></p><p>Of course, I’d rather remove trailing closures altogether, but I suspect that won’t happen. :(<br></p><p>&gt; On 23 Dec 2015, at 03:45, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt; <br>&gt; It has probably been 6 months since I have had time to do anything interesting (JDK6 + Oracle SQL recently for contracts recently) so if I am messing up terminology or syntax - please excuse me.  I messed a few things up and had to open up an old Scala project to remind me what I was doing.<br>&gt; <br>&gt; <br>&gt; The standard map syntax for Scala is:<br>&gt; <br>&gt; 	a.map(x =&gt; x + 5)<br>&gt; <br>&gt; or using a placeholder (very limited shorthand - cannot use a placeholder twice for the same value):<br>&gt; <br>&gt; 	a.map(_ + 5)<br>&gt; <br>&gt; if it is a tuple then<br>&gt; <br>&gt; 	a.map(x =&gt; f(x._1, x._2))<br>&gt; <br>&gt; or you can pass in a function block (with pattern matching case)<br>&gt; <br>&gt; 	a.map { case (x, y) =&gt; (y, x) }<br>&gt; <br>&gt; there might be some mathematical reason behind the “in” keyword - but it is lost on me as well (it has been a good 30 years since University) and gets lost on me.  If I had more time I might get use to it.<br>&gt; <br>&gt; I hope I did not mess up those examples as bad.<br>&gt; <br>&gt; <br>&gt;  <br>&gt; <br>&gt;&gt; On 2015-12-23, at 9:52:46, Andrey Tarantsov &lt;andrey at tarantsov.com &lt;mailto:andrey at tarantsov.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; foo.map( bar =&gt; bar.boz) // single line<br>&gt;&gt; <br>&gt;&gt; Well how important is it to use () instead of {} here?<br>&gt;&gt; <br>&gt;&gt; If you make it<br>&gt;&gt; <br>&gt;&gt; foo.map { bar =&gt; bar.boz }<br>&gt;&gt; <br>&gt;&gt; then it&#39;s like it is now, but with &quot;in&quot; replace by &quot;=&gt;&quot;.<br>&gt;&gt; <br>&gt;&gt;&gt; foo.map { (x, y) =&gt; x * 5 + y }<br>&gt;&gt; <br>&gt;&gt; I actually like the bare version:<br>&gt;&gt; <br>&gt;&gt; foo.map { x, y =&gt; x * 5 + y }<br>&gt;&gt; <br>&gt;&gt; but not in your example (here it looks atrocious). Take this real code, though:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;         constrain(topBlock, tableView, view) { top, tbl, sup in<br>&gt;&gt;             top.left  == sup.left + horizPadding<br>&gt;&gt;             top.right == sup.right - horizPadding<br>&gt;&gt;             top.top   == sup.top  + topPadding<br>&gt;&gt; <br>&gt;&gt;             tbl.top    == top.bottom + 16<br>&gt;&gt;             tbl.bottom == sup.bottom<br>&gt;&gt; <br>&gt;&gt;             tbl.left  == sup.left + horizPadding - horizTableHang<br>&gt;&gt;             tbl.right == sup.right - horizPadding + horizTableHang<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt; I think the lack of parens is beneficial in reducing the visual noise here.<br>&gt;&gt; <br>&gt;&gt;&gt; And yes, I certainly would prefer `=&gt;` rather than `in`.<br>&gt;&gt; <br>&gt;&gt; It seems like the community can actually agree on this.<br>&gt;&gt; <br>&gt;&gt; Does anyone know if it has any parsing problems / grammar implications right now? <br>&gt;&gt; <br>&gt;&gt;&gt; I think a big problem with `in` is that it’s textual, and doesn’t provide a clear visual separation from keywords/names at the start of the body or the end of the type specifier.<br>&gt;&gt; <br>&gt;&gt; Yes, agreed. “Not delimited enough”.<br>&gt;&gt; <br>&gt;&gt;&gt; (Are the [parentheses] around `bar` in your example required? I’m ambivalent to them.)<br>&gt;&gt; <br>&gt;&gt; No, they are not, as shown above.<br>&gt;&gt; <br>&gt;&gt;&gt; To be clear, I’m still not a fan of the Ruby syntax. I think it makes the parsing easier for a compiler but harder for a human…<br>&gt;&gt; <br>&gt;&gt; Depends on the human. To this specific human, the Ruby-style one is the easiest to parse (and mind you, I had very limited experience with Ruby compared to other languages, so it&#39;s not just being used to it, but rather an honest love and preference).<br>&gt;&gt; <br>&gt;&gt; A.<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/04af3861/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 22, 2015 at 08:00:00pm</p></header><div class="content"><p>Hi, Alexander. For your most recent version, what does the syntax look like when there are explicit types? As far as I can tell the only change is substituting &quot;in&quot; for &quot;=&gt;&quot;, which means taking an existing keyword (from &#39;for&#39; loops) and replacing it with what&#39;s currently a valid operator.<br></p><p>We definitely thought a lot about closure syntax; what we ended up with<br>(a) is concise,<br>(b) has some precedent, structurally (Ruby, Smalltalk),<br>(c) is easy to parse (does not require unbounded lookahead) and therefore easier to produce diagnostics for, and<br>(d) kept the parameter list and return values looking like they do in declarations (when types are included)<br></p><p>It may not be the prettiest thing in the language, but I&#39;m not sure why any of your proposals are objectively better. The main thing we are missing is that closures do not look like standalone function declarations, but we decided that they&#39;re important enough that they need a lightweight syntax. (Compare with JavaScript for a language that did not prioritize this.)<br></p><p>I personally love trailing closures, both here and in Ruby, so I&#39;d put that down to just as much a matter of opinion as closure syntax.<br></p><p>Best,<br>Jordan<br></p><p><br>&gt; On Dec 22, 2015, at 19:48 , Alexander Regueiro via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The standard map syntax is directly inspired by that of C#.<br>&gt; <br>&gt; For Swift, I’d be relatively happy with something like the following (repeating what’s already been said I believe)<br>&gt; <br>&gt; map ({ x =&gt; x + 5 })<br>&gt; <br>&gt; or using trailing closure<br>&gt; <br>&gt; map { x =&gt; x + 5 }<br>&gt; <br>&gt; with the possibility of an additional single-line option:<br>&gt; <br>&gt; map ( x =&gt; x + 5 )<br>&gt; <br>&gt; (which is useful in the case of non-trailing-closure expressions).<br>&gt; <br>&gt; Of course, I’d rather remove trailing closures altogether, but I suspect that won’t happen. :(<br>&gt; <br>&gt;&gt; On 23 Dec 2015, at 03:45, Craig Cruden &lt;ccruden at novafore.com &lt;mailto:ccruden at novafore.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It has probably been 6 months since I have had time to do anything interesting (JDK6 + Oracle SQL recently for contracts recently) so if I am messing up terminology or syntax - please excuse me.  I messed a few things up and had to open up an old Scala project to remind me what I was doing.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The standard map syntax for Scala is:<br>&gt;&gt; <br>&gt;&gt; 	a.map(x =&gt; x + 5)<br>&gt;&gt; <br>&gt;&gt; or using a placeholder (very limited shorthand - cannot use a placeholder twice for the same value):<br>&gt;&gt; <br>&gt;&gt; 	a.map(_ + 5)<br>&gt;&gt; <br>&gt;&gt; if it is a tuple then<br>&gt;&gt; <br>&gt;&gt; 	a.map(x =&gt; f(x._1, x._2))<br>&gt;&gt; <br>&gt;&gt; or you can pass in a function block (with pattern matching case)<br>&gt;&gt; <br>&gt;&gt; 	a.map { case (x, y) =&gt; (y, x) }<br>&gt;&gt; <br>&gt;&gt; there might be some mathematical reason behind the “in” keyword - but it is lost on me as well (it has been a good 30 years since University) and gets lost on me.  If I had more time I might get use to it.<br>&gt;&gt; <br>&gt;&gt; I hope I did not mess up those examples as bad.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt; On 2015-12-23, at 9:52:46, Andrey Tarantsov &lt;andrey at tarantsov.com &lt;mailto:andrey at tarantsov.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; foo.map( bar =&gt; bar.boz) // single line<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well how important is it to use () instead of {} here?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you make it<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; foo.map { bar =&gt; bar.boz }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; then it&#39;s like it is now, but with &quot;in&quot; replace by &quot;=&gt;&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; foo.map { (x, y) =&gt; x * 5 + y }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I actually like the bare version:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; foo.map { x, y =&gt; x * 5 + y }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; but not in your example (here it looks atrocious). Take this real code, though:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         constrain(topBlock, tableView, view) { top, tbl, sup in<br>&gt;&gt;&gt;             top.left  == sup.left + horizPadding<br>&gt;&gt;&gt;             top.right == sup.right - horizPadding<br>&gt;&gt;&gt;             top.top   == sup.top  + topPadding<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;             tbl.top    == top.bottom + 16<br>&gt;&gt;&gt;             tbl.bottom == sup.bottom<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;             tbl.left  == sup.left + horizPadding - horizTableHang<br>&gt;&gt;&gt;             tbl.right == sup.right - horizPadding + horizTableHang<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the lack of parens is beneficial in reducing the visual noise here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And yes, I certainly would prefer `=&gt;` rather than `in`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems like the community can actually agree on this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Does anyone know if it has any parsing problems / grammar implications right now? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think a big problem with `in` is that it’s textual, and doesn’t provide a clear visual separation from keywords/names at the start of the body or the end of the type specifier.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, agreed. “Not delimited enough”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (Are the [parentheses] around `bar` in your example required? I’m ambivalent to them.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, they are not, as shown above.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To be clear, I’m still not a fan of the Ruby syntax. I think it makes the parsing easier for a compiler but harder for a human…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Depends on the human. To this specific human, the Ruby-style one is the easiest to parse (and mind you, I had very limited experience with Ruby compared to other languages, so it&#39;s not just being used to it, but rather an honest love and preference).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/ff17886a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 23, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; love trailing closures<br>I wouldn&#39;t go that far and just say &quot;})&quot; looks ugly — but that has the same implications ;-)<br>With parameters, trailing closures loose a lot of their appeal, and an alternative syntax (&quot;func(x: Int) {&quot; instead of &quot;{ x: Int in}&quot; isn&#39;t that bad for trailing closure either.<br></p><p>The only obvious downside is the &quot;$0&quot; shortcut would be confusing with &quot;func() {&quot; (but not so much with &quot;func {&quot;…).<br>Speaking of &quot;$0&quot;, you could argue why it is allowed in closures and not in methods… but I&#39;m in some discord with $0 anyways:<br>It is really nice for small constructs, but drawing the line when to discourage their use is tough (at least to tough for the compiler to enforce a rule).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/f21a4ced/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Lambda function syntax</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 23, 2015 at 10:00:00am</p></header><div class="content"><p>I don&#39;t think either are that nice, we could do a ruby thing and use &quot;do&quot;.<br>The do expresses that we are passing in a block :)  and the arguments are<br>on the outside of the closure which matches iit elsewhere:<br></p><p>heyThere() do |hi, there|<br>{<br></p><p>}<br></p><p>we could allow anon functions like so:<br></p><p>heyThere((hi, there){<br>})<br></p><p>But then its inconsistent, so I don&#39;t mind what swift does now :) as its<br>consistent whether its a closure block or a argument we are passing in.<br></p><p>Regarding the &quot;=&gt;&quot; vs &quot;in&quot; debate, they are both obtuse to me. In some-ways<br>&quot;in&quot; is better as it reads to me as &quot;the arguments in this closure&quot; so I<br>would much prefer &quot;in&quot;. I know this is subjective but that&#39;s just my two<br>cents ;)<br></p><p>On Wed, Dec 23, 2015 at 9:42 AM, Tino Heth via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; love trailing closures<br>&gt;<br>&gt; I wouldn&#39;t go that far and just say &quot;})&quot; looks ugly — but that has the<br>&gt; same implications ;-)<br>&gt; With parameters, trailing closures loose a lot of their appeal, and an<br>&gt; alternative syntax (&quot;func(x: Int) {&quot; instead of &quot;{ x: Int in}&quot; isn&#39;t that<br>&gt; bad for trailing closure either.<br>&gt;<br>&gt; The only obvious downside is the &quot;$0&quot; shortcut would be confusing with<br>&gt; &quot;func() {&quot; (but not so much with &quot;func {&quot;…).<br>&gt; Speaking of &quot;$0&quot;, you could argue why it is allowed in closures and not in<br>&gt; methods… but I&#39;m in some discord with $0 anyways:<br>&gt; It is really nice for small constructs, but drawing the line when to<br>&gt; discourage their use is tough (at least to tough for the compiler to<br>&gt; enforce a rule).<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br> Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/0822dcad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 23, 2015 at 02:00:00am</p></header><div class="content"><p>I have to admit I haven&#39;t read the entire thread, so maybe I missed discussion of this.<br></p><p>I, too, don&#39;t like the `params in code` syntax. After a year and a half with Swift, I now remember it, but it still reads funny, and I see new developers struggle with it frequently. I&#39;ve also used Ruby quite a bit, but I really don&#39;t like the `||` syntax there either.<br></p><p>What I would do is pull the parameters/type signature out of the braces and put a symbol in front of them. For example:<br></p><p>	let names = people.map =&gt; person { person.name }<br></p><p>	database.saveRecord(record) =&gt; record, error {<br>		if let record = record {<br>			completionHandler(true)<br>		}<br>		else {<br>			handleError(error!)<br>		}<br>	}<br></p><p>`=&gt;` is used here merely because it&#39;s been discussed upthread; I actually think it&#39;s a little too heavy for this role, but I don&#39;t have a great replacement immediately at hand.<br></p><p>A no-parameters closure would not require a `=&gt;`; a bare block would still do there. I suppose the capture list would still go before the parameters, but after the `=&gt;`. Other closure features remain the same—you can still use the `$N` implicit parameters, and you can still use `-&gt;` to specify a return value, `()` to surround the parameters, `:` to specify exact types, etc.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8b9f0c10986385f3c7f50615d6176be3?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Pierre Monod-Broca</string> &lt;pierre at monod-broca.fr&gt;<p>December 23, 2015 at 12:00:00pm</p></header><div class="content"><p>I like that the closure parameters are inside the closure, to me it makes as much sense as outside. They&#39;re the input, so as much in as out.<br></p><p>I have nothing against `in`, but I wouldn&#39;t be against a sensible replacement.<br>I like `=&gt;`, but I&#39;m concerned it might be confused with `-&gt;` by beginners in swift.<br></p><p>-- <br>Pierre<br></p><p>&gt; Le 23 déc. 2015 à 11:21, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I have to admit I haven&#39;t read the entire thread, so maybe I missed discussion of this.<br>&gt; <br>&gt; I, too, don&#39;t like the `params in code` syntax. After a year and a half with Swift, I now remember it, but it still reads funny, and I see new developers struggle with it frequently. I&#39;ve also used Ruby quite a bit, but I really don&#39;t like the `||` syntax there either.<br>&gt; <br>&gt; What I would do is pull the parameters/type signature out of the braces and put a symbol in front of them. For example:<br>&gt; <br>&gt; 	let names = people.map =&gt; person { person.name }<br>&gt; <br>&gt; 	database.saveRecord(record) =&gt; record, error {<br>&gt; 		if let record = record {<br>&gt; 			completionHandler(true)<br>&gt; 		}<br>&gt; 		else {<br>&gt; 			handleError(error!)<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; `=&gt;` is used here merely because it&#39;s been discussed upthread; I actually think it&#39;s a little too heavy for this role, but I don&#39;t have a great replacement immediately at hand.<br>&gt; <br>&gt; A no-parameters closure would not require a `=&gt;`; a bare block would still do there. I suppose the capture list would still go before the parameters, but after the `=&gt;`. Other closure features remain the same—you can still use the `$N` implicit parameters, and you can still use `-&gt;` to specify a return value, `()` to surround the parameters, `:` to specify exact types, etc.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/c50c8979/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d5c03d71ebd1813a9c856bff896009b7?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Daniel Valls Estella</string> &lt;daniel at upzzle.com&gt;<p>December 23, 2015 at 02:00:00pm</p></header><div class="content"><p>I think =&gt; may be confusing in many of shown cases. Its a cause/efect symbol and can be also and operator.<br></p><p>I put again the idea of with for the newcomers:<br></p><p>with (  parameters ) -&gt; return_type {<br>    statements<br>}<br></p><p><br>sorted = names.sort( with(s1, s2){ s1 &gt; s2 } )<br></p><p>sorted = names.sort( with{ $0 &gt; $1 } )<br></p><p><br>sorted = names.sort()  with { $0 &gt; $1 }  <br></p><p>reversed = names.sort with(s1,s2){<br></p><p>	//bla bla code<br>	return resultVar <br>}<br> <br>reversed = names.sort with { $0 &gt; $1 }  <br></p><p><br>But thinking about it, what we are really always doing with clousures is solving a quicky tiny delegation pattern. Maybe we could name it what it is. Too long word, but just to brainstorm.<br></p><p>delegating (  parameters ) -&gt; return_type {<br>    statements<br>}<br></p><p><br>sorted = names.sort( delegating(s1, s2){ s1 &gt; s2 } )<br></p><p>sorted = names.sort( delegating{ $0 &gt; $1 } )<br></p><p><br>sorted = names.sort()  delegating{ $0 &gt; $1 }  <br></p><p>reversed = names.sort delegating(s1,s2){<br></p><p>	//bla bla code<br>	return resultVar <br>}<br> <br>reversed = names.sort delegating{ $0 &gt; $1 }<br></p><p><br></p><p>:)<br></p><p>&gt; El 23 des 2015, a les 12:49, Pierre Monod-Broca via swift-evolution &lt;swift-evolution at swift.org&gt; va escriure:<br>&gt; <br>&gt; I like that the closure parameters are inside the closure, to me it makes as much sense as outside. They&#39;re the input, so as much in as out.<br>&gt; <br>&gt; I have nothing against `in`, but I wouldn&#39;t be against a sensible replacement.<br>&gt; I like `=&gt;`, but I&#39;m concerned it might be confused with `-&gt;` by beginners in swift.<br>&gt; <br>&gt; -- <br>&gt; Pierre<br>&gt; <br>&gt;&gt; Le 23 déc. 2015 à 11:21, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; I have to admit I haven&#39;t read the entire thread, so maybe I missed discussion of this.<br>&gt;&gt; <br>&gt;&gt; I, too, don&#39;t like the `params in code` syntax. After a year and a half with Swift, I now remember it, but it still reads funny, and I see new developers struggle with it frequently. I&#39;ve also used Ruby quite a bit, but I really don&#39;t like the `||` syntax there either.<br>&gt;&gt; <br>&gt;&gt; What I would do is pull the parameters/type signature out of the braces and put a symbol in front of them. For example:<br>&gt;&gt; <br>&gt;&gt; 	let names = people.map =&gt; person { person.name }<br>&gt;&gt; <br>&gt;&gt; 	database.saveRecord(record) =&gt; record, error {<br>&gt;&gt; 		if let record = record {<br>&gt;&gt; 			completionHandler(true)<br>&gt;&gt; 		}<br>&gt;&gt; 		else {<br>&gt;&gt; 			handleError(error!)<br>&gt;&gt; 		}<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; `=&gt;` is used here merely because it&#39;s been discussed upthread; I actually think it&#39;s a little too heavy for this role, but I don&#39;t have a great replacement immediately at hand.<br>&gt;&gt; <br>&gt;&gt; A no-parameters closure would not require a `=&gt;`; a bare block would still do there. I suppose the capture list would still go before the parameters, but after the `=&gt;`. Other closure features remain the same—you can still use the `$N` implicit parameters, and you can still use `-&gt;` to specify a return value, `()` to surround the parameters, `:` to specify exact types, etc.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/8c19a3fd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Lambda function syntax</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 23, 2015 at 01:00:00pm</p></header><div class="content"><p>Why not just do ?<br></p><p>On Wed, Dec 23, 2015 at 1:02 PM, Daniel Valls Estella via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I think =&gt; may be confusing in many of shown cases. Its a cause/efect<br>&gt; symbol and can be also and operator.<br>&gt;<br>&gt; I put again the idea of with for the newcomers:<br>&gt;<br>&gt; with (  *parameters* ) -&gt; *return_type* {<br>&gt;     *statements*<br>&gt; }<br>&gt;<br>&gt;<br>&gt; sorted = names.sort( *with*(s1, s2){ s1 &gt; s2 } )<br>&gt;<br>&gt; sorted = names.sort( *with*{ $0 &gt; $1 } )<br>&gt;<br>&gt;<br>&gt; sorted = names.sort()  *with* { $0 &gt; $1 }<br>&gt;<br>&gt; reversed = names.sort *with*(s1,s2){<br>&gt;<br>&gt; //bla bla code<br>&gt; return resultVar<br>&gt; }<br>&gt;<br>&gt; reversed = names.sort *with* { $0 &gt; $1 }<br>&gt;<br>&gt;<br>&gt; But thinking about it, what we are really always doing with clousures is<br>&gt; solving a quicky tiny delegation pattern. Maybe we could name it what it<br>&gt; is. Too long word, but just to brainstorm.<br>&gt;<br>&gt; delegating (  *parameters* ) -&gt; *return_type* {<br>&gt;     *statements*<br>&gt; }<br>&gt;<br>&gt;<br>&gt; sorted = names.sort( *delegating*(s1, s2){ s1 &gt; s2 } )<br>&gt;<br>&gt; sorted = names.sort( *delegating*{ $0 &gt; $1 } )<br>&gt;<br>&gt;<br>&gt; sorted = names.sort()  *delegating*{ $0 &gt; $1 }<br>&gt;<br>&gt; reversed = names.sort *delegating*(s1,s2){<br>&gt;<br>&gt; //bla bla code<br>&gt; return resultVar<br>&gt; }<br>&gt;<br>&gt; reversed = names.sort *delegating*{ $0 &gt; $1 }<br>&gt;<br>&gt;<br>&gt;<br>&gt; :)<br>&gt;<br>&gt; El 23 des 2015, a les 12:49, Pierre Monod-Broca via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; va escriure:<br>&gt;<br>&gt; I like that the closure parameters are inside the closure, to me it makes<br>&gt; as much sense as outside. They&#39;re the input, so as much in as out.<br>&gt;<br>&gt; I have nothing against `in`, but I wouldn&#39;t be against a sensible<br>&gt; replacement.<br>&gt; I like `=&gt;`, but I&#39;m concerned it might be confused with `-&gt;` by beginners<br>&gt; in swift.<br>&gt;<br>&gt; --<br>&gt; Pierre<br>&gt;<br>&gt; Le 23 déc. 2015 à 11:21, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; I have to admit I haven&#39;t read the entire thread, so maybe I missed<br>&gt; discussion of this.<br>&gt;<br>&gt; I, too, don&#39;t like the `params in code` syntax. After a year and a half<br>&gt; with Swift, I now remember it, but it still reads funny, and I see new<br>&gt; developers struggle with it frequently. I&#39;ve also used Ruby quite a bit,<br>&gt; but I really don&#39;t like the `||` syntax there either.<br>&gt;<br>&gt; What I would do is pull the parameters/type signature out of the braces<br>&gt; and put a symbol in front of them. For example:<br>&gt;<br>&gt; let names = people.map =&gt; person { person.name }<br>&gt;<br>&gt; database.saveRecord(record) =&gt; record, error {<br>&gt; if let record = record {<br>&gt; completionHandler(true)<br>&gt; }<br>&gt; else {<br>&gt; handleError(error!)<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; `=&gt;` is used here merely because it&#39;s been discussed upthread; I actually<br>&gt; think it&#39;s a little too heavy for this role, but I don&#39;t have a great<br>&gt; replacement immediately at hand.<br>&gt;<br>&gt; A no-parameters closure would not require a `=&gt;`; a bare block would still<br>&gt; do there. I suppose the capture list would still go before the parameters,<br>&gt; but after the `=&gt;`. Other closure features remain the same—you can still<br>&gt; use the `$N` implicit parameters, and you can still use `-&gt;` to specify a<br>&gt; return value, `()` to surround the parameters, `:` to specify exact types,<br>&gt; etc.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br> Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/d3b2c281/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 23, 2015 at 05:00:00am</p></header><div class="content"><p>&gt; I think =&gt; may be confusing in many of shown cases. Its a cause/efect symbol and can be also and operator.<br>&gt; <br>&gt; I put again the idea of with for the newcomers:<br>&gt; <br>&gt; with (  parameters ) -&gt; return_type {<br>&gt;     statements<br>&gt; }<br>&gt; <br>&gt; <br>&gt; sorted = names.sort( with(s1, s2){ s1 &gt; s2 } )<br>&gt; <br>&gt; sorted = names.sort( with{ $0 &gt; $1 } )<br>&gt; <br>&gt; <br>&gt; sorted = names.sort()  with { $0 &gt; $1 }  <br>&gt; <br>&gt; reversed = names.sort with(s1,s2){<br>&gt; <br>&gt; 	//bla bla code<br>&gt; 	return resultVar <br>&gt; }<br>&gt;  <br>&gt; reversed = names.sort with { $0 &gt; $1 }  <br></p><p>I don&#39;t think this is particularly helpful. Even if you don&#39;t know what a closure is, if you&#39;re familiar with any C-like language, or with other parts of Swift&#39;s syntax, you know that `{ ... }` indicates a piece of code. That&#39;s all you really need to know in order to understand what `names.sort { $0 &gt; $1 }` *means*, even if you don&#39;t immediately know how it *works*.<br></p><p>We don&#39;t need a keyword hopping up and down shouting &quot;CLOSURE! CLOSURE! CLOSURE!&quot;; all we need is a syntactic marker delimiting the boundary between the parameter list and whatever&#39;s adjacent to it. Your `with` and `delegating` keywords hop up and down. The current `in` keyword marks the boundary; so does whatever we actually call my proposed `=&gt;` symbol. (Again, I don&#39;t actually like that specific symbol—think of it as a placeholder.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eed60bdfc964ec62cc48aa6020a03d7b?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Alexander Regueiro</string> &lt;alexreg at gmail.com&gt;<p>December 23, 2015 at 05:00:00pm</p></header><div class="content"><p>This is very similar to my proposal. We were later suggesting the use of `=&gt;` in place of `in`, but formerly I suggested essentially what you did here, but with `func` or `\` in place of `&gt;=` to signify the start of a closure expression.<br></p><p>&gt; On 23 Dec 2015, at 10:21, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt; I have to admit I haven&#39;t read the entire thread, so maybe I missed discussion of this.<br>&gt; <br>&gt; I, too, don&#39;t like the `params in code` syntax. After a year and a half with Swift, I now remember it, but it still reads funny, and I see new developers struggle with it frequently. I&#39;ve also used Ruby quite a bit, but I really don&#39;t like the `||` syntax there either.<br>&gt; <br>&gt; What I would do is pull the parameters/type signature out of the braces and put a symbol in front of them. For example:<br>&gt; <br>&gt; 	let names = people.map =&gt; person { person.name }<br>&gt; <br>&gt; 	database.saveRecord(record) =&gt; record, error {<br>&gt; 		if let record = record {<br>&gt; 			completionHandler(true)<br>&gt; 		}<br>&gt; 		else {<br>&gt; 			handleError(error!)<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; `=&gt;` is used here merely because it&#39;s been discussed upthread; I actually think it&#39;s a little too heavy for this role, but I don&#39;t have a great replacement immediately at hand.<br>&gt; <br>&gt; A no-parameters closure would not require a `=&gt;`; a bare block would still do there. I suppose the capture list would still go before the parameters, but after the `=&gt;`. Other closure features remain the same—you can still use the `$N` implicit parameters, and you can still use `-&gt;` to specify a return value, `()` to surround the parameters, `:` to specify exact types, etc.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 23, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; This is very similar to my proposal. We were later suggesting the use of `=&gt;` in place of `in`, but formerly I suggested essentially what you did here, but with `func` or `\` in place of `&gt;=` to signify the start of a closure expression.<br></p><p>It seems, though, that you thought *all* closures should be marked with this character, even parameterless ones. Whereas I propose that:<br></p><p>&gt;&gt; A no-parameters closure would not require a `=&gt;`; a bare block would still do there.<br></p><p>Perhaps it&#39;s a difference in perspective—I&#39;ve spent nearly my entire career using languages where closures were common—but I really don&#39;t think closures need a big, obvious syntactic marker. All we need is a good way to mark the ambiguous end of the parameter list (the front end if it&#39;s outside the closure, the back end if it&#39;s inside).<br></p><p>Closures are not conceptually a terribly difficult feature—they&#39;re just omitted from many languages because they&#39;re difficult to *implement*. We have to be careful not to make their syntax heavier than it needs to be.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eed60bdfc964ec62cc48aa6020a03d7b?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Alexander Regueiro</string> &lt;alexreg at gmail.com&gt;<p>December 23, 2015 at 09:00:00pm</p></header><div class="content"><p>Marking the *start* of a closure is more difficult than marking the end of the parameter the list. The end of the parameter list and start of the body of a closure (lambda expression) can be easily delineated by `{` in my scheme.<br></p><p>&gt; On 23 Dec 2015, at 21:15, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; This is very similar to my proposal. We were later suggesting the use of `=&gt;` in place of `in`, but formerly I suggested essentially what you did here, but with `func` or `\` in place of `&gt;=` to signify the start of a closure expression.<br>&gt; <br>&gt; It seems, though, that you thought *all* closures should be marked with this character, even parameterless ones. Whereas I propose that:<br>&gt; <br>&gt;&gt;&gt; A no-parameters closure would not require a `=&gt;`; a bare block would still do there.<br>&gt; <br>&gt; Perhaps it&#39;s a difference in perspective—I&#39;ve spent nearly my entire career using languages where closures were common—but I really don&#39;t think closures need a big, obvious syntactic marker. All we need is a good way to mark the ambiguous end of the parameter list (the front end if it&#39;s outside the closure, the back end if it&#39;s inside).<br>&gt; <br>&gt; Closures are not conceptually a terribly difficult feature—they&#39;re just omitted from many languages because they&#39;re difficult to *implement*. We have to be careful not to make their syntax heavier than it needs to be.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/945b22bad6d88de707d2ae9531c185ff?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Thorsten Seitz</string> &lt;trsfoo at googlemail.com&gt;<p>December 27, 2015 at 08:00:00pm</p></header><div class="content"><p>In this mail I’m answering several statements made in this thread by different people, not only Brent’s mail from which I just picked the following snippet:<br></p><p>&gt; let names = people.map =&gt; person { person.name }<br></p><p>For me that is more difficult to read than<br></p><p>	let names = people.map { person in person.name }<br></p><p>Especially when chaining is used, i.e.<br></p><p>	let names = people.filter =&gt; person { person.isFriend }.map =&gt; person { person.name }<br></p><p>(or would I have to add parentheses somewhere with this proposed syntax?)<br></p><p>vs.<br></p><p>	let names = people.filter { person in person.isFriend }.map { person in person.name }<br></p><p><br>Those „=&gt;“ pretty much visually separate the statement in the wrong positions, i.e. the parts grouped together visually are<br></p><p>1. people.filter<br>2. person { person.isFriend }.map<br>3. person { person.name }<br></p><p>which is simply wrong for the middle part (or parts in case of more chaining).<br></p><p>Whereas having the arguments in the closure separate the parts visually much better, keeping the closures together and interspersed with the function names.<br></p><p><br>With regards to trailing closures: Having them is an important part of DSLs in Ruby, Smalltalk and Scala.<br></p><p>See for example the links cited in https://news.ycombinator.com/item?id=7921011 or the Akka library (http://akka.io) or rake (Ruby’s „make&quot; replacement).<br></p><p>Of course Alexander is right that the concept of a trailing closure works only for one closure and not for several. That is indeed a thing where Smalltalk’s syntax without any parentheses around function arguments had a really nice advantage which is not possible in Swift (although the parameter keywords are really great in alleviating this).<br>But there are so many cases (as the links above demonstrate) where a single trailing closure is sufficient that this feature is tremendously useful.<br></p><p><br>With regards to Haskell: the above example would (typically) look like:<br></p><p>names = map (\person -&gt; name person) . filter (\person -&gt; isFriend person) $ people<br></p><p>which also uses only one pair of parentheses just around the lambda expressions (because Haskell has neither parentheses around parameters nor around closures).<br></p><p>Visually it actually looks just the same as Swift’s closures (replacing parentheses with braces and „-&gt;“ with „in“ and dropping the backslash which stands in for the greek letter lambda), i.e. visually the parameters of the closure are within the parentheses, just like in Swift.<br>Of course the syntactical meaning of the parentheses is different from that of the braces but the visual effect is quite important in my eyes. That helps a lot in readability.<br></p><p><br>With regards to „in“: I personally like it but could also live with something like „=&gt;“ or the bar „|“ as used in Ruby (two bars around the params) or Smalltalk (just one bar after the params which I would prefer), e.g.<br></p><p>let names = people.map { person | person.name }<br></p><p>although the „in“ definitely looks better with syntax highlighting and when using the wrong font like now (where the bar just looks like the upper case letter „i“).<br></p><p>I think I said it already: the „in“ reminds me of the let-in-expression of Haskell, e.g. „let foo = 3 in …“<br></p><p><br>-Thorsten<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/ce516ccd/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eed60bdfc964ec62cc48aa6020a03d7b?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Alexander Regueiro</string> &lt;alexreg at gmail.com&gt;<p>December 23, 2015 at 05:00:00pm</p></header><div class="content"><p>I’m against everything here. It’s universally worse, in my view.<br></p><p>&gt; On 23 Dec 2015, at 10:05, James Campbell &lt;james at supmenow.com&gt; wrote:<br>&gt; <br>&gt; I don&#39;t think either are that nice, we could do a ruby thing and use &quot;do&quot;. The do expresses that we are passing in a block :)  and the arguments are on the outside of the closure which matches iit elsewhere:<br>&gt; <br>&gt; heyThere() do |hi, there|<br>&gt; {<br>&gt; <br>&gt; }<br>&gt; <br>&gt; we could allow anon functions like so:<br>&gt; <br>&gt; heyThere((hi, there){<br>&gt; })<br>&gt; <br>&gt; But then its inconsistent, so I don&#39;t mind what swift does now :) as its consistent whether its a closure block or a argument we are passing in.<br>&gt; <br>&gt; Regarding the &quot;=&gt;&quot; vs &quot;in&quot; debate, they are both obtuse to me. In some-ways &quot;in&quot; is better as it reads to me as &quot;the arguments in this closure&quot; so I would much prefer &quot;in&quot;. I know this is subjective but that&#39;s just my two cents ;)<br>&gt; <br>&gt; On Wed, Dec 23, 2015 at 9:42 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; love trailing closures<br>&gt; I wouldn&#39;t go that far and just say &quot;})&quot; looks ugly — but that has the same implications ;-)<br>&gt; With parameters, trailing closures loose a lot of their appeal, and an alternative syntax (&quot;func(x: Int) {&quot; instead of &quot;{ x: Int in}&quot; isn&#39;t that bad for trailing closure either.<br>&gt; <br>&gt; The only obvious downside is the &quot;$0&quot; shortcut would be confusing with &quot;func() {&quot; (but not so much with &quot;func {&quot;…).<br>&gt; Speaking of &quot;$0&quot;, you could argue why it is allowed in closures and not in methods… but I&#39;m in some discord with $0 anyways:<br>&gt; It is really nice for small constructs, but drawing the line when to discourage their use is tough (at least to tough for the compiler to enforce a rule).<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt;  Wizard<br>&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;<br>&gt; +44 7523 279 698<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/4fb48bb6/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eed60bdfc964ec62cc48aa6020a03d7b?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Alexander Regueiro</string> &lt;alexreg at gmail.com&gt;<p>December 23, 2015 at 05:00:00pm</p></header><div class="content"><p>I agree on this. For large closures, `$0` isn’t very clear what you’re referring to. Personally, I’d rather remove them altogether, but I don’t want to start a subdiscussion on that here.<br></p><p>&gt; On 23 Dec 2015, at 09:42, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; love trailing closures<br>&gt; I wouldn&#39;t go that far and just say &quot;})&quot; looks ugly — but that has the same implications ;-)<br>&gt; With parameters, trailing closures loose a lot of their appeal, and an alternative syntax (&quot;func(x: Int) {&quot; instead of &quot;{ x: Int in}&quot; isn&#39;t that bad for trailing closure either.<br>&gt; <br>&gt; The only obvious downside is the &quot;$0&quot; shortcut would be confusing with &quot;func() {&quot; (but not so much with &quot;func {&quot;…).<br>&gt; Speaking of &quot;$0&quot;, you could argue why it is allowed in closures and not in methods… but I&#39;m in some discord with $0 anyways:<br>&gt; It is really nice for small constructs, but drawing the line when to discourage their use is tough (at least to tough for the compiler to enforce a rule).<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/0c96bf79/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eed60bdfc964ec62cc48aa6020a03d7b?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Alexander Regueiro</string> &lt;alexreg at gmail.com&gt;<p>December 23, 2015 at 05:00:00pm</p></header><div class="content"><p>Does “in” really make sense semantically though? It seems to have confused almost everywhere, and as we’ve discussed, it’s not “delimited enough”.<br></p><p>My recent personal proposal was the syntax:<br></p><p>func x, y, z { … }<br></p><p>– for the reasons/advantages discussed in my post stating the grammar (and previous one).<br></p><p>If this can’t be effected, then I would compromise for the syntax that just replaces `in` with `&gt;=` in the current syntax.<br></p><p>I also like the proposal of changing `-&gt;` to `:` in function type specifiers, for consistency. This also frees up another operator.<br></p><p>&gt; On 23 Dec 2015, at 04:02, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi, Alexander. For your most recent version, what does the syntax look like when there are explicit types? As far as I can tell the only change is substituting &quot;in&quot; for &quot;=&gt;&quot;, which means taking an existing keyword (from &#39;for&#39; loops) and replacing it with what&#39;s currently a valid operator.<br>&gt; <br>&gt; We definitely thought a lot about closure syntax; what we ended up with<br>&gt; (a) is concise,<br>&gt; (b) has some precedent, structurally (Ruby, Smalltalk),<br>&gt; (c) is easy to parse (does not require unbounded lookahead) and therefore easier to produce diagnostics for, and<br>&gt; (d) kept the parameter list and return values looking like they do in declarations (when types are included)<br>&gt; <br>&gt; It may not be the prettiest thing in the language, but I&#39;m not sure why any of your proposals are objectively better. The main thing we are missing is that closures do not look like standalone function declarations, but we decided that they&#39;re important enough that they need a lightweight syntax. (Compare with JavaScript for a language that did not prioritize this.)<br>&gt; <br>&gt; I personally love trailing closures, both here and in Ruby, so I&#39;d put that down to just as much a matter of opinion as closure syntax.<br>&gt; <br>&gt; Best,<br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 19:48 , Alexander Regueiro via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The standard map syntax is directly inspired by that of C#.<br>&gt;&gt; <br>&gt;&gt; For Swift, I’d be relatively happy with something like the following (repeating what’s already been said I believe)<br>&gt;&gt; <br>&gt;&gt; map ({ x =&gt; x + 5 })<br>&gt;&gt; <br>&gt;&gt; or using trailing closure<br>&gt;&gt; <br>&gt;&gt; map { x =&gt; x + 5 }<br>&gt;&gt; <br>&gt;&gt; with the possibility of an additional single-line option:<br>&gt;&gt; <br>&gt;&gt; map ( x =&gt; x + 5 )<br>&gt;&gt; <br>&gt;&gt; (which is useful in the case of non-trailing-closure expressions).<br>&gt;&gt; <br>&gt;&gt; Of course, I’d rather remove trailing closures altogether, but I suspect that won’t happen. :(<br>&gt;&gt; <br>&gt;&gt;&gt; On 23 Dec 2015, at 03:45, Craig Cruden &lt;ccruden at novafore.com &lt;mailto:ccruden at novafore.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It has probably been 6 months since I have had time to do anything interesting (JDK6 + Oracle SQL recently for contracts recently) so if I am messing up terminology or syntax - please excuse me.  I messed a few things up and had to open up an old Scala project to remind me what I was doing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The standard map syntax for Scala is:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	a.map(x =&gt; x + 5)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or using a placeholder (very limited shorthand - cannot use a placeholder twice for the same value):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	a.map(_ + 5)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if it is a tuple then<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	a.map(x =&gt; f(x._1, x._2))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or you can pass in a function block (with pattern matching case)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	a.map { case (x, y) =&gt; (y, x) }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; there might be some mathematical reason behind the “in” keyword - but it is lost on me as well (it has been a good 30 years since University) and gets lost on me.  If I had more time I might get use to it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I hope I did not mess up those examples as bad.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 2015-12-23, at 9:52:46, Andrey Tarantsov &lt;andrey at tarantsov.com &lt;mailto:andrey at tarantsov.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; foo.map( bar =&gt; bar.boz) // single line<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Well how important is it to use () instead of {} here?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you make it<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; foo.map { bar =&gt; bar.boz }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; then it&#39;s like it is now, but with &quot;in&quot; replace by &quot;=&gt;&quot;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; foo.map { (x, y) =&gt; x * 5 + y }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I actually like the bare version:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; foo.map { x, y =&gt; x * 5 + y }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; but not in your example (here it looks atrocious). Take this real code, though:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         constrain(topBlock, tableView, view) { top, tbl, sup in<br>&gt;&gt;&gt;&gt;             top.left  == sup.left + horizPadding<br>&gt;&gt;&gt;&gt;             top.right == sup.right - horizPadding<br>&gt;&gt;&gt;&gt;             top.top   == sup.top  + topPadding<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;             tbl.top    == top.bottom + 16<br>&gt;&gt;&gt;&gt;             tbl.bottom == sup.bottom<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;             tbl.left  == sup.left + horizPadding - horizTableHang<br>&gt;&gt;&gt;&gt;             tbl.right == sup.right - horizPadding + horizTableHang<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think the lack of parens is beneficial in reducing the visual noise here.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And yes, I certainly would prefer `=&gt;` rather than `in`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems like the community can actually agree on this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Does anyone know if it has any parsing problems / grammar implications right now? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think a big problem with `in` is that it’s textual, and doesn’t provide a clear visual separation from keywords/names at the start of the body or the end of the type specifier.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, agreed. “Not delimited enough”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (Are the [parentheses] around `bar` in your example required? I’m ambivalent to them.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No, they are not, as shown above.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To be clear, I’m still not a fan of the Ruby syntax. I think it makes the parsing easier for a compiler but harder for a human…<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Depends on the human. To this specific human, the Ruby-style one is the easiest to parse (and mind you, I had very limited experience with Ruby compared to other languages, so it&#39;s not just being used to it, but rather an honest love and preference).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/5ac188a0/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>December 22, 2015 at 11:00:00pm</p></header><div class="content"><p>I think &quot;in&quot; is slightly easier to type in than &quot;=&gt;&quot;. <br>The =&gt; may be interpreted as equal or greater than.<br></p><p><br>On Dec 22, 2015, at 9:52 PM, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; And yes, I certainly would prefer `=&gt;` rather than `in`.<br>&gt; <br>&gt; It seems like the community can actually agree on this.<br>&gt; <br>&gt; Does anyone know if it has any parsing problems / grammar implications right now?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eed60bdfc964ec62cc48aa6020a03d7b?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Alexander Regueiro</string> &lt;alexreg at gmail.com&gt;<p>December 23, 2015 at 05:00:00pm</p></header><div class="content"><p>Virtually everyone agrees `=&gt;` is a much clearer delimiter/separator. `in` is too textual and not easy enough to distinguish from following code.<br></p><p>Also, other languages (e.g. C#) have no problem with the `=&gt;` symbol, as anyone with even a little experience programming knows greater-than-or-equal to is `&gt;=`.<br></p><p>However, if we adopt the new function type specifier syntax (replacing `-&gt;` with `:` for the return type), then `-&gt;` could be used in place of the `in` keyword, to make you happier.<br></p><p>&gt; On 23 Dec 2015, at 04:11, Ricardo Parada &lt;rparada at mac.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; I think &quot;in&quot; is slightly easier to type in than &quot;=&gt;&quot;. <br>&gt; The =&gt; may be interpreted as equal or greater than.<br>&gt; <br>&gt; <br>&gt; On Dec 22, 2015, at 9:52 PM, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; And yes, I certainly would prefer `=&gt;` rather than `in`.<br>&gt;&gt; <br>&gt;&gt; It seems like the community can actually agree on this.<br>&gt;&gt; <br>&gt;&gt; Does anyone know if it has any parsing problems / grammar implications right now?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8b9f0c10986385f3c7f50615d6176be3?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Pierre Monod-Broca</string> &lt;pierre at monod-broca.fr&gt;<p>December 24, 2015 at 11:00:00am</p></header><div class="content"><p>I&#39;m completely against replacing &#39;-&gt;&#39; by &#39;:&#39; it would make unreadable the declaration of a function taking a closure as parameter, or returning one (among other things).<br></p><p>-- <br>Pierre<br></p><p>&gt; Le 23 déc. 2015 à 18:07, Alexander Regueiro via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Virtually everyone agrees `=&gt;` is a much clearer delimiter/separator. `in` is too textual and not easy enough to distinguish from following code.<br>&gt; <br>&gt; Also, other languages (e.g. C#) have no problem with the `=&gt;` symbol, as anyone with even a little experience programming knows greater-than-or-equal to is `&gt;=`.<br>&gt; <br>&gt; However, if we adopt the new function type specifier syntax (replacing `-&gt;` with `:` for the return type), then `-&gt;` could be used in place of the `in` keyword, to make you happier.<br>&gt; <br>&gt;&gt; On 23 Dec 2015, at 04:11, Ricardo Parada &lt;rparada at mac.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I think &quot;in&quot; is slightly easier to type in than &quot;=&gt;&quot;. <br>&gt;&gt; The =&gt; may be interpreted as equal or greater than.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 22, 2015, at 9:52 PM, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; And yes, I certainly would prefer `=&gt;` rather than `in`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems like the community can actually agree on this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Does anyone know if it has any parsing problems / grammar implications right now? <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151224/58941636/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 24, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; I&#39;m completely against replacing &#39;-&gt;&#39; by &#39;:&#39; it would make unreadable the declaration of a function taking a closure as parameter, or returning one (among other things).<br></p><p>That&#39;s definitely right: Two different separators only shift the problem by one level, but hopefully it won&#39;t become common to deal with &quot;functions having functions as parameters that have function parameters that… ;-)<br>Also there is the different meaning of &quot;:&quot; (&quot;is a...&quot;) and &quot;-&gt;&quot; (&quot;returns a…&quot;)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151224/b35b8de6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>December 24, 2015 at 06:00:00pm</p></header><div class="content"><p>I have to say that nuance is basically lost on me.  If I assign a variable I know when I use it I get a type back based on “:”.  If I call a function it has parameters that are defined as : type, if I use a function that ends with a definition “)” [end of parameter list; beginning of type of function] “:” it specifies the “type” of function (what I expect when I call the function).  <br></p><p>I have always associated “arrows” with things like mathematical functions, as such when I switch back and forth between languages I immediately switch back to reading arrows in regards to functions.  <br></p><p>It probably is only compounded by the other languages that I use where they tend to use -&gt; or =&gt; to represent an arrow.<br></p><p>But then each person’s sensibilities are different :p<br></p><p><br></p><p><br>&gt; On 2015-12-24, at 17:44:52, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I&#39;m completely against replacing &#39;-&gt;&#39; by &#39;:&#39; it would make unreadable the declaration of a function taking a closure as parameter, or returning one (among other things).<br>&gt; <br>&gt; That&#39;s definitely right: Two different separators only shift the problem by one level, but hopefully it won&#39;t become common to deal with &quot;functions having functions as parameters that have function parameters that… ;-)<br>&gt; Also there is the different meaning of &quot;:&quot; (&quot;is a...&quot;) and &quot;-&gt;&quot; (&quot;returns a…&quot;)<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151224/90485aab/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 24, 2015 at 04:00:00am</p></header><div class="content"><p>&gt; I&#39;m completely against replacing &#39;-&gt;&#39; by &#39;:&#39; it would make unreadable the declaration of a function taking a closure as parameter, or returning one (among other things).<br></p><p>Actually, I find this perfectly readable, though a little bit strange after so long with the current signatures:<br></p><p>	func indexOf(predicate: Element: Bool): Index? {<br>		for (i, elem) in zip(indexes, self) {<br>			if predicate(elem) {<br>				return i<br>			}<br>		}<br>		return nil<br>	}<br></p><p>Where I *do* foresee big issues is with tuples. Take a look at this declaration:<br></p><p>	let tuple: (Int: Int, Bool: Bool)<br></p><p>Does `tuple` contain two unlabeled functions, or two labeled values?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>December 24, 2015 at 08:00:00pm</p></header><div class="content"><p>Assuming that you are using : for type assignment and -&gt; or =&gt; for functions<br></p><p>unlabelled functions would have the syntax  Int =&gt; Int not Int: Int.<br></p><p>So func(int : Int, bool: Bool) : Int  // would return a value<br></p><p>func((int: Int, bool: Bool) : Int =&gt; Int would return a function with parameter of int and and a function f(i) -&gt; int.<br></p><p><br>&gt; On 2015-12-24, at 19:38:37, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I&#39;m completely against replacing &#39;-&gt;&#39; by &#39;:&#39; it would make unreadable the declaration of a function taking a closure as parameter, or returning one (among other things).<br>&gt; <br>&gt; Actually, I find this perfectly readable, though a little bit strange after so long with the current signatures:<br>&gt; <br>&gt; 	func indexOf(predicate: Element: Bool): Index? {<br>&gt; 		for (i, elem) in zip(indexes, self) {<br>&gt; 			if predicate(elem) {<br>&gt; 				return i<br>&gt; 			}<br>&gt; 		}<br>&gt; 		return nil<br>&gt; 	}<br>&gt; <br>&gt; Where I *do* foresee big issues is with tuples. Take a look at this declaration:<br>&gt; <br>&gt; 	let tuple: (Int: Int, Bool: Bool)<br>&gt; <br>&gt; Does `tuple` contain two unlabeled functions, or two labeled values?<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7411024ff3fb3fdbb0624c41b72a1b92?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Alan Skipp</string> &lt;al_skipp at icloud.com&gt;<p>December 24, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; I&#39;m completely against replacing &#39;-&gt;&#39; by &#39;:&#39; it would make unreadable the declaration of a function taking a closure as parameter, or returning one (among other things).<br>&gt; <br>&gt; -- <br>&gt; Pierre<br></p><p>I agree with Pierre. Parameter names and functions as arguments or return values are easily distinguished currently. <br></p><p>Replacing -&gt; with :, would severely impact readability. <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151224/9da82d1b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eed60bdfc964ec62cc48aa6020a03d7b?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Alexander Regueiro</string> &lt;alexreg at gmail.com&gt;<p>December 24, 2015 at 04:00:00pm</p></header><div class="content"><p>Yeah, I&#39;m not to bothered by this either way. Back to the discussion about closure syntax, maybe?<br></p><p>Sent from my iPhone<br></p><p>&gt; On 24 Dec 2015, at 14:05, Alan Skipp &lt;al_skipp at icloud.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m completely against replacing &#39;-&gt;&#39; by &#39;:&#39; it would make unreadable the declaration of a function taking a closure as parameter, or returning one (among other things).<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Pierre<br>&gt; <br>&gt; I agree with Pierre. Parameter names and functions as arguments or return values are easily distinguished currently. <br>&gt; <br>&gt; Replacing -&gt; with :, would severely impact readability. <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151224/cca91608/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>December 23, 2015 at 09:00:00am</p></header><div class="content"><p>I would prefer the type definition for functions return type to be the same syntax as the type definition for parameters - which would leave the arrows for things like lambdas.<br></p><p>i.e. <br></p><p>   func test(symbol: String): Bool {<br></p><p>   }<br></p><p><br>&gt; On 2015-12-23, at 9:30:24, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; So I believe the opinion of the core team and the community would be generally in opposition to the style you want. I understand your arguments, but somehow they are against the entire experience of me (and, presumably, others) as developers.<br>&gt; <br>&gt; To continue our friendly banter, though, do you mind sharing your background? When I read this, I wasn&#39;t sure if you&#39;re serious or trolling:<br>&gt; <br>&gt;&gt; I would propose changing it from:<br>&gt;&gt; <br>&gt;&gt; { (param_list) -&gt; return_type in … }<br>&gt;&gt; <br>&gt;&gt; to something cleaner like:<br>&gt;&gt; <br>&gt;&gt; (param_list) -&gt; return_type =&gt; { … }<br>&gt; <br>&gt; I wonder if doing something like Haskel a lot makes you more used to that sort of arrow constructs?<br>&gt; <br>&gt; This is written in good faith; I hope I used the right tone to indicate that.<br>&gt; <br>&gt; A.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eed60bdfc964ec62cc48aa6020a03d7b?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Alexander Regueiro</string> &lt;alexreg at gmail.com&gt;<p>December 23, 2015 at 02:00:00am</p></header><div class="content"><p>Fair suggestion. I’d give this my vote, in fact.<br></p><p>&gt; On 23 Dec 2015, at 02:34, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt; <br>&gt; I would prefer the type definition for functions return type to be the same syntax as the type definition for parameters - which would leave the arrows for things like lambdas.<br>&gt; <br>&gt; i.e. <br>&gt; <br>&gt;   func test(symbol: String): Bool {<br>&gt; <br>&gt;   }<br>&gt; <br>&gt; <br>&gt;&gt; On 2015-12-23, at 9:30:24, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; So I believe the opinion of the core team and the community would be generally in opposition to the style you want. I understand your arguments, but somehow they are against the entire experience of me (and, presumably, others) as developers.<br>&gt;&gt; <br>&gt;&gt; To continue our friendly banter, though, do you mind sharing your background? When I read this, I wasn&#39;t sure if you&#39;re serious or trolling:<br>&gt;&gt; <br>&gt;&gt;&gt; I would propose changing it from:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; { (param_list) -&gt; return_type in … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; to something cleaner like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (param_list) -&gt; return_type =&gt; { … }<br>&gt;&gt; <br>&gt;&gt; I wonder if doing something like Haskel a lot makes you more used to that sort of arrow constructs?<br>&gt;&gt; <br>&gt;&gt; This is written in good faith; I hope I used the right tone to indicate that.<br>&gt;&gt; <br>&gt;&gt; A.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 22, 2015 at 12:00:00am</p></header><div class="content"><p>&gt;  am open to whether the introducing keyword is “func” (overloading the existing keyword but in an evidently separate context, and unambiguously I believe) – or “lambda” (like Python), or “\” (like Haskell) – or even something like “cl” (for Closure).<br>The cool thing with Swift compared to other languages:<br>Apple could leave out surrogates and just change the key bindings for λ ;-)<br></p><p>Me to had some instinctive repulsion against putting arguments inside the curly braces, but it has benefits, and I bet it would be tough to change such a fundamental part of the language now<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eed60bdfc964ec62cc48aa6020a03d7b?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Alexander Regueiro</string> &lt;alexreg at gmail.com&gt;<p>December 23, 2015 at 06:00:00pm</p></header><div class="content"><p>I just thought, another way of looking at this proposal is by merging the nested function and closure expression features. Or rather, simply removing current closure syntax and allowing nested functions to be specified inline (and adding capture support to nested functions). This would not only simplify the language, but improve style, in quite an elegant way.<br></p><p>&gt; On 21 Dec 2015, at 22:26, Alexander Regueiro &lt;alexreg at gmail.com&gt; wrote:<br>&gt; <br>&gt; Thanks for clarifying.<br>&gt; <br>&gt; In that case, I would propose grammar for capture expressions, which should drop in without modifications elsewhere (I say tentatively):<br>&gt; <br>&gt; closure-expression → “func&quot; closure-signature_opt { statements }<br>&gt; ‌ closure-signature → parameter-clause function-result_opt<br>&gt; ‌ closure-signature → identifier-list function-result_opt<br>&gt; ‌ closure-signature → capture-list parameter-clause function-result_opt<br>&gt; ‌ closure-signature → capture-list identifier-list function-result_opt<br>&gt; ‌ closure-signature → capture-list<br>&gt; ‌ capture-list → [ capture-list-items ]<br>&gt; ‌ capture-list-items → capture-list-item | capture-list-item , capture-list-items<br>&gt; ‌ capture-list-item → capture-specifier_opt expression<br>&gt; ‌ capture-specifier → weak | unowned | unowned(safe) | unowned(unsafe)<br>&gt; <br>&gt; I am open to whether the introducing keyword is “func” (overloading the existing keyword but in an evidently separate context, and unambiguously I believe) – or “lambda” (like Python), or “\” (like Haskell) – or even something like “cl” (for Closure). Note that the aforementioned adds an additional keyword, but also removes the the “in” keyword. For reasons mentioned in my previous message, I believe this syntax is both clearer and more consistent. It’s also more in line with other widespread languages (in my experience).<br>&gt; <br>&gt; For reference, the current grammar is:<br>&gt; <br>&gt; closure-expression → { closure-signature_opt statements }<br>&gt; ‌ closure-signature → parameter-clause function-result_opt “in&quot;<br>&gt; ‌ closure-signature → identifier-list function-result_opt “in&quot;<br>&gt; ‌ closure-signature → capture-list parameter-clause function-result_opt “in&quot;<br>&gt; ‌ closure-signature → capture-list identifier-list function-result_opt &quot;in&quot;<br>&gt; ‌ closure-signature → capture-list “in&quot;<br>&gt; ‌ capture-list → [ capture-list-items ]<br>&gt; ‌ capture-list-items → capture-list-item | capture-list-item , capture-list-items<br>&gt; ‌ capture-list-item → capture-specifier_opt expression<br>&gt; ‌ capture-specifier → weak | unowned | unowned(safe) | unowned(unsafe)<br>&gt; <br>&gt; Also, I didn’t bother making braces optional, since I hear that the original language designers wanted to avoid the problems that optional braces have the potential to introduce (e.g. in C-style languages). There are no round brackets used in my above syntax either, which is consistent with their absence in expressions in conditional and loop statements.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt;&gt; On 21 Dec 2015, at 21:47, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 21, 2015, at 1:33 PM, Alexander Regueiro &lt;alexreg at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Chris,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Don’t you think the suggestion is better? I’m happy to formula it in terms of an E(BNF) grammar if you like. Is this published/available anywhere, for the current version of Swift?<br>&gt;&gt; <br>&gt;&gt; My personal opinion is “no”, because it will look very weird in trailing closure, in the argument lists for function calls, etc.<br>&gt;&gt; <br>&gt;&gt; Further, it would not permit dropping ()’s on closure arguments, you wouldn’t be able to write this:<br>&gt;&gt; <br>&gt;&gt; foo({ lhs, rhs in … })<br>&gt;&gt; <br>&gt;&gt; because the  comma would be exposed out to the function call.<br>&gt;&gt; <br>&gt;&gt; The grammar is described in the reference section of TSPL:<br>&gt;&gt; https://swift.org/documentation/<br>&gt;&gt; <br>&gt;&gt; In addition to proposing EBNF, please consider the existing grammar so that the new proposal isn’t completely ambiguous.  What you are proposing would be an extremely tricky thing to do.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 21 Dec 2015, at 19:22, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 21, 2015, at 11:20 AM, Alexander Regueiro via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Does anyone not like the current syntax for this?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would propose changing it from:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; { (param_list) -&gt; return_type in … }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; to something cleaner like:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (param_list) -&gt; return_type =&gt; { … }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; where I’m not so bothered about the `=&gt;` separator (could be `:`, `,`, or indeed `in`).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The braces being around the type specifier as well as function body rather bothers me. Surely it would be more consistent just to have the braces around the function body, and then the type specifier preceding this?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Alexander,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We’re open in principle to replacing closure syntax with something better, but A) it needs to be actually better, and B) it needs to fit with the swift grammar.  If you’re interested in pushing forward in this area, please familiarize yourself with the structure of the grammar and propose what you’re thinking in terms of a diff to it.  Thanks,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eed60bdfc964ec62cc48aa6020a03d7b?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Alexander Regueiro</string> &lt;alexreg at gmail.com&gt;<p>December 23, 2015 at 06:00:00pm</p></header><div class="content"><p>N.B. My previous observation would also rely on return being optional (at least for single-line nested functions / closures). I believe that making return statements optional at the end of a function is already being considered under another proposal.<br></p><p>&gt; On 21 Dec 2015, at 21:47, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 21, 2015, at 1:33 PM, Alexander Regueiro &lt;alexreg at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Chris,<br>&gt;&gt; <br>&gt;&gt; Don’t you think the suggestion is better? I’m happy to formula it in terms of an E(BNF) grammar if you like. Is this published/available anywhere, for the current version of Swift?<br>&gt; <br>&gt; My personal opinion is “no”, because it will look very weird in trailing closure, in the argument lists for function calls, etc.<br>&gt; <br>&gt; Further, it would not permit dropping ()’s on closure arguments, you wouldn’t be able to write this:<br>&gt; <br>&gt; foo({ lhs, rhs in … })<br>&gt; <br>&gt; because the  comma would be exposed out to the function call.<br>&gt; <br>&gt; The grammar is described in the reference section of TSPL:<br>&gt; https://swift.org/documentation/<br>&gt; <br>&gt; In addition to proposing EBNF, please consider the existing grammar so that the new proposal isn’t completely ambiguous.  What you are proposing would be an extremely tricky thing to do.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Thanks.<br>&gt;&gt; <br>&gt;&gt;&gt; On 21 Dec 2015, at 19:22, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 21, 2015, at 11:20 AM, Alexander Regueiro via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Does anyone not like the current syntax for this?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would propose changing it from:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; { (param_list) -&gt; return_type in … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; to something cleaner like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (param_list) -&gt; return_type =&gt; { … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; where I’m not so bothered about the `=&gt;` separator (could be `:`, `,`, or indeed `in`).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The braces being around the type specifier as well as function body rather bothers me. Surely it would be more consistent just to have the braces around the function body, and then the type specifier preceding this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Alexander,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We’re open in principle to replacing closure syntax with something better, but A) it needs to be actually better, and B) it needs to fit with the swift grammar.  If you’re interested in pushing forward in this area, please familiarize yourself with the structure of the grammar and propose what you’re thinking in terms of a diff to it.  Thanks,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5a72880ffed1a30cb9b8e3f372507145?s=50"></div><header><strong>Lambda function syntax</strong> from <string>Rob Mayoff</string> &lt;mayoff at dqd.com&gt;<p>December 23, 2015 at 02:00:00am</p></header><div class="content"><p>&gt;<br>&gt; The braces being around the type specifier as well as function body rather<br>&gt; bothers me. Surely it would be more consistent just to have the braces<br>&gt; around the function body, and then the type specifier preceding this?<br>&gt;<br></p><p>If you mean consistency between closures and function declarations,<br>wouldn&#39;t it be simpler to go the other way?<br></p><p>    func tableView { (tableView: UITableView, cellForRowAtIndexPath<br>indexPath: NSIndexPath) -&gt; UITableViewCell in<br>        ...<br>    }<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/76f4cf40/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
