<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>[Proposal Update 1] A simplified notation for avoiding the weak/strong dance with closure capture lists</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>February 12, 2016 at 01:00:00pm</p></header><div class="content"><p>Hello,<br></p><p>I sent out an earlier draft of this proposal last week, and have updated it based on feedback from the list.<br></p><p>The newer proposal now has a much smaller conceptual footprint to address concerns that the previous iteration was too complex and would lead to verbose notation within the capture lists.<br></p><p>You can find the updated gist here &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440&gt;, as well as pasted below.<br></p><p>Evan<br></p><p>---<br></p><p>Simplified notation for avoiding the [weak self]/strongSelf dance with closures<br></p><p>Proposal: TBD<br>Author: Evan Maloney &lt;https://github.com/emaloney&gt;<br>Status: Draft<br>Review manager: TBD<br> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#introduction&gt;Introduction<br></p><p>Frequently, closures are used as completion callbacks for asynchronous operations, such as when dealing with network requests. It is quite common to model these sorts of operations in such a way that an object instance represents a request/response transaction, for example:<br></p><p>protocol NetworkTransaction: class<br>{<br>    enum Result {<br>        case Succeeded(NSData)<br>        case Failed(ErrorType)<br>    }<br></p><p>    func execute(completion: (Result) -&gt; Void)<br>}<br>Here, the NetworkTransaction protocol declares the interface by which an asynchronous transaction occurs. The user of a NetworkTransaction calls the execute() function, passing in a completion function that is called at some time in the future, when the transaction completes.<br></p><p>For example, imagine a hypothetical DataConsumer class that uses a transaction to try to fetch some network data and process it:<br></p><p>class DataConsumer<br>{<br>    let transaction: NetworkTransaction<br></p><p>    init(transaction: NetworkTransaction)<br>    {<br>        self.transaction = transaction<br>    }<br></p><p>    func fetchData()<br>    {<br>        transaction.execute() { [weak self] result in<br>            guard let strongSelf = self else { <br>                return<br>            }<br></p><p>            switch result {<br>            case .Succeeded(let data):<br>                strongSelf.processData(data)<br></p><p>            case .Failed(let err):<br>                strongSelf.handleError(err)<br>            }<br>        }<br>    }<br></p><p>    func processData(data: NSData) <br>    {<br>        // process the data<br>    }<br></p><p>    func handleError(error: ErrorType)<br>    {<br>        // handle the error<br>    }<br>}<br>You&#39;ll notice the [weak self]/strongSelf dance in the fetchData() function. This is a common pattern with asynchronously-executed closures, and it signals the possibility that a closure might outlive its usefulness.<br></p><p>Because the NetworkTransaction may complete at any time, it is possible that the closure will execute after the DataConsumer that initiated the transaction has been deallocated. Perhaps the user has navigated elsewhere in the application and whatever data was to be fetched by DataConsumer is no longer needed.<br></p><p>In this case, after a DataConsumer instance goes away, we don&#39;t really want the closure doing anything. So, we capture self weakly to ensure that the closure doesn&#39;t hold a reference to the owning DataConsumer. That prevents a reference cycle and ensures that DataConsumer can be deallocated when no longer in use.<br></p><p>When it comes time to execute the closure, the guard statement effectively asks the question, &quot;Is self still alive?&quot; If the answer is no, the guard forces a return and the rest of the closure does not execute.<br></p><p>If self is still alive, then the weakly-captured self will be non-nil and it will be converted into a strong reference held by strongSelf for the duration of the closure&#39;s execution.<br></p><p>When the closure is done executing, strongSelf goes away, once again making the DataConsumer eligible for deallocation when no other references are held.<br></p><p> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#the-problem&gt;The Problem<br></p><p>The [weak self]/strongSelf dance requires common boilerplate wherever it is used, and the fact that a self-like variable with an arbitrary name adds noise within the closure. The more strongSelf is needed within the closure, the more noise there is.<br></p><p>Further, using a consistent name like strongSelf is by convention only; it can&#39;t be enforced by the compiler, so searching your codebase for a given keyword won&#39;t be exhaustive if team members use the wrong name.<br></p><p> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#proposed-solution&gt;Proposed Solution<br></p><p>The proposed solution adds a new capture type by repurposing the guard keyword for another use, which would look like:<br></p><p>transaction.execute() { [guard self] result in<br>    switch result {<br>    case .Succeeded(let data):<br>        self.processData(data)<br></p><p>    case .Failed(let err):<br>        self.handleError(err)<br>    }<br>}<br>Here, the [guard self] capture list serves as a signal that the compiler should handle the weak/strong dance itself. When encountering [guard self], the compiler should emit code that does the following:<br></p><p>Captures self in a weak reference on behalf of the closure<br>Whenever the closure is about to be executed, the weak reference is checked to see if self is still alive<br>If self is not alive, the closure becomes a no-op &lt;https://en.wikipedia.org/wiki/NOP&gt;; calling the closure returns immediately without anything inside the braces being executed<br>If self is alive, it is upgraded to a strong reference for the lifetime of the closure&#39;s execution. Within the closure, self is non-optional, unlike how it would be with a [weak self] capture. When the closure is done executing, the strong reference will be cleared and only the weak reference will be held on behalf of the closure.<br> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#non-self-references&gt;Non-self References<br></p><p>Because guard is an additional capture type, like weak and unowned, it can also be used to capture references other than self:<br></p><p>let capturingTwo = { [guard self, button] in<br>    // weakly capture self and button<br>    // but execute the closure with strong references<br>    // if and only if self AND button still exist<br>    // when the closure is being asked to execute<br>}<br>When encountering multiple references being captured via guard, the closure will execute only when all references are still alive when the closure is being asked to execute.<br></p><p> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#limitations&gt;Limitations<br></p><p>Because guard is a special capture type that causes the closure to become a no-op once a referenced object deallocates, it is only designed to be used with closures returning Void.<br></p><p>This limitation was deemed acceptable because it would cover the vast majority of cases, and those that it didn&#39;t cover can still fall back on the existing technique.<br></p><p>The compiler should emit an error if this notation is used in conjunction with a closure that has a non-Void return type.<br></p><p> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#caveats&gt;Caveats<br></p><p>This notation is not intended to be a full-fledged replacement for guard statements within the closure. We are only using guard here as a way to declare a specific memory-management behavior for references. Therefore, guard within [square brackets ] should be seen as a capture type on par with weak or unowned.<br></p><p>Unlike with a typical guard statement, we are not attempting to support an else or where clause, or any boolean expressions within this notation.<br></p><p>Rather, we&#39;re simply adding a new capture behavior and providing a means to specify an early exit if the behavior couldn&#39;t be fulfilled because one or more objects was deallocated.<br></p><p>The word guard was chosen as the capture type because (1) it functions as a guard, ensuring that the closure doesn&#39;t execute unless the specified objects are still alive, and (2) it obviates the need for the full-fledged guard statement that would otherwise be required to achieve the same result.<br></p><p> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#impact-on-existing-code&gt;Impact on Existing Code<br></p><p>None, since this does not affect any existing constructs. Implementation of this proposal will not result in any code breakage.<br></p><p> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#alternatives-considered&gt;Alternatives Considered<br></p><p> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#status-quo&gt;Status Quo<br></p><p>The primary alternative is to do nothing, requiring developers to add boilerplate guard code and handle upgrading the weak-to-strong references manually.<br></p><p>As stated above, this leads to needless boilerplate that can easily be factored out by the compiler. Also, the use of a self-like variable with an arbitrary name makes it more difficult to exhaustively find such uses in large projects. With this proposal, searching for the text &quot;[guard&quot; is all that&#39;s necessary to find all instances of this memory management technique.<br></p><p>Finally, the need to declare and use alternate names to capture values that already have existing names adds visual clutter to code and serves to obscure the code&#39;s original intent, making it harder to reason about.<br></p><p> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#closures-with-an-optional-return-type&gt;Closures with an Optional Return Type<br></p><p>One possible addition to this proposal would extend support to any closure returning an Optional of some kind.<br></p><p>If one of the objects in a guard capture list has been deallocated, executing the closure will always result in an immediate nil return.<br></p><p>This idea was excluded from this iteration of the proposal due to a concern that it relied on a &quot;magic return value&quot; (albeit a reasonable one) and a perception that the community favored a solution with a smaller conceptual footprint.<br></p><p> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#closures-with-a-bool-return-type&gt;Closures with a Bool Return Type<br></p><p>One possible addition to this proposal would extend support to any closure returning a Bool.<br></p><p>If one of the objects in a guard capture list has been deallocated, executing the closure will always result in an immediate false return.<br></p><p>This idea was excluded from this iteration of the proposal due to a concern that it relied on a &quot;magic return value&quot; (albeit a reasonable one) and a perception that the community favored a solution with a smaller conceptual footprint.<br></p><p> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#closures-with-arbitrary-return-types&gt;Closures with Arbitrary Return Types<br></p><p>An earlier iteration of this proposal included support for closures with arbitrary return values. The community consensus was that the proposal was too heavy-weight and tried to do too much, and would lead to verbosity within the capture declaration. As a result, this idea was removed from the proposal.<br></p><p>The ability to handle non-Void return values relied on supporting an else clause within a guard-based capture list:<br></p><p>let happinessLevel: () -&gt; Int = { [guard self else -1] in<br>    var level = 0<br>    level += self.isHealthy ? 25 : 0<br>    level += !self.isHungry ? 25 : 0<br>    level += !self.isFearful ? 25 : 0<br>    level += self.hasLove ? 25 : 0<br>    return level<br>}<br>Here, the else clause provides a value to return in cases where self has gone away and the guard fails.<br></p><p>In this example, if you call happinessLevel() after self has been deallocated, the value -1 will always be returned.<br></p><p> &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#citations&gt;Citations<br></p><p>Variations on this proposal were discussed earlier in the following swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; threads:<br></p><p>Wanted: syntactic sugar for [weak self] callbacks &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/008713.html&gt;<br>Allowing guard let self = self else { … } for weakly captured self in a closure. &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/009023.html&gt;<br>[Draft Proposal] A simplified notation for avoiding the weak/strong dance with closure capture lists &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/009241.html&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/d3af6263/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7321934b88ca8da079d7b89926501a9c?s=50"></div><header><strong>[Proposal Update 1] A simplified notation for avoiding the weak/strong dance with closure capture lists</strong> from <string>David Turnbull</string> &lt;dturnbull at gmail.com&gt;<p>February 12, 2016 at 10:00:00am</p></header><div class="content"><p>This could be the default behavior. A program can request &quot;self&quot;, &quot;weak<br>self&quot;, or &quot;unowned self&quot; if they want something else.<br></p><p>-david<br></p><p>On Fri, Feb 12, 2016 at 10:23 AM, Evan Maloney via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello,<br>&gt;<br>&gt; I sent out an earlier draft of this proposal last week, and have updated<br>&gt; it based on feedback from the list.<br>&gt;<br>&gt; The newer proposal now has a much smaller conceptual footprint to address<br>&gt; concerns that the previous iteration was too complex and would lead to<br>&gt; verbose notation within the capture lists.<br>&gt;<br>&gt; You can find the updated gist here<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440&gt;, as well as<br>&gt; pasted below.<br>&gt;<br>&gt; Evan<br>&gt;<br>&gt; ---<br>&gt;<br>&gt; Simplified notation for avoiding the [weak self]/strongSelf dance with<br>&gt; closures<br>&gt;<br>&gt;    - Proposal: TBD<br>&gt;    - Author: Evan Maloney &lt;https://github.com/emaloney&gt;<br>&gt;    - Status: *Draft*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Frequently, closures are used as completion callbacks for asynchronous<br>&gt; operations, such as when dealing with network requests. It is quite common<br>&gt; to model these sorts of operations in such a way that an object instance<br>&gt; represents a request/response transaction, for example:<br>&gt;<br>&gt; protocol NetworkTransaction: class<br>&gt; {<br>&gt;     enum Result {<br>&gt;         case Succeeded(NSData)<br>&gt;         case Failed(ErrorType)<br>&gt;     }<br>&gt;<br>&gt;     func execute(completion: (Result) -&gt; Void)<br>&gt; }<br>&gt;<br>&gt; Here, the NetworkTransaction protocol declares the interface by which an<br>&gt; asynchronous transaction occurs. The user of a NetworkTransaction calls<br>&gt; the execute() function, passing in a completion function that is called<br>&gt; at some time in the future, when the transaction completes.<br>&gt;<br>&gt; For example, imagine a hypothetical DataConsumer class that uses a<br>&gt; transaction to try to fetch some network data and process it:<br>&gt;<br>&gt; class DataConsumer<br>&gt; {<br>&gt;     let transaction: NetworkTransaction<br>&gt;<br>&gt;     init(transaction: NetworkTransaction)<br>&gt;     {<br>&gt;         self.transaction = transaction<br>&gt;     }<br>&gt;<br>&gt;     func fetchData()<br>&gt;     {<br>&gt;         transaction.execute() { [weak self] result in<br>&gt;             guard let strongSelf = self else {<br>&gt;                 return<br>&gt;             }<br>&gt;<br>&gt;             switch result {<br>&gt;             case .Succeeded(let data):<br>&gt;                 strongSelf.processData(data)<br>&gt;<br>&gt;             case .Failed(let err):<br>&gt;                 strongSelf.handleError(err)<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     func processData(data: NSData)<br>&gt;     {<br>&gt;         // process the data<br>&gt;     }<br>&gt;<br>&gt;     func handleError(error: ErrorType)<br>&gt;     {<br>&gt;         // handle the error<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; You&#39;ll notice the [weak self]/strongSelf dance in the fetchData() function.<br>&gt; This is a common pattern with asynchronously-executed closures, and it<br>&gt; signals the possibility that a closure might outlive its usefulness.<br>&gt;<br>&gt; Because the NetworkTransaction may complete at any time, it is possible<br>&gt; that the closure will execute after the DataConsumer that initiated the<br>&gt; transaction has been deallocated. Perhaps the user has navigated elsewhere<br>&gt; in the application and whatever data was to be fetched by DataConsumer is<br>&gt; no longer needed.<br>&gt;<br>&gt; In this case, after a DataConsumer instance goes away, we don&#39;t really<br>&gt; want the closure doing anything. So, we capture self weakly to ensure<br>&gt; that the closure doesn&#39;t hold a reference to the owning DataConsumer.<br>&gt; That prevents a reference cycle and ensures that DataConsumer can be<br>&gt; deallocated when no longer in use.<br>&gt;<br>&gt; When it comes time to execute the closure, the guard statement<br>&gt; effectively asks the question, &quot;Is self still alive?&quot; If the answer is<br>&gt; no, the guard forces a return and the rest of the closure does not execute.<br>&gt;<br>&gt; If self *is* still alive, then the weakly-captured self will be non-nil and<br>&gt; it will be converted into a strong reference held by strongSelf for the<br>&gt; duration of the closure&#39;s execution.<br>&gt;<br>&gt; When the closure is done executing, strongSelf goes away, once again<br>&gt; making the DataConsumer eligible for deallocation when no other<br>&gt; references are held.<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#the-problem&gt;The<br>&gt; Problem<br>&gt;<br>&gt; The [weak self]/strongSelf dance requires common boilerplate wherever it<br>&gt; is used, and the fact that a self-like variable with an arbitrary name<br>&gt; adds noise within the closure. The more strongSelf is needed within the<br>&gt; closure, the more noise there is.<br>&gt;<br>&gt; Further, using a consistent name like strongSelf is by convention only;<br>&gt; it can&#39;t be enforced by the compiler, so searching your codebase for a<br>&gt; given keyword won&#39;t be exhaustive if team members use the wrong name.<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#proposed-solution&gt;Proposed<br>&gt; Solution<br>&gt;<br>&gt; The proposed solution adds a new capture type by repurposing the guard keyword<br>&gt; for another use, which would look like:<br>&gt;<br>&gt; transaction.execute() { [guard self] result in<br>&gt;     switch result {<br>&gt;     case .Succeeded(let data):<br>&gt;         self.processData(data)<br>&gt;<br>&gt;     case .Failed(let err):<br>&gt;         self.handleError(err)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Here, the [guard self] capture list serves as a signal that the compiler<br>&gt; should handle the weak/strong dance itself. When encountering [guard self],<br>&gt; the compiler should emit code that does the following:<br>&gt;<br>&gt;    - Captures self in a weak reference on behalf of the closure<br>&gt;    - Whenever the closure is about to be executed, the weak reference is<br>&gt;    checked to see if self is still alive<br>&gt;       - If self is not alive, the closure becomes a no-op<br>&gt;       &lt;https://en.wikipedia.org/wiki/NOP&gt;; calling the closure returns<br>&gt;       immediately without anything inside the braces being executed<br>&gt;       - If self is alive, it is upgraded to a strong reference for the<br>&gt;       lifetime of the closure&#39;s execution. Within the closure, self is<br>&gt;       non-optional, unlike how it would be with a [weak self] capture.<br>&gt;       When the closure is done executing, the strong reference will be cleared<br>&gt;       and only the weak reference will be held on behalf of the closure.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#non-self-references&gt;<br>&gt; Non-self References<br>&gt;<br>&gt; Because guard is an additional capture type, like weak and unowned, it<br>&gt; can also be used to capture references other than self:<br>&gt;<br>&gt; let capturingTwo = { [guard self, button] in<br>&gt;     // weakly capture self and button<br>&gt;     // but execute the closure with strong references<br>&gt;     // if and only if self AND button still exist<br>&gt;     // when the closure is being asked to execute<br>&gt; }<br>&gt;<br>&gt; When encountering multiple references being captured via guard, the<br>&gt; closure will execute *only* when *all* references are still alive when<br>&gt; the closure is being asked to execute.<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#limitations&gt;<br>&gt; Limitations<br>&gt;<br>&gt; Because guard is a special capture type that causes the closure to become<br>&gt; a no-op once a referenced object deallocates, it is only designed to be<br>&gt; used with closures returning Void.<br>&gt;<br>&gt; This limitation was deemed acceptable because it would cover the vast<br>&gt; majority of cases, and those that it didn&#39;t cover can still fall back on<br>&gt; the existing technique.<br>&gt;<br>&gt; The compiler should emit an error if this notation is used in conjunction<br>&gt; with a closure that has a non-Void return type.<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#caveats&gt;Caveats<br>&gt;<br>&gt; This notation is not intended to be a full-fledged replacement for guard<br>&gt; statements within the closure. We are only using guard here as a way to<br>&gt; declare a specific memory-management behavior for references. Therefore,<br>&gt; guard within [square brackets ] should be seen as a capture type on par<br>&gt; with weak or unowned.<br>&gt;<br>&gt; Unlike with a typical guard statement, we are not attempting to support<br>&gt; an else or where clause, or any boolean expressions within this notation.<br>&gt;<br>&gt; Rather, we&#39;re simply adding a new capture behavior and providing a means<br>&gt; to specify an early exit if the behavior couldn&#39;t be fulfilled because one<br>&gt; or more objects was deallocated.<br>&gt;<br>&gt; The word guard was chosen as the capture type because (1) it functions as<br>&gt; a guard, ensuring that the closure doesn&#39;t execute unless the specified<br>&gt; objects are still alive, and (2) it obviates the need for the full-fledged<br>&gt; guard statement that would otherwise be required to achieve the same<br>&gt; result.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; None, since this does not affect any existing constructs. Implementation<br>&gt; of this proposal will not result in any code breakage.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#status-quo&gt;Status<br>&gt; Quo<br>&gt;<br>&gt; The primary alternative is to do nothing, requiring developers to add<br>&gt; boilerplate guard code and handle upgrading the weak-to-strong references<br>&gt; manually.<br>&gt;<br>&gt; As stated above, this leads to needless boilerplate that can easily be<br>&gt; factored out by the compiler. Also, the use of a self-like variable with<br>&gt; an arbitrary name makes it more difficult to exhaustively find such uses in<br>&gt; large projects. With this proposal, searching for the text &quot;[guard&quot; is<br>&gt; all that&#39;s necessary to find all instances of this memory management<br>&gt; technique.<br>&gt;<br>&gt; Finally, the need to declare and use alternate names to capture values<br>&gt; that already have existing names adds visual clutter to code and serves to<br>&gt; obscure the code&#39;s original intent, making it harder to reason about.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#closures-with-an-optional-return-type&gt;Closures<br>&gt; with an Optional Return Type<br>&gt;<br>&gt; One possible addition to this proposal would extend support to any closure<br>&gt; returning an Optional of some kind.<br>&gt;<br>&gt; If one of the objects in a guard capture list has been deallocated,<br>&gt; executing the closure will always result in an immediate nil return.<br>&gt;<br>&gt; This idea was excluded from this iteration of the proposal due to a<br>&gt; concern that it relied on a &quot;magic return value&quot; (albeit a reasonable one)<br>&gt; and a perception that the community favored a solution with a smaller<br>&gt; conceptual footprint.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#closures-with-a-bool-return-type&gt;Closures<br>&gt; with a Bool Return Type<br>&gt;<br>&gt; One possible addition to this proposal would extend support to any closure<br>&gt; returning a Bool.<br>&gt;<br>&gt; If one of the objects in a guard capture list has been deallocated,<br>&gt; executing the closure will always result in an immediate false return.<br>&gt;<br>&gt; This idea was excluded from this iteration of the proposal due to a<br>&gt; concern that it relied on a &quot;magic return value&quot; (albeit a reasonable one)<br>&gt; and a perception that the community favored a solution with a smaller<br>&gt; conceptual footprint.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#closures-with-arbitrary-return-types&gt;Closures<br>&gt; with Arbitrary Return Types<br>&gt;<br>&gt; An earlier iteration of this proposal included support for closures with<br>&gt; arbitrary return values. The community consensus was that the proposal was<br>&gt; too heavy-weight and tried to do too much, and would lead to verbosity<br>&gt; within the capture declaration. As a result, this idea was removed from the<br>&gt; proposal.<br>&gt;<br>&gt; The ability to handle non-Void return values relied on supporting an else clause<br>&gt; within a guard-based capture list:<br>&gt;<br>&gt; let happinessLevel: () -&gt; Int = { [guard self else -1] in<br>&gt;     var level = 0<br>&gt;     level += self.isHealthy ? 25 : 0<br>&gt;     level += !self.isHungry ? 25 : 0<br>&gt;     level += !self.isFearful ? 25 : 0<br>&gt;     level += self.hasLove ? 25 : 0<br>&gt;     return level<br>&gt; }<br>&gt;<br>&gt; Here, the else clause provides a value to return in cases where self has<br>&gt; gone away and the guard fails.<br>&gt;<br>&gt; In this example, if you call happinessLevel() after self has been<br>&gt; deallocated, the value -1 will always be returned.<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#citations&gt;Citations<br>&gt;<br>&gt; Variations on this proposal were discussed earlier in the following<br>&gt; swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  threads:<br>&gt;<br>&gt;    - Wanted: syntactic sugar for [weak self] callbacks<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/008713.html&gt;<br>&gt;    - Allowing guard let self = self else { … } for weakly captured self<br>&gt;    in a closure.<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/009023.html&gt;<br>&gt;    - [Draft Proposal] A simplified notation for avoiding the weak/strong<br>&gt;    dance with closure capture lists<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/009241.html&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/bac88a09/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal Update 1] A simplified notation for avoiding the weak/strong dance with closure capture lists</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 12, 2016 at 11:00:00am</p></header><div class="content"><p>So long as it&#39;s technically possible, this would rock.<br></p><p>-- E<br></p><p><br>&gt; On Feb 12, 2016, at 11:23 AM, Evan Maloney &lt;emaloney at gilt.com&gt; wrote:<br>&gt; <br>&gt; Hello,<br>&gt; <br>&gt; I sent out an earlier draft of this proposal last week, and have updated it based on feedback from the list.<br>&gt; <br>&gt; The newer proposal now has a much smaller conceptual footprint to address concerns that the previous iteration was too complex and would lead to verbose notation within the capture lists.<br>&gt; <br>&gt; You can find the updated gist here &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440&gt;, as well as pasted below.<br>&gt; <br>&gt; Evan<br>&gt; <br>&gt; ---<br>&gt; <br>&gt; Simplified notation for avoiding the [weak self]/strongSelf dance with closures<br>&gt; <br>&gt; Proposal: TBD<br>&gt; Author: Evan Maloney &lt;https://github.com/emaloney&gt;<br>&gt; Status: Draft<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#introduction&gt;Introduction<br>&gt; <br>&gt; Frequently, closures are used as completion callbacks for asynchronous operations, such as when dealing with network requests. It is quite common to model these sorts of operations in such a way that an object instance represents a request/response transaction, for example:<br>&gt; <br>&gt; protocol NetworkTransaction: class<br>&gt; {<br>&gt;     enum Result {<br>&gt;         case Succeeded(NSData)<br>&gt;         case Failed(ErrorType)<br>&gt;     }<br>&gt; <br>&gt;     func execute(completion: (Result) -&gt; Void)<br>&gt; }<br>&gt; Here, the NetworkTransaction protocol declares the interface by which an asynchronous transaction occurs. The user of a NetworkTransaction calls the execute() function, passing in a completion function that is called at some time in the future, when the transaction completes.<br>&gt; <br>&gt; For example, imagine a hypothetical DataConsumer class that uses a transaction to try to fetch some network data and process it:<br>&gt; <br>&gt; class DataConsumer<br>&gt; {<br>&gt;     let transaction: NetworkTransaction<br>&gt; <br>&gt;     init(transaction: NetworkTransaction)<br>&gt;     {<br>&gt;         self.transaction = transaction<br>&gt;     }<br>&gt; <br>&gt;     func fetchData()<br>&gt;     {<br>&gt;         transaction.execute() { [weak self] result in<br>&gt;             guard let strongSelf = self else { <br>&gt;                 return<br>&gt;             }<br>&gt; <br>&gt;             switch result {<br>&gt;             case .Succeeded(let data):<br>&gt;                 strongSelf.processData(data)<br>&gt; <br>&gt;             case .Failed(let err):<br>&gt;                 strongSelf.handleError(err)<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt;     func processData(data: NSData) <br>&gt;     {<br>&gt;         // process the data<br>&gt;     }<br>&gt; <br>&gt;     func handleError(error: ErrorType)<br>&gt;     {<br>&gt;         // handle the error<br>&gt;     }<br>&gt; }<br>&gt; You&#39;ll notice the [weak self]/strongSelf dance in the fetchData() function. This is a common pattern with asynchronously-executed closures, and it signals the possibility that a closure might outlive its usefulness.<br>&gt; <br>&gt; Because the NetworkTransaction may complete at any time, it is possible that the closure will execute after the DataConsumer that initiated the transaction has been deallocated. Perhaps the user has navigated elsewhere in the application and whatever data was to be fetched by DataConsumer is no longer needed.<br>&gt; <br>&gt; In this case, after a DataConsumer instance goes away, we don&#39;t really want the closure doing anything. So, we capture self weakly to ensure that the closure doesn&#39;t hold a reference to the owning DataConsumer. That prevents a reference cycle and ensures that DataConsumer can be deallocated when no longer in use.<br>&gt; <br>&gt; When it comes time to execute the closure, the guard statement effectively asks the question, &quot;Is self still alive?&quot; If the answer is no, the guard forces a return and the rest of the closure does not execute.<br>&gt; <br>&gt; If self is still alive, then the weakly-captured self will be non-nil and it will be converted into a strong reference held by strongSelf for the duration of the closure&#39;s execution.<br>&gt; <br>&gt; When the closure is done executing, strongSelf goes away, once again making the DataConsumer eligible for deallocation when no other references are held.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#the-problem&gt;The Problem<br>&gt; <br>&gt; The [weak self]/strongSelf dance requires common boilerplate wherever it is used, and the fact that a self-like variable with an arbitrary name adds noise within the closure. The more strongSelf is needed within the closure, the more noise there is.<br>&gt; <br>&gt; Further, using a consistent name like strongSelf is by convention only; it can&#39;t be enforced by the compiler, so searching your codebase for a given keyword won&#39;t be exhaustive if team members use the wrong name.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#proposed-solution&gt;Proposed Solution<br>&gt; <br>&gt; The proposed solution adds a new capture type by repurposing the guard keyword for another use, which would look like:<br>&gt; <br>&gt; transaction.execute() { [guard self] result in<br>&gt;     switch result {<br>&gt;     case .Succeeded(let data):<br>&gt;         self.processData(data)<br>&gt; <br>&gt;     case .Failed(let err):<br>&gt;         self.handleError(err)<br>&gt;     }<br>&gt; }<br>&gt; Here, the [guard self] capture list serves as a signal that the compiler should handle the weak/strong dance itself. When encountering [guard self], the compiler should emit code that does the following:<br>&gt; <br>&gt; Captures self in a weak reference on behalf of the closure<br>&gt; Whenever the closure is about to be executed, the weak reference is checked to see if self is still alive<br>&gt; If self is not alive, the closure becomes a no-op &lt;https://en.wikipedia.org/wiki/NOP&gt;; calling the closure returns immediately without anything inside the braces being executed<br>&gt; If self is alive, it is upgraded to a strong reference for the lifetime of the closure&#39;s execution. Within the closure, self is non-optional, unlike how it would be with a [weak self] capture. When the closure is done executing, the strong reference will be cleared and only the weak reference will be held on behalf of the closure.<br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#non-self-references&gt;Non-self References<br>&gt; <br>&gt; Because guard is an additional capture type, like weak and unowned, it can also be used to capture references other than self:<br>&gt; <br>&gt; let capturingTwo = { [guard self, button] in<br>&gt;     // weakly capture self and button<br>&gt;     // but execute the closure with strong references<br>&gt;     // if and only if self AND button still exist<br>&gt;     // when the closure is being asked to execute<br>&gt; }<br>&gt; When encountering multiple references being captured via guard, the closure will execute only when all references are still alive when the closure is being asked to execute.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#limitations&gt;Limitations<br>&gt; <br>&gt; Because guard is a special capture type that causes the closure to become a no-op once a referenced object deallocates, it is only designed to be used with closures returning Void.<br>&gt; <br>&gt; This limitation was deemed acceptable because it would cover the vast majority of cases, and those that it didn&#39;t cover can still fall back on the existing technique.<br>&gt; <br>&gt; The compiler should emit an error if this notation is used in conjunction with a closure that has a non-Void return type.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#caveats&gt;Caveats<br>&gt; <br>&gt; This notation is not intended to be a full-fledged replacement for guard statements within the closure. We are only using guard here as a way to declare a specific memory-management behavior for references. Therefore, guard within [square brackets ] should be seen as a capture type on par with weak or unowned.<br>&gt; <br>&gt; Unlike with a typical guard statement, we are not attempting to support an else or where clause, or any boolean expressions within this notation.<br>&gt; <br>&gt; Rather, we&#39;re simply adding a new capture behavior and providing a means to specify an early exit if the behavior couldn&#39;t be fulfilled because one or more objects was deallocated.<br>&gt; <br>&gt; The word guard was chosen as the capture type because (1) it functions as a guard, ensuring that the closure doesn&#39;t execute unless the specified objects are still alive, and (2) it obviates the need for the full-fledged guard statement that would otherwise be required to achieve the same result.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; None, since this does not affect any existing constructs. Implementation of this proposal will not result in any code breakage.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#status-quo&gt;Status Quo<br>&gt; <br>&gt; The primary alternative is to do nothing, requiring developers to add boilerplate guard code and handle upgrading the weak-to-strong references manually.<br>&gt; <br>&gt; As stated above, this leads to needless boilerplate that can easily be factored out by the compiler. Also, the use of a self-like variable with an arbitrary name makes it more difficult to exhaustively find such uses in large projects. With this proposal, searching for the text &quot;[guard&quot; is all that&#39;s necessary to find all instances of this memory management technique.<br>&gt; <br>&gt; Finally, the need to declare and use alternate names to capture values that already have existing names adds visual clutter to code and serves to obscure the code&#39;s original intent, making it harder to reason about.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#closures-with-an-optional-return-type&gt;Closures with an Optional Return Type<br>&gt; <br>&gt; One possible addition to this proposal would extend support to any closure returning an Optional of some kind.<br>&gt; <br>&gt; If one of the objects in a guard capture list has been deallocated, executing the closure will always result in an immediate nil return.<br>&gt; <br>&gt; This idea was excluded from this iteration of the proposal due to a concern that it relied on a &quot;magic return value&quot; (albeit a reasonable one) and a perception that the community favored a solution with a smaller conceptual footprint.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#closures-with-a-bool-return-type&gt;Closures with a Bool Return Type<br>&gt; <br>&gt; One possible addition to this proposal would extend support to any closure returning a Bool.<br>&gt; <br>&gt; If one of the objects in a guard capture list has been deallocated, executing the closure will always result in an immediate false return.<br>&gt; <br>&gt; This idea was excluded from this iteration of the proposal due to a concern that it relied on a &quot;magic return value&quot; (albeit a reasonable one) and a perception that the community favored a solution with a smaller conceptual footprint.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#closures-with-arbitrary-return-types&gt;Closures with Arbitrary Return Types<br>&gt; <br>&gt; An earlier iteration of this proposal included support for closures with arbitrary return values. The community consensus was that the proposal was too heavy-weight and tried to do too much, and would lead to verbosity within the capture declaration. As a result, this idea was removed from the proposal.<br>&gt; <br>&gt; The ability to handle non-Void return values relied on supporting an else clause within a guard-based capture list:<br>&gt; <br>&gt; let happinessLevel: () -&gt; Int = { [guard self else -1] in<br>&gt;     var level = 0<br>&gt;     level += self.isHealthy ? 25 : 0<br>&gt;     level += !self.isHungry ? 25 : 0<br>&gt;     level += !self.isFearful ? 25 : 0<br>&gt;     level += self.hasLove ? 25 : 0<br>&gt;     return level<br>&gt; }<br>&gt; Here, the else clause provides a value to return in cases where self has gone away and the guard fails.<br>&gt; <br>&gt; In this example, if you call happinessLevel() after self has been deallocated, the value -1 will always be returned.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#citations&gt;Citations<br>&gt; <br>&gt; Variations on this proposal were discussed earlier in the following swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; threads:<br>&gt; <br>&gt; Wanted: syntactic sugar for [weak self] callbacks &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/008713.html&gt;<br>&gt; Allowing guard let self = self else { … } for weakly captured self in a closure. &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/009023.html&gt;<br>&gt; [Draft Proposal] A simplified notation for avoiding the weak/strong dance with closure capture lists &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/009241.html&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/4fcb2711/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/502f76b6ca94ea1c6e262634231b0888?s=50"></div><header><strong>[Proposal Update 1] A simplified notation for avoiding the weak/strong dance with closure capture lists</strong> from <string>Jason Gregori</string> &lt;jasongregori at gmail.com&gt;<p>February 12, 2016 at 11:00:00am</p></header><div class="content"><p>I like this much better 👍🏼.<br></p><p>Although I think adding weak in there would make what&#39;s going on much<br>clearer. [guard self] looks more like it returns if self is nil. [guard<br>weak self] obviously has something to do with weak semantics.<br></p><p><br></p><p>On Fri, Feb 12, 2016 at 10:44 AM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; So long as it&#39;s technically possible, this would rock.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; On Feb 12, 2016, at 11:23 AM, Evan Maloney &lt;emaloney at gilt.com&gt; wrote:<br>&gt;<br>&gt; Hello,<br>&gt;<br>&gt; I sent out an earlier draft of this proposal last week, and have updated<br>&gt; it based on feedback from the list.<br>&gt;<br>&gt; The newer proposal now has a much smaller conceptual footprint to address<br>&gt; concerns that the previous iteration was too complex and would lead to<br>&gt; verbose notation within the capture lists.<br>&gt;<br>&gt; You can find the updated gist here<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440&gt;, as well as<br>&gt; pasted below.<br>&gt;<br>&gt; Evan<br>&gt;<br>&gt; ---<br>&gt;<br>&gt; Simplified notation for avoiding the [weak self]/strongSelf dance with<br>&gt; closures<br>&gt;<br>&gt;    - Proposal: TBD<br>&gt;    - Author: Evan Maloney &lt;https://github.com/emaloney&gt;<br>&gt;    - Status: *Draft*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Frequently, closures are used as completion callbacks for asynchronous<br>&gt; operations, such as when dealing with network requests. It is quite common<br>&gt; to model these sorts of operations in such a way that an object instance<br>&gt; represents a request/response transaction, for example:<br>&gt;<br>&gt; protocol NetworkTransaction: class<br>&gt; {<br>&gt;     enum Result {<br>&gt;         case Succeeded(NSData)<br>&gt;         case Failed(ErrorType)<br>&gt;     }<br>&gt;<br>&gt;     func execute(completion: (Result) -&gt; Void)<br>&gt; }<br>&gt;<br>&gt; Here, the NetworkTransaction protocol declares the interface by which an<br>&gt; asynchronous transaction occurs. The user of a NetworkTransaction calls<br>&gt; the execute() function, passing in a completion function that is called<br>&gt; at some time in the future, when the transaction completes.<br>&gt;<br>&gt; For example, imagine a hypothetical DataConsumer class that uses a<br>&gt; transaction to try to fetch some network data and process it:<br>&gt;<br>&gt; class DataConsumer<br>&gt; {<br>&gt;     let transaction: NetworkTransaction<br>&gt;<br>&gt;     init(transaction: NetworkTransaction)<br>&gt;     {<br>&gt;         self.transaction = transaction<br>&gt;     }<br>&gt;<br>&gt;     func fetchData()<br>&gt;     {<br>&gt;         transaction.execute() { [weak self] result in<br>&gt;             guard let strongSelf = self else {<br>&gt;                 return<br>&gt;             }<br>&gt;<br>&gt;             switch result {<br>&gt;             case .Succeeded(let data):<br>&gt;                 strongSelf.processData(data)<br>&gt;<br>&gt;             case .Failed(let err):<br>&gt;                 strongSelf.handleError(err)<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     func processData(data: NSData)<br>&gt;     {<br>&gt;         // process the data<br>&gt;     }<br>&gt;<br>&gt;     func handleError(error: ErrorType)<br>&gt;     {<br>&gt;         // handle the error<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; You&#39;ll notice the [weak self]/strongSelf dance in the fetchData() function.<br>&gt; This is a common pattern with asynchronously-executed closures, and it<br>&gt; signals the possibility that a closure might outlive its usefulness.<br>&gt;<br>&gt; Because the NetworkTransaction may complete at any time, it is possible<br>&gt; that the closure will execute after the DataConsumer that initiated the<br>&gt; transaction has been deallocated. Perhaps the user has navigated elsewhere<br>&gt; in the application and whatever data was to be fetched by DataConsumer is<br>&gt; no longer needed.<br>&gt;<br>&gt; In this case, after a DataConsumer instance goes away, we don&#39;t really<br>&gt; want the closure doing anything. So, we capture self weakly to ensure<br>&gt; that the closure doesn&#39;t hold a reference to the owning DataConsumer.<br>&gt; That prevents a reference cycle and ensures that DataConsumer can be<br>&gt; deallocated when no longer in use.<br>&gt;<br>&gt; When it comes time to execute the closure, the guard statement<br>&gt; effectively asks the question, &quot;Is self still alive?&quot; If the answer is<br>&gt; no, the guard forces a return and the rest of the closure does not execute.<br>&gt;<br>&gt; If self *is* still alive, then the weakly-captured self will be non-nil and<br>&gt; it will be converted into a strong reference held by strongSelf for the<br>&gt; duration of the closure&#39;s execution.<br>&gt;<br>&gt; When the closure is done executing, strongSelf goes away, once again<br>&gt; making the DataConsumer eligible for deallocation when no other<br>&gt; references are held.<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#the-problem&gt;The<br>&gt; Problem<br>&gt;<br>&gt; The [weak self]/strongSelf dance requires common boilerplate wherever it<br>&gt; is used, and the fact that a self-like variable with an arbitrary name<br>&gt; adds noise within the closure. The more strongSelf is needed within the<br>&gt; closure, the more noise there is.<br>&gt;<br>&gt; Further, using a consistent name like strongSelf is by convention only;<br>&gt; it can&#39;t be enforced by the compiler, so searching your codebase for a<br>&gt; given keyword won&#39;t be exhaustive if team members use the wrong name.<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#proposed-solution&gt;Proposed<br>&gt; Solution<br>&gt;<br>&gt; The proposed solution adds a new capture type by repurposing the guard keyword<br>&gt; for another use, which would look like:<br>&gt;<br>&gt; transaction.execute() { [guard self] result in<br>&gt;     switch result {<br>&gt;     case .Succeeded(let data):<br>&gt;         self.processData(data)<br>&gt;<br>&gt;     case .Failed(let err):<br>&gt;         self.handleError(err)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Here, the [guard self] capture list serves as a signal that the compiler<br>&gt; should handle the weak/strong dance itself. When encountering [guard self],<br>&gt; the compiler should emit code that does the following:<br>&gt;<br>&gt;    - Captures self in a weak reference on behalf of the closure<br>&gt;    - Whenever the closure is about to be executed, the weak reference is<br>&gt;    checked to see if self is still alive<br>&gt;       - If self is not alive, the closure becomes a no-op<br>&gt;       &lt;https://en.wikipedia.org/wiki/NOP&gt;; calling the closure returns<br>&gt;       immediately without anything inside the braces being executed<br>&gt;       - If self is alive, it is upgraded to a strong reference for the<br>&gt;       lifetime of the closure&#39;s execution. Within the closure, self is<br>&gt;       non-optional, unlike how it would be with a [weak self] capture.<br>&gt;       When the closure is done executing, the strong reference will be cleared<br>&gt;       and only the weak reference will be held on behalf of the closure.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#non-self-references&gt;<br>&gt; Non-self References<br>&gt;<br>&gt; Because guard is an additional capture type, like weak and unowned, it<br>&gt; can also be used to capture references other than self:<br>&gt;<br>&gt; let capturingTwo = { [guard self, button] in<br>&gt;     // weakly capture self and button<br>&gt;     // but execute the closure with strong references<br>&gt;     // if and only if self AND button still exist<br>&gt;     // when the closure is being asked to execute<br>&gt; }<br>&gt;<br>&gt; When encountering multiple references being captured via guard, the<br>&gt; closure will execute *only* when *all* references are still alive when<br>&gt; the closure is being asked to execute.<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#limitations&gt;<br>&gt; Limitations<br>&gt;<br>&gt; Because guard is a special capture type that causes the closure to become<br>&gt; a no-op once a referenced object deallocates, it is only designed to be<br>&gt; used with closures returning Void.<br>&gt;<br>&gt; This limitation was deemed acceptable because it would cover the vast<br>&gt; majority of cases, and those that it didn&#39;t cover can still fall back on<br>&gt; the existing technique.<br>&gt;<br>&gt; The compiler should emit an error if this notation is used in conjunction<br>&gt; with a closure that has a non-Void return type.<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#caveats&gt;Caveats<br>&gt;<br>&gt; This notation is not intended to be a full-fledged replacement for guard<br>&gt; statements within the closure. We are only using guard here as a way to<br>&gt; declare a specific memory-management behavior for references. Therefore,<br>&gt; guard within [square brackets ] should be seen as a capture type on par<br>&gt; with weak or unowned.<br>&gt;<br>&gt; Unlike with a typical guard statement, we are not attempting to support<br>&gt; an else or where clause, or any boolean expressions within this notation.<br>&gt;<br>&gt; Rather, we&#39;re simply adding a new capture behavior and providing a means<br>&gt; to specify an early exit if the behavior couldn&#39;t be fulfilled because one<br>&gt; or more objects was deallocated.<br>&gt;<br>&gt; The word guard was chosen as the capture type because (1) it functions as<br>&gt; a guard, ensuring that the closure doesn&#39;t execute unless the specified<br>&gt; objects are still alive, and (2) it obviates the need for the full-fledged<br>&gt; guard statement that would otherwise be required to achieve the same<br>&gt; result.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; None, since this does not affect any existing constructs. Implementation<br>&gt; of this proposal will not result in any code breakage.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#status-quo&gt;Status<br>&gt; Quo<br>&gt;<br>&gt; The primary alternative is to do nothing, requiring developers to add<br>&gt; boilerplate guard code and handle upgrading the weak-to-strong references<br>&gt; manually.<br>&gt;<br>&gt; As stated above, this leads to needless boilerplate that can easily be<br>&gt; factored out by the compiler. Also, the use of a self-like variable with<br>&gt; an arbitrary name makes it more difficult to exhaustively find such uses in<br>&gt; large projects. With this proposal, searching for the text &quot;[guard&quot; is<br>&gt; all that&#39;s necessary to find all instances of this memory management<br>&gt; technique.<br>&gt;<br>&gt; Finally, the need to declare and use alternate names to capture values<br>&gt; that already have existing names adds visual clutter to code and serves to<br>&gt; obscure the code&#39;s original intent, making it harder to reason about.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#closures-with-an-optional-return-type&gt;Closures<br>&gt; with an Optional Return Type<br>&gt;<br>&gt; One possible addition to this proposal would extend support to any closure<br>&gt; returning an Optional of some kind.<br>&gt;<br>&gt; If one of the objects in a guard capture list has been deallocated,<br>&gt; executing the closure will always result in an immediate nil return.<br>&gt;<br>&gt; This idea was excluded from this iteration of the proposal due to a<br>&gt; concern that it relied on a &quot;magic return value&quot; (albeit a reasonable one)<br>&gt; and a perception that the community favored a solution with a smaller<br>&gt; conceptual footprint.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#closures-with-a-bool-return-type&gt;Closures<br>&gt; with a Bool Return Type<br>&gt;<br>&gt; One possible addition to this proposal would extend support to any closure<br>&gt; returning a Bool.<br>&gt;<br>&gt; If one of the objects in a guard capture list has been deallocated,<br>&gt; executing the closure will always result in an immediate false return.<br>&gt;<br>&gt; This idea was excluded from this iteration of the proposal due to a<br>&gt; concern that it relied on a &quot;magic return value&quot; (albeit a reasonable one)<br>&gt; and a perception that the community favored a solution with a smaller<br>&gt; conceptual footprint.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#closures-with-arbitrary-return-types&gt;Closures<br>&gt; with Arbitrary Return Types<br>&gt;<br>&gt; An earlier iteration of this proposal included support for closures with<br>&gt; arbitrary return values. The community consensus was that the proposal was<br>&gt; too heavy-weight and tried to do too much, and would lead to verbosity<br>&gt; within the capture declaration. As a result, this idea was removed from the<br>&gt; proposal.<br>&gt;<br>&gt; The ability to handle non-Void return values relied on supporting an else clause<br>&gt; within a guard-based capture list:<br>&gt;<br>&gt; let happinessLevel: () -&gt; Int = { [guard self else -1] in<br>&gt;     var level = 0<br>&gt;     level += self.isHealthy ? 25 : 0<br>&gt;     level += !self.isHungry ? 25 : 0<br>&gt;     level += !self.isFearful ? 25 : 0<br>&gt;     level += self.hasLove ? 25 : 0<br>&gt;     return level<br>&gt; }<br>&gt;<br>&gt; Here, the else clause provides a value to return in cases where self has<br>&gt; gone away and the guard fails.<br>&gt;<br>&gt; In this example, if you call happinessLevel() after self has been<br>&gt; deallocated, the value -1 will always be returned.<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#citations&gt;Citations<br>&gt;<br>&gt; Variations on this proposal were discussed earlier in the following<br>&gt; swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  threads:<br>&gt;<br>&gt;    - Wanted: syntactic sugar for [weak self] callbacks<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/008713.html&gt;<br>&gt;    - Allowing guard let self = self else { … } for weakly captured self<br>&gt;    in a closure.<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/009023.html&gt;<br>&gt;    - [Draft Proposal] A simplified notation for avoiding the weak/strong<br>&gt;    dance with closure capture lists<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/009241.html&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/fd4d2361/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>[Proposal Update 1] A simplified notation for avoiding the weak/strong dance with closure capture lists</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>February 12, 2016 at 05:00:00pm</p></header><div class="content"><p>Well... While I think this could be a good idea, I think that the current<br>implementation is already a “syntactic sugar” for the weak and strong<br>dance. A simple `if let self = self` inside the closure (not allowed today)<br>would be enough if we are going to change the current behaviour.<br></p><p><br>-Van<br></p><p><br>On Fri, Feb 12, 2016 at 4:23 PM, Evan Maloney via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello,<br>&gt;<br>&gt; I sent out an earlier draft of this proposal last week, and have updated<br>&gt; it based on feedback from the list.<br>&gt;<br>&gt; The newer proposal now has a much smaller conceptual footprint to address<br>&gt; concerns that the previous iteration was too complex and would lead to<br>&gt; verbose notation within the capture lists.<br>&gt;<br>&gt; You can find the updated gist here<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440&gt;, as well as<br>&gt; pasted below.<br>&gt;<br>&gt; Evan<br>&gt;<br>&gt; ---<br>&gt;<br>&gt; Simplified notation for avoiding the [weak self]/strongSelf dance with<br>&gt; closures<br>&gt;<br>&gt;    - Proposal: TBD<br>&gt;    - Author: Evan Maloney &lt;https://github.com/emaloney&gt;<br>&gt;    - Status: *Draft*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Frequently, closures are used as completion callbacks for asynchronous<br>&gt; operations, such as when dealing with network requests. It is quite common<br>&gt; to model these sorts of operations in such a way that an object instance<br>&gt; represents a request/response transaction, for example:<br>&gt;<br>&gt; protocol NetworkTransaction: class<br>&gt; {<br>&gt;     enum Result {<br>&gt;         case Succeeded(NSData)<br>&gt;         case Failed(ErrorType)<br>&gt;     }<br>&gt;<br>&gt;     func execute(completion: (Result) -&gt; Void)<br>&gt; }<br>&gt;<br>&gt; Here, the NetworkTransaction protocol declares the interface by which an<br>&gt; asynchronous transaction occurs. The user of a NetworkTransaction calls<br>&gt; the execute() function, passing in a completion function that is called<br>&gt; at some time in the future, when the transaction completes.<br>&gt;<br>&gt; For example, imagine a hypothetical DataConsumer class that uses a<br>&gt; transaction to try to fetch some network data and process it:<br>&gt;<br>&gt; class DataConsumer<br>&gt; {<br>&gt;     let transaction: NetworkTransaction<br>&gt;<br>&gt;     init(transaction: NetworkTransaction)<br>&gt;     {<br>&gt;         self.transaction = transaction<br>&gt;     }<br>&gt;<br>&gt;     func fetchData()<br>&gt;     {<br>&gt;         transaction.execute() { [weak self] result in<br>&gt;             guard let strongSelf = self else {<br>&gt;                 return<br>&gt;             }<br>&gt;<br>&gt;             switch result {<br>&gt;             case .Succeeded(let data):<br>&gt;                 strongSelf.processData(data)<br>&gt;<br>&gt;             case .Failed(let err):<br>&gt;                 strongSelf.handleError(err)<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     func processData(data: NSData)<br>&gt;     {<br>&gt;         // process the data<br>&gt;     }<br>&gt;<br>&gt;     func handleError(error: ErrorType)<br>&gt;     {<br>&gt;         // handle the error<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; You&#39;ll notice the [weak self]/strongSelf dance in the fetchData() function.<br>&gt; This is a common pattern with asynchronously-executed closures, and it<br>&gt; signals the possibility that a closure might outlive its usefulness.<br>&gt;<br>&gt; Because the NetworkTransaction may complete at any time, it is possible<br>&gt; that the closure will execute after the DataConsumer that initiated the<br>&gt; transaction has been deallocated. Perhaps the user has navigated elsewhere<br>&gt; in the application and whatever data was to be fetched by DataConsumer is<br>&gt; no longer needed.<br>&gt;<br>&gt; In this case, after a DataConsumer instance goes away, we don&#39;t really<br>&gt; want the closure doing anything. So, we capture self weakly to ensure<br>&gt; that the closure doesn&#39;t hold a reference to the owning DataConsumer.<br>&gt; That prevents a reference cycle and ensures that DataConsumer can be<br>&gt; deallocated when no longer in use.<br>&gt;<br>&gt; When it comes time to execute the closure, the guard statement<br>&gt; effectively asks the question, &quot;Is self still alive?&quot; If the answer is<br>&gt; no, the guard forces a return and the rest of the closure does not execute.<br>&gt;<br>&gt; If self *is* still alive, then the weakly-captured self will be non-nil and<br>&gt; it will be converted into a strong reference held by strongSelf for the<br>&gt; duration of the closure&#39;s execution.<br>&gt;<br>&gt; When the closure is done executing, strongSelf goes away, once again<br>&gt; making the DataConsumer eligible for deallocation when no other<br>&gt; references are held.<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#the-problem&gt;The<br>&gt; Problem<br>&gt;<br>&gt; The [weak self]/strongSelf dance requires common boilerplate wherever it<br>&gt; is used, and the fact that a self-like variable with an arbitrary name<br>&gt; adds noise within the closure. The more strongSelf is needed within the<br>&gt; closure, the more noise there is.<br>&gt;<br>&gt; Further, using a consistent name like strongSelf is by convention only;<br>&gt; it can&#39;t be enforced by the compiler, so searching your codebase for a<br>&gt; given keyword won&#39;t be exhaustive if team members use the wrong name.<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#proposed-solution&gt;Proposed<br>&gt; Solution<br>&gt;<br>&gt; The proposed solution adds a new capture type by repurposing the guard keyword<br>&gt; for another use, which would look like:<br>&gt;<br>&gt; transaction.execute() { [guard self] result in<br>&gt;     switch result {<br>&gt;     case .Succeeded(let data):<br>&gt;         self.processData(data)<br>&gt;<br>&gt;     case .Failed(let err):<br>&gt;         self.handleError(err)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Here, the [guard self] capture list serves as a signal that the compiler<br>&gt; should handle the weak/strong dance itself. When encountering [guard self],<br>&gt; the compiler should emit code that does the following:<br>&gt;<br>&gt;    - Captures self in a weak reference on behalf of the closure<br>&gt;    - Whenever the closure is about to be executed, the weak reference is<br>&gt;    checked to see if self is still alive<br>&gt;       - If self is not alive, the closure becomes a no-op<br>&gt;       &lt;https://en.wikipedia.org/wiki/NOP&gt;; calling the closure returns<br>&gt;       immediately without anything inside the braces being executed<br>&gt;       - If self is alive, it is upgraded to a strong reference for the<br>&gt;       lifetime of the closure&#39;s execution. Within the closure, self is<br>&gt;       non-optional, unlike how it would be with a [weak self] capture.<br>&gt;       When the closure is done executing, the strong reference will be cleared<br>&gt;       and only the weak reference will be held on behalf of the closure.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#non-self-references&gt;<br>&gt; Non-self References<br>&gt;<br>&gt; Because guard is an additional capture type, like weak and unowned, it<br>&gt; can also be used to capture references other than self:<br>&gt;<br>&gt; let capturingTwo = { [guard self, button] in<br>&gt;     // weakly capture self and button<br>&gt;     // but execute the closure with strong references<br>&gt;     // if and only if self AND button still exist<br>&gt;     // when the closure is being asked to execute<br>&gt; }<br>&gt;<br>&gt; When encountering multiple references being captured via guard, the<br>&gt; closure will execute *only* when *all* references are still alive when<br>&gt; the closure is being asked to execute.<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#limitations&gt;<br>&gt; Limitations<br>&gt;<br>&gt; Because guard is a special capture type that causes the closure to become<br>&gt; a no-op once a referenced object deallocates, it is only designed to be<br>&gt; used with closures returning Void.<br>&gt;<br>&gt; This limitation was deemed acceptable because it would cover the vast<br>&gt; majority of cases, and those that it didn&#39;t cover can still fall back on<br>&gt; the existing technique.<br>&gt;<br>&gt; The compiler should emit an error if this notation is used in conjunction<br>&gt; with a closure that has a non-Void return type.<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#caveats&gt;Caveats<br>&gt;<br>&gt; This notation is not intended to be a full-fledged replacement for guard<br>&gt; statements within the closure. We are only using guard here as a way to<br>&gt; declare a specific memory-management behavior for references. Therefore,<br>&gt; guard within [square brackets ] should be seen as a capture type on par<br>&gt; with weak or unowned.<br>&gt;<br>&gt; Unlike with a typical guard statement, we are not attempting to support<br>&gt; an else or where clause, or any boolean expressions within this notation.<br>&gt;<br>&gt; Rather, we&#39;re simply adding a new capture behavior and providing a means<br>&gt; to specify an early exit if the behavior couldn&#39;t be fulfilled because one<br>&gt; or more objects was deallocated.<br>&gt;<br>&gt; The word guard was chosen as the capture type because (1) it functions as<br>&gt; a guard, ensuring that the closure doesn&#39;t execute unless the specified<br>&gt; objects are still alive, and (2) it obviates the need for the full-fledged<br>&gt; guard statement that would otherwise be required to achieve the same<br>&gt; result.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; None, since this does not affect any existing constructs. Implementation<br>&gt; of this proposal will not result in any code breakage.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#status-quo&gt;Status<br>&gt; Quo<br>&gt;<br>&gt; The primary alternative is to do nothing, requiring developers to add<br>&gt; boilerplate guard code and handle upgrading the weak-to-strong references<br>&gt; manually.<br>&gt;<br>&gt; As stated above, this leads to needless boilerplate that can easily be<br>&gt; factored out by the compiler. Also, the use of a self-like variable with<br>&gt; an arbitrary name makes it more difficult to exhaustively find such uses in<br>&gt; large projects. With this proposal, searching for the text &quot;[guard&quot; is<br>&gt; all that&#39;s necessary to find all instances of this memory management<br>&gt; technique.<br>&gt;<br>&gt; Finally, the need to declare and use alternate names to capture values<br>&gt; that already have existing names adds visual clutter to code and serves to<br>&gt; obscure the code&#39;s original intent, making it harder to reason about.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#closures-with-an-optional-return-type&gt;Closures<br>&gt; with an Optional Return Type<br>&gt;<br>&gt; One possible addition to this proposal would extend support to any closure<br>&gt; returning an Optional of some kind.<br>&gt;<br>&gt; If one of the objects in a guard capture list has been deallocated,<br>&gt; executing the closure will always result in an immediate nil return.<br>&gt;<br>&gt; This idea was excluded from this iteration of the proposal due to a<br>&gt; concern that it relied on a &quot;magic return value&quot; (albeit a reasonable one)<br>&gt; and a perception that the community favored a solution with a smaller<br>&gt; conceptual footprint.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#closures-with-a-bool-return-type&gt;Closures<br>&gt; with a Bool Return Type<br>&gt;<br>&gt; One possible addition to this proposal would extend support to any closure<br>&gt; returning a Bool.<br>&gt;<br>&gt; If one of the objects in a guard capture list has been deallocated,<br>&gt; executing the closure will always result in an immediate false return.<br>&gt;<br>&gt; This idea was excluded from this iteration of the proposal due to a<br>&gt; concern that it relied on a &quot;magic return value&quot; (albeit a reasonable one)<br>&gt; and a perception that the community favored a solution with a smaller<br>&gt; conceptual footprint.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#closures-with-arbitrary-return-types&gt;Closures<br>&gt; with Arbitrary Return Types<br>&gt;<br>&gt; An earlier iteration of this proposal included support for closures with<br>&gt; arbitrary return values. The community consensus was that the proposal was<br>&gt; too heavy-weight and tried to do too much, and would lead to verbosity<br>&gt; within the capture declaration. As a result, this idea was removed from the<br>&gt; proposal.<br>&gt;<br>&gt; The ability to handle non-Void return values relied on supporting an else clause<br>&gt; within a guard-based capture list:<br>&gt;<br>&gt; let happinessLevel: () -&gt; Int = { [guard self else -1] in<br>&gt;     var level = 0<br>&gt;     level += self.isHealthy ? 25 : 0<br>&gt;     level += !self.isHungry ? 25 : 0<br>&gt;     level += !self.isFearful ? 25 : 0<br>&gt;     level += self.hasLove ? 25 : 0<br>&gt;     return level<br>&gt; }<br>&gt;<br>&gt; Here, the else clause provides a value to return in cases where self has<br>&gt; gone away and the guard fails.<br>&gt;<br>&gt; In this example, if you call happinessLevel() after self has been<br>&gt; deallocated, the value -1 will always be returned.<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#citations&gt;Citations<br>&gt;<br>&gt; Variations on this proposal were discussed earlier in the following<br>&gt; swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  threads:<br>&gt;<br>&gt;    - Wanted: syntactic sugar for [weak self] callbacks<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/008713.html&gt;<br>&gt;    - Allowing guard let self = self else { … } for weakly captured self<br>&gt;    in a closure.<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/009023.html&gt;<br>&gt;    - [Draft Proposal] A simplified notation for avoiding the weak/strong<br>&gt;    dance with closure capture lists<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/009241.html&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/bd828900/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal Update 1] A simplified notation for avoiding the weak/strong dance with closure capture lists</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 12, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; Alternatives Considered<br>&gt; <br>&gt; Status Quo<br>&gt; <br>&gt; Closures with an Optional Return Type<br>&gt; <br>&gt; Closures with a Bool Return Type<br>&gt; <br>&gt; Closures with Arbitrary Return Types<br></p><p>I would also discuss the alternative of allowing `self` to be shadowed so that you could write `guard let self = self else { return }`. Your proposal still has some advantages over that one, but I would like to see those explicitly called out and discussed.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal Update 1] A simplified notation for avoiding the weak/strong dance with closure capture lists</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 12, 2016 at 03:00:00pm</p></header><div class="content"><p>Oh, and I just realized I have been responding to the wrong thread.<br></p><p><br>[weak self]<br>guard reconstitute self else { return }<br></p><p>I thought it might be handy to control how the guard exits scope, enabling self == nil (as well as any other reconstitutions of a weak variable) failure cases to do reporting, fatalError-ing, etc. I think it&#39;s important to defer to the programmer on how the weak self condition is handled, enabling any clean-up action to be taken as well as deciding whether to terminate the app, recover, etc.<br></p><p>-- E, off to pick up kids<br></p><p><br></p><p>&gt; On Feb 12, 2016, at 3:46 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Alternatives Considered<br>&gt;&gt; <br>&gt;&gt; Status Quo<br>&gt;&gt; <br>&gt;&gt; Closures with an Optional Return Type<br>&gt;&gt; <br>&gt;&gt; Closures with a Bool Return Type<br>&gt;&gt; <br>&gt;&gt; Closures with Arbitrary Return Types<br>&gt; <br>&gt; I would also discuss the alternative of allowing `self` to be shadowed so that you could write `guard let self = self else { return }`. Your proposal still has some advantages over that one, but I would like to see those explicitly called out and discussed.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/2aef42c4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal Update 1] A simplified notation for avoiding the weak/strong dance with closure capture lists</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 12, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; guard reconstitute self else { return }<br></p><p>I think `reconstitute` is inferior to `let self = ` on almost every axis. It&#39;s longer, requires you to learn a new keyword instead of applying existing constructs, and doesn&#39;t solve any other problems the way permitting `self` shadowing would.<br></p><p>&gt; I think it&#39;s important to defer to the programmer on how the weak self condition is handled, enabling any clean-up action to be taken as well as deciding whether to terminate the app, recover, etc.<br></p><p>I&#39;m really not convinced by this by this. If you want to terminate, capture the variable `unowned`. If you want to customize the behavior in some other way, do a weak-strong dance just like today.<br></p><p>I&#39;m not entirely convinced `[guard]` is a good idea either, but the lack of `else` customization isn&#39;t the reason for my concern. &quot;Just do nothing if this doesn&#39;t exist&quot; is by far the most common case for guarding on a weak `self`.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal Update 1] A simplified notation for avoiding the weak/strong dance with closure capture lists</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 12, 2016 at 04:00:00pm</p></header><div class="content"><p>I&#39;d be fine with let self = self. My biggest issue with [guard self] is that it has to happen before any defer.<br></p><p>-- E<br></p><p>&gt; On Feb 12, 2016, at 4:07 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; guard reconstitute self else { return }<br>&gt; <br>&gt; I think `reconstitute` is inferior to `let self = ` on almost every axis. It&#39;s longer, requires you to learn a new keyword instead of applying existing constructs, and doesn&#39;t solve any other problems the way permitting `self` shadowing would.<br>&gt; <br>&gt;&gt; I think it&#39;s important to defer to the programmer on how the weak self condition is handled, enabling any clean-up action to be taken as well as deciding whether to terminate the app, recover, etc.<br>&gt; <br>&gt; I&#39;m really not convinced by this by this. If you want to terminate, capture the variable `unowned`. If you want to customize the behavior in some other way, do a weak-strong dance just like today.<br>&gt; <br>&gt; I&#39;m not entirely convinced `[guard]` is a good idea either, but the lack of `else` customization isn&#39;t the reason for my concern. &quot;Just do nothing if this doesn&#39;t exist&quot; is by far the most common case for guarding on a weak `self`.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c0eafab7106ab63b8db4025e57c1a8d2?s=50"></div><header><strong>[Proposal Update 1] A simplified notation for avoiding the weak/strong dance with closure capture lists</strong> from <string>Javier Soto</string> &lt;javier.api at gmail.com&gt;<p>February 13, 2016 at 07:00:00am</p></header><div class="content"><p>-1<br></p><p>I think &quot;return and do anything if self is nil&quot; is a code-smell in many<br>cases. You&#39;re preventing a crash and a retain cycle, but at the expense of<br>potentially leaving some piece of functionality broken. I think often<br>strongly capturing self is OK if one can reason that the closure won&#39;t live<br>forever, or use unowned if self is guaranteed to outlive the closure.<br>Always resorting to weak self by default and without considering whether<br>it&#39;s the right choice means not thinking carefully about the lifetime<br>semantics of the code that you&#39;re writing, and adding syntax to make that<br>easier would just encourage that.<br>On Fri, Feb 12, 2016 at 3:41 PM Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;d be fine with let self = self. My biggest issue with [guard self] is<br>&gt; that it has to happen before any defer.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; &gt; On Feb 12, 2016, at 4:07 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; guard reconstitute self else { return }<br>&gt; &gt;<br>&gt; &gt; I think `reconstitute` is inferior to `let self = ` on almost every<br>&gt; axis. It&#39;s longer, requires you to learn a new keyword instead of applying<br>&gt; existing constructs, and doesn&#39;t solve any other problems the way<br>&gt; permitting `self` shadowing would.<br>&gt; &gt;<br>&gt; &gt;&gt; I think it&#39;s important to defer to the programmer on how the weak self<br>&gt; condition is handled, enabling any clean-up action to be taken as well as<br>&gt; deciding whether to terminate the app, recover, etc.<br>&gt; &gt;<br>&gt; &gt; I&#39;m really not convinced by this by this. If you want to terminate,<br>&gt; capture the variable `unowned`. If you want to customize the behavior in<br>&gt; some other way, do a weak-strong dance just like today.<br>&gt; &gt;<br>&gt; &gt; I&#39;m not entirely convinced `[guard]` is a good idea either, but the lack<br>&gt; of `else` customization isn&#39;t the reason for my concern. &quot;Just do nothing<br>&gt; if this doesn&#39;t exist&quot; is by far the most common case for guarding on a<br>&gt; weak `self`.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>Javier Soto<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160213/e29c8901/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal Update 1] A simplified notation for avoiding the weak/strong dance with closure capture lists</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 13, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; I think &quot;return and do anything if self is nil&quot; is a code-smell in many cases. You&#39;re preventing a crash and a retain cycle, but at the expense of potentially leaving some piece of functionality broken.<br></p><p>You&#39;re breaking something unless you&#39;re not breaking anything. And I think it&#39;s actually pretty common that you&#39;re not breaking anything. For instance, if you perform an async network call to fetch the contents of a view controller and then dismiss the view controller before the fetch is complete, throwing away the results is often the best you can do. Even if you get an error, that error is probably no longer relevant.<br></p><p>Certainly not all blocks are like this—if you&#39;re *writing* data, you wouldn&#39;t want to throw away the result. But I think completion handlers which really can be safely ignored if the object that scheduled them has gone away are pretty common. Maybe not common enough to justify such a dramatic shorthand, but certainly common enough that I wouldn&#39;t call it a smell.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Proposal Update 1] A simplified notation for avoiding the weak/strong dance with closure capture lists</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>February 13, 2016 at 12:00:00pm</p></header><div class="content"><p>-1<br></p><p>I like the concept but the proposed solution is inflexible and way too specific. Inability to deal with return values and also inability to execute behaviour if the references have led the scope are big no-goes IMO. This is adding more arbitrary magic to the language and making it more complex. <br></p><p>I am still favouring the <br></p><p>guard self  = self else {} <br></p><p>solution. Slightly more verbose, but infinitely more flexible and makes it very clear what is going on. <br></p><p>— Taras<br></p><p>&gt; On 13 Feb 2016, at 10:46, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I think &quot;return and do anything if self is nil&quot; is a code-smell in many cases. You&#39;re preventing a crash and a retain cycle, but at the expense of potentially leaving some piece of functionality broken.<br>&gt; <br>&gt; You&#39;re breaking something unless you&#39;re not breaking anything. And I think it&#39;s actually pretty common that you&#39;re not breaking anything. For instance, if you perform an async network call to fetch the contents of a view controller and then dismiss the view controller before the fetch is complete, throwing away the results is often the best you can do. Even if you get an error, that error is probably no longer relevant.<br>&gt; <br>&gt; Certainly not all blocks are like this—if you&#39;re *writing* data, you wouldn&#39;t want to throw away the result. But I think completion handlers which really can be safely ignored if the object that scheduled them has gone away are pretty common. Maybe not common enough to justify such a dramatic shorthand, but certainly common enough that I wouldn&#39;t call it a smell.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5964fd17efcebf88154b1fba66f1c198?s=50"></div><header><strong>[Proposal Update 1] A simplified notation for avoiding the weak/strong dance with closure capture lists</strong> from <string>Carlos Parada</string> &lt;carlosparada at me.com&gt;<p>February 13, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; guard self  = self else {} <br></p><p>I agree with Taras on this. I also would prefer something along these lines. Besides being more consistent and familiar, the else clause encourages you to think what would happen if self is gone. &quot;Is it fine if I just return or do I have to display an error message?” This helps lessens the points Javier Soto had against the original idea.<br></p><p>— Carlos Parada<br></p><p><br>&gt; On Feb 13, 2016, at 3:07 AM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; -1<br>&gt; <br>&gt; I like the concept but the proposed solution is inflexible and way too specific. Inability to deal with return values and also inability to execute behaviour if the references have led the scope are big no-goes IMO. This is adding more arbitrary magic to the language and making it more complex. <br>&gt; <br>&gt; I am still favouring the <br>&gt; <br>&gt; guard self  = self else {} <br>&gt; <br>&gt; solution. Slightly more verbose, but infinitely more flexible and makes it very clear what is going on. <br>&gt; <br>&gt; — Taras<br>&gt; <br>&gt;&gt; On 13 Feb 2016, at 10:46, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I think &quot;return and do anything if self is nil&quot; is a code-smell in many cases. You&#39;re preventing a crash and a retain cycle, but at the expense of potentially leaving some piece of functionality broken.<br>&gt;&gt; <br>&gt;&gt; You&#39;re breaking something unless you&#39;re not breaking anything. And I think it&#39;s actually pretty common that you&#39;re not breaking anything. For instance, if you perform an async network call to fetch the contents of a view controller and then dismiss the view controller before the fetch is complete, throwing away the results is often the best you can do. Even if you get an error, that error is probably no longer relevant.<br>&gt;&gt; <br>&gt;&gt; Certainly not all blocks are like this—if you&#39;re *writing* data, you wouldn&#39;t want to throw away the result. But I think completion handlers which really can be safely ignored if the object that scheduled them has gone away are pretty common. Maybe not common enough to justify such a dramatic shorthand, but certainly common enough that I wouldn&#39;t call it a smell.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Proposal Update 1] A simplified notation for avoiding the weak/strong dance with closure capture lists</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>February 14, 2016 at 04:00:00pm</p></header><div class="content"><p>-1<br></p><p>Like was previously stated, I would prefer something like &quot;guard let self = self else {}&quot; to be valid.<br>It has the benefit of:<br></p><p>- being less surprising<br>- having an even smaller language footprint<br>- fixing all the caveats of the original proposal<br></p><p>&gt; On 13 Feb 2016, at 22:27, Carlos Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; guard self  = self else {} <br>&gt; <br>&gt; I agree with Taras on this. I also would prefer something along these lines. Besides being more consistent and familiar, the else clause encourages you to think what would happen if self is gone. &quot;Is it fine if I just return or do I have to display an error message?” This helps lessens the points Javier Soto had against the original idea.<br>&gt; <br>&gt; — Carlos Parada<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 13, 2016, at 3:07 AM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1<br>&gt;&gt; <br>&gt;&gt; I like the concept but the proposed solution is inflexible and way too specific. Inability to deal with return values and also inability to execute behaviour if the references have led the scope are big no-goes IMO. This is adding more arbitrary magic to the language and making it more complex. <br>&gt;&gt; <br>&gt;&gt; I am still favouring the <br>&gt;&gt; <br>&gt;&gt; guard self  = self else {} <br>&gt;&gt; <br>&gt;&gt; solution. Slightly more verbose, but infinitely more flexible and makes it very clear what is going on. <br>&gt;&gt; <br>&gt;&gt; — Taras<br>&gt;&gt; <br>&gt;&gt;&gt; On 13 Feb 2016, at 10:46, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think &quot;return and do anything if self is nil&quot; is a code-smell in many cases. You&#39;re preventing a crash and a retain cycle, but at the expense of potentially leaving some piece of functionality broken.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You&#39;re breaking something unless you&#39;re not breaking anything. And I think it&#39;s actually pretty common that you&#39;re not breaking anything. For instance, if you perform an async network call to fetch the contents of a view controller and then dismiss the view controller before the fetch is complete, throwing away the results is often the best you can do. Even if you get an error, that error is probably no longer relevant.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Certainly not all blocks are like this—if you&#39;re *writing* data, you wouldn&#39;t want to throw away the result. But I think completion handlers which really can be safely ignored if the object that scheduled them has gone away are pretty common. Maybe not common enough to justify such a dramatic shorthand, but certainly common enough that I wouldn&#39;t call it a smell.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Proposal Update 1] A simplified notation for avoiding the weak/strong dance with closure capture lists</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>February 13, 2016 at 05:00:00pm</p></header><div class="content"><p>Looks great, I support this as-is, I do have one suggestion, perhaps for a<br>follow up proposal:<br></p><p>Have a protocol akin to NilLiteralConvertible, let&#39;s call it<br>GuardFailureConvertible for now. Then have any failing guard able to<br>implicitly return that value. The protocol is something like this:<br></p><p>protocol GuardFailureConvertible {<br>    init(guardFailure: Void)<br>}<br></p><p>Your guard syntax could go unchanged, normal guards could also have a<br>shorthand:<br></p><p>guard something() else return<br></p><p>On Saturday, 13 February 2016, Evan Maloney via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello,<br>&gt;<br>&gt; I sent out an earlier draft of this proposal last week, and have updated<br>&gt; it based on feedback from the list.<br>&gt;<br>&gt; The newer proposal now has a much smaller conceptual footprint to address<br>&gt; concerns that the previous iteration was too complex and would lead to<br>&gt; verbose notation within the capture lists.<br>&gt;<br>&gt; You can find the updated gist here<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440&gt;, as well as<br>&gt; pasted below.<br>&gt;<br>&gt; Evan<br>&gt;<br>&gt; ---<br>&gt;<br>&gt; Simplified notation for avoiding the [weak self]/strongSelf dance with<br>&gt; closures<br>&gt;<br>&gt;    - Proposal: TBD<br>&gt;    - Author: Evan Maloney &lt;https://github.com/emaloney&gt;<br>&gt;    - Status: *Draft*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Frequently, closures are used as completion callbacks for asynchronous<br>&gt; operations, such as when dealing with network requests. It is quite common<br>&gt; to model these sorts of operations in such a way that an object instance<br>&gt; represents a request/response transaction, for example:<br>&gt;<br>&gt; protocol NetworkTransaction: class<br>&gt; {<br>&gt;     enum Result {<br>&gt;         case Succeeded(NSData)<br>&gt;         case Failed(ErrorType)<br>&gt;     }<br>&gt;<br>&gt;     func execute(completion: (Result) -&gt; Void)<br>&gt; }<br>&gt;<br>&gt; Here, the NetworkTransaction protocol declares the interface by which an<br>&gt; asynchronous transaction occurs. The user of a NetworkTransaction calls<br>&gt; the execute() function, passing in a completion function that is called<br>&gt; at some time in the future, when the transaction completes.<br>&gt;<br>&gt; For example, imagine a hypothetical DataConsumer class that uses a<br>&gt; transaction to try to fetch some network data and process it:<br>&gt;<br>&gt; class DataConsumer<br>&gt; {<br>&gt;     let transaction: NetworkTransaction<br>&gt;<br>&gt;     init(transaction: NetworkTransaction)<br>&gt;     {<br>&gt;         self.transaction = transaction<br>&gt;     }<br>&gt;<br>&gt;     func fetchData()<br>&gt;     {<br>&gt;         transaction.execute() { [weak self] result in<br>&gt;             guard let strongSelf = self else {<br>&gt;                 return<br>&gt;             }<br>&gt;<br>&gt;             switch result {<br>&gt;             case .Succeeded(let data):<br>&gt;                 strongSelf.processData(data)<br>&gt;<br>&gt;             case .Failed(let err):<br>&gt;                 strongSelf.handleError(err)<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     func processData(data: NSData)<br>&gt;     {<br>&gt;         // process the data<br>&gt;     }<br>&gt;<br>&gt;     func handleError(error: ErrorType)<br>&gt;     {<br>&gt;         // handle the error<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; You&#39;ll notice the [weak self]/strongSelf dance in the fetchData() function.<br>&gt; This is a common pattern with asynchronously-executed closures, and it<br>&gt; signals the possibility that a closure might outlive its usefulness.<br>&gt;<br>&gt; Because the NetworkTransaction may complete at any time, it is possible<br>&gt; that the closure will execute after the DataConsumer that initiated the<br>&gt; transaction has been deallocated. Perhaps the user has navigated elsewhere<br>&gt; in the application and whatever data was to be fetched by DataConsumer is<br>&gt; no longer needed.<br>&gt;<br>&gt; In this case, after a DataConsumer instance goes away, we don&#39;t really<br>&gt; want the closure doing anything. So, we capture self weakly to ensure<br>&gt; that the closure doesn&#39;t hold a reference to the owning DataConsumer.<br>&gt; That prevents a reference cycle and ensures that DataConsumer can be<br>&gt; deallocated when no longer in use.<br>&gt;<br>&gt; When it comes time to execute the closure, the guard statement<br>&gt; effectively asks the question, &quot;Is self still alive?&quot; If the answer is<br>&gt; no, the guard forces a return and the rest of the closure does not execute.<br>&gt;<br>&gt; If self *is* still alive, then the weakly-captured self will be non-nil and<br>&gt; it will be converted into a strong reference held by strongSelf for the<br>&gt; duration of the closure&#39;s execution.<br>&gt;<br>&gt; When the closure is done executing, strongSelf goes away, once again<br>&gt; making the DataConsumer eligible for deallocation when no other<br>&gt; references are held.<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#the-problem&gt;The<br>&gt; Problem<br>&gt;<br>&gt; The [weak self]/strongSelf dance requires common boilerplate wherever it<br>&gt; is used, and the fact that a self-like variable with an arbitrary name<br>&gt; adds noise within the closure. The more strongSelf is needed within the<br>&gt; closure, the more noise there is.<br>&gt;<br>&gt; Further, using a consistent name like strongSelf is by convention only;<br>&gt; it can&#39;t be enforced by the compiler, so searching your codebase for a<br>&gt; given keyword won&#39;t be exhaustive if team members use the wrong name.<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#proposed-solution&gt;Proposed<br>&gt; Solution<br>&gt;<br>&gt; The proposed solution adds a new capture type by repurposing the guard keyword<br>&gt; for another use, which would look like:<br>&gt;<br>&gt; transaction.execute() { [guard self] result in<br>&gt;     switch result {<br>&gt;     case .Succeeded(let data):<br>&gt;         self.processData(data)<br>&gt;<br>&gt;     case .Failed(let err):<br>&gt;         self.handleError(err)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Here, the [guard self] capture list serves as a signal that the compiler<br>&gt; should handle the weak/strong dance itself. When encountering [guard self],<br>&gt; the compiler should emit code that does the following:<br>&gt;<br>&gt;    - Captures self in a weak reference on behalf of the closure<br>&gt;    - Whenever the closure is about to be executed, the weak reference is<br>&gt;    checked to see if self is still alive<br>&gt;       - If self is not alive, the closure becomes a no-op<br>&gt;       &lt;https://en.wikipedia.org/wiki/NOP&gt;; calling the closure returns<br>&gt;       immediately without anything inside the braces being executed<br>&gt;       - If self is alive, it is upgraded to a strong reference for the<br>&gt;       lifetime of the closure&#39;s execution. Within the closure, self is<br>&gt;       non-optional, unlike how it would be with a [weak self] capture.<br>&gt;       When the closure is done executing, the strong reference will be cleared<br>&gt;       and only the weak reference will be held on behalf of the closure.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#non-self-references&gt;<br>&gt; Non-self References<br>&gt;<br>&gt; Because guard is an additional capture type, like weak and unowned, it<br>&gt; can also be used to capture references other than self:<br>&gt;<br>&gt; let capturingTwo = { [guard self, button] in<br>&gt;     // weakly capture self and button<br>&gt;     // but execute the closure with strong references<br>&gt;     // if and only if self AND button still exist<br>&gt;     // when the closure is being asked to execute<br>&gt; }<br>&gt;<br>&gt; When encountering multiple references being captured via guard, the<br>&gt; closure will execute *only* when *all* references are still alive when<br>&gt; the closure is being asked to execute.<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#limitations&gt;<br>&gt; Limitations<br>&gt;<br>&gt; Because guard is a special capture type that causes the closure to become<br>&gt; a no-op once a referenced object deallocates, it is only designed to be<br>&gt; used with closures returning Void.<br>&gt;<br>&gt; This limitation was deemed acceptable because it would cover the vast<br>&gt; majority of cases, and those that it didn&#39;t cover can still fall back on<br>&gt; the existing technique.<br>&gt;<br>&gt; The compiler should emit an error if this notation is used in conjunction<br>&gt; with a closure that has a non-Void return type.<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#caveats&gt;Caveats<br>&gt;<br>&gt; This notation is not intended to be a full-fledged replacement for guard<br>&gt; statements within the closure. We are only using guard here as a way to<br>&gt; declare a specific memory-management behavior for references. Therefore,<br>&gt; guard within [square brackets ] should be seen as a capture type on par<br>&gt; with weak or unowned.<br>&gt;<br>&gt; Unlike with a typical guard statement, we are not attempting to support<br>&gt; an else or where clause, or any boolean expressions within this notation.<br>&gt;<br>&gt; Rather, we&#39;re simply adding a new capture behavior and providing a means<br>&gt; to specify an early exit if the behavior couldn&#39;t be fulfilled because one<br>&gt; or more objects was deallocated.<br>&gt;<br>&gt; The word guard was chosen as the capture type because (1) it functions as<br>&gt; a guard, ensuring that the closure doesn&#39;t execute unless the specified<br>&gt; objects are still alive, and (2) it obviates the need for the full-fledged<br>&gt; guard statement that would otherwise be required to achieve the same<br>&gt; result.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; None, since this does not affect any existing constructs. Implementation<br>&gt; of this proposal will not result in any code breakage.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#status-quo&gt;Status<br>&gt; Quo<br>&gt;<br>&gt; The primary alternative is to do nothing, requiring developers to add<br>&gt; boilerplate guard code and handle upgrading the weak-to-strong references<br>&gt; manually.<br>&gt;<br>&gt; As stated above, this leads to needless boilerplate that can easily be<br>&gt; factored out by the compiler. Also, the use of a self-like variable with<br>&gt; an arbitrary name makes it more difficult to exhaustively find such uses in<br>&gt; large projects. With this proposal, searching for the text &quot;[guard&quot; is<br>&gt; all that&#39;s necessary to find all instances of this memory management<br>&gt; technique.<br>&gt;<br>&gt; Finally, the need to declare and use alternate names to capture values<br>&gt; that already have existing names adds visual clutter to code and serves to<br>&gt; obscure the code&#39;s original intent, making it harder to reason about.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#closures-with-an-optional-return-type&gt;Closures<br>&gt; with an Optional Return Type<br>&gt;<br>&gt; One possible addition to this proposal would extend support to any closure<br>&gt; returning an Optional of some kind.<br>&gt;<br>&gt; If one of the objects in a guard capture list has been deallocated,<br>&gt; executing the closure will always result in an immediate nil return.<br>&gt;<br>&gt; This idea was excluded from this iteration of the proposal due to a<br>&gt; concern that it relied on a &quot;magic return value&quot; (albeit a reasonable one)<br>&gt; and a perception that the community favored a solution with a smaller<br>&gt; conceptual footprint.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440#closures-with-a-bool-return-type&gt;Closures<br>&gt; with a Bool Return Type<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160213/b530b7d1/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
