<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>July 18, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; * What is your evaluation of the proposal?<br>Still -1.  I think this is a big mistake.<br></p><p>That said, since it seems resistance is futile, I have a few changes I would like to recommend:<br></p><p>First, part of the proposal is aimed at methods which need to be public, but should not be subclassed (at least externally).  There is another equally encountered use-case where a method is intended to be subclassed (it may even be abstract), but it shouldn’t be called by anyone but the originating class (or very occasionally a subclass).  Common examples: drawRect: and layoutSubviews:.  If we had a protected access level, that would solve it, but since we aren’t moving that way either, we should have a keyword that is used in place of ‘open&#39; for these cases (maybe “uncallable” or “hidden”).  We should solve these two together since ‘final’, ‘open’, and ‘uncallable’ are all mutually exclusive states.<br></p><p>Second, I would really like to see the methods match the open-ness or final-ity of their enclosing scope by default.  Note: I also feel this way about access levels, which work this way except for public… I believe they should work the same way for public too (while keeping internal as the default level for top-level structures).  If a class is public open, I am typically going to want 85%+ of the methods to also be &#39;public open’.  Having to annotate each of them adds a lot of visual noise, and is fairly easy to forget to add when refactoring amidst that visual noise.  I already have this problem with ‘public&#39;, so I expect it will only be worse for &#39;public open&#39;.<br></p><p><br>Finally, can we talk about migration strategy?  I mean, we are about to break all of CocoaPods and most of GitHub.  At the very least, when migrating to swift 3, we should take any classes/methods which are marked public (but not final) and mark them public open.  That is what the authorial intent was in Swift 2.  This is especially true for people who went through and marked some of their classes/methods final (or thought about it and purposefully didn’t).  Otherwise we are asking users of these frameworks to go in and guess the author’s intent by hand annotating everything while they wait for a fix.<br></p><p>This, more than any other change, will keep me from being able to upgrade to Swift 3 in a timely manner (I have to wait for my dependencies to update).  With a migration strategy, at least I can run the updater on their code as a stop-gap until they have updated their frameworks.<br></p><p>As a framework author myself, this is a tricky update.  I have frameworks which work perfectly well in Swift 2, but are now unusable in Swift 3 without these annotations… but the annotations make them unusable in Swift 2.  I know that is part of the “source-breaking changes” bit, but I have been able to work around pretty much everything else until this.  In the cases where there is a name change causing issues (e.g. “Collection” vs “CollectionType”) they could just run the auto-updater and everything worked.<br></p><p>&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br>No, I think it is premature optimization.<br></p><p>There is one legitimate issue of needing to subclass internally without allowing public subclassing.  There are workarounds, but they are workarounds.  Still, this could be solved without changing the default.  I believe changing the default in this manner will create many more problems than it solves. <br></p><p><br>&gt; * Does this proposal fit well with the feel and direction of Swift?<br>No, I believe it makes Swift worse overall.  More visual noise everywhere when reading/writing frameworks.  <br></p><p>I especially think this hurts code reading, which is a hobby/habit of mine.  I will just run through GitHub frameworks reading the code to see how different authors solve problems or organize their code.  I already find having ‘public’ everywhere makes everything less clear/parseable and I suspect that having ‘public open’ everywhere will be strictly worse.  I know that is a less common use-case, but it is something that every programmer should do (and frameworks are, in a way, one of the public faces of swift).<br></p><p><br>&gt; * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>We are breaking new ground here… and not in a good way.<br></p><p>&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>I read the proposal and most of the (very long) discussion.<br></p><p>Thanks,<br>Jon<br></p><p><br>&gt; Hello Swift community,<br>&gt; <br>&gt; The second review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; begins now and runs through July 22. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md&gt;<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160718/e6912f5c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review #2] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 19, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; Am 19.07.2016 um 04:11 schrieb Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt; Second, I would really like to see the methods match the open-ness or final-ity of their enclosing scope by default.  Note: I also feel this way about access levels, which work this way except for public… I believe they should work the same way for public too (while keeping internal as the default level for top-level structures).<br></p><p>afaics, I completely agree with your whole message, but this one is worth to be emphasized:<br>The effect of &quot;public&quot; should be propagated in the same way as &quot;open&quot;; I don&#39;t think there is any good reason to have two different models for similar concepts.<br></p><p>I think it would be even better to extend propagation up to module-level, and let the author decide what access levels are right for him — but that&#39;s most likely way beyond the willingness for compromise.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160719/d4e82c2e/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
