<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ade0c334ecff1448bb96f5f733bf1f83?s=50"></div><header><strong>deinit and failable initializers</strong> from <string>Chris Eidhof</string> &lt;chris at eidhof.nl&gt;<p>January 26, 2016 at 06:00:00pm</p></header><div class="content"><p>Now that we can return nil from a failable initializer without having initialized all the properties, it’s easier to make a mistake. For example, consider the following (artificial) code:<br></p><p>class MyArray&lt;T&gt; {<br>    var pointer: UnsafeMutablePointer&lt;T&gt;<br>    var capacity: Int<br>    <br>    init?(capacity: Int) {<br>        pointer = UnsafeMutablePointer.alloc(capacity)<br>        if capacity &gt; 100 {<br>            // Here we should also free the memory. In other words, duplicate the code from deinit.<br>            return nil<br>        }<br>        self.capacity = capacity<br>        <br>    }<br>    <br>    deinit {<br>        pointer.destroy(capacity)<br>    }<br>}<br></p><p>In the `return nil` case, we should really free the memory allocated by the pointer. Or in other words, we need to duplicate the behavior from the deinit.<br></p><p>Before Swift 2.2, this mistake wasn’t possible, because we knew that we could count on deinit being called, *always*. With the current behavior, return `nil` is easier, but it does come at the cost of accidentally introducing bugs. As Joe Groff pointed out, a solution would be to have something like “deferOnError” (or in this case, “deferOnNil”), but that feels a bit heavy-weight to me (and you still have to duplicate code).<br></p><p>In any case, I think it’s nice that we can now return nil earlier. I don’t like that it goes at the cost of safety, but I realize it’s probably only making things less safe in a small amount of edge cases.<br></p><p>Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/cfbde381/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>deinit and failable initializers</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 26, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 26, 2016, at 9:15 AM, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Now that we can return nil from a failable initializer without having initialized all the properties, it’s easier to make a mistake. For example, consider the following (artificial) code:<br>&gt; <br>&gt; class MyArray&lt;T&gt; {<br>&gt;     var pointer: UnsafeMutablePointer&lt;T&gt;<br>&gt;     var capacity: Int<br>&gt;     <br>&gt;     init?(capacity: Int) {<br>&gt;         pointer = UnsafeMutablePointer.alloc(capacity)<br>&gt;         if capacity &gt; 100 {<br>&gt;             // Here we should also free the memory. In other words, duplicate the code from deinit.<br>&gt;             return nil<br>&gt;         }<br>&gt;         self.capacity = capacity<br>&gt;         <br>&gt;     }<br>&gt;     <br>&gt;     deinit {<br>&gt;         pointer.destroy(capacity)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; In the `return nil` case, we should really free the memory allocated by the pointer. Or in other words, we need to duplicate the behavior from the deinit.<br>&gt; <br>&gt; Before Swift 2.2, this mistake wasn’t possible, because we knew that we could count on deinit being called, *always*. With the current behavior, return `nil` is easier, but it does come at the cost of accidentally introducing bugs. As Joe Groff pointed out, a solution would be to have something like “deferOnError” (or in this case, “deferOnNil”), but that feels a bit heavy-weight to me (and you still have to duplicate code).<br>&gt; <br>&gt; In any case, I think it’s nice that we can now return nil earlier. I don’t like that it goes at the cost of safety, but I realize it’s probably only making things less safe in a small amount of edge cases.<br></p><p>Let’s re-order the statements in your example:<br></p><p>class MyArray&lt;T&gt; {<br>    var pointer: UnsafeMutablePointer&lt;T&gt;<br>    var capacity: Int<br></p><p>    init?(capacity: Int) {<br>        if capacity &gt; 100 {<br>            // Here we should also free the memory. In other words, duplicate the code from deinit.<br>            return nil<br>        }<br>        self.capacity = capacity<br>        pointer = UnsafeMutablePointer.alloc(capacity)<br>    }<br>    <br>    deinit {<br>        pointer.destroy(capacity)<br>    }<br>}<br></p><p>If the initializer returns ‘nil’ and we still call deinit, we end up destroying a pointer that was never allocated.<br></p><p>If you come from an Objective-C background, you might expect implicit zeroing of the allocated block to help here. However, Swift doesn’t have that, because many Swift types don’t have a “zero” state that’s safe to destroy. For example, anything with a member of non-optional reference type, e.g.,<br></p><p>class ClassWrapper {<br>  var array: MyArray&lt;String&gt;<br></p><p>  init(array: MyArray&lt;String&gt;) {<br>    self.array = array<br>  }<br></p><p>  deinit {<br>    print(array) // array is a valid instance of MyArray&lt;String&gt;<br>  }<br>}<br></p><p>A valid ClassWrapper instance will always have an instance of MyArray&lt;String&gt;, even throughout its deinitializer.<br></p><p>The basic property here is that one cannot run a deinitializer on an instance that hasn’t been fully constructed (all the way up the class hierarchy).<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/16638c3a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ade0c334ecff1448bb96f5f733bf1f83?s=50"></div><header><strong>deinit and failable initializers</strong> from <string>Chris Eidhof</string> &lt;chris at eidhof.nl&gt;<p>January 26, 2016 at 10:00:00pm</p></header><div class="content"><p>Absolutely, I agree with you. Of course, this was a simplified example, you<br>can easily construct an example where just reordering isn’t going to cut it.<br></p><p>It’s not hard to do things right in the current model. We can reorder<br>statements, write wrappers, or think of different solutions altogether.<br>Once you understand how it works, it’s very easy to write correct code.<br></p><p>However, my complaint is that it’s now also easy to make a mistake. In the<br>previous model, it wasn’t so easy (the previous model was simpler: an init<br>would always be matched by a deinit).<br></p><p>On Tue, Jan 26, 2016 at 6:39 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 26, 2016, at 9:15 AM, Chris Eidhof via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Now that we can return nil from a failable initializer without having<br>&gt; initialized all the properties, it’s easier to make a mistake. For example,<br>&gt; consider the following (artificial) code:<br>&gt;<br>&gt; class MyArray&lt;T&gt; {<br>&gt;     var pointer: UnsafeMutablePointer&lt;T&gt;<br>&gt;     var capacity: Int<br>&gt;<br>&gt;     init?(capacity: Int) {<br>&gt;         pointer = UnsafeMutablePointer.alloc(capacity)<br>&gt;         if capacity &gt; 100 {<br>&gt;             // Here we should also free the memory. In other words,<br>&gt; duplicate the code from deinit.<br>&gt;             return nil<br>&gt;         }<br>&gt;         self.capacity = capacity<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;     deinit {<br>&gt;         pointer.destroy(capacity)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; In the `return nil` case, we should really free the memory allocated by<br>&gt; the pointer. Or in other words, we need to duplicate the behavior from the<br>&gt; deinit.<br>&gt;<br>&gt; Before Swift 2.2, this mistake wasn’t possible, because we knew that we<br>&gt; could count on deinit being called, *always*. With the current behavior,<br>&gt; return `nil` is easier, but it does come at the cost of accidentally<br>&gt; introducing bugs. As Joe Groff pointed out, a solution would be to have<br>&gt; something like “deferOnError” (or in this case, “deferOnNil”), but that<br>&gt; feels a bit heavy-weight to me (and you still have to duplicate code).<br>&gt;<br>&gt; In any case, I think it’s nice that we can now return nil earlier. I don’t<br>&gt; like that it goes at the cost of safety, but I realize it’s probably only<br>&gt; making things less safe in a small amount of edge cases.<br>&gt;<br>&gt;<br>&gt; Let’s re-order the statements in your example:<br>&gt;<br>&gt; class MyArray&lt;T&gt; {<br>&gt;     var pointer: UnsafeMutablePointer&lt;T&gt;<br>&gt;     var capacity: Int<br>&gt;<br>&gt;     init?(capacity: Int) {<br>&gt;         if capacity &gt; 100 {<br>&gt;             // Here we should also free the memory. In other words,<br>&gt; duplicate the code from deinit.<br>&gt;             return nil<br>&gt;         }<br>&gt;         self.capacity = capacity<br>&gt;         pointer = UnsafeMutablePointer.alloc(capacity)<br>&gt;     }<br>&gt;<br>&gt;     deinit {<br>&gt;         pointer.destroy(capacity)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; If the initializer returns ‘nil’ and we still call deinit, we end up<br>&gt; destroying a pointer that was never allocated.<br>&gt;<br>&gt; If you come from an Objective-C background, you might expect implicit<br>&gt; zeroing of the allocated block to help here. However, Swift doesn’t have<br>&gt; that, because many Swift types don’t have a “zero” state that’s safe to<br>&gt; destroy. For example, anything with a member of non-optional reference<br>&gt; type, e.g.,<br>&gt;<br>&gt; class ClassWrapper {<br>&gt;   var array: MyArray&lt;String&gt;<br>&gt;<br>&gt;   init(array: MyArray&lt;String&gt;) {<br>&gt;     self.array = array<br>&gt;   }<br>&gt;<br>&gt;   deinit {<br>&gt;     print(array) // array is a valid instance of MyArray&lt;String&gt;<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; A valid ClassWrapper instance will always have an instance of<br>&gt; MyArray&lt;String&gt;, even throughout its deinitializer.<br>&gt;<br>&gt; The basic property here is that one cannot run a deinitializer on an<br>&gt; instance that hasn’t been fully constructed (all the way up the class<br>&gt; hierarchy).<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br>Chris Eidhof<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/d1f4bb41/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5818a8a9211c31af95d6db8974457683?s=50"></div><header><strong>deinit and failable initializers</strong> from <string>Joseph Lord</string> &lt;joseph at human-friendly.com&gt;<p>January 27, 2016 at 01:00:00am</p></header><div class="content"><p>I think that there is risk here but I don&#39;t think it is serious enough one to be with making changes for.<br></p><p>1. For most classes there is no problem because everything is managed by ARC anyway so will clean up without special consideration (few of my classes require a deinit). <br>2. It doesn&#39;t seem surprising that if init did not succeed that deinit will not run.<br></p><p>I suppose the risk is greatest where the nil is a result of a returned value from a call made being passed up as explicit `return nil` or `throw` are more visible. <br></p><p>If something were to be changed I wonder if in cases where a failable init exists in a class with a deinit the init could still be responsible for the clean up but must also call an special empty function to confirm to compiler that the situation has been handled. Not sure on name but maybe `deinited()`. Maybe it would just be a warning if not called. Treatment could maybe be similar to warnings where super calls are not made.<br></p><p>Joseph<br></p><p><br>&gt; On Jan 26, 2016, at 9:39 PM, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Absolutely, I agree with you. Of course, this was a simplified example, you can easily construct an example where just reordering isn’t going to cut it.<br>&gt; <br>&gt; It’s not hard to do things right in the current model. We can reorder statements, write wrappers, or think of different solutions altogether. Once you understand how it works, it’s very easy to write correct code.<br>&gt; <br>&gt; However, my complaint is that it’s now also easy to make a mistake. In the previous model, it wasn’t so easy (the previous model was simpler: an init would always be matched by a deinit).<br>&gt; <br>&gt;&gt; On Tue, Jan 26, 2016 at 6:39 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 26, 2016, at 9:15 AM, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now that we can return nil from a failable initializer without having initialized all the properties, it’s easier to make a mistake. For example, consider the following (artificial) code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class MyArray&lt;T&gt; {<br>&gt;&gt;&gt;     var pointer: UnsafeMutablePointer&lt;T&gt;<br>&gt;&gt;&gt;     var capacity: Int<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     init?(capacity: Int) {<br>&gt;&gt;&gt;         pointer = UnsafeMutablePointer.alloc(capacity)<br>&gt;&gt;&gt;         if capacity &gt; 100 {<br>&gt;&gt;&gt;             // Here we should also free the memory. In other words, duplicate the code from deinit.<br>&gt;&gt;&gt;             return nil<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         self.capacity = capacity<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     deinit {<br>&gt;&gt;&gt;         pointer.destroy(capacity)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the `return nil` case, we should really free the memory allocated by the pointer. Or in other words, we need to duplicate the behavior from the deinit.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Before Swift 2.2, this mistake wasn’t possible, because we knew that we could count on deinit being called, *always*. With the current behavior, return `nil` is easier, but it does come at the cost of accidentally introducing bugs. As Joe Groff pointed out, a solution would be to have something like “deferOnError” (or in this case, “deferOnNil”), but that feels a bit heavy-weight to me (and you still have to duplicate code).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In any case, I think it’s nice that we can now return nil earlier. I don’t like that it goes at the cost of safety, but I realize it’s probably only making things less safe in a small amount of edge cases.<br>&gt;&gt; <br>&gt;&gt; Let’s re-order the statements in your example:<br>&gt;&gt; <br>&gt;&gt; class MyArray&lt;T&gt; {<br>&gt;&gt;     var pointer: UnsafeMutablePointer&lt;T&gt;<br>&gt;&gt;     var capacity: Int<br>&gt;&gt; <br>&gt;&gt;     init?(capacity: Int) {<br>&gt;&gt;         if capacity &gt; 100 {<br>&gt;&gt;             // Here we should also free the memory. In other words, duplicate the code from deinit.<br>&gt;&gt;             return nil<br>&gt;&gt;         }<br>&gt;&gt;         self.capacity = capacity<br>&gt;&gt;         pointer = UnsafeMutablePointer.alloc(capacity)<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     deinit {<br>&gt;&gt;         pointer.destroy(capacity)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; If the initializer returns ‘nil’ and we still call deinit, we end up destroying a pointer that was never allocated.<br>&gt;&gt; <br>&gt;&gt; If you come from an Objective-C background, you might expect implicit zeroing of the allocated block to help here. However, Swift doesn’t have that, because many Swift types don’t have a “zero” state that’s safe to destroy. For example, anything with a member of non-optional reference type, e.g.,<br>&gt;&gt; <br>&gt;&gt; class ClassWrapper {<br>&gt;&gt;   var array: MyArray&lt;String&gt;<br>&gt;&gt; <br>&gt;&gt;   init(array: MyArray&lt;String&gt;) {<br>&gt;&gt;     self.array = array<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   deinit {<br>&gt;&gt;     print(array) // array is a valid instance of MyArray&lt;String&gt;<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; A valid ClassWrapper instance will always have an instance of MyArray&lt;String&gt;, even throughout its deinitializer.<br>&gt;&gt; <br>&gt;&gt; The basic property here is that one cannot run a deinitializer on an instance that hasn’t been fully constructed (all the way up the class hierarchy).<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Chris Eidhof<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/b9703c34/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3a28b53f05e7f3067fb104cb78fbb585?s=50"></div><header><strong>deinit and failable initializers</strong> from <string>Kostiantyn Koval</string> &lt;konstantin.koval1 at gmail.com&gt;<p>January 27, 2016 at 10:00:00am</p></header><div class="content"><p>In my opinion deinit should be called only for objets that we fully initialized successfully (as it works now).<br>How about allowing early return only when no properties were initialized. <br></p><p>The possible problem with this solution is that complex initializers would need to store intermediate results in local variables before assigning them to properties.<br>Example: <br></p><p>struct MyArray&lt;T&gt; {<br>  var pointer: UnsafeMutablePointer&lt;T&gt;<br>  var capacity: Int<br></p><p>  init?(capacity: Int) {<br>    self.pointer = UnsafeMutablePointer.alloc(capacity)<br>    if capacity &gt; 100 {<br>      return nil // Error. Can&#39;t return nil after partial initialization. <br>    }<br>    self.capacity = capacity<br>  }<br></p><p>  init?(capacity: Int) {<br>    if capacity &gt; 100 {<br>      return nil // This is ok, early return before initializing any property<br>    }<br>    self.pointer = UnsafeMutablePointer.alloc(capacity)<br>    self.capacity = capacity<br>  }<br>}<br></p><p>Kostiantyn<br></p><p>&gt; On 27 Jan 2016, at 02:40, Joseph Lord via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think that there is risk here but I don&#39;t think it is serious enough one to be with making changes for.<br>&gt; <br>&gt; 1. For most classes there is no problem because everything is managed by ARC anyway so will clean up without special consideration (few of my classes require a deinit). <br>&gt; 2. It doesn&#39;t seem surprising that if init did not succeed that deinit will not run.<br>&gt; <br>&gt; I suppose the risk is greatest where the nil is a result of a returned value from a call made being passed up as explicit `return nil` or `throw` are more visible. <br>&gt; <br>&gt; If something were to be changed I wonder if in cases where a failable init exists in a class with a deinit the init could still be responsible for the clean up but must also call an special empty function to confirm to compiler that the situation has been handled. Not sure on name but maybe `deinited()`. Maybe it would just be a warning if not called. Treatment could maybe be similar to warnings where super calls are not made.<br>&gt; <br>&gt; Joseph<br>&gt; <br>&gt; <br>&gt; On Jan 26, 2016, at 9:39 PM, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Absolutely, I agree with you. Of course, this was a simplified example, you can easily construct an example where just reordering isn’t going to cut it.<br>&gt;&gt; <br>&gt;&gt; It’s not hard to do things right in the current model. We can reorder statements, write wrappers, or think of different solutions altogether. Once you understand how it works, it’s very easy to write correct code.<br>&gt;&gt; <br>&gt;&gt; However, my complaint is that it’s now also easy to make a mistake. In the previous model, it wasn’t so easy (the previous model was simpler: an init would always be matched by a deinit).<br>&gt;&gt; <br>&gt;&gt; On Tue, Jan 26, 2016 at 6:39 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 26, 2016, at 9:15 AM, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now that we can return nil from a failable initializer without having initialized all the properties, it’s easier to make a mistake. For example, consider the following (artificial) code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class MyArray&lt;T&gt; {<br>&gt;&gt;&gt;     var pointer: UnsafeMutablePointer&lt;T&gt;<br>&gt;&gt;&gt;     var capacity: Int<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     init?(capacity: Int) {<br>&gt;&gt;&gt;         pointer = UnsafeMutablePointer.alloc(capacity)<br>&gt;&gt;&gt;         if capacity &gt; 100 {<br>&gt;&gt;&gt;             // Here we should also free the memory. In other words, duplicate the code from deinit.<br>&gt;&gt;&gt;             return nil<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         self.capacity = capacity<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     deinit {<br>&gt;&gt;&gt;         pointer.destroy(capacity)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the `return nil` case, we should really free the memory allocated by the pointer. Or in other words, we need to duplicate the behavior from the deinit.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Before Swift 2.2, this mistake wasn’t possible, because we knew that we could count on deinit being called, *always*. With the current behavior, return `nil` is easier, but it does come at the cost of accidentally introducing bugs. As Joe Groff pointed out, a solution would be to have something like “deferOnError” (or in this case, “deferOnNil”), but that feels a bit heavy-weight to me (and you still have to duplicate code).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In any case, I think it’s nice that we can now return nil earlier. I don’t like that it goes at the cost of safety, but I realize it’s probably only making things less safe in a small amount of edge cases.<br>&gt;&gt; <br>&gt;&gt; Let’s re-order the statements in your example:<br>&gt;&gt; <br>&gt;&gt; class MyArray&lt;T&gt; {<br>&gt;&gt;     var pointer: UnsafeMutablePointer&lt;T&gt;<br>&gt;&gt;     var capacity: Int<br>&gt;&gt; <br>&gt;&gt;     init?(capacity: Int) {<br>&gt;&gt;         if capacity &gt; 100 {<br>&gt;&gt;             // Here we should also free the memory. In other words, duplicate the code from deinit.<br>&gt;&gt;             return nil<br>&gt;&gt;         }<br>&gt;&gt;         self.capacity = capacity<br>&gt;&gt;         pointer = UnsafeMutablePointer.alloc(capacity)<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     deinit {<br>&gt;&gt;         pointer.destroy(capacity)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; If the initializer returns ‘nil’ and we still call deinit, we end up destroying a pointer that was never allocated.<br>&gt;&gt; <br>&gt;&gt; If you come from an Objective-C background, you might expect implicit zeroing of the allocated block to help here. However, Swift doesn’t have that, because many Swift types don’t have a “zero” state that’s safe to destroy. For example, anything with a member of non-optional reference type, e.g.,<br>&gt;&gt; <br>&gt;&gt; class ClassWrapper {<br>&gt;&gt;   var array: MyArray&lt;String&gt;<br>&gt;&gt; <br>&gt;&gt;   init(array: MyArray&lt;String&gt;) {<br>&gt;&gt;     self.array = array<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   deinit {<br>&gt;&gt;     print(array) // array is a valid instance of MyArray&lt;String&gt;<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; A valid ClassWrapper instance will always have an instance of MyArray&lt;String&gt;, even throughout its deinitializer.<br>&gt;&gt; <br>&gt;&gt; The basic property here is that one cannot run a deinitializer on an instance that hasn’t been fully constructed (all the way up the class hierarchy).<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Chris Eidhof<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/eed73d56/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>deinit and failable initializers</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>January 27, 2016 at 03:00:00pm</p></header><div class="content"><p>Forcing usage of local variable don’t solve the code duplication issue.<br>You will still have to replicate the deinit logic in the initializer (to release resources used by temporary local variable instead of member variables, but this is the same).<br></p><p><br>&gt; Le 27 janv. 2016 à 10:26, Kostiantyn Koval via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; In my opinion deinit should be called only for objets that we fully initialized successfully (as it works now).<br>&gt; How about allowing early return only when no properties were initialized. <br>&gt; <br>&gt; The possible problem with this solution is that complex initializers would need to store intermediate results in local variables before assigning them to properties.<br>&gt; Example: <br>&gt; <br>&gt; struct MyArray&lt;T&gt; {<br>&gt;   var pointer: UnsafeMutablePointer&lt;T&gt;<br>&gt;   var capacity: Int<br>&gt; <br>&gt;   init?(capacity: Int) {<br>&gt;     self.pointer = UnsafeMutablePointer.alloc(capacity)<br>&gt;     if capacity &gt; 100 {<br>&gt;       return nil // Error. Can&#39;t return nil after partial initialization. <br>&gt;     }<br>&gt;     self.capacity = capacity<br>&gt;   }<br>&gt; <br>&gt;   init?(capacity: Int) {<br>&gt;     if capacity &gt; 100 {<br>&gt;       return nil // This is ok, early return before initializing any property<br>&gt;     }<br>&gt;     self.pointer = UnsafeMutablePointer.alloc(capacity)<br>&gt;     self.capacity = capacity<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Kostiantyn<br>&gt; <br>&gt;&gt; On 27 Jan 2016, at 02:40, Joseph Lord via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think that there is risk here but I don&#39;t think it is serious enough one to be with making changes for.<br>&gt;&gt; <br>&gt;&gt; 1. For most classes there is no problem because everything is managed by ARC anyway so will clean up without special consideration (few of my classes require a deinit). <br>&gt;&gt; 2. It doesn&#39;t seem surprising that if init did not succeed that deinit will not run.<br>&gt;&gt; <br>&gt;&gt; I suppose the risk is greatest where the nil is a result of a returned value from a call made being passed up as explicit `return nil` or `throw` are more visible. <br>&gt;&gt; <br>&gt;&gt; If something were to be changed I wonder if in cases where a failable init exists in a class with a deinit the init could still be responsible for the clean up but must also call an special empty function to confirm to compiler that the situation has been handled. Not sure on name but maybe `deinited()`. Maybe it would just be a warning if not called. Treatment could maybe be similar to warnings where super calls are not made.<br>&gt;&gt; <br>&gt;&gt; Joseph<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 26, 2016, at 9:39 PM, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Absolutely, I agree with you. Of course, this was a simplified example, you can easily construct an example where just reordering isn’t going to cut it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s not hard to do things right in the current model. We can reorder statements, write wrappers, or think of different solutions altogether. Once you understand how it works, it’s very easy to write correct code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, my complaint is that it’s now also easy to make a mistake. In the previous model, it wasn’t so easy (the previous model was simpler: an init would always be matched by a deinit).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Jan 26, 2016 at 6:39 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 26, 2016, at 9:15 AM, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now that we can return nil from a failable initializer without having initialized all the properties, it’s easier to make a mistake. For example, consider the following (artificial) code:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class MyArray&lt;T&gt; {<br>&gt;&gt;&gt;&gt;     var pointer: UnsafeMutablePointer&lt;T&gt;<br>&gt;&gt;&gt;&gt;     var capacity: Int<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     init?(capacity: Int) {<br>&gt;&gt;&gt;&gt;         pointer = UnsafeMutablePointer.alloc(capacity)<br>&gt;&gt;&gt;&gt;         if capacity &gt; 100 {<br>&gt;&gt;&gt;&gt;             // Here we should also free the memory. In other words, duplicate the code from deinit.<br>&gt;&gt;&gt;&gt;             return nil<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         self.capacity = capacity<br>&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     deinit {<br>&gt;&gt;&gt;&gt;         pointer.destroy(capacity)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the `return nil` case, we should really free the memory allocated by the pointer. Or in other words, we need to duplicate the behavior from the deinit.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Before Swift 2.2, this mistake wasn’t possible, because we knew that we could count on deinit being called, *always*. With the current behavior, return `nil` is easier, but it does come at the cost of accidentally introducing bugs. As Joe Groff pointed out, a solution would be to have something like “deferOnError” (or in this case, “deferOnNil”), but that feels a bit heavy-weight to me (and you still have to duplicate code).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In any case, I think it’s nice that we can now return nil earlier. I don’t like that it goes at the cost of safety, but I realize it’s probably only making things less safe in a small amount of edge cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let’s re-order the statements in your example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class MyArray&lt;T&gt; {<br>&gt;&gt;&gt;     var pointer: UnsafeMutablePointer&lt;T&gt;<br>&gt;&gt;&gt;     var capacity: Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     init?(capacity: Int) {<br>&gt;&gt;&gt;         if capacity &gt; 100 {<br>&gt;&gt;&gt;             // Here we should also free the memory. In other words, duplicate the code from deinit.<br>&gt;&gt;&gt;             return nil<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         self.capacity = capacity<br>&gt;&gt;&gt;         pointer = UnsafeMutablePointer.alloc(capacity)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     deinit {<br>&gt;&gt;&gt;         pointer.destroy(capacity)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If the initializer returns ‘nil’ and we still call deinit, we end up destroying a pointer that was never allocated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you come from an Objective-C background, you might expect implicit zeroing of the allocated block to help here. However, Swift doesn’t have that, because many Swift types don’t have a “zero” state that’s safe to destroy. For example, anything with a member of non-optional reference type, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class ClassWrapper {<br>&gt;&gt;&gt;   var array: MyArray&lt;String&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   init(array: MyArray&lt;String&gt;) {<br>&gt;&gt;&gt;     self.array = array<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   deinit {<br>&gt;&gt;&gt;     print(array) // array is a valid instance of MyArray&lt;String&gt;<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A valid ClassWrapper instance will always have an instance of MyArray&lt;String&gt;, even throughout its deinitializer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The basic property here is that one cannot run a deinitializer on an instance that hasn’t been fully constructed (all the way up the class hierarchy).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Chris Eidhof<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/30521bf3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>deinit and failable initializers</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 27, 2016 at 09:00:00am</p></header><div class="content"><p>Wouldn’t local variables go away on their own when the function returns? Unless you’re thinking of, say, unhooking yourself from Core Location or something, in which case, yes, you are correct. What if only “@pure” (has that proposal gone through yet?) functions could be called before an early return? Alternately, what if functions that must be “paired” (startMonitoringForRegion, for example) were marked as such? Part of me doesn’t want functions with 20 @whatevers hanging off their declaration, but another (bigger) part of me really wants to see what the language can do when the compiler knows more about what’s going on.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jan 27, 2016, at 06:24, Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Forcing usage of local variable don’t solve the code duplication issue.<br>&gt; You will still have to replicate the deinit logic in the initializer (to release resources used by temporary local variable instead of member variables, but this is the same).<br>&gt; <br>&gt; <br>&gt;&gt; Le 27 janv. 2016 à 10:26, Kostiantyn Koval via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; In my opinion deinit should be called only for objets that we fully initialized successfully (as it works now).<br>&gt;&gt; How about allowing early return only when no properties were initialized. <br>&gt;&gt; <br>&gt;&gt; The possible problem with this solution is that complex initializers would need to store intermediate results in local variables before assigning them to properties.<br>&gt;&gt; Example: <br>&gt;&gt; <br>&gt;&gt; struct MyArray&lt;T&gt; {<br>&gt;&gt;   var pointer: UnsafeMutablePointer&lt;T&gt;<br>&gt;&gt;   var capacity: Int<br>&gt;&gt; <br>&gt;&gt;   init?(capacity: Int) {<br>&gt;&gt;     self.pointer = UnsafeMutablePointer.alloc(capacity)<br>&gt;&gt;     if capacity &gt; 100 {<br>&gt;&gt;       return nil // Error. Can&#39;t return nil after partial initialization. <br>&gt;&gt;     }<br>&gt;&gt;     self.capacity = capacity<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   init?(capacity: Int) {<br>&gt;&gt;     if capacity &gt; 100 {<br>&gt;&gt;       return nil // This is ok, early return before initializing any property<br>&gt;&gt;     }<br>&gt;&gt;     self.pointer = UnsafeMutablePointer.alloc(capacity)<br>&gt;&gt;     self.capacity = capacity<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Kostiantyn<br>&gt;&gt; <br>&gt;&gt;&gt; On 27 Jan 2016, at 02:40, Joseph Lord via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think that there is risk here but I don&#39;t think it is serious enough one to be with making changes for.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. For most classes there is no problem because everything is managed by ARC anyway so will clean up without special consideration (few of my classes require a deinit). <br>&gt;&gt;&gt; 2. It doesn&#39;t seem surprising that if init did not succeed that deinit will not run.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I suppose the risk is greatest where the nil is a result of a returned value from a call made being passed up as explicit `return nil` or `throw` are more visible. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If something were to be changed I wonder if in cases where a failable init exists in a class with a deinit the init could still be responsible for the clean up but must also call an special empty function to confirm to compiler that the situation has been handled. Not sure on name but maybe `deinited()`. Maybe it would just be a warning if not called. Treatment could maybe be similar to warnings where super calls are not made.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Joseph<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 26, 2016, at 9:39 PM, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Absolutely, I agree with you. Of course, this was a simplified example, you can easily construct an example where just reordering isn’t going to cut it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s not hard to do things right in the current model. We can reorder statements, write wrappers, or think of different solutions altogether. Once you understand how it works, it’s very easy to write correct code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However, my complaint is that it’s now also easy to make a mistake. In the previous model, it wasn’t so easy (the previous model was simpler: an init would always be matched by a deinit).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, Jan 26, 2016 at 6:39 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 26, 2016, at 9:15 AM, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Now that we can return nil from a failable initializer without having initialized all the properties, it’s easier to make a mistake. For example, consider the following (artificial) code:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class MyArray&lt;T&gt; {<br>&gt;&gt;&gt;&gt;&gt;     var pointer: UnsafeMutablePointer&lt;T&gt;<br>&gt;&gt;&gt;&gt;&gt;     var capacity: Int<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;     init?(capacity: Int) {<br>&gt;&gt;&gt;&gt;&gt;         pointer = UnsafeMutablePointer.alloc(capacity)<br>&gt;&gt;&gt;&gt;&gt;         if capacity &gt; 100 {<br>&gt;&gt;&gt;&gt;&gt;             // Here we should also free the memory. In other words, duplicate the code from deinit.<br>&gt;&gt;&gt;&gt;&gt;             return nil<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;         self.capacity = capacity<br>&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;     deinit {<br>&gt;&gt;&gt;&gt;&gt;         pointer.destroy(capacity)<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In the `return nil` case, we should really free the memory allocated by the pointer. Or in other words, we need to duplicate the behavior from the deinit.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Before Swift 2.2, this mistake wasn’t possible, because we knew that we could count on deinit being called, *always*. With the current behavior, return `nil` is easier, but it does come at the cost of accidentally introducing bugs. As Joe Groff pointed out, a solution would be to have something like “deferOnError” (or in this case, “deferOnNil”), but that feels a bit heavy-weight to me (and you still have to duplicate code).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In any case, I think it’s nice that we can now return nil earlier. I don’t like that it goes at the cost of safety, but I realize it’s probably only making things less safe in a small amount of edge cases.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let’s re-order the statements in your example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class MyArray&lt;T&gt; {<br>&gt;&gt;&gt;&gt;     var pointer: UnsafeMutablePointer&lt;T&gt;<br>&gt;&gt;&gt;&gt;     var capacity: Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     init?(capacity: Int) {<br>&gt;&gt;&gt;&gt;         if capacity &gt; 100 {<br>&gt;&gt;&gt;&gt;             // Here we should also free the memory. In other words, duplicate the code from deinit.<br>&gt;&gt;&gt;&gt;             return nil<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         self.capacity = capacity<br>&gt;&gt;&gt;&gt;         pointer = UnsafeMutablePointer.alloc(capacity)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     deinit {<br>&gt;&gt;&gt;&gt;         pointer.destroy(capacity)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If the initializer returns ‘nil’ and we still call deinit, we end up destroying a pointer that was never allocated.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you come from an Objective-C background, you might expect implicit zeroing of the allocated block to help here. However, Swift doesn’t have that, because many Swift types don’t have a “zero” state that’s safe to destroy. For example, anything with a member of non-optional reference type, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class ClassWrapper {<br>&gt;&gt;&gt;&gt;   var array: MyArray&lt;String&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   init(array: MyArray&lt;String&gt;) {<br>&gt;&gt;&gt;&gt;     self.array = array<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   deinit {<br>&gt;&gt;&gt;&gt;     print(array) // array is a valid instance of MyArray&lt;String&gt;<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A valid ClassWrapper instance will always have an instance of MyArray&lt;String&gt;, even throughout its deinitializer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The basic property here is that one cannot run a deinitializer on an instance that hasn’t been fully constructed (all the way up the class hierarchy).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Chris Eidhof<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/4848e5cf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>deinit and failable initializers</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>January 27, 2016 at 07:00:00pm</p></header><div class="content"><p>The discussed sample is explicitly about a UnsafeMutablePointer.alloc(capacity) call that must be explicitly freed. That why I said local variable wouldn’t improve much the issue.<br></p><p>You can’t restrict the operations that can be done before an early return. How would you write a failable init that return nil when a ressource allocation or access fail (which is far more common than having a @pure function failing) ?<br></p><p><br>&gt; Le 27 janv. 2016 à 18:15, Dave via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Wouldn’t local variables go away on their own when the function returns? Unless you’re thinking of, say, unhooking yourself from Core Location or something, in which case, yes, you are correct. What if only “@pure” (has that proposal gone through yet?) functions could be called before an early return? Alternately, what if functions that must be “paired” (startMonitoringForRegion, for example) were marked as such? Part of me doesn’t want functions with 20 @whatevers hanging off their declaration, but another (bigger) part of me really wants to see what the language can do when the compiler knows more about what’s going on.<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; On Jan 27, 2016, at 06:24, Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Forcing usage of local variable don’t solve the code duplication issue.<br>&gt;&gt; You will still have to replicate the deinit logic in the initializer (to release resources used by temporary local variable instead of member variables, but this is the same).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Le 27 janv. 2016 à 10:26, Kostiantyn Koval via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my opinion deinit should be called only for objets that we fully initialized successfully (as it works now).<br>&gt;&gt;&gt; How about allowing early return only when no properties were initialized. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The possible problem with this solution is that complex initializers would need to store intermediate results in local variables before assigning them to properties.<br>&gt;&gt;&gt; Example: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct MyArray&lt;T&gt; {<br>&gt;&gt;&gt;   var pointer: UnsafeMutablePointer&lt;T&gt;<br>&gt;&gt;&gt;   var capacity: Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   init?(capacity: Int) {<br>&gt;&gt;&gt;     self.pointer = UnsafeMutablePointer.alloc(capacity)<br>&gt;&gt;&gt;     if capacity &gt; 100 {<br>&gt;&gt;&gt;       return nil // Error. Can&#39;t return nil after partial initialization. <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     self.capacity = capacity<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   init?(capacity: Int) {<br>&gt;&gt;&gt;     if capacity &gt; 100 {<br>&gt;&gt;&gt;       return nil // This is ok, early return before initializing any property<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     self.pointer = UnsafeMutablePointer.alloc(capacity)<br>&gt;&gt;&gt;     self.capacity = capacity<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Kostiantyn<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 27 Jan 2016, at 02:40, Joseph Lord via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think that there is risk here but I don&#39;t think it is serious enough one to be with making changes for.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. For most classes there is no problem because everything is managed by ARC anyway so will clean up without special consideration (few of my classes require a deinit). <br>&gt;&gt;&gt;&gt; 2. It doesn&#39;t seem surprising that if init did not succeed that deinit will not run.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I suppose the risk is greatest where the nil is a result of a returned value from a call made being passed up as explicit `return nil` or `throw` are more visible. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If something were to be changed I wonder if in cases where a failable init exists in a class with a deinit the init could still be responsible for the clean up but must also call an special empty function to confirm to compiler that the situation has been handled. Not sure on name but maybe `deinited()`. Maybe it would just be a warning if not called. Treatment could maybe be similar to warnings where super calls are not made.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Joseph<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 26, 2016, at 9:39 PM, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Absolutely, I agree with you. Of course, this was a simplified example, you can easily construct an example where just reordering isn’t going to cut it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It’s not hard to do things right in the current model. We can reorder statements, write wrappers, or think of different solutions altogether. Once you understand how it works, it’s very easy to write correct code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; However, my complaint is that it’s now also easy to make a mistake. In the previous model, it wasn’t so easy (the previous model was simpler: an init would always be matched by a deinit).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Tue, Jan 26, 2016 at 6:39 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 26, 2016, at 9:15 AM, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Now that we can return nil from a failable initializer without having initialized all the properties, it’s easier to make a mistake. For example, consider the following (artificial) code:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class MyArray&lt;T&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;     var pointer: UnsafeMutablePointer&lt;T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;     var capacity: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;&gt;     init?(capacity: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;         pointer = UnsafeMutablePointer.alloc(capacity)<br>&gt;&gt;&gt;&gt;&gt;&gt;         if capacity &gt; 100 {<br>&gt;&gt;&gt;&gt;&gt;&gt;             // Here we should also free the memory. In other words, duplicate the code from deinit.<br>&gt;&gt;&gt;&gt;&gt;&gt;             return nil<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;         self.capacity = capacity<br>&gt;&gt;&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;&gt;     deinit {<br>&gt;&gt;&gt;&gt;&gt;&gt;         pointer.destroy(capacity)<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In the `return nil` case, we should really free the memory allocated by the pointer. Or in other words, we need to duplicate the behavior from the deinit.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Before Swift 2.2, this mistake wasn’t possible, because we knew that we could count on deinit being called, *always*. With the current behavior, return `nil` is easier, but it does come at the cost of accidentally introducing bugs. As Joe Groff pointed out, a solution would be to have something like “deferOnError” (or in this case, “deferOnNil”), but that feels a bit heavy-weight to me (and you still have to duplicate code).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In any case, I think it’s nice that we can now return nil earlier. I don’t like that it goes at the cost of safety, but I realize it’s probably only making things less safe in a small amount of edge cases.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Let’s re-order the statements in your example:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class MyArray&lt;T&gt; {<br>&gt;&gt;&gt;&gt;&gt;     var pointer: UnsafeMutablePointer&lt;T&gt;<br>&gt;&gt;&gt;&gt;&gt;     var capacity: Int<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     init?(capacity: Int) {<br>&gt;&gt;&gt;&gt;&gt;         if capacity &gt; 100 {<br>&gt;&gt;&gt;&gt;&gt;             // Here we should also free the memory. In other words, duplicate the code from deinit.<br>&gt;&gt;&gt;&gt;&gt;             return nil<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;         self.capacity = capacity<br>&gt;&gt;&gt;&gt;&gt;         pointer = UnsafeMutablePointer.alloc(capacity)<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;     deinit {<br>&gt;&gt;&gt;&gt;&gt;         pointer.destroy(capacity)<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If the initializer returns ‘nil’ and we still call deinit, we end up destroying a pointer that was never allocated.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If you come from an Objective-C background, you might expect implicit zeroing of the allocated block to help here. However, Swift doesn’t have that, because many Swift types don’t have a “zero” state that’s safe to destroy. For example, anything with a member of non-optional reference type, e.g.,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class ClassWrapper {<br>&gt;&gt;&gt;&gt;&gt;   var array: MyArray&lt;String&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   init(array: MyArray&lt;String&gt;) {<br>&gt;&gt;&gt;&gt;&gt;     self.array = array<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   deinit {<br>&gt;&gt;&gt;&gt;&gt;     print(array) // array is a valid instance of MyArray&lt;String&gt;<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A valid ClassWrapper instance will always have an instance of MyArray&lt;String&gt;, even throughout its deinitializer.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The basic property here is that one cannot run a deinitializer on an instance that hasn’t been fully constructed (all the way up the class hierarchy).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; Chris Eidhof<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/965f63c0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>deinit and failable initializers</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 27, 2016 at 11:00:00am</p></header><div class="content"><p>I don’t think UnsafeMutablePointer.alloc(capacity) qualifies as “pure”, so you’d have to handle it before failing:<br>init?(capacity: Int) {<br>    self.pointer = UnsafeMutablePointer.alloc(capacity)<br>    if capacity &gt; 100 {<br>        self.pointer.dealloc(capacity)<br>        return nil // Ok, because everything that has side effects has been dealt with<br>    }<br>    self.capacity = capacity<br>}<br>or, as in Kostiantyn’s example, bail out before anything with side effects has been done:<br>init?(capacity: Int) {<br>    if capacity &gt; 100 {<br>        return nil // This is ok, we haven’t actually done anything yet<br>    }<br>    self.pointer = UnsafeMutablePointer.alloc(capacity)<br>    self.capacity = capacity<br>}<br></p><p>Either way, in this case we don’t really lose anything because current system doesn’t prevent this kind of memory leak in the first place. This doesn’t bother the playground at all:<br>struct MyArray&lt;T&gt; {<br>    var pointer: UnsafeMutablePointer&lt;T&gt;<br>    var capacity: Int<br>    <br>    init?(capacity: Int) {<br>        self.pointer = UnsafeMutablePointer.alloc(capacity)<br>        self.capacity = capacity<br>        if capacity &gt; 100 {<br>            return nil // Oops! Memory leak!<br>        }<br>    }<br>    // Will probably leak anyway, since structs don’t have deinits.<br>}<br></p><p><br></p><p>What if we allowed functions to have where clauses?<br>struct MyArray&lt;T&gt; {<br>    var pointer: UnsafeMutablePointer&lt;T&gt;<br>    var capacity: Int<br>    <br>    init?(capacity: Int where capacity &lt;= 100) { // Immediately returns nil if the where clause evaluates to false<br>        self.pointer = UnsafeMutablePointer.alloc(capacity)<br>        self.capacity = capacity<br>    }<br>    /* OR (note that the init has become non-failable) */<br>    init(capacity: Int where capacity &lt;= 100) throws { // Immediately throws an error if the where clause evaluates to false<br>        self.pointer = UnsafeMutablePointer.alloc(capacity)<br>        self.capacity = capacity<br>    }<br>}<br></p><p>I know guard offers similar functionality, but it can appear anywhere in the function body… where must to be up-front, and would get checked before the function body has a chance to do anything. Plus, since it’s part of the function’s signature, it’d appear in API headers. I can’t remember which thread it was in, but as I’ve said before… Which is more useful: a note buried somewhere in the API docs about preconditions, or being able to see the actual bit of code that’ll validate your data?<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jan 27, 2016, at 10:24, Jean-Daniel Dupas &lt;mailing at xenonium.com&gt; wrote:<br>&gt; <br>&gt; The discussed sample is explicitly about a UnsafeMutablePointer.alloc(capacity) call that must be explicitly freed. That why I said local variable wouldn’t improve much the issue.<br>&gt; <br>&gt; You can’t restrict the operations that can be done before an early return. How would you write a failable init that return nil when a ressource allocation or access fail (which is far more common than having a @pure function failing) ?<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/816fd033/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>deinit and failable initializers</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 26, 2016 at 12:00:00pm</p></header><div class="content"><p>A simple deinitOnNil/deinitOnError will be insufficient as soon as you have to allocate more than one resources with a failable point in between.<br></p><p>I think that it could best be solved with move semantics but that&#39;s far off Swift 3.<br></p><p>Félix<br></p><p>&gt; Le 26 janv. 2016 à 12:15:46, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Now that we can return nil from a failable initializer without having initialized all the properties, it’s easier to make a mistake. For example, consider the following (artificial) code:<br>&gt; <br>&gt; class MyArray&lt;T&gt; {<br>&gt;     var pointer: UnsafeMutablePointer&lt;T&gt;<br>&gt;     var capacity: Int<br>&gt;     <br>&gt;     init?(capacity: Int) {<br>&gt;         pointer = UnsafeMutablePointer.alloc(capacity)<br>&gt;         if capacity &gt; 100 {<br>&gt;             // Here we should also free the memory. In other words, duplicate the code from deinit.<br>&gt;             return nil<br>&gt;         }<br>&gt;         self.capacity = capacity<br>&gt;         <br>&gt;     }<br>&gt;     <br>&gt;     deinit {<br>&gt;         pointer.destroy(capacity)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; In the `return nil` case, we should really free the memory allocated by the pointer. Or in other words, we need to duplicate the behavior from the deinit.<br>&gt; <br>&gt; Before Swift 2.2, this mistake wasn’t possible, because we knew that we could count on deinit being called, *always*. With the current behavior, return `nil` is easier, but it does come at the cost of accidentally introducing bugs. As Joe Groff pointed out, a solution would be to have something like “deferOnError” (or in this case, “deferOnNil”), but that feels a bit heavy-weight to me (and you still have to duplicate code).<br>&gt; <br>&gt; In any case, I think it’s nice that we can now return nil earlier. I don’t like that it goes at the cost of safety, but I realize it’s probably only making things less safe in a small amount of edge cases.<br>&gt; <br>&gt; Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/ad603d01/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>deinit and failable initializers</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 26, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 26, 2016, at 9:58 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A simple deinitOnNil/deinitOnError will be insufficient as soon as you have to allocate more than one resources with a failable point in between.<br></p><p>How so? In general, you want to clean up these resources unless you&#39;ve already committed them to a fully-initialized object. This should do the right thing:<br></p><p>init() throws {<br>  self.foo = alloc(); deferOnError { dealloc(self.foo) }<br>  try something()<br>  self.bar = alloc(); deferOnError { dealloc(self.bar) }<br>  try something()<br>  super.init()<br>}<br></p><p>-Joe<br></p><p>&gt; I think that it could best be solved with move semantics but that&#39;s far off Swift 3.<br></p><p>You don&#39;t need move semantics; you could also factor out your resources into dedicated owner classes with non-failable initializers, which would allow for automatic memory management to do the right thing. The problem only arises with unsafe resources or other invariants that require manual management, and it&#39;s a general issue with implicit early exits.<br></p><p>-Joe<br></p><p>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 26 janv. 2016 à 12:15:46, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Now that we can return nil from a failable initializer without having initialized all the properties, it’s easier to make a mistake. For example, consider the following (artificial) code:<br>&gt;&gt; <br>&gt;&gt; class MyArray&lt;T&gt; {<br>&gt;&gt;     var pointer: UnsafeMutablePointer&lt;T&gt;<br>&gt;&gt;     var capacity: Int<br>&gt;&gt;     <br>&gt;&gt;     init?(capacity: Int) {<br>&gt;&gt;         pointer = UnsafeMutablePointer.alloc(capacity)<br>&gt;&gt;         if capacity &gt; 100 {<br>&gt;&gt;             // Here we should also free the memory. In other words, duplicate the code from deinit.<br>&gt;&gt;             return nil<br>&gt;&gt;         }<br>&gt;&gt;         self.capacity = capacity<br>&gt;&gt;         <br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     deinit {<br>&gt;&gt;         pointer.destroy(capacity)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In the `return nil` case, we should really free the memory allocated by the pointer. Or in other words, we need to duplicate the behavior from the deinit.<br>&gt;&gt; <br>&gt;&gt; Before Swift 2.2, this mistake wasn’t possible, because we knew that we could count on deinit being called, *always*. With the current behavior, return `nil` is easier, but it does come at the cost of accidentally introducing bugs. As Joe Groff pointed out, a solution would be to have something like “deferOnError” (or in this case, “deferOnNil”), but that feels a bit heavy-weight to me (and you still have to duplicate code).<br>&gt;&gt; <br>&gt;&gt; In any case, I think it’s nice that we can now return nil earlier. I don’t like that it goes at the cost of safety, but I realize it’s probably only making things less safe in a small amount of edge cases.<br>&gt;&gt; <br>&gt;&gt; Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/0ec307c6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>deinit and failable initializers</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 26, 2016 at 02:00:00pm</p></header><div class="content"><p>I thought it was a separate magic method. This pattern is fine.<br></p><p>Félix<br></p><p>&gt; Le 26 janv. 2016 à 13:03:47, Joe Groff &lt;jgroff at apple.com&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 26, 2016, at 9:58 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; A simple deinitOnNil/deinitOnError will be insufficient as soon as you have to allocate more than one resources with a failable point in between.<br>&gt; <br>&gt; How so? In general, you want to clean up these resources unless you&#39;ve already committed them to a fully-initialized object. This should do the right thing:<br>&gt; <br>&gt; init() throws {<br>&gt;   self.foo = alloc(); deferOnError { dealloc(self.foo) }<br>&gt;   try something()<br>&gt;   self.bar = alloc(); deferOnError { dealloc(self.bar) }<br>&gt;   try something()<br>&gt;   super.init()<br>&gt; }<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; I think that it could best be solved with move semantics but that&#39;s far off Swift 3.<br>&gt; <br>&gt; You don&#39;t need move semantics; you could also factor out your resources into dedicated owner classes with non-failable initializers, which would allow for automatic memory management to do the right thing. The problem only arises with unsafe resources or other invariants that require manual management, and it&#39;s a general issue with implicit early exits.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 26 janv. 2016 à 12:15:46, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now that we can return nil from a failable initializer without having initialized all the properties, it’s easier to make a mistake. For example, consider the following (artificial) code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class MyArray&lt;T&gt; {<br>&gt;&gt;&gt;     var pointer: UnsafeMutablePointer&lt;T&gt;<br>&gt;&gt;&gt;     var capacity: Int<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     init?(capacity: Int) {<br>&gt;&gt;&gt;         pointer = UnsafeMutablePointer.alloc(capacity)<br>&gt;&gt;&gt;         if capacity &gt; 100 {<br>&gt;&gt;&gt;             // Here we should also free the memory. In other words, duplicate the code from deinit.<br>&gt;&gt;&gt;             return nil<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         self.capacity = capacity<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     deinit {<br>&gt;&gt;&gt;         pointer.destroy(capacity)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the `return nil` case, we should really free the memory allocated by the pointer. Or in other words, we need to duplicate the behavior from the deinit.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Before Swift 2.2, this mistake wasn’t possible, because we knew that we could count on deinit being called, *always*. With the current behavior, return `nil` is easier, but it does come at the cost of accidentally introducing bugs. As Joe Groff pointed out, a solution would be to have something like “deferOnError” (or in this case, “deferOnNil”), but that feels a bit heavy-weight to me (and you still have to duplicate code).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In any case, I think it’s nice that we can now return nil earlier. I don’t like that it goes at the cost of safety, but I realize it’s probably only making things less safe in a small amount of edge cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Chris<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/56d8ebd6/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>deinit and failable initializers</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 27, 2016 at 10:00:00am</p></header><div class="content"><p>On Jan 26, 2016, at 11:15 AM, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; class MyArray&lt;T&gt; {<br>&gt;     var pointer: UnsafeMutablePointer&lt;T&gt;<br>&gt;     var capacity: Int<br>&gt;     <br>&gt;     init?(capacity: Int) {<br>&gt;         pointer = UnsafeMutablePointer.alloc(capacity)<br>&gt;         if capacity &gt; 100 {<br>&gt;             // Here we should also free the memory. In other words, duplicate the code from deinit.<br>&gt;             return nil<br>&gt;         }<br>&gt;         self.capacity = capacity<br>&gt;         <br>&gt;     }<br>&gt;     <br>&gt;     deinit {<br>&gt;         pointer.destroy(capacity)<br>&gt;     }<br>&gt; }<br></p><p>In Swift, this sort of pattern is pretty rare. In the cases where you do need to manually allocate memory, you can always wrap the initializer in a “do” block, and release the memory in “catch”.<br></p><p>I don’t think this is a big issue.<br></p><p>Charles<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
