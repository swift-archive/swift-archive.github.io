<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fa2575f192bfdb93dd4cb043545a5df4?s=50"></div><header><strong>Proposal: &#39;selfless&#39; keyword for refactoring duplicate code from initialisers</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium at gmail.com&gt;<p>December 15, 2015 at 11:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>I&#39;m a new member of the list, so apologies if this is a duplicate of an<br>existing idea or if there&#39;s already a way to do this in Swift 2.1 that I&#39;ve<br>missed.<br></p><p>In Objective C, and C-like languages, an initialiser function represents a<br>stage after allocation of memory where properties are given values. In<br>Swift, init appears to precede (or overlap with) allocation. The benefit of<br>this is that for type-safety reasons, all properties of a type (or new<br>properties of a derived type) can be verified as having values. The<br>disadvantage, and one of the stumbling blocks for those who learned<br>Objective-C, is that until all the properties have values, the instance<br>does not exist and instance functions cannot be called.<br></p><p>There&#39;s an invisible threshold in Swift init() functions marking this<br>transition. In derived classes it&#39;s the point where super.init() is called<br>- after the derived type has provided initial values, but before any type<br>functions can be called.<br></p><p>Some types have multiple initialisers, and may be duplicating a lot of code<br>in those distinct inits before they cross the threshold. This code can&#39;t be<br>refactored into an instance function because the instance doesn&#39;t exist<br>yet. The instance function may not even require the use of any properties<br>of the type.<br></p><p>If the compiler can read an init function and its varied control flow and<br>determine a threshold where all properties have values, presumably it can<br>read the code of any function called before that threshold, determine which<br>properties they read and which they assign to, and provide a warning if a<br>path assigns to a constant a second time, etc.. But this isn&#39;t currently<br>happening.<br></p><p>I&#39;m guessing there are multiple contributing factors for this: the<br>combinatorial explosion of possible control flow paths with functions<br>(particularly if they&#39;re recursive); the possibility that the function<br>calls are used by the compiler to mark the end of a control flow path, by<br>which point it can determine whether everything has a value; the function<br>genuinely can&#39;t exist without allocation. I don&#39;t know the reasons but I&#39;d<br>be interested to learn them.<br></p><p>I&#39;m proposing the keyword &#39;selfless&#39; for a function which could be called<br>before the threshold. It either only uses local properties or properties<br>belonging to the type - never to the &#39;super&#39; type (in the case of a derived<br>class). It can&#39;t call any instance functions which aren&#39;t themselves<br>selfless.<br></p><p>Example of use:<br>class FooView : UIView<br>{<br>    var property : Int<br></p><p>    init()<br>    {<br>        initialiseProperty()<br>        super.init()<br>    }<br></p><p>    init(frame:CGRect)<br>    {<br>        initialiseProperty()<br>        super.init(frame)<br>    }<br></p><p>    selfless func initialiseProperty()<br>    {<br>        property = 4<br>    }<br>}<br></p><p>Is this something of interest?<br></p><p>Regards,<br>Ross O&#39;Brien<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/4985dd6f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0eaab3d5d1d4428f74a711f724f2eb47?s=50"></div><header><strong>Proposal: &#39;selfless&#39; keyword for refactoring duplicate code from initialisers</strong> from <string>Etan Kissling</string> &lt;kissling at oberon.ch&gt;<p>December 16, 2015 at 10:00:00am</p></header><div class="content"><p>The problem exists only if you have multiple designated initializers.<br></p><p>For other cases, you can use convenience initializers.<br></p><p>class FooView : UIView<br>{<br>    var property : Int<br></p><p>    convenience init()<br>    {<br>        self.init(frame: CGRect())<br>    }<br></p><p>    override init(frame: CGRect)<br>    {<br>        property = 4<br>        super.init(frame: frame)<br>    }<br></p><p>    required init?(coder aDecoder: NSCoder) {<br>        property = 4<br>        super.init(coder: aDecoder)<br>    }<br>}<br></p><p><br>For the case with multiple designated initializers, you could use lazy initialized properties.<br></p><p>class FooView : UIView<br>{<br>    lazy var property : Int = {<br>        print(&quot;Can use self here: \(self)&quot;)<br>        return 4<br>    }()<br></p><p>    convenience init()<br>    {<br>        self.init(frame: CGRect())<br>    }<br></p><p>    override init(frame: CGRect)<br>    {<br>        super.init(frame: frame)<br>    }<br></p><p>    required init?(coder aDecoder: NSCoder) {<br>        super.init(coder: aDecoder)<br>    }<br>}<br></p><p><br></p><p><br></p><p>&gt; On 16 Dec 2015, at 00:52, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; I&#39;m a new member of the list, so apologies if this is a duplicate of an existing idea or if there&#39;s already a way to do this in Swift 2.1 that I&#39;ve missed.<br>&gt; <br>&gt; In Objective C, and C-like languages, an initialiser function represents a stage after allocation of memory where properties are given values. In Swift, init appears to precede (or overlap with) allocation. The benefit of this is that for type-safety reasons, all properties of a type (or new properties of a derived type) can be verified as having values. The disadvantage, and one of the stumbling blocks for those who learned Objective-C, is that until all the properties have values, the instance does not exist and instance functions cannot be called.<br>&gt; <br>&gt; There&#39;s an invisible threshold in Swift init() functions marking this transition. In derived classes it&#39;s the point where super.init() is called - after the derived type has provided initial values, but before any type functions can be called.<br>&gt; <br>&gt; Some types have multiple initialisers, and may be duplicating a lot of code in those distinct inits before they cross the threshold. This code can&#39;t be refactored into an instance function because the instance doesn&#39;t exist yet. The instance function may not even require the use of any properties of the type.<br>&gt; <br>&gt; If the compiler can read an init function and its varied control flow and determine a threshold where all properties have values, presumably it can read the code of any function called before that threshold, determine which properties they read and which they assign to, and provide a warning if a path assigns to a constant a second time, etc.. But this isn&#39;t currently happening.<br>&gt; <br>&gt; I&#39;m guessing there are multiple contributing factors for this: the combinatorial explosion of possible control flow paths with functions (particularly if they&#39;re recursive); the possibility that the function calls are used by the compiler to mark the end of a control flow path, by which point it can determine whether everything has a value; the function genuinely can&#39;t exist without allocation. I don&#39;t know the reasons but I&#39;d be interested to learn them.<br>&gt; <br>&gt; I&#39;m proposing the keyword &#39;selfless&#39; for a function which could be called before the threshold. It either only uses local properties or properties belonging to the type - never to the &#39;super&#39; type (in the case of a derived class). It can&#39;t call any instance functions which aren&#39;t themselves selfless.<br>&gt; <br>&gt; Example of use:<br>&gt; class FooView : UIView<br>&gt; {<br>&gt;     var property : Int<br>&gt; <br>&gt;     init()<br>&gt;     {<br>&gt;         initialiseProperty()<br>&gt;         super.init()<br>&gt;     }<br>&gt; <br>&gt;     init(frame:CGRect)<br>&gt;     {<br>&gt;         initialiseProperty()<br>&gt;         super.init(frame)<br>&gt;     }<br>&gt; <br>&gt;     selfless func initialiseProperty()<br>&gt;     {<br>&gt;         property = 4<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Is this something of interest?<br>&gt; <br>&gt; Regards,<br>&gt; Ross O&#39;Brien<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/2b8b4fe2/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 801 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/2b8b4fe2/attachment.sig&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
