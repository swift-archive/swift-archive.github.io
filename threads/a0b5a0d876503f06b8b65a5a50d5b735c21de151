<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 20, 2016 at 11:00:00am</p></header><div class="content"><p>on Tue Apr 19 2016, Thorsten Seitz &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;d like to have something like Summable with &#39;add&#39;, &#39;adding&#39; and &#39;zero&#39; being a<br>&gt; separate protocol as well as somthing like Multiplicative with &#39;multiply&#39;,<br>&gt; &#39;multiplied&#39; and &#39;one&#39; being a separate protocol, because these are universally<br>&gt; interesting for other cases, e.g. Summable would be useful for defining path<br>&gt; lengths in a graph library.<br>&gt;<br>&gt; Would you mind adding that to the proposal?<br></p><p>I suspect you may be headed into the realm of<br>protocols-as-bags-of-syntax.  I&#39;m guessing Summable should probably be<br>Monoid &lt;https://en.wikipedia.org/wiki/Monoid&gt; and the Multiplicative<br>one, likely Ring &lt;https://en.wikipedia.org/wiki/Ring_(mathematics)&gt;.<br></p><p>Creating and using a lattice of Swift protocols for Algebraic Structures<br>&lt;https://en.wikipedia.org/wiki/Algebraic_structure&gt; is a research<br>project.  Look at pages 14 and 24 of<br>&lt;http://www.cs.indiana.edu/pub/techreports/TR638.pdf&gt;—which does the job<br>right for C++—and you&#39;ll see why.  That level of complexity probably<br>shouldn&#39;t appear at the top level of the standard library, and really<br>needs a family of generic algorithms to justify it.  Ideally, all of<br>this would be researched and developed outside the standard library and<br>possibly incorporated when it is established existing practice.  IMO<br>it&#39;s definitely not a realm the standard library should enter casually<br>by throwing in a couple of protocols based around addition and<br>multiplication.<br></p><p>Cheers,<br>Dave<br></p><p>&gt; Am 15.04.2016 um 01:55 schrieb Stephen Canon via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt;:<br>&gt;<br>&gt;     Enhanced floating-point protocols<br>&gt;<br>&gt;     * Proposal: SE-NNNN<br>&gt;     * Author(s): Stephen Canon<br>&gt;     * Status: Awaiting review<br>&gt;     * Review manager: TBD<br>&gt;<br>&gt; SVG ImageIntroduction<br>&gt;<br>&gt;     The current FloatingPoint protocol is quite limited, and provides only a<br>&gt;     small subset of the features expected of an IEEE 754 conforming type. This<br>&gt;     proposal expands the protocol to cover most of the expected basic<br>&gt;     operations, and adds a second protocol, BinaryFloatingPoint, that provides a<br>&gt;     number of useful tools for generic programming with the most commonly used<br>&gt;     types.<br>&gt;<br>&gt; SVG ImageMotivation<br>&gt;<br>&gt;     Beside the high-level motivation provided by the introduction, the proposed<br>&gt;     prototype schema addresses a number of issues and requests that we&#39;ve<br>&gt;     received from programmers:<br>&gt;<br>&gt;     * FloatingPoint should conform to Equatable, and Comparable<br>&gt;     * FloatingPoint should conform to FloatLiteralConvertible<br>&gt;     * Deprecate the % operator for floating-point types<br>&gt;     * Provide basic constants (analogues of C&#39;s DBL_MAX, etc.)<br>&gt;     * Make Float80 conform to FloatingPoint<br>&gt;<br>&gt;     It also puts FloatingPoint much more tightly in sync with the work that is<br>&gt;     being done on protocols for Integers, which will make it easier to provide a<br>&gt;     uniform interface for arithmetic scalar types.<br>&gt;<br>&gt; SVG ImageDetailed design<br>&gt;<br>&gt;     A new protocol, Arithmetic, is introduced that provides the most basic<br>&gt;     operations (add, subtract, multiply and divide) as well as Equatable and<br>&gt;     IntegerLiteralConvertible, and is conformed to by both integer and floating-<br>&gt;     point types.<br>&gt;<br>&gt;     There has been some resistance to adding such a protocol, owing to<br>&gt;     differences in behavior between floating point and integer arithmetic. While<br>&gt;     these differences make it difficult to write correct generic code that<br>&gt;     operates on all &quot;arithmetic&quot; types, it is nonetheless convenient to provide<br>&gt;     a single protocol that guarantees the availability of these basic<br>&gt;     operations. It is intended that &quot;number-like&quot; types should provide these<br>&gt;     APIs.<br>&gt;<br>&gt;     /// Arithmetic protocol declares methods backing binary arithmetic operators,<br>&gt; /// such as  `+`, `-` and `*`; and their mutating counterparts.  These methods<br>&gt; /// operate on arguments of the same type.<br>&gt; ///<br>&gt; /// Both mutating and non-mutating operations are declared in the protocol, but<br>&gt; /// only the mutating ones are required.  Should conforming type omit<br>&gt; /// non-mutating implementations, they will be provided by a protocol extension.<br>&gt; /// Implementation in that case will copy `self`, perform a mutating operation<br>&gt; /// on it and return the resulting value.<br>&gt; public protocol Arithmetic: Equatable, IntegerLiteralConvertible {<br>&gt;   /// Initialize to zero<br>&gt;   init()<br>&gt;<br>&gt;   /// The sum of `self` and `rhs`.<br>&gt;   //  Arithmetic provides a default implementation of this method in terms<br>&gt;   //  of the mutating `add` operation.<br>&gt;   @warn_unused_result<br>&gt;   func adding(rhs: Self) -&gt; Self<br>&gt;<br>&gt;   /// Adds `rhs` to `self`.<br>&gt;   mutating func add(rhs: Self)<br>&gt;<br>&gt;   /// The result of subtracting `rhs` from `self`.<br>&gt;   //  Arithmetic provides a default implementation of this method in terms<br>&gt;   //  of the mutating `subtract` operation.<br>&gt;   @warn_unused_result<br>&gt;   func subtracting(rhs: Self) -&gt; Self<br>&gt;<br>&gt;   /// Subtracts `rhs` from `self`.<br>&gt;   mutating func subtract(rhs: Self)<br>&gt;<br>&gt;   /// The product of `self` and `rhs`.<br>&gt;   //  Arithmetic provides a default implementation of this method in terms<br>&gt;   //  of the mutating `multiply` operation.<br>&gt;   @warn_unused_result<br>&gt;   func multiplied(by rhs: Self) -&gt; Self<br>&gt;<br>&gt;   /// Multiplies `self` by `rhs`.<br>&gt;   mutating func multiply(by rhs: Self)<br>&gt;<br>&gt;   /// The quotient of `self` dividing by `rhs`.<br>&gt;   //  Arithmetic provides a default implementation of this method in terms<br>&gt;   //  of the mutating `divide` operation.<br>&gt;   @warn_unused_result<br>&gt;   func divided(by rhs: Self) -&gt; Self<br>&gt;<br>&gt;   /// Divides `self` by `rhs`.<br>&gt;   mutating func divide(by rhs: Self)<br>&gt; }<br>&gt;<br>&gt; /// SignedArithmetic protocol will only be conformed to by signed numbers,<br>&gt; /// otherwise it would be possible to negate an unsigned value.<br>&gt; ///<br>&gt; /// The only method of this protocol has the default implementation in an<br>&gt; /// extension, that uses a parameterless initializer and subtraction.<br>&gt; public protocol SignedArithmetic : Arithmetic {<br>&gt;   func negate() -&gt; Self<br>&gt; }<br>&gt;<br>&gt;     The usual arithmetic operators are then defined in terms of the<br>&gt;     implementation hooks provided by Arithmetic and SignedArithmetic, so<br>&gt;     providing those operations are all that is necessary for a type to present a<br>&gt;     &quot;number-like&quot; interface.<br>&gt;<br>&gt;     The FloatingPoint protocol is split into two parts; FloatingPoint and<br>&gt;     BinaryFloatingPoint, which conforms to FloatingPoint. If decimal types were<br>&gt;     added at some future point, they would conform to DecimalFloatingPoint.<br>&gt;<br>&gt;     FloatingPoint is expanded to contain most of the IEEE 754 basic operations,<br>&gt;     as well as conformance to SignedArithmetic and Comparable.<br>&gt;<br>&gt;     /// A floating-point type that provides most of the IEEE 754 basic (clause 5)<br>&gt; /// operations.  The base, precision, and exponent range are not fixed in<br>&gt; /// any way by this protocol, but it enforces the basic requirements of<br>&gt; /// any IEEE 754 floating-point type.<br>&gt; ///<br>&gt; /// The BinaryFloatingPoint protocol refines these requirements and provides<br>&gt; /// some additional useful operations as well.<br>&gt; public protocol FloatingPoint: SignedArithmetic, Comparable {<br>&gt;<br>&gt;   /// An unsigned integer type that can represent the significand of any value.<br>&gt;   ///<br>&gt;   /// The significand (http://en.wikipedia.org/wiki/Significand) is frequently<br>&gt;   /// also called the &quot;mantissa&quot;, but this terminology is slightly incorrect<br>&gt;   /// (see the &quot;Use of &#39;mantissa&#39;&quot; section on the linked Wikipedia page for<br>&gt;   /// more details).  &quot;Significand&quot; is the preferred terminology in IEEE 754.<br>&gt;   associatedtype RawSignificand: UnsignedInteger<br>&gt;<br>&gt;   /// 2 for binary floating-point types, 10 for decimal.<br>&gt;   ///<br>&gt;   /// A conforming type may use any integer radix, but values other than<br>&gt;   /// 2 or 10 are extraordinarily rare in practice.<br>&gt;   static var radix: Int { get }<br>&gt;<br>&gt;   /// Positive infinity.  Compares greater than all finite numbers.<br>&gt;   static var infinity: Self { get }<br>&gt;<br>&gt;   /// A quiet NaN (not-a-number).  Compares not equal to every value,<br>&gt;   /// including itself.<br>&gt;   static var nan: Self { get }<br>&gt;<br>&gt;   /// NaN with specified `payload`.<br>&gt;   ///<br>&gt;   /// Compares not equal to every value, including itself.  Most operations<br>&gt;   /// with a NaN operand will produce a NaN result.  Note that it is generally<br>&gt;   /// not the case that all possible significand values are valid<br>&gt;   /// NaN `payloads`.  `FloatingPoint` types should either treat inadmissible<br>&gt;   /// payloads as zero, or mask them to create an admissible payload.<br>&gt;   @warn_unused_result<br>&gt;   static func nan(payload payload: RawSignificand, signaling: Bool) -&gt; Self<br>&gt;<br>&gt;   /// The greatest finite number.<br>&gt;   ///<br>&gt;   /// Compares greater than or equal to all finite numbers, but less than<br>&gt;   /// infinity.  Corresponds to the C macros `FLT_MAX`, `DBL_MAX`, etc.<br>&gt;   /// The naming of those macros is slightly misleading, because infinity<br>&gt;   /// is greater than this value.<br>&gt;   static var greatestFiniteMagnitude: Self { get }<br>&gt;<br>&gt;   // NOTE: Rationale for &quot;ulp&quot; instead of &quot;epsilon&quot;:<br>&gt;   // We do not use that name because it is ambiguous at best and misleading<br>&gt;   // at worst:<br>&gt;   //<br>&gt;   // - Historically several definitions of &quot;machine epsilon&quot; have commonly<br>&gt;   //   been used, which differ by up to a factor of two or so.  By contrast<br>&gt;   //   &quot;ulp&quot; is a term with a specific unambiguous definition.<br>&gt;   //<br>&gt;   // - Some languages have used &quot;epsilon&quot; to refer to wildly different values,<br>&gt;   //   such as `leastMagnitude`.<br>&gt;   //<br>&gt;   // - Inexperienced users often believe that &quot;epsilon&quot; should be used as a<br>&gt;   //   tolerance for floating-point comparisons, because of the name.  It is<br>&gt;   //   nearly always the wrong value to use for this purpose.<br>&gt;<br>&gt;   /// The unit in the last place of 1.0.<br>&gt;   ///<br>&gt;   /// This is the weight of the least significant bit of the significand of 1.0,<br>&gt;   /// or the positive difference between 1.0 and the next greater representable<br>&gt;   /// number.  Corresponds to the C macros `FLT_EPSILON`, `DBL_EPSILON`, etc.<br>&gt;   static var ulp: Self { get }<br>&gt;<br>&gt;   /// The unit in the last place of `self`.<br>&gt;   ///<br>&gt;   /// This is the unit of the least significant digit in the significand of<br>&gt;   /// `self`.  For most numbers `x`, this is the difference between `x` and<br>&gt;   /// the next greater (in magnitude) representable number.  There are some<br>&gt;   /// edge cases to be aware of:<br>&gt;   ///<br>&gt;   /// - `greatestFiniteMagnitude.ulp` is a finite number, even though<br>&gt;   ///   the next greater representable value is `infinity`.<br>&gt;   /// - `x.ulp` is `NaN` if `x` is not a finite number.<br>&gt;   /// - If `x` is very small in magnitude, then `x.ulp` may be a subnormal<br>&gt;   ///   number.  On targets that do not support subnormals, `x.ulp` may be<br>&gt;   ///   flushed to zero.<br>&gt;   ///<br>&gt;   /// This quantity, or a related quantity is sometimes called &quot;epsilon&quot; or<br>&gt;   /// &quot;machine epsilon&quot;.  We avoid that name because it has different meanings<br>&gt;   /// in different languages, which can lead to confusion, and because it<br>&gt;   /// suggests that it is an good tolerance to use for comparisons,<br>&gt;   /// which is almost never is.<br>&gt;   ///<br>&gt;   /// (See https://en.wikipedia.org/wiki/Machine_epsilon for more detail)<br>&gt;   var ulp: Self { get }<br>&gt;<br>&gt;   /// The least positive normal number.<br>&gt;   ///<br>&gt;   /// Compares less than or equal to all positive normal numbers.  There may<br>&gt;   /// be smaller positive numbers, but they are &quot;subnormal&quot;, meaning that<br>&gt;   /// they are represented with less precision than normal numbers.<br>&gt;   /// Corresponds to the C macros `FLT_MIN`, `DBL_MIN`, etc.  The naming of<br>&gt;   /// those macros is slightly misleading, because subnormals, zeros, and<br>&gt;   /// negative numbers are smaller than this value.<br>&gt;   static var leastNormalMagnitude: Self { get }<br>&gt;<br>&gt;   /// The least positive number.<br>&gt;   ///<br>&gt;   /// Compares less than or equal to all positive numbers, but greater than<br>&gt;   /// zero.  If the target supports subnormal values, this is smaller than<br>&gt;   /// `leastNormalMagnitude`; otherwise they are equal.<br>&gt;   static var leastMagnitude: Self { get }<br>&gt;<br>&gt;   /// `true` iff the signbit of `self` is set.  Implements the IEEE 754<br>&gt;   /// `signbit` operation.<br>&gt;   ///<br>&gt;   /// Note that this is not the same as `self &lt; 0`.  In particular, this<br>&gt;   /// property is true for `-0` and some NaNs, both of which compare not<br>&gt;   /// less than zero.<br>&gt;   //  TODO: strictly speaking a bit and a bool are slightly different<br>&gt;   //  concepts.  Is another name more appropriate for this property?<br>&gt;   //  `isNegative` is incorrect because of -0 and NaN.  `isSignMinus` might<br>&gt;   //  be acceptable, but isn&#39;t great.  `signBit` is the IEEE 754 name.<br>&gt;   var signBit: Bool { get }<br>&gt;<br>&gt;   /// The integer part of the base-r logarithm of the magnitude of `self`,<br>&gt;   /// where r is the radix (2 for binary, 10 for decimal).  Implements the<br>&gt;   /// IEEE 754 `logB` operation.<br>&gt;   ///<br>&gt;   /// Edge cases:<br>&gt;   ///<br>&gt;   /// - If `x` is zero, then `x.exponent` is `Int.min`.<br>&gt;   /// - If `x` is +/-infinity or NaN, then `x.exponent` is `Int.max`<br>&gt;   var exponent: Int { get }<br>&gt;<br>&gt;   /// The significand satisfies:<br>&gt;   ///<br>&gt;   /// ~~~<br>&gt;   /// self = (signBit ? -1 : 1) * significand * radix**exponent<br>&gt;   /// ~~~<br>&gt;   ///<br>&gt;   /// If radix is 2 (the most common case), then for finite non-zero numbers<br>&gt;   /// `1 &lt;= significand` and `significand &lt; 2`.  For other values of `x`,<br>&gt;   /// `x.significand` is defined as follows:<br>&gt;   ///<br>&gt;   /// - If `x` is zero, then `x.significand` is 0.0.<br>&gt;   /// - If `x` is infinity, then `x.significand` is 1.0.<br>&gt;   /// - If `x` is NaN, then `x.significand` is NaN.<br>&gt;   ///<br>&gt;   /// For all floating-point `x`, if we define y by:<br>&gt;   ///<br>&gt;   /// ~~~<br>&gt;   /// let y = Self(signBit: x.signBit, exponent: x.exponent,<br>&gt;   ///              significand: x.significand)<br>&gt;   /// ~~~<br>&gt;   ///<br>&gt;   /// then `y` is equivalent to `x`, meaning that `y` is `x` canonicalized.<br>&gt;   var significand: Self { get }<br>&gt;<br>&gt;   /// Initialize from signBit, exponent, and significand.<br>&gt;   ///<br>&gt;   /// The result is:<br>&gt;   ///<br>&gt;   /// ~~~<br>&gt;   /// (signBit ? -1 : 1) * significand * radix**exponent<br>&gt;   /// ~~~<br>&gt;   ///<br>&gt;   /// (where `**` is exponentiation) computed as if by a single correctly-<br>&gt;   /// rounded floating-point operation.  If this value is outside the<br>&gt;   /// representable range of the type, overflow or underflow occurs, and zero,<br>&gt;   /// a subnormal value, or infinity may result, as with any basic operation.<br>&gt;   /// Other edge cases:<br>&gt;   ///<br>&gt;   /// - If `significand` is zero or infinite, the result is zero or infinite,<br>&gt;   ///   regardless of the value of `exponent`.<br>&gt;   ///<br>&gt;   /// - If `significand` is NaN, the result is NaN.<br>&gt;   ///<br>&gt;   /// Note that for any floating-point `x` the result of<br>&gt;   ///<br>&gt;   ///   `Self(signBit: x.signBit,<br>&gt;   ///         exponent: x.exponent,<br>&gt;   ///         significand: x.significand)`<br>&gt;   ///<br>&gt;   /// is &quot;the same&quot; as `x`; it is `x` canonicalized.<br>&gt;   ///<br>&gt;   /// Because of these properties, this initializer implements the IEEE 754<br>&gt;   /// `scaleB` operation.<br>&gt;   init(signBit: Bool, exponent: Int, significand: Self)<br>&gt;<br>&gt;   /// A floating point value whose exponent and signficand are taken from<br>&gt;   /// `magnitude` and whose signBit is taken from `signOf`.  Implements the<br>&gt;   /// IEEE 754 `copysign` operation.<br>&gt;   //  TODO: better argument names would be great.<br>&gt;   init(magnitudeOf magnitude: Self, signOf: Self)<br>&gt;<br>&gt;   /// The least representable value that compares greater than `self`.<br>&gt;   ///<br>&gt;   /// - If `x` is `-infinity`, then `x.nextUp` is `-greatestMagnitude`.<br>&gt;   /// - If `x` is `-leastMagnitude`, then `x.nextUp` is `-0.0`.<br>&gt;   /// - If `x` is zero, then `x.nextUp` is `leastMagnitude`.<br>&gt;   /// - If `x` is `greatestMagnitude`, then `x.nextUp` is `infinity`.<br>&gt;   /// - If `x` is `infinity` or `NaN`, then `x.nextUp` is `x`.<br>&gt;   var nextUp: Self { get }<br>&gt;<br>&gt;   /// The greatest representable value that compares less than `self`.<br>&gt;   ///<br>&gt;   /// `x.nextDown` is equivalent to `-(-x).nextUp`<br>&gt;   var nextDown: Self { get }<br>&gt;<br>&gt;   /// Remainder of `self` divided by `other`.<br>&gt;   ///<br>&gt;   /// For finite `self` and `other`, the remainder `r` is defined by<br>&gt;   /// `r = self - other*n`, where `n` is the integer nearest to `self/other`.<br>&gt;   /// (Note that `n` is *not* `self/other` computed in floating-point<br>&gt;   /// arithmetic, and that `n` may not even be representable in any available<br>&gt;   /// integer type).  If `self/other` is exactly halfway between two integers,<br>&gt;   /// `n` is chosen to be even.<br>&gt;   ///<br>&gt;   /// It follows that if `self` and `other` are finite numbers, the remainder<br>&gt;   /// `r` satisfies `-|other|/2 &lt;= r` and `r &lt;= |other|/2`.<br>&gt;   ///<br>&gt;   /// `formRemainder` is always exact, and therefore is not affected by<br>&gt;   /// rounding modes.<br>&gt;   mutating func formRemainder(dividingBy other: Self)<br>&gt;<br>&gt;   /// Remainder of `self` divided by `other` using truncating division.<br>&gt;   ///<br>&gt;   /// If `self` and `other` are finite numbers, the truncating remainder<br>&gt;   /// `r` has the same sign as `other` and is strictly smaller in magnitude.<br>&gt;   /// It satisfies `r = self - other*n`, where `n` is the integral part<br>&gt;   /// of `self/other`.<br>&gt;   ///<br>&gt;   /// `formTruncatingRemainder` is always exact, and therefore is not<br>&gt;   /// affected by rounding modes.<br>&gt;   mutating func formTruncatingRemainder(dividingBy other: Self)<br>&gt;<br>&gt;   /// Mutating form of square root.<br>&gt;   mutating func formSquareRoot( )<br>&gt;<br>&gt;   /// Fused multiply-add, accumulating the product of `lhs` and `rhs` to `self`.<br>&gt;   mutating func addProduct(lhs: Self, _ rhs: Self)<br>&gt;<br>&gt;   /// Remainder of `self` divided by `other`.<br>&gt;   @warn_unused_result<br>&gt;   func remainder(dividingBy other: Self) -&gt; Self<br>&gt;<br>&gt;   /// Remainder of `self` divided by `other` using truncating division.<br>&gt;   @warn_unused_result<br>&gt;   func truncatingRemainder(dividingBy other: Self) -&gt; Self<br>&gt;<br>&gt;   /// Square root of `self`.<br>&gt;   @warn_unused_result<br>&gt;   func squareRoot( ) -&gt; Self<br>&gt;<br>&gt;   /// `self + lhs*rhs` computed without intermediate rounding.<br>&gt;   @warn_unused_result<br>&gt;   func addingProduct(lhs: Self, _ rhs: Self) -&gt; Self<br>&gt;<br>&gt;   /// The minimum of `x` and `y`.  Implements the IEEE 754 `minNum` operation.<br>&gt;   ///<br>&gt;   /// Returns `x` if `x &lt;= y`, `y` if `y &lt; x`, and whichever of `x` or `y`<br>&gt;   /// is a number if the other is NaN.  The result is NaN only if both <br>&gt;   /// arguments are NaN.<br>&gt;   ///<br>&gt;   /// This function is an implementation hook to be used by the free function<br>&gt;   /// min(Self, Self) -&gt; Self so that we get the IEEE 754 behavior with regard<br>&gt;   /// to NaNs.<br>&gt;   @warn_unused_result<br>&gt;   static func minimum(x: Self, _ y: Self) -&gt; Self<br>&gt;<br>&gt;   /// The maximum of `x` and `y`.  Implements the IEEE 754 `maxNum` operation.<br>&gt;   ///<br>&gt;   /// Returns `x` if `x &gt;= y`, `y` if `y &gt; x`, and whichever of `x` or `y`<br>&gt;   /// is a number if the other is NaN.  The result is NaN only if both<br>&gt;   /// arguments are NaN.<br>&gt;   ///<br>&gt;   /// This function is an implementation hook to be used by the free function<br>&gt;   /// max(Self, Self) -&gt; Self so that we get the IEEE 754 behavior with regard<br>&gt;   /// to NaNs.<br>&gt;   @warn_unused_result<br>&gt;   static func maximum(x: Self, _ y: Self) -&gt; Self<br>&gt;<br>&gt;   /// Whichever of `x` or `y` has lesser magnitude.  Implements the IEEE 754<br>&gt;   /// `minNumMag` operation.<br>&gt;   ///<br>&gt;   /// Returns `x` if abs(x) &lt;= abs(y), `y` if abs(y) &lt; abs(x), and whichever of<br>&gt;   /// `x` or `y` is a number if the other is NaN.  The result is NaN<br>&gt;   /// only if both arguments are NaN.<br>&gt;   @warn_unused_result<br>&gt;   static func minimumMagnitude(x: Self, _ y: Self) -&gt; Self<br>&gt;<br>&gt;   /// Whichever of `x` or `y` has greater magnitude.  Implements the IEEE 754<br>&gt;   /// `maxNumMag` operation.<br>&gt;   ///<br>&gt;   /// Returns `x` if abs(x) &gt;= abs(y), `y` if abs(y) &gt; abs(x), and whichever of<br>&gt;   /// `x` or `y` is a number if the other is NaN.  The result is NaN<br>&gt;   /// only if both arguments are NaN.<br>&gt;   @warn_unused_result<br>&gt;   static func maximumMagnitude(x: Self, _ y: Self) -&gt; Self<br>&gt;<br>&gt;   /// IEEE 754 equality predicate.<br>&gt;   ///<br>&gt;   /// -0 compares equal to +0, and NaN compares not equal to anything,<br>&gt;   /// including itself.<br>&gt;   @warn_unused_result<br>&gt;   func isEqual(to other: Self) -&gt; Bool<br>&gt;<br>&gt;   /// IEEE 754 less-than predicate.<br>&gt;   ///<br>&gt;   /// NaN compares not less than anything.  -infinity compares less than<br>&gt;   /// all values except for itself and NaN.  Everything except for NaN and<br>&gt;   /// +infinity compares less than +infinity.<br>&gt;   @warn_unused_result<br>&gt;   func isLess(than other: Self) -&gt; Bool<br>&gt;<br>&gt;   /// IEEE 754 less-than-or-equal predicate.<br>&gt;   ///<br>&gt;   /// NaN compares not less than or equal to anything, including itself.<br>&gt;   /// -infinity compares less than or equal to everything except NaN.<br>&gt;   /// Everything except NaN compares less than or equal to +infinity.<br>&gt;   ///<br>&gt;   /// Because of the existence of NaN in FloatingPoint types, trichotomy does<br>&gt;   /// not hold, which means that `x &lt; y` and `!(y &lt;= x)` are not equivalent.<br>&gt;   /// This is why `isLessThanOrEqual(to:)` is a separate implementation hook<br>&gt;   /// in the protocol.<br>&gt;   ///<br>&gt;   /// Note that this predicate does not impose a total order.  The `totalOrder`<br>&gt;   /// predicate provides a refinement satisfying that criteria.<br>&gt;   @warn_unused_result<br>&gt;   func isLessThanOrEqual(to other: Self) -&gt; Bool<br>&gt;<br>&gt;   /// IEEE 754 unordered predicate.  True if either `self` or `other` is NaN,<br>&gt;   /// and false otherwise.<br>&gt;   @warn_unused_result<br>&gt;   func isUnordered(with other: Self) -&gt; Bool<br>&gt;<br>&gt;   /// True if and only if `self` is normal.<br>&gt;   ///<br>&gt;   /// A normal number uses the full precision available in the format.  Zero<br>&gt;   /// is not a normal number.<br>&gt;   var isNormal: Bool { get }<br>&gt;<br>&gt;   /// True if and only if `self` is finite.<br>&gt;   ///<br>&gt;   /// If `x.isFinite` is `true`, then one of `x.isZero`, `x.isSubnormal`, or<br>&gt;   /// `x.isNormal` is also `true`, and `x.isInfinite` and `x.isNan` are<br>&gt;   /// `false`.<br>&gt;   var isFinite: Bool { get }<br>&gt;<br>&gt;   /// True iff `self` is zero.  Equivalent to `self == 0`.<br>&gt;   var isZero: Bool { get }<br>&gt;<br>&gt;   /// True if and only if `self` is subnormal.<br>&gt;   ///<br>&gt;   /// A subnormal number does not use the full precision available to normal<br>&gt;   /// numbers of the same format.  Zero is not a subnormal number.<br>&gt;   var isSubnormal: Bool { get }<br>&gt;<br>&gt;   /// True if and only if `self` is infinite.<br>&gt;   ///<br>&gt;   /// Note that `isFinite` and `isInfinite` do not form a dichotomy, because<br>&gt;   /// they are not total.  If `x` is `NaN`, then both properties are `false`.<br>&gt;   var isInfinite: Bool { get }<br>&gt;<br>&gt;   /// True if and only if `self` is NaN (&quot;not a number&quot;).<br>&gt;   var isNan: Bool { get }<br>&gt;<br>&gt;   /// True if and only if `self` is a signaling NaN.<br>&gt;   var isSignalingNan: Bool { get }<br>&gt;<br>&gt;   /// The IEEE 754 &quot;class&quot; of this type.<br>&gt;   var floatingPointClass: FloatingPointClassification { get }<br>&gt;<br>&gt;   /// True if and only if `self` is canonical.<br>&gt;   ///<br>&gt;   /// Every floating-point value of type Float or Double is canonical, but<br>&gt;   /// non-canonical values of type Float80 exist, and non-canonical values<br>&gt;   /// may exist for other types that conform to FloatingPoint.<br>&gt;   ///<br>&gt;   /// The non-canonical Float80 values are known as &quot;pseudo-denormal&quot;,<br>&gt;   /// &quot;unnormal&quot;, &quot;pseudo-infinity&quot;, and &quot;pseudo-NaN&quot;.<br>&gt;   /// (https://en.wikipedia.org/wiki/Extended_precision#x86_Extended_Precision_Format)<br>&gt;   var isCanonical: Bool { get }<br>&gt;<br>&gt;   /// True if and only if `self` preceeds `other` in the IEEE 754 total order<br>&gt;   /// relation.<br>&gt;   ///<br>&gt;   /// This relation is a refinement of `&lt;=` that provides a total order on all<br>&gt;   /// values of type `Self`, including non-canonical encodings, signed zeros,<br>&gt;   /// and NaNs.  Because it is used much less frequently than the usual<br>&gt;   /// comparisons, there is no operator form of this relation.<br>&gt;   @warn_unused_result<br>&gt;   func totalOrder(with other: Self) -&gt; Bool<br>&gt;<br>&gt;   /// True if and only if `abs(self)` preceeds `abs(other)` in the IEEE 754<br>&gt;   /// total order relation.<br>&gt;   @warn_unused_result<br>&gt;   func totalOrderMagnitude(with other: Self) -&gt; Bool<br>&gt;<br>&gt;   /// The closest representable value to the argument.<br>&gt;   init&lt;Source: Integer&gt;(_ value: Source)<br>&gt;<br>&gt;   /// Fails if the argument cannot be exactly represented.<br>&gt;   init?&lt;Source: Integer&gt;(exactly value: Source)<br>&gt; }<br>&gt;<br>&gt;     The BinaryFloatingPoint protocol provides a number of additional APIs that<br>&gt;     only make sense for types with fixed radix 2:<br>&gt;<br>&gt;     /// A radix-2 (binary) floating-point type that follows the IEEE 754 encoding<br>&gt; /// conventions.<br>&gt; public protocol BinaryFloatingPoint: FloatingPoint {<br>&gt;<br>&gt;   /// The number of bits used to represent the exponent.<br>&gt;   ///<br>&gt;   /// Following IEEE 754 encoding convention, the exponent bias is:<br>&gt;   ///<br>&gt;   ///   bias = 2**(exponentBitCount-1) - 1<br>&gt;   ///<br>&gt;   /// The least normal exponent is `1-bias` and the largest finite exponent<br>&gt;   /// is `bias`.  The all-zeros exponent is reserved for subnormals and zeros,<br>&gt;   /// and the all-ones exponent is reserved for infinities and NaNs.<br>&gt;   static var exponentBitCount: Int { get }<br>&gt;<br>&gt;   /// For fixed-width floating-point types, this is the number of fractional<br>&gt;   /// significand bits.<br>&gt;   ///<br>&gt;   /// For extensible floating-point types, `significandBitCount` should be<br>&gt;   /// the maximum allowed significand width (without counting any leading<br>&gt;   /// integral bit of the significand).  If there is no upper limit, then<br>&gt;   /// `significandBitCount` should be `Int.max`.<br>&gt;   ///<br>&gt;   /// Note that `Float80.significandBitCount` is 63, even though 64 bits<br>&gt;   /// are used to store the significand in the memory representation of a<br>&gt;   /// `Float80` (unlike other floating-point types, `Float80` explicitly<br>&gt;   /// stores the leading integral significand bit, but the<br>&gt;   /// `BinaryFloatingPoint` APIs provide an abstraction so that users don&#39;t<br>&gt;   /// need to be aware of this detail).<br>&gt;   static var significandBitCount: Int { get }<br>&gt;<br>&gt;   /// The raw encoding of the exponent field of the floating-point value.<br>&gt;   var exponentBitPattern: UInt { get }<br>&gt;<br>&gt;   /// The raw encoding of the significand field of the floating-point value.<br>&gt;   ///<br>&gt;   /// `significandBitPattern` does *not* include the leading integral bit of<br>&gt;   /// the significand, even for types like `Float80` that store it explicitly.<br>&gt;   var significandBitPattern: RawSignificand { get }<br>&gt;<br>&gt;   /// Combines `signBit`, `exponent` and `significand` bit patterns to produce<br>&gt;   /// a floating-point value.<br>&gt;   init(signBit: Bool,<br>&gt;        exponentBitPattern: UInt,<br>&gt;        significandBitPattern: RawSignificand)<br>&gt;<br>&gt;   /// The least-magnitude member of the binade of `self`.<br>&gt;   ///<br>&gt;   /// If `x` is `+/-significand * 2**exponent`, then `x.binade` is<br>&gt;   /// `+/- 2**exponent`; i.e. the floating point number with the same sign<br>&gt;   /// and exponent, but with a significand of 1.0.<br>&gt;   var binade: Self { get }<br>&gt;<br>&gt;   /// The number of bits required to represent significand.<br>&gt;   ///<br>&gt;   /// If `self` is not a finite non-zero number, `significandWidth` is<br>&gt;   /// `-1`.  Otherwise, it is the number of bits required to represent the<br>&gt;   /// significand exactly (less `1` because common formats represent one bit<br>&gt;   /// implicitly).<br>&gt;   var significandWidth: Int { get }<br>&gt;<br>&gt;   @warn_unused_result<br>&gt;   func isEqual&lt;Other: BinaryFloatingPoint&gt;(to other: Other) -&gt; Bool<br>&gt;<br>&gt;   @warn_unused_result<br>&gt;   func isLess&lt;Other: BinaryFloatingPoint&gt;(than other: Other) -&gt; Bool<br>&gt;<br>&gt;   @warn_unused_result<br>&gt;   func isLessThanOrEqual&lt;Other: BinaryFloatingPoint&gt;(to other: Other) -&gt; Bool<br>&gt;<br>&gt;   @warn_unused_result<br>&gt;   func isUnordered&lt;Other: BinaryFloatingPoint&gt;(with other: Other) -&gt; Bool<br>&gt;<br>&gt;   @warn_unused_result<br>&gt;   func totalOrder&lt;Other: BinaryFloatingPoint&gt;(with other: Other) -&gt; Bool<br>&gt;<br>&gt;   /// `value` rounded to the closest representable value.<br>&gt;   init&lt;Source: BinaryFloatingPoint&gt;(_ value: Source)<br>&gt;<br>&gt;   /// Fails if `value` cannot be represented exactly as `Self`.<br>&gt;   init?&lt;Source: BinaryFloatingPoint&gt;(exactly value: Source)<br>&gt; }<br>&gt;<br>&gt;     Float, Double, Float80 and CGFloat will conform to all of these protocols.<br>&gt;<br>&gt;     A small portion of the implementation of these APIs is dependent on new<br>&gt;     Integer protocols that will be proposed separately. Everything else is<br>&gt;     implemented in draft form on the branch floating-point-revision of my fork.<br>&gt;<br>&gt; SVG ImageImpact on existing code<br>&gt;<br>&gt;     1       The % operator is no longer available for FloatingPoint types. We<br>&gt;       don&#39;t believe that it was widely used correctly, and the operation is<br>&gt;       still available via the formTruncatingRemainder method for people who need<br>&gt;       it.<br>&gt;<br>&gt;     2       To follow the naming guidelines, NaN and isNaN are replaced with nan<br>&gt;       and isNan.<br>&gt;<br>&gt;     3       The redundant property quietNaN is removed.<br>&gt;<br>&gt;     4       isSignaling is renamed isSignalingNan.<br>&gt;<br>&gt; SVG ImageAlternatives considered<br>&gt;<br>&gt;     N/A.<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April 20, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Apr 20, 2016, at 1:15 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Tue Apr 19 2016, Thorsten Seitz &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I&#39;d like to have something like Summable with &#39;add&#39;, &#39;adding&#39; and &#39;zero&#39; being a<br>&gt;&gt; separate protocol as well as somthing like Multiplicative with &#39;multiply&#39;,<br>&gt;&gt; &#39;multiplied&#39; and &#39;one&#39; being a separate protocol, because these are universally<br>&gt;&gt; interesting for other cases, e.g. Summable would be useful for defining path<br>&gt;&gt; lengths in a graph library.<br>&gt;&gt; <br>&gt;&gt; Would you mind adding that to the proposal?<br>&gt; <br>&gt; I suspect you may be headed into the realm of<br>&gt; protocols-as-bags-of-syntax.<br>You say that like it’s a bad thing… Am I missing the point? (NOT a rhetorical question)<br></p><p>Speaking only for myself, I want stuff broken up into many simpler protocols (which `Arithmetic` and such conform to) because there are many algorithms which only require small parts of the larger protocol. What if I wanted to add a function that sums all the elements in a collection?<br>extension CollectionType where Generator.Element: Arithmetic {<br>    func sum() -&gt; Generator.Element {<br>        var s = Generator.Element()<br>        for e in self {<br>            s.add(e)<br>        }<br>        return s<br>    }<br>}<br></p><p>Yeah, it works, but if I want to get the sum of a collection of some custom type, I have to implement *all* of `Arithmetic`, as opposed to just the two parts of it (`init()` and `.add(:)`) that the algorithm actually uses. It’d be both simpler for the users and *more to the point of the function*, if it could be written like this:<br>extension CollectionType where Generator.Element: Addable { // &quot;Addable&quot; instead of &quot;Arithmetic&quot;<br>    ... // No change here<br>}<br></p><p>Now, if Swift allowed you to add protocol conformance to protocols:<br>protocol Addable {<br>    ... // Relevant subset of `Arithmetic`<br>}<br>#for T in Arithmetic { // &quot;#for&quot; because this is clearly macro-ish, and # seems to be what we&#39;ve settled on for that<br>    extension T : Addable {} // Don&#39;t need anything here since `Arithmetic` already has everything in `Addable`<br>}<br>… then this all becomes a somewhat moot point. If some generic function only needs a subset of a protocol’s functionality, said function’s author could do this “#for T …” song &amp; dance, and their function would be defined with the minimum constraints.<br></p><p><br>&gt; Look at pages 14 and 24 of<br>&gt; &lt;http://www.cs.indiana.edu/pub/techreports/TR638.pdf&gt;—which does the job<br>&gt; right for C++—and you&#39;ll see why.<br>COOL!!! Thanks for posting that, it looks like it’ll be a great read! :-D<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160420/ee1b8ba6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April 21, 2016 at 03:00:00pm</p></header><div class="content"><p>I totally agree with Dave Sweeris. He has put the issue quite nicely.<br></p><p>Being able to add protocol conformance to a protocol would indeed solve this problem (having well designed protocols in the standard library would still be nice, though, so many thanks for the pointers, Dave A, that looks really interesting!).<br></p><p>-Thorsten<br></p><p>&gt; Am 20.04.2016 um 23:23 schrieb Dave via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 20, 2016, at 1:15 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Tue Apr 19 2016, Thorsten Seitz &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like to have something like Summable with &#39;add&#39;, &#39;adding&#39; and &#39;zero&#39; being a<br>&gt;&gt;&gt; separate protocol as well as somthing like Multiplicative with &#39;multiply&#39;,<br>&gt;&gt;&gt; &#39;multiplied&#39; and &#39;one&#39; being a separate protocol, because these are universally<br>&gt;&gt;&gt; interesting for other cases, e.g. Summable would be useful for defining path<br>&gt;&gt;&gt; lengths in a graph library.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would you mind adding that to the proposal?<br>&gt;&gt; <br>&gt;&gt; I suspect you may be headed into the realm of<br>&gt;&gt; protocols-as-bags-of-syntax.<br>&gt; You say that like it’s a bad thing… Am I missing the point? (NOT a rhetorical question)<br>&gt; <br>&gt; Speaking only for myself, I want stuff broken up into many simpler protocols (which `Arithmetic` and such conform to) because there are many algorithms which only require small parts of the larger protocol. What if I wanted to add a function that sums all the elements in a collection?<br>&gt; extension CollectionType where Generator.Element: Arithmetic {<br>&gt;     func sum() -&gt; Generator.Element {<br>&gt;         var s = Generator.Element()<br>&gt;         for e in self {<br>&gt;             s.add(e)<br>&gt;         }<br>&gt;         return s<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Yeah, it works, but if I want to get the sum of a collection of some custom type, I have to implement *all* of `Arithmetic`, as opposed to just the two parts of it (`init()` and `.add(:)`) that the algorithm actually uses. It’d be both simpler for the users and *more to the point of the function*, if it could be written like this:<br>&gt; extension CollectionType where Generator.Element: Addable { // &quot;Addable&quot; instead of &quot;Arithmetic&quot;<br>&gt;     ... // No change here<br>&gt; }<br>&gt; <br>&gt; Now, if Swift allowed you to add protocol conformance to protocols:<br>&gt; protocol Addable {<br>&gt;     ... // Relevant subset of `Arithmetic`<br>&gt; }<br>&gt; #for T in Arithmetic { // &quot;#for&quot; because this is clearly macro-ish, and # seems to be what we&#39;ve settled on for that<br>&gt;     extension T : Addable {} // Don&#39;t need anything here since `Arithmetic` already has everything in `Addable`<br>&gt; }<br>&gt; … then this all becomes a somewhat moot point. If some generic function only needs a subset of a protocol’s functionality, said function’s author could do this “#for T …” song &amp; dance, and their function would be defined with the minimum constraints.<br>&gt; <br>&gt; <br>&gt;&gt; Look at pages 14 and 24 of<br>&gt;&gt; &lt;http://www.cs.indiana.edu/pub/techreports/TR638.pdf&gt;—which does the job<br>&gt;&gt; right for C++—and you&#39;ll see why.<br>&gt; COOL!!! Thanks for posting that, it looks like it’ll be a great read! :-D<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160421/2e451ce6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 21, 2016 at 11:00:00am</p></header><div class="content"><p>on Wed Apr 20 2016, davesweeris-AT-mac.com wrote:<br></p><p>&gt;&gt; On Apr 20, 2016, at 1:15 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Tue Apr 19 2016, Thorsten Seitz &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like to have something like Summable with &#39;add&#39;, &#39;adding&#39; and &#39;zero&#39; being a<br>&gt;&gt;&gt; separate protocol as well as somthing like Multiplicative with &#39;multiply&#39;,<br>&gt;&gt;&gt; &#39;multiplied&#39; and &#39;one&#39; being a separate protocol, because these are universally<br>&gt;&gt;&gt; interesting for other cases, e.g. Summable would be useful for defining path<br>&gt;&gt;&gt; lengths in a graph library.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would you mind adding that to the proposal?<br>&gt;&gt; <br>&gt;&gt; I suspect you may be headed into the realm of<br>&gt;&gt; protocols-as-bags-of-syntax.<br>&gt;<br>&gt; You say that like it’s a bad thing… <br></p><p>Indeed!<br></p><p>&gt; Am I missing the point? (NOT a rhetorical question)<br></p><p>I don&#39;t know, but I&#39;ll try to help answer...<br></p><p>&gt; Speaking only for myself, I want stuff broken up into many simpler<br>&gt; protocols (which `Arithmetic` and such conform to) because there are<br>&gt; many algorithms which only require small parts of the larger<br>&gt; protocol. What if I wanted to add a function that sums all the<br>&gt; elements in a collection?<br>&gt;<br>&gt; extension CollectionType where Generator.Element: Arithmetic {<br>&gt;     func sum() -&gt; Generator.Element {<br>&gt;         var s = Generator.Element()<br>&gt;         for e in self {<br>&gt;             s.add(e)<br>&gt;         }<br>&gt;         return s<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Yeah, it works, but if I want to get the sum of a collection of some custom type, I<br>&gt; have to implement *all* of `Arithmetic`, as opposed to just the two<br>&gt; parts of it (`init()` and `.add(:)`) that the algorithm actually<br>&gt; uses. It’d be both simpler for the users and *more to the point of the<br>&gt; function*, if it could be written like this:<br>&gt;<br>&gt; extension CollectionType where Generator.Element: Addable { // &quot;Addable&quot; instead of &quot;Arithmetic&quot;<br>&gt;     ... // No change here<br>&gt; }<br></p><p>This method is undocumented.  What does it *do*, given an arbitrary<br>element type conforming to Addable?  The answer needs to be a<br>description of the semantics that doesn&#39;t require me to effectively<br>execute the source of the function in my head.  How can I test that the<br>method does the right thing?  To answer these questions, you have to<br>attach some semantics to Addable so that it&#39;s more than a mere bag of<br>syntax.  For example, for the above to produce the usual semantics of<br>summing, the Element&#39;s init() method needs to produce the additive<br>identity element.<br></p><p>Choosing the granularity of protocols is something of an art.  Lots has<br>been written about generic programming&#39;s “requirement minimization<br>principle,” in which the more requirements you add, the less reusable<br>algorithms become.  Almost nothing has been written about the other side<br>of the coin, but...<br></p><p>After much googling I came up with a reference to one of Alexander<br>Stepanov and James Dehnert&#39;s early papers on generic programming (it<br>sometimes amazes me how many of the key insights can only be found in<br>that early work):<br></p><p>http://www.stepanovpapers.com/DeSt98.pdf<br></p><p>  We call the set of axioms satisfied by a data type and a set of<br>  operations on it a concept. Examples of concepts might be an integer<br>  data type with an addition operation satisfying the usual axioms; or a<br>  list of data objects with a first element, an iterator for traversing<br>  the list, and a test for identifying the end of the list. **The critical<br>  insight which produced generic programming is that highly reusable<br>  components must be programmed assuming a minimal collection of such<br>  concepts, and that the concepts used must match as wide a variety of<br>  concrete program structures as possible**. Thus, successful production<br>  of a generic component is not simply a matter of identifying the<br>  minimal requirements of an arbitrary type or algorithm – it requires<br>  identifying the common requirements of a broad collection of similar<br>  components. The final requirement is that we accomplish this without<br>  sacrificing performance relative to programming with concrete<br>  structures. A good generic library becomes a repository of highly<br>  efficient data structures and algorithms, based on a small number of<br>  broadly useful concepts, such that a library user can combine them and<br>  his own components in a wide variety of ways.<br></p><p>(emphasis mine).<br></p><p>I&#39;m not sure I&#39;m adding anything by saying this, but one problem with<br>creating protocols that satisfy the absolute minimum requirements for a<br>particular algorithm is that you end up without any meaningful<br>abstractions.<br></p><p>“*The* critical insight,” wow.  And it&#39;s so easily overlooked.<br></p><p>HTH,<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April 21, 2016 at 11:00:00pm</p></header><div class="content"><p>I totally agree with you. <br></p><p>But I think that the suggested Summable with zero fits the bill of your citation quite nicely as it actually is a very generic concept which is widely useful. <br></p><p>FWIW I had chosen the name Summable instead of Monoid for two reasons: (1) there has been reluctance by some people on this list to add algebraic types to the standard library and (2) Summable is one concrete instance of Monoid for numbers (with respect to addition) just as my other suggestion Multiplicative is another instance of Monoid for numbers (with respect to multiplication).<br></p><p>If we want to add Monoid (and other algebraic types) to the standard library (I would welcome that), you are certainly right that we should design this well. The above actually suggests that summable and multiplicative instances for numbers might just be that: (singleton?) instances of Monoid with an associated type of Number (instead of protocols) so that they can be passed around more easily. <br>On the other hand we could borrow some ideas from Eiffel to solve the (semantic) diamond problem via renaming and choosing defaults. Like the early work about generics you found, Eiffel&#39;s solution sadly is ignored in most language designs (and interfaces thought of as a solution of the diamond problem... they are not). Not too long ago I wrote a lenghty mail on this list about that in the Mixin thread IIRC.<br></p><p>&gt; I&#39;m not sure I&#39;m adding anything by saying this, but one problem with<br>&gt; creating protocols that satisfy the absolute minimum requirements for a<br>&gt; particular algorithm is that you end up without any meaningful<br>&gt; abstractions.<br></p><p>I think Dave Sweeris&#39; example is not about creating Addable a.k.a Summable just because it satisfies the algorithm but rather it happens that Monoid *is* such a useful abstraction that it naturally pops up in many algorithms.<br></p><p>-Thorsten <br></p><p>&gt; Am 21.04.2016 um 20:36 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt; on Wed Apr 20 2016, davesweeris-AT-mac.com wrote:<br>&gt; <br>&gt;&gt;&gt; On Apr 20, 2016, at 1:15 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Tue Apr 19 2016, Thorsten Seitz &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d like to have something like Summable with &#39;add&#39;, &#39;adding&#39; and &#39;zero&#39; being a<br>&gt;&gt;&gt;&gt; separate protocol as well as somthing like Multiplicative with &#39;multiply&#39;,<br>&gt;&gt;&gt;&gt; &#39;multiplied&#39; and &#39;one&#39; being a separate protocol, because these are universally<br>&gt;&gt;&gt;&gt; interesting for other cases, e.g. Summable would be useful for defining path<br>&gt;&gt;&gt;&gt; lengths in a graph library.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Would you mind adding that to the proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I suspect you may be headed into the realm of<br>&gt;&gt;&gt; protocols-as-bags-of-syntax.<br>&gt;&gt; <br>&gt;&gt; You say that like it’s a bad thing… <br>&gt; <br>&gt; Indeed!<br>&gt; <br>&gt;&gt; Am I missing the point? (NOT a rhetorical question)<br>&gt; <br>&gt; I don&#39;t know, but I&#39;ll try to help answer...<br>&gt; <br>&gt;&gt; Speaking only for myself, I want stuff broken up into many simpler<br>&gt;&gt; protocols (which `Arithmetic` and such conform to) because there are<br>&gt;&gt; many algorithms which only require small parts of the larger<br>&gt;&gt; protocol. What if I wanted to add a function that sums all the<br>&gt;&gt; elements in a collection?<br>&gt;&gt; <br>&gt;&gt; extension CollectionType where Generator.Element: Arithmetic {<br>&gt;&gt;    func sum() -&gt; Generator.Element {<br>&gt;&gt;        var s = Generator.Element()<br>&gt;&gt;        for e in self {<br>&gt;&gt;            s.add(e)<br>&gt;&gt;        }<br>&gt;&gt;        return s<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Yeah, it works, but if I want to get the sum of a collection of some custom type, I<br>&gt;&gt; have to implement *all* of `Arithmetic`, as opposed to just the two<br>&gt;&gt; parts of it (`init()` and `.add(:)`) that the algorithm actually<br>&gt;&gt; uses. It’d be both simpler for the users and *more to the point of the<br>&gt;&gt; function*, if it could be written like this:<br>&gt;&gt; <br>&gt;&gt; extension CollectionType where Generator.Element: Addable { // &quot;Addable&quot; instead of &quot;Arithmetic&quot;<br>&gt;&gt;    ... // No change here<br>&gt;&gt; }<br>&gt; <br>&gt; This method is undocumented.  What does it *do*, given an arbitrary<br>&gt; element type conforming to Addable?  The answer needs to be a<br>&gt; description of the semantics that doesn&#39;t require me to effectively<br>&gt; execute the source of the function in my head.  How can I test that the<br>&gt; method does the right thing?  To answer these questions, you have to<br>&gt; attach some semantics to Addable so that it&#39;s more than a mere bag of<br>&gt; syntax.  For example, for the above to produce the usual semantics of<br>&gt; summing, the Element&#39;s init() method needs to produce the additive<br>&gt; identity element.<br>&gt; <br>&gt; Choosing the granularity of protocols is something of an art.  Lots has<br>&gt; been written about generic programming&#39;s “requirement minimization<br>&gt; principle,” in which the more requirements you add, the less reusable<br>&gt; algorithms become.  Almost nothing has been written about the other side<br>&gt; of the coin, but...<br>&gt; <br>&gt; After much googling I came up with a reference to one of Alexander<br>&gt; Stepanov and James Dehnert&#39;s early papers on generic programming (it<br>&gt; sometimes amazes me how many of the key insights can only be found in<br>&gt; that early work):<br>&gt; <br>&gt; http://www.stepanovpapers.com/DeSt98.pdf<br>&gt; <br>&gt;  We call the set of axioms satisfied by a data type and a set of<br>&gt;  operations on it a concept. Examples of concepts might be an integer<br>&gt;  data type with an addition operation satisfying the usual axioms; or a<br>&gt;  list of data objects with a first element, an iterator for traversing<br>&gt;  the list, and a test for identifying the end of the list. **The critical<br>&gt;  insight which produced generic programming is that highly reusable<br>&gt;  components must be programmed assuming a minimal collection of such<br>&gt;  concepts, and that the concepts used must match as wide a variety of<br>&gt;  concrete program structures as possible**. Thus, successful production<br>&gt;  of a generic component is not simply a matter of identifying the<br>&gt;  minimal requirements of an arbitrary type or algorithm – it requires<br>&gt;  identifying the common requirements of a broad collection of similar<br>&gt;  components. The final requirement is that we accomplish this without<br>&gt;  sacrificing performance relative to programming with concrete<br>&gt;  structures. A good generic library becomes a repository of highly<br>&gt;  efficient data structures and algorithms, based on a small number of<br>&gt;  broadly useful concepts, such that a library user can combine them and<br>&gt;  his own components in a wide variety of ways.<br>&gt; <br>&gt; (emphasis mine).<br>&gt; <br>&gt; I&#39;m not sure I&#39;m adding anything by saying this, but one problem with<br>&gt; creating protocols that satisfy the absolute minimum requirements for a<br>&gt; particular algorithm is that you end up without any meaningful<br>&gt; abstractions.<br>&gt; <br>&gt; “*The* critical insight,” wow.  And it&#39;s so easily overlooked.<br>&gt; <br>&gt; HTH,<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160421/d81da4e8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
