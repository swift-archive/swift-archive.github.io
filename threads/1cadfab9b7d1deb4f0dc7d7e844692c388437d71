<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 26, 2016 at 10:00:00am</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of “Abstract classes and methods” begins now and runs through March 4, 2016. The proposal is available here:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br></p><p>Proposal link:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md<br></p><p>Reply text<br></p><p>Other replies<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	• What is your evaluation of the proposal?<br>	• Is the problem being addressed significant enough to warrant a change to Swift?<br>	• Does this proposal fit well with the feel and direction of Swift?<br>	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at:<br></p><p>https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Joe<br>Review Manager<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution-announce/attachments/20160226/1cad7d71/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>February 26, 2016 at 01:00:00pm</p></header><div class="content"><p>What is your evaluation of the proposal?<br></p><p>I believe it is a well intended and certainly an interesting feature to have.<br></p><p>Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>No, but not strongly.  Sure, there are cases where it would make more sense to use an &quot;interface class&quot; (a la Java) to implement an abstract data type, but I believe those kinds of design patterns are subsumed by protocols and Swift&#39;s general approach to designing data types in the large.  Even a language as dedicated to OO as Objective-C didn&#39;t need abstract classes, and where necessary, were simply implemented with macros declaring a one-line stub that throws an exception.  Even without macros, I don&#39;t believe the keystroke savings is enough to justify the inclusion of another keyword.<br></p><p>Does this proposal fit well with the feel and direction of Swift?<br></p><p>For the reasons above, I&#39;m afraid not.<br></p><p>How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A quick reading.<br></p><p>~Robert Widmann<br></p><p>2016/02/26 13:11、Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of “Abstract classes and methods” begins now and runs through March 4, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md<br>&gt; <br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	• What is your evaluation of the proposal?<br>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Joe<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/d5ddeaaa/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>February 26, 2016 at 11:00:00am</p></header><div class="content"><p>What is your evaluation of the proposal?<br></p><p>-1. The examples are not compelling enough. The only value currently, that I see at least, is the ability to require a specific storage mechanism for properties and to provide default values for all implementations of those properties.<br></p><p>Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Maybe, but I believe updates to protocols are the better path.<br></p><p>Does this proposal fit well with the feel and direction of Swift?<br></p><p>No. <br></p><p>If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Yes, such as C++ and C#. In the vast majority of cases, the usage seemed to break down into two basic categories: mixins and interfaces. I don&#39;t believe this proposal really addresses either of those use cases well.<br></p><p>How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A quick reading.<br></p><p>-David<br></p><p><br>&gt; On Feb 26, 2016, at 10:11 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of “Abstract classes and methods” begins now and runs through March 4, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	• What is your evaluation of the proposal?<br>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; -Joe<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/13bd74b1/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>February 26, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md<br>&gt; 	• What is your evaluation of the proposal?<br></p><p>I am mixed on this. I’ve mentioned wanting this myself on this list and have run into situations where I *really* wished I had it at the time (instead of having to do fatalError()), but ultimately I’ve almost always gone back to redesign those things to get rid of the abstract base class pattern and improved the design in the process. Perhaps this is an anti-pattern and Swift should not encourage it. I’m not sure.<br></p><p><br>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>I’m not so sure. I feel like by not having it, Swift has often pushed me toward better design (at the cost of some of my hair).<br></p><p><br>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br></p><p>Again, I’m not sure about this. I don’t think the potential of protocols have been fully explored yet and this feels like just adding an old feature from old languages because that’s the way we’re used to doing it. I feel like you could get the same effect by having a way to apply a single protocol to a class “abstractly” and have that *result in* an abstract class. This would more clearly separate the parts that are meant for subclasses to fill in vs. not. For example, to use the class from the proposal:<br></p><p>protocol RESTClientSubclass {<br>  var url : String { get }<br>}<br></p><p>class RESTClient: @abstract(RESTClientSubclass) {}<br></p><p>class MyRestServiceClient : RESTClient {<br>  var url : String { return &quot;http://www.foo.com/client” }<br>}<br></p><p>“override” wouldn’t be necessary here because you’re not actually overriding anything and the methods/properties the subclass needs to implement are clearly grouped together in the RESTClientSubclass protocol. (In fact it might even be an error for RESTClient to implement *any* method itself in an abstract protocol conformance).<br></p><p><br>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Yes and it doesn’t feel any different - which is what bothers me, perhaps. :)<br></p><p><br>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Skimmed the discussions as they happened a bit, read the proposal, but did not spend significant time on it.<br></p><p>l8r<br>Sean<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>February 26, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt;From the other thread, quoting myself:<br></p><p>&quot;Do not take me wrong, I really like protocols and structs and I understand<br>how to use them, but it seems that many of us believe that the is something<br>wrong with classes and the protocol/struct is the new Holy Grail. I<br>disagree. New possibilites and new way to do things are always welcome,<br>mainly if they are solid and consistent and really solves the<br>problem intended to be solved.<br></p><p>I also understand that the Swift team does not want to introduce any new<br>keywords to the language. To tell the truth I think I need to read again<br>all the information on Swift. I thought the Swift would be one thing, but<br>looks like it will be another. It is likely that the wrong one is me.<br></p><p>Provide ways to create abstract classes and abstract methods is not a<br>&quot;keystroke saver&quot;. It is one of many concepts involved in OOP, IMHO.&quot;<br></p><p>-Van<br></p><p>On Fri, Feb 26, 2016 at 4:21 PM, Sean Heber via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; Proposal link:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md<br>&gt; &gt;       • What is your evaluation of the proposal?<br>&gt;<br>&gt; I am mixed on this. I’ve mentioned wanting this myself on this list and<br>&gt; have run into situations where I *really* wished I had it at the time<br>&gt; (instead of having to do fatalError()), but ultimately I’ve almost always<br>&gt; gone back to redesign those things to get rid of the abstract base class<br>&gt; pattern and improved the design in the process. Perhaps this is an<br>&gt; anti-pattern and Swift should not encourage it. I’m not sure.<br>&gt;<br>&gt;<br>&gt; &gt;       • Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;<br>&gt; I’m not so sure. I feel like by not having it, Swift has often pushed me<br>&gt; toward better design (at the cost of some of my hair).<br>&gt;<br>&gt;<br>&gt; &gt;       • Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; Again, I’m not sure about this. I don’t think the potential of protocols<br>&gt; have been fully explored yet and this feels like just adding an old feature<br>&gt; from old languages because that’s the way we’re used to doing it. I feel<br>&gt; like you could get the same effect by having a way to apply a single<br>&gt; protocol to a class “abstractly” and have that *result in* an abstract<br>&gt; class. This would more clearly separate the parts that are meant for<br>&gt; subclasses to fill in vs. not. For example, to use the class from the<br>&gt; proposal:<br>&gt;<br>&gt; protocol RESTClientSubclass {<br>&gt;   var url : String { get }<br>&gt; }<br>&gt;<br>&gt; class RESTClient: @abstract(RESTClientSubclass) {}<br>&gt;<br>&gt; class MyRestServiceClient : RESTClient {<br>&gt;   var url : String { return &quot;http://www.foo.com/client” }<br>&gt; }<br>&gt;<br>&gt; “override” wouldn’t be necessary here because you’re not actually<br>&gt; overriding anything and the methods/properties the subclass needs to<br>&gt; implement are clearly grouped together in the RESTClientSubclass protocol.<br>&gt; (In fact it might even be an error for RESTClient to implement *any* method<br>&gt; itself in an abstract protocol conformance).<br>&gt;<br>&gt;<br>&gt; &gt;       • If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;<br>&gt; Yes and it doesn’t feel any different - which is what bothers me, perhaps.<br>&gt; :)<br>&gt;<br>&gt;<br>&gt; &gt;       • How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>&gt; Skimmed the discussions as they happened a bit, read the proposal, but did<br>&gt; not spend significant time on it.<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/db125926/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5818a8a9211c31af95d6db8974457683?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0026 Abstract classes and methods</strong> from <string>Joseph Lord</string> &lt;joseph at human-friendly.com&gt;<p>February 26, 2016 at 07:00:00pm</p></header><div class="content"><p>-1<br></p><p>Requiring sub classing is never necessary and equivalent effects can be achieved by having customisation points in the form of delegates with protocol types (I prefer separate delegates for different aspects of customisation). The delegates can be required in the initializer is they are necessary. If the client wants to subclass they still can and then set the delegate to self.<br></p><p>Inheritance isn&#39;t necessarily bad but it is a distinct design choice that should be left to the client code not forced by the library.<br></p><p>Summary:<br>Isn&#39;t necessary.<br>Complicates language.<br>Forces class and inheritance model on client code.<br>Single inheritance also puts limitations that don&#39;t exist with protocols. <br></p><p>The proposal does say that there are things that can&#39;t be achieved by protocols although I didn&#39;t understand what they are although it may have been saying protocol extensions which may have limits that delegation does not have. <br></p><p>I haven&#39;t followed the preceding discussion on this proposal but I have been thinking about such things in Swift for some time. This blog post was supporting the access control design and the lack of need for protected which has very similar arguments and alternative approaches as does abstract. There is also some discussion on the post.<br>http://blog.human-friendly.com/swift-access-controls-are-like-cs-and-that-isnt-necessarily-a-bad-thing<br></p><p>Aside:<br>One improvement to delegation I would like is to be able to create a property that is either weak or a value type so that delegates are not forced to be classes to avoid retain loops. Maybe it will be possible with property behaviours.<br></p><p>Joseph<br></p><p>&gt; On Feb 26, 2016, at 6:11 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of “Abstract classes and methods” begins now and runs through March 4, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md<br>&gt; <br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	• What is your evaluation of the proposal?<br>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Joe<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/b0519d43/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0026 Abstract classes and methods</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>February 26, 2016 at 11:00:00am</p></header><div class="content"><p>&gt;<br>&gt; • What is your evaluation of the proposal?<br>&gt;<br></p><p>I am in favor of this proposal, for reasons described below.<br></p><p><br>&gt; • Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?<br>&gt;<br></p><p>In my opinion, yes.<br></p><p>Currently (and for some time to come to come), one of Swift&#39;s primary use<br>cases will be building iOS and OS X applications using the Cocoa and Cocoa<br>Touch frameworks. These frameworks are object-oriented and<br>inheritance-based. They make use of the class cluster pattern and contain<br>classes that are meant only as templates for application subclasses.<br>Support for abstract classes would allow formalizing usage restrictions<br>that currently exist only as informal conventions, sternly worded<br>documentation comments, and runtime asserts.<br></p><p>Even if Cocoa is never augmented to take advantage of abstract Swift<br>classes (an idea: pragma directive to import an Objective-C class as<br>&#39;abstract&#39;?), there are quite a few app development patterns which involve<br>creating &#39;abstract&#39; view controllers or UI elements with various<br>customization points meant to be filled in by subclasses. Abstract class<br>support would make this less error-prone.<br></p><p><br>&gt; • Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br></p><p>The question we should be asking is, &quot;is inheritance-based object-oriented<br>programming using `class` a first-class Swift citizen?&quot; Or is Swift&#39;s OO<br>subsystem something &#39;grudgingly&#39; included in the language to facilitate<br>ObjC/Cocoa interop? I love POP and hate the misuse of inheritance as much<br>as anyone on this list, but I still think that inheritance-based modeling<br>is the best solution to at least some types of problems.<br></p><p>I don&#39;t think abstract classes unduly burden the rest of the language, and<br>I think they are an important part of object-oriented programming and<br>interop with existing frameworks that Objective-C could have benefitted<br>from. (&#39;Burden&#39; in this case is in contrast to something like inout, an<br>excellent feature which nonetheless has resulted in weird ramifications for<br>everything from tuple splatting to closure argument capture to currying.)<br></p><p><br>&gt; • If you have used other languages or libraries with a similar feature,<br>&gt; how do you feel that this proposal compares to those?<br>&gt;<br></p><p>n/a, although the design seems like a thoroughly conventional one compared<br>to the same concept in other OO languages.<br></p><p><br>&gt; • How much effort did you put into your review? A glance, a quick reading,<br>&gt; or an in-depth study?<br>&gt;<br></p><p>Close reading of proposal document. Following (and posted in) various<br>threads in which the topic came up.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/f32e79ff/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0026 Abstract classes and methods</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>February 26, 2016 at 08:00:00pm</p></header><div class="content"><p>I am on the road at the moment so hard to do a full reply to the<br>proposal... so I just want to say basically ditto to what Austin posted.<br></p><p>It improve class support in Swift while not getting in the way of other<br>Swift paradigms.<br></p><p>On Fri, Feb 26, 2016 at 11:58 AM Austin Zheng via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; • What is your evaluation of the proposal?<br>&gt;&gt;<br>&gt;<br>&gt; I am in favor of this proposal, for reasons described below.<br>&gt;<br>&gt;<br>&gt;&gt; • Is the problem being addressed significant enough to warrant a change<br>&gt;&gt; to Swift?<br>&gt;&gt;<br>&gt;<br>&gt; In my opinion, yes.<br>&gt;<br>&gt; Currently (and for some time to come to come), one of Swift&#39;s primary use<br>&gt; cases will be building iOS and OS X applications using the Cocoa and Cocoa<br>&gt; Touch frameworks. These frameworks are object-oriented and<br>&gt; inheritance-based. They make use of the class cluster pattern and contain<br>&gt; classes that are meant only as templates for application subclasses.<br>&gt; Support for abstract classes would allow formalizing usage restrictions<br>&gt; that currently exist only as informal conventions, sternly worded<br>&gt; documentation comments, and runtime asserts.<br>&gt;<br>&gt; Even if Cocoa is never augmented to take advantage of abstract Swift<br>&gt; classes (an idea: pragma directive to import an Objective-C class as<br>&gt; &#39;abstract&#39;?), there are quite a few app development patterns which involve<br>&gt; creating &#39;abstract&#39; view controllers or UI elements with various<br>&gt; customization points meant to be filled in by subclasses. Abstract class<br>&gt; support would make this less error-prone.<br>&gt;<br>&gt;<br>&gt;&gt; • Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;<br>&gt;<br>&gt; The question we should be asking is, &quot;is inheritance-based object-oriented<br>&gt; programming using `class` a first-class Swift citizen?&quot; Or is Swift&#39;s OO<br>&gt; subsystem something &#39;grudgingly&#39; included in the language to facilitate<br>&gt; ObjC/Cocoa interop? I love POP and hate the misuse of inheritance as much<br>&gt; as anyone on this list, but I still think that inheritance-based modeling<br>&gt; is the best solution to at least some types of problems.<br>&gt;<br>&gt; I don&#39;t think abstract classes unduly burden the rest of the language, and<br>&gt; I think they are an important part of object-oriented programming and<br>&gt; interop with existing frameworks that Objective-C could have benefitted<br>&gt; from. (&#39;Burden&#39; in this case is in contrast to something like inout, an<br>&gt; excellent feature which nonetheless has resulted in weird ramifications for<br>&gt; everything from tuple splatting to closure argument capture to currying.)<br>&gt;<br>&gt;<br>&gt;&gt; • If you have used other languages or libraries with a similar feature,<br>&gt;&gt; how do you feel that this proposal compares to those?<br>&gt;&gt;<br>&gt;<br>&gt; n/a, although the design seems like a thoroughly conventional one compared<br>&gt; to the same concept in other OO languages.<br>&gt;<br>&gt;<br>&gt;&gt; • How much effort did you put into your review? A glance, a quick<br>&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;<br>&gt;<br>&gt; Close reading of proposal document. Following (and posted in) various<br>&gt; threads in which the topic came up.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/3f5d88b0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0026 Abstract classes and methods</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>February 26, 2016 at 02:00:00pm</p></header><div class="content"><p>-1.  I don’t think the protocol oriented programming has had enough time to sink in yet, and I’d like to see what else can be done with protocols as the generic system matures.  Then maybe revisit this topic next year and see if abstract classes are still as desirable.<br></p><p>Others on this thread have suggested workarounds to accomplish the job of abstract classes, and I’m happy to do that for the time being rather than changing the language.<br></p><p>Matt<br> <br>&gt; On Feb 26, 2016, at 11:58, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 	• What is your evaluation of the proposal?<br>&gt; <br>&gt; I am in favor of this proposal, for reasons described below.<br>&gt;  <br>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; In my opinion, yes.<br>&gt; <br>&gt; Currently (and for some time to come to come), one of Swift&#39;s primary use cases will be building iOS and OS X applications using the Cocoa and Cocoa Touch frameworks. These frameworks are object-oriented and inheritance-based. They make use of the class cluster pattern and contain classes that are meant only as templates for application subclasses. Support for abstract classes would allow formalizing usage restrictions that currently exist only as informal conventions, sternly worded documentation comments, and runtime asserts.<br>&gt; <br>&gt; Even if Cocoa is never augmented to take advantage of abstract Swift classes (an idea: pragma directive to import an Objective-C class as &#39;abstract&#39;?), there are quite a few app development patterns which involve creating &#39;abstract&#39; view controllers or UI elements with various customization points meant to be filled in by subclasses. Abstract class support would make this less error-prone.<br>&gt;  <br>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; The question we should be asking is, &quot;is inheritance-based object-oriented programming using `class` a first-class Swift citizen?&quot; Or is Swift&#39;s OO subsystem something &#39;grudgingly&#39; included in the language to facilitate ObjC/Cocoa interop? I love POP and hate the misuse of inheritance as much as anyone on this list, but I still think that inheritance-based modeling is the best solution to at least some types of problems.<br>&gt; <br>&gt; I don&#39;t think abstract classes unduly burden the rest of the language, and I think they are an important part of object-oriented programming and interop with existing frameworks that Objective-C could have benefitted from. (&#39;Burden&#39; in this case is in contrast to something like inout, an excellent feature which nonetheless has resulted in weird ramifications for everything from tuple splatting to closure argument capture to currying.)<br>&gt;  <br>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; n/a, although the design seems like a thoroughly conventional one compared to the same concept in other OO languages.<br>&gt;  <br>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; Close reading of proposal document. Following (and posted in) various threads in which the topic came up.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/f9bafd2f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0026 Abstract classes and methods</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>February 26, 2016 at 07:00:00pm</p></header><div class="content"><p>We have a hammer and pliers. Now we invented a screwdriver, let&#39;s throw the<br>hammer in the trash. (If it was a sonic screwdriver would be cool.)<br></p><p>I believe that each tool is used for a purpose. Taking the possibility of<br>other tools just because there is a new way to another does not seem to<br>make sense.<br></p><p>Otherwise, what about eliminate classes for good? What do you (plural)<br>think? So the Swift will be fully POP. (This remember me: &quot;POP goes my<br>heart!&quot; I can swear I&#39;m listening someone singing this song here.)<br></p><p>I like POP anda I like OOP. I&#39;d like to use both in Swift development.<br></p><p>Remembering that Cocoa/CocoaTouch is fundamentally made using classes and<br>subclasses in mind. I know that Objective-C does not have abstract classes,<br>but this is a defect, not a quality.<br></p><p>Well... Maybe we have a whole new  set of frameworks for OS<br>X/iOS/watchOS/tvOS coming and I do not know?<br></p><p>-Van<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/19f977e0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5818a8a9211c31af95d6db8974457683?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0026 Abstract classes and methods</strong> from <string>Joseph Lord</string> &lt;Joseph at human-friendly.com&gt;<p>February 27, 2016 at 02:00:00am</p></header><div class="content"><p>Sent from my phone<br>&gt; On Feb 26, 2016, at 10:54 PM, Vanderlei Martinelli via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; We have a hammer and pliers. Now we invented a screwdriver, let&#39;s throw the hammer in the trash. (If it was a sonic screwdriver would be cool.)<br>&gt; <br>&gt; I believe that each tool is used for a purpose. Taking the possibility of other tools just because there is a new way to another does not seem to make sense.<br></p><p>The path of including everything that is useful leads to C++ and isn&#39;t what I want for Swift. <br></p><p>&gt; Otherwise, what about eliminate classes for good? What do you (plural) think? So the Swift will be fully POP. (This remember me: &quot;POP goes my heart!&quot; I can swear I&#39;m listening someone singing this song here.)<br></p><p>If it wasn&#39;t for existing code and particularly Cocoa Touch I might be tempted to propose removing implementation inheritance. Even the if that was the case a reference type would still be desirable and probably necessary. <br></p><p>&gt; I like POP anda I like OOP. I&#39;d like to use both in Swift development.<br>&gt; <br>&gt; Remembering that Cocoa/CocoaTouch is fundamentally made using classes and subclasses in mind. I know that Objective-C does not have abstract classes, but this is a defect, not a quality.<br></p><p>Yes they are very class based, but they are also heavily protocol and delegation based and I think that is the better pattern to encourage. The only place I can think of where there is an abstract class is in gesture recognition and I think it would be better if there was an additional delegate instead. <br></p><p>&gt; Well... Maybe we have a whole new  set of frameworks for OS X/iOS/watchOS/tvOS coming and I do not know?<br></p><p>Existing code will not disappear even if that does happen but that doesn&#39;t mean inheritance should be encouraged. <br></p><p>Joseph<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>February 26, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; 	• What is your evaluation of the proposal?<br></p><p>I am against the proposal. I believe that protocols, mix-ins and composition are better answers to the problems that abstract classes are usually called to solve. In my experience, abstract classes lead to subpar design decisions.<br></p><p>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>I do not believe so. There are most likely cases where current tools could be improved, by that should be done by improving support for behavior composition rather than forced subclassing<br></p><p>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br></p><p>I do not believe so, for the reason outlined above<br></p><p>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A quick glance. <br></p><p><br>&gt; On 26 Feb 2016, at 19:11, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of “Abstract classes and methods” begins now and runs through March 4, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	• What is your evaluation of the proposal?<br>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; -Joe<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/339e02eb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6a925eec074f3a4a853412a55bbc543e?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Joshua Kopin</string> &lt;jkopin at apple.com&gt;<p>February 26, 2016 at 01:00:00pm</p></header><div class="content"><p>## What is your evaluation of the proposal?<br></p><p>I vote -1 on the proposal as submitted. First of all, while I do <br>appreciate the effort that went into writing the proposal, having read <br>the whole document I still don&#39;t understand (i) exactly what problem is <br>being solved here and (ii) why abstract classes are the necessary <br>solution to those problems. This might just be a function of my lack of <br>knowledge, but considering that this proposal is trying to extend the <br>language with a significant new concept, I think the burden should be on <br>its author to analyze the problem, sketch out a space of possible <br>solutions to the problem as analyzed, weight these solutions against one <br>another by examining each of their consequences, and demonstrate why the <br>proposed solution is the best possible option in light of the <br>alternatives.<br></p><p><br>## If you have used other languages or libraries with a similar feature, <br>how do you feel that  this proposal compares to those?<br></p><p>To put my cards on the table -- while I do acknowledge their utility I&#39;m <br>not a big fan on abstract classes. I think they&#39;re an ad-hoc solution to <br>a deep problem that benefits from a more principled approach.<br></p><p>Here&#39;s my best attempt at a breakdown. In my view, if classes give <br>programmers a concise way to specify a data structure, its interface, <br>and its implementation in an open, hierarchically extensible fashion, <br>abstract classes give programmers a concise way to *partially* specify a <br>data structure, its interface, and its implementation in an open, <br>hierarchically extensible fashion.<br></p><p>The issue I have with abstract classes is that there are much better, <br>more principled ways to solve the problem of partial specification of an <br>data structure / interface implementation in an extensible fashion <br>(mixins, in particular, which I understand to be more or less <br>protocols-with-storage that introduce a subtyping relationship with <br>anything that mixes them in). Abstract classes are a convenient, nearly <br>inevitable, and actually pretty decent incremental extension of the <br>object-oriented paradigm. But when you break out the deep problems <br>abstract classes are meant to solve, they emerge (in my opinion) as <br>incomplete, limited, and ultimately unhelpful despite their utility.<br></p><p>The main reason for this is that they lock users into hierarchical <br>inheritance (and hierarchical thinking) when it isn&#39;t needed, it isn&#39;t <br>efficient, and it isn&#39;t as flexible as it could be. The flexibility <br>afforded by mixins (especially if mixins themselves could inherit from <br>and extend one another) would allow the user to reuse code in far more <br>ways that abstract classes currently do. It would allow functionality to <br>be factored out in all of the clever ways protocol extensions currently <br>allow but without the storage-related limitations.<br></p><p>## Is the problem being addressed significant enough to warrant a change <br>to Swift?<br></p><p>I&#39;m not sure, partially because having read the proposal I&#39;m still not <br>clear exactly what the problem is. While I have on occasion missed <br>something like abstract classes in Swift, that itch has always been <br>minor, and it is often an indication that my architecture could use a <br>good rethink. On top of that, as I outlined above, mixins have always <br>seemed to me like a strictly more powerful solution to the same problem <br>solved by abstract classes. I&#39;d be willing to wait for protocols / <br>protocol extensions to gain the ability to add storage to the structs <br>and classes that adopt them.<br></p><p>## Does this proposal fit well with the feel and direction of Swift?<br></p><p>I don&#39;t think so, for the reasons above.<br></p><p>## How much effort did you put into your review? A glance, a quick <br>reading, or an in-depth study?<br></p><p>I read the whole proposal once and have followed the discussion a little <br>bit.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/479aa5fd/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>February 26, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 26, 2016, at 12:11 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md&gt;<br>&gt; 	• What is your evaluation of the proposal?<br></p><p>A tentative -1; although there are places abstract classes *would* be useful, I can’t think of a single such scenario for which an abstract class would be the *best* solution (or at least the solution I’d prefer).<br></p><p>Since the points I would make here have already been made I won’t belabor this point; suffice to say it’d be a lot more compelling a proposition if there were an example usage that fundamentally required the abstract-class approach (and couldn’t simply accept some parameters in `init`).<br></p><p>I do have some “fresh&quot; concerns, however.<br></p><p># Support For “Intermediate” Classes<br></p><p>As stated, it seems the proposal would force classes to be either or concrete; this is going to be limiting at times, and approaches like the below are often useful:<br></p><p>// fully-abstract<br>abstract class BaseClass  {<br> <br>  abstract func someFunction()<br>  abstract func someOtherFunction()<br></p><p>}<br></p><p>// partially-abstract<br>abstract class IntermediateClass : BaseClass {<br></p><p>  override func someFunction() { /* implementation here */  }<br></p><p>}<br></p><p>// fully-concrete<br>class TerminalClass : IntermediateClass {<br></p><p>  override func someOtherFunction() { /* implementation here */ }<br></p><p>}<br></p><p>…although I could be mis-reading the proposal.<br></p><p># Access Control Issues: Mixed OK, or Not?<br></p><p>Abstract classes and access control issues would need to be addressed. EG: is the below allowed, or not:<br></p><p>abstract public class ClassWithInternalAbstractMembers {<br></p><p>  // abstract members less visible than the containing type:<br>  internal abstract func someFunctionOnlyVisibleWithinThisModule()<br>  private abstract func someFunctionOnlyVisibleWithinThisFile()<br></p><p>}<br></p><p>…?<br></p><p>I think *not* is more consistent with how Swift generally works, but if *not* is chosen it has some awkward implications for how useful the feature is (see next point).<br></p><p># Can’t Use Nicely For a “Closed&quot; Class-Cluster<br></p><p>I personally think the strongest case for abstract classes is as an aide to building class-clusters, but there seem to be major issues doing this from Swift, especially if you are hoping for a “closed” class-cluster (e.g. one that isn’t meant for subclassing &quot;from outside the module”). That is, it should meet the following bullet-points:<br></p><p>- there’s an abstract public base class (as the public-API)<br>- this public base class is de-facto final (not meant for “external” subclassing)<br>- there are some “private”, concrete subclasses (specialized in various ways, and all `final`)<br></p><p>…(noting that you wouldn’t always *want* a closed cluster, but sometimes you would…). <br></p><p>One annoying issue here is that such a class-cluster can’t use `init`; even if we *could* have `init` return a subclass instance, the compiler would still presumably want to prevent us from “instantiating” an instance of our abstract class, and this seems awkward to really resolve…so we’re stuck with static factory functions (which will seem unnatural).<br></p><p>Most of the other issues I’d raise re really due to the lack of a way to say “this class/this method/etc. should be *treated* as final outside this module, even if it’s not actually `final` within the module”. But, without that kind of feature, it becomes hard to achieve a “de-facto `final`” approach, b/c:<br></p><p>- the abstract base class is public<br>- thus the abstract functions are also public (by no-mixed-visibility assumption)<br>- those methods can’t be marked final (we *need* to override them)<br>- thus we can’t achieve the closed-family (b/c the abstract methods are all public and non-final on a public and non-final class)<br></p><p>…which can be worked around if you keep all the *classes* module-internal and export, say, a public struct wrapper privately wrapping a class instance, but that’s getting pretty unwieldy and feels like it shouldn’t be necessary.<br></p><p>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>I think it *exposes* a significant problem, but I’m not sure the fix is right.<br></p><p>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br></p><p>It seems hard to fit into the rest of Swift in the details (e.g. the `init` issue, and the apparent lack of a satisfying way for the implementer to achieve a reasonable balance of visibility, overridability, and finality). <br></p><p>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>It seems broadly similar. <br></p><p>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Some thought, some observation of the discussion.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/c706e83f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 29, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 26.02.2016 um 22:51 schrieb plx via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Abstract classes and access control issues would need to be addressed. EG: is the below allowed, or not:<br>&gt; <br>&gt; abstract public class ClassWithInternalAbstractMembers {<br>&gt; <br>&gt;   // abstract members less visible than the containing type:<br>&gt;   internal abstract func someFunctionOnlyVisibleWithinThisModule()<br>&gt;   private abstract func someFunctionOnlyVisibleWithinThisFile()<br>&gt; <br>&gt; }<br></p><p>Of course, why not? This allows template methods (protected would be even more nice for those) which is an important use case for abstract classes IMO.<br></p><p>-Thorsten<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>February 26, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md&gt;<br>&gt; 	• What is your evaluation of the proposal?<br></p><p>-1.<br></p><p>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>The functionality (to allow greater composability of code) is significant enough to warrant a change in swift, but the actual implementation (via abstract classes) is not. I would prefer additional trait/mixin functionality.<br></p><p>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br></p><p>While Swift could use more functionality around mixin-like behavior and more sophisticated trait functionality, staying away from class inheritance more often than not results in better code.<br></p><p>Abstract base classes in particular have a strong tendency to become a composability anti-pattern, because you are not defining the behavior of the interacting objects but are requiring a specific form of implementation and specific, often undocumented side-effects.<br></p><p>As an example from the proposal:<br></p><p>The RESTClient abstract base class defined in the proposal has hard-coded a single URL. If I need multiple URLs (say, client side address randomization) then the behavior between var url and performNetworkCall is insufficient. It is likely that other code relying on RESTClient is using the base class name, and not some protocol, so my only hope for working with existing code is to figure out how to make my subclass behave properly when performNetworkCall is defined.<br></p><p>If I was working with RESTClient as a protocol, performNetworkCall would just be a required method to implement. I could choose to implement it however I want to. Because of the abstract base class, I need to worry about whether some other functionality in the base class I am forced to use for interoperability will conflict with my new definition. And of course, var url is still meaningless in my implementation, so I better just have it return a dummy value.<br></p><p>To be fair, RESTClient is a placeholder. It could be better designed if it were part of a system and not an example in a proposal. <br></p><p>However, this is the problem with abstract base classes - they always could be hypothetically designed better. Their goal is usually to provide some implementation details while allowing flexibility of a third party to extend with the actual functionality and behavior needed. But it is very difficult (perhaps impossible) to on one hand remain flexible while on the other hand dictate implementation details both as side effects required in your system and for convenience. Sure, abstract classes can always be better designed - when considered in retrospect. Thats because the author of the abstract class has gained experience and now understands some of the flexibility other developers required in implementation!<br></p><p>Better to define protocols, and provide implementations of those protocols based on the functionality you know people will need. Even more so if you can use traits to define behavior you commonly expect developers to need, such that they can take or leave such behaviors as they see fit.<br></p><p>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>In my professional experience, I have a tough time thinking of any abstract base class which I haven’t considered a poor design choice. That abstract base classes are often the simplest design choice makes me believe this feature would be abused.<br></p><p>Java is the language where I’ve hit the most abstract base class requirements. I have nothing to suggest be salvaged from there in this regard.<br></p><p>Ruby has both class inheritance and mix-in support, and both are used extensively. Class inheritance in Ruby is saved by late-bound typing - it is considered bad form to test that your code was given a specific type, instead encouraging either coercion of types or duck typing. Otherwise, the lack of protocols in the language would make developing code very difficult.<br></p><p>Design (including language design) is not just about what is there, but what is not. I feel promoting traits over abstract classes this is another opportunity for the Swift language to promote better code.<br></p><p>It is also worth noting that Objective-C does not support abstract classes, and this proposal did not attempt to define how that would be rectified as part of interoperability:<br>- Would abstract classes need also be defined in Objective-C?<br>- Does the entire hierarchy at and defending from the abstract class become un-exposable to Objective-C, or just the abstract classes themselves?<br>- If the initializable classes in the hierarchy are exposed to Objective-C, are the abstract classes exposed via e.g. +(Class) superclass; ?<br></p><p>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Participated in the discussion, in-depth study.<br></p><p>-DW<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/368f1ce1/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0026 Abstract classes and methods</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February 26, 2016 at 06:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Feb 26, 2016, at 1:11 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; 	• What is your evaluation of the proposal?<br></p><p>It seems that programming languages are evolving in a way that rely less on pure object-oriented concepts that previous languages, such as C++ and Java, have relied upon. The reasons for this derive from experience. Some concepts have proven problematic and introduced more problems over the long-term than they solve. Multiple inheritance is a good example of one of these concepts. In my opinion, abstract declarations represents another.<br></p><p>In addition, the examples provided by the proposal do not provide a strong argument in favor. It isn&#39;t difficult to see that there are better patterns that could have been employed to solve the problem illustrated by the example.<br></p><p>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>No.<br></p><p>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br></p><p>No.<br></p><p>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>More modern languages like Ruby and Python do not support abstract definitions. I like Swift because it draws from design patterns based in modern languages such as these. I&#39;d like to see Swift continue on the modern path.<br></p><p>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Read the proposal thorough and the original thread on which it was based.<br></p><p>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0026 Abstract classes and methods</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 29, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 27.02.2016 um 00:20 schrieb Patrick R. Gili via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Some concepts have proven problematic and introduced more problems over the long-term than they solve. Multiple inheritance is a good example of one of these concepts. In my opinion, abstract declarations represents another.<br></p><p>Actually multiple inheritance is not a good example as it<br>- never was implemented right except in Eiffel<br>- interfaces/protocols are widely presumed not to have the problems of multiple inheritance but in fact they do have just the same problems when two interfaces/protocols are implemented/conformed to, which have the same member but with different semantics (the diamond problem related to state has the exact same solution as the problem just mentioned, i.e. renaming)<br>- multiple inheritance is popping up in more and more languages, i.e. in Java with default implementations of interfaces, in Swift with protocol extensions, etc.<br></p><p>-Thorsten<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>February 26, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; What is your evaluation of the proposal?<br></p><p>In its current state: -1<br></p><p>I&#39;d love for the proposal to present clear examples of problems that exist in Swift that cannot be solved in any other way. The &quot;RESTClient&quot; example is overly simplistic and can be solved easily using POP:<br></p><p>    protocol RESTClient {<br>        var: url: String { get }<br>    }<br>    extension RESTClient {<br>        performNetworkCall() {<br>            // impl<br>        }<br>    }<br>    final class MyRestServiceClient: RESTClient {<br>        let url = &quot;http://www.foo.com/client&quot;<br>    }<br></p><p>In fact, the problem it presents doesn&#39;t even need POP:<br></p><p>    final class RESTClient {<br>        let url: String<br>        init(url: String) { self.url = url }<br>        performNetworkCall() { /* impl */ }<br>    }<br></p><p>If the proposal were to be updated with better examples that _cannot_ be solved without abstract classes, or at the very least cannot be solved without significant sacrifices to the quality of the code, I would reconsider it.<br></p><p>I believe the proposal would also need to be updated to address other unanswered questions brought up in this thread.<br></p><p>--<br>Stephen<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9ae1f2ed10d2ef77cce06bbb5a2dcf7e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0026 Abstract classes and methods</strong> from <string>Alex Hoppen</string> &lt;alex at ateamer.de&gt;<p>February 27, 2016 at 08:00:00am</p></header><div class="content"><p>+1 for the proposal.<br>As I said in the original discussion abstract classes allow you to override methods of existing classes, which protocols cannot do (and by definition will never be able to do). I think this is a major advantage that cannot be neglected.<br>To name an example: Without abstract classes there is no way to create NSOperations that perform preliminary setup (like checking dependencies, notifying observers, …) and call through to the actual operation’s implementation in between (I’m referring to the sample code of the Advanced NSOperation’s talk at last year’s WWDC, where Operation would have greatly benefitted from making the execute method abstract). <br>Sure, there are ways to work around this issue. As suggested several times you may define a delegate that does the actual operation’s work, which I don’t like because it a) defeats the concept of the operation performing the actual work, b) requires you to always think about two types (the operation and the delegate) when needing to override other methods of the actual operation and c) it does not make sense to create a raw (NS)Operation on its own. Alternatively there is the current way of doing it by creating a class that has a fatalError implementation but I guess nobody will argue that this is the right way to go. Or you may say that NSOperation should have been designed in another way so that it leverages protocols from the ground up. But it isn’t designed that way and there are huge amounts of code that were written before Swift introduced protocols and protocol extensions. I think from a point of interoperability it would simply be wrong to assume that this code does not exist.<br>Swift is a multi-paradigm programming language and POP isn’t the silver bullet that solves all our problems. IMO there are several use cases where abstract classes are the cleaner solution than a mix of protocols, extensions and classes (which have there use cases as well). It may, however, be beneficial to delay the introduction of abstract classes to Swift 4, so that people get more used to POP and see the benefits it brings with it and will not fall back to old (and maybe bad) patterns using abstract classes where POP would be the right way to go.<br></p><p>– Alex<br></p><p>&gt; On 26 Feb 2016, at 19:11, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of “Abstract classes and methods” begins now and runs through March 4, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	• What is your evaluation of the proposal?<br>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; -Joe<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/a1d92c77/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6c95cd06f79f91eaf9f58e4f1c50a25a?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Ondrej Barina</string> &lt;obarina at gmail.com&gt;<p>February 27, 2016 at 05:00:00pm</p></header><div class="content"><p>What is your evaluation of the proposal?<br></p><p>+1<br></p><p>Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.  Abstract methods and classes have its usage<br></p><p>Does this proposal fit well with the feel and direction of Swift?<br></p><p>yes<br></p><p>How much effort did you put into your review? A glance, a quick<br>reading, or an in-depth study?<br></p><p>I have read the whole discussion. (including draft)<br></p><p>Ondrej Barina<br></p><p>On Fri, Feb 26, 2016 at 7:11 PM, Joe Groff via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of “Abstract classes and methods” begins now and runs through<br>&gt; March 4, 2016. The proposal is available here:<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md<br>&gt;<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review<br>&gt; manager. When replying, please try to keep the proposal link at the top of<br>&gt; the message:<br>&gt;<br>&gt; Proposal link:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md<br>&gt;<br>&gt;<br>&gt; Reply text<br>&gt;<br>&gt;<br>&gt; Other replies<br>&gt;<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt;<br>&gt; • What is your evaluation of the proposal?<br>&gt; • Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?<br>&gt; • Does this proposal fit well with the feel and direction of Swift?<br>&gt; • If you have used other languages or libraries with a similar feature, how<br>&gt; do you feel that this proposal compares to those?<br>&gt; • How much effort did you put into your review? A glance, a quick reading,<br>&gt; or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at:<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Joe<br>&gt; Review Manager<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>February 28, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of “Abstract classes and methods” begins now and runs through March 4, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md<br>&gt; <br>&gt; 	• What is your evaluation of the proposal?<br></p><p>Positive.<br></p><p>Many voices here have a major bias for POP against OOP, and the Crusty character of the founding https://developer.apple.com/videos/play/wwdc2015/408/ session was indeed a very well-done marketing coup both in favor of POP, and against OOP.<br></p><p>Yet I think that code that uses abstract classes is not, per se, bad code which needs refactoring using POP. It’s just code that uses abstract classes, and it may have its (excellent) reasons.<br></p><p><br>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>I think so, for two reasons:<br></p><p>1. Many abstract classes exist in the wild, and they currently have to fallback to runtime errors like &quot;subclass must override&quot;. Compiler support would be a great bonus.<br></p><p>2. Protocol-based refactoring of abstract classes falls short because protocols miss three major features provided only by base classes: `super`, properties, and encapsulation of implementation details that allows easy refactoring of inner guts. For more details: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005755.html, https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005862.html.<br></p><p><br>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes it does, since Swift does provide class inheritance as a matter of fact, and fosters safety at the compile time.<br></p><p><br>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Other languages do not have the Swift protocols that are the main argument of opponents to abstract classes. So the comparison with other languages may be useless here.<br></p><p>Yet if Swift would support it, it could help a lot welcoming programmers that are familiar with other languages, and bring their OOP experience to the community.<br></p><p><br>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A quick reading of the proposal. It may be rough on some edges.<br></p><p>Gwendal Roué<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0026 Abstract classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>February 28, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; <br>&gt; 	• What is your evaluation of the proposal?<br></p><p>-1.  I would prefer to focus on protocol-oriented solutions which I believe are generally more robust.  I passionately dislike a requirement to subclass by libraries and frameworks and would prefer to guide the Swift community away from that approach.  Introducing abstract classes would do the opposite.<br></p><p>I would prefer to see the the generics and protocol-related features fully fleshed out in Swift 3 and Swift 4 and allow the community to identify approaches to design that do not rely on inheritance.  <br></p><p>If there remain use cases addressed by abstract classes for which we do not have an acceptable protocol-oriented alternative we could consider the feature again at that time with better knowledge of what use cases are uniquely addressed by the more brittle and inflexible inheritance-based approach.<br></p><p>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Maybe, but I am not convinced yet.  We should allow the language to evolve a bit more before making a final judgment about this.<br></p><p>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br></p><p>No.  It is a classic OO inheritance feature and Swift leans heavily in the direction of protocols.<br></p><p>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>It is about the same, including the all downsides of library designs that require subclassing by consumers.  <br></p><p>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A brief glance.  However, my review is informed by lots of experience with both implementing and using libraries and frameworks that require subclassing (including use of abstract classes).  This experience has taught me that it is generally best to look for other solutions.<br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; -Joe<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/ae3db52c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/698e94ec61aae18a4cae067ad645b3fb?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Jeremy W. Sherman</string> &lt;jeremyw.sherman at gmail.com&gt;<p>February 28, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; El 26 feb 2016, a las 13:11, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; escribió:<br></p><p>This is a review of [SE-0026 &quot;Abstract classes and methods&quot;.](https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md) &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md&gt;<br></p><p>I am **against** the acceptance of this proposal:<br></p><p>- It lacks a clear problem.<br>- The leap from a nebulous problem to abstract classes as the solution is a *non sequitur.*<br>- Its arguments are insufficient to justify the complication it would add to Swift, which is contrary the simplification and clarification aims of the Swift community.<br></p><p>The contrast is sharpened by comparison to the Python Enhancement Proposal that accompanied the introduction of abstract base class into Python. The present proposal fails to provide a correspondingly thoughtful rationale.<br></p><p><br>## No Clear Problem<br>The proposal itself does little to define a practical problem, and less to explain how abstract classes solve this problem better than alternatives. It feels like a solution in want of a problem, which is the opposite of a considered addition to the language.<br></p><p>As best I can determine, the primary problem introduced is that of wanting to have abstract properties. The example given is better resolved by providing the `url` as a constructor argument, as [noted by Stephen Celis.](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160222/011207.html) &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160222/011207.html&gt; Further, the immediate solution appears to be to argue in favor of [uniform access](https://en.wikipedia.org/wiki/Uniform_access_principle) &lt;https://en.wikipedia.org/wiki/Uniform_access_principle&gt; as found in Self and Eiffel, not abstract base classes, which compound non-uniform access by a further serving of complexity.<br></p><p>Another problem mentioned is lack of easy delegation of implementation in the context of protocols; providing a simple way to proxy calls to another object would present a promising and useful avenue for resolving this problem that would also compose more generally with the rest of the language. `NSProxy` has always been somewhat awkward in this regard; perhaps we can do better in Swift?<br></p><p><br>## No Clear Significance<br>Without a clear problem to address, it becomes difficult to evaluate the significance of the problem.<br></p><p>Ultimately, it&#39;s unclear precisely what the problem under consideration is, unless the problem is stated simply as, &quot;Swift doesn&#39;t have abstract base classes.&quot; If that is the true problem considered to address, then it seems especially insignificant; Swift also lacks good support for relational programming à la mini-kanren, but a difference does not a problem make.<br></p><p>If we focus on &quot;no abstract classes&quot; as the problem, then the problem appears insignificant: Smalltalk and Objective-C have both made do without formal support for abstract classes. Objective-C went so far as to remove `subclassResponsibility` from the common language vocabulary, which eliminated all inbuilt support for abstract classes. Never have I heard either Smalltalker or Obj-C hacker end up despondent and cursing over the lack of built-in abstract class support in these languages.<br></p><p><br>## Compared to Python&#39;s Rationale for Adding Abstract Classes<br>It is interesting to consider the motivation for adding abstract base class support to Python as explained in [PEP 3119](https://www.python.org/dev/peps/pep-3119/). &lt;https://www.python.org/dev/peps/pep-3119/&gt;<br></p><p>In Python&#39;s case, the decision was motivated by the desire for a reliable means to test particularly for some shared quality of a group of objects - basically, a reliable `respondsToSelector:` or `isKindOfClass:` that allows detecting this quality without incidental risk of false positives or negatives ([&quot;Rationale&quot;](https://www.python.org/dev/peps/pep-3119/#rationale) &lt;https://www.python.org/dev/peps/pep-3119/#rationale&gt;).<br></p><p>As a result, Python adopted abstract base classes as an alternative to interfaces ([&quot;ABCs vs. Interfaces&quot;](https://www.python.org/dev/peps/pep-3119/#abcs-vs-interfaces) &lt;https://www.python.org/dev/peps/pep-3119/#abcs-vs-interfaces&gt;). But Swift already has interfaces in the form of protocols; this answers the need that motivated the addition of abstract base classes to Swift.<br></p><p>Because we cannot borrow the rationale used for adding abstract base classes to Python, and the document before us spends its effort explaining abstract base classes rather than the problem they would solve, it remains for those arguing for the added formal complexity of abstract base classes to motivate their addition in the context of Swift. The current proposal is manifestly lacking in this regard.<br></p><p><br># Out of Alignment with Swift<br>Adding abstract class support to Swift seems unprincipled. I cannot see what problem would be solved, and Swift is working towards considered language growth, and even better, language contraction, at this point in time. Adding abstract base classes would feel like nodding to feature agglutination by cargo cult, not the careful evolution we aspire to.<br></p><p><br># Effort<br>I read the article and then looked at the arguments in favor of supporting abstract base classes in Python for comparison. I would love to see a rationale as tailored to Swift and to real problems as PEP 3119 was to Python and its programmers&#39; problems! In Python&#39;s case, &quot;[m]uch of the thinking that went into the proposal [was] not about the specific mechanism of ABCs, as contrasted with Interfaces or Generic Functions (GFs), but about clarifying philosophical issues…&quot; This sort of laborious semantic work is a necessary accompaniment to any significant proposed changes to an object system, and that thought is unfortunately not apparent in this proposal.<br></p><p><br>--<br>Jeremy W. Sherman<br>https://jeremywsherman.com/ &lt;https://jeremywsherman.com/&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/4bbacf9b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0026 Abstract classes and methods</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 29, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md<br>&gt; <br>&gt; 	• What is your evaluation of the proposal?<br></p><p>-1.<br></p><p>Swift already has a means to create abstract types; we call them &quot;protocols&quot;. Protocols cannot yet do all of the things that abstract classes can. But I think we would be better served by enhancing protocols to fill these gaps, rather than creating a parallel construct which muddies the conceptual simplicity of our current classes.<br></p><p>I believe the missing functionality would include:<br></p><p>1. Being able to constrain a protocol so that conforming types must inherit from a particular class.<br>2. Being able to use `override` and `super` in a protocol extension as long as the protocol has a must-inherit requirement ensuring the relevant member exists.<br>3. Being able to declare stored properties in protocol extensions, as long as they were declared in the same module as the protocol.<br></p><p>Three more things would be nice-to-haves:<br></p><p>4. Being able to declare conformance only to the protocol in a class, and have the required inheritance be implied.<br>4. Being able to add static members which could be called on the protocol itself, not just types conforming to it.<br>5. Being able to add factory initializers to the protocol which could initialize any conforming type.<br></p><p>With these six features in place, I believe Corelibs Foundation could implement its class clusters (NSArray et.al.) as protocols constrained to subclass NSObject, and clients of both libraries could be source-compatible.<br></p><p>I see the following benefits in going with protocols:<br></p><p>* Draws a bright line between abstract and concrete types.<br>* Required language changes are incremental.<br>* No problems with private abstract members of public types; all protocol requirements are already as public as the protocol itself.<br>* Allows for more flexible application (e.g. `UITextField` can conform to `protocol TextualView: UIView` even though it&#39;s actually a grandchild class of `UIView`).<br></p><p>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. Just not *this* change.<br></p><p>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br></p><p>No, I don&#39;t think so. Currently Swift draws a bright line between concrete and abstract types: protocols are abstract and all other types are concrete. Allowing abstract classes would blur this distinction.<br></p><p>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I have used abstract classes, but only in languages with an &quot;everything is a class&quot; approach. I always found them clumsy and wished for something better.<br></p><p>I have also used languages (including Objective-C) with no effective solution to the problem abstract classes attempt to solve other than the equivalent of `fatalError(&quot;not implemented&quot;)`. That sucked too. I quite agree with the desire to find a solution to this problem.<br></p><p>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I have read the proposal and all prior reviews, and participated in pre-proposal discussions.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0026 Abstract classes and methods</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March  1, 2016 at 07:00:00am</p></header><div class="content"><p>Am 01.03.2016 um 01:37 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md<br>&gt;&gt; <br>&gt;&gt;    • What is your evaluation of the proposal?<br>&gt; <br>&gt; -1.<br>&gt; <br>&gt; Swift already has a means to create abstract types; we call them &quot;protocols&quot;. Protocols cannot yet do all of the things that abstract classes can. But I think we would be better served by enhancing protocols to fill these gaps, rather than creating a parallel construct which muddies the conceptual simplicity of our current classes.<br></p><p>I&#39;m all for enhancing protocols.<br></p><p><br>&gt; I believe the missing functionality would include:<br>&gt; <br>&gt; 1. Being able to constrain a protocol so that conforming types must inherit from a particular class.<br>&gt; 2. Being able to use `override` and `super` in a protocol extension as long as the protocol has a must-inherit requirement ensuring the relevant member exists.<br></p><p>Just a note: This would require naming the concrete super protocol to use, because multiple parents might provide the relevant member (and by virtue of protocol extensions they might even gain this member after the fact of defining the protocol containing the super call). Knowing which super to call is the advantage of and reason for the restriction to single inheritance when deriving from a parent class. <br></p><p><br>&gt; 3. Being able to declare stored properties in protocol extensions, as long as they were declared in the same module as the protocol.<br></p><p>That would be nice.<br></p><p><br>&gt; Three more things would be nice-to-haves:<br>&gt; <br>&gt; 4. Being able to declare conformance only to the protocol in a class, and have the required inheritance be implied.<br></p><p>Sorry, I don&#39;t understand that.<br></p><p><br>&gt; 4. Being able to add static members which could be called on the protocol itself, not just types conforming to it.<br>&gt; 5. Being able to add factory initializers to the protocol which could initialize any conforming type.<br></p><p>That would be an important requirement as soon as protocols can contain properties.<br></p><p>I&#39;m missing an important feature in your list: being able to declare protocol members with access scopes different from that of the protocol, i.e. private or internal in a public protocol.<br>This is a very important requirement for something like template methods.<br></p><p>Another important feature quite related to that is a &quot;protected&quot; scope.<br></p><p><br>&gt; With these six features in place, I believe Corelibs Foundation could implement its class clusters (NSArray et.al.) as protocols constrained to subclass NSObject, and clients of both libraries could be source-compatible.<br>&gt; <br>&gt; I see the following benefits in going with protocols:<br>&gt; <br>&gt; * Draws a bright line between abstract and concrete types.<br>&gt; * Required language changes are incremental.<br>&gt; * No problems with private abstract members of public types; all protocol requirements are already as public as the protocol itself.<br></p><p>That is a marked disadvantage which prohibits defining partial behavior which is filled in by concrete types!<br>If protocols should remain like that then that alone is a decisive argument for adding abstract classes.<br></p><p>-Thorsten <br></p><p><br>&gt; * Allows for more flexible application (e.g. `UITextField` can conform to `protocol TextualView: UIView` even though it&#39;s actually a grandchild class of `UIView`).<br>&gt; <br>&gt;&gt;    • Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes. Just not *this* change.<br>&gt; <br>&gt;&gt;    • Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; No, I don&#39;t think so. Currently Swift draws a bright line between concrete and abstract types: protocols are abstract and all other types are concrete. Allowing abstract classes would blur this distinction.<br>&gt; <br>&gt;&gt;    • If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; I have used abstract classes, but only in languages with an &quot;everything is a class&quot; approach. I always found them clumsy and wished for something better.<br>&gt; <br>&gt; I have also used languages (including Objective-C) with no effective solution to the problem abstract classes attempt to solve other than the equivalent of `fatalError(&quot;not implemented&quot;)`. That sucked too. I quite agree with the desire to find a solution to this problem.<br>&gt; <br>&gt;&gt;    • How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I have read the proposal and all prior reviews, and participated in pre-proposal discussions.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0026 Abstract classes and methods</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>March  1, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Le 1 mars 2016 à 07:08, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I&#39;m missing an important feature in your list: being able to declare protocol members with access scopes different from that of the protocol, i.e. private or internal in a public protocol.<br>&gt; This is a very important requirement for something like template methods.<br>&gt; <br>&gt; Another important feature quite related to that is a &quot;protected&quot; scope.<br>&gt; <br>&gt; […]<br>&gt; <br>&gt;&gt; * No problems with private abstract members of public types; all protocol requirements are already as public as the protocol itself.<br>&gt; <br>&gt; That is a marked disadvantage which prohibits defining partial behavior which is filled in by concrete types!<br>&gt; If protocols should remain like that then that alone is a decisive argument for adding abstract classes.<br>&gt; <br>&gt; -Thorsten<br></p><p>I 100% support this point. Today all declarations in a protocol are as public as the protocol itself. Only &quot;abstract classes&quot;, as known from languages that support this concept, are able to hide some implementation details.<br></p><p>As long as protocols keep &quot;flat&quot; access control, there will be a need for abstract classes, the ready-made concept that already provides data hiding and encapsulation.<br></p><p>Gwendal<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0026 Abstract classes and methods</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  1, 2016 at 02:00:00am</p></header><div class="content"><p>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md<br></p><p>&gt;&gt; 2. Being able to use `override` and `super` in a protocol extension as long as the protocol has a must-inherit requirement ensuring the relevant member exists.<br>&gt; <br>&gt; Just a note: This would require naming the concrete super protocol to use, because multiple parents might provide the relevant member (and by virtue of protocol extensions they might even gain this member after the fact of defining the protocol containing the super call). Knowing which super to call is the advantage of and reason for the restriction to single inheritance when deriving from a parent class. <br></p><p>I think you&#39;re talking about this problem:<br></p><p>	  1&gt; protocol A {}; extension A { func foo() { print(&quot;A&quot;) } }<br>	  2&gt; protocol B {}; extension B { func foo() { print(&quot;B&quot;) } } <br>	  3&gt; struct X: A, B {}<br>	  4&gt; X().foo()<br>	repl.swift:4:1: error: ambiguous use of &#39;foo()&#39;<br></p><p>That&#39;s not really related to the point above, which is about allowing protocol extensions to override superclass members.<br></p><p>	protocol ActivityViewControlling: UIViewController {<br>		...<br>	}<br>	extension ActivityViewController {<br>		override func viewWillAppear(animated: Bool) {<br>			super.viewWillAppear(animated)<br>			...<br>		}<br>	}<br></p><p>However, handling conflicts between protocol extensions with identically-named members *is* an issue with protocols in general. I think we should look into that as a problem with protocols as a whole, rather than thinking of it as something specific to this proposal.<br></p><p>&gt;&gt; 4. Being able to declare conformance only to the protocol in a class, and have the required inheritance be implied.<br>&gt; <br>&gt; Sorry, I don&#39;t understand that.<br></p><p>That simply means that, instead of saying this:<br></p><p>	class MyActivityViewController: UIViewController, ActivityViewControlling {<br>		...<br>	}<br></p><p>It&#39;d be nice if you could say this:<br></p><p>	class MyActivityViewController: ActivityViewControlling {<br>		...<br>	}<br></p><p>And have the inheritance from UIViewController be implied.<br></p><p>&gt;&gt; 5. Being able to add factory initializers to the protocol which could initialize any conforming type.<br>&gt; <br>&gt; That would be an important requirement as soon as protocols can contain properties.<br></p><p>Factory initializers are actually not related to properties. They&#39;re more about encapsulating the selection of a concrete implementation—basically, they&#39;re for patterns like class clusters.<br></p><p>	extension ActivityViewControlling {<br>		factory init(userInterfaceIdiom: UIUserInterfaceIdiom) {<br>			switch userInterfaceIdiom {<br>			case .Phone:<br>				self = PhoneActivityViewController()<br>			case .TV:<br>				self = TVActivityViewController()<br>			default:<br>				self = PadActivityViewController()<br>		}<br>	}<br></p><p>There will probably need to be a way to initialize stored properties—particularly private ones—added by extensions, but this is also necessary for allowing stored properties in concrete type extensions, so we can reuse whatever mechanism we end up with there.<br></p><p>&gt; I&#39;m missing an important feature in your list: being able to declare protocol members with access scopes different from that of the protocol, i.e. private or internal in a public protocol.<br></p><p>Extension methods can always have different access control scopes from the protocol as a whole. The required/abstract methods are a different story, but I&#39;ll get into that later.<br></p><p>&gt; Another important feature quite related to that is a &quot;protected&quot; scope.<br></p><p>Let&#39;s keep the simultaneously open cans of worms to a minimum.<br></p><p>&gt;&gt; * No problems with private abstract members of public types; all protocol requirements are already as public as the protocol itself.<br>&gt; <br>&gt; That is a marked disadvantage which prohibits defining partial behavior which is filled in by concrete types!<br>&gt; If protocols should remain like that then that alone is a decisive argument for adding abstract classes.<br></p><p>This is actually an issue with both approaches. You cannot conform to a protocol/inherit from an abstract class unless you fulfill all of the requirements/implement all of the abstract members. This implies that all of those required/abstract members must be visible to any code which can conform/inherit.<br></p><p>In fact, this situation is actually slightly *better* for protocols, because you can always make a protocol more private than its concrete conforming types; the relationship between those types just won&#39;t be visible. A subclass, on the other hand, cannot be more visible than its superclass, so you have to make abstract superclasses and their abstract members fully visible.<br></p><p>This issue can be solved by allowing you to make a protocol/class more visible than the ability to conform to/inherit from it (basically, the &quot;sealed&quot; proposal that has come out of the resilience work); then you could give each requirement/abstract member a visibility anywhere between the ability to conform and the ability to see the type.<br></p><p>But in any case, this is an issue for both constructs; I don&#39;t think it should cause us to prefer one of them over the other.<br></p><p>***<br></p><p>Actually, that reminds me that there&#39;s another, more procedural, reason we should reject SE-0026: The proposal is woefully incomplete, more of a sketch than a detailed plan ready to be implemented.<br></p><p>Technical gaps:<br></p><p>1. The aforementioned visibility concern. Can abstract members be less visible than the type they belong to? If so, what does that mean for the visibility of abstract classes and their subclasses?<br>2. Who is responsible for initializing an abstract stored property: the parent class or the child? Only the child knows it&#39;s stored, but the parent might need a particular initial value. Perhaps it&#39;s the child&#39;s responsibility unless the parent explicitly says it will initialize the value? How would it say so?<br>3. How does abstractness interact with resiliency? Can abstract members become non-abstract? Can an abstract class become concrete?<br>4. Can you have abstract `let`s? How about `subscript`s? `init`s? A `deinit`? Class members? Any other kinds of members I might have forgotten?<br>5. Can you have partially-abstract properties? For instance, can you have a property with a concrete getter and an abstract setter? Or concrete accessors but abstract observers?<br>6. Can abstract classes have associated types? That would be a powerful feature, but it would open a whole &#39;nother can of worms.<br>7. If you can have abstract inits, can you also have concrete inits which initialize the class&#39;s concrete stored properties? What are the inheritance rules for them?<br>8. Can you nest types inside of abstract classes? Can those types themselves be abstract? If so, would concrete classes have to implement those types? What if you want them to be value types?<br></p><p>Proposal justification gaps:<br></p><p>9. Why is `override` used when you&#39;re implementing abstract members? They&#39;re not overriding anything.<br>10. What&#39;s the purpose of abstract `willSet`/`didSet`? <br>11. As several other reviews have lamented, there are no particularly good use cases in the proposal.<br>12. There is no in-depth exploration of alternative approaches. (This would be much easier to do if we had use cases; then we could look at how alternatives would fare.)<br></p><p>I really think that this review has only two reasonable outcomes: reject because we don&#39;t want the feature, or reject because the proposal still needs more work. SE-0026 is just not ready for prime time.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0026 Abstract classes and methods</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>March  1, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; Le 1 mars 2016 à 11:29, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; I&#39;m missing an important feature in your list: being able to declare protocol members with access scopes different from that of the protocol, i.e. private or internal in a public protocol.<br>&gt; <br>&gt; Extension methods can always have different access control scopes from the protocol as a whole. The required/abstract methods are a different story, but I&#39;ll get into that later.<br></p><p>Don’t you go too fast? Methods declared in protocol extensions are very different from methods declared inside the protocol: they are not dynamically dispatched.<br></p><p>I, too, am concerned about the flat world of protocols&#39; access control.<br></p><p>Gwendal<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0026 Abstract classes and methods</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>March  1, 2016 at 02:00:00pm</p></header><div class="content"><p>I really dislike the fact that default methods implemented in a protocol extension are statically dispatched by default... An optimisation which can have confusing side effects should be programmer driven not automagically applied, but we are going off topic I guess ;).<br></p><p>Sent from my iPhone<br></p><p>&gt; On 1 Mar 2016, at 12:13, Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; Le 1 mars 2016 à 11:29, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m missing an important feature in your list: being able to declare protocol members with access scopes different from that of the protocol, i.e. private or internal in a public protocol.<br>&gt;&gt; <br>&gt;&gt; Extension methods can always have different access control scopes from the protocol as a whole. The required/abstract methods are a different story, but I&#39;ll get into that later.<br>&gt; <br>&gt; Don’t you go too fast? Methods declared in protocol extensions are very different from methods declared inside the protocol: they are not dynamically dispatched.<br>&gt; <br>&gt; I, too, am concerned about the flat world of protocols&#39; access control.<br>&gt; <br>&gt; Gwendal<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>March  4, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 26 Feb 2016, at 19:11, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 	• What is your evaluation of the proposal?<br></p><p>-1. I&#39;m strongly against this proposal because they are already language features that provide similar benefits. Even if Swift is a multi-paradigm language, it has always meshed together orthogonal concepts: functional + oop + systems. Whereas in a his case, the proposal suggests adding a different syntax for something that can almost be completely expressed with protocols and protocol extensions.<br></p><p>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>As POP can already provide similar behaviour without subclassing, I&#39;d say the problem is pretty much non-existent.<br></p><p>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br></p><p>No. I believe it goes contrary to the philosophy and paradigms of Swift as I understand them.<br></p><p>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Yes, Java and C#. Abstract classes were useful in those languages, but fairly rarely used (as far as I&#39;m concerned). And we now have protocol extensions to do the same.<br></p><p>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>In-depth reading, followed he discussion.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>March  4, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 26 Feb 2016, at 19:11, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;    • What is your evaluation of the proposal?<br></p><p>-1. I&#39;m strongly against this proposal because they are already language features that provide similar benefits. Even if Swift is a multi-paradigm language, it has always meshed together orthogonal concepts: functional + oop + systems. Whereas in a his case, the proposal suggests adding a different syntax for something that can almost be completely expressed with protocols and protocol extensions.<br></p><p>&gt;    • Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>As POP can already provide similar behaviour without subclassing, I&#39;d say the problem is pretty much non-existent.<br></p><p>&gt;    • Does this proposal fit well with the feel and direction of Swift?<br></p><p>No. I believe it goes contrary to the philosophy and paradigms of Swift as I understand them.<br></p><p>&gt;    • If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Yes, Java and C#. Abstract classes were useful in those languages, but fairly rarely used (as far as I&#39;m concerned). And we now have protocol extensions to do the same.<br></p><p>&gt;    • How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>In-depth reading, followed he discussion.<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/21db42f6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d30e546d655d1c7ece0464791a9a90d5?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Adrian Kashivskyy</string> &lt;adrian.kashivskyy at me.com&gt;<p>March  4, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; What is your evaluation of the proposal?<br></p><p>-1. While I believe abstract methods can be a great addition for dealing with contract-like constructs in object-oriented languages, they seem out-of-place in Swift, which is a protocol-oriented language. Adding abstract methods to Swift would encourage lazy developers to use them instead of protocols and value types. <br></p><p>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt; Does this proposal fit well with the feel and direction of Swift?<br></p><p>No. I believe it doesn&#39;t fit well in the direction Swift is taking.<br></p><p>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Yes, PHP. While I must say that abstract classes and methods were a common and powerful tool in PHP, they do not fit well in Swift, which offers a much more powerful alternative – protocols.<br></p><p>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A quick reading of the proposal document.<br></p><p><br>Pozdrawiam – Regards,<br>Adrian Kashivskyy<br></p><p>&gt; Wiadomość napisana przez Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; w dniu 26.02.2016, o godz. 19:11:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of “Abstract classes and methods” begins now and runs through March 4, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0026-abstract-classes-and-methods.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	• What is your evaluation of the proposal?<br>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; -Joe<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/86055521/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>March 29, 2016 at 03:00:00pm</p></header><div class="content"><p>I love protocols as much as the next guy, but if the problem I&#39;m solving requires a hierarchy of<br></p><p>RubyInterpreter<br>SystemRubyInterpreter<br>HomebrewRubyInterpreter<br>RVMRubyInterpreter<br></p><p>then thank you, but no, I&#39;ll prefer to stick to the most simple and clear solution (an abstract class). Yes, I can turn that into a protocol with extensions, supercharged with some extra features we don&#39;t currently have. But why on earth would I want to?<br></p><p>There are no benefits to be had from a protocol here.<br></p><p>Things won&#39;t get more clear or readable.<br></p><p>Everyone in the world understands simple hierarchies.<br></p><p>Yes, it&#39;s a wrong modeling tool conceptually, but it&#39;s a very simple and practical one. Sometimes the problem doesn&#39;t call for anything else.<br></p><p>So many people will continue to prefer simple class hierarchies in these cases. Let us be clear about what we&#39;re choosing from here.<br></p><p>Our choice is between fatalError(&quot;Must override&quot;) and a keyword that makes that clear. I&#39;ll take a keyword any day, but if you deny me, I&#39;ll go on using fatalError.<br></p><p>But please don&#39;t live in a fantasy world where, due to lack of SE-0026, I switch to protocols for those very simple and isolated cases, unless you can demonstrate the benefits for those specific cases. Please do not be so high-handed.<br></p><p>A.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/2676bfc8/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
