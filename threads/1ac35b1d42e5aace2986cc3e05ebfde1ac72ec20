<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 28, 2015 at 03:00:00pm</p></header><div class="content"><p>## Introduction<br></p><p>Add a few more functional sequence utilities to the standard library.<br></p><p>## Motivation<br></p><p>We have map, filter, and reduce, but we&#39;re missing a bunch of useful utilities like scan, iterate, takeWhile, and dropWhile. Interestingly, the stdlib includes an implementation of scan in the doc comment for LazySequenceType, it just doesn&#39;t actually provide it as API.<br></p><p>## Proposed solution<br></p><p>We extend SequenceType with 3 new methods scan, takeWhile, and dropWhile. We also add a single global function iterate.<br></p><p>## Detailed design<br></p><p>We add the following extension to SequenceType:<br></p><p>extension SequenceType {<br>    func scan&lt;T&gt;(initial: T, @noescape combine: (T, Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T]<br>    func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>    func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>}<br></p><p>These all take functions, so to follow convention they&#39;re @noescape and return arrays. We also provide an extension of CollectionType that overrides a couple of these methods:<br></p><p>extension CollectionType {<br>    func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.SubSequence<br>    func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.SubSequence<br>}<br></p><p>We also provide lazy versions:<br></p><p>extension LazySequenceType {<br>    func scan&lt;T&gt;(initial: T, combine: (T, Self.Generator.Element) -&gt; T) -&gt; LazyScanSequence&lt;Self.Elements, T&gt;<br>    func dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyDropWhileSequence&lt;Self.Elements&gt;<br>    func takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyTakeWhileSequence&lt;Self.Elements&gt;<br>}<br></p><p>extension LazyCollectionType {<br>    func dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyDropWhileCollection&lt;Self.Elements&gt;<br>    func takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyTakeWhileCollection&lt;Self.Elements&gt;<br>}<br></p><p>No collection variant of scan is provided because that would require storing the last value in the index itself, which would cause problems if the combine function isn&#39;t pure.<br></p><p>LazyDropWhileCollection would behave similarly to LazyFilterCollection in that it runs the predicate against the elements to drop when accessing startIndex; unlike LazyFilterCollection, because there&#39;s nothing else to skip after that point, the index itself can actually be Self.Elements.Index (just like a slice). LazyTakeWhileCollection also runs the predicate against the first element when accessing startIndex, but it does need a unique index type (because endIndex has to be some sentinel value, as it doesn&#39;t know where the end is until you reach that point; this index type would therefore only conform to ForwardIndexType).<br></p><p>And finally, we provide a global function<br></p><p>func iterate&lt;T&gt;(initial: T, _ f: T -&gt; T) -&gt; IterateSequence&lt;T&gt;<br></p><p>This function is inherently lazy and yields an infinite list of nested applications of the function, so iterate(x, f) yields a sequence like [x, f(x), f(f(x)), ...].<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>December 29, 2015 at 10:00:00pm</p></header><div class="content"><p>Consider this:<br></p><p>extension CollectionType where Generator.Element : Equatable {<br></p><p>    /// Returns a subsequence, until a element equal to `value`, containing<br>the<br>    /// initial elements.<br>    ///<br>    /// If none of elements equal to `value`, the result contains all<br>    /// the elements of `self`.<br>    ///<br>    /// - Complexity: O(`self.count`)<br>    @warn_unused_result<br>    public func prefixUntil(element: Self.Generator.Element) -&gt;<br>Self.SubSequence {<br>        return self.prefixUpTo(self.indexOf(element) ?? self.endIndex)<br>    }<br>}<br></p><p><br>extension CollectionType {<br></p><p>    /// Returns a subsequence, until a element satisfying the predicate,<br>containing the<br>    /// initial elements.<br>    ///<br>    /// If none of elements satisfying the predicate, the result contains<br>all<br>    /// the elements of `self`.<br>    ///<br>    /// - Complexity: O(`self.count`)<br>    @warn_unused_result<br>    public func prefixUntil(@noescape predicate: (Self.Generator.Element)<br>throws -&gt; Bool) rethrows -&gt; Self.SubSequence {<br>        return self.prefixUpTo(try self.indexOf(predicate) ?? self.endIndex)<br>    }<br>}<br></p><p><br>extension CollectionType where Generator.Element : Equatable, Index :<br>BidirectionalIndexType {<br>    /// Returns a subsequence, until a element equal to `value`, containing<br>the<br>    /// final elements of `self`.<br>    ///<br>    /// If none of elements equal to `value`, the result contains all<br>    /// the elements of `self`.<br>    ///<br>    /// - Complexity: O(`self.count`)<br>    @warn_unused_result<br>    public func suffixUntil(element: Self.Generator.Element) -&gt;<br>Self.SubSequence {<br>        return self.suffixFrom(self.reverse().indexOf(element)?.base ??<br>self.startIndex)<br>    }<br>}<br></p><p><br>extension CollectionType where Index : BidirectionalIndexType {<br>    /// Returns a subsequence, until a element satisfying the predicate,<br>containing the<br>    /// final elements of `self`.<br>    ///<br>    /// If none of elements satisfying the predicate, the result contains<br>all<br>    /// the elements of `self`.<br>    ///<br>    /// - Complexity: O(`self.count`)<br>    @warn_unused_result<br>    public func suffixUntil(@noescape predicate: (Self.Generator.Element)<br>throws -&gt; Bool) rethrows -&gt; Self.SubSequence {<br>        return self.suffixFrom(try self.reverse().indexOf(predicate)?.base<br>?? self.startIndex)<br>    }<br>}<br></p><p>and here are my<br>utilities:https://github.com/SusanDoggie/Doggie/blob/master/Doggie/Foundation.swift<br></p><p><br>Kevin Ballard &lt;kevin at sb.org&gt; 於 2015年12月29日 上午7:59 寫道：<br></p><p>## Introduction<br></p><p>Add a few more functional sequence utilities to the standard library.<br></p><p>## Motivation<br></p><p>We have map, filter, and reduce, but we&#39;re missing a bunch of useful<br>utilities like scan, iterate, takeWhile, and dropWhile. Interestingly, the<br>stdlib includes an implementation of scan in the doc comment for<br>LazySequenceType, it just doesn&#39;t actually provide it as API.<br></p><p>## Proposed solution<br></p><p>We extend SequenceType with 3 new methods scan, takeWhile, and dropWhile.<br>We also add a single global function iterate.<br></p><p>## Detailed design<br></p><p>We add the following extension to SequenceType:<br></p><p>extension SequenceType {<br>   func scan&lt;T&gt;(initial: T, @noescape combine: (T, Self.Generator.Element)<br>throws -&gt; T) rethrows -&gt; [T]<br>   func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt;<br>Bool) rethrows -&gt; [Self.Generator.Element]<br>   func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt;<br>Bool) rethrows -&gt; [Self.Generator.Element]<br>}<br></p><p>These all take functions, so to follow convention they&#39;re @noescape and<br>return arrays. We also provide an extension of CollectionType that<br>overrides a couple of these methods:<br></p><p>extension CollectionType {<br>   func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt;<br>Bool) rethrows -&gt; Self.SubSequence<br>   func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt;<br>Bool) rethrows -&gt; Self.SubSequence<br>}<br></p><p>We also provide lazy versions:<br></p><p>extension LazySequenceType {<br>   func scan&lt;T&gt;(initial: T, combine: (T, Self.Generator.Element) -&gt; T) -&gt;<br>LazyScanSequence&lt;Self.Elements, T&gt;<br>   func dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>LazyDropWhileSequence&lt;Self.Elements&gt;<br>   func takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>LazyTakeWhileSequence&lt;Self.Elements&gt;<br>}<br></p><p>extension LazyCollectionType {<br>   func dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>LazyDropWhileCollection&lt;Self.Elements&gt;<br>   func takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>LazyTakeWhileCollection&lt;Self.Elements&gt;<br>}<br></p><p>No collection variant of scan is provided because that would require<br>storing the last value in the index itself, which would cause problems if<br>the combine function isn&#39;t pure.<br></p><p>LazyDropWhileCollection would behave similarly to LazyFilterCollection in<br>that it runs the predicate against the elements to drop when accessing<br>startIndex; unlike LazyFilterCollection, because there&#39;s nothing else to<br>skip after that point, the index itself can actually be Self.Elements.Index<br>(just like a slice). LazyTakeWhileCollection also runs the predicate<br>against the first element when accessing startIndex, but it does need a<br>unique index type (because endIndex has to be some sentinel value, as it<br>doesn&#39;t know where the end is until you reach that point; this index type<br>would therefore only conform to ForwardIndexType).<br></p><p>And finally, we provide a global function<br></p><p>func iterate&lt;T&gt;(initial: T, _ f: T -&gt; T) -&gt; IterateSequence&lt;T&gt;<br></p><p>This function is inherently lazy and yields an infinite list of nested<br>applications of the function, so iterate(x, f) yields a sequence like [x,<br>f(x), f(f(x)), ...].<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/0ac2c88d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 29, 2015 at 10:00:00pm</p></header><div class="content"><p>+1<br></p><p>-Thorsten<br></p><p>&gt; Am 29.12.2015 um 00:59 schrieb Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; Add a few more functional sequence utilities to the standard library.<br>&gt; <br>&gt; ## Motivation<br>&gt; <br>&gt; We have map, filter, and reduce, but we&#39;re missing a bunch of useful utilities like scan, iterate, takeWhile, and dropWhile. Interestingly, the stdlib includes an implementation of scan in the doc comment for LazySequenceType, it just doesn&#39;t actually provide it as API.<br>&gt; <br>&gt; ## Proposed solution<br>&gt; <br>&gt; We extend SequenceType with 3 new methods scan, takeWhile, and dropWhile. We also add a single global function iterate.<br>&gt; <br>&gt; ## Detailed design<br>&gt; <br>&gt; We add the following extension to SequenceType:<br>&gt; <br>&gt; extension SequenceType {<br>&gt;    func scan&lt;T&gt;(initial: T, @noescape combine: (T, Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt;    func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt;    func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt; }<br>&gt; <br>&gt; These all take functions, so to follow convention they&#39;re @noescape and return arrays. We also provide an extension of CollectionType that overrides a couple of these methods:<br>&gt; <br>&gt; extension CollectionType {<br>&gt;    func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.SubSequence<br>&gt;    func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.SubSequence<br>&gt; }<br>&gt; <br>&gt; We also provide lazy versions:<br>&gt; <br>&gt; extension LazySequenceType {<br>&gt;    func scan&lt;T&gt;(initial: T, combine: (T, Self.Generator.Element) -&gt; T) -&gt; LazyScanSequence&lt;Self.Elements, T&gt;<br>&gt;    func dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyDropWhileSequence&lt;Self.Elements&gt;<br>&gt;    func takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyTakeWhileSequence&lt;Self.Elements&gt;<br>&gt; }<br>&gt; <br>&gt; extension LazyCollectionType {<br>&gt;    func dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyDropWhileCollection&lt;Self.Elements&gt;<br>&gt;    func takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyTakeWhileCollection&lt;Self.Elements&gt;<br>&gt; }<br>&gt; <br>&gt; No collection variant of scan is provided because that would require storing the last value in the index itself, which would cause problems if the combine function isn&#39;t pure.<br>&gt; <br>&gt; LazyDropWhileCollection would behave similarly to LazyFilterCollection in that it runs the predicate against the elements to drop when accessing startIndex; unlike LazyFilterCollection, because there&#39;s nothing else to skip after that point, the index itself can actually be Self.Elements.Index (just like a slice). LazyTakeWhileCollection also runs the predicate against the first element when accessing startIndex, but it does need a unique index type (because endIndex has to be some sentinel value, as it doesn&#39;t know where the end is until you reach that point; this index type would therefore only conform to ForwardIndexType).<br>&gt; <br>&gt; And finally, we provide a global function<br>&gt; <br>&gt; func iterate&lt;T&gt;(initial: T, _ f: T -&gt; T) -&gt; IterateSequence&lt;T&gt;<br>&gt; <br>&gt; This function is inherently lazy and yields an infinite list of nested applications of the function, so iterate(x, f) yields a sequence like [x, f(x), f(f(x)), ...].<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9f3e3f9871fd088e42df4509aa724367?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Adriano Ferreira</string> &lt;adriano.ferreira at me.com&gt;<p>January  7, 2016 at 10:00:00am</p></header><div class="content"><p>+1<br></p><p>— A<br></p><p>&gt; On Dec 29, 2015, at 4:55 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt;&gt; Am 29.12.2015 um 00:59 schrieb Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; ## Introduction<br>&gt;&gt; <br>&gt;&gt; Add a few more functional sequence utilities to the standard library.<br>&gt;&gt; <br>&gt;&gt; ## Motivation<br>&gt;&gt; <br>&gt;&gt; We have map, filter, and reduce, but we&#39;re missing a bunch of useful utilities like scan, iterate, takeWhile, and dropWhile. Interestingly, the stdlib includes an implementation of scan in the doc comment for LazySequenceType, it just doesn&#39;t actually provide it as API.<br>&gt;&gt; <br>&gt;&gt; ## Proposed solution<br>&gt;&gt; <br>&gt;&gt; We extend SequenceType with 3 new methods scan, takeWhile, and dropWhile. We also add a single global function iterate.<br>&gt;&gt; <br>&gt;&gt; ## Detailed design<br>&gt;&gt; <br>&gt;&gt; We add the following extension to SequenceType:<br>&gt;&gt; <br>&gt;&gt; extension SequenceType {<br>&gt;&gt;   func scan&lt;T&gt;(initial: T, @noescape combine: (T, Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt;&gt;   func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt;&gt;   func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; These all take functions, so to follow convention they&#39;re @noescape and return arrays. We also provide an extension of CollectionType that overrides a couple of these methods:<br>&gt;&gt; <br>&gt;&gt; extension CollectionType {<br>&gt;&gt;   func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.SubSequence<br>&gt;&gt;   func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.SubSequence<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; We also provide lazy versions:<br>&gt;&gt; <br>&gt;&gt; extension LazySequenceType {<br>&gt;&gt;   func scan&lt;T&gt;(initial: T, combine: (T, Self.Generator.Element) -&gt; T) -&gt; LazyScanSequence&lt;Self.Elements, T&gt;<br>&gt;&gt;   func dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyDropWhileSequence&lt;Self.Elements&gt;<br>&gt;&gt;   func takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyTakeWhileSequence&lt;Self.Elements&gt;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension LazyCollectionType {<br>&gt;&gt;   func dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyDropWhileCollection&lt;Self.Elements&gt;<br>&gt;&gt;   func takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyTakeWhileCollection&lt;Self.Elements&gt;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; No collection variant of scan is provided because that would require storing the last value in the index itself, which would cause problems if the combine function isn&#39;t pure.<br>&gt;&gt; <br>&gt;&gt; LazyDropWhileCollection would behave similarly to LazyFilterCollection in that it runs the predicate against the elements to drop when accessing startIndex; unlike LazyFilterCollection, because there&#39;s nothing else to skip after that point, the index itself can actually be Self.Elements.Index (just like a slice). LazyTakeWhileCollection also runs the predicate against the first element when accessing startIndex, but it does need a unique index type (because endIndex has to be some sentinel value, as it doesn&#39;t know where the end is until you reach that point; this index type would therefore only conform to ForwardIndexType).<br>&gt;&gt; <br>&gt;&gt; And finally, we provide a global function<br>&gt;&gt; <br>&gt;&gt; func iterate&lt;T&gt;(initial: T, _ f: T -&gt; T) -&gt; IterateSequence&lt;T&gt;<br>&gt;&gt; <br>&gt;&gt; This function is inherently lazy and yields an infinite list of nested applications of the function, so iterate(x, f) yields a sequence like [x, f(x), f(f(x)), ...].<br>&gt;&gt; <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/357b710213d3c0e01356f7c90f78b9f2?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Vincent Esche</string> &lt;regexident.mailinglists at gmail.com&gt;<p>January  7, 2016 at 06:00:00pm</p></header><div class="content"><p>+1<br></p><p>- Vincent<br></p><p>&gt; On 07 Jan 2016, at 16:03, Adriano Ferreira via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1<br>&gt; <br>&gt; — A<br>&gt; <br>&gt;&gt; On Dec 29, 2015, at 4:55 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt;&gt; Am 29.12.2015 um 00:59 schrieb Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Add a few more functional sequence utilities to the standard library.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We have map, filter, and reduce, but we&#39;re missing a bunch of useful utilities like scan, iterate, takeWhile, and dropWhile. Interestingly, the stdlib includes an implementation of scan in the doc comment for LazySequenceType, it just doesn&#39;t actually provide it as API.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We extend SequenceType with 3 new methods scan, takeWhile, and dropWhile. We also add a single global function iterate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We add the following extension to SequenceType:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension SequenceType {<br>&gt;&gt;&gt;  func scan&lt;T&gt;(initial: T, @noescape combine: (T, Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt;&gt;&gt;  func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt;&gt;&gt;  func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These all take functions, so to follow convention they&#39;re @noescape and return arrays. We also provide an extension of CollectionType that overrides a couple of these methods:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension CollectionType {<br>&gt;&gt;&gt;  func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.SubSequence<br>&gt;&gt;&gt;  func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.SubSequence<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We also provide lazy versions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension LazySequenceType {<br>&gt;&gt;&gt;  func scan&lt;T&gt;(initial: T, combine: (T, Self.Generator.Element) -&gt; T) -&gt; LazyScanSequence&lt;Self.Elements, T&gt;<br>&gt;&gt;&gt;  func dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyDropWhileSequence&lt;Self.Elements&gt;<br>&gt;&gt;&gt;  func takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyTakeWhileSequence&lt;Self.Elements&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension LazyCollectionType {<br>&gt;&gt;&gt;  func dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyDropWhileCollection&lt;Self.Elements&gt;<br>&gt;&gt;&gt;  func takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyTakeWhileCollection&lt;Self.Elements&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No collection variant of scan is provided because that would require storing the last value in the index itself, which would cause problems if the combine function isn&#39;t pure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; LazyDropWhileCollection would behave similarly to LazyFilterCollection in that it runs the predicate against the elements to drop when accessing startIndex; unlike LazyFilterCollection, because there&#39;s nothing else to skip after that point, the index itself can actually be Self.Elements.Index (just like a slice). LazyTakeWhileCollection also runs the predicate against the first element when accessing startIndex, but it does need a unique index type (because endIndex has to be some sentinel value, as it doesn&#39;t know where the end is until you reach that point; this index type would therefore only conform to ForwardIndexType).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And finally, we provide a global function<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func iterate&lt;T&gt;(initial: T, _ f: T -&gt; T) -&gt; IterateSequence&lt;T&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This function is inherently lazy and yields an infinite list of nested applications of the function, so iterate(x, f) yields a sequence like [x, f(x), f(f(x)), ...].<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  9, 2016 at 04:00:00pm</p></header><div class="content"><p>Re-reading this proposal, I actually want to make a couple of changes. To better match the existing set of SequenceType methods, the extensions for dropWhile() and takeWhile() on SequenceType should in fact be members of the protocol that return Self.SubSequence, with default implementations provided that return AnySequence&lt;Self.Generator.Element&gt;. This matches how prefix(), dropFirst(), etc. are all handled.<br></p><p>The downside to this is any existing type that conforms to SequenceType but not CollectionType and that defines its SubSequence as anything other than AnySequence&lt;Self.Generator.Element&gt; will have to provide its own implementation of dropWhile() and takeWhile(). However, AFAIK in the stdlib every type that conforms to SequenceType also either conforms to CollectionType or leaves SubSequence at the default definition of AnySequence. And it&#39;s reasonable to assume that third-party code matches this behavior, because otherwise the third-party SequenceType has to implement a bunch of methods already like dropFirst() and prefix() that one does not normally expect third-party code to implement.<br></p><p>As such, the resulting API actually looks like<br></p><p>protocol SequenceType {<br>    // ...<br>    func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.SubSequence<br>    func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.SubSequence<br>}<br></p><p>extension SequenceType {<br>    func scan&lt;T&gt;(initial: T, @noescape combine: (T, Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T]<br>    func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; AnySequence&lt;Self.Generator.Element&gt;<br>    func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; AnySequence&lt;Self.Generator.Element&gt;<br>}<br></p><p>The API on collectionType, LazySequenceType, and LazyCollectionType all remain the same.<br></p><p>-Kevin Ballard<br></p><p>On Mon, Dec 28, 2015, at 03:59 PM, Kevin Ballard wrote:<br>&gt; ## Introduction<br>&gt; <br>&gt; Add a few more functional sequence utilities to the standard library.<br>&gt; <br>&gt; ## Motivation<br>&gt; <br>&gt; We have map, filter, and reduce, but we&#39;re missing a bunch of useful utilities like scan, iterate, takeWhile, and dropWhile. Interestingly, the stdlib includes an implementation of scan in the doc comment for LazySequenceType, it just doesn&#39;t actually provide it as API.<br>&gt; <br>&gt; ## Proposed solution<br>&gt; <br>&gt; We extend SequenceType with 3 new methods scan, takeWhile, and dropWhile. We also add a single global function iterate.<br>&gt; <br>&gt; ## Detailed design<br>&gt; <br>&gt; We add the following extension to SequenceType:<br>&gt; <br>&gt; extension SequenceType {<br>&gt;     func scan&lt;T&gt;(initial: T, @noescape combine: (T, Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt;     func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt;     func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt; }<br>&gt; <br>&gt; These all take functions, so to follow convention they&#39;re @noescape and return arrays. We also provide an extension of CollectionType that overrides a couple of these methods:<br>&gt; <br>&gt; extension CollectionType {<br>&gt;     func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.SubSequence<br>&gt;     func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.SubSequence<br>&gt; }<br>&gt; <br>&gt; We also provide lazy versions:<br>&gt; <br>&gt; extension LazySequenceType {<br>&gt;     func scan&lt;T&gt;(initial: T, combine: (T, Self.Generator.Element) -&gt; T) -&gt; LazyScanSequence&lt;Self.Elements, T&gt;<br>&gt;     func dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyDropWhileSequence&lt;Self.Elements&gt;<br>&gt;     func takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyTakeWhileSequence&lt;Self.Elements&gt;<br>&gt; }<br>&gt; <br>&gt; extension LazyCollectionType {<br>&gt;     func dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyDropWhileCollection&lt;Self.Elements&gt;<br>&gt;     func takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyTakeWhileCollection&lt;Self.Elements&gt;<br>&gt; }<br>&gt; <br>&gt; No collection variant of scan is provided because that would require storing the last value in the index itself, which would cause problems if the combine function isn&#39;t pure.<br>&gt; <br>&gt; LazyDropWhileCollection would behave similarly to LazyFilterCollection in that it runs the predicate against the elements to drop when accessing startIndex; unlike LazyFilterCollection, because there&#39;s nothing else to skip after that point, the index itself can actually be Self.Elements.Index (just like a slice). LazyTakeWhileCollection also runs the predicate against the first element when accessing startIndex, but it does need a unique index type (because endIndex has to be some sentinel value, as it doesn&#39;t know where the end is until you reach that point; this index type would therefore only conform to ForwardIndexType).<br>&gt; <br>&gt; And finally, we provide a global function<br>&gt; <br>&gt; func iterate&lt;T&gt;(initial: T, _ f: T -&gt; T) -&gt; IterateSequence&lt;T&gt;<br>&gt; <br>&gt; This function is inherently lazy and yields an infinite list of nested applications of the function, so iterate(x, f) yields a sequence like [x, f(x), f(f(x)), ...].<br>&gt; <br>&gt; -Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4030f7e8f6b6d3c09d10ec12691773c1?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>John Randolph</string> &lt;jcr at mac.com&gt;<p>January 13, 2016 at 05:00:00pm</p></header><div class="content"><p>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/d8d81a5f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 13, 2016 at 05:00:00pm</p></header><div class="content"><p>They&#39;re different. We already have &quot;filter&quot; in stdlib; takeWhile is more<br>like<br></p><p>var results: [Element] = []<br>for element in self {<br>    if !predicate(element) { break }<br>    results.append(element)<br>}<br>return results<br></p><p>Jacob Bandes-Storch<br></p><p>On Wed, Jan 13, 2016 at 5:14 PM, John Randolph via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I’d like to see this functionality added, but I would suggest some<br>&gt; different names.  When Marcel Weiher wrote his paper on Higher-order<br>&gt; Messaging in Objective-C (available here:<br>&gt; http://www.metaobject.com/papers/Higher_Order_Messaging_OOPSLA_2005.pdf)<br>&gt;  He used “select”, “filter”, “each” and so on.  To my eye, words like<br>&gt; “takeWhile” in your proposal causes some confusion with  an ordinary<br>&gt; “while”.<br>&gt;<br>&gt; If you change “dropWhile” and “takeWhile” to “filter” and “select”, it<br>&gt; becomes much clearer, IMHO.<br>&gt;<br>&gt; -jcr<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Jan 9, 2016, at 4:20 PM, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Re-reading this proposal, I actually want to make a couple of changes. To<br>&gt; better match the existing set of SequenceType methods, the extensions for<br>&gt; dropWhile() and takeWhile() on SequenceType should in fact be members of<br>&gt; the protocol that return Self.SubSequence, with default implementations<br>&gt; provided that return AnySequence&lt;Self.Generator.Element&gt;. This matches how<br>&gt; prefix(), dropFirst(), etc. are all handled.<br>&gt;<br>&gt; The downside to this is any existing type that conforms to SequenceType<br>&gt; but not CollectionType and that defines its SubSequence as anything other<br>&gt; than AnySequence&lt;Self.Generator.Element&gt; will have to provide its own<br>&gt; implementation of dropWhile() and takeWhile(). However, AFAIK in the stdlib<br>&gt; every type that conforms to SequenceType also either conforms to<br>&gt; CollectionType or leaves SubSequence at the default definition of<br>&gt; AnySequence. And it&#39;s reasonable to assume that third-party code matches<br>&gt; this behavior, because otherwise the third-party SequenceType has to<br>&gt; implement a bunch of methods already like dropFirst() and prefix() that one<br>&gt; does not normally expect third-party code to implement.<br>&gt;<br>&gt; As such, the resulting API actually looks like<br>&gt;<br>&gt; protocol SequenceType {<br>&gt;  // ...<br>&gt;  func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt;<br>&gt; Bool) rethrows -&gt; Self.SubSequence<br>&gt;  func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt;<br>&gt; Bool) rethrows -&gt; Self.SubSequence<br>&gt; }<br>&gt;<br>&gt; extension SequenceType {<br>&gt;  func scan&lt;T&gt;(initial: T, @noescape combine: (T, Self.Generator.Element)<br>&gt; throws -&gt; T) rethrows -&gt; [T]<br>&gt;  func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt;<br>&gt; Bool) rethrows -&gt; AnySequence&lt;Self.Generator.Element&gt;<br>&gt;  func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt;<br>&gt; Bool) rethrows -&gt; AnySequence&lt;Self.Generator.Element&gt;<br>&gt; }<br>&gt;<br>&gt; The API on collectionType, LazySequenceType, and LazyCollectionType all<br>&gt; remain the same.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Mon, Dec 28, 2015, at 03:59 PM, Kevin Ballard wrote:<br>&gt;<br>&gt; ## Introduction<br>&gt;<br>&gt; Add a few more functional sequence utilities to the standard library.<br>&gt;<br>&gt; ## Motivation<br>&gt;<br>&gt; We have map, filter, and reduce, but we&#39;re missing a bunch of useful<br>&gt; utilities like scan, iterate, takeWhile, and dropWhile. Interestingly, the<br>&gt; stdlib includes an implementation of scan in the doc comment for<br>&gt; LazySequenceType, it just doesn&#39;t actually provide it as API.<br>&gt;<br>&gt; ## Proposed solution<br>&gt;<br>&gt; We extend SequenceType with 3 new methods scan, takeWhile, and dropWhile.<br>&gt; We also add a single global function iterate.<br>&gt;<br>&gt; ## Detailed design<br>&gt;<br>&gt; We add the following extension to SequenceType:<br>&gt;<br>&gt; extension SequenceType {<br>&gt;  func scan&lt;T&gt;(initial: T, @noescape combine: (T, Self.Generator.Element)<br>&gt; throws -&gt; T) rethrows -&gt; [T]<br>&gt;  func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt;<br>&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt;  func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt;<br>&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt; }<br>&gt;<br>&gt; These all take functions, so to follow convention they&#39;re @noescape and<br>&gt; return arrays. We also provide an extension of CollectionType that<br>&gt; overrides a couple of these methods:<br>&gt;<br>&gt; extension CollectionType {<br>&gt;  func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt;<br>&gt; Bool) rethrows -&gt; Self.SubSequence<br>&gt;  func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt;<br>&gt; Bool) rethrows -&gt; Self.SubSequence<br>&gt; }<br>&gt;<br>&gt; We also provide lazy versions:<br>&gt;<br>&gt; extension LazySequenceType {<br>&gt;  func scan&lt;T&gt;(initial: T, combine: (T, Self.Generator.Element) -&gt; T) -&gt;<br>&gt; LazyScanSequence&lt;Self.Elements, T&gt;<br>&gt;  func dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>&gt; LazyDropWhileSequence&lt;Self.Elements&gt;<br>&gt;  func takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>&gt; LazyTakeWhileSequence&lt;Self.Elements&gt;<br>&gt; }<br>&gt;<br>&gt; extension LazyCollectionType {<br>&gt;  func dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>&gt; LazyDropWhileCollection&lt;Self.Elements&gt;<br>&gt;  func takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>&gt; LazyTakeWhileCollection&lt;Self.Elements&gt;<br>&gt; }<br>&gt;<br>&gt; No collection variant of scan is provided because that would require<br>&gt; storing the last value in the index itself, which would cause problems if<br>&gt; the combine function isn&#39;t pure.<br>&gt;<br>&gt; LazyDropWhileCollection would behave similarly to LazyFilterCollection in<br>&gt; that it runs the predicate against the elements to drop when accessing<br>&gt; startIndex; unlike LazyFilterCollection, because there&#39;s nothing else to<br>&gt; skip after that point, the index itself can actually be Self.Elements.Index<br>&gt; (just like a slice). LazyTakeWhileCollection also runs the predicate<br>&gt; against the first element when accessing startIndex, but it does need a<br>&gt; unique index type (because endIndex has to be some sentinel value, as it<br>&gt; doesn&#39;t know where the end is until you reach that point; this index type<br>&gt; would therefore only conform to ForwardIndexType).<br>&gt;<br>&gt; And finally, we provide a global function<br>&gt;<br>&gt; func iterate&lt;T&gt;(initial: T, _ f: T -&gt; T) -&gt; IterateSequence&lt;T&gt;<br>&gt;<br>&gt; This function is inherently lazy and yields an infinite list of nested<br>&gt; applications of the function, so iterate(x, f) yields a sequence like [x,<br>&gt; f(x), f(f(x)), ...].<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/bc8be02e/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  9, 2016 at 05:00:00pm</p></header><div class="content"><p>Proposal PR submitted as https://github.com/apple/swift-evolution/pull/95<br></p><p>-Kevin Ballard<br></p><p>On Mon, Dec 28, 2015, at 03:59 PM, Kevin Ballard wrote:<br>&gt; ## Introduction<br>&gt; <br>&gt; Add a few more functional sequence utilities to the standard library.<br>&gt; <br>&gt; ## Motivation<br>&gt; <br>&gt; We have map, filter, and reduce, but we&#39;re missing a bunch of useful utilities like scan, iterate, takeWhile, and dropWhile. Interestingly, the stdlib includes an implementation of scan in the doc comment for LazySequenceType, it just doesn&#39;t actually provide it as API.<br>&gt; <br>&gt; ## Proposed solution<br>&gt; <br>&gt; We extend SequenceType with 3 new methods scan, takeWhile, and dropWhile. We also add a single global function iterate.<br>&gt; <br>&gt; ## Detailed design<br>&gt; <br>&gt; We add the following extension to SequenceType:<br>&gt; <br>&gt; extension SequenceType {<br>&gt;     func scan&lt;T&gt;(initial: T, @noescape combine: (T, Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt;     func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt;     func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt; }<br>&gt; <br>&gt; These all take functions, so to follow convention they&#39;re @noescape and return arrays. We also provide an extension of CollectionType that overrides a couple of these methods:<br>&gt; <br>&gt; extension CollectionType {<br>&gt;     func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.SubSequence<br>&gt;     func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.SubSequence<br>&gt; }<br>&gt; <br>&gt; We also provide lazy versions:<br>&gt; <br>&gt; extension LazySequenceType {<br>&gt;     func scan&lt;T&gt;(initial: T, combine: (T, Self.Generator.Element) -&gt; T) -&gt; LazyScanSequence&lt;Self.Elements, T&gt;<br>&gt;     func dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyDropWhileSequence&lt;Self.Elements&gt;<br>&gt;     func takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyTakeWhileSequence&lt;Self.Elements&gt;<br>&gt; }<br>&gt; <br>&gt; extension LazyCollectionType {<br>&gt;     func dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyDropWhileCollection&lt;Self.Elements&gt;<br>&gt;     func takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyTakeWhileCollection&lt;Self.Elements&gt;<br>&gt; }<br>&gt; <br>&gt; No collection variant of scan is provided because that would require storing the last value in the index itself, which would cause problems if the combine function isn&#39;t pure.<br>&gt; <br>&gt; LazyDropWhileCollection would behave similarly to LazyFilterCollection in that it runs the predicate against the elements to drop when accessing startIndex; unlike LazyFilterCollection, because there&#39;s nothing else to skip after that point, the index itself can actually be Self.Elements.Index (just like a slice). LazyTakeWhileCollection also runs the predicate against the first element when accessing startIndex, but it does need a unique index type (because endIndex has to be some sentinel value, as it doesn&#39;t know where the end is until you reach that point; this index type would therefore only conform to ForwardIndexType).<br>&gt; <br>&gt; And finally, we provide a global function<br>&gt; <br>&gt; func iterate&lt;T&gt;(initial: T, _ f: T -&gt; T) -&gt; IterateSequence&lt;T&gt;<br>&gt; <br>&gt; This function is inherently lazy and yields an infinite list of nested applications of the function, so iterate(x, f) yields a sequence like [x, f(x), f(f(x)), ...].<br>&gt; <br>&gt; -Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a1faea18be9eb2d50c4edcd223f2d685?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Seth Friedman</string> &lt;sethfri at gmail.com&gt;<p>January 11, 2016 at 05:00:00am</p></header><div class="content"><p>I&#39;m not familiar with any of the functions listed and would love to see<br>more about them and their usefulness to Swift as part of the proposal.<br></p><p>Thanks!<br></p><p>Seth<br>On Sat, Jan 9, 2016 at 5:30 PM Kevin Ballard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Proposal PR submitted as https://github.com/apple/swift-evolution/pull/95<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Mon, Dec 28, 2015, at 03:59 PM, Kevin Ballard wrote:<br>&gt; &gt; ## Introduction<br>&gt; &gt;<br>&gt; &gt; Add a few more functional sequence utilities to the standard library.<br>&gt; &gt;<br>&gt; &gt; ## Motivation<br>&gt; &gt;<br>&gt; &gt; We have map, filter, and reduce, but we&#39;re missing a bunch of useful<br>&gt; utilities like scan, iterate, takeWhile, and dropWhile. Interestingly, the<br>&gt; stdlib includes an implementation of scan in the doc comment for<br>&gt; LazySequenceType, it just doesn&#39;t actually provide it as API.<br>&gt; &gt;<br>&gt; &gt; ## Proposed solution<br>&gt; &gt;<br>&gt; &gt; We extend SequenceType with 3 new methods scan, takeWhile, and<br>&gt; dropWhile. We also add a single global function iterate.<br>&gt; &gt;<br>&gt; &gt; ## Detailed design<br>&gt; &gt;<br>&gt; &gt; We add the following extension to SequenceType:<br>&gt; &gt;<br>&gt; &gt; extension SequenceType {<br>&gt; &gt;     func scan&lt;T&gt;(initial: T, @noescape combine: (T,<br>&gt; Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt; &gt;     func dropWhile(@noescape dropElement: (Self.Generator.Element)<br>&gt; throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt; &gt;     func takeWhile(@noescape takeElement: (Self.Generator.Element)<br>&gt; throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; These all take functions, so to follow convention they&#39;re @noescape and<br>&gt; return arrays. We also provide an extension of CollectionType that<br>&gt; overrides a couple of these methods:<br>&gt; &gt;<br>&gt; &gt; extension CollectionType {<br>&gt; &gt;     func dropWhile(@noescape dropElement: (Self.Generator.Element)<br>&gt; throws -&gt; Bool) rethrows -&gt; Self.SubSequence<br>&gt; &gt;     func takeWhile(@noescape takeElement: (Self.Generator.Element)<br>&gt; throws -&gt; Bool) rethrows -&gt; Self.SubSequence<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; We also provide lazy versions:<br>&gt; &gt;<br>&gt; &gt; extension LazySequenceType {<br>&gt; &gt;     func scan&lt;T&gt;(initial: T, combine: (T, Self.Generator.Element) -&gt; T)<br>&gt; -&gt; LazyScanSequence&lt;Self.Elements, T&gt;<br>&gt; &gt;     func dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>&gt; LazyDropWhileSequence&lt;Self.Elements&gt;<br>&gt; &gt;     func takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>&gt; LazyTakeWhileSequence&lt;Self.Elements&gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; extension LazyCollectionType {<br>&gt; &gt;     func dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>&gt; LazyDropWhileCollection&lt;Self.Elements&gt;<br>&gt; &gt;     func takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>&gt; LazyTakeWhileCollection&lt;Self.Elements&gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; No collection variant of scan is provided because that would require<br>&gt; storing the last value in the index itself, which would cause problems if<br>&gt; the combine function isn&#39;t pure.<br>&gt; &gt;<br>&gt; &gt; LazyDropWhileCollection would behave similarly to LazyFilterCollection<br>&gt; in that it runs the predicate against the elements to drop when accessing<br>&gt; startIndex; unlike LazyFilterCollection, because there&#39;s nothing else to<br>&gt; skip after that point, the index itself can actually be Self.Elements.Index<br>&gt; (just like a slice). LazyTakeWhileCollection also runs the predicate<br>&gt; against the first element when accessing startIndex, but it does need a<br>&gt; unique index type (because endIndex has to be some sentinel value, as it<br>&gt; doesn&#39;t know where the end is until you reach that point; this index type<br>&gt; would therefore only conform to ForwardIndexType).<br>&gt; &gt;<br>&gt; &gt; And finally, we provide a global function<br>&gt; &gt;<br>&gt; &gt; func iterate&lt;T&gt;(initial: T, _ f: T -&gt; T) -&gt; IterateSequence&lt;T&gt;<br>&gt; &gt;<br>&gt; &gt; This function is inherently lazy and yields an infinite list of nested<br>&gt; applications of the function, so iterate(x, f) yields a sequence like [x,<br>&gt; f(x), f(f(x)), ...].<br>&gt; &gt;<br>&gt; &gt; -Kevin Ballard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/dd8a359f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a1faea18be9eb2d50c4edcd223f2d685?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Seth Friedman</string> &lt;sethfri at gmail.com&gt;<p>January 11, 2016 at 05:00:00am</p></header><div class="content"><p>To clear my thoughts up a bit, that wasn&#39;t an &quot;I&#39;m too lazy to Google what<br>these functions normally do&quot; comment, but rather an &quot;I believe proposals<br>should provide as much context as possible about what you&#39;d like to add<br>along with the benefits of doing so&quot; comment.<br>On Sun, Jan 10, 2016 at 9:48 PM Seth Friedman &lt;sethfri at gmail.com&gt; wrote:<br></p><p>&gt; I&#39;m not familiar with any of the functions listed and would love to see<br>&gt; more about them and their usefulness to Swift as part of the proposal.<br>&gt;<br>&gt; Thanks!<br>&gt;<br>&gt; Seth<br>&gt; On Sat, Jan 9, 2016 at 5:30 PM Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Proposal PR submitted as https://github.com/apple/swift-evolution/pull/95<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt; On Mon, Dec 28, 2015, at 03:59 PM, Kevin Ballard wrote:<br>&gt;&gt; &gt; ## Introduction<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Add a few more functional sequence utilities to the standard library.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ## Motivation<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; We have map, filter, and reduce, but we&#39;re missing a bunch of useful<br>&gt;&gt; utilities like scan, iterate, takeWhile, and dropWhile. Interestingly, the<br>&gt;&gt; stdlib includes an implementation of scan in the doc comment for<br>&gt;&gt; LazySequenceType, it just doesn&#39;t actually provide it as API.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ## Proposed solution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; We extend SequenceType with 3 new methods scan, takeWhile, and<br>&gt;&gt; dropWhile. We also add a single global function iterate.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ## Detailed design<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; We add the following extension to SequenceType:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; extension SequenceType {<br>&gt;&gt; &gt;     func scan&lt;T&gt;(initial: T, @noescape combine: (T,<br>&gt;&gt; Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt;&gt; &gt;     func dropWhile(@noescape dropElement: (Self.Generator.Element)<br>&gt;&gt; throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt;&gt; &gt;     func takeWhile(@noescape takeElement: (Self.Generator.Element)<br>&gt;&gt; throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; These all take functions, so to follow convention they&#39;re @noescape and<br>&gt;&gt; return arrays. We also provide an extension of CollectionType that<br>&gt;&gt; overrides a couple of these methods:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; extension CollectionType {<br>&gt;&gt; &gt;     func dropWhile(@noescape dropElement: (Self.Generator.Element)<br>&gt;&gt; throws -&gt; Bool) rethrows -&gt; Self.SubSequence<br>&gt;&gt; &gt;     func takeWhile(@noescape takeElement: (Self.Generator.Element)<br>&gt;&gt; throws -&gt; Bool) rethrows -&gt; Self.SubSequence<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; We also provide lazy versions:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; extension LazySequenceType {<br>&gt;&gt; &gt;     func scan&lt;T&gt;(initial: T, combine: (T, Self.Generator.Element) -&gt; T)<br>&gt;&gt; -&gt; LazyScanSequence&lt;Self.Elements, T&gt;<br>&gt;&gt; &gt;     func dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>&gt;&gt; LazyDropWhileSequence&lt;Self.Elements&gt;<br>&gt;&gt; &gt;     func takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>&gt;&gt; LazyTakeWhileSequence&lt;Self.Elements&gt;<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; extension LazyCollectionType {<br>&gt;&gt; &gt;     func dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>&gt;&gt; LazyDropWhileCollection&lt;Self.Elements&gt;<br>&gt;&gt; &gt;     func takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>&gt;&gt; LazyTakeWhileCollection&lt;Self.Elements&gt;<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; No collection variant of scan is provided because that would require<br>&gt;&gt; storing the last value in the index itself, which would cause problems if<br>&gt;&gt; the combine function isn&#39;t pure.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; LazyDropWhileCollection would behave similarly to LazyFilterCollection<br>&gt;&gt; in that it runs the predicate against the elements to drop when accessing<br>&gt;&gt; startIndex; unlike LazyFilterCollection, because there&#39;s nothing else to<br>&gt;&gt; skip after that point, the index itself can actually be Self.Elements.Index<br>&gt;&gt; (just like a slice). LazyTakeWhileCollection also runs the predicate<br>&gt;&gt; against the first element when accessing startIndex, but it does need a<br>&gt;&gt; unique index type (because endIndex has to be some sentinel value, as it<br>&gt;&gt; doesn&#39;t know where the end is until you reach that point; this index type<br>&gt;&gt; would therefore only conform to ForwardIndexType).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; And finally, we provide a global function<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; func iterate&lt;T&gt;(initial: T, _ f: T -&gt; T) -&gt; IterateSequence&lt;T&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This function is inherently lazy and yields an infinite list of nested<br>&gt;&gt; applications of the function, so iterate(x, f) yields a sequence like [x,<br>&gt;&gt; f(x), f(f(x)), ...].<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -Kevin Ballard<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/cbb95736/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January 10, 2016 at 10:00:00pm</p></header><div class="content"><p>When the proposal is &quot;we have a bunch of functions that match functions used in other languages, lets add a few more from the same category of functions that we missed&quot;, does there really need to be much explanation beyond &quot;they&#39;re useful in the other languages that have them, they&#39;d be useful for the same reasons in Swift&quot;?<br></p><p>If requested, I can provide examples of usage. But if you&#39;re not already sold on the benefits of working with sequences in a functional manner, it&#39;s out of scope of the proposal to convince you of the merits of that style of programming. And if you are already sold on the benefits of doing so, then adding these functions shouldn&#39;t need much explanation.<br></p><p>Here&#39;s a few toy examples, if it helps:<br></p><p>// list of all powers of 2 below some limit<br>iterate(1, apply: { $0 * 2 }).takeWhile({ $0 &lt; limit })<br></p><p>// first &quot;word&quot; of a string, skipping whitespace<br>let cs = NSCharacterSet.whitespaceCharacterSet()<br>String(str.unicodeScalars.skipWhile({ cs.longCharacterIsMember($0.value) })<br>                         .takeWhile({ !cs.longCharacterIsMember($0.value) }))<br></p><p>// running total of an array of numbers<br>numbers.scan(0, combine: +).dropFirst()<br></p><p>// infinite fibonacci sequence<br>iterate((0,1), apply: { ($1, $0+$1) }).lazy.map({$1})<br></p><p>-Kevin Ballard<br></p><p>On Sun, Jan 10, 2016, at 09:55 PM, Seth Friedman wrote:<br>&gt; To clear my thoughts up a bit, that wasn&#39;t an &quot;I&#39;m too lazy to Google what these functions normally do&quot; comment, but rather an &quot;I believe proposals should provide as much context as possible about what you&#39;d like to add along with the benefits of doing so&quot; comment.<br>&gt; On Sun, Jan 10, 2016 at 9:48 PM Seth Friedman &lt;sethfri at gmail.com &lt;mailto:sethfri at gmail.com&gt;&gt; wrote:<br>&gt; I&#39;m not familiar with any of the functions listed and would love to see more about them and their usefulness to Swift as part of the proposal.<br>&gt;  <br>&gt; Thanks!<br>&gt;  <br>&gt; Seth<br>&gt; On Sat, Jan 9, 2016 at 5:30 PM Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Proposal PR submitted as https://github.com/apple/swift-evolution/pull/95 &lt;https://github.com/apple/swift-evolution/pull/95&gt;<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; On Mon, Dec 28, 2015, at 03:59 PM, Kevin Ballard wrote:<br>&gt; &gt; ## Introduction<br>&gt; &gt;<br>&gt; &gt; Add a few more functional sequence utilities to the standard library.<br>&gt; &gt;<br>&gt; &gt; ## Motivation<br>&gt; &gt;<br>&gt; &gt; We have map, filter, and reduce, but we&#39;re missing a bunch of useful utilities like scan, iterate, takeWhile, and dropWhile. Interestingly, the stdlib includes an implementation of scan in the doc comment for LazySequenceType, it just doesn&#39;t actually provide it as API.<br>&gt; &gt;<br>&gt; &gt; ## Proposed solution<br>&gt; &gt;<br>&gt; &gt; We extend SequenceType with 3 new methods scan, takeWhile, and dropWhile. We also add a single global function iterate.<br>&gt; &gt;<br>&gt; &gt; ## Detailed design<br>&gt; &gt;<br>&gt; &gt; We add the following extension to SequenceType:<br>&gt; &gt;<br>&gt; &gt; extension SequenceType {<br>&gt; &gt;     func scan&lt;T&gt;(initial: T, @noescape combine: (T, Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt; &gt;     func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt; &gt;     func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; These all take functions, so to follow convention they&#39;re @noescape and return arrays. We also provide an extension of CollectionType that overrides a couple of these methods:<br>&gt; &gt;<br>&gt; &gt; extension CollectionType {<br>&gt; &gt;     func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.SubSequence<br>&gt; &gt;     func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; Self.SubSequence<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; We also provide lazy versions:<br>&gt; &gt;<br>&gt; &gt; extension LazySequenceType {<br>&gt; &gt;     func scan&lt;T&gt;(initial: T, combine: (T, Self.Generator.Element) -&gt; T) -&gt; LazyScanSequence&lt;Self.Elements, T&gt;<br>&gt; &gt;     func dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyDropWhileSequence&lt;Self.Elements&gt;<br>&gt; &gt;     func takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyTakeWhileSequence&lt;Self.Elements&gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; extension LazyCollectionType {<br>&gt; &gt;     func dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyDropWhileCollection&lt;Self.Elements&gt;<br>&gt; &gt;     func takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt; LazyTakeWhileCollection&lt;Self.Elements&gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; No collection variant of scan is provided because that would require storing the last value in the index itself, which would cause problems if the combine function isn&#39;t pure.<br>&gt; &gt;<br>&gt; &gt; LazyDropWhileCollection would behave similarly to LazyFilterCollection in that it runs the predicate against the elements to drop when accessing startIndex; unlike LazyFilterCollection, because there&#39;s nothing else to skip after that point, the index itself can actually be Self.Elements.Index (just like a slice). LazyTakeWhileCollection also runs the predicate against the first element when accessing startIndex, but it does need a unique index type (because endIndex has to be some sentinel value, as it doesn&#39;t know where the end is until you reach that point; this index type would therefore only conform to ForwardIndexType).<br>&gt; &gt;<br>&gt; &gt; And finally, we provide a global function<br>&gt; &gt;<br>&gt; &gt; func iterate&lt;T&gt;(initial: T, _ f: T -&gt; T) -&gt; IterateSequence&lt;T&gt;<br>&gt; &gt;<br>&gt; &gt; This function is inherently lazy and yields an infinite list of nested applications of the function, so iterate(x, f) yields a sequence like [x, f(x), f(f(x)), ...].<br>&gt; &gt;<br>&gt; &gt; -Kevin Ballard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/485330ee/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a1faea18be9eb2d50c4edcd223f2d685?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Seth Friedman</string> &lt;sethfri at gmail.com&gt;<p>January 11, 2016 at 06:00:00am</p></header><div class="content"><p>I wasn&#39;t suggesting you should convince the reviewers of the merits of<br>functional style programming. I&#39;m coming at it from the perspective of &quot;Hey<br>I&#39;m not very familiar with functional style. What cool new things could<br>these functions help me do if they&#39;re added to the stdlib?&quot;.<br></p><p>Not all of your reviewers are necessarily going to be familiar with these<br>functions from other languages; I simply think more detail would make the<br>proposal more compelling. Ultimately up to you.<br></p><p>Thanks,<br>Seth<br>On Sun, Jan 10, 2016 at 10:20 PM Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br></p><p>&gt; When the proposal is &quot;we have a bunch of functions that match functions<br>&gt; used in other languages, lets add a few more from the same category of<br>&gt; functions that we missed&quot;, does there really need to be much explanation<br>&gt; beyond &quot;they&#39;re useful in the other languages that have them, they&#39;d be<br>&gt; useful for the same reasons in Swift&quot;?<br>&gt;<br>&gt; If requested, I can provide examples of usage. But if you&#39;re not already<br>&gt; sold on the benefits of working with sequences in a functional manner, it&#39;s<br>&gt; out of scope of the proposal to convince you of the merits of that style of<br>&gt; programming. And if you are already sold on the benefits of doing so, then<br>&gt; adding these functions shouldn&#39;t need much explanation.<br>&gt;<br>&gt; Here&#39;s a few toy examples, if it helps:<br>&gt;<br>&gt; // list of all powers of 2 below some limit<br>&gt; iterate(1, apply: { $0 * 2 }).takeWhile({ $0 &lt; limit })<br>&gt;<br>&gt; // first &quot;word&quot; of a string, skipping whitespace<br>&gt; let cs = NSCharacterSet.whitespaceCharacterSet()<br>&gt; String(str.unicodeScalars.skipWhile({ cs.longCharacterIsMember($0.value) })<br>&gt;                          .takeWhile({ !cs.longCharacterIsMember($0.value)<br>&gt; }))<br>&gt;<br>&gt; // running total of an array of numbers<br>&gt; numbers.scan(0, combine: +).dropFirst()<br>&gt;<br>&gt; // infinite fibonacci sequence<br>&gt; iterate((0,1), apply: { ($1, $0+$1) }).lazy.map({$1})<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Sun, Jan 10, 2016, at 09:55 PM, Seth Friedman wrote:<br>&gt;<br>&gt; To clear my thoughts up a bit, that wasn&#39;t an &quot;I&#39;m too lazy to Google what<br>&gt; these functions normally do&quot; comment, but rather an &quot;I believe proposals<br>&gt; should provide as much context as possible about what you&#39;d like to add<br>&gt; along with the benefits of doing so&quot; comment.<br>&gt; On Sun, Jan 10, 2016 at 9:48 PM Seth Friedman &lt;sethfri at gmail.com&gt; wrote:<br>&gt;<br>&gt; I&#39;m not familiar with any of the functions listed and would love to see<br>&gt; more about them and their usefulness to Swift as part of the proposal.<br>&gt;<br>&gt; Thanks!<br>&gt;<br>&gt; Seth<br>&gt; On Sat, Jan 9, 2016 at 5:30 PM Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Proposal PR submitted as https://github.com/apple/swift-evolution/pull/95<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Mon, Dec 28, 2015, at 03:59 PM, Kevin Ballard wrote:<br>&gt; &gt; ## Introduction<br>&gt; &gt;<br>&gt; &gt; Add a few more functional sequence utilities to the standard library.<br>&gt; &gt;<br>&gt; &gt; ## Motivation<br>&gt; &gt;<br>&gt; &gt; We have map, filter, and reduce, but we&#39;re missing a bunch of useful<br>&gt; utilities like scan, iterate, takeWhile, and dropWhile. Interestingly, the<br>&gt; stdlib includes an implementation of scan in the doc comment for<br>&gt; LazySequenceType, it just doesn&#39;t actually provide it as API.<br>&gt; &gt;<br>&gt; &gt; ## Proposed solution<br>&gt; &gt;<br>&gt; &gt; We extend SequenceType with 3 new methods scan, takeWhile, and<br>&gt; dropWhile. We also add a single global function iterate.<br>&gt; &gt;<br>&gt; &gt; ## Detailed design<br>&gt; &gt;<br>&gt; &gt; We add the following extension to SequenceType:<br>&gt; &gt;<br>&gt; &gt; extension SequenceType {<br>&gt; &gt;     func scan&lt;T&gt;(initial: T, @noescape combine: (T,<br>&gt; Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt; &gt;     func dropWhile(@noescape dropElement: (Self.Generator.Element)<br>&gt; throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt; &gt;     func takeWhile(@noescape takeElement: (Self.Generator.Element)<br>&gt; throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; These all take functions, so to follow convention they&#39;re @noescape and<br>&gt; return arrays. We also provide an extension of CollectionType that<br>&gt; overrides a couple of these methods:<br>&gt; &gt;<br>&gt; &gt; extension CollectionType {<br>&gt; &gt;     func dropWhile(@noescape dropElement: (Self.Generator.Element)<br>&gt; throws -&gt; Bool) rethrows -&gt; Self.SubSequence<br>&gt; &gt;     func takeWhile(@noescape takeElement: (Self.Generator.Element)<br>&gt; throws -&gt; Bool) rethrows -&gt; Self.SubSequence<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; We also provide lazy versions:<br>&gt; &gt;<br>&gt; &gt; extension LazySequenceType {<br>&gt; &gt;     func scan&lt;T&gt;(initial: T, combine: (T, Self.Generator.Element) -&gt; T)<br>&gt; -&gt; LazyScanSequence&lt;Self.Elements, T&gt;<br>&gt; &gt;     func dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>&gt; LazyDropWhileSequence&lt;Self.Elements&gt;<br>&gt; &gt;     func takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>&gt; LazyTakeWhileSequence&lt;Self.Elements&gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; extension LazyCollectionType {<br>&gt; &gt;     func dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>&gt; LazyDropWhileCollection&lt;Self.Elements&gt;<br>&gt; &gt;     func takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>&gt; LazyTakeWhileCollection&lt;Self.Elements&gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; No collection variant of scan is provided because that would require<br>&gt; storing the last value in the index itself, which would cause problems if<br>&gt; the combine function isn&#39;t pure.<br>&gt; &gt;<br>&gt; &gt; LazyDropWhileCollection would behave similarly to LazyFilterCollection<br>&gt; in that it runs the predicate against the elements to drop when accessing<br>&gt; startIndex; unlike LazyFilterCollection, because there&#39;s nothing else to<br>&gt; skip after that point, the index itself can actually be Self.Elements.Index<br>&gt; (just like a slice). LazyTakeWhileCollection also runs the predicate<br>&gt; against the first element when accessing startIndex, but it does need a<br>&gt; unique index type (because endIndex has to be some sentinel value, as it<br>&gt; doesn&#39;t know where the end is until you reach that point; this index type<br>&gt; would therefore only conform to ForwardIndexType).<br>&gt; &gt;<br>&gt; &gt; And finally, we provide a global function<br>&gt; &gt;<br>&gt; &gt; func iterate&lt;T&gt;(initial: T, _ f: T -&gt; T) -&gt; IterateSequence&lt;T&gt;<br>&gt; &gt;<br>&gt; &gt; This function is inherently lazy and yields an infinite list of nested<br>&gt; applications of the function, so iterate(x, f) yields a sequence like [x,<br>&gt; f(x), f(f(x)), ...].<br>&gt; &gt;<br>&gt; &gt; -Kevin Ballard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/9e073986/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January 10, 2016 at 10:00:00pm</p></header><div class="content"><p>Sounds like you want usage examples, then. Are the ones I gave useful?<br></p><p>-Kevin Ballard<br></p><p>On Sun, Jan 10, 2016, at 10:26 PM, Seth Friedman wrote:<br>&gt; I wasn&#39;t suggesting you should convince the reviewers of the merits of<br>&gt; functional style programming. I&#39;m coming at it from the perspective of<br>&gt; &quot;Hey I&#39;m not very familiar with functional style. What cool new things<br>&gt; could these functions help me do if they&#39;re added to the stdlib?&quot;.<br>&gt;<br>&gt; Not all of your reviewers are necessarily going to be familiar with<br>&gt; these functions from other languages; I simply think more detail would<br>&gt; make the proposal more compelling. Ultimately up to you.<br>&gt;<br>&gt; Thanks, Seth On Sun, Jan 10, 2016 at 10:20 PM Kevin Ballard<br>&gt; &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt; When the proposal is &quot;we have a bunch of functions that match<br>&gt;&gt; functions used in other languages, lets add a few more from the same<br>&gt;&gt; category of functions that we missed&quot;, does there really need to be<br>&gt;&gt; much explanation beyond &quot;they&#39;re useful in the other languages that<br>&gt;&gt; have them, they&#39;d be useful for the same reasons in Swift&quot;?<br>&gt;&gt;<br>&gt;&gt; If requested, I can provide examples of usage. But if you&#39;re not<br>&gt;&gt; already sold on the benefits of working with sequences in a<br>&gt;&gt; functional manner, it&#39;s out of scope of the proposal to convince you<br>&gt;&gt; of the merits of that style of programming. And if you are already<br>&gt;&gt; sold on the benefits of doing so, then adding these functions<br>&gt;&gt; shouldn&#39;t need much explanation.<br>&gt;&gt;<br>&gt;&gt; Here&#39;s a few toy examples, if it helps:<br>&gt;&gt;<br>&gt;&gt; // list of all powers of 2 below some limit iterate(1, apply: { $0 *<br>&gt;&gt; 2 }).takeWhile({ $0 &lt; limit })<br>&gt;&gt;<br>&gt;&gt; // first &quot;word&quot; of a string, skipping whitespace let cs =<br>&gt;&gt; NSCharacterSet.whitespaceCharacterSet()<br>&gt;&gt; String(str.unicodeScalars.skipWhile({<br>&gt;&gt; cs.longCharacterIsMember($0.value) })<br>&gt;&gt; .takeWhile({ !cs.longCharacterIsMember($0.value) }))<br>&gt;&gt;<br>&gt;&gt; // running total of an array of numbers numbers.scan(, combine:<br>&gt;&gt; +).dropFirst()<br>&gt;&gt;<br>&gt;&gt; // infinite fibonacci sequence iterate((,1), apply: { ($1, $0+$1)<br>&gt;&gt; }).lazy.map({$1})<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt; On Sun, Jan 10, 2016, at 09:55 PM, Seth Friedman wrote:<br>&gt;&gt;&gt; To clear my thoughts up a bit, that wasn&#39;t an &quot;I&#39;m too lazy to<br>&gt;&gt;&gt; Google what these functions normally do&quot; comment, but rather an &quot;I<br>&gt;&gt;&gt; believe proposals should provide as much context as possible about<br>&gt;&gt;&gt; what you&#39;d like to add along with the benefits of doing so&quot; comment.<br>&gt;&gt;&gt; On Sun, Jan 10, 2016 at 9:48 PM Seth Friedman &lt;sethfri at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; I&#39;m not familiar with any of the functions listed and would love to<br>&gt;&gt;&gt;&gt; see more about them and their usefulness to Swift as part of the<br>&gt;&gt;&gt;&gt; proposal.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Seth On Sat, Jan 9, 2016 at 5:30 PM Kevin Ballard via swift-<br>&gt;&gt;&gt;&gt; evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Proposal PR submitted as<br>&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/pull/95<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Mon, Dec 28, 2015, at 03:59 PM, Kevin Ballard wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt; ## Introduction<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Add a few more functional sequence utilities to the standard<br>&gt;&gt;&gt;&gt;&gt; &gt; library.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; ## Motivation<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; We have map, filter, and reduce, but we&#39;re missing a bunch of<br>&gt;&gt;&gt;&gt;&gt; &gt; useful utilities like scan, iterate, takeWhile, and dropWhile.<br>&gt;&gt;&gt;&gt;&gt; &gt; Interestingly, the stdlib includes an implementation of scan in<br>&gt;&gt;&gt;&gt;&gt; &gt; the doc comment for LazySequenceType, it just doesn&#39;t actually<br>&gt;&gt;&gt;&gt;&gt; &gt; provide it as API.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; ## Proposed solution<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; We extend SequenceType with 3 new methods scan, takeWhile, and<br>&gt;&gt;&gt;&gt;&gt; &gt; dropWhile. We also add a single global function iterate.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; ## Detailed design<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; We add the following extension to SequenceType:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; extension SequenceType {     func scan&lt;T&gt;(initial: T, @noescape<br>&gt;&gt;&gt;&gt;&gt; &gt; combine: (T, Self.Generator.Element) throws -&gt; T) rethrows -&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; [T]     func dropWhile(@noescape dropElement:<br>&gt;&gt;&gt;&gt;&gt; &gt; (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; [Self.Generator.Element]     func takeWhile(@noescape<br>&gt;&gt;&gt;&gt;&gt; &gt; takeElement: (Self.Generator.Element) throws -&gt; Bool) rethrows<br>&gt;&gt;&gt;&gt;&gt; &gt; -&gt; [Self.Generator.Element] }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; These all take functions, so to follow convention they&#39;re<br>&gt;&gt;&gt;&gt;&gt; &gt; @noescape and return arrays. We also provide an extension of<br>&gt;&gt;&gt;&gt;&gt; &gt; CollectionType that overrides a couple of these methods:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; extension CollectionType {     func dropWhile(@noescape<br>&gt;&gt;&gt;&gt;&gt; &gt; dropElement: (Self.Generator.Element) throws -&gt; Bool) rethrows<br>&gt;&gt;&gt;&gt;&gt; &gt; -&gt; Self.SubSequence     func takeWhile(@noescape takeElement:<br>&gt;&gt;&gt;&gt;&gt; &gt; (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Self.SubSequence }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; We also provide lazy versions:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; extension LazySequenceType {     func scan&lt;T&gt;(initial: T,<br>&gt;&gt;&gt;&gt;&gt; &gt; combine: (T, Self.Generator.Element) -&gt; T) -&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; LazyScanSequence&lt;Self.Elements, T&gt;     func<br>&gt;&gt;&gt;&gt;&gt; &gt; dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; LazyDropWhileSequence&lt;Self.Elements&gt;     func<br>&gt;&gt;&gt;&gt;&gt; &gt; takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; LazyTakeWhileSequence&lt;Self.Elements&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; extension LazyCollectionType {     func dropWhile(dropElement:<br>&gt;&gt;&gt;&gt;&gt; &gt; (Self.Generator.Element) -&gt; Bool) -&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; LazyDropWhileCollection&lt;Self.Elements&gt;     func<br>&gt;&gt;&gt;&gt;&gt; &gt; takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; LazyTakeWhileCollection&lt;Self.Elements&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; No collection variant of scan is provided because that would<br>&gt;&gt;&gt;&gt;&gt; &gt; require storing the last value in the index itself, which would<br>&gt;&gt;&gt;&gt;&gt; &gt; cause problems if the combine function isn&#39;t pure.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; LazyDropWhileCollection would behave similarly to<br>&gt;&gt;&gt;&gt;&gt; &gt; LazyFilterCollection in that it runs the predicate against the<br>&gt;&gt;&gt;&gt;&gt; &gt; elements to drop when accessing startIndex; unlike<br>&gt;&gt;&gt;&gt;&gt; &gt; LazyFilterCollection, because there&#39;s nothing else to skip after<br>&gt;&gt;&gt;&gt;&gt; &gt; that point, the index itself can actually be Self.Elements.Index<br>&gt;&gt;&gt;&gt;&gt; &gt; (just like a slice). LazyTakeWhileCollection also runs the<br>&gt;&gt;&gt;&gt;&gt; &gt; predicate against the first element when accessing startIndex,<br>&gt;&gt;&gt;&gt;&gt; &gt; but it does need a unique index type (because endIndex has to be<br>&gt;&gt;&gt;&gt;&gt; &gt; some sentinel value, as it doesn&#39;t know where the end is until<br>&gt;&gt;&gt;&gt;&gt; &gt; you reach that point; this index type would therefore only<br>&gt;&gt;&gt;&gt;&gt; &gt; conform to ForwardIndexType).<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; And finally, we provide a global function<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; func iterate&lt;T&gt;(initial: T, _ f: T -&gt; T) -&gt; IterateSequence&lt;T&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; This function is inherently lazy and yields an infinite list of<br>&gt;&gt;&gt;&gt;&gt; &gt; nested applications of the function, so iterate(x, f) yields a<br>&gt;&gt;&gt;&gt;&gt; &gt; sequence like [x, f(x), f(f(x)), ...].<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/572c1d44/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a1faea18be9eb2d50c4edcd223f2d685?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Seth Friedman</string> &lt;sethfri at gmail.com&gt;<p>January 11, 2016 at 06:00:00am</p></header><div class="content"><p>Yes, thank you!<br>On Sun, Jan 10, 2016 at 10:28 PM Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br></p><p>&gt; Sounds like you want usage examples, then. Are the ones I gave useful?<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Sun, Jan 10, 2016, at 10:26 PM, Seth Friedman wrote:<br>&gt;<br>&gt; I wasn&#39;t suggesting you should convince the reviewers of the merits of<br>&gt; functional style programming. I&#39;m coming at it from the perspective of &quot;Hey<br>&gt; I&#39;m not very familiar with functional style. What cool new things could<br>&gt; these functions help me do if they&#39;re added to the stdlib?&quot;.<br>&gt;<br>&gt; Not all of your reviewers are necessarily going to be familiar with these<br>&gt; functions from other languages; I simply think more detail would make the<br>&gt; proposal more compelling. Ultimately up to you.<br>&gt;<br>&gt; Thanks,<br>&gt; Seth<br>&gt; On Sun, Jan 10, 2016 at 10:20 PM Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;<br>&gt; When the proposal is &quot;we have a bunch of functions that match functions<br>&gt; used in other languages, lets add a few more from the same category of<br>&gt; functions that we missed&quot;, does there really need to be much explanation<br>&gt; beyond &quot;they&#39;re useful in the other languages that have them, they&#39;d be<br>&gt; useful for the same reasons in Swift&quot;?<br>&gt;<br>&gt; If requested, I can provide examples of usage. But if you&#39;re not already<br>&gt; sold on the benefits of working with sequences in a functional manner, it&#39;s<br>&gt; out of scope of the proposal to convince you of the merits of that style of<br>&gt; programming. And if you are already sold on the benefits of doing so, then<br>&gt; adding these functions shouldn&#39;t need much explanation.<br>&gt;<br>&gt; Here&#39;s a few toy examples, if it helps:<br>&gt;<br>&gt; // list of all powers of 2 below some limit<br>&gt; iterate(1, apply: { $0 * 2 }).takeWhile({ $0 &lt; limit })<br>&gt;<br>&gt; // first &quot;word&quot; of a string, skipping whitespace<br>&gt; let cs = NSCharacterSet.whitespaceCharacterSet()<br>&gt; String(str.unicodeScalars.skipWhile({ cs.longCharacterIsMember($0.value) })<br>&gt;                          .takeWhile({ !cs.longCharacterIsMember($0.value)<br>&gt; }))<br>&gt;<br>&gt; // running total of an array of numbers<br>&gt; numbers.scan(0, combine: +).dropFirst()<br>&gt;<br>&gt; // infinite fibonacci sequence<br>&gt; iterate((0,1), apply: { ($1, $0+$1) }).lazy.map({$1})<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Sun, Jan 10, 2016, at 09:55 PM, Seth Friedman wrote:<br>&gt;<br>&gt; To clear my thoughts up a bit, that wasn&#39;t an &quot;I&#39;m too lazy to Google what<br>&gt; these functions normally do&quot; comment, but rather an &quot;I believe proposals<br>&gt; should provide as much context as possible about what you&#39;d like to add<br>&gt; along with the benefits of doing so&quot; comment.<br>&gt; On Sun, Jan 10, 2016 at 9:48 PM Seth Friedman &lt;sethfri at gmail.com&gt; wrote:<br>&gt;<br>&gt; I&#39;m not familiar with any of the functions listed and would love to see<br>&gt; more about them and their usefulness to Swift as part of the proposal.<br>&gt;<br>&gt; Thanks!<br>&gt;<br>&gt; Seth<br>&gt; On Sat, Jan 9, 2016 at 5:30 PM Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Proposal PR submitted as https://github.com/apple/swift-evolution/pull/95<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Mon, Dec 28, 2015, at 03:59 PM, Kevin Ballard wrote:<br>&gt; &gt; ## Introduction<br>&gt; &gt;<br>&gt; &gt; Add a few more functional sequence utilities to the standard library.<br>&gt; &gt;<br>&gt; &gt; ## Motivation<br>&gt; &gt;<br>&gt; &gt; We have map, filter, and reduce, but we&#39;re missing a bunch of useful<br>&gt; utilities like scan, iterate, takeWhile, and dropWhile. Interestingly, the<br>&gt; stdlib includes an implementation of scan in the doc comment for<br>&gt; LazySequenceType, it just doesn&#39;t actually provide it as API.<br>&gt; &gt;<br>&gt; &gt; ## Proposed solution<br>&gt; &gt;<br>&gt; &gt; We extend SequenceType with 3 new methods scan, takeWhile, and<br>&gt; dropWhile. We also add a single global function iterate.<br>&gt; &gt;<br>&gt; &gt; ## Detailed design<br>&gt; &gt;<br>&gt; &gt; We add the following extension to SequenceType:<br>&gt; &gt;<br>&gt; &gt; extension SequenceType {<br>&gt; &gt;     func scan&lt;T&gt;(initial: T, @noescape combine: (T,<br>&gt; Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt; &gt;     func dropWhile(@noescape dropElement: (Self.Generator.Element)<br>&gt; throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt; &gt;     func takeWhile(@noescape takeElement: (Self.Generator.Element)<br>&gt; throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; These all take functions, so to follow convention they&#39;re @noescape and<br>&gt; return arrays. We also provide an extension of CollectionType that<br>&gt; overrides a couple of these methods:<br>&gt; &gt;<br>&gt; &gt; extension CollectionType {<br>&gt; &gt;     func dropWhile(@noescape dropElement: (Self.Generator.Element)<br>&gt; throws -&gt; Bool) rethrows -&gt; Self.SubSequence<br>&gt; &gt;     func takeWhile(@noescape takeElement: (Self.Generator.Element)<br>&gt; throws -&gt; Bool) rethrows -&gt; Self.SubSequence<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; We also provide lazy versions:<br>&gt; &gt;<br>&gt; &gt; extension LazySequenceType {<br>&gt; &gt;     func scan&lt;T&gt;(initial: T, combine: (T, Self.Generator.Element) -&gt; T)<br>&gt; -&gt; LazyScanSequence&lt;Self.Elements, T&gt;<br>&gt; &gt;     func dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>&gt; LazyDropWhileSequence&lt;Self.Elements&gt;<br>&gt; &gt;     func takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>&gt; LazyTakeWhileSequence&lt;Self.Elements&gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; extension LazyCollectionType {<br>&gt; &gt;     func dropWhile(dropElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>&gt; LazyDropWhileCollection&lt;Self.Elements&gt;<br>&gt; &gt;     func takeWhile(takeElement: (Self.Generator.Element) -&gt; Bool) -&gt;<br>&gt; LazyTakeWhileCollection&lt;Self.Elements&gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; No collection variant of scan is provided because that would require<br>&gt; storing the last value in the index itself, which would cause problems if<br>&gt; the combine function isn&#39;t pure.<br>&gt; &gt;<br>&gt; &gt; LazyDropWhileCollection would behave similarly to LazyFilterCollection<br>&gt; in that it runs the predicate against the elements to drop when accessing<br>&gt; startIndex; unlike LazyFilterCollection, because there&#39;s nothing else to<br>&gt; skip after that point, the index itself can actually be Self.Elements.Index<br>&gt; (just like a slice). LazyTakeWhileCollection also runs the predicate<br>&gt; against the first element when accessing startIndex, but it does need a<br>&gt; unique index type (because endIndex has to be some sentinel value, as it<br>&gt; doesn&#39;t know where the end is until you reach that point; this index type<br>&gt; would therefore only conform to ForwardIndexType).<br>&gt; &gt;<br>&gt; &gt; And finally, we provide a global function<br>&gt; &gt;<br>&gt; &gt; func iterate&lt;T&gt;(initial: T, _ f: T -&gt; T) -&gt; IterateSequence&lt;T&gt;<br>&gt; &gt;<br>&gt; &gt; This function is inherently lazy and yields an infinite list of nested<br>&gt; applications of the function, so iterate(x, f) yields a sequence like [x,<br>&gt; f(x), f(f(x)), ...].<br>&gt; &gt;<br>&gt; &gt; -Kevin Ballard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/70322313/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 11, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 10, 2016, at 10:20 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; When the proposal is &quot;we have a bunch of functions that match functions used in other languages, lets add a few more from the same category of functions that we missed&quot;, does there really need to be much explanation beyond &quot;they&#39;re useful in the other languages that have them, they&#39;d be useful for the same reasons in Swift”?<br></p><p>I agree with what you’re saying, but the flip-side is: how do we scope what we accept into the standard library?  Just existing in some other language doesn’t mean that we should (automatically) accept new standard library functionality.<br></p><p>I’m not arguing for or against your proposal, just trying to say that this rationale isn’t enough to justify adding things to the Swift standard library.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 11, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 7:11 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 10, 2016, at 10:20 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; When the proposal is &quot;we have a bunch of functions that match functions used in other languages, lets add a few more from the same category of functions that we missed&quot;, does there really need to be much explanation beyond &quot;they&#39;re useful in the other languages that have them, they&#39;d be useful for the same reasons in Swift”?<br>&gt; <br>&gt; I agree with what you’re saying, but the flip-side is: how do we scope what we accept into the standard library?  Just existing in some other language doesn’t mean that we should (automatically) accept new standard library functionality.<br>&gt; <br>&gt; I’m not arguing for or against your proposal, just trying to say that this rationale isn’t enough to justify adding things to the Swift standard library.<br></p><p>I agree.  <br></p><p>Something I would like to see in the longer term is a set of libraries outside the standard library, but still going through a community review process for their evolution.  They would be given an “official” stamp of approval and would be hosted in community repos, but accessed via SPM rather than part of the core install.  This would allow us to keep the core library lean, but still offer a “batteries included” approach.  <br></p><p>Matthew<br></p><p>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 11, 2016 at 05:00:00pm</p></header><div class="content"><p>On Mon, Jan 11, 2016 at 5:18 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jan 11, 2016, at 7:11 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Jan 10, 2016, at 10:20 PM, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; When the proposal is &quot;we have a bunch of functions that match functions<br>&gt; used in other languages, lets add a few more from the same category of<br>&gt; functions that we missed&quot;, does there really need to be much explanation<br>&gt; beyond &quot;they&#39;re useful in the other languages that have them, they&#39;d be<br>&gt; useful for the same reasons in Swift”?<br>&gt; &gt;<br>&gt; &gt; I agree with what you’re saying, but the flip-side is: how do we scope<br>&gt; what we accept into the standard library?  Just existing in some other<br>&gt; language doesn’t mean that we should (automatically) accept new standard<br>&gt; library functionality.<br>&gt; &gt;<br>&gt; &gt; I’m not arguing for or against your proposal, just trying to say that<br>&gt; this rationale isn’t enough to justify adding things to the Swift standard<br>&gt; library.<br>&gt;<br>&gt; I agree.<br>&gt;<br>&gt; Something I would like to see in the longer term is a set of libraries<br>&gt; outside the standard library, but still going through a community review<br>&gt; process for their evolution.  They would be given an “official” stamp of<br>&gt; approval and would be hosted in community repos, but accessed via SPM<br>&gt; rather than part of the core install.  This would allow us to keep the core<br>&gt; library lean, but still offer a “batteries included” approach.<br>&gt;<br></p><p>This might be a good place for things like Either, Deque, etc.<br></p><p><br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt; &gt;<br>&gt; &gt; -Chris<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/c769ede3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 11, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 7:21 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Mon, Jan 11, 2016 at 5:18 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Jan 11, 2016, at 7:11 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Jan 10, 2016, at 10:20 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; When the proposal is &quot;we have a bunch of functions that match functions used in other languages, lets add a few more from the same category of functions that we missed&quot;, does there really need to be much explanation beyond &quot;they&#39;re useful in the other languages that have them, they&#39;d be useful for the same reasons in Swift”?<br>&gt; &gt;<br>&gt; &gt; I agree with what you’re saying, but the flip-side is: how do we scope what we accept into the standard library?  Just existing in some other language doesn’t mean that we should (automatically) accept new standard library functionality.<br>&gt; &gt;<br>&gt; &gt; I’m not arguing for or against your proposal, just trying to say that this rationale isn’t enough to justify adding things to the Swift standard library.<br>&gt; <br>&gt; I agree.<br>&gt; <br>&gt; Something I would like to see in the longer term is a set of libraries outside the standard library, but still going through a community review process for their evolution.  They would be given an “official” stamp of approval and would be hosted in community repos, but accessed via SPM rather than part of the core install.  This would allow us to keep the core library lean, but still offer a “batteries included” approach.<br>&gt; <br>&gt; This might be a good place for things like Either, Deque, etc.<br></p><p>Deque sure and maybe Either.  But if we’re going to get an Either that is really a Result I would prefer to see that in the standard library and integrated with the error handling system (i.e. allow us to call a throwing function without `try` and receive a Result wrapping the return value, etc).<br></p><p>&gt;  <br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt; &gt;<br>&gt; &gt; -Chris<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/12e2de14/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>January 13, 2016 at 08:00:00pm</p></header><div class="content"><p>The dropWhile sounds weird to me, I usually would see such functionality as a dropUntil; I discard stuff until I see what I want.<br>Your example below doesn’t use dropWhile, but skipWhile; which sounds a bit better that dropWhile as one skip what he doesn’t want.<br></p><p>What do the other languages use? A dropWhile, skipWhile or dropUntil concept?<br></p><p>Dany<br></p><p><br>&gt; Le 11 janv. 2016 à 01:20, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Here&#39;s a few toy examples, if it helps:<br>&gt; <br>&gt; // list of all powers of 2 below some limit<br>&gt; iterate(1, apply: { $0 * 2 }).takeWhile({ $0 &lt; limit })<br>&gt; <br>&gt; // first &quot;word&quot; of a string, skipping whitespace<br>&gt; let cs = NSCharacterSet.whitespaceCharacterSet()<br>&gt; String(str.unicodeScalars.skipWhile({ cs.longCharacterIsMember($0.value) })<br>&gt;                          .takeWhile({ !cs.longCharacterIsMember($0.value) }))<br>&gt; <br>&gt; // running total of an array of numbers<br>&gt; numbers.scan(0, combine: +).dropFirst()<br>&gt; <br>&gt; // infinite fibonacci sequence<br>&gt; iterate((0,1), apply: { ($1, $0+$1) }).lazy.map({$1})<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt;&gt; On Mon, Dec 28, 2015, at 03:59 PM, Kevin Ballard wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ## Detailed design<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; We add the following extension to SequenceType:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; extension SequenceType {<br>&gt;&gt; &gt;     func scan&lt;T&gt;(initial: T, @noescape combine: (T, Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt;&gt; &gt;     func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt;&gt; &gt;     func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/d93b6773/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7ba3c93f9350613c243eeb87c602935e?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>David Smith</string> &lt;david_smith at apple.com&gt;<p>January 13, 2016 at 06:00:00pm</p></header><div class="content"><p>Naming conventions would suggest that something returning a new collection should be named with a noun phrase describing what it returns. Unfortunately, most of the ones I can think of off the top of my head are fairly clunky. &quot;suffixFromFirstNonMatchingElement&quot; describes what it does, but I haven&#39;t thought of a non-painful way to say that yet. &quot;suffixExcluding&quot; is almost right, but it incorrectly implies (to my eye at least) that the returned collection excludes all elements matching the predicate, rather than just matching prefixes. Hm, what about flipping the predicate and getting a &quot;suffixFrom&quot; overload that takes a predicate for the first matching element to be included, rather than the last matching element to be excluded?<br></p><p>	David<br></p><p>&gt; On Jan 13, 2016, at 5:54 PM, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The dropWhile sounds weird to me, I usually would see such functionality as a dropUntil; I discard stuff until I see what I want.<br>&gt; Your example below doesn’t use dropWhile, but skipWhile; which sounds a bit better that dropWhile as one skip what he doesn’t want.<br>&gt; <br>&gt; What do the other languages use? A dropWhile, skipWhile or dropUntil concept?<br>&gt; <br>&gt; Dany<br>&gt; <br>&gt; <br>&gt;&gt; Le 11 janv. 2016 à 01:20, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Here&#39;s a few toy examples, if it helps:<br>&gt;&gt; <br>&gt;&gt; // list of all powers of 2 below some limit<br>&gt;&gt; iterate(1, apply: { $0 * 2 }).takeWhile({ $0 &lt; limit })<br>&gt;&gt; <br>&gt;&gt; // first &quot;word&quot; of a string, skipping whitespace<br>&gt;&gt; let cs = NSCharacterSet.whitespaceCharacterSet()<br>&gt;&gt; String(str.unicodeScalars.skipWhile({ cs.longCharacterIsMember($0.value) })<br>&gt;&gt;                          .takeWhile({ !cs.longCharacterIsMember($0.value) }))<br>&gt;&gt; <br>&gt;&gt; // running total of an array of numbers<br>&gt;&gt; numbers.scan(0, combine: +).dropFirst()<br>&gt;&gt; <br>&gt;&gt; // infinite fibonacci sequence<br>&gt;&gt; iterate((0,1), apply: { ($1, $0+$1) }).lazy.map({$1})<br>&gt;&gt; <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt; <br>&gt;&gt;&gt; On Mon, Dec 28, 2015, at 03:59 PM, Kevin Ballard wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; ## Detailed design<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; We add the following extension to SequenceType:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; extension SequenceType {<br>&gt;&gt;&gt; &gt;     func scan&lt;T&gt;(initial: T, @noescape combine: (T, Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt;&gt;&gt; &gt;     func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt;&gt;&gt; &gt;     func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/4d1c21de/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7ba3c93f9350613c243eeb87c602935e?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>David Smith</string> &lt;david_smith at apple.com&gt;<p>January 13, 2016 at 08:00:00pm</p></header><div class="content"><p>Rob Rix pointed out that &quot;suffixAfter&quot; would meet all my original criteria. Not sure if keeping the original &quot;match the stuff to drop rather than the stuff to keep&quot; semantics are critical, but this gives us an option for either way 😊<br></p><p>    David<br></p><p>&gt; On Jan 13, 2016, at 6:40 PM, David Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Naming conventions would suggest that something returning a new collection should be named with a noun phrase describing what it returns. Unfortunately, most of the ones I can think of off the top of my head are fairly clunky. &quot;suffixFromFirstNonMatchingElement&quot; describes what it does, but I haven&#39;t thought of a non-painful way to say that yet. &quot;suffixExcluding&quot; is almost right, but it incorrectly implies (to my eye at least) that the returned collection excludes all elements matching the predicate, rather than just matching prefixes. Hm, what about flipping the predicate and getting a &quot;suffixFrom&quot; overload that takes a predicate for the first matching element to be included, rather than the last matching element to be excluded?<br>&gt; <br>&gt; 	David<br>&gt; <br>&gt;&gt; On Jan 13, 2016, at 5:54 PM, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The dropWhile sounds weird to me, I usually would see such functionality as a dropUntil; I discard stuff until I see what I want.<br>&gt;&gt; Your example below doesn’t use dropWhile, but skipWhile; which sounds a bit better that dropWhile as one skip what he doesn’t want.<br>&gt;&gt; <br>&gt;&gt; What do the other languages use? A dropWhile, skipWhile or dropUntil concept?<br>&gt;&gt; <br>&gt;&gt; Dany<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Le 11 janv. 2016 à 01:20, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here&#39;s a few toy examples, if it helps:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // list of all powers of 2 below some limit<br>&gt;&gt;&gt; iterate(1, apply: { $0 * 2 }).takeWhile({ $0 &lt; limit })<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // first &quot;word&quot; of a string, skipping whitespace<br>&gt;&gt;&gt; let cs = NSCharacterSet.whitespaceCharacterSet()<br>&gt;&gt;&gt; String(str.unicodeScalars.skipWhile({ cs.longCharacterIsMember($0.value) })<br>&gt;&gt;&gt;                          .takeWhile({ !cs.longCharacterIsMember($0.value) }))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // running total of an array of numbers<br>&gt;&gt;&gt; numbers.scan(0, combine: +).dropFirst()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // infinite fibonacci sequence<br>&gt;&gt;&gt; iterate((0,1), apply: { ($1, $0+$1) }).lazy.map({$1})<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mon, Dec 28, 2015, at 03:59 PM, Kevin Ballard wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; ## Detailed design<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; We add the following extension to SequenceType:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; extension SequenceType {<br>&gt;&gt;&gt;&gt; &gt;     func scan&lt;T&gt;(initial: T, @noescape combine: (T, Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt;&gt;&gt;&gt; &gt;     func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt;&gt;&gt;&gt; &gt;     func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/8cc58937/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January 13, 2016 at 11:00:00pm</p></header><div class="content"><p>&quot;suffixAfter&quot; sounds like the equivalent of dropFirst(_:), i.e. it sounds like it should take a count of elements to skip. Similarly, actually trying an expression that takes a predicate looks weird:<br></p><p>seq.suffixAfter({ isspace($0) })<br></p><p>Even knowing what it&#39;s supposed to do, it&#39;s hard for me to read that<br>expression in any sensible fashion.<br></p><p>Also, I&#39;m not sure the &quot;noun phrase&quot; convention really makes sense for<br>SequenceType methods. They&#39;re not technically mutating methods, but single-<br>pass collections are in fact destructively mutated by Array-returning<br>sequence methods (and the methods that return SubSequence also<br>destructively mutate upon any access to the returned subsequence). Which<br>is to say, despite not being marked as &quot;mutating&quot;, they do in fact<br>behave like mutating methods for single-pass sequences. Which suggests<br>that verb phrases are perfectly fine.<br></p><p>-Kevin Ballard<br></p><p>On Wed, Jan 13, 2016, at 08:36 PM, David Smith via swift-evolution wrote:<br>&gt;<br>&gt; Rob Rix pointed out that &quot;suffixAfter&quot; would meet all my original<br>&gt; criteria. Not sure if keeping the original &quot;match the stuff to drop<br>&gt; rather than the stuff to keep&quot; semantics are critical, but this gives<br>&gt; us an option for either way 😊<br>&gt;<br>&gt; David<br>&gt;<br>&gt; On Jan 13, 2016, at 6:40 PM, David Smith via swift-evolution &lt;swift-<br>&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt; Naming conventions would suggest that something returning a new<br>&gt;&gt; collection should be named with a noun phrase describing what it<br>&gt;&gt; returns. Unfortunately, most of the ones I can think of off the top<br>&gt;&gt; of my head are fairly clunky. &quot;suffixFromFirstNonMatchingElement&quot;<br>&gt;&gt; describes what it does, but I haven&#39;t thought of a non-painful way to<br>&gt;&gt; say that yet. &quot;suffixExcluding&quot; is almost right, but it incorrectly<br>&gt;&gt; implies (to my eye at least) that the returned collection excludes<br>&gt;&gt; all elements matching the predicate, rather than just matching<br>&gt;&gt; prefixes. Hm, what about flipping the predicate and getting a<br>&gt;&gt; &quot;suffixFrom&quot; overload that takes a predicate for the first matching<br>&gt;&gt; element to be included, rather than the last matching element to be<br>&gt;&gt; excluded?<br>&gt;&gt;<br>&gt;&gt; David<br>&gt;&gt;<br>&gt;&gt;&gt; On Jan 13, 2016, at 5:54 PM, Dany St-Amant via swift-evolution &lt;swift-<br>&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The dropWhile sounds weird to me, I usually would see such<br>&gt;&gt;&gt; functionality as a dropUntil; I discard stuff until I see what I<br>&gt;&gt;&gt; want. Your example below doesn’t use dropWhile, but skipWhile; which<br>&gt;&gt;&gt; sounds a bit better that dropWhile as one skip what he doesn’t want.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What do the other languages use? A dropWhile, skipWhile or dropUntil<br>&gt;&gt;&gt; concept?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Dany<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Le 11 janv. 2016 à 01:20, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt; evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Here&#39;s a few toy examples, if it helps:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // list of all powers of 2 below some limit iterate(1, apply: { $0<br>&gt;&gt;&gt;&gt; * 2 }).takeWhile({ $0 &lt; limit })<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // first &quot;word&quot; of a string, skipping whitespace let cs =<br>&gt;&gt;&gt;&gt; NSCharacterSet.whitespaceCharacterSet()<br>&gt;&gt;&gt;&gt; String(str.unicodeScalars.skipWhile({<br>&gt;&gt;&gt;&gt; cs.longCharacterIsMember($0.value) })<br>&gt;&gt;&gt;&gt; .takeWhile({ !cs.longCharacterIsMember($0.value) }))<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // running total of an array of numbers numbers.scan(, combine:<br>&gt;&gt;&gt;&gt; +).dropFirst()<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // infinite fibonacci sequence iterate((,1), apply: { ($1, $0+$1)<br>&gt;&gt;&gt;&gt; }).lazy.map({$1})<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 28, 2015, at 03:59 PM, Kevin Ballard wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; ## Detailed design<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; We add the following extension to SequenceType:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; extension SequenceType {     func scan&lt;T&gt;(initial: T,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; @noescape combine: (T, Self.Generator.Element) throws -&gt; T)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; rethrows -&gt; [T]     func dropWhile(@noescape dropElement:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; [Self.Generator.Element]     func takeWhile(@noescape<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; takeElement: (Self.Generator.Element) throws -&gt; Bool) rethrows<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; -&gt; [Self.Generator.Element] }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/96ee8d47/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7ba3c93f9350613c243eeb87c602935e?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>David Smith</string> &lt;david_smith at apple.com&gt;<p>January 21, 2016 at 02:00:00pm</p></header><div class="content"><p>To be honest these all seem equally &quot;weird&quot; looking to me, so my hope is that it&#39;s just a matter of familiarity 😊 My personal inclination is still that overloading suffixFrom with a predicate-taking variant is the way to go. That way it occupies the same mental slot as the existing suffixFrom method, and all you have to decide when using it is &quot;do I want to specify where to suffix from, or how to find where to suffix from?&quot;. e.g. it basically becomes sugar that turns<br></p><p>let idx = foo.indexOf { … }<br>let suffix = foo.suffixFrom(idx)<br></p><p>into<br></p><p>let suffix = foo.suffixFrom { … }<br></p><p>with the bonus feature that it works on single-pass sequences.<br></p><p>	David<br></p><p>&gt; On Jan 13, 2016, at 11:52 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &quot;suffixAfter&quot; sounds like the equivalent of dropFirst(_:), i.e. it sounds like it should take a count of elements to skip. Similarly, actually trying an expression that takes a predicate looks weird:<br>&gt;  <br>&gt;     seq.suffixAfter({ isspace($0) })<br>&gt;  <br>&gt; Even knowing what it&#39;s supposed to do, it&#39;s hard for me to read that expression in any sensible fashion.<br>&gt;  <br>&gt; Also, I&#39;m not sure the &quot;noun phrase&quot; convention really makes sense for SequenceType methods. They&#39;re not technically mutating methods, but single-pass collections are in fact destructively mutated by Array-returning sequence methods (and the methods that return SubSequence also destructively mutate upon any access to the returned subsequence). Which is to say, despite not being marked as &quot;mutating&quot;, they do in fact behave like mutating methods for single-pass sequences. Which suggests that verb phrases are perfectly fine.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; On Wed, Jan 13, 2016, at 08:36 PM, David Smith via swift-evolution wrote:<br>&gt;&gt;  <br>&gt;&gt; Rob Rix pointed out that &quot;suffixAfter&quot; would meet all my original criteria. Not sure if keeping the original &quot;match the stuff to drop rather than the stuff to keep&quot; semantics are critical, but this gives us an option for either way 😊<br>&gt;&gt;  <br>&gt;&gt;     David<br>&gt;&gt;  <br>&gt;&gt; On Jan 13, 2016, at 6:40 PM, David Smith via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Naming conventions would suggest that something returning a new collection should be named with a noun phrase describing what it returns. Unfortunately, most of the ones I can think of off the top of my head are fairly clunky. &quot;suffixFromFirstNonMatchingElement&quot; describes what it does, but I haven&#39;t thought of a non-painful way to say that yet. &quot;suffixExcluding&quot; is almost right, but it incorrectly implies (to my eye at least) that the returned collection excludes all elements matching the predicate, rather than just matching prefixes. Hm, what about flipping the predicate and getting a &quot;suffixFrom&quot; overload that takes a predicate for the first matching element to be included, rather than the last matching element to be excluded?<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; David<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Jan 13, 2016, at 5:54 PM, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; The dropWhile sounds weird to me, I usually would see such functionality as a dropUntil; I discard stuff until I see what I want.<br>&gt;&gt;&gt;&gt; Your example below doesn’t use dropWhile, but skipWhile; which sounds a bit better that dropWhile as one skip what he doesn’t want.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; What do the other languages use? A dropWhile, skipWhile or dropUntil concept?<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Dany<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Le 11 janv. 2016 à 01:20, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Here&#39;s a few toy examples, if it helps:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; // list of all powers of 2 below some limit<br>&gt;&gt;&gt;&gt;&gt; iterate(1, apply: { $0 * 2 }).takeWhile({ $0 &lt; limit })<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; // first &quot;word&quot; of a string, skipping whitespace<br>&gt;&gt;&gt;&gt;&gt; let cs = NSCharacterSet.whitespaceCharacterSet()<br>&gt;&gt;&gt;&gt;&gt; String(str.unicodeScalars.skipWhile({ cs.longCharacterIsMember($0.value) })<br>&gt;&gt;&gt;&gt;&gt;                          .takeWhile({ !cs.longCharacterIsMember($0.value) }))<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; // running total of an array of numbers<br>&gt;&gt;&gt;&gt;&gt; numbers.scan(0, combine: +).dropFirst()<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; // infinite fibonacci sequence<br>&gt;&gt;&gt;&gt;&gt; iterate((0,1), apply: { ($1, $0+$1) }).lazy.map({$1})<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 28, 2015, at 03:59 PM, Kevin Ballard wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; ## Detailed design<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; We add the following extension to SequenceType:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; extension SequenceType {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;     func scan&lt;T&gt;(initial: T, @noescape combine: (T, Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;     func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;     func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/7f74b340/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 22, 2016 at 10:00:00am</p></header><div class="content"><p>+1 to `iterate` and `scan`.<br></p><p>I&#39;m familiar with `takeWhile` from other languages, but I think it doesn&#39;t<br>quite fit with existing library methods.<br>I don&#39;t like the phrasing of `dropFirst` already in the library, I&#39;d prefer<br>something more familiar to `dropWhile`.<br></p><p>Stops when the block returns true, doesn&#39;t include that element:<br></p><p>`prefixUpTo {...}`<br></p><p><br>Starts when the block returns true, includes that element.<br></p><p>`suffixFrom { ... }`<br></p><p><br>So:<br></p><p>array.prefixUpTo(filterFunction) + array.suffixFrom(filterFunction) == array<br></p><p><br></p><p>On Fri, Jan 22, 2016 at 9:57 AM, David Smith via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; To be honest these all seem equally &quot;weird&quot; looking to me, so my hope is<br>&gt; that it&#39;s just a matter of familiarity 😊 My personal inclination is still<br>&gt; that overloading suffixFrom with a predicate-taking variant is the way to<br>&gt; go. That way it occupies the same mental slot as the existing suffixFrom<br>&gt; method, and all you have to decide when using it is &quot;do I want to specify<br>&gt; where to suffix from, or how to find where to suffix from?&quot;. e.g. it<br>&gt; basically becomes sugar that turns<br>&gt;<br>&gt; let idx = foo.indexOf { … }<br>&gt; let suffix = foo.suffixFrom(idx)<br>&gt;<br>&gt; into<br>&gt;<br>&gt; let suffix = foo.suffixFrom { … }<br>&gt;<br>&gt; with the bonus feature that it works on single-pass sequences.<br>&gt;<br>&gt; David<br>&gt;<br>&gt;<br>&gt; On Jan 13, 2016, at 11:52 PM, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &quot;suffixAfter&quot; sounds like the equivalent of dropFirst(_:), i.e. it sounds<br>&gt; like it should take a count of elements to skip. Similarly, actually trying<br>&gt; an expression that takes a predicate looks weird:<br>&gt;<br>&gt;     seq.suffixAfter({ isspace($0) })<br>&gt;<br>&gt; Even knowing what it&#39;s supposed to do, it&#39;s hard for me to read that<br>&gt; expression in any sensible fashion.<br>&gt;<br>&gt; Also, I&#39;m not sure the &quot;noun phrase&quot; convention really makes sense for<br>&gt; SequenceType methods. They&#39;re not technically mutating methods, but<br>&gt; single-pass collections are in fact destructively mutated by<br>&gt; Array-returning sequence methods (and the methods that return SubSequence<br>&gt; also destructively mutate upon any access to the returned subsequence).<br>&gt; Which is to say, despite not being marked as &quot;mutating&quot;, they do in fact<br>&gt; behave like mutating methods for single-pass sequences. Which suggests that<br>&gt; verb phrases are perfectly fine.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Wed, Jan 13, 2016, at 08:36 PM, David Smith via swift-evolution wrote:<br>&gt;<br>&gt;<br>&gt; Rob Rix pointed out that &quot;suffixAfter&quot; would meet all my original<br>&gt; criteria. Not sure if keeping the original &quot;match the stuff to drop rather<br>&gt; than the stuff to keep&quot; semantics are critical, but this gives us an option<br>&gt; for either way 😊<br>&gt;<br>&gt;     David<br>&gt;<br>&gt; On Jan 13, 2016, at 6:40 PM, David Smith via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Naming conventions would suggest that something returning a new collection<br>&gt; should be named with a noun phrase describing what it returns.<br>&gt; Unfortunately, most of the ones I can think of off the top of my head are<br>&gt; fairly clunky. &quot;suffixFromFirstNonMatchingElement&quot; describes what it does,<br>&gt; but I haven&#39;t thought of a non-painful way to say that yet.<br>&gt; &quot;suffixExcluding&quot; is almost right, but it incorrectly implies (to my eye at<br>&gt; least) that the returned collection excludes all elements matching the<br>&gt; predicate, rather than just matching prefixes. Hm, what about flipping the<br>&gt; predicate and getting a &quot;suffixFrom&quot; overload that takes a predicate for<br>&gt; the first matching element to be included, rather than the last matching<br>&gt; element to be excluded?<br>&gt;<br>&gt; David<br>&gt;<br>&gt;<br>&gt; On Jan 13, 2016, at 5:54 PM, Dany St-Amant via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; The dropWhile sounds weird to me, I usually would see such functionality<br>&gt; as a dropUntil; I discard stuff until I see what I want.<br>&gt; Your example below doesn’t use dropWhile, but skipWhile; which sounds a<br>&gt; bit better that dropWhile as one skip what he doesn’t want.<br>&gt;<br>&gt; What do the other languages use? A dropWhile, skipWhile or dropUntil<br>&gt; concept?<br>&gt;<br>&gt; Dany<br>&gt;<br>&gt;<br>&gt;<br>&gt; Le 11 janv. 2016 à 01:20, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; Here&#39;s a few toy examples, if it helps:<br>&gt;<br>&gt; // list of all powers of 2 below some limit<br>&gt; iterate(1, apply: { $0 * 2 }).takeWhile({ $0 &lt; limit })<br>&gt;<br>&gt; // first &quot;word&quot; of a string, skipping whitespace<br>&gt; let cs = NSCharacterSet.whitespaceCharacterSet()<br>&gt; String(str.unicodeScalars.skipWhile({ cs.longCharacterIsMember($0.value) })<br>&gt;                          .takeWhile({ !cs.longCharacterIsMember($0.value)<br>&gt; }))<br>&gt;<br>&gt; // running total of an array of numbers<br>&gt; numbers.scan(0, combine: +).dropFirst()<br>&gt;<br>&gt; // infinite fibonacci sequence<br>&gt; iterate((0,1), apply: { ($1, $0+$1) }).lazy.map({$1})<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt;<br>&gt; On Mon, Dec 28, 2015, at 03:59 PM, Kevin Ballard wrote:<br>&gt; &gt;<br>&gt; &gt; ## Detailed design<br>&gt; &gt;<br>&gt; &gt; We add the following extension to SequenceType:<br>&gt; &gt;<br>&gt; &gt; extension SequenceType {<br>&gt; &gt;     func scan&lt;T&gt;(initial: T, @noescape combine: (T,<br>&gt; Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt; &gt;     func dropWhile(@noescape dropElement: (Self.Generator.Element)<br>&gt; throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt; &gt;     func takeWhile(@noescape takeElement: (Self.Generator.Element)<br>&gt; throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt; &gt; }<br>&gt; &gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; *_______________________________________________*<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/d2a9b6bf/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January 21, 2016 at 04:00:00pm</p></header><div class="content"><p>I&#39;m rather opposed to the idea of taking the methods that take indexes<br>and overloading them to take predicates instead. They&#39;re extremely<br>different functionality. An index is a value that, once generated, is<br>constant-time to use, and therefore the functions that take them are<br>typically O(1). For example, CollectionType.suffixFrom() is documented<br>explicitly as being O(1).<br></p><p>But functions taking a predicate must be O(N), because they have to<br>evaluate the predicate on every element in turn until it returns true<br>(or false, depending on the method in question).<br></p><p>So if we overload suffixFrom() to take a predicate, then we have one<br>function with one overload that&#39;s always O(1), and one overload that&#39;s<br>always O(N), and that is a great way to confuse people and hide<br>performance issues.<br></p><p>This is also why I&#39;m particularly fond of the takeWhile / dropWhile<br>terminology. Besides the rather extensive precedent, the inclusion of<br>the word &quot;while&quot; makes it clear that it&#39;s iterating over the<br>sequence/collection, which means it&#39;s intuitively O(N).<br></p><p>-Kevin Ballard<br></p><p>On Thu, Jan 21, 2016, at 02:57 PM, David Smith wrote:<br>&gt; To be honest these all seem equally &quot;weird&quot; looking to me, so my hope<br>&gt; is that it&#39;s just a matter of familiarity 😊 My personal inclination is<br>&gt; still that overloading suffixFrom with a predicate-taking variant is<br>&gt; the way to go. That way it occupies the same mental slot as the<br>&gt; existing suffixFrom method, and all you have to decide when using it<br>&gt; is &quot;do I want to specify where to suffix from, or how to find where to<br>&gt; suffix from?&quot;. e.g. it basically becomes sugar that turns<br>&gt;<br>&gt; let idx = foo.indexOf { … } let suffix = foo.suffixFrom(idx)<br>&gt;<br>&gt; into<br>&gt;<br>&gt; let suffix = foo.suffixFrom { … }<br>&gt;<br>&gt; with the bonus feature that it works on single-pass sequences.<br>&gt;<br>&gt; David<br>&gt;<br>&gt;&gt; On Jan 13, 2016, at 11:52 PM, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &quot;suffixAfter&quot; sounds like the equivalent of dropFirst(_:), i.e. it<br>&gt;&gt; sounds like it should take a count of elements to skip. Similarly,<br>&gt;&gt; actually trying an expression that takes a predicate looks weird:<br>&gt;&gt;<br>&gt;&gt; seq.suffixAfter({ isspace($0) })<br>&gt;&gt;<br>&gt;&gt; Even knowing what it&#39;s supposed to do, it&#39;s hard for me to read that<br>&gt;&gt; expression in any sensible fashion.<br>&gt;&gt;<br>&gt;&gt; Also, I&#39;m not sure the &quot;noun phrase&quot; convention really makes sense<br>&gt;&gt; for SequenceType methods. They&#39;re not technically mutating methods,<br>&gt;&gt; but single-pass collections are in fact destructively mutated by Array-<br>&gt;&gt; returning sequence methods (and the methods that return SubSequence<br>&gt;&gt; also destructively mutate upon any access to the returned<br>&gt;&gt; subsequence). Which is to say, despite not being marked as<br>&gt;&gt; &quot;mutating&quot;, they do in fact behave like mutating methods for single-<br>&gt;&gt; pass sequences. Which suggests that verb phrases are perfectly fine.<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt; On Wed, Jan 13, 2016, at 08:36 PM, David Smith via swift-<br>&gt;&gt; evolution wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Rob Rix pointed out that &quot;suffixAfter&quot; would meet all my original<br>&gt;&gt;&gt; criteria. Not sure if keeping the original &quot;match the stuff to drop<br>&gt;&gt;&gt; rather than the stuff to keep&quot; semantics are critical, but this<br>&gt;&gt;&gt; gives us an option for either way 😊<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; David<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jan 13, 2016, at 6:40 PM, David Smith via swift-evolution &lt;swift-<br>&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Naming conventions would suggest that something returning a new<br>&gt;&gt;&gt;&gt; collection should be named with a noun phrase describing what it<br>&gt;&gt;&gt;&gt; returns. Unfortunately, most of the ones I can think of off the top<br>&gt;&gt;&gt;&gt; of my head are fairly clunky. &quot;suffixFromFirstNonMatchingElement&quot;<br>&gt;&gt;&gt;&gt; describes what it does, but I haven&#39;t thought of a non-painful way<br>&gt;&gt;&gt;&gt; to say that yet. &quot;suffixExcluding&quot; is almost right, but it<br>&gt;&gt;&gt;&gt; incorrectly implies (to my eye at least) that the returned<br>&gt;&gt;&gt;&gt; collection excludes all elements matching the predicate, rather<br>&gt;&gt;&gt;&gt; than just matching prefixes. Hm, what about flipping the predicate<br>&gt;&gt;&gt;&gt; and getting a &quot;suffixFrom&quot; overload that takes a predicate for the<br>&gt;&gt;&gt;&gt; first matching element to be included, rather than the last<br>&gt;&gt;&gt;&gt; matching element to be excluded?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; David<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Jan 13, 2016, at 5:54 PM, Dany St-Amant via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; The dropWhile sounds weird to me, I usually would see such<br>&gt;&gt;&gt;&gt;&gt; functionality as a dropUntil; I discard stuff until I see what I<br>&gt;&gt;&gt;&gt;&gt; want. Your example below doesn’t use dropWhile, but skipWhile;<br>&gt;&gt;&gt;&gt;&gt; which sounds a bit better that dropWhile as one skip what he<br>&gt;&gt;&gt;&gt;&gt; doesn’t want.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; What do the other languages use? A dropWhile, skipWhile or<br>&gt;&gt;&gt;&gt;&gt; dropUntil concept?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Dany<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Le 11 janv. 2016 à 01:20, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt;&gt;&gt; evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Here&#39;s a few toy examples, if it helps:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; // list of all powers of 2 below some limit iterate(1, apply: {<br>&gt;&gt;&gt;&gt;&gt;&gt; $0 * 2 }).takeWhile({ $0 &lt; limit })<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; // first &quot;word&quot; of a string, skipping whitespace let cs =<br>&gt;&gt;&gt;&gt;&gt;&gt; NSCharacterSet.whitespaceCharacterSet()<br>&gt;&gt;&gt;&gt;&gt;&gt; String(str.unicodeScalars.skipWhile({<br>&gt;&gt;&gt;&gt;&gt;&gt; cs.longCharacterIsMember($0.value) })<br>&gt;&gt;&gt;&gt;&gt;&gt; .takeWhile({ !cs.longCharacterIsMember($0.value) }))<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; // running total of an array of numbers numbers.scan(, combine:<br>&gt;&gt;&gt;&gt;&gt;&gt; +).dropFirst()<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; // infinite fibonacci sequence iterate((,1), apply: { ($1, $0+$1)<br>&gt;&gt;&gt;&gt;&gt;&gt; }).lazy.map({$1})<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 28, 2015, at 03:59 PM, Kevin Ballard wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; ## Detailed design<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; We add the following extension to SequenceType:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; extension SequenceType {     func scan&lt;T&gt;(initial: T,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; @noescape combine: (T, Self.Generator.Element) throws -&gt; T)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; rethrows -&gt; [T]     func dropWhile(@noescape dropElement:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; [Self.Generator.Element]     func takeWhile(@noescape<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; takeElement: (Self.Generator.Element) throws -&gt; Bool)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; rethrows -&gt; [Self.Generator.Element] }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _________________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/aac62683/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 22, 2016 at 12:00:00pm</p></header><div class="content"><p>Great point Kevin, you&#39;ve convinced me. I&#39;m also happy with `dropWhile` for<br>this reason. My issues with &quot;drop&quot; should be resolved in a separate<br>proposal.<br></p><p>On Fri, Jan 22, 2016 at 11:17 AM, Kevin Ballard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;m rather opposed to the idea of taking the methods that take indexes and<br>&gt; overloading them to take predicates instead. They&#39;re extremely different<br>&gt; functionality. An index is a value that, once generated, is constant-time<br>&gt; to use, and therefore the functions that take them are typically O(1). For<br>&gt; example, CollectionType.suffixFrom() is documented explicitly as being O(1).<br>&gt;<br>&gt; But functions taking a predicate must be O(N), because they have to<br>&gt; evaluate the predicate on every element in turn until it returns true (or<br>&gt; false, depending on the method in question).<br>&gt;<br>&gt; So if we overload suffixFrom() to take a predicate, then we have one<br>&gt; function with one overload that&#39;s always O(1), and one overload that&#39;s<br>&gt; always O(N), and that is a great way to confuse people and hide performance<br>&gt; issues.<br>&gt;<br>&gt; This is also why I&#39;m particularly fond of the takeWhile / dropWhile<br>&gt; terminology. Besides the rather extensive precedent, the inclusion of the<br>&gt; word &quot;while&quot; makes it clear that it&#39;s iterating over the<br>&gt; sequence/collection, which means it&#39;s intuitively O(N).<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Thu, Jan 21, 2016, at 02:57 PM, David Smith wrote:<br>&gt;<br>&gt; To be honest these all seem equally &quot;weird&quot; looking to me, so my hope is<br>&gt; that it&#39;s just a matter of familiarity 😊 My personal inclination is still<br>&gt; that overloading suffixFrom with a predicate-taking variant is the way to<br>&gt; go. That way it occupies the same mental slot as the existing suffixFrom<br>&gt; method, and all you have to decide when using it is &quot;do I want to specify<br>&gt; where to suffix from, or how to find where to suffix from?&quot;. e.g. it<br>&gt; basically becomes sugar that turns<br>&gt;<br>&gt; let idx = foo.indexOf { … }<br>&gt; let suffix = foo.suffixFrom(idx)<br>&gt;<br>&gt; into<br>&gt;<br>&gt; let suffix = foo.suffixFrom { … }<br>&gt;<br>&gt; with the bonus feature that it works on single-pass sequences.<br>&gt;<br>&gt; David<br>&gt;<br>&gt;<br>&gt; On Jan 13, 2016, at 11:52 PM, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &quot;suffixAfter&quot; sounds like the equivalent of dropFirst(_:), i.e. it sounds<br>&gt; like it should take a count of elements to skip. Similarly, actually trying<br>&gt; an expression that takes a predicate looks weird:<br>&gt;<br>&gt;     seq.suffixAfter({ isspace($0) })<br>&gt;<br>&gt; Even knowing what it&#39;s supposed to do, it&#39;s hard for me to read that<br>&gt; expression in any sensible fashion.<br>&gt;<br>&gt; Also, I&#39;m not sure the &quot;noun phrase&quot; convention really makes sense for<br>&gt; SequenceType methods. They&#39;re not technically mutating methods, but<br>&gt; single-pass collections are in fact destructively mutated by<br>&gt; Array-returning sequence methods (and the methods that return SubSequence<br>&gt; also destructively mutate upon any access to the returned subsequence).<br>&gt; Which is to say, despite not being marked as &quot;mutating&quot;, they do in fact<br>&gt; behave like mutating methods for single-pass sequences. Which suggests that<br>&gt; verb phrases are perfectly fine.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Wed, Jan 13, 2016, at 08:36 PM, David Smith via swift-evolution wrote:<br>&gt;<br>&gt;<br>&gt; Rob Rix pointed out that &quot;suffixAfter&quot; would meet all my original<br>&gt; criteria. Not sure if keeping the original &quot;match the stuff to drop rather<br>&gt; than the stuff to keep&quot; semantics are critical, but this gives us an option<br>&gt; for either way 😊<br>&gt;<br>&gt;     David<br>&gt;<br>&gt; On Jan 13, 2016, at 6:40 PM, David Smith via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Naming conventions would suggest that something returning a new collection<br>&gt; should be named with a noun phrase describing what it returns.<br>&gt; Unfortunately, most of the ones I can think of off the top of my head are<br>&gt; fairly clunky. &quot;suffixFromFirstNonMatchingElement&quot; describes what it does,<br>&gt; but I haven&#39;t thought of a non-painful way to say that yet.<br>&gt; &quot;suffixExcluding&quot; is almost right, but it incorrectly implies (to my eye at<br>&gt; least) that the returned collection excludes all elements matching the<br>&gt; predicate, rather than just matching prefixes. Hm, what about flipping the<br>&gt; predicate and getting a &quot;suffixFrom&quot; overload that takes a predicate for<br>&gt; the first matching element to be included, rather than the last matching<br>&gt; element to be excluded?<br>&gt;<br>&gt; David<br>&gt;<br>&gt;<br>&gt; On Jan 13, 2016, at 5:54 PM, Dany St-Amant via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; The dropWhile sounds weird to me, I usually would see such functionality<br>&gt; as a dropUntil; I discard stuff until I see what I want.<br>&gt; Your example below doesn’t use dropWhile, but skipWhile; which sounds a<br>&gt; bit better that dropWhile as one skip what he doesn’t want.<br>&gt;<br>&gt; What do the other languages use? A dropWhile, skipWhile or dropUntil<br>&gt; concept?<br>&gt;<br>&gt; Dany<br>&gt;<br>&gt;<br>&gt;<br>&gt; Le 11 janv. 2016 à 01:20, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; Here&#39;s a few toy examples, if it helps:<br>&gt;<br>&gt; // list of all powers of 2 below some limit<br>&gt; iterate(1, apply: { $0 * 2 }).takeWhile({ $0 &lt; limit })<br>&gt;<br>&gt; // first &quot;word&quot; of a string, skipping whitespace<br>&gt; let cs = NSCharacterSet.whitespaceCharacterSet()<br>&gt; String(str.unicodeScalars.skipWhile({ cs.longCharacterIsMember($0.value) })<br>&gt;                          .takeWhile({ !cs.longCharacterIsMember($0.value)<br>&gt; }))<br>&gt;<br>&gt; // running total of an array of numbers<br>&gt; numbers.scan(0, combine: +).dropFirst()<br>&gt;<br>&gt; // infinite fibonacci sequence<br>&gt; iterate((0,1), apply: { ($1, $0+$1) }).lazy.map({$1})<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt;<br>&gt; On Mon, Dec 28, 2015, at 03:59 PM, Kevin Ballard wrote:<br>&gt; &gt;<br>&gt; &gt; ## Detailed design<br>&gt; &gt;<br>&gt; &gt; We add the following extension to SequenceType:<br>&gt; &gt;<br>&gt; &gt; extension SequenceType {<br>&gt; &gt;     func scan&lt;T&gt;(initial: T, @noescape combine: (T,<br>&gt; Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt; &gt;     func dropWhile(@noescape dropElement: (Self.Generator.Element)<br>&gt; throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt; &gt;     func takeWhile(@noescape takeElement: (Self.Generator.Element)<br>&gt; throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt; &gt; }<br>&gt; &gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; *_______________________________________________*<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/fa366a81/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January 21, 2016 at 11:00:00pm</p></header><div class="content"><p>I’m tempted to say we should rename dropFirst() / dropWhile() to skipFirst() / skipWhile(), i.e. use Rust’s name, because “skip” doesn’t sound like a mutating verb but I do see why people say “drop” does. But yeah, that would be a different proposal entirely.<br></p><p>-Kevin Ballard<br></p><p>&gt; On Jan 21, 2016, at 5:02 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Great point Kevin, you&#39;ve convinced me. I&#39;m also happy with `dropWhile` for this reason. My issues with &quot;drop&quot; should be resolved in a separate proposal.<br>&gt; <br>&gt; On Fri, Jan 22, 2016 at 11:17 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I&#39;m rather opposed to the idea of taking the methods that take indexes and overloading them to take predicates instead. They&#39;re extremely different functionality. An index is a value that, once generated, is constant-time to use, and therefore the functions that take them are typically O(1). For example, CollectionType.suffixFrom() is documented explicitly as being O(1).<br>&gt;  <br>&gt; But functions taking a predicate must be O(N), because they have to evaluate the predicate on every element in turn until it returns true (or false, depending on the method in question).<br>&gt;  <br>&gt; So if we overload suffixFrom() to take a predicate, then we have one function with one overload that&#39;s always O(1), and one overload that&#39;s always O(N), and that is a great way to confuse people and hide performance issues.<br>&gt;  <br>&gt; This is also why I&#39;m particularly fond of the takeWhile / dropWhile terminology. Besides the rather extensive precedent, the inclusion of the word &quot;while&quot; makes it clear that it&#39;s iterating over the sequence/collection, which means it&#39;s intuitively O(N).<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; On Thu, Jan 21, 2016, at 02:57 PM, David Smith wrote:<br>&gt;&gt; To be honest these all seem equally &quot;weird&quot; looking to me, so my hope is that it&#39;s just a matter of familiarity 😊 My personal inclination is still that overloading suffixFrom with a predicate-taking variant is the way to go. That way it occupies the same mental slot as the existing suffixFrom method, and all you have to decide when using it is &quot;do I want to specify where to suffix from, or how to find where to suffix from?&quot;. e.g. it basically becomes sugar that turns<br>&gt;&gt;  <br>&gt;&gt; let idx = foo.indexOf { … }<br>&gt;&gt; let suffix = foo.suffixFrom(idx)<br>&gt;&gt;  <br>&gt;&gt; into<br>&gt;&gt;  <br>&gt;&gt; let suffix = foo.suffixFrom { … }<br>&gt;&gt;  <br>&gt;&gt; with the bonus feature that it works on single-pass sequences.<br>&gt;&gt;  <br>&gt;&gt; David<br>&gt;&gt;  <br>&gt;&gt;&gt; On Jan 13, 2016, at 11:52 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; &quot;suffixAfter&quot; sounds like the equivalent of dropFirst(_:), i.e. it sounds like it should take a count of elements to skip. Similarly, actually trying an expression that takes a predicate looks weird:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;     seq.suffixAfter({ isspace($0) })<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Even knowing what it&#39;s supposed to do, it&#39;s hard for me to read that expression in any sensible fashion.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Also, I&#39;m not sure the &quot;noun phrase&quot; convention really makes sense for SequenceType methods. They&#39;re not technically mutating methods, but single-pass collections are in fact destructively mutated by Array-returning sequence methods (and the methods that return SubSequence also destructively mutate upon any access to the returned subsequence). Which is to say, despite not being marked as &quot;mutating&quot;, they do in fact behave like mutating methods for single-pass sequences. Which suggests that verb phrases are perfectly fine.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; On Wed, Jan 13, 2016, at 08:36 PM, David Smith via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Rob Rix pointed out that &quot;suffixAfter&quot; would meet all my original criteria. Not sure if keeping the original &quot;match the stuff to drop rather than the stuff to keep&quot; semantics are critical, but this gives us an option for either way 😊<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;     David<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Jan 13, 2016, at 6:40 PM, David Smith via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Naming conventions would suggest that something returning a new collection should be named with a noun phrase describing what it returns. Unfortunately, most of the ones I can think of off the top of my head are fairly clunky. &quot;suffixFromFirstNonMatchingElement&quot; describes what it does, but I haven&#39;t thought of a non-painful way to say that yet. &quot;suffixExcluding&quot; is almost right, but it incorrectly implies (to my eye at least) that the returned collection excludes all elements matching the predicate, rather than just matching prefixes. Hm, what about flipping the predicate and getting a &quot;suffixFrom&quot; overload that takes a predicate for the first matching element to be included, rather than the last matching element to be excluded?<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; David<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 13, 2016, at 5:54 PM, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; The dropWhile sounds weird to me, I usually would see such functionality as a dropUntil; I discard stuff until I see what I want.<br>&gt;&gt;&gt;&gt;&gt;&gt; Your example below doesn’t use dropWhile, but skipWhile; which sounds a bit better that dropWhile as one skip what he doesn’t want.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; What do the other languages use? A dropWhile, skipWhile or dropUntil concept?<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Dany<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 11 janv. 2016 à 01:20, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Here&#39;s a few toy examples, if it helps:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // list of all powers of 2 below some limit<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; iterate(1, apply: { $0 * 2 }).takeWhile({ $0 &lt; limit })<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // first &quot;word&quot; of a string, skipping whitespace<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let cs = NSCharacterSet.whitespaceCharacterSet()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; String(str.unicodeScalars.skipWhile({ cs.longCharacterIsMember($0.value) })<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                          .takeWhile({ !cs.longCharacterIsMember($0.value) }))<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // running total of an array of numbers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; numbers.scan(0, combine: +).dropFirst()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // infinite fibonacci sequence<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; iterate((0,1), apply: { ($1, $0+$1) }).lazy.map({$1})<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 28, 2015, at 03:59 PM, Kevin Ballard wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; ## Detailed design<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; We add the following extension to SequenceType:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; extension SequenceType {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;     func scan&lt;T&gt;(initial: T, @noescape combine: (T, Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;     func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;     func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/75e8aca9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January 13, 2016 at 11:00:00pm</p></header><div class="content"><p>Oops, you&#39;re right on the skipWhile(), that snuck in there because I was<br>looking at the Rust documentation (and Rust uses the name skipWhile()).<br></p><p>As for dropUntil, all of the precedent I know of behaves like a<br>dropWhile, not a dropUntil. And dropUntil sounds weird to me; every<br>time I&#39;ve wanted to use this functionality, I do in fact want to drop<br>the stuff I don&#39;t want, rather than dropping until some predicate<br>becomes true.<br></p><p>Language precedent:<br></p><p>Rust: skip_while() and take_while() Ruby: drop_while() and take_while()<br>Python: dropwhile() and takewhile() Haskell: dropWhile and takeWhile<br></p><p>-Kevin Ballard<br></p><p>On Wed, Jan 13, 2016, at 05:54 PM, Dany St-Amant wrote:<br>&gt; The dropWhile sounds weird to me, I usually would see such<br>&gt; functionality as a dropUntil; I discard stuff until I see what I want.<br>&gt; Your example below doesn’t use dropWhile, but skipWhile; which sounds<br>&gt; a bit better that dropWhile as one skip what he doesn’t want.<br>&gt;<br>&gt; What do the other languages use? A dropWhile, skipWhile or dropUntil<br>&gt; concept?<br>&gt;<br>&gt; Dany<br>&gt;<br>&gt;<br>&gt;&gt; Le 11 janv. 2016 à 01:20, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; Here&#39;s a few toy examples, if it helps:<br>&gt;&gt;<br>&gt;&gt; // list of all powers of 2 below some limit iterate(1, apply: { $0 *<br>&gt;&gt; 2 }).takeWhile({ $0 &lt; limit })<br>&gt;&gt;<br>&gt;&gt; // first &quot;word&quot; of a string, skipping whitespace let cs =<br>&gt;&gt; NSCharacterSet.whitespaceCharacterSet()<br>&gt;&gt; String(str.unicodeScalars.skipWhile({<br>&gt;&gt; cs.longCharacterIsMember($0.value) })<br>&gt;&gt; .takeWhile({ !cs.longCharacterIsMember($0.value) }))<br>&gt;&gt;<br>&gt;&gt; // running total of an array of numbers numbers.scan(, combine:<br>&gt;&gt; +).dropFirst()<br>&gt;&gt;<br>&gt;&gt; // infinite fibonacci sequence iterate((,1), apply: { ($1, $0+$1)<br>&gt;&gt; }).lazy.map({$1})<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Mon, Dec 28, 2015, at 03:59 PM, Kevin Ballard wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; ## Detailed design<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; We add the following extension to SequenceType:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; extension SequenceType {     func scan&lt;T&gt;(initial: T, @noescape<br>&gt;&gt;&gt;&gt;&gt; &gt; combine: (T, Self.Generator.Element) throws -&gt; T) rethrows -&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; [T]     func dropWhile(@noescape dropElement:<br>&gt;&gt;&gt;&gt;&gt; &gt; (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; [Self.Generator.Element]     func takeWhile(@noescape<br>&gt;&gt;&gt;&gt;&gt; &gt; takeElement: (Self.Generator.Element) throws -&gt; Bool) rethrows<br>&gt;&gt;&gt;&gt;&gt; &gt; -&gt; [Self.Generator.Element] }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/51b9700a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
