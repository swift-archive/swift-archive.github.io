<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft] Availability by Swift version</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>September 28, 2016 at 11:00:00am</p></header><div class="content"><p>on Thu Sep 22 2016, Graydon Hoare &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi,<br>&gt;<br>&gt; The following is a proposal for a very minor extension of the @available system. Hopefully uncontroversial!<br>&gt;<br>&gt; Thanks,<br>&gt;<br>&gt; -Graydon<br>&gt;<br>&gt; # Availability by Swift version<br>&gt;<br>&gt; * Proposal: [SE-NNNN](NNNN-available-by-swift-version.md)<br>&gt; * Authors: [Graydon Hoare](https://github.com/graydon)<br>&gt; * Review Manager: TBD<br>&gt; * Status: **Awaiting review**<br>&gt;<br>&gt; ## Introduction<br>&gt;<br>&gt; Swift&#39;s existing `@available(...)` attribute indicates the lifecycle of a<br>&gt; given declaration, either unconditionally or relative to a particular<br>&gt; platform or OS version range.<br>&gt;<br>&gt; It does not currently support indicating declaration lifecycle relative to<br>&gt; Swift language versions. This proposal seeks to extend it to do so.<br>&gt;<br>&gt; ## Motivation<br>&gt;<br>&gt; As the Swift language progresses from one version to the next, some<br>&gt; declarations will be added, renamed, deprecated or removed from the<br>&gt; standard library. Existing code written for earlier versions of Swift will<br>&gt; be supported through a `-swift-version N` command-line flag, that runs the<br>&gt; compiler in a backward-compatibility mode for the specified &quot;effective&quot;<br>&gt; language version.<br>&gt;<br>&gt; When running in a backward-compatibility mode, the set of available<br>&gt; standard library declarations should change to match expectations of older<br>&gt; code. Currently the only mechanism for testing a language version is the<br>&gt; compiler-control statement `#if swift(&gt;= N)` which is a static construct:<br>&gt; it can be used to compile-out a declaration from the standard library, but<br>&gt; evolving the standard library through this mechanism would necessitate<br>&gt; compiling the standard library once for each supported older language<br>&gt; version.<br>&gt;<br>&gt; It would be preferable to compile the standard library _once_ for all<br>&gt; supported language versions, but make declarations _conditionally<br>&gt; available_ depending on the effective language version of a _user_ of the<br>&gt; library. The existing `@available(...)` attribute is similar to this<br>&gt; use-case, and this proposal seeks to extend the attribute to support it.<br>&gt;<br>&gt; ## Proposed solution<br>&gt;<br>&gt; The `@available(...)` attribute will be extended to support specifying<br>&gt; `swift` version numbers, in addition to its existing platform versions.<br>&gt;<br>&gt; As an example, an API that is removed in Swift 3.1 will be written<br>&gt; as:<br>&gt;<br>&gt; ~~~~<br>&gt; @available(swift, obsoleted: 3.1)<br>&gt; class Foo {<br>&gt;   //...<br>&gt; }<br>&gt; ~~~~<br>&gt;<br>&gt; When compiling _user code_ in `-swift-version 3.0` mode, this declaration<br>&gt; would be available, but not when compiling in subsequent versions.<br>&gt;<br>&gt; ## Detailed design<br>&gt;<br>&gt; The token `swift` will be added to the set of valid initial arguments<br>&gt; to the `@available(...)` attribute. It will be treated similarly,<br>&gt; but slightly differently, than the existing platform arguments. In<br>&gt; particular:<br>&gt;<br>&gt;   - As with platform-based availability judgments, a declaration&#39;s<br>&gt;     `swift` version availability will default to available-everywhere<br>&gt;     if unspecified.<br>&gt;<br>&gt;   - A declaration&#39;s `swift` version availability will be considered<br>&gt;     in logical conjunction with its platform-based availability.<br>&gt;     That is, a given declaration will be available if and only<br>&gt;     if it is _both_ available to the current effective `swift` version<br>&gt;     _and_ available to the current deployment-target platform.<br>&gt;<br>&gt;   - Similar to the abbreviated form of platform availability, an<br>&gt;     abbreviated form `@available(swift N)` will be permitted as a synonym<br>&gt;     for `@available(swift, introduced: N)`. However, adding `swift` to<br>&gt;     a platform availability abbreviation list will not be allowed. That is,<br>&gt;     writing the following examples is not permitted:<br>&gt;<br>&gt;     - `@available(swift 3, *)`<br>&gt;     - `@available(swift 3, iOS 10, *)`<br>&gt;<br>&gt;     This restriction is due to the fact that platform-availability lists<br>&gt;     are interpreted disjunctively (as a logical-_OR_ of their arguments),<br>&gt;     and adding a conjunct (logical-_AND_) to such a list would make<br>&gt;     the abbreviation potentially ambiguous to readers.<br>&gt;<br>&gt; ## Impact on existing code<br>&gt;<br>&gt; Existing code does not use this form of attribute, so will not be<br>&gt; affected at declaration-site.<br>&gt;<br>&gt; As declarations are annotated as unavailable or obsoleted via<br>&gt; this attribute, some user code may stop working, but the same risk exists<br>&gt; (with a worse user experience) in today&#39;s language any time declarations<br>&gt; are removed or conditionally-compiled out. The purpose of this proposal<br>&gt; is to provide a better user experience around such changes, and facilitate<br>&gt; backward-compatibility modes.<br>&gt;<br>&gt; ## Alternatives considered<br>&gt;<br>&gt; The main alternative is compiling libraries separately for each language<br>&gt; version and using `#if swift(&gt;=N)` to conditionally include varying APIs.<br>&gt; For a library used locally within a single project, recompiling for a<br>&gt; specific language version may be appropriate, but for shipping the standard<br>&gt; library it is more economical to compile once with all declarations, and<br>&gt; select a subset based on language version.<br></p><p>I am +1 on providing this facility but I am concerned that there are<br>several kinds of library evolutions, which we know we&#39;ll need for the<br>standard library, that it doesn&#39;t support.<br></p><p>One example is our plan to inject a new base protocol of Comparable that<br>will henceforth be known as Comparable (to support the &lt;=&gt; proposal).<br>Another thing we think we&#39;ll need to do is to turn what was one type in<br>Swift 3 into two distinct types in Swift 4.  And these are just the<br>needs we can anticipate at this early stage.  I am concerned that we<br>will need a system of much greater power and flexibility in the long<br>term.<br></p><p><br>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
