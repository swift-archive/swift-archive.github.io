<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8da0cba30fa0e47cf4fb26ebb968e552?s=50"></div><header><strong>[proposal draft] new syntax to access a given case&#39;s payload</strong> from <string>Jérôme Duquennoy</string> &lt;jerome+swift at duquennoy.fr&gt;<p>September 26, 2016 at 05:00:00pm</p></header><div class="content"><p>Summary<br>The aim of this proposal is to offer a new syntax to ease some uses of enums with payload.<br></p><p>Situation to improve:<br>Enums makes it possible to have explicate typing where it was not possible before. A classic example of that is filling a dictionary with data coming from a file or a stream (json, plist, …) : the types of possible values is finite : arrays, dicts, int, double, bool or string for json for exemple.<br>An enum can represent this finite range of possible types, its make the code and the API more self-documented.<br>Then, you have two possibilities to deal with this enum:<br>- using switch statements<br>- using the if case syntax introduced by swift 2<br></p><p>The drawback is that those two solutions can lead to writing code with high visual complexity, even though the logic behind is pretty simple.<br></p><p>Consider this example of a data dictionary, that a web service could have returned:<br>- book<br>  - title: <br>  - author:<br>    - name: Apple<br>    - age: 40<br></p><p>We can decode this in a variable of type [String:Value], where Value is:<br></p><p>enum Value {<br>  case integer(value: Int)<br>  case string(value: String)<br>  case dict(value: [String:Value])<br>  case null<br>}<br></p><p>Here is a snippet of code to access the age of the author:<br></p><p>if case .dict(let book) = data {<br>  if case .dict(let author) = book[&quot;author&quot;] ?? .null {<br>    if case .integer(let age) = author[&quot;age&quot;] ?? .null {<br>      // now we have the age<br>    }<br>  }<br>}<br></p><p>The multiple indentation levels can rapidly make this code unattractive to read, and we need to add a null case to the enum to deal with optional values.<br></p><p>Proposed solution:<br>I suggest to add a new syntax, using the case keyword to ease access to the payload of such enums :<br></p><p>let payloadContent = case? .enumCase(variable)<br></p><p>The payloadContent variable will be an optional, that can be either nil, or contain the payload of enumCase.<br>If the payload contains multiple variables, payloadContent will be a tupple.<br>This syntax can accommodate an optional variable as an input. If the value of variable is nil, then payloadContent will be nil.<br>Only enum cases with a payload can be used with this syntax (it would make no sens for cases without a payload).<br></p><p>With that syntax, the null case of the enum can be removed, and the code to access the age becomes:<br></p><p>let book = case? .dict(inputData)<br>let author = case? .dict(book?[&quot;author&quot;])<br>let age = case? .integer(author?[&quot;age&quot;])<br></p><p>Advantages:<br>- It leverages the well established notion of optional, and similar logic already exists in the language (for the as? operator notably).<br>- It does not add a new keyword<br>- It promotes the use of enum to enforce explicit typing, which leads to more self-documenting code<br>- It reduces the complexity of the code in situations such as the one of the exemple<br></p><p>Drawbacks:<br>- It adds a third use of the case keyword. <br>- In the proposed syntax, the variable between parenthesis is not the payload, but the variable to decode. This might be disturbing, as it differs from the other syntax of enum values.<br>- If the payload is an optional, it is not possible to differentiate a non-matching case and a matching case a nil payload.<br></p><p>Alternatives:<br>- Another syntax without parenthesis could be used to avoid the second drawback:<br>let payload = case? .enumCase variable<br></p><p>Impact on existing code:<br>None, this is adding a new syntax<br></p><p><br>This proposal would have no impact on the ABI, so it probably does not fit the stage 1 of swift 4’s roadmap. But I would be glad to have your feedback, so that I can have a proposal ready once we enter stage 2.<br>So what your thoughts on that proposal ?<br></p><p>Thanks<br></p><p>Jerome<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160926/ff7d9bf2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>[proposal draft] new syntax to access a given case&#39;s payload</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>September 26, 2016 at 06:00:00pm</p></header><div class="content"><p>While I don’t have time to get into detail right now, you may be interested in an approach I used for a JSON framework: http://github.com/swiftrien/swifterjson<br>In that approach I used the unix pipe operator “|” to chain a series of JSON accesses. In your example that would be written as:<br></p><p>guard let age = (json|”book”|”author”|”age”)?.integerValue else {…}<br></p><p>Maybe this could be of significance to your proposal?<br></p><p>Regards,<br>Rien.<br></p><p>&gt; On 26 Sep 2016, at 17:51, Jérôme Duquennoy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Summary<br>&gt; The aim of this proposal is to offer a new syntax to ease some uses of enums with payload.<br>&gt; <br>&gt; Situation to improve:<br>&gt; Enums makes it possible to have explicate typing where it was not possible before. A classic example of that is filling a dictionary with data coming from a file or a stream (json, plist, …) : the types of possible values is finite : arrays, dicts, int, double, bool or string for json for exemple.<br>&gt; An enum can represent this finite range of possible types, its make the code and the API more self-documented.<br>&gt; Then, you have two possibilities to deal with this enum:<br>&gt; - using switch statements<br>&gt; - using the if case syntax introduced by swift 2<br>&gt; <br>&gt; The drawback is that those two solutions can lead to writing code with high visual complexity, even though the logic behind is pretty simple.<br>&gt; <br>&gt; Consider this example of a data dictionary, that a web service could have returned:<br>&gt; - book<br>&gt;   - title: <br>&gt;   - author:<br>&gt;     - name: Apple<br>&gt;     - age: 40<br>&gt; <br>&gt; We can decode this in a variable of type [String:Value], where Value is:<br>&gt; <br>&gt; enum Value {<br>&gt;   case integer(value: Int)<br>&gt;   case string(value: String)<br>&gt;   case dict(value: [String:Value])<br>&gt;   case null<br>&gt; }<br>&gt; <br>&gt; Here is a snippet of code to access the age of the author:<br>&gt; <br>&gt; if case .dict(let book) = data {<br>&gt;   if case .dict(let author) = book[&quot;author&quot;] ?? .null {<br>&gt;     if case .integer(let age) = author[&quot;age&quot;] ?? .null {<br>&gt;       // now we have the age<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; The multiple indentation levels can rapidly make this code unattractive to read, and we need to add a null case to the enum to deal with optional values.<br>&gt; <br>&gt; Proposed solution:<br>&gt; I suggest to add a new syntax, using the case keyword to ease access to the payload of such enums :<br>&gt; <br>&gt; let payloadContent = case? .enumCase(variable)<br>&gt; <br>&gt; The payloadContent variable will be an optional, that can be either nil, or contain the payload of enumCase.<br>&gt; If the payload contains multiple variables, payloadContent will be a tupple.<br>&gt; This syntax can accommodate an optional variable as an input. If the value of variable is nil, then payloadContent will be nil.<br>&gt; Only enum cases with a payload can be used with this syntax (it would make no sens for cases without a payload).<br>&gt; <br>&gt; With that syntax, the null case of the enum can be removed, and the code to access the age becomes:<br>&gt; <br>&gt; let book = case? .dict(inputData)<br>&gt; let author = case? .dict(book?[&quot;author&quot;])<br>&gt; let age = case? .integer(author?[&quot;age&quot;])<br>&gt; <br>&gt; Advantages:<br>&gt; - It leverages the well established notion of optional, and similar logic already exists in the language (for the as? operator notably).<br>&gt; - It does not add a new keyword<br>&gt; - It promotes the use of enum to enforce explicit typing, which leads to more self-documenting code<br>&gt; - It reduces the complexity of the code in situations such as the one of the exemple<br>&gt; <br>&gt; Drawbacks:<br>&gt; - It adds a third use of the case keyword. <br>&gt; - In the proposed syntax, the variable between parenthesis is not the payload, but the variable to decode. This might be disturbing, as it differs from the other syntax of enum values.<br>&gt; - If the payload is an optional, it is not possible to differentiate a non-matching case and a matching case a nil payload.<br>&gt; <br>&gt; Alternatives:<br>&gt; - Another syntax without parenthesis could be used to avoid the second drawback:<br>&gt; let payload = case? .enumCase variable<br>&gt; <br>&gt; Impact on existing code:<br>&gt; None, this is adding a new syntax<br>&gt; <br>&gt; <br>&gt; This proposal would have no impact on the ABI, so it probably does not fit the stage 1 of swift 4’s roadmap. But I would be glad to have your feedback, so that I can have a proposal ready once we enter stage 2.<br>&gt; So what your thoughts on that proposal ?<br>&gt; <br>&gt; Thanks<br>&gt; <br>&gt; Jerome<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[proposal draft] new syntax to access a given case&#39;s payload</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>September 26, 2016 at 07:00:00pm</p></header><div class="content"><p>Being a power user of this feature, I don’t think the existing syntax is cumbersome enough to warrant this kind of shortcut.  I really like being able to<br></p><p>guard case let .dict(book) = data else {<br>	// bail out<br>}<br>guard case let .dict(author) = book[&quot;author&quot;] ?? .null else {<br>	// bail out<br>}<br>guard case let .integer(age) = author[&quot;age&quot;] ?? .null else {<br>	// bail out<br>}<br></p><p>// now we have the age<br></p><p>or more succinctly<br></p><p>guard case let .dict(book) = data,<br>      case let .dict(author) = book[&quot;author&quot;] ?? .null,<br>      case let .integer(age) = author[&quot;age&quot;] ?? .null <br>else {<br>	// bail out<br>}<br>// now we have the age<br></p><p>Because it forces me to think about the bailout case(s) and is really not that much longer than your proposed syntax<br></p><p>guard let book = case? .dict(inputData), <br>      let author = case? .dict(book?[&quot;author”]), <br>      let age = case? .integer(author?[&quot;age”])<br>else {<br>	// bail out<br>}<br>// now we have the age<br></p><p>~Robert Widmann<br></p><p>&gt; On Sep 26, 2016, at 11:51 AM, Jérôme Duquennoy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Summary<br>&gt; The aim of this proposal is to offer a new syntax to ease some uses of enums with payload.<br>&gt; <br>&gt; Situation to improve:<br>&gt; Enums makes it possible to have explicate typing where it was not possible before. A classic example of that is filling a dictionary with data coming from a file or a stream (json, plist, …) : the types of possible values is finite : arrays, dicts, int, double, bool or string for json for exemple.<br>&gt; An enum can represent this finite range of possible types, its make the code and the API more self-documented.<br>&gt; Then, you have two possibilities to deal with this enum:<br>&gt; - using switch statements<br>&gt; - using the if case syntax introduced by swift 2<br>&gt; <br>&gt; The drawback is that those two solutions can lead to writing code with high visual complexity, even though the logic behind is pretty simple.<br>&gt; <br>&gt; Consider this example of a data dictionary, that a web service could have returned:<br>&gt; - book<br>&gt;   - title: <br>&gt;   - author:<br>&gt;     - name: Apple<br>&gt;     - age: 40<br>&gt; <br>&gt; We can decode this in a variable of type [String:Value], where Value is:<br>&gt; <br>&gt; enum Value {<br>&gt;   case integer(value: Int)<br>&gt;   case string(value: String)<br>&gt;   case dict(value: [String:Value])<br>&gt;   case null<br>&gt; }<br>&gt; <br>&gt; Here is a snippet of code to access the age of the author:<br>&gt; <br>&gt; if case .dict(let book) = data {<br>&gt;   if case .dict(let author) = book[&quot;author&quot;] ?? .null {<br>&gt;     if case .integer(let age) = author[&quot;age&quot;] ?? .null {<br>&gt;       // now we have the age<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; The multiple indentation levels can rapidly make this code unattractive to read, and we need to add a null case to the enum to deal with optional values.<br>&gt; <br>&gt; Proposed solution:<br>&gt; I suggest to add a new syntax, using the case keyword to ease access to the payload of such enums :<br>&gt; <br>&gt; let payloadContent = case? .enumCase(variable)<br>&gt; <br>&gt; The payloadContent variable will be an optional, that can be either nil, or contain the payload of enumCase.<br>&gt; If the payload contains multiple variables, payloadContent will be a tupple.<br>&gt; This syntax can accommodate an optional variable as an input. If the value of variable is nil, then payloadContent will be nil.<br>&gt; Only enum cases with a payload can be used with this syntax (it would make no sens for cases without a payload).<br>&gt; <br>&gt; With that syntax, the null case of the enum can be removed, and the code to access the age becomes:<br>&gt; <br>&gt; let book = case? .dict(inputData)<br>&gt; let author = case? .dict(book?[&quot;author&quot;])<br>&gt; let age = case? .integer(author?[&quot;age&quot;])<br>&gt; <br>&gt; Advantages:<br>&gt; - It leverages the well established notion of optional, and similar logic already exists in the language (for the as? operator notably).<br>&gt; - It does not add a new keyword<br>&gt; - It promotes the use of enum to enforce explicit typing, which leads to more self-documenting code<br>&gt; - It reduces the complexity of the code in situations such as the one of the exemple<br>&gt; <br>&gt; Drawbacks:<br>&gt; - It adds a third use of the case keyword. <br>&gt; - In the proposed syntax, the variable between parenthesis is not the payload, but the variable to decode. This might be disturbing, as it differs from the other syntax of enum values.<br>&gt; - If the payload is an optional, it is not possible to differentiate a non-matching case and a matching case a nil payload.<br>&gt; <br>&gt; Alternatives:<br>&gt; - Another syntax without parenthesis could be used to avoid the second drawback:<br>&gt; let payload = case? .enumCase variable<br>&gt; <br>&gt; Impact on existing code:<br>&gt; None, this is adding a new syntax<br>&gt; <br>&gt; <br>&gt; This proposal would have no impact on the ABI, so it probably does not fit the stage 1 of swift 4’s roadmap. But I would be glad to have your feedback, so that I can have a proposal ready once we enter stage 2.<br>&gt; So what your thoughts on that proposal ?<br>&gt; <br>&gt; Thanks<br>&gt; <br>&gt; Jerome<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160926/62bdac85/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8da0cba30fa0e47cf4fb26ebb968e552?s=50"></div><header><strong>[proposal draft] new syntax to access a given case&#39;s payload</strong> from <string>Jérôme Duquennoy</string> &lt;jerome+swift at duquennoy.fr&gt;<p>September 27, 2016 at 01:00:00pm</p></header><div class="content"><p>This pattern matching syntax is very nice, for sure.<br>I think the proposed evolution would be a nice complement to it in two ways:<br>- being able to handle the case of optional using case? would avoid having to declare a case (.null in the exemple) that is purely technical, and does not match what the enum describes ;<br>- being able to assign a constant or variable outside of a flow control structure like “if&quot; or “guard&quot; can be useful (if you need to use the variable in multiple distinct places for exemple, be it in the same method, in different methods, or even in an instance variable) ;<br></p><p>But your point emphasise the second drawback I listed : in all those existing syntaxes, the parenthesis after the enum case contains the variable in which the payload will be stored.<br>The syntax I am suggesting does not follow the same logic, which is not nice.<br></p><p>That syntax would be closer:<br></p><p>let case? .enumCase(payloadItem1, payloadItem2) = input<br></p><p>It is pretty similar to the syntax used for pattern matching in guard, for and if.<br>The let and case keywords are swapped, the case gains a ‘?’ to reflect the fact that it will produce an optional, but the rest is the usual pattern matching syntax.<br></p><p>This solution would be even closer:<br></p><p>case? let .enumCase(payloadItem1, payloadItem2) = input<br></p><p>It mostly boils down to removing the guard keyword and its associated else.<br>But I feel very weird not having the let or var at the beginning of the line. Is that only me being too used to that, or does that matter for you too ?<br></p><p>Jerome<br></p><p><br>&gt; On 27 Sep 2016, at 01:04, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Being a power user of this feature, I don’t think the existing syntax is cumbersome enough to warrant this kind of shortcut.  I really like being able to<br>&gt; <br>&gt; guard case let .dict(book) = data else {<br>&gt; 	// bail out<br>&gt; }<br>&gt; guard case let .dict(author) = book[&quot;author&quot;] ?? .null else {<br>&gt; 	// bail out<br>&gt; }<br>&gt; guard case let .integer(age) = author[&quot;age&quot;] ?? .null else {<br>&gt; 	// bail out<br>&gt; }<br>&gt; <br>&gt; // now we have the age<br>&gt; <br>&gt; or more succinctly<br>&gt; <br>&gt; guard case let .dict(book) = data,<br>&gt;       case let .dict(author) = book[&quot;author&quot;] ?? .null,<br>&gt;       case let .integer(age) = author[&quot;age&quot;] ?? .null <br>&gt; else {<br>&gt; 	// bail out<br>&gt; }<br>&gt; // now we have the age<br>&gt; <br>&gt; Because it forces me to think about the bailout case(s) and is really not that much longer than your proposed syntax<br>&gt; <br>&gt; guard let book = case? .dict(inputData), <br>&gt;       let author = case? .dict(book?[&quot;author”]), <br>&gt;       let age = case? .integer(author?[&quot;age”])<br>&gt; else {<br>&gt; 	// bail out<br>&gt; }<br>&gt; // now we have the age<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt;&gt; On Sep 26, 2016, at 11:51 AM, Jérôme Duquennoy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Summary<br>&gt;&gt; The aim of this proposal is to offer a new syntax to ease some uses of enums with payload.<br>&gt;&gt; <br>&gt;&gt; Situation to improve:<br>&gt;&gt; Enums makes it possible to have explicate typing where it was not possible before. A classic example of that is filling a dictionary with data coming from a file or a stream (json, plist, …) : the types of possible values is finite : arrays, dicts, int, double, bool or string for json for exemple.<br>&gt;&gt; An enum can represent this finite range of possible types, its make the code and the API more self-documented.<br>&gt;&gt; Then, you have two possibilities to deal with this enum:<br>&gt;&gt; - using switch statements<br>&gt;&gt; - using the if case syntax introduced by swift 2<br>&gt;&gt; <br>&gt;&gt; The drawback is that those two solutions can lead to writing code with high visual complexity, even though the logic behind is pretty simple.<br>&gt;&gt; <br>&gt;&gt; Consider this example of a data dictionary, that a web service could have returned:<br>&gt;&gt; - book<br>&gt;&gt;   - title: <br>&gt;&gt;   - author:<br>&gt;&gt;     - name: Apple<br>&gt;&gt;     - age: 40<br>&gt;&gt; <br>&gt;&gt; We can decode this in a variable of type [String:Value], where Value is:<br>&gt;&gt; <br>&gt;&gt; enum Value {<br>&gt;&gt;   case integer(value: Int)<br>&gt;&gt;   case string(value: String)<br>&gt;&gt;   case dict(value: [String:Value])<br>&gt;&gt;   case null<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Here is a snippet of code to access the age of the author:<br>&gt;&gt; <br>&gt;&gt; if case .dict(let book) = data {<br>&gt;&gt;   if case .dict(let author) = book[&quot;author&quot;] ?? .null {<br>&gt;&gt;     if case .integer(let age) = author[&quot;age&quot;] ?? .null {<br>&gt;&gt;       // now we have the age<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The multiple indentation levels can rapidly make this code unattractive to read, and we need to add a null case to the enum to deal with optional values.<br>&gt;&gt; <br>&gt;&gt; Proposed solution:<br>&gt;&gt; I suggest to add a new syntax, using the case keyword to ease access to the payload of such enums :<br>&gt;&gt; <br>&gt;&gt; let payloadContent = case? .enumCase(variable)<br>&gt;&gt; <br>&gt;&gt; The payloadContent variable will be an optional, that can be either nil, or contain the payload of enumCase.<br>&gt;&gt; If the payload contains multiple variables, payloadContent will be a tupple.<br>&gt;&gt; This syntax can accommodate an optional variable as an input. If the value of variable is nil, then payloadContent will be nil.<br>&gt;&gt; Only enum cases with a payload can be used with this syntax (it would make no sens for cases without a payload).<br>&gt;&gt; <br>&gt;&gt; With that syntax, the null case of the enum can be removed, and the code to access the age becomes:<br>&gt;&gt; <br>&gt;&gt; let book = case? .dict(inputData)<br>&gt;&gt; let author = case? .dict(book?[&quot;author&quot;])<br>&gt;&gt; let age = case? .integer(author?[&quot;age&quot;])<br>&gt;&gt; <br>&gt;&gt; Advantages:<br>&gt;&gt; - It leverages the well established notion of optional, and similar logic already exists in the language (for the as? operator notably).<br>&gt;&gt; - It does not add a new keyword<br>&gt;&gt; - It promotes the use of enum to enforce explicit typing, which leads to more self-documenting code<br>&gt;&gt; - It reduces the complexity of the code in situations such as the one of the exemple<br>&gt;&gt; <br>&gt;&gt; Drawbacks:<br>&gt;&gt; - It adds a third use of the case keyword. <br>&gt;&gt; - In the proposed syntax, the variable between parenthesis is not the payload, but the variable to decode. This might be disturbing, as it differs from the other syntax of enum values.<br>&gt;&gt; - If the payload is an optional, it is not possible to differentiate a non-matching case and a matching case a nil payload.<br>&gt;&gt; <br>&gt;&gt; Alternatives:<br>&gt;&gt; - Another syntax without parenthesis could be used to avoid the second drawback:<br>&gt;&gt; let payload = case? .enumCase variable<br>&gt;&gt; <br>&gt;&gt; Impact on existing code:<br>&gt;&gt; None, this is adding a new syntax<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This proposal would have no impact on the ABI, so it probably does not fit the stage 1 of swift 4’s roadmap. But I would be glad to have your feedback, so that I can have a proposal ready once we enter stage 2.<br>&gt;&gt; So what your thoughts on that proposal ?<br>&gt;&gt; <br>&gt;&gt; Thanks<br>&gt;&gt; <br>&gt;&gt; Jerome<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160927/e8790b63/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[proposal draft] new syntax to access a given case&#39;s payload</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>September 27, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Am 27.09.2016 um 01:04 schrieb Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Being a power user of this feature, I don’t think the existing syntax is cumbersome enough to warrant this kind of shortcut.  I really like being able to<br>&gt; <br>&gt; guard case let .dict(book) = data else {<br>&gt; 	// bail out<br>&gt; }<br>&gt; guard case let .dict(author) = book[&quot;author&quot;] ?? .null else {<br>&gt; 	// bail out<br>&gt; }<br>&gt; guard case let .integer(age) = author[&quot;age&quot;] ?? .null else {<br>&gt; 	// bail out<br>&gt; }<br>&gt; <br>&gt; // now we have the age<br>&gt; <br>&gt; or more succinctly<br>&gt; <br>&gt; guard case let .dict(book) = data,<br>&gt;       case let .dict(author) = book[&quot;author&quot;] ?? .null,<br>&gt;       case let .integer(age) = author[&quot;age&quot;] ?? .null <br>&gt; else {<br>&gt; 	// bail out<br>&gt; }<br>&gt; // now we have the age<br></p><p>This is a very nice and readable solution. IMHO much better than the proposed syntax.<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt; Because it forces me to think about the bailout case(s) and is really not that much longer than your proposed syntax<br>&gt; <br>&gt; guard let book = case? .dict(inputData), <br>&gt;       let author = case? .dict(book?[&quot;author”]), <br>&gt;       let age = case? .integer(author?[&quot;age”])<br>&gt; else {<br>&gt; 	// bail out<br>&gt; }<br>&gt; // now we have the age<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt;&gt; On Sep 26, 2016, at 11:51 AM, Jérôme Duquennoy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Summary<br>&gt;&gt; The aim of this proposal is to offer a new syntax to ease some uses of enums with payload.<br>&gt;&gt; <br>&gt;&gt; Situation to improve:<br>&gt;&gt; Enums makes it possible to have explicate typing where it was not possible before. A classic example of that is filling a dictionary with data coming from a file or a stream (json, plist, …) : the types of possible values is finite : arrays, dicts, int, double, bool or string for json for exemple.<br>&gt;&gt; An enum can represent this finite range of possible types, its make the code and the API more self-documented.<br>&gt;&gt; Then, you have two possibilities to deal with this enum:<br>&gt;&gt; - using switch statements<br>&gt;&gt; - using the if case syntax introduced by swift 2<br>&gt;&gt; <br>&gt;&gt; The drawback is that those two solutions can lead to writing code with high visual complexity, even though the logic behind is pretty simple.<br>&gt;&gt; <br>&gt;&gt; Consider this example of a data dictionary, that a web service could have returned:<br>&gt;&gt; - book<br>&gt;&gt;   - title: <br>&gt;&gt;   - author:<br>&gt;&gt;     - name: Apple<br>&gt;&gt;     - age: 40<br>&gt;&gt; <br>&gt;&gt; We can decode this in a variable of type [String:Value], where Value is:<br>&gt;&gt; <br>&gt;&gt; enum Value {<br>&gt;&gt;   case integer(value: Int)<br>&gt;&gt;   case string(value: String)<br>&gt;&gt;   case dict(value: [String:Value])<br>&gt;&gt;   case null<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Here is a snippet of code to access the age of the author:<br>&gt;&gt; <br>&gt;&gt; if case .dict(let book) = data {<br>&gt;&gt;   if case .dict(let author) = book[&quot;author&quot;] ?? .null {<br>&gt;&gt;     if case .integer(let age) = author[&quot;age&quot;] ?? .null {<br>&gt;&gt;       // now we have the age<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The multiple indentation levels can rapidly make this code unattractive to read, and we need to add a null case to the enum to deal with optional values.<br>&gt;&gt; <br>&gt;&gt; Proposed solution:<br>&gt;&gt; I suggest to add a new syntax, using the case keyword to ease access to the payload of such enums :<br>&gt;&gt; <br>&gt;&gt; let payloadContent = case? .enumCase(variable)<br>&gt;&gt; <br>&gt;&gt; The payloadContent variable will be an optional, that can be either nil, or contain the payload of enumCase.<br>&gt;&gt; If the payload contains multiple variables, payloadContent will be a tupple.<br>&gt;&gt; This syntax can accommodate an optional variable as an input. If the value of variable is nil, then payloadContent will be nil.<br>&gt;&gt; Only enum cases with a payload can be used with this syntax (it would make no sens for cases without a payload).<br>&gt;&gt; <br>&gt;&gt; With that syntax, the null case of the enum can be removed, and the code to access the age becomes:<br>&gt;&gt; <br>&gt;&gt; let book = case? .dict(inputData)<br>&gt;&gt; let author = case? .dict(book?[&quot;author&quot;])<br>&gt;&gt; let age = case? .integer(author?[&quot;age&quot;])<br>&gt;&gt; <br>&gt;&gt; Advantages:<br>&gt;&gt; - It leverages the well established notion of optional, and similar logic already exists in the language (for the as? operator notably).<br>&gt;&gt; - It does not add a new keyword<br>&gt;&gt; - It promotes the use of enum to enforce explicit typing, which leads to more self-documenting code<br>&gt;&gt; - It reduces the complexity of the code in situations such as the one of the exemple<br>&gt;&gt; <br>&gt;&gt; Drawbacks:<br>&gt;&gt; - It adds a third use of the case keyword. <br>&gt;&gt; - In the proposed syntax, the variable between parenthesis is not the payload, but the variable to decode. This might be disturbing, as it differs from the other syntax of enum values.<br>&gt;&gt; - If the payload is an optional, it is not possible to differentiate a non-matching case and a matching case a nil payload.<br>&gt;&gt; <br>&gt;&gt; Alternatives:<br>&gt;&gt; - Another syntax without parenthesis could be used to avoid the second drawback:<br>&gt;&gt; let payload = case? .enumCase variable<br>&gt;&gt; <br>&gt;&gt; Impact on existing code:<br>&gt;&gt; None, this is adding a new syntax<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This proposal would have no impact on the ABI, so it probably does not fit the stage 1 of swift 4’s roadmap. But I would be glad to have your feedback, so that I can have a proposal ready once we enter stage 2.<br>&gt;&gt; So what your thoughts on that proposal ?<br>&gt;&gt; <br>&gt;&gt; Thanks<br>&gt;&gt; <br>&gt;&gt; Jerome<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160927/248b0377/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[proposal draft] new syntax to access a given case&#39;s payload</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>September 27, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Sep 26, 2016, at 8:51 AM, Jérôme Duquennoy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Summary<br>&gt; The aim of this proposal is to offer a new syntax to ease some uses of enums with payload.<br>&gt; <br>&gt; Situation to improve:<br>&gt; Enums makes it possible to have explicate typing where it was not possible before. A classic example of that is filling a dictionary with data coming from a file or a stream (json, plist, …) : the types of possible values is finite : arrays, dicts, int, double, bool or string for json for exemple.<br>&gt; An enum can represent this finite range of possible types, its make the code and the API more self-documented.<br>&gt; Then, you have two possibilities to deal with this enum:<br>&gt; - using switch statements<br>&gt; - using the if case syntax introduced by swift 2<br>&gt; <br>&gt; The drawback is that those two solutions can lead to writing code with high visual complexity, even though the logic behind is pretty simple.<br>&gt; <br>&gt; Consider this example of a data dictionary, that a web service could have returned:<br>&gt; - book<br>&gt;   - title: <br>&gt;   - author:<br>&gt;     - name: Apple<br>&gt;     - age: 40<br>&gt; <br>&gt; We can decode this in a variable of type [String:Value], where Value is:<br>&gt; <br>&gt; enum Value {<br>&gt;   case integer(value: Int)<br>&gt;   case string(value: String)<br>&gt;   case dict(value: [String:Value])<br>&gt;   case null<br>&gt; }<br>&gt; <br>&gt; Here is a snippet of code to access the age of the author:<br>&gt; <br>&gt; if case .dict(let book) = data {<br>&gt;   if case .dict(let author) = book[&quot;author&quot;] ?? .null {<br>&gt;     if case .integer(let age) = author[&quot;age&quot;] ?? .null {<br>&gt;       // now we have the age<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; The multiple indentation levels can rapidly make this code unattractive to read, and we need to add a null case to the enum to deal with optional values.<br>&gt; <br>&gt; Proposed solution:<br>&gt; I suggest to add a new syntax, using the case keyword to ease access to the payload of such enums :<br>&gt; <br>&gt; let payloadContent = case? .enumCase(variable)<br>&gt; <br>&gt; The payloadContent variable will be an optional, that can be either nil, or contain the payload of enumCase.<br>&gt; If the payload contains multiple variables, payloadContent will be a tupple.<br>&gt; This syntax can accommodate an optional variable as an input. If the value of variable is nil, then payloadContent will be nil.<br>&gt; Only enum cases with a payload can be used with this syntax (it would make no sens for cases without a payload).<br>&gt; <br>&gt; With that syntax, the null case of the enum can be removed, and the code to access the age becomes:<br>&gt; <br>&gt; let book = case? .dict(inputData)<br>&gt; let author = case? .dict(book?[&quot;author&quot;])<br>&gt; let age = case? .integer(author?[&quot;age&quot;])<br>&gt; <br>&gt; Advantages:<br>&gt; - It leverages the well established notion of optional, and similar logic already exists in the language (for the as? operator notably).<br>&gt; - It does not add a new keyword<br>&gt; - It promotes the use of enum to enforce explicit typing, which leads to more self-documenting code<br>&gt; - It reduces the complexity of the code in situations such as the one of the exemple<br>&gt; <br>&gt; Drawbacks:<br>&gt; - It adds a third use of the case keyword. <br>&gt; - In the proposed syntax, the variable between parenthesis is not the payload, but the variable to decode. This might be disturbing, as it differs from the other syntax of enum values.<br>&gt; - If the payload is an optional, it is not possible to differentiate a non-matching case and a matching case a nil payload.<br>&gt; <br>&gt; Alternatives:<br>&gt; - Another syntax without parenthesis could be used to avoid the second drawback:<br>&gt; let payload = case? .enumCase variable<br>&gt; <br>&gt; Impact on existing code:<br>&gt; None, this is adding a new syntax<br>&gt; <br>&gt; <br>&gt; This proposal would have no impact on the ABI, so it probably does not fit the stage 1 of swift 4’s roadmap. But I would be glad to have your feedback, so that I can have a proposal ready once we enter stage 2.<br>&gt; So what your thoughts on that proposal ?<br></p><p>I think it&#39;s reasonable to want an expression for extracting the payload of a enum case as an Optional. Instead of introducing a new operator, though, we could say that the cases themselves behave as Optional properties of an enum, which would allow you to say:<br></p><p>if let book = inputData.dict,<br>   let author = book[&quot;author&quot;].dict,<br>   let age = author[&quot;age&quot;].integer { ... }<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[proposal draft] new syntax to access a given case&#39;s payload</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>September 28, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On 27 Sep 2016, at 18:55, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 26, 2016, at 8:51 AM, Jérôme Duquennoy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Summary<br>&gt;&gt; The aim of this proposal is to offer a new syntax to ease some uses of enums with payload.<br>&gt;&gt; <br>&gt;&gt; Situation to improve:<br>&gt;&gt; Enums makes it possible to have explicate typing where it was not possible before. A classic example of that is filling a dictionary with data coming from a file or a stream (json, plist, …) : the types of possible values is finite : arrays, dicts, int, double, bool or string for json for exemple.<br>&gt;&gt; An enum can represent this finite range of possible types, its make the code and the API more self-documented.<br>&gt;&gt; Then, you have two possibilities to deal with this enum:<br>&gt;&gt; - using switch statements<br>&gt;&gt; - using the if case syntax introduced by swift 2<br>&gt;&gt; <br>&gt;&gt; The drawback is that those two solutions can lead to writing code with high visual complexity, even though the logic behind is pretty simple.<br>&gt;&gt; <br>&gt;&gt; Consider this example of a data dictionary, that a web service could have returned:<br>&gt;&gt; - book<br>&gt;&gt;  - title: <br>&gt;&gt;  - author:<br>&gt;&gt;    - name: Apple<br>&gt;&gt;    - age: 40<br>&gt;&gt; <br>&gt;&gt; We can decode this in a variable of type [String:Value], where Value is:<br>&gt;&gt; <br>&gt;&gt; enum Value {<br>&gt;&gt;  case integer(value: Int)<br>&gt;&gt;  case string(value: String)<br>&gt;&gt;  case dict(value: [String:Value])<br>&gt;&gt;  case null<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Here is a snippet of code to access the age of the author:<br>&gt;&gt; <br>&gt;&gt; if case .dict(let book) = data {<br>&gt;&gt;  if case .dict(let author) = book[&quot;author&quot;] ?? .null {<br>&gt;&gt;    if case .integer(let age) = author[&quot;age&quot;] ?? .null {<br>&gt;&gt;      // now we have the age<br>&gt;&gt;    }<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The multiple indentation levels can rapidly make this code unattractive to read, and we need to add a null case to the enum to deal with optional values.<br>&gt;&gt; <br>&gt;&gt; Proposed solution:<br>&gt;&gt; I suggest to add a new syntax, using the case keyword to ease access to the payload of such enums :<br>&gt;&gt; <br>&gt;&gt; let payloadContent = case? .enumCase(variable)<br>&gt;&gt; <br>&gt;&gt; The payloadContent variable will be an optional, that can be either nil, or contain the payload of enumCase.<br>&gt;&gt; If the payload contains multiple variables, payloadContent will be a tupple.<br>&gt;&gt; This syntax can accommodate an optional variable as an input. If the value of variable is nil, then payloadContent will be nil.<br>&gt;&gt; Only enum cases with a payload can be used with this syntax (it would make no sens for cases without a payload).<br>&gt;&gt; <br>&gt;&gt; With that syntax, the null case of the enum can be removed, and the code to access the age becomes:<br>&gt;&gt; <br>&gt;&gt; let book = case? .dict(inputData)<br>&gt;&gt; let author = case? .dict(book?[&quot;author&quot;])<br>&gt;&gt; let age = case? .integer(author?[&quot;age&quot;])<br>&gt;&gt; <br>&gt;&gt; Advantages:<br>&gt;&gt; - It leverages the well established notion of optional, and similar logic already exists in the language (for the as? operator notably).<br>&gt;&gt; - It does not add a new keyword<br>&gt;&gt; - It promotes the use of enum to enforce explicit typing, which leads to more self-documenting code<br>&gt;&gt; - It reduces the complexity of the code in situations such as the one of the exemple<br>&gt;&gt; <br>&gt;&gt; Drawbacks:<br>&gt;&gt; - It adds a third use of the case keyword. <br>&gt;&gt; - In the proposed syntax, the variable between parenthesis is not the payload, but the variable to decode. This might be disturbing, as it differs from the other syntax of enum values.<br>&gt;&gt; - If the payload is an optional, it is not possible to differentiate a non-matching case and a matching case a nil payload.<br>&gt;&gt; <br>&gt;&gt; Alternatives:<br>&gt;&gt; - Another syntax without parenthesis could be used to avoid the second drawback:<br>&gt;&gt; let payload = case? .enumCase variable<br>&gt;&gt; <br>&gt;&gt; Impact on existing code:<br>&gt;&gt; None, this is adding a new syntax<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This proposal would have no impact on the ABI, so it probably does not fit the stage 1 of swift 4’s roadmap. But I would be glad to have your feedback, so that I can have a proposal ready once we enter stage 2.<br>&gt;&gt; So what your thoughts on that proposal ?<br>&gt; <br>&gt; I think it&#39;s reasonable to want an expression for extracting the payload of a enum case as an Optional. Instead of introducing a new operator, though, we could say that the cases themselves behave as Optional properties of an enum, which would allow you to say:<br>&gt; <br>&gt; if let book = inputData.dict,<br>&gt;   let author = book[&quot;author&quot;].dict,<br>&gt;   let age = author[&quot;age&quot;].integer { ... }<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>I was thinking the same thing. I’m finding myself writing a lot of convenience accessors of the type:<br></p><p>enum MyEnum&lt;T&gt; {<br>    case stateOne<br>    case stateTwo(Array&lt;T&gt;)<br>    case stateThree(T)<br>    case stateFour(Error, T)<br></p><p>    var error : (Error, T)? {<br>        if case .error(let r) = self { return r }<br>        return .none<br>    }<br>}<br></p><p>It would be nice if the compiler could generate these style of accessors, with the payload available as an optional tuple. Perhaps it would be called `var stateFourData : (Error, T)?` or something predictable.<br></p><p>While I’m on the subject, sometimes I want every case of an enum to be its own type, which is a subtype of the enum’s type - e.g. MyEnum&lt;Int&gt;.stateThree.self. That would allow you to keep a collection of MyEnum values which are guaranteed to all be the same case.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[proposal draft] new syntax to access a given case&#39;s payload</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>September 27, 2016 at 07:00:00pm</p></header><div class="content"><p>I can solve the last one!  You often want phantom types in Swift, and they can be had albeit a bit unsafely with a &quot;sealed conformance&quot; to a common protocol and a set of no-case (for phantom types) or single-case (for singleton types) enums.  This this you can do terrible things like create type-level Nats https://gist.github.com/CodaFi/7bb3bd00f04a9b26fd71 and things indexed by them like Fin or even recover light dependent pattern matching with type(of:).<br></p><p>~Robert Widmann<br></p><p>2016/09/27 18:59、Karl via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; <br>&gt;&gt; On 27 Sep 2016, at 18:55, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 26, 2016, at 8:51 AM, Jérôme Duquennoy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Summary<br>&gt;&gt;&gt; The aim of this proposal is to offer a new syntax to ease some uses of enums with payload.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Situation to improve:<br>&gt;&gt;&gt; Enums makes it possible to have explicate typing where it was not possible before. A classic example of that is filling a dictionary with data coming from a file or a stream (json, plist, …) : the types of possible values is finite : arrays, dicts, int, double, bool or string for json for exemple.<br>&gt;&gt;&gt; An enum can represent this finite range of possible types, its make the code and the API more self-documented.<br>&gt;&gt;&gt; Then, you have two possibilities to deal with this enum:<br>&gt;&gt;&gt; - using switch statements<br>&gt;&gt;&gt; - using the if case syntax introduced by swift 2<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The drawback is that those two solutions can lead to writing code with high visual complexity, even though the logic behind is pretty simple.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider this example of a data dictionary, that a web service could have returned:<br>&gt;&gt;&gt; - book<br>&gt;&gt;&gt; - title: <br>&gt;&gt;&gt; - author:<br>&gt;&gt;&gt;   - name: Apple<br>&gt;&gt;&gt;   - age: 40<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We can decode this in a variable of type [String:Value], where Value is:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum Value {<br>&gt;&gt;&gt; case integer(value: Int)<br>&gt;&gt;&gt; case string(value: String)<br>&gt;&gt;&gt; case dict(value: [String:Value])<br>&gt;&gt;&gt; case null<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is a snippet of code to access the age of the author:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if case .dict(let book) = data {<br>&gt;&gt;&gt; if case .dict(let author) = book[&quot;author&quot;] ?? .null {<br>&gt;&gt;&gt;   if case .integer(let age) = author[&quot;age&quot;] ?? .null {<br>&gt;&gt;&gt;     // now we have the age<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The multiple indentation levels can rapidly make this code unattractive to read, and we need to add a null case to the enum to deal with optional values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution:<br>&gt;&gt;&gt; I suggest to add a new syntax, using the case keyword to ease access to the payload of such enums :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let payloadContent = case? .enumCase(variable)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The payloadContent variable will be an optional, that can be either nil, or contain the payload of enumCase.<br>&gt;&gt;&gt; If the payload contains multiple variables, payloadContent will be a tupple.<br>&gt;&gt;&gt; This syntax can accommodate an optional variable as an input. If the value of variable is nil, then payloadContent will be nil.<br>&gt;&gt;&gt; Only enum cases with a payload can be used with this syntax (it would make no sens for cases without a payload).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With that syntax, the null case of the enum can be removed, and the code to access the age becomes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let book = case? .dict(inputData)<br>&gt;&gt;&gt; let author = case? .dict(book?[&quot;author&quot;])<br>&gt;&gt;&gt; let age = case? .integer(author?[&quot;age&quot;])<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Advantages:<br>&gt;&gt;&gt; - It leverages the well established notion of optional, and similar logic already exists in the language (for the as? operator notably).<br>&gt;&gt;&gt; - It does not add a new keyword<br>&gt;&gt;&gt; - It promotes the use of enum to enforce explicit typing, which leads to more self-documenting code<br>&gt;&gt;&gt; - It reduces the complexity of the code in situations such as the one of the exemple<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Drawbacks:<br>&gt;&gt;&gt; - It adds a third use of the case keyword. <br>&gt;&gt;&gt; - In the proposed syntax, the variable between parenthesis is not the payload, but the variable to decode. This might be disturbing, as it differs from the other syntax of enum values.<br>&gt;&gt;&gt; - If the payload is an optional, it is not possible to differentiate a non-matching case and a matching case a nil payload.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives:<br>&gt;&gt;&gt; - Another syntax without parenthesis could be used to avoid the second drawback:<br>&gt;&gt;&gt; let payload = case? .enumCase variable<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code:<br>&gt;&gt;&gt; None, this is adding a new syntax<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal would have no impact on the ABI, so it probably does not fit the stage 1 of swift 4’s roadmap. But I would be glad to have your feedback, so that I can have a proposal ready once we enter stage 2.<br>&gt;&gt;&gt; So what your thoughts on that proposal ?<br>&gt;&gt; <br>&gt;&gt; I think it&#39;s reasonable to want an expression for extracting the payload of a enum case as an Optional. Instead of introducing a new operator, though, we could say that the cases themselves behave as Optional properties of an enum, which would allow you to say:<br>&gt;&gt; <br>&gt;&gt; if let book = inputData.dict,<br>&gt;&gt;  let author = book[&quot;author&quot;].dict,<br>&gt;&gt;  let age = author[&quot;age&quot;].integer { ... }<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; I was thinking the same thing. I’m finding myself writing a lot of convenience accessors of the type:<br>&gt; <br>&gt; enum MyEnum&lt;T&gt; {<br>&gt;    case stateOne<br>&gt;    case stateTwo(Array&lt;T&gt;)<br>&gt;    case stateThree(T)<br>&gt;    case stateFour(Error, T)<br>&gt; <br>&gt;    var error : (Error, T)? {<br>&gt;        if case .error(let r) = self { return r }<br>&gt;        return .none<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; It would be nice if the compiler could generate these style of accessors, with the payload available as an optional tuple. Perhaps it would be called `var stateFourData : (Error, T)?` or something predictable.<br>&gt; <br>&gt; While I’m on the subject, sometimes I want every case of an enum to be its own type, which is a subtype of the enum’s type - e.g. MyEnum&lt;Int&gt;.stateThree.self. That would allow you to keep a collection of MyEnum values which are guaranteed to all be the same case.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160927/d6d31783/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[proposal draft] new syntax to access a given case&#39;s payload</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>September 27, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Sep 26, 2016, at 8:51 AM, Jérôme Duquennoy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Summary<br>&gt; The aim of this proposal is to offer a new syntax to ease some uses of enums with payload.<br></p><p>Hi Jérôme,<br></p><p>This proposal is out of scope for Swift 4 Stage 1, as it is a purely syntactic sugar proposal.  We’re holding off discussion of those because we need to stay focused on more fundamental issues (e.g. the many things that affect ABI stability, like the incomplete generic system).<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160927/82ea1831/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
