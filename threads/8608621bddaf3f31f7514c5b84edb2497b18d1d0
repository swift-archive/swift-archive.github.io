<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abab8a25de5c943e3481fd3f95f3d89a?s=50"></div><header><strong>What about concurrency?</strong> from <string>Антон Миронов</string> &lt;antonvmironov at gmail.com&gt;<p>September  5, 2016 at 01:00:00am</p></header><div class="content"><p>Hi,<br></p><p>My job is mostly consists of writing core functionality for macOS (and I love core functionality). My code must take advantage of concurrency. I&#39;ve been looking for solutions that allow me to write clean and (most important) reliable concurrent code. I would love to discuss some of those solutions and find out if they are any close to what Swift team want to implement in Swift 4+.<br></p><p>1. using actors<br>Actor (in this context) is a stateful object that owns private serial queue and performs all changes of internal state on that queue. In my opinion, it fits into actor model https://en.wikipedia.org/wiki/Actor_model (where a mailbox is an internal queue). So 95% of classes I make are folding into two categories: concurrency-aware actors and other objects that are made for single threaded usage.<br>There is a very common corner case of NSResponder/UIResponder (view controllers, windows, views, quartz core layers and etc) but they are basically components of some imaginary global actor that live on the main queue.<br>I also want to thank Apple team for adding dispatchPrecondition(...) function that helps me to detect if I accidently called agent`s private method on the wrong queue.<br></p><p>2. using futures (and streams) instead of callbacks<br>It saved me from callback hell and helped me to avoid some common issues (such as forgetting to call the callback in some error-handling related cases). The most convincing thing to me was a way of combining multiple futures together. It is far simpler and safer than using group or barrier.<br>I&#39;ve used FutureKit for utility app that has a lot of concurrency and it served me very well. Now I am trying to implement something like it for Swift 3 with more strict error handling and with streams.<br></p><p>3. no atomic properties and locks (except for locks in FutureKit)<br>I&#39;ve learned the hard way that locks are making a lot of troubles. So now I am free from them and I am very glad about it.<br>I also want to thank Swift team for not adding @synchronized to Swift because this decision is really cleaned my mind.<br></p><p>So what do you think?<br></p><p>Thanks,<br>Anton Mironov<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>What about concurrency?</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>September  6, 2016 at 05:00:00pm</p></header><div class="content"><p>On Sep 4, 2016, at 3:00 PM, Anton Mironov via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; My job is mostly consists of writing core functionality for macOS (and I love core functionality). My code must take advantage of concurrency. I&#39;ve been looking for solutions that allow me to write clean and (most important) reliable concurrent code. I would love to discuss some of those solutions and find out if they are any close to what Swift team want to implement in Swift 4+.<br></p><p>Hi Anton,<br></p><p>Many people have thoughts and opinions on this (some held very strong, some not so much).  We hope to kick off discussions about concurrency sometime after the Swift 4 stage 1 projects are complete (with the tentative goal of getting a baked concurrency story into Swift 5).<br></p><p>In the meantime, we’re prefer to stay focused on getting Swift 3 out the door, then move on the Swift 4 stage 1.  Thanks!<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abab8a25de5c943e3481fd3f95f3d89a?s=50"></div><header><strong>What about concurrency?</strong> from <string>Антон Миронов</string> &lt;antonvmironov at gmail.com&gt;<p>September  7, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; 7 вер. 2016 р. о 03:05 Chris Lattner &lt;clattner at apple.com&gt; написав(ла):<br>&gt; <br>&gt; On Sep 4, 2016, at 3:00 PM, Anton Mironov via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; My job is mostly consists of writing core functionality for macOS (and I love core functionality). My code must take advantage of concurrency. I&#39;ve been looking for solutions that allow me to write clean and (most important) reliable concurrent code. I would love to discuss some of those solutions and find out if they are any close to what Swift team want to implement in Swift 4+.<br>&gt; <br>&gt; Hi Anton,<br>&gt; <br>&gt; Many people have thoughts and opinions on this (some held very strong, some not so much).  We hope to kick off discussions about concurrency sometime after the Swift 4 stage 1 projects are complete (with the tentative goal of getting a baked concurrency story into Swift 5).<br>&gt; <br>&gt; In the meantime, we’re prefer to stay focused on getting Swift 3 out the door, then move on the Swift 4 stage 1.  Thanks!<br>&gt; <br>&gt; -Chris<br></p><p><br>Hi Chris,<br></p><p>Thank you for your response. Focusing on Swift 3 and goals for Swift 4 stage 1 are definitely more important than concurrency in any possible way.<br></p><p>On the other hand, concurrency is still a very important aspect for most of apps. We just cannot live without it. It might be two years from now till standardized concurrency will be in Xcode GM seed. For all this time we are bound to use own solutions.<br></p><p>The great thing about implementing concurrency is that it can be tried out in parallel with Swift 3 and Swift 4 development. Maybe as a Swift users community we can discuss and try out some solutions that do not require any/much language support. This will give us well-discussed concurrency implementations much earlier. It will also provide real world testing of these solutions before Swift team implementation and engraving solutions into the standard.<br></p><p>Thanks,<br>Anton Mironov<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
