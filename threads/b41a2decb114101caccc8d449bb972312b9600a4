<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 23, 2016 at 10:00:00am</p></header><div class="content"><p>I have completed a draft of a proposal to move the `*LiteralConvertible` protocols into a `Syntax` namespace as suggested by the standard library team. <br></p><p>The draft can be found here: https://gist.github.com/anandabits/99dad2305d310874bd613b72b14eee56 &lt;https://gist.github.com/anandabits/99dad2305d310874bd613b72b14eee56&gt;.  It is also included below.<br></p><p>I will submit a PR in the next day or two after incorporating any feedback.<br></p><p>-Matthew<br></p><p>Literal Syntax Protocols<br></p><p>Proposal: SE-NNNN &lt;file:///Users/Matthew/Library/Containers/com.brettterpstra.marked2/Data/Library/Caches/Marked%202/Watchers/NNNN-literal-syntax-protocols.md&gt;<br>Author: Matthew Johnson &lt;https://github.com/anandabits&gt;<br>Status: Awaiting review<br>Review manager: TBD<br>Introduction<br></p><p>This proposal renames the *LiteralConvertible protocols to Syntax.*Literal. <br></p><p>Swift-evolution thread: Revisiting SE–0041 Names &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/21290&gt;<br>Motivation<br></p><p>The standard library currently has protocols that use the term Convertible in two different ways. The *LiteralConvertible protocols use the meaning of converting from a literal. The Custom(Debug)StringConvertible protocols use the meaning of converting to a String. This causes confusion for developers attempting to name their own protocols following the precedence established by the standard library.<br></p><p>Further, the standard library team has observed:<br></p><p>The &quot;literal&quot; protocols are not about conversion, they are about adopting a certain syntax provided by the language.  &quot;Convertible&quot; in the name is a red herring: a type can&#39;t be convertible from an integer literal because there is no &quot;IntegerLiteral&quot; entity in the type system.  The literal *becomes* typed as the corresponding literal type (e.g., Int or String), and as far as the user at the call site is concerned, there is no visible conversion (even if one is happening behind the scenes)<br>An earlier proposal &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt; was intended to address the first problem by introducing strong naming conventions for three kinds of conversion protocols (from, to, and bidirectional). The review highlighted the difficulity in establishing conventions that everyone is happy with. This proposal takes a different approach to solving the problem that originally inspired that proposal while also solving the awkwardness of the current names described by the standard library team.<br></p><p>Proposed solution<br></p><p>This proposal addresses both problems by introducing a Syntax “namespace” and moving the *LiteralConvertible protocols into that “namespace” while also renaming them. The proposal does not make any changes to the requirements of the protocols.<br></p><p>Detailed design<br></p><p>All of the *LiteralConvertible protocols will receive new *Literal names inside a Syntaxnamespace. <br></p><p>This namespace will initially be implemented using a case-less enum, but this detail may change in the future if submodules or namespaces are added to Swift. Swift does not currently allow protocols to be declared inside the scope of a type. In order to work around this limitation the protocols themselves will be declared using underscore-prefixed names internal to the standard library. Typealiases inside the Syntax enum will declare the names intended to be visible to user code.<br></p><p>This proposal does not change any requirements of these protocols. All requirements of all *LiteralConvertible protocols will remain exactly the same.<br></p><p>The following protocol declarations and names:<br></p><p>public protocol NilLiteralConvertible { ... }<br>public protocol BooleanLiteralConvertible { ... }<br>public protocol FloatLiteralConvertible { ... }<br>public protocol IntegerLiteralConvertible { ... }<br>public protocol UnicodeScalarLiteralConvertible { ... }<br>public protocol ExtendedGraphemeClusterConvertible { ... }<br>public protocol StringLiteralLiteralConvertible { ... }<br>public protocol StringInterpolationLiteralConvertible { ... }<br>public protocol ArrayLiteralConvertible { ... }<br>public protocol DictionaryLiteralConvertible { ... }<br>Are changed as follows:<br></p><p><br>public protocol _NilLiteralSyntax { ... }<br>public protocol _BooleanLiteralSyntax { ... }<br>public protocol _IntegerLiteralSyntax { ... }<br>public protocol _FloatLiteralSyntax { ... }<br>public protocol _UnicodeScalarLiteralSyntax { ... }<br>public protocol _ExtendedGraphemeClusterLiteralSyntax { ... }<br>public protocol _StringLiteralLiteralSyntax { ... }<br>public protocol _StringInterpolationLiteralSyntax { ... }<br>public protocol _ArrayLiteralSyntax { ... }<br>public protocol _DictionaryLiteralSyntax { ... }<br></p><p>public /* closed */ enum Syntax {<br>  public typealias NilLiteral = _NilLiteralSyntax<br>  public typealias BooleanLiteral = _BooleanLiteralSyntax<br>  public typealias IntegerLiteral = _IntegerLiteralSyntax<br>  public typealias FloatLiteral = _FloatLiteralSyntax<br>  public typealias UnicodeScalarLiteral = _UnicodeScalarLiteralSyntax<br>  public typealias ExtendedGraphemeClusterLiteral = _ExtendedGraphemeClusterLiteralSyntax<br>  public typealias StringLiteralLiteral = _StringLiteralLiteralSyntax<br>  public typealias StringInterplolationLiteral = _StringInterpolationLiteralSyntax<br>  public typealias ArrayrLiteral = _ArrayLiteralSyntax<br>  public typealias DictionaryLiteral = _DictionaryLiteralSyntax<br>}<br>Impact on existing code<br></p><p>All code that references any of the *LiteralConvertible protocols will need to be modified to reference the protocol via the new Syntax.*Literal name.<br></p><p>Alternatives considered<br></p><p>Protocol names<br></p><p>Several commenters have suggested that the names in this proposal are confusing at the site of use:<br></p><p>struct Foo: Syntax.IntegerLiteral { ... }<br>One alternative naming scheme would emphasize the semantic of initializing the type with a literal:<br></p><p>struct Foo: Syntax.IntegerLiteralInitializable { ... }<br>Discussion of the pros and cons of the proposed and alternative naming schemes is encouraged. The core team should feel free to make a final decision on the exact naming scheme used if they choose to accept this proposal.<br></p><p>Previous proposal<br></p><p>This proposal is a follow up to Updating Protocol Naming Conventions for Conversions &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt;. Many related alternatives were explored during the discussion and review of that proposal.<br></p><p>Acknowledgements<br></p><p>The design described in this proposal was suggested by Dave Abrahams, Dmitri Gribenko, and Maxim Moiseev.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/b41a00a4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June 23, 2016 at 10:00:00am</p></header><div class="content"><p>My only feedback at the moment is that “Syntax” seems like a weird name.<br></p><p>This is all about literals, right? So why not use:<br></p><p>Literal.Integer<br>Literal.Float<br>Literal.String<br></p><p>etc.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Jun 23, 2016, at 10:31 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have completed a draft of a proposal to move the `*LiteralConvertible` protocols into a `Syntax` namespace as suggested by the standard library team. <br>&gt; <br>&gt; The draft can be found here: https://gist.github.com/anandabits/99dad2305d310874bd613b72b14eee56.  It is also included below.<br>&gt; <br>&gt; I will submit a PR in the next day or two after incorporating any feedback.<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt; Literal Syntax Protocols<br>&gt; <br>&gt; 	• Proposal: SE-NNNN<br>&gt; 	• Author: Matthew Johnson<br>&gt; 	• Status: Awaiting review<br>&gt; 	• Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; This proposal renames the *LiteralConvertible protocols to Syntax.*Literal. <br>&gt; <br>&gt; Swift-evolution thread: Revisiting SE–0041 Names<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; The standard library currently has protocols that use the term Convertible in two different ways. The *LiteralConvertible protocols use the meaning of converting from a literal. The Custom(Debug)StringConvertible protocols use the meaning of converting to a String. This causes confusion for developers attempting to name their own protocols following the precedence established by the standard library.<br>&gt; <br>&gt; Further, the standard library team has observed:<br>&gt; <br>&gt; The &quot;literal&quot; protocols are not about conversion, they are about adopting a certain syntax provided by the language.  &quot;Convertible&quot; in the name is a red herring: a type can&#39;t be convertible from an integer literal because there is no &quot;IntegerLiteral&quot; entity in the type system.  The literal *becomes* typed as the corresponding literal type (e.g., Int or String), and as far as the user at the call site is concerned, there is no visible conversion (even if one is happening behind the<br>&gt;  scenes)<br>&gt; <br>&gt; An earlier proposal was intended to address the first problem by introducing strong naming conventions for three kinds of conversion protocols (from, to, and bidirectional). The review highlighted the difficulity in establishing conventions that everyone is happy with. This proposal takes a different approach to solving the problem that originally inspired that proposal while also solving the awkwardness of the current names described by the standard library team.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; This proposal addresses both problems by introducing a Syntax “namespace” and moving the *LiteralConvertible protocols into that “namespace” while also renaming them. The proposal does not make any changes to the requirements of the protocols.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; All of the *LiteralConvertible protocols will receive new *Literal names inside a Syntaxnamespace. <br>&gt; <br>&gt; This namespace will initially be implemented using a case-less enum, but this detail may change in the future if submodules or namespaces are added to Swift. Swift does not currently allow protocols to be declared inside the scope of a type. In order to work around this limitation the protocols themselves will be declared using underscore-prefixed names internal to the standard library. Typealiases inside the Syntax enum will declare the names intended to be visible to user code.<br>&gt; <br>&gt; This proposal does not change any requirements of these protocols. All requirements of all *LiteralConvertible protocols will remain exactly the same.<br>&gt; <br>&gt; The following protocol declarations and names:<br>&gt; <br>&gt; public protocol NilLiteralConvertible <br>&gt; { ... }<br>&gt; <br>&gt; public protocol BooleanLiteralConvertible <br>&gt; { ... }<br>&gt; <br>&gt; public protocol FloatLiteralConvertible <br>&gt; { ... }<br>&gt; <br>&gt; public protocol IntegerLiteralConvertible <br>&gt; { ... }<br>&gt; <br>&gt; public protocol UnicodeScalarLiteralConvertible <br>&gt; { ... }<br>&gt; <br>&gt; public protocol ExtendedGraphemeClusterConvertible <br>&gt; { ... }<br>&gt; <br>&gt; public protocol StringLiteralLiteralConvertible <br>&gt; { ... }<br>&gt; <br>&gt; public protocol StringInterpolationLiteralConvertible <br>&gt; { ... }<br>&gt; <br>&gt; public protocol ArrayLiteralConvertible <br>&gt; { ... }<br>&gt; <br>&gt; public protocol DictionaryLiteralConvertible { ... }<br>&gt; Are changed as follows:<br>&gt; <br>&gt; <br>&gt; public protocol _NilLiteralSyntax <br>&gt; { ... }<br>&gt; <br>&gt; public protocol _BooleanLiteralSyntax <br>&gt; { ... }<br>&gt; <br>&gt; public protocol _IntegerLiteralSyntax <br>&gt; { ... }<br>&gt; <br>&gt; public protocol _FloatLiteralSyntax <br>&gt; { ... }<br>&gt; <br>&gt; public protocol _UnicodeScalarLiteralSyntax <br>&gt; { ... }<br>&gt; <br>&gt; public protocol _ExtendedGraphemeClusterLiteralSyntax <br>&gt; { ... }<br>&gt; <br>&gt; public protocol _StringLiteralLiteralSyntax <br>&gt; { ... }<br>&gt; <br>&gt; public protocol _StringInterpolationLiteralSyntax <br>&gt; { ... }<br>&gt; <br>&gt; public protocol _ArrayLiteralSyntax <br>&gt; { ... }<br>&gt; <br>&gt; public protocol _DictionaryLiteralSyntax <br>&gt; { ... }<br>&gt; <br>&gt; <br>&gt; public /* closed */ enum Syntax <br>&gt; {<br>&gt;   <br>&gt; public typealias NilLiteral<br>&gt;  = _NilLiteralSyntax<br>&gt;   <br>&gt; public typealias BooleanLiteral<br>&gt;  = _BooleanLiteralSyntax<br>&gt;   <br>&gt; public typealias IntegerLiteral<br>&gt;  = _IntegerLiteralSyntax<br>&gt;   <br>&gt; public typealias FloatLiteral<br>&gt;  = _FloatLiteralSyntax<br>&gt;   <br>&gt; public typealias UnicodeScalarLiteral<br>&gt;  = _UnicodeScalarLiteralSyntax<br>&gt;   <br>&gt; public typealias ExtendedGraphemeClusterLiteral<br>&gt;  = _ExtendedGraphemeClusterLiteralSyntax<br>&gt;   <br>&gt; public typealias StringLiteralLiteral<br>&gt;  = _StringLiteralLiteralSyntax<br>&gt;   <br>&gt; public typealias StringInterplolationLiteral<br>&gt;  = _StringInterpolationLiteralSyntax<br>&gt;   <br>&gt; public typealias ArrayrLiteral<br>&gt;  = _ArrayLiteralSyntax<br>&gt;   <br>&gt; public typealias DictionaryLiteral<br>&gt;  = _DictionaryLiteralSyntax<br>&gt; }<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; All code that references any of the *LiteralConvertible protocols will need to be modified to reference the protocol via the new Syntax.*Literal name.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Protocol names<br>&gt; <br>&gt; Several commenters have suggested that the names in this proposal are confusing at the site of use:<br>&gt; <br>&gt; struct Foo: Syntax.IntegerLiteral { ... }<br>&gt; One alternative naming scheme would emphasize the semantic of initializing the type with a literal:<br>&gt; <br>&gt; struct Foo: Syntax.IntegerLiteralInitializable { ... }<br>&gt; Discussion of the pros and cons of the proposed and alternative naming schemes is encouraged. The core team should feel free to make a final decision on the exact naming scheme used if they choose to accept this proposal.<br>&gt; <br>&gt; Previous proposal<br>&gt; <br>&gt; This proposal is a follow up to Updating Protocol Naming Conventions for Conversions. Many related alternatives were explored during the discussion and review of that proposal.<br>&gt; <br>&gt; Acknowledgements<br>&gt; <br>&gt; The design described in this proposal was suggested by Dave Abrahams, Dmitri Gribenko, and Maxim Moiseev.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 23, 2016 at 10:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 23, 2016, at 10:39 AM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; My only feedback at the moment is that “Syntax” seems like a weird name.<br></p><p>This name was suggested by the standard library team.  I believe the intent is to place all syntax-supporting protocols in it.  The only syntax-supporting protocols we have right now are literals but that may not always be the case.  I&#39;ll let the team elaborate further if they have anything to add.<br></p><p>&gt; <br>&gt; This is all about literals, right? So why not use:<br>&gt; <br>&gt; Literal.Integer<br>&gt; Literal.Float<br>&gt; Literal.String<br>&gt; <br>&gt; etc.<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 10:31 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have completed a draft of a proposal to move the `*LiteralConvertible` protocols into a `Syntax` namespace as suggested by the standard library team. <br>&gt;&gt; <br>&gt;&gt; The draft can be found here: https://gist.github.com/anandabits/99dad2305d310874bd613b72b14eee56.  It is also included below.<br>&gt;&gt; <br>&gt;&gt; I will submit a PR in the next day or two after incorporating any feedback.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt; Literal Syntax Protocols<br>&gt;&gt; <br>&gt;&gt;    • Proposal: SE-NNNN<br>&gt;&gt;    • Author: Matthew Johnson<br>&gt;&gt;    • Status: Awaiting review<br>&gt;&gt;    • Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal renames the *LiteralConvertible protocols to Syntax.*Literal. <br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: Revisiting SE–0041 Names<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; The standard library currently has protocols that use the term Convertible in two different ways. The *LiteralConvertible protocols use the meaning of converting from a literal. The Custom(Debug)StringConvertible protocols use the meaning of converting to a String. This causes confusion for developers attempting to name their own protocols following the precedence established by the standard library.<br>&gt;&gt; <br>&gt;&gt; Further, the standard library team has observed:<br>&gt;&gt; <br>&gt;&gt; The &quot;literal&quot; protocols are not about conversion, they are about adopting a certain syntax provided by the language.  &quot;Convertible&quot; in the name is a red herring: a type can&#39;t be convertible from an integer literal because there is no &quot;IntegerLiteral&quot; entity in the type system.  The literal *becomes* typed as the corresponding literal type (e.g., Int or String), and as far as the user at the call site is concerned, there is no visible conversion (even if one is happening behind the<br>&gt;&gt; scenes)<br>&gt;&gt; <br>&gt;&gt; An earlier proposal was intended to address the first problem by introducing strong naming conventions for three kinds of conversion protocols (from, to, and bidirectional). The review highlighted the difficulity in establishing conventions that everyone is happy with. This proposal takes a different approach to solving the problem that originally inspired that proposal while also solving the awkwardness of the current names described by the standard library team.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; This proposal addresses both problems by introducing a Syntax “namespace” and moving the *LiteralConvertible protocols into that “namespace” while also renaming them. The proposal does not make any changes to the requirements of the protocols.<br>&gt;&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; All of the *LiteralConvertible protocols will receive new *Literal names inside a Syntaxnamespace. <br>&gt;&gt; <br>&gt;&gt; This namespace will initially be implemented using a case-less enum, but this detail may change in the future if submodules or namespaces are added to Swift. Swift does not currently allow protocols to be declared inside the scope of a type. In order to work around this limitation the protocols themselves will be declared using underscore-prefixed names internal to the standard library. Typealiases inside the Syntax enum will declare the names intended to be visible to user code.<br>&gt;&gt; <br>&gt;&gt; This proposal does not change any requirements of these protocols. All requirements of all *LiteralConvertible protocols will remain exactly the same.<br>&gt;&gt; <br>&gt;&gt; The following protocol declarations and names:<br>&gt;&gt; <br>&gt;&gt; public protocol NilLiteralConvertible <br>&gt;&gt; { ... }<br>&gt;&gt; <br>&gt;&gt; public protocol BooleanLiteralConvertible <br>&gt;&gt; { ... }<br>&gt;&gt; <br>&gt;&gt; public protocol FloatLiteralConvertible <br>&gt;&gt; { ... }<br>&gt;&gt; <br>&gt;&gt; public protocol IntegerLiteralConvertible <br>&gt;&gt; { ... }<br>&gt;&gt; <br>&gt;&gt; public protocol UnicodeScalarLiteralConvertible <br>&gt;&gt; { ... }<br>&gt;&gt; <br>&gt;&gt; public protocol ExtendedGraphemeClusterConvertible <br>&gt;&gt; { ... }<br>&gt;&gt; <br>&gt;&gt; public protocol StringLiteralLiteralConvertible <br>&gt;&gt; { ... }<br>&gt;&gt; <br>&gt;&gt; public protocol StringInterpolationLiteralConvertible <br>&gt;&gt; { ... }<br>&gt;&gt; <br>&gt;&gt; public protocol ArrayLiteralConvertible <br>&gt;&gt; { ... }<br>&gt;&gt; <br>&gt;&gt; public protocol DictionaryLiteralConvertible { ... }<br>&gt;&gt; Are changed as follows:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; public protocol _NilLiteralSyntax <br>&gt;&gt; { ... }<br>&gt;&gt; <br>&gt;&gt; public protocol _BooleanLiteralSyntax <br>&gt;&gt; { ... }<br>&gt;&gt; <br>&gt;&gt; public protocol _IntegerLiteralSyntax <br>&gt;&gt; { ... }<br>&gt;&gt; <br>&gt;&gt; public protocol _FloatLiteralSyntax <br>&gt;&gt; { ... }<br>&gt;&gt; <br>&gt;&gt; public protocol _UnicodeScalarLiteralSyntax <br>&gt;&gt; { ... }<br>&gt;&gt; <br>&gt;&gt; public protocol _ExtendedGraphemeClusterLiteralSyntax <br>&gt;&gt; { ... }<br>&gt;&gt; <br>&gt;&gt; public protocol _StringLiteralLiteralSyntax <br>&gt;&gt; { ... }<br>&gt;&gt; <br>&gt;&gt; public protocol _StringInterpolationLiteralSyntax <br>&gt;&gt; { ... }<br>&gt;&gt; <br>&gt;&gt; public protocol _ArrayLiteralSyntax <br>&gt;&gt; { ... }<br>&gt;&gt; <br>&gt;&gt; public protocol _DictionaryLiteralSyntax <br>&gt;&gt; { ... }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; public /* closed */ enum Syntax <br>&gt;&gt; {<br>&gt;&gt; <br>&gt;&gt; public typealias NilLiteral<br>&gt;&gt; = _NilLiteralSyntax<br>&gt;&gt; <br>&gt;&gt; public typealias BooleanLiteral<br>&gt;&gt; = _BooleanLiteralSyntax<br>&gt;&gt; <br>&gt;&gt; public typealias IntegerLiteral<br>&gt;&gt; = _IntegerLiteralSyntax<br>&gt;&gt; <br>&gt;&gt; public typealias FloatLiteral<br>&gt;&gt; = _FloatLiteralSyntax<br>&gt;&gt; <br>&gt;&gt; public typealias UnicodeScalarLiteral<br>&gt;&gt; = _UnicodeScalarLiteralSyntax<br>&gt;&gt; <br>&gt;&gt; public typealias ExtendedGraphemeClusterLiteral<br>&gt;&gt; = _ExtendedGraphemeClusterLiteralSyntax<br>&gt;&gt; <br>&gt;&gt; public typealias StringLiteralLiteral<br>&gt;&gt; = _StringLiteralLiteralSyntax<br>&gt;&gt; <br>&gt;&gt; public typealias StringInterplolationLiteral<br>&gt;&gt; = _StringInterpolationLiteralSyntax<br>&gt;&gt; <br>&gt;&gt; public typealias ArrayrLiteral<br>&gt;&gt; = _ArrayLiteralSyntax<br>&gt;&gt; <br>&gt;&gt; public typealias DictionaryLiteral<br>&gt;&gt; = _DictionaryLiteralSyntax<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; All code that references any of the *LiteralConvertible protocols will need to be modified to reference the protocol via the new Syntax.*Literal name.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Protocol names<br>&gt;&gt; <br>&gt;&gt; Several commenters have suggested that the names in this proposal are confusing at the site of use:<br>&gt;&gt; <br>&gt;&gt; struct Foo: Syntax.IntegerLiteral { ... }<br>&gt;&gt; One alternative naming scheme would emphasize the semantic of initializing the type with a literal:<br>&gt;&gt; <br>&gt;&gt; struct Foo: Syntax.IntegerLiteralInitializable { ... }<br>&gt;&gt; Discussion of the pros and cons of the proposed and alternative naming schemes is encouraged. The core team should feel free to make a final decision on the exact naming scheme used if they choose to accept this proposal.<br>&gt;&gt; <br>&gt;&gt; Previous proposal<br>&gt;&gt; <br>&gt;&gt; This proposal is a follow up to Updating Protocol Naming Conventions for Conversions. Many related alternatives were explored during the discussion and review of that proposal.<br>&gt;&gt; <br>&gt;&gt; Acknowledgements<br>&gt;&gt; <br>&gt;&gt; The design described in this proposal was suggested by Dave Abrahams, Dmitri Gribenko, and Maxim Moiseev.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>June 23, 2016 at 11:00:00am</p></header><div class="content"><p>I like the namespace-based approach to group these protocols together and I&#39;m very happy to see some clarification happening in this group of protocols. However, I don&#39;t think the proposed new names communicate what they need to. The names listed in the &quot;Alternatives Considered&quot; section do a better job of describing the use and behavior of these protocols.<br></p><p>Primarily, the new names read like we&#39;re saying that a conforming type is a literal, compounding a common existing confusion between literals and types that can be initialized with a literal. Swift&#39;s type inference can sometimes make it seem like dark magic is afoot with literal conversions—for example, you need to understand an awful lot about the standard library to figure out why line 1 works here but not line 2:<br></p><p>    var x = [1, 2, 3, 4, 5]<br>    let y = [10, 20]<br></p><p>    x[1..&lt;2] = [10, 20]     // 1<br>    x[1..&lt;2] = y            // 2<br></p><p>These new names are a (small) step in the wrong direction. While it&#39;s true that the type system doesn&#39;t have an IntegerLiteral type, the language does have integer literals. If someone reads:<br></p><p>    extension MyInt : Syntax.IntegerLiteral { ... }<br></p><p>the implication is that MyInt is an integer literal, and therefore instances of MyInt should be usable wherever an integer literal is usable. The existing &quot;Convertible&quot; wording may be a red herring, but it at least suggests that there&#39;s a difference between a literal and a concrete type.<br></p><p>In sum, I support a change like this and strongly recommend keeping some sort of adjective in the protocol name.<br></p><p>Nate<br></p><p><br>&gt; On Jun 23, 2016, at 10:31 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have completed a draft of a proposal to move the `*LiteralConvertible` protocols into a `Syntax` namespace as suggested by the standard library team. <br>&gt; <br>&gt; The draft can be found here: https://gist.github.com/anandabits/99dad2305d310874bd613b72b14eee56 &lt;https://gist.github.com/anandabits/99dad2305d310874bd613b72b14eee56&gt;.  It is also included below.<br>&gt; <br>&gt; I will submit a PR in the next day or two after incorporating any feedback.<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt; Literal Syntax Protocols<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;file:///Users/Matthew/Library/Containers/com.brettterpstra.marked2/Data/Library/Caches/Marked%202/Watchers/NNNN-literal-syntax-protocols.md&gt;<br>&gt; Author: Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; This proposal renames the *LiteralConvertible protocols to Syntax.*Literal. <br>&gt; <br>&gt; Swift-evolution thread: Revisiting SE–0041 Names &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/21290&gt;<br>&gt; Motivation<br>&gt; <br>&gt; The standard library currently has protocols that use the term Convertible in two different ways. The *LiteralConvertible protocols use the meaning of converting from a literal. The Custom(Debug)StringConvertible protocols use the meaning of converting to a String. This causes confusion for developers attempting to name their own protocols following the precedence established by the standard library.<br>&gt; <br>&gt; Further, the standard library team has observed:<br>&gt; <br>&gt; The &quot;literal&quot; protocols are not about conversion, they are about adopting a certain syntax provided by the language.  &quot;Convertible&quot; in the name is a red herring: a type can&#39;t be convertible from an integer literal because there is no &quot;IntegerLiteral&quot; entity in the type system.  The literal *becomes* typed as the corresponding literal type (e.g., Int or String), and as far as the user at the call site is concerned, there is no visible conversion (even if one is happening behind the scenes)<br>&gt; An earlier proposal &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt; was intended to address the first problem by introducing strong naming conventions for three kinds of conversion protocols (from, to, and bidirectional). The review highlighted the difficulity in establishing conventions that everyone is happy with. This proposal takes a different approach to solving the problem that originally inspired that proposal while also solving the awkwardness of the current names described by the standard library team.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; This proposal addresses both problems by introducing a Syntax “namespace” and moving the *LiteralConvertible protocols into that “namespace” while also renaming them. The proposal does not make any changes to the requirements of the protocols.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; All of the *LiteralConvertible protocols will receive new *Literal names inside a Syntaxnamespace. <br>&gt; <br>&gt; This namespace will initially be implemented using a case-less enum, but this detail may change in the future if submodules or namespaces are added to Swift. Swift does not currently allow protocols to be declared inside the scope of a type. In order to work around this limitation the protocols themselves will be declared using underscore-prefixed names internal to the standard library. Typealiases inside the Syntax enum will declare the names intended to be visible to user code.<br>&gt; <br>&gt; This proposal does not change any requirements of these protocols. All requirements of all *LiteralConvertible protocols will remain exactly the same.<br>&gt; <br>&gt; The following protocol declarations and names:<br>&gt; <br>&gt; public protocol NilLiteralConvertible { ... }<br>&gt; public protocol BooleanLiteralConvertible { ... }<br>&gt; public protocol FloatLiteralConvertible { ... }<br>&gt; public protocol IntegerLiteralConvertible { ... }<br>&gt; public protocol UnicodeScalarLiteralConvertible { ... }<br>&gt; public protocol ExtendedGraphemeClusterConvertible { ... }<br>&gt; public protocol StringLiteralLiteralConvertible { ... }<br>&gt; public protocol StringInterpolationLiteralConvertible { ... }<br>&gt; public protocol ArrayLiteralConvertible { ... }<br>&gt; public protocol DictionaryLiteralConvertible { ... }<br>&gt; Are changed as follows:<br>&gt; <br>&gt; <br>&gt; public protocol _NilLiteralSyntax { ... }<br>&gt; public protocol _BooleanLiteralSyntax { ... }<br>&gt; public protocol _IntegerLiteralSyntax { ... }<br>&gt; public protocol _FloatLiteralSyntax { ... }<br>&gt; public protocol _UnicodeScalarLiteralSyntax { ... }<br>&gt; public protocol _ExtendedGraphemeClusterLiteralSyntax { ... }<br>&gt; public protocol _StringLiteralLiteralSyntax { ... }<br>&gt; public protocol _StringInterpolationLiteralSyntax { ... }<br>&gt; public protocol _ArrayLiteralSyntax { ... }<br>&gt; public protocol _DictionaryLiteralSyntax { ... }<br>&gt; <br>&gt; public /* closed */ enum Syntax {<br>&gt;   public typealias NilLiteral = _NilLiteralSyntax<br>&gt;   public typealias BooleanLiteral = _BooleanLiteralSyntax<br>&gt;   public typealias IntegerLiteral = _IntegerLiteralSyntax<br>&gt;   public typealias FloatLiteral = _FloatLiteralSyntax<br>&gt;   public typealias UnicodeScalarLiteral = _UnicodeScalarLiteralSyntax<br>&gt;   public typealias ExtendedGraphemeClusterLiteral = _ExtendedGraphemeClusterLiteralSyntax<br>&gt;   public typealias StringLiteralLiteral = _StringLiteralLiteralSyntax<br>&gt;   public typealias StringInterplolationLiteral = _StringInterpolationLiteralSyntax<br>&gt;   public typealias ArrayrLiteral = _ArrayLiteralSyntax<br>&gt;   public typealias DictionaryLiteral = _DictionaryLiteralSyntax<br>&gt; }<br>&gt; Impact on existing code<br>&gt; <br>&gt; All code that references any of the *LiteralConvertible protocols will need to be modified to reference the protocol via the new Syntax.*Literal name.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Protocol names<br>&gt; <br>&gt; Several commenters have suggested that the names in this proposal are confusing at the site of use:<br>&gt; <br>&gt; struct Foo: Syntax.IntegerLiteral { ... }<br>&gt; One alternative naming scheme would emphasize the semantic of initializing the type with a literal:<br>&gt; <br>&gt; struct Foo: Syntax.IntegerLiteralInitializable { ... }<br>&gt; Discussion of the pros and cons of the proposed and alternative naming schemes is encouraged. The core team should feel free to make a final decision on the exact naming scheme used if they choose to accept this proposal.<br>&gt; <br>&gt; Previous proposal<br>&gt; <br>&gt; This proposal is a follow up to Updating Protocol Naming Conventions for Conversions &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt;. Many related alternatives were explored during the discussion and review of that proposal.<br>&gt; <br>&gt; Acknowledgements<br>&gt; <br>&gt; The design described in this proposal was suggested by Dave Abrahams, Dmitri Gribenko, and Maxim Moiseev.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/68af7044/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 23, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 11:43 AM, Nate Cook &lt;natecook at gmail.com&gt; wrote:<br>&gt; <br>&gt; I like the namespace-based approach to group these protocols together and I&#39;m very happy to see some clarification happening in this group of protocols. However, I don&#39;t think the proposed new names communicate what they need to. The names listed in the &quot;Alternatives Considered&quot; section do a better job of describing the use and behavior of these protocols.<br>&gt; <br>&gt; Primarily, the new names read like we&#39;re saying that a conforming type is a literal, compounding a common existing confusion between literals and types that can be initialized with a literal. Swift&#39;s type inference can sometimes make it seem like dark magic is afoot with literal conversions—for example, you need to understand an awful lot about the standard library to figure out why line 1 works here but not line 2:<br>&gt; <br>&gt;     var x = [1, 2, 3, 4, 5]<br>&gt;     let y = [10, 20]<br>&gt; <br>&gt;     x[1..&lt;2] = [10, 20]     // 1<br>&gt;     x[1..&lt;2] = y            // 2<br>&gt; <br>&gt; These new names are a (small) step in the wrong direction. While it&#39;s true that the type system doesn&#39;t have an IntegerLiteral type, the language does have integer literals. If someone reads:<br>&gt; <br>&gt;     extension MyInt : Syntax.IntegerLiteral { ... }<br>&gt; <br>&gt; the implication is that MyInt is an integer literal, and therefore instances of MyInt should be usable wherever an integer literal is usable. The existing &quot;Convertible&quot; wording may be a red herring, but it at least suggests that there&#39;s a difference between a literal and a concrete type.<br>&gt; <br>&gt; In sum, I support a change like this and strongly recommend keeping some sort of adjective in the protocol name.<br></p><p>I appreciate your comments Nate.  Do you mind if I paste some of this into the proposal in the alternatives considered section?<br></p><p>I tend to agree with this and prefer the `Syntax.*LiteralInitializable` names myself. However, the standard library team seems to prefer the names in the proposal.  <br></p><p>I have already had a related proposal rejected because the core team didn’t like the names in the proposal so I am taking a conservative approach here of writing the proposal using the names they prefer and listing my preference as an alternative.  I am hoping community feedback will prompt the core team to accept a revised version with names that are a bit more clear.  Short of that, I am hoping to avoid rejection as I think the proposal as-written is an improvement over current state.<br></p><p><br>&gt; <br>&gt; Nate<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 10:31 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have completed a draft of a proposal to move the `*LiteralConvertible` protocols into a `Syntax` namespace as suggested by the standard library team. <br>&gt;&gt; <br>&gt;&gt; The draft can be found here: https://gist.github.com/anandabits/99dad2305d310874bd613b72b14eee56 &lt;https://gist.github.com/anandabits/99dad2305d310874bd613b72b14eee56&gt;.  It is also included below.<br>&gt;&gt; <br>&gt;&gt; I will submit a PR in the next day or two after incorporating any feedback.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt; Literal Syntax Protocols<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;file:///Users/Matthew/Library/Containers/com.brettterpstra.marked2/Data/Library/Caches/Marked%202/Watchers/NNNN-literal-syntax-protocols.md&gt;<br>&gt;&gt; Author: Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal renames the *LiteralConvertible protocols to Syntax.*Literal. <br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: Revisiting SE–0041 Names &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/21290&gt;<br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; The standard library currently has protocols that use the term Convertible in two different ways. The *LiteralConvertible protocols use the meaning of converting from a literal. The Custom(Debug)StringConvertible protocols use the meaning of converting to a String. This causes confusion for developers attempting to name their own protocols following the precedence established by the standard library.<br>&gt;&gt; <br>&gt;&gt; Further, the standard library team has observed:<br>&gt;&gt; <br>&gt;&gt; The &quot;literal&quot; protocols are not about conversion, they are about adopting a certain syntax provided by the language.  &quot;Convertible&quot; in the name is a red herring: a type can&#39;t be convertible from an integer literal because there is no &quot;IntegerLiteral&quot; entity in the type system.  The literal *becomes* typed as the corresponding literal type (e.g., Int or String), and as far as the user at the call site is concerned, there is no visible conversion (even if one is happening behind the scenes)<br>&gt;&gt; An earlier proposal &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt; was intended to address the first problem by introducing strong naming conventions for three kinds of conversion protocols (from, to, and bidirectional). The review highlighted the difficulity in establishing conventions that everyone is happy with. This proposal takes a different approach to solving the problem that originally inspired that proposal while also solving the awkwardness of the current names described by the standard library team.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; This proposal addresses both problems by introducing a Syntax “namespace” and moving the *LiteralConvertible protocols into that “namespace” while also renaming them. The proposal does not make any changes to the requirements of the protocols.<br>&gt;&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; All of the *LiteralConvertible protocols will receive new *Literal names inside a Syntaxnamespace. <br>&gt;&gt; <br>&gt;&gt; This namespace will initially be implemented using a case-less enum, but this detail may change in the future if submodules or namespaces are added to Swift. Swift does not currently allow protocols to be declared inside the scope of a type. In order to work around this limitation the protocols themselves will be declared using underscore-prefixed names internal to the standard library. Typealiases inside the Syntax enum will declare the names intended to be visible to user code.<br>&gt;&gt; <br>&gt;&gt; This proposal does not change any requirements of these protocols. All requirements of all *LiteralConvertible protocols will remain exactly the same.<br>&gt;&gt; <br>&gt;&gt; The following protocol declarations and names:<br>&gt;&gt; <br>&gt;&gt; public protocol NilLiteralConvertible { ... }<br>&gt;&gt; public protocol BooleanLiteralConvertible { ... }<br>&gt;&gt; public protocol FloatLiteralConvertible { ... }<br>&gt;&gt; public protocol IntegerLiteralConvertible { ... }<br>&gt;&gt; public protocol UnicodeScalarLiteralConvertible { ... }<br>&gt;&gt; public protocol ExtendedGraphemeClusterConvertible { ... }<br>&gt;&gt; public protocol StringLiteralLiteralConvertible { ... }<br>&gt;&gt; public protocol StringInterpolationLiteralConvertible { ... }<br>&gt;&gt; public protocol ArrayLiteralConvertible { ... }<br>&gt;&gt; public protocol DictionaryLiteralConvertible { ... }<br>&gt;&gt; Are changed as follows:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; public protocol _NilLiteralSyntax { ... }<br>&gt;&gt; public protocol _BooleanLiteralSyntax { ... }<br>&gt;&gt; public protocol _IntegerLiteralSyntax { ... }<br>&gt;&gt; public protocol _FloatLiteralSyntax { ... }<br>&gt;&gt; public protocol _UnicodeScalarLiteralSyntax { ... }<br>&gt;&gt; public protocol _ExtendedGraphemeClusterLiteralSyntax { ... }<br>&gt;&gt; public protocol _StringLiteralLiteralSyntax { ... }<br>&gt;&gt; public protocol _StringInterpolationLiteralSyntax { ... }<br>&gt;&gt; public protocol _ArrayLiteralSyntax { ... }<br>&gt;&gt; public protocol _DictionaryLiteralSyntax { ... }<br>&gt;&gt; <br>&gt;&gt; public /* closed */ enum Syntax {<br>&gt;&gt;   public typealias NilLiteral = _NilLiteralSyntax<br>&gt;&gt;   public typealias BooleanLiteral = _BooleanLiteralSyntax<br>&gt;&gt;   public typealias IntegerLiteral = _IntegerLiteralSyntax<br>&gt;&gt;   public typealias FloatLiteral = _FloatLiteralSyntax<br>&gt;&gt;   public typealias UnicodeScalarLiteral = _UnicodeScalarLiteralSyntax<br>&gt;&gt;   public typealias ExtendedGraphemeClusterLiteral = _ExtendedGraphemeClusterLiteralSyntax<br>&gt;&gt;   public typealias StringLiteralLiteral = _StringLiteralLiteralSyntax<br>&gt;&gt;   public typealias StringInterplolationLiteral = _StringInterpolationLiteralSyntax<br>&gt;&gt;   public typealias ArrayrLiteral = _ArrayLiteralSyntax<br>&gt;&gt;   public typealias DictionaryLiteral = _DictionaryLiteralSyntax<br>&gt;&gt; }<br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; All code that references any of the *LiteralConvertible protocols will need to be modified to reference the protocol via the new Syntax.*Literal name.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Protocol names<br>&gt;&gt; <br>&gt;&gt; Several commenters have suggested that the names in this proposal are confusing at the site of use:<br>&gt;&gt; <br>&gt;&gt; struct Foo: Syntax.IntegerLiteral { ... }<br>&gt;&gt; One alternative naming scheme would emphasize the semantic of initializing the type with a literal:<br>&gt;&gt; <br>&gt;&gt; struct Foo: Syntax.IntegerLiteralInitializable { ... }<br>&gt;&gt; Discussion of the pros and cons of the proposed and alternative naming schemes is encouraged. The core team should feel free to make a final decision on the exact naming scheme used if they choose to accept this proposal.<br>&gt;&gt; <br>&gt;&gt; Previous proposal<br>&gt;&gt; <br>&gt;&gt; This proposal is a follow up to Updating Protocol Naming Conventions for Conversions &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt;. Many related alternatives were explored during the discussion and review of that proposal.<br>&gt;&gt; <br>&gt;&gt; Acknowledgements<br>&gt;&gt; <br>&gt;&gt; The design described in this proposal was suggested by Dave Abrahams, Dmitri Gribenko, and Maxim Moiseev.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/aa0c48e3/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 23, 2016 at 07:00:00pm</p></header><div class="content"><p>What an disturbing name... &#39;Syntax.xxx&#39; <br>it makes me anticipate basically a proliferation of other:<br>NarrowLittleCornerCase.yyyy<br>YetAnotherNameToIsolateSomethingElseFromTheRest.zzzz<br></p><p>It evokes to me the &quot;File file&quot; naming pattern (compared to &#39;File settings&#39; or &#39;File avatarImage&#39;)<br>Regards<br>LM<br>(From mobile)<br></p><p>&gt; On Jun 23, 2016, at 5:31 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have completed a draft of a proposal to move the `*LiteralConvertible` protocols into a `Syntax` namespace as suggested by the standard library team. <br>&gt; <br>&gt; The draft can be found here: https://gist.github.com/anandabits/99dad2305d310874bd613b72b14eee56.  It is also included below.<br>&gt; <br>&gt; I will submit a PR in the next day or two after incorporating any feedback.<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt; Literal Syntax Protocols<br>&gt; <br>&gt; Proposal: SE-NNNN<br>&gt; Author: Matthew Johnson<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; This proposal renames the *LiteralConvertible protocols to Syntax.*Literal. <br>&gt; <br>&gt; Swift-evolution thread: Revisiting SE–0041 Names<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; The standard library currently has protocols that use the term Convertible in two different ways. The *LiteralConvertible protocols use the meaning of converting from a literal. The Custom(Debug)StringConvertible protocols use the meaning of converting to a String. This causes confusion for developers attempting to name their own protocols following the precedence established by the standard library.<br>&gt; <br>&gt; Further, the standard library team has observed:<br>&gt; <br>&gt; The &quot;literal&quot; protocols are not about conversion, they are about adopting a certain syntax provided by the language.  &quot;Convertible&quot; in the name is a red herring: a type can&#39;t be convertible from an integer literal because there is no &quot;IntegerLiteral&quot; entity in the type system.  The literal *becomes* typed as the corresponding literal type (e.g., Int or String), and as far as the user at the call site is concerned, there is no visible conversion (even if one is happening behind the scenes)<br>&gt; An earlier proposal was intended to address the first problem by introducing strong naming conventions for three kinds of conversion protocols (from, to, and bidirectional). The review highlighted the difficulity in establishing conventions that everyone is happy with. This proposal takes a different approach to solving the problem that originally inspired that proposal while also solving the awkwardness of the current names described by the standard library team.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; This proposal addresses both problems by introducing a Syntax “namespace” and moving the *LiteralConvertible protocols into that “namespace” while also renaming them. The proposal does not make any changes to the requirements of the protocols.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; All of the *LiteralConvertible protocols will receive new *Literal names inside a Syntaxnamespace. <br>&gt; <br>&gt; This namespace will initially be implemented using a case-less enum, but this detail may change in the future if submodules or namespaces are added to Swift. Swift does not currently allow protocols to be declared inside the scope of a type. In order to work around this limitation the protocols themselves will be declared using underscore-prefixed names internal to the standard library. Typealiases inside the Syntax enum will declare the names intended to be visible to user code.<br>&gt; <br>&gt; This proposal does not change any requirements of these protocols. All requirements of all *LiteralConvertible protocols will remain exactly the same.<br>&gt; <br>&gt; The following protocol declarations and names:<br>&gt; <br>&gt; public protocol NilLiteralConvertible { ... }<br>&gt; public protocol BooleanLiteralConvertible { ... }<br>&gt; public protocol FloatLiteralConvertible { ... }<br>&gt; public protocol IntegerLiteralConvertible { ... }<br>&gt; public protocol UnicodeScalarLiteralConvertible { ... }<br>&gt; public protocol ExtendedGraphemeClusterConvertible { ... }<br>&gt; public protocol StringLiteralLiteralConvertible { ... }<br>&gt; public protocol StringInterpolationLiteralConvertible { ... }<br>&gt; public protocol ArrayLiteralConvertible { ... }<br>&gt; public protocol DictionaryLiteralConvertible { ... }<br>&gt; Are changed as follows:<br>&gt; <br>&gt; <br>&gt; public protocol _NilLiteralSyntax { ... }<br>&gt; public protocol _BooleanLiteralSyntax { ... }<br>&gt; public protocol _IntegerLiteralSyntax { ... }<br>&gt; public protocol _FloatLiteralSyntax { ... }<br>&gt; public protocol _UnicodeScalarLiteralSyntax { ... }<br>&gt; public protocol _ExtendedGraphemeClusterLiteralSyntax { ... }<br>&gt; public protocol _StringLiteralLiteralSyntax { ... }<br>&gt; public protocol _StringInterpolationLiteralSyntax { ... }<br>&gt; public protocol _ArrayLiteralSyntax { ... }<br>&gt; public protocol _DictionaryLiteralSyntax { ... }<br>&gt; <br>&gt; public /* closed */ enum Syntax {<br>&gt;   public typealias NilLiteral = _NilLiteralSyntax<br>&gt;   public typealias BooleanLiteral = _BooleanLiteralSyntax<br>&gt;   public typealias IntegerLiteral = _IntegerLiteralSyntax<br>&gt;   public typealias FloatLiteral = _FloatLiteralSyntax<br>&gt;   public typealias UnicodeScalarLiteral = _UnicodeScalarLiteralSyntax<br>&gt;   public typealias ExtendedGraphemeClusterLiteral = _ExtendedGraphemeClusterLiteralSyntax<br>&gt;   public typealias StringLiteralLiteral = _StringLiteralLiteralSyntax<br>&gt;   public typealias StringInterplolationLiteral = _StringInterpolationLiteralSyntax<br>&gt;   public typealias ArrayrLiteral = _ArrayLiteralSyntax<br>&gt;   public typealias DictionaryLiteral = _DictionaryLiteralSyntax<br>&gt; }<br>&gt; Impact on existing code<br>&gt; <br>&gt; All code that references any of the *LiteralConvertible protocols will need to be modified to reference the protocol via the new Syntax.*Literal name.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Protocol names<br>&gt; <br>&gt; Several commenters have suggested that the names in this proposal are confusing at the site of use:<br>&gt; <br>&gt; struct Foo: Syntax.IntegerLiteral { ... }<br>&gt; One alternative naming scheme would emphasize the semantic of initializing the type with a literal:<br>&gt; <br>&gt; struct Foo: Syntax.IntegerLiteralInitializable { ... }<br>&gt; Discussion of the pros and cons of the proposed and alternative naming schemes is encouraged. The core team should feel free to make a final decision on the exact naming scheme used if they choose to accept this proposal.<br>&gt; <br>&gt; Previous proposal<br>&gt; <br>&gt; This proposal is a follow up to Updating Protocol Naming Conventions for Conversions. Many related alternatives were explored during the discussion and review of that proposal.<br>&gt; <br>&gt; Acknowledgements<br>&gt; <br>&gt; The design described in this proposal was suggested by Dave Abrahams, Dmitri Gribenko, and Maxim Moiseev.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/5132d517/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 23, 2016 at 12:00:00pm</p></header><div class="content"><p>+1<br></p><p>“Syntax” still feels weird, though…<br></p><p>Oh, so if the idea is that literals don’t have a type, that the “Syntax” isn’t meant to be exclusively about literals, and that the various `*LiteralConvertible` protocols only exist to tell the --&gt;compiler&lt;-- what types any given literal can become, what about just calling it “Compiler”?<br>struct Foo : Compiler.IntegerLiteral {}<br></p><p>This reinforces the notion (at least in my mind, and at least more than “Syntax” does) that literals live outside of Swift’s &quot;normal&quot; type system.<br> <br>- Dave Sweeris<br></p><p>&gt; On Jun 23, 2016, at 10:31 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have completed a draft of a proposal to move the `*LiteralConvertible` protocols into a `Syntax` namespace as suggested by the standard library team. <br>&gt; <br>&gt; The draft can be found here: https://gist.github.com/anandabits/99dad2305d310874bd613b72b14eee56 &lt;https://gist.github.com/anandabits/99dad2305d310874bd613b72b14eee56&gt;.  It is also included below.<br>&gt; <br>&gt; I will submit a PR in the next day or two after incorporating any feedback.<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt; Literal Syntax Protocols<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;file:///Users/Matthew/Library/Containers/com.brettterpstra.marked2/Data/Library/Caches/Marked%202/Watchers/NNNN-literal-syntax-protocols.md&gt;<br>&gt; Author: Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; This proposal renames the *LiteralConvertible protocols to Syntax.*Literal. <br>&gt; <br>&gt; Swift-evolution thread: Revisiting SE–0041 Names &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/21290&gt;<br>&gt; Motivation<br>&gt; <br>&gt; The standard library currently has protocols that use the term Convertible in two different ways. The *LiteralConvertible protocols use the meaning of converting from a literal. The Custom(Debug)StringConvertible protocols use the meaning of converting to a String. This causes confusion for developers attempting to name their own protocols following the precedence established by the standard library.<br>&gt; <br>&gt; Further, the standard library team has observed:<br>&gt; <br>&gt; The &quot;literal&quot; protocols are not about conversion, they are about adopting a certain syntax provided by the language.  &quot;Convertible&quot; in the name is a red herring: a type can&#39;t be convertible from an integer literal because there is no &quot;IntegerLiteral&quot; entity in the type system.  The literal *becomes* typed as the corresponding literal type (e.g., Int or String), and as far as the user at the call site is concerned, there is no visible conversion (even if one is happening behind the scenes)<br>&gt; An earlier proposal &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt; was intended to address the first problem by introducing strong naming conventions for three kinds of conversion protocols (from, to, and bidirectional). The review highlighted the difficulity in establishing conventions that everyone is happy with. This proposal takes a different approach to solving the problem that originally inspired that proposal while also solving the awkwardness of the current names described by the standard library team.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; This proposal addresses both problems by introducing a Syntax “namespace” and moving the *LiteralConvertible protocols into that “namespace” while also renaming them. The proposal does not make any changes to the requirements of the protocols.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; All of the *LiteralConvertible protocols will receive new *Literal names inside a Syntaxnamespace. <br>&gt; <br>&gt; This namespace will initially be implemented using a case-less enum, but this detail may change in the future if submodules or namespaces are added to Swift. Swift does not currently allow protocols to be declared inside the scope of a type. In order to work around this limitation the protocols themselves will be declared using underscore-prefixed names internal to the standard library. Typealiases inside the Syntax enum will declare the names intended to be visible to user code.<br>&gt; <br>&gt; This proposal does not change any requirements of these protocols. All requirements of all *LiteralConvertible protocols will remain exactly the same.<br>&gt; <br>&gt; The following protocol declarations and names:<br>&gt; <br>&gt; public protocol NilLiteralConvertible { ... }<br>&gt; public protocol BooleanLiteralConvertible { ... }<br>&gt; public protocol FloatLiteralConvertible { ... }<br>&gt; public protocol IntegerLiteralConvertible { ... }<br>&gt; public protocol UnicodeScalarLiteralConvertible { ... }<br>&gt; public protocol ExtendedGraphemeClusterConvertible { ... }<br>&gt; public protocol StringLiteralLiteralConvertible { ... }<br>&gt; public protocol StringInterpolationLiteralConvertible { ... }<br>&gt; public protocol ArrayLiteralConvertible { ... }<br>&gt; public protocol DictionaryLiteralConvertible { ... }<br>&gt; Are changed as follows:<br>&gt; <br>&gt; <br>&gt; public protocol _NilLiteralSyntax { ... }<br>&gt; public protocol _BooleanLiteralSyntax { ... }<br>&gt; public protocol _IntegerLiteralSyntax { ... }<br>&gt; public protocol _FloatLiteralSyntax { ... }<br>&gt; public protocol _UnicodeScalarLiteralSyntax { ... }<br>&gt; public protocol _ExtendedGraphemeClusterLiteralSyntax { ... }<br>&gt; public protocol _StringLiteralLiteralSyntax { ... }<br>&gt; public protocol _StringInterpolationLiteralSyntax { ... }<br>&gt; public protocol _ArrayLiteralSyntax { ... }<br>&gt; public protocol _DictionaryLiteralSyntax { ... }<br>&gt; <br>&gt; public /* closed */ enum Syntax {<br>&gt;   public typealias NilLiteral = _NilLiteralSyntax<br>&gt;   public typealias BooleanLiteral = _BooleanLiteralSyntax<br>&gt;   public typealias IntegerLiteral = _IntegerLiteralSyntax<br>&gt;   public typealias FloatLiteral = _FloatLiteralSyntax<br>&gt;   public typealias UnicodeScalarLiteral = _UnicodeScalarLiteralSyntax<br>&gt;   public typealias ExtendedGraphemeClusterLiteral = _ExtendedGraphemeClusterLiteralSyntax<br>&gt;   public typealias StringLiteralLiteral = _StringLiteralLiteralSyntax<br>&gt;   public typealias StringInterplolationLiteral = _StringInterpolationLiteralSyntax<br>&gt;   public typealias ArrayrLiteral = _ArrayLiteralSyntax<br>&gt;   public typealias DictionaryLiteral = _DictionaryLiteralSyntax<br>&gt; }<br>&gt; Impact on existing code<br>&gt; <br>&gt; All code that references any of the *LiteralConvertible protocols will need to be modified to reference the protocol via the new Syntax.*Literal name.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Protocol names<br>&gt; <br>&gt; Several commenters have suggested that the names in this proposal are confusing at the site of use:<br>&gt; <br>&gt; struct Foo: Syntax.IntegerLiteral { ... }<br>&gt; One alternative naming scheme would emphasize the semantic of initializing the type with a literal:<br>&gt; <br>&gt; struct Foo: Syntax.IntegerLiteralInitializable { ... }<br>&gt; Discussion of the pros and cons of the proposed and alternative naming schemes is encouraged. The core team should feel free to make a final decision on the exact naming scheme used if they choose to accept this proposal.<br>&gt; <br>&gt; Previous proposal<br>&gt; <br>&gt; This proposal is a follow up to Updating Protocol Naming Conventions for Conversions &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt;. Many related alternatives were explored during the discussion and review of that proposal.<br>&gt; <br>&gt; Acknowledgements<br>&gt; <br>&gt; The design described in this proposal was suggested by Dave Abrahams, Dmitri Gribenko, and Maxim Moiseev.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/d375240b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 23, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 12:26 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt; <br>&gt; +1<br>&gt; <br>&gt; “Syntax” still feels weird, though…<br>&gt; <br>&gt; Oh, so if the idea is that literals don’t have a type, that the “Syntax” isn’t meant to be exclusively about literals, and that the various `*LiteralConvertible` protocols only exist to tell the --&gt;compiler&lt;-- what types any given literal can become, what about just calling it “Compiler”?<br>&gt; struct Foo : Compiler.IntegerLiteral {}<br>&gt; <br>&gt; This reinforces the notion (at least in my mind, and at least more than “Syntax” does) that literals live outside of Swift’s &quot;normal&quot; type system.<br></p><p>Thanks for the feedback.  `Compiler` seems like a reasonable alternative.  I will add it to the proposal.  I anticipate plenty of bike shedding during discussion / review and want to encourage the community to debate the pros and cons of the options we are able to come up with.<br></p><p>&gt;  <br>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 10:31 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have completed a draft of a proposal to move the `*LiteralConvertible` protocols into a `Syntax` namespace as suggested by the standard library team. <br>&gt;&gt; <br>&gt;&gt; The draft can be found here: https://gist.github.com/anandabits/99dad2305d310874bd613b72b14eee56 &lt;https://gist.github.com/anandabits/99dad2305d310874bd613b72b14eee56&gt;.  It is also included below.<br>&gt;&gt; <br>&gt;&gt; I will submit a PR in the next day or two after incorporating any feedback.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt; Literal Syntax Protocols<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;file:///Users/Matthew/Library/Containers/com.brettterpstra.marked2/Data/Library/Caches/Marked%202/Watchers/NNNN-literal-syntax-protocols.md&gt;<br>&gt;&gt; Author: Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal renames the *LiteralConvertible protocols to Syntax.*Literal. <br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: Revisiting SE–0041 Names &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/21290&gt;<br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; The standard library currently has protocols that use the term Convertible in two different ways. The *LiteralConvertible protocols use the meaning of converting from a literal. The Custom(Debug)StringConvertible protocols use the meaning of converting to a String. This causes confusion for developers attempting to name their own protocols following the precedence established by the standard library.<br>&gt;&gt; <br>&gt;&gt; Further, the standard library team has observed:<br>&gt;&gt; <br>&gt;&gt; The &quot;literal&quot; protocols are not about conversion, they are about adopting a certain syntax provided by the language.  &quot;Convertible&quot; in the name is a red herring: a type can&#39;t be convertible from an integer literal because there is no &quot;IntegerLiteral&quot; entity in the type system.  The literal *becomes* typed as the corresponding literal type (e.g., Int or String), and as far as the user at the call site is concerned, there is no visible conversion (even if one is happening behind the scenes)<br>&gt;&gt; An earlier proposal &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt; was intended to address the first problem by introducing strong naming conventions for three kinds of conversion protocols (from, to, and bidirectional). The review highlighted the difficulity in establishing conventions that everyone is happy with. This proposal takes a different approach to solving the problem that originally inspired that proposal while also solving the awkwardness of the current names described by the standard library team.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; This proposal addresses both problems by introducing a Syntax “namespace” and moving the *LiteralConvertible protocols into that “namespace” while also renaming them. The proposal does not make any changes to the requirements of the protocols.<br>&gt;&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; All of the *LiteralConvertible protocols will receive new *Literal names inside a Syntaxnamespace. <br>&gt;&gt; <br>&gt;&gt; This namespace will initially be implemented using a case-less enum, but this detail may change in the future if submodules or namespaces are added to Swift. Swift does not currently allow protocols to be declared inside the scope of a type. In order to work around this limitation the protocols themselves will be declared using underscore-prefixed names internal to the standard library. Typealiases inside the Syntax enum will declare the names intended to be visible to user code.<br>&gt;&gt; <br>&gt;&gt; This proposal does not change any requirements of these protocols. All requirements of all *LiteralConvertible protocols will remain exactly the same.<br>&gt;&gt; <br>&gt;&gt; The following protocol declarations and names:<br>&gt;&gt; <br>&gt;&gt; public protocol NilLiteralConvertible { ... }<br>&gt;&gt; public protocol BooleanLiteralConvertible { ... }<br>&gt;&gt; public protocol FloatLiteralConvertible { ... }<br>&gt;&gt; public protocol IntegerLiteralConvertible { ... }<br>&gt;&gt; public protocol UnicodeScalarLiteralConvertible { ... }<br>&gt;&gt; public protocol ExtendedGraphemeClusterConvertible { ... }<br>&gt;&gt; public protocol StringLiteralLiteralConvertible { ... }<br>&gt;&gt; public protocol StringInterpolationLiteralConvertible { ... }<br>&gt;&gt; public protocol ArrayLiteralConvertible { ... }<br>&gt;&gt; public protocol DictionaryLiteralConvertible { ... }<br>&gt;&gt; Are changed as follows:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; public protocol _NilLiteralSyntax { ... }<br>&gt;&gt; public protocol _BooleanLiteralSyntax { ... }<br>&gt;&gt; public protocol _IntegerLiteralSyntax { ... }<br>&gt;&gt; public protocol _FloatLiteralSyntax { ... }<br>&gt;&gt; public protocol _UnicodeScalarLiteralSyntax { ... }<br>&gt;&gt; public protocol _ExtendedGraphemeClusterLiteralSyntax { ... }<br>&gt;&gt; public protocol _StringLiteralLiteralSyntax { ... }<br>&gt;&gt; public protocol _StringInterpolationLiteralSyntax { ... }<br>&gt;&gt; public protocol _ArrayLiteralSyntax { ... }<br>&gt;&gt; public protocol _DictionaryLiteralSyntax { ... }<br>&gt;&gt; <br>&gt;&gt; public /* closed */ enum Syntax {<br>&gt;&gt;   public typealias NilLiteral = _NilLiteralSyntax<br>&gt;&gt;   public typealias BooleanLiteral = _BooleanLiteralSyntax<br>&gt;&gt;   public typealias IntegerLiteral = _IntegerLiteralSyntax<br>&gt;&gt;   public typealias FloatLiteral = _FloatLiteralSyntax<br>&gt;&gt;   public typealias UnicodeScalarLiteral = _UnicodeScalarLiteralSyntax<br>&gt;&gt;   public typealias ExtendedGraphemeClusterLiteral = _ExtendedGraphemeClusterLiteralSyntax<br>&gt;&gt;   public typealias StringLiteralLiteral = _StringLiteralLiteralSyntax<br>&gt;&gt;   public typealias StringInterplolationLiteral = _StringInterpolationLiteralSyntax<br>&gt;&gt;   public typealias ArrayrLiteral = _ArrayLiteralSyntax<br>&gt;&gt;   public typealias DictionaryLiteral = _DictionaryLiteralSyntax<br>&gt;&gt; }<br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; All code that references any of the *LiteralConvertible protocols will need to be modified to reference the protocol via the new Syntax.*Literal name.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Protocol names<br>&gt;&gt; <br>&gt;&gt; Several commenters have suggested that the names in this proposal are confusing at the site of use:<br>&gt;&gt; <br>&gt;&gt; struct Foo: Syntax.IntegerLiteral { ... }<br>&gt;&gt; One alternative naming scheme would emphasize the semantic of initializing the type with a literal:<br>&gt;&gt; <br>&gt;&gt; struct Foo: Syntax.IntegerLiteralInitializable { ... }<br>&gt;&gt; Discussion of the pros and cons of the proposed and alternative naming schemes is encouraged. The core team should feel free to make a final decision on the exact naming scheme used if they choose to accept this proposal.<br>&gt;&gt; <br>&gt;&gt; Previous proposal<br>&gt;&gt; <br>&gt;&gt; This proposal is a follow up to Updating Protocol Naming Conventions for Conversions &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt;. Many related alternatives were explored during the discussion and review of that proposal.<br>&gt;&gt; <br>&gt;&gt; Acknowledgements<br>&gt;&gt; <br>&gt;&gt; The design described in this proposal was suggested by Dave Abrahams, Dmitri Gribenko, and Maxim Moiseev.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/4499bdb2/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June 24, 2016 at 05:00:00pm</p></header><div class="content"><p>+1 from me. If I&#39;ll see `struct A : Syntax.NilLiteral {..}` I read this as <br>&quot;`A` could be represented in syntax as nil literal&quot; or even &quot;A could be a <br>nil literal in syntax&quot;<br></p><p>On 23.06.2016 18:31, Matthew Johnson via swift-evolution wrote:<br>&gt; I have completed a draft of a proposal to move the `*LiteralConvertible`<br>&gt; protocols into a `Syntax` namespace as suggested by the standard library team.<br>&gt;<br>&gt; The draft can be found<br>&gt; here: https://gist.github.com/anandabits/99dad2305d310874bd613b72b14eee56.<br>&gt;  It is also included below.<br>&gt;<br>&gt; I will submit a PR in the next day or two after incorporating any feedback.<br>&gt;<br>&gt; -Matthew<br>&gt;<br>&gt;<br>&gt;   Literal Syntax Protocols<br>&gt;<br>&gt;   * Proposal: SE-NNNN<br>&gt;   * Author: Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt;   * Status: *Awaiting review*<br>&gt;   * Review manager: TBD<br>&gt;<br>&gt;<br>&gt;     Introduction<br>&gt;<br>&gt; This proposal renames the |*LiteralConvertible| protocols<br>&gt; to |Syntax.*Literal|.<br>&gt;<br>&gt; Swift-evolution thread: Revisiting SE–0041 Names<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/21290&gt;<br>&gt;<br>&gt;<br>&gt;     Motivation<br>&gt;<br>&gt; The standard library currently has protocols that use the<br>&gt; term |Convertible| in two different ways.<br>&gt; The |*LiteralConvertible| protocols use the meaning of converting /from/ a<br>&gt; literal. The |Custom(Debug)StringConvertible| protocols use the meaning of<br>&gt; converting /to/ a |String|. This causes confusion for developers attempting<br>&gt; to name their own protocols following the precedence established by the<br>&gt; standard library.<br>&gt;<br>&gt; Further, the standard library team has observed:<br>&gt;<br>&gt; |The &quot;literal&quot; protocols are not about conversion, they are about adopting a<br>&gt; certain syntax provided by the language. &quot;Convertible&quot; in the name is a red<br>&gt; herring: a type can&#39;t be convertible from an integer literal because there<br>&gt; is no &quot;IntegerLiteral&quot; entity in the type system. The literal *becomes*<br>&gt; typed as the corresponding literal type (e.g., Int or String), and as far<br>&gt; as the user at the call site is concerned, there is no visible conversion<br>&gt; (even if one is happening behind the scenes) |<br>&gt;<br>&gt; An earlier proposal<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt; was<br>&gt; intended to address the first problem by introducing strong naming<br>&gt; conventions for three kinds of conversion protocols (/from/, /to/,<br>&gt; and /bidirectional/). The review highlighted the difficulity in<br>&gt; establishing conventions that everyone is happy with. This proposal takes a<br>&gt; different approach to solving the problem that originally inspired that<br>&gt; proposal while also solving the awkwardness of the current names described<br>&gt; by the standard library team.<br>&gt;<br>&gt;<br>&gt;     Proposed solution<br>&gt;<br>&gt; This proposal addresses both problems by introducing a |Syntax| “namespace”<br>&gt; and moving the |*LiteralConvertible| protocols into that “namespace” while<br>&gt; also renaming them. The proposal *does not* make any changes to the<br>&gt; requirements of the protocols.<br>&gt;<br>&gt;<br>&gt;     Detailed design<br>&gt;<br>&gt; All of the |*LiteralConvertible| protocols will receive<br>&gt; new |*Literal| names inside a |Syntax|namespace.<br>&gt;<br>&gt; This namespace will initially be implemented using a case-less |enum|, but<br>&gt; this detail may change in the future if submodules or namespaces are added<br>&gt; to Swift. Swift does not currently allow protocols to be declared inside<br>&gt; the scope of a type. In order to work around this limitation the protocols<br>&gt; themselves will be declared using underscore-prefixed names internal to the<br>&gt; standard library. Typealiases inside the |Syntax| enum will declare the<br>&gt; names intended to be visible to user code.<br>&gt;<br>&gt; This proposal does not change any requirements of these protocols. All<br>&gt; requirements of all |*LiteralConvertible| protocols will remain exactly the<br>&gt; same.<br>&gt;<br>&gt; The following protocol declarations and names:<br>&gt;<br>&gt; |public protocol NilLiteralConvertible { ... } public protocol<br>&gt; BooleanLiteralConvertible { ... } public protocol FloatLiteralConvertible {<br>&gt; ... } public protocol IntegerLiteralConvertible { ... } public protocol<br>&gt; UnicodeScalarLiteralConvertible { ... } public protocol<br>&gt; ExtendedGraphemeClusterConvertible { ... } public protocol<br>&gt; StringLiteralLiteralConvertible { ... } public protocol<br>&gt; StringInterpolationLiteralConvertible { ... } public protocol<br>&gt; ArrayLiteralConvertible { ... } public protocol<br>&gt; DictionaryLiteralConvertible { ... }|<br>&gt;<br>&gt; Are changed as follows:<br>&gt;<br>&gt; |public protocol _NilLiteralSyntax { ... } public protocol<br>&gt; _BooleanLiteralSyntax { ... } public protocol _IntegerLiteralSyntax { ... }<br>&gt; public protocol _FloatLiteralSyntax { ... } public protocol<br>&gt; _UnicodeScalarLiteralSyntax { ... } public protocol<br>&gt; _ExtendedGraphemeClusterLiteralSyntax { ... } public protocol<br>&gt; _StringLiteralLiteralSyntax { ... } public protocol<br>&gt; _StringInterpolationLiteralSyntax { ... } public protocol<br>&gt; _ArrayLiteralSyntax { ... } public protocol _DictionaryLiteralSyntax { ...<br>&gt; } public /* closed */ enum Syntax { public typealias NilLiteral =<br>&gt; _NilLiteralSyntax public typealias BooleanLiteral = _BooleanLiteralSyntax<br>&gt; public typealias IntegerLiteral = _IntegerLiteralSyntax public typealias<br>&gt; FloatLiteral = _FloatLiteralSyntax public typealias UnicodeScalarLiteral =<br>&gt; _UnicodeScalarLiteralSyntax public typealias ExtendedGraphemeClusterLiteral<br>&gt; = _ExtendedGraphemeClusterLiteralSyntax public typealias<br>&gt; StringLiteralLiteral = _StringLiteralLiteralSyntax public typealias<br>&gt; StringInterplolationLiteral = _StringInterpolationLiteralSyntax public<br>&gt; typealias ArrayrLiteral = _ArrayLiteralSyntax public typealias<br>&gt; DictionaryLiteral = _DictionaryLiteralSyntax }|<br>&gt;<br>&gt;<br>&gt;     Impact on existing code<br>&gt;<br>&gt; All code that references any of the |*LiteralConvertible| protocols will<br>&gt; need to be modified to reference the protocol via the<br>&gt; new |Syntax.*Literal| name.<br>&gt;<br>&gt;<br>&gt;     Alternatives considered<br>&gt;<br>&gt;<br>&gt;       Protocol names<br>&gt;<br>&gt; Several commenters have suggested that the names in this proposal are<br>&gt; confusing at the site of use:<br>&gt;<br>&gt; |struct Foo: Syntax.IntegerLiteral { ... }|<br>&gt;<br>&gt; One alternative naming scheme would emphasize the semantic of initializing<br>&gt; the type with a literal:<br>&gt;<br>&gt; |struct Foo: Syntax.IntegerLiteralInitializable { ... }|<br>&gt;<br>&gt; Discussion of the pros and cons of the proposed and alternative naming<br>&gt; schemes is encouraged. The core team should feel free to make a final<br>&gt; decision on the exact naming scheme used if they choose to accept this<br>&gt; proposal.<br>&gt;<br>&gt;<br>&gt;       Previous proposal<br>&gt;<br>&gt; This proposal is a follow up to Updating Protocol Naming Conventions for<br>&gt; Conversions<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt;.<br>&gt; Many related alternatives were explored during the discussion and review of<br>&gt; that proposal.<br>&gt;<br>&gt;<br>&gt;     Acknowledgements<br>&gt;<br>&gt; The design described in this proposal was suggested by Dave Abrahams,<br>&gt; Dmitri Gribenko, and Maxim Moiseev.<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 24, 2016 at 05:00:00pm</p></header><div class="content"><p>I don’t like an underscore on public protocols. If we’re not forced to use the proposed syntax at all it looks strange when you use a type with an underscore (which to me represents something for private or internal usage).<br></p><p>In Swift we only can use literals for a single direction literal -&gt; type, so why don’t we just rename the protocols to look like:<br></p><p>public protocol NilLiteralProtocol { ... }<br>public protocol BooleanLiteralProtocol { ... }<br>public protocol FloatLiteralProtocol { ... }<br>public protocol IntegerLiteralProtocol { ... }<br>public protocol UnicodeScalarLiteralProtocol { ... }<br>public protocol ExtendedGraphemeClusterProtocol { ... }<br>public protocol StringLiteralLiteralProtocol { ... }<br>public protocol StringInterpolationLiteralProtocol { ... }<br>public protocol ArrayLiteralProtocol { ... }<br>public protocol DictionaryLiteralProtocol { ... }<br>Here Protocol corresponds to the user that we’re about to access a specific literal with our type which implements the protocol. (Just like ErrorProtocol.)<br>- extension Array : ArrayLiteralConvertible<br>+ extension Array : ArrayLiteralProtocol<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 24. Juni 2016 um 16:21:21, Vladimir.S via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>es are<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/008b26bc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 24, 2016 at 10:00:00am</p></header><div class="content"><p>Thanks for the feedback Adrian!<br></p><p>&gt; On Jun 24, 2016, at 10:01 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I don’t like an underscore on public protocols. If we’re not forced to use the proposed syntax at all it looks strange when you use a type with an underscore (which to me represents something for private or internal usage).<br>&gt; <br>&gt; <br>The underscore is used in the same way it is used elsewhere in the standard library.  The protocols must be public because they need to be visible to user code in order for the design to work correctly.  However, they are considered implementation details that users really shouldn’t know about.  This pattern is well established in the standard library.<br></p><p>&gt; In Swift we only can use literals for a single direction literal -&gt; type, so why don’t we just rename the protocols to look like:<br>&gt; <br>&gt; <br>This is a reasonable suggestion.  I’ll add it to the alternatives section.<br>&gt; public protocol NilLiteralProtocol { ... }<br>&gt; public protocol BooleanLiteralProtocol { ... }<br>&gt; public protocol FloatLiteralProtocol { ... }<br>&gt; public protocol IntegerLiteralProtocol { ... }<br>&gt; public protocol UnicodeScalarLiteralProtocol { ... }<br>&gt; public protocol ExtendedGraphemeClusterProtocol { ... }<br>&gt; public protocol StringLiteralLiteralProtocol { ... }<br>&gt; public protocol StringInterpolationLiteralProtocol { ... }<br>&gt; public protocol ArrayLiteralProtocol { ... }<br>&gt; public protocol DictionaryLiteralProtocol { ... }<br>&gt; Here Protocol corresponds to the user that we’re about to access a specific literal with our type which implements the protocol. (Just like ErrorProtocol.)<br>&gt; - extension Array : ArrayLiteralConvertible<br>&gt; + extension Array : ArrayLiteralProtocol<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 24. Juni 2016 um 16:21:21, Vladimir.S via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt; <br>&gt;&gt; es are<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/942c4486/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7e554db1f80d7d6041d92edd5145698?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Hooman Mehr</string> &lt;hooman at mac.com&gt;<p>June 26, 2016 at 08:00:00am</p></header><div class="content"><p>Syntax by itself is not clear enough. Appending Initializable makes it too long. <br></p><p>We can replace Syntax with LiteralSyntax to clarify. Then we will have:<br></p><p>extension MyNumber: LiteralSyntax.Integer, LiteralSyntax.Float { /*…*/ }<br></p><p>Better yet, to address the valid concern of doing something so different and hack-like for literals, how about simply renaming *LiteralConvertible protocols to *LiteralSyntax or LiteralSyntax*. The key is the LiteralSyntax phrase which (I think) is the clearest short phrase we can get to communicate the intent. Look: It is right there in the title!<br></p><p>&gt; On Jun 23, 2016, at 8:31 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have completed a draft of a proposal to move the `*LiteralConvertible` protocols into a `Syntax` namespace as suggested by the standard library team. <br>&gt; <br>&gt; The draft can be found here: https://gist.github.com/anandabits/99dad2305d310874bd613b72b14eee56 &lt;https://gist.github.com/anandabits/99dad2305d310874bd613b72b14eee56&gt;.  It is also included below.<br>&gt; <br>&gt; I will submit a PR in the next day or two after incorporating any feedback.<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt; Literal Syntax Protocols<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;file:///Users/Matthew/Library/Containers/com.brettterpstra.marked2/Data/Library/Caches/Marked%202/Watchers/NNNN-literal-syntax-protocols.md&gt;<br>&gt; Author: Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; This proposal renames the *LiteralConvertible protocols to Syntax.*Literal. <br>&gt; <br>&gt; Swift-evolution thread: Revisiting SE–0041 Names &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/21290&gt;<br>&gt; Motivation<br>&gt; <br>&gt; The standard library currently has protocols that use the term Convertible in two different ways. The *LiteralConvertible protocols use the meaning of converting from a literal. The Custom(Debug)StringConvertible protocols use the meaning of converting to a String. This causes confusion for developers attempting to name their own protocols following the precedence established by the standard library.<br>&gt; <br>&gt; Further, the standard library team has observed:<br>&gt; <br>&gt; The &quot;literal&quot; protocols are not about conversion, they are about adopting a certain syntax provided by the language.  &quot;Convertible&quot; in the name is a red herring: a type can&#39;t be convertible from an integer literal because there is no &quot;IntegerLiteral&quot; entity in the type system.  The literal *becomes* typed as the corresponding literal type (e.g., Int or String), and as far as the user at the call site is concerned, there is no visible conversion (even if one is happening behind the scenes)<br>&gt; An earlier proposal &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt; was intended to address the first problem by introducing strong naming conventions for three kinds of conversion protocols (from, to, and bidirectional). The review highlighted the difficulity in establishing conventions that everyone is happy with. This proposal takes a different approach to solving the problem that originally inspired that proposal while also solving the awkwardness of the current names described by the standard library team.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; This proposal addresses both problems by introducing a Syntax “namespace” and moving the *LiteralConvertible protocols into that “namespace” while also renaming them. The proposal does not make any changes to the requirements of the protocols.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; All of the *LiteralConvertible protocols will receive new *Literal names inside a Syntaxnamespace. <br>&gt; <br>&gt; This namespace will initially be implemented using a case-less enum, but this detail may change in the future if submodules or namespaces are added to Swift. Swift does not currently allow protocols to be declared inside the scope of a type. In order to work around this limitation the protocols themselves will be declared using underscore-prefixed names internal to the standard library. Typealiases inside the Syntax enum will declare the names intended to be visible to user code.<br>&gt; <br>&gt; This proposal does not change any requirements of these protocols. All requirements of all *LiteralConvertible protocols will remain exactly the same.<br>&gt; <br>&gt; The following protocol declarations and names:<br>&gt; <br>&gt; public protocol NilLiteralConvertible { ... }<br>&gt; public protocol BooleanLiteralConvertible { ... }<br>&gt; public protocol FloatLiteralConvertible { ... }<br>&gt; public protocol IntegerLiteralConvertible { ... }<br>&gt; public protocol UnicodeScalarLiteralConvertible { ... }<br>&gt; public protocol ExtendedGraphemeClusterConvertible { ... }<br>&gt; public protocol StringLiteralLiteralConvertible { ... }<br>&gt; public protocol StringInterpolationLiteralConvertible { ... }<br>&gt; public protocol ArrayLiteralConvertible { ... }<br>&gt; public protocol DictionaryLiteralConvertible { ... }<br>&gt; Are changed as follows:<br>&gt; <br>&gt; <br>&gt; public protocol _NilLiteralSyntax { ... }<br>&gt; public protocol _BooleanLiteralSyntax { ... }<br>&gt; public protocol _IntegerLiteralSyntax { ... }<br>&gt; public protocol _FloatLiteralSyntax { ... }<br>&gt; public protocol _UnicodeScalarLiteralSyntax { ... }<br>&gt; public protocol _ExtendedGraphemeClusterLiteralSyntax { ... }<br>&gt; public protocol _StringLiteralLiteralSyntax { ... }<br>&gt; public protocol _StringInterpolationLiteralSyntax { ... }<br>&gt; public protocol _ArrayLiteralSyntax { ... }<br>&gt; public protocol _DictionaryLiteralSyntax { ... }<br>&gt; <br>&gt; public /* closed */ enum Syntax {<br>&gt;   public typealias NilLiteral = _NilLiteralSyntax<br>&gt;   public typealias BooleanLiteral = _BooleanLiteralSyntax<br>&gt;   public typealias IntegerLiteral = _IntegerLiteralSyntax<br>&gt;   public typealias FloatLiteral = _FloatLiteralSyntax<br>&gt;   public typealias UnicodeScalarLiteral = _UnicodeScalarLiteralSyntax<br>&gt;   public typealias ExtendedGraphemeClusterLiteral = _ExtendedGraphemeClusterLiteralSyntax<br>&gt;   public typealias StringLiteralLiteral = _StringLiteralLiteralSyntax<br>&gt;   public typealias StringInterplolationLiteral = _StringInterpolationLiteralSyntax<br>&gt;   public typealias ArrayrLiteral = _ArrayLiteralSyntax<br>&gt;   public typealias DictionaryLiteral = _DictionaryLiteralSyntax<br>&gt; }<br>&gt; Impact on existing code<br>&gt; <br>&gt; All code that references any of the *LiteralConvertible protocols will need to be modified to reference the protocol via the new Syntax.*Literal name.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Protocol names<br>&gt; <br>&gt; Several commenters have suggested that the names in this proposal are confusing at the site of use:<br>&gt; <br>&gt; struct Foo: Syntax.IntegerLiteral { ... }<br>&gt; One alternative naming scheme would emphasize the semantic of initializing the type with a literal:<br>&gt; <br>&gt; struct Foo: Syntax.IntegerLiteralInitializable { ... }<br>&gt; Discussion of the pros and cons of the proposed and alternative naming schemes is encouraged. The core team should feel free to make a final decision on the exact naming scheme used if they choose to accept this proposal.<br>&gt; <br>&gt; Previous proposal<br>&gt; <br>&gt; This proposal is a follow up to Updating Protocol Naming Conventions for Conversions &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt;. Many related alternatives were explored during the discussion and review of that proposal.<br>&gt; <br>&gt; Acknowledgements<br>&gt; <br>&gt; The design described in this proposal was suggested by Dave Abrahams, Dmitri Gribenko, and Maxim Moiseev.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160626/d8998239/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>June 26, 2016 at 01:00:00pm</p></header><div class="content"><p>what about `*LiteralRepresentable`?<br></p><p>On Sun, Jun 26, 2016 at 11:11 AM, Hooman Mehr via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Syntax by itself is not clear enough. Appending Initializable makes it too<br>&gt; long.<br>&gt;<br>&gt; We can replace Syntax with LiteralSyntax to clarify. Then we will have:<br>&gt;<br>&gt; extension MyNumber: LiteralSyntax.Integer, LiteralSyntax.Float { /*…*/ }<br>&gt;<br>&gt; Better yet, to address the valid concern of doing something so different<br>&gt; and hack-like for literals, how about simply *renaming<br>&gt; *LiteralConvertible protocols to *LiteralSyntax or LiteralSyntax*.* The<br>&gt; key is the *LiteralSyntax* phrase which (I think) is the clearest short<br>&gt; phrase we can get to communicate the intent. Look: It is right there in the<br>&gt; title!<br>&gt;<br>&gt; On Jun 23, 2016, at 8:31 AM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I have completed a draft of a proposal to move the `*LiteralConvertible`<br>&gt; protocols into a `Syntax` namespace as suggested by the standard library<br>&gt; team.<br>&gt;<br>&gt; The draft can be found here:<br>&gt; https://gist.github.com/anandabits/99dad2305d310874bd613b72b14eee56.  It<br>&gt; is also included below.<br>&gt;<br>&gt; I will submit a PR in the next day or two after incorporating any feedback.<br>&gt;<br>&gt; -Matthew<br>&gt;<br>&gt; Literal Syntax Protocols<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    - Author: Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt;    - Status: *Awaiting review*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal renames the *LiteralConvertible protocols to Syntax.*Literal<br>&gt; .<br>&gt;<br>&gt; Swift-evolution thread: Revisiting SE–0041 Names<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/21290&gt;<br>&gt; Motivation<br>&gt;<br>&gt; The standard library currently has protocols that use the term Convertible in<br>&gt; two different ways. The *LiteralConvertible protocols use the meaning of<br>&gt; converting *from* a literal. The Custom(Debug)StringConvertible protocols<br>&gt; use the meaning of converting *to* a String. This causes confusion for<br>&gt; developers attempting to name their own protocols following the precedence<br>&gt; established by the standard library.<br>&gt;<br>&gt; Further, the standard library team has observed:<br>&gt;<br>&gt; The &quot;literal&quot; protocols are not about conversion, they are about adopting a certain syntax provided by the language.  &quot;Convertible&quot; in the name is a red herring: a type can&#39;t be convertible from an integer literal because there is no &quot;IntegerLiteral&quot; entity in the type system.  The literal *becomes* typed as the corresponding literal type (e.g., Int or String), and as far as the user at the call site is concerned, there is no visible conversion (even if one is happening behind the scenes)<br>&gt;<br>&gt; An earlier proposal<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt; was<br>&gt; intended to address the first problem by introducing strong naming<br>&gt; conventions for three kinds of conversion protocols (*from*, *to*, and<br>&gt; *bidirectional*). The review highlighted the difficulity in establishing<br>&gt; conventions that everyone is happy with. This proposal takes a different<br>&gt; approach to solving the problem that originally inspired that proposal<br>&gt; while also solving the awkwardness of the current names described by the<br>&gt; standard library team.<br>&gt; Proposed solution<br>&gt;<br>&gt; This proposal addresses both problems by introducing a Syntax “namespace”<br>&gt; and moving the *LiteralConvertible protocols into that “namespace” while<br>&gt; also renaming them. The proposal *does not* make any changes to the<br>&gt; requirements of the protocols.<br>&gt; Detailed design<br>&gt;<br>&gt; All of the *LiteralConvertible protocols will receive new *Literal names<br>&gt; inside a Syntaxnamespace.<br>&gt;<br>&gt; This namespace will initially be implemented using a case-less enum, but<br>&gt; this detail may change in the future if submodules or namespaces are added<br>&gt; to Swift. Swift does not currently allow protocols to be declared inside<br>&gt; the scope of a type. In order to work around this limitation the protocols<br>&gt; themselves will be declared using underscore-prefixed names internal to the<br>&gt; standard library. Typealiases inside the Syntax enum will declare the<br>&gt; names intended to be visible to user code.<br>&gt;<br>&gt; This proposal does not change any requirements of these protocols. All<br>&gt; requirements of all *LiteralConvertible protocols will remain exactly the<br>&gt; same.<br>&gt;<br>&gt; The following protocol declarations and names:<br>&gt;<br>&gt; public protocol NilLiteralConvertible { ... }public protocol BooleanLiteralConvertible { ... }public protocol FloatLiteralConvertible { ... }public protocol IntegerLiteralConvertible { ... }public protocol UnicodeScalarLiteralConvertible { ... }public protocol ExtendedGraphemeClusterConvertible { ... }public protocol StringLiteralLiteralConvertible { ... }public protocol StringInterpolationLiteralConvertible { ... }public protocol ArrayLiteralConvertible { ... }public protocol DictionaryLiteralConvertible { ... }<br>&gt;<br>&gt; Are changed as follows:<br>&gt;<br>&gt; public protocol _NilLiteralSyntax { ... }public protocol _BooleanLiteralSyntax { ... }public protocol _IntegerLiteralSyntax { ... }public protocol _FloatLiteralSyntax { ... }public protocol _UnicodeScalarLiteralSyntax { ... }public protocol _ExtendedGraphemeClusterLiteralSyntax { ... }public protocol _StringLiteralLiteralSyntax { ... }public protocol _StringInterpolationLiteralSyntax { ... }public protocol _ArrayLiteralSyntax { ... }public protocol _DictionaryLiteralSyntax { ... }<br>&gt; public /* closed */ enum Syntax {<br>&gt;   public typealias NilLiteral = _NilLiteralSyntax<br>&gt;   public typealias BooleanLiteral = _BooleanLiteralSyntax<br>&gt;   public typealias IntegerLiteral = _IntegerLiteralSyntax<br>&gt;   public typealias FloatLiteral = _FloatLiteralSyntax<br>&gt;   public typealias UnicodeScalarLiteral = _UnicodeScalarLiteralSyntax<br>&gt;   public typealias ExtendedGraphemeClusterLiteral = _ExtendedGraphemeClusterLiteralSyntax<br>&gt;   public typealias StringLiteralLiteral = _StringLiteralLiteralSyntax<br>&gt;   public typealias StringInterplolationLiteral = _StringInterpolationLiteralSyntax<br>&gt;   public typealias ArrayrLiteral = _ArrayLiteralSyntax<br>&gt;   public typealias DictionaryLiteral = _DictionaryLiteralSyntax<br>&gt; }<br>&gt;<br>&gt; Impact on existing code<br>&gt;<br>&gt; All code that references any of the *LiteralConvertible protocols will<br>&gt; need to be modified to reference the protocol via the new Syntax.*Literal<br>&gt;  name.<br>&gt; Alternatives consideredProtocol names<br>&gt;<br>&gt; Several commenters have suggested that the names in this proposal are<br>&gt; confusing at the site of use:<br>&gt;<br>&gt; struct Foo: Syntax.IntegerLiteral { ... }<br>&gt;<br>&gt; One alternative naming scheme would emphasize the semantic of initializing<br>&gt; the type with a literal:<br>&gt;<br>&gt; struct Foo: Syntax.IntegerLiteralInitializable { ... }<br>&gt;<br>&gt; Discussion of the pros and cons of the proposed and alternative naming<br>&gt; schemes is encouraged. The core team should feel free to make a final<br>&gt; decision on the exact naming scheme used if they choose to accept this<br>&gt; proposal.<br>&gt; Previous proposal<br>&gt;<br>&gt; This proposal is a follow up to Updating Protocol Naming Conventions for<br>&gt; Conversions<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt;.<br>&gt; Many related alternatives were explored during the discussion and review of<br>&gt; that proposal.<br>&gt; Acknowledgements<br>&gt;<br>&gt; The design described in this proposal was suggested by Dave Abrahams,<br>&gt; Dmitri Gribenko, and Maxim Moiseev.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160626/e2d73be0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7e554db1f80d7d6041d92edd5145698?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Hooman Mehr</string> &lt;hooman at mac.com&gt;<p>June 26, 2016 at 11:00:00am</p></header><div class="content"><p>This is already rejected for not being clear enough. We can express some Double values using integer literal syntax, because integers are a subset of floating point numbers but not the other way around. Representable seems to imply it should work both ways.<br></p><p>*LiteralConvertible protocols indicate that we can always use the syntax of the given kind[1] of literal to create an instance of that type. This operation is inherently one way as Literal is a concept that is defined in the context of the source code under compilation. <br></p><p>Compiler converts a literal (a stream of characters in the source code that adhere to the syntax of a given kind of literal) to an instance of some type. This is where the original Convertible comes from. <br></p><p>As you see this is all about compiler and language syntax. That is why the new round of suggested names focus on Compiler and Syntax words to keep the domain clear. It is unfortunate that it does not fit the API guidelines protocol naming conventions.<br></p><p>[1] I am avoiding the use of word “type” here to avoid confusion.<br> <br></p><p>&gt; On Jun 26, 2016, at 10:06 AM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; <br>&gt; what about `*LiteralRepresentable`?<br>&gt; <br>&gt; On Sun, Jun 26, 2016 at 11:11 AM, Hooman Mehr via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Syntax by itself is not clear enough. Appending Initializable makes it too long. <br>&gt; <br>&gt; We can replace Syntax with LiteralSyntax to clarify. Then we will have:<br>&gt; <br>&gt; extension MyNumber: LiteralSyntax.Integer, LiteralSyntax.Float { /*…*/ }<br>&gt; <br>&gt; Better yet, to address the valid concern of doing something so different and hack-like for literals, how about simply renaming *LiteralConvertible protocols to *LiteralSyntax or LiteralSyntax*. The key is the LiteralSyntax phrase which (I think) is the clearest short phrase we can get to communicate the intent. Look: It is right there in the title!<br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 8:31 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have completed a draft of a proposal to move the `*LiteralConvertible` protocols into a `Syntax` namespace as suggested by the standard library team. <br>&gt;&gt; <br>&gt;&gt; The draft can be found here: https://gist.github.com/anandabits/99dad2305d310874bd613b72b14eee56 &lt;https://gist.github.com/anandabits/99dad2305d310874bd613b72b14eee56&gt;.  It is also included below.<br>&gt;&gt; <br>&gt;&gt; I will submit a PR in the next day or two after incorporating any feedback.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt; Literal Syntax Protocols<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;&gt;<br>&gt;&gt; Author: Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal renames the *LiteralConvertible protocols to Syntax.*Literal. <br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: Revisiting SE–0041 Names &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/21290&gt;<br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; The standard library currently has protocols that use the term Convertible in two different ways. The *LiteralConvertible protocols use the meaning of converting from a literal. The Custom(Debug)StringConvertible protocols use the meaning of converting to a String. This causes confusion for developers attempting to name their own protocols following the precedence established by the standard library.<br>&gt;&gt; <br>&gt;&gt; Further, the standard library team has observed:<br>&gt;&gt; <br>&gt;&gt; The &quot;literal&quot; protocols are not about conversion, they are about adopting a certain syntax provided by the language.  &quot;Convertible&quot; in the name is a red herring: a type can&#39;t be convertible from an integer literal because there is no &quot;IntegerLiteral&quot; entity in the type system.  The literal *becomes* typed as the corresponding literal type (e.g., Int or String), and as far as the user at the call site is concerned, there is no visible conversion (even if one is happening behind the scenes)<br>&gt;&gt; An earlier proposal &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt; was intended to address the first problem by introducing strong naming conventions for three kinds of conversion protocols (from, to, and bidirectional). The review highlighted the difficulity in establishing conventions that everyone is happy with. This proposal takes a different approach to solving the problem that originally inspired that proposal while also solving the awkwardness of the current names described by the standard library team.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; This proposal addresses both problems by introducing a Syntax “namespace” and moving the *LiteralConvertible protocols into that “namespace” while also renaming them. The proposal does not make any changes to the requirements of the protocols.<br>&gt;&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; All of the *LiteralConvertible protocols will receive new *Literal names inside a Syntaxnamespace. <br>&gt;&gt; <br>&gt;&gt; This namespace will initially be implemented using a case-less enum, but this detail may change in the future if submodules or namespaces are added to Swift. Swift does not currently allow protocols to be declared inside the scope of a type. In order to work around this limitation the protocols themselves will be declared using underscore-prefixed names internal to the standard library. Typealiases inside the Syntax enum will declare the names intended to be visible to user code.<br>&gt;&gt; <br>&gt;&gt; This proposal does not change any requirements of these protocols. All requirements of all *LiteralConvertible protocols will remain exactly the same.<br>&gt;&gt; <br>&gt;&gt; The following protocol declarations and names:<br>&gt;&gt; <br>&gt;&gt; public protocol NilLiteralConvertible { ... }<br>&gt;&gt; public protocol BooleanLiteralConvertible { ... }<br>&gt;&gt; public protocol FloatLiteralConvertible { ... }<br>&gt;&gt; public protocol IntegerLiteralConvertible { ... }<br>&gt;&gt; public protocol UnicodeScalarLiteralConvertible { ... }<br>&gt;&gt; public protocol ExtendedGraphemeClusterConvertible { ... }<br>&gt;&gt; public protocol StringLiteralLiteralConvertible { ... }<br>&gt;&gt; public protocol StringInterpolationLiteralConvertible { ... }<br>&gt;&gt; public protocol ArrayLiteralConvertible { ... }<br>&gt;&gt; public protocol DictionaryLiteralConvertible { ... }<br>&gt;&gt; Are changed as follows:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; public protocol _NilLiteralSyntax { ... }<br>&gt;&gt; public protocol _BooleanLiteralSyntax { ... }<br>&gt;&gt; public protocol _IntegerLiteralSyntax { ... }<br>&gt;&gt; public protocol _FloatLiteralSyntax { ... }<br>&gt;&gt; public protocol _UnicodeScalarLiteralSyntax { ... }<br>&gt;&gt; public protocol _ExtendedGraphemeClusterLiteralSyntax { ... }<br>&gt;&gt; public protocol _StringLiteralLiteralSyntax { ... }<br>&gt;&gt; public protocol _StringInterpolationLiteralSyntax { ... }<br>&gt;&gt; public protocol _ArrayLiteralSyntax { ... }<br>&gt;&gt; public protocol _DictionaryLiteralSyntax { ... }<br>&gt;&gt; <br>&gt;&gt; public /* closed */ enum Syntax {<br>&gt;&gt;   public typealias NilLiteral = _NilLiteralSyntax<br>&gt;&gt;   public typealias BooleanLiteral = _BooleanLiteralSyntax<br>&gt;&gt;   public typealias IntegerLiteral = _IntegerLiteralSyntax<br>&gt;&gt;   public typealias FloatLiteral = _FloatLiteralSyntax<br>&gt;&gt;   public typealias UnicodeScalarLiteral = _UnicodeScalarLiteralSyntax<br>&gt;&gt;   public typealias ExtendedGraphemeClusterLiteral = _ExtendedGraphemeClusterLiteralSyntax<br>&gt;&gt;   public typealias StringLiteralLiteral = _StringLiteralLiteralSyntax<br>&gt;&gt;   public typealias StringInterplolationLiteral = _StringInterpolationLiteralSyntax<br>&gt;&gt;   public typealias ArrayrLiteral = _ArrayLiteralSyntax<br>&gt;&gt;   public typealias DictionaryLiteral = _DictionaryLiteralSyntax<br>&gt;&gt; }<br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; All code that references any of the *LiteralConvertible protocols will need to be modified to reference the protocol via the new Syntax.*Literal name.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Protocol names<br>&gt;&gt; <br>&gt;&gt; Several commenters have suggested that the names in this proposal are confusing at the site of use:<br>&gt;&gt; <br>&gt;&gt; struct Foo: Syntax.IntegerLiteral { ... }<br>&gt;&gt; One alternative naming scheme would emphasize the semantic of initializing the type with a literal:<br>&gt;&gt; <br>&gt;&gt; struct Foo: Syntax.IntegerLiteralInitializable { ... }<br>&gt;&gt; Discussion of the pros and cons of the proposed and alternative naming schemes is encouraged. The core team should feel free to make a final decision on the exact naming scheme used if they choose to accept this proposal.<br>&gt;&gt; <br>&gt;&gt; Previous proposal<br>&gt;&gt; <br>&gt;&gt; This proposal is a follow up to Updating Protocol Naming Conventions for Conversions &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt;. Many related alternatives were explored during the discussion and review of that proposal.<br>&gt;&gt; <br>&gt;&gt; Acknowledgements<br>&gt;&gt; <br>&gt;&gt; The design described in this proposal was suggested by Dave Abrahams, Dmitri Gribenko, and Maxim Moiseev.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160626/e2d75472/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 27, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 26, 2016, at 10:11 AM, Hooman Mehr &lt;hooman at mac.com&gt; wrote:<br>&gt; <br>&gt; Syntax by itself is not clear enough. Appending Initializable makes it too long. <br>&gt; <br>&gt; We can replace Syntax with LiteralSyntax to clarify. Then we will have:<br>&gt; <br>&gt; extension MyNumber: LiteralSyntax.Integer, LiteralSyntax.Float { /*…*/ }<br>&gt; <br>&gt; Better yet, to address the valid concern of doing something so different and hack-like for literals, how about simply renaming *LiteralConvertible protocols to *LiteralSyntax or LiteralSyntax*. The key is the LiteralSyntax phrase which (I think) is the clearest short phrase we can get to communicate the intent. Look: It is right there in the title!<br></p><p>This looks reasonable if you only focus on the existing protocols.  However, I believe the intent of this namespace is that it can support any syntax-related protocols that might emerge in the future whether they are related to literals or not.  With that in mind, I don’t think `LiteralSyntax` will fly as it isn’t general enough to support that.<br></p><p>&gt; <br>&gt;&gt; On Jun 23, 2016, at 8:31 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have completed a draft of a proposal to move the `*LiteralConvertible` protocols into a `Syntax` namespace as suggested by the standard library team. <br>&gt;&gt; <br>&gt;&gt; The draft can be found here: https://gist.github.com/anandabits/99dad2305d310874bd613b72b14eee56 &lt;https://gist.github.com/anandabits/99dad2305d310874bd613b72b14eee56&gt;.  It is also included below.<br>&gt;&gt; <br>&gt;&gt; I will submit a PR in the next day or two after incorporating any feedback.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt; Literal Syntax Protocols<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;file:///Users/Matthew/Library/Containers/com.brettterpstra.marked2/Data/Library/Caches/Marked%202/Watchers/NNNN-literal-syntax-protocols.md&gt;<br>&gt;&gt; Author: Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal renames the *LiteralConvertible protocols to Syntax.*Literal. <br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: Revisiting SE–0041 Names &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/21290&gt;<br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; The standard library currently has protocols that use the term Convertible in two different ways. The *LiteralConvertible protocols use the meaning of converting from a literal. The Custom(Debug)StringConvertible protocols use the meaning of converting to a String. This causes confusion for developers attempting to name their own protocols following the precedence established by the standard library.<br>&gt;&gt; <br>&gt;&gt; Further, the standard library team has observed:<br>&gt;&gt; <br>&gt;&gt; The &quot;literal&quot; protocols are not about conversion, they are about adopting a certain syntax provided by the language.  &quot;Convertible&quot; in the name is a red herring: a type can&#39;t be convertible from an integer literal because there is no &quot;IntegerLiteral&quot; entity in the type system.  The literal *becomes* typed as the corresponding literal type (e.g., Int or String), and as far as the user at the call site is concerned, there is no visible conversion (even if one is happening behind the scenes)<br>&gt;&gt; An earlier proposal &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt; was intended to address the first problem by introducing strong naming conventions for three kinds of conversion protocols (from, to, and bidirectional). The review highlighted the difficulity in establishing conventions that everyone is happy with. This proposal takes a different approach to solving the problem that originally inspired that proposal while also solving the awkwardness of the current names described by the standard library team.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; This proposal addresses both problems by introducing a Syntax “namespace” and moving the *LiteralConvertible protocols into that “namespace” while also renaming them. The proposal does not make any changes to the requirements of the protocols.<br>&gt;&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; All of the *LiteralConvertible protocols will receive new *Literal names inside a Syntaxnamespace. <br>&gt;&gt; <br>&gt;&gt; This namespace will initially be implemented using a case-less enum, but this detail may change in the future if submodules or namespaces are added to Swift. Swift does not currently allow protocols to be declared inside the scope of a type. In order to work around this limitation the protocols themselves will be declared using underscore-prefixed names internal to the standard library. Typealiases inside the Syntax enum will declare the names intended to be visible to user code.<br>&gt;&gt; <br>&gt;&gt; This proposal does not change any requirements of these protocols. All requirements of all *LiteralConvertible protocols will remain exactly the same.<br>&gt;&gt; <br>&gt;&gt; The following protocol declarations and names:<br>&gt;&gt; <br>&gt;&gt; public protocol NilLiteralConvertible { ... }<br>&gt;&gt; public protocol BooleanLiteralConvertible { ... }<br>&gt;&gt; public protocol FloatLiteralConvertible { ... }<br>&gt;&gt; public protocol IntegerLiteralConvertible { ... }<br>&gt;&gt; public protocol UnicodeScalarLiteralConvertible { ... }<br>&gt;&gt; public protocol ExtendedGraphemeClusterConvertible { ... }<br>&gt;&gt; public protocol StringLiteralLiteralConvertible { ... }<br>&gt;&gt; public protocol StringInterpolationLiteralConvertible { ... }<br>&gt;&gt; public protocol ArrayLiteralConvertible { ... }<br>&gt;&gt; public protocol DictionaryLiteralConvertible { ... }<br>&gt;&gt; Are changed as follows:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; public protocol _NilLiteralSyntax { ... }<br>&gt;&gt; public protocol _BooleanLiteralSyntax { ... }<br>&gt;&gt; public protocol _IntegerLiteralSyntax { ... }<br>&gt;&gt; public protocol _FloatLiteralSyntax { ... }<br>&gt;&gt; public protocol _UnicodeScalarLiteralSyntax { ... }<br>&gt;&gt; public protocol _ExtendedGraphemeClusterLiteralSyntax { ... }<br>&gt;&gt; public protocol _StringLiteralLiteralSyntax { ... }<br>&gt;&gt; public protocol _StringInterpolationLiteralSyntax { ... }<br>&gt;&gt; public protocol _ArrayLiteralSyntax { ... }<br>&gt;&gt; public protocol _DictionaryLiteralSyntax { ... }<br>&gt;&gt; <br>&gt;&gt; public /* closed */ enum Syntax {<br>&gt;&gt;   public typealias NilLiteral = _NilLiteralSyntax<br>&gt;&gt;   public typealias BooleanLiteral = _BooleanLiteralSyntax<br>&gt;&gt;   public typealias IntegerLiteral = _IntegerLiteralSyntax<br>&gt;&gt;   public typealias FloatLiteral = _FloatLiteralSyntax<br>&gt;&gt;   public typealias UnicodeScalarLiteral = _UnicodeScalarLiteralSyntax<br>&gt;&gt;   public typealias ExtendedGraphemeClusterLiteral = _ExtendedGraphemeClusterLiteralSyntax<br>&gt;&gt;   public typealias StringLiteralLiteral = _StringLiteralLiteralSyntax<br>&gt;&gt;   public typealias StringInterplolationLiteral = _StringInterpolationLiteralSyntax<br>&gt;&gt;   public typealias ArrayrLiteral = _ArrayLiteralSyntax<br>&gt;&gt;   public typealias DictionaryLiteral = _DictionaryLiteralSyntax<br>&gt;&gt; }<br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; All code that references any of the *LiteralConvertible protocols will need to be modified to reference the protocol via the new Syntax.*Literal name.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Protocol names<br>&gt;&gt; <br>&gt;&gt; Several commenters have suggested that the names in this proposal are confusing at the site of use:<br>&gt;&gt; <br>&gt;&gt; struct Foo: Syntax.IntegerLiteral { ... }<br>&gt;&gt; One alternative naming scheme would emphasize the semantic of initializing the type with a literal:<br>&gt;&gt; <br>&gt;&gt; struct Foo: Syntax.IntegerLiteralInitializable { ... }<br>&gt;&gt; Discussion of the pros and cons of the proposed and alternative naming schemes is encouraged. The core team should feel free to make a final decision on the exact naming scheme used if they choose to accept this proposal.<br>&gt;&gt; <br>&gt;&gt; Previous proposal<br>&gt;&gt; <br>&gt;&gt; This proposal is a follow up to Updating Protocol Naming Conventions for Conversions &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt;. Many related alternatives were explored during the discussion and review of that proposal.<br>&gt;&gt; <br>&gt;&gt; Acknowledgements<br>&gt;&gt; <br>&gt;&gt; The design described in this proposal was suggested by Dave Abrahams, Dmitri Gribenko, and Maxim Moiseev.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/0e06243d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>June 27, 2016 at 01:00:00pm</p></header><div class="content"><p>&lt;https://github.com/apple/swift-evolution/pull/381&gt;<br></p><p>CORRECTIONS:<br></p><p>Find:    &quot;ExtendedGraphemeClusterConvertible&quot;<br>Replace: &quot;ExtendedGraphemeClusterLiteralConvertible&quot;<br></p><p>Find:    &quot;StringInterpolationLiteralConvertible&quot;<br>Replace: &quot;StringInterpolationConvertible&quot;<br></p><p>Find:    &quot;StringLiteralLiteral&quot; (x5)<br>Replace: &quot;StringLiteral&quot;<br></p><p>Find:    &quot;ArrayrLiteral&quot;<br>Replace: &quot;ArrayLiteral&quot;<br></p><p>SUGGESTIONS:<br></p><p>Should the `DictionaryLiteral` structure be renamed?<br>&lt;https://developer.apple.com/reference/swift/dictionaryliteral&gt;<br>It isn&#39;t a dictionary or a literal, it&#39;s an ordered collection.<br></p><p>Can we also change `ExtendedGraphemeCluster` to `Character`?<br>This would affect the argument label, global type alias, etc.<br></p><p>-- Ben<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 27, 2016 at 01:00:00pm</p></header><div class="content"><p>DictionaryLiteral seems fine to me; it&#39;s as much a dictionary as<br>ArrayLiteral is an array, right?<br></p><p>What&#39;s wrong with ExtendedGraphemeCluster? It precisely self-documents what<br>must exist between the double quotes to qualify as such a literal. Plus, we<br>don&#39;t have e.g. a single-quoted character type; the name CharacterLiteral<br>is a misnomer for what&#39;s effectively a string literal constrained by length.<br></p><p>Likewise, it&#39;s not a StringInterpolationLiteral but StringInterpolation;<br>there&#39;s no syntax for demarcating it, so it&#39;s a string literal constrained<br>by what&#39;s between the double quotes.<br>On Mon, Jun 27, 2016 at 08:40 Ben Rimmington via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &lt;https://github.com/apple/swift-evolution/pull/381&gt;<br>&gt;<br>&gt; CORRECTIONS:<br>&gt;<br>&gt; Find:    &quot;ExtendedGraphemeClusterConvertible&quot;<br>&gt; Replace: &quot;ExtendedGraphemeClusterLiteralConvertible&quot;<br>&gt;<br>&gt; Find:    &quot;StringInterpolationLiteralConvertible&quot;<br>&gt; Replace: &quot;StringInterpolationConvertible&quot;<br>&gt;<br>&gt; Find:    &quot;StringLiteralLiteral&quot; (x5)<br>&gt; Replace: &quot;StringLiteral&quot;<br>&gt;<br>&gt; Find:    &quot;ArrayrLiteral&quot;<br>&gt; Replace: &quot;ArrayLiteral&quot;<br>&gt;<br>&gt; SUGGESTIONS:<br>&gt;<br>&gt; Should the `DictionaryLiteral` structure be renamed?<br>&gt; &lt;https://developer.apple.com/reference/swift/dictionaryliteral&gt;<br>&gt; It isn&#39;t a dictionary or a literal, it&#39;s an ordered collection.<br>&gt;<br>&gt; Can we also change `ExtendedGraphemeCluster` to `Character`?<br>&gt; This would affect the argument label, global type alias, etc.<br>&gt;<br>&gt; -- Ben<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/178ab83d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>June 27, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On 27 Jun 2016, at 14:37, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; DictionaryLiteral seems fine to me; it&#39;s as much a dictionary as ArrayLiteral is an array, right?<br></p><p>The `DictionaryLiteral` *structure* isn&#39;t a hash table.<br>It&#39;s an array of key-value pairs, and allows duplicate keys.<br>Entries are accessed by their position, not by their key.<br>&lt;https://developer.apple.com/reference/swift/dictionaryliteral&gt;<br></p><p>&gt; What&#39;s wrong with ExtendedGraphemeCluster? It precisely self-documents what must exist between the double quotes to qualify as such a literal. Plus, we don&#39;t have e.g. a single-quoted character type; the name CharacterLiteral is a misnomer for what&#39;s effectively a string literal constrained by length.<br></p><p>The `ExtendedGraphemeCluster` prefix is verbose.<br>The `Character` *structure* is already defined as:<br>&quot;A single extended grapheme cluster, ...&quot;<br>Why have different names for the same concept?<br>&lt;https://developer.apple.com/reference/swift/character&gt;<br></p><p>&gt; Likewise, it&#39;s not a StringInterpolationLiteral but StringInterpolation; there&#39;s no syntax for demarcating it, so it&#39;s a string literal constrained by what&#39;s between the double quotes.<br></p><p>The design team suggested `InterpolatedStringLiteral` in their SE-0041 feedback.<br>&lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md#response-to-design-team-feedback&gt;<br></p><p>I suggested using protocol inheritance.<br>&lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/17229&gt;<br></p><p>-- Ben<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Literal Syntax Protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 27, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 7:40 AM, Ben Rimmington &lt;me at benrimmington.com&gt; wrote:<br>&gt; <br>&gt; &lt;https://github.com/apple/swift-evolution/pull/381&gt;<br>&gt; <br>&gt; CORRECTIONS:<br>&gt; <br>&gt; Find:    &quot;ExtendedGraphemeClusterConvertible&quot;<br>&gt; Replace: &quot;ExtendedGraphemeClusterLiteralConvertible&quot;<br>&gt; <br>&gt; Find:    &quot;StringInterpolationLiteralConvertible&quot;<br>&gt; Replace: &quot;StringInterpolationConvertible&quot;<br>&gt; <br>&gt; Find:    &quot;StringLiteralLiteral&quot; (x5)<br>&gt; Replace: &quot;StringLiteral&quot;<br>&gt; <br>&gt; Find:    &quot;ArrayrLiteral&quot;<br>&gt; Replace: &quot;ArrayLiteral&quot;<br>&gt; <br>&gt; SUGGESTIONS:<br>&gt; <br>&gt; Should the `DictionaryLiteral` structure be renamed?<br>&gt; &lt;https://developer.apple.com/reference/swift/dictionaryliteral&gt;<br>&gt; It isn&#39;t a dictionary or a literal, it&#39;s an ordered collection.<br>&gt; <br>&gt; Can we also change `ExtendedGraphemeCluster` to `Character`?<br>&gt; This would affect the argument label, global type alias, etc.<br></p><p>Thanks for catching these mistakes!  Looks like my late night copy / pasting and proofreading skills could use some improvement. :)<br></p><p>I want to keep this proposal as tightly focused as possible so it has maximum chance of acceptance.  If you want to propose renaming the root of a couple of these protocols you should pursue an independent proposal for that.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; -- Ben<br>&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
