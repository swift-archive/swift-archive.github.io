<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>June 11, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; If your code has many manual type erasing wrappers corresponding to<br>&gt; protocols with associated types and/or Self requirements that also never<br>&gt; have to trap type mismatches, that would certainly be instructive<br>&gt; empirical data.  Would you care to share the protocols and wrappers you<br>&gt; are talking about?<br>This code is a bit embarrassing (I wrote most of it as I was still learning Swift), but if it is helpful I will share:<br>https://gist.github.com/jonhull/639e756ad5228348f93f40f06169588c<br></p><p>It doesn’t trap anywhere (that I know about). Some of the code which calls it does throw an error in the case of mismatched types (but it doesn’t/shouldn&#39;t crash).  Most functions which use it are generic on the associatedType.<br></p><p>It does work fairly well though (even on the AppleWatch).  The main issue is that I have no way to persist the values which have been drawn into the type-erased world (or even the value-type world, really).<br></p><p>Also, if anyone has a better way to write the type erasing wrapper, I would love to hear it. These are very memory intensive…<br></p><p>Thanks,<br>Jon<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160611/165973f9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>June 11, 2016 at 04:00:00am</p></header><div class="content"><p>Here is another example from a current project: (Here there is an option to trap, if desired… but many more options not to)<br>(Note: The commented out bit was an attempt to get the compiler to play nicer with intuiting the type, but it didn’t help… leaving as data)<br></p><p>struct HashableBox:Hashable {<br>    private let _value:Any<br>    private let _hash:Int<br>    private let _eq:(Any)-&gt;Bool<br>    <br>    enum Error:ErrorType {<br>        case typeMismatch<br>    }<br>    <br>    init&lt;T:Hashable&gt;(_ value:T){<br>        self._value = value<br>        self._hash = value.hashValue<br>        self._eq = { other in<br>            guard let otherT = other as? T else {return false}<br>            return value == otherT<br>        }<br>    }<br>    <br>    func valueOrCrash&lt;T:Hashable&gt;(msg:String? = nil) -&gt; T {<br>        guard let value = _value as? T else {<br>            let msg = msg ?? &quot;Attempt to retrieve value of type \(self._value.dynamicType) as \(T.self)&quot;<br>            fatalError(msg)<br>        }<br>        return value<br>    }<br>    <br>    func valueOrNil&lt;T:Hashable&gt;() -&gt; T? {//(type:T.Type = T.self) -&gt; T? {<br>        return self._value as? T<br>    }<br>    <br>    func valueOrError&lt;T:Hashable&gt;()throws -&gt; T {<br>        guard let value = _value as? T else {throw Error.typeMismatch}<br>        return value<br>    }<br>    <br>    var asAny:Any {<br>        return _value<br>    }<br>    <br>    var hashValue: Int {<br>        return _hash<br>    }<br>}<br></p><p>func == (lhs:HashableBox, rhs:HashableBox) -&gt; Bool {<br>    return lhs._eq(rhs)<br>}<br></p><p><br>Thanks,<br>Jon<br></p><p>&gt; On Jun 11, 2016, at 3:25 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; If your code has many manual type erasing wrappers corresponding to<br>&gt;&gt; protocols with associated types and/or Self requirements that also never<br>&gt;&gt; have to trap type mismatches, that would certainly be instructive<br>&gt;&gt; empirical data.  Would you care to share the protocols and wrappers you<br>&gt;&gt; are talking about?<br>&gt; This code is a bit embarrassing (I wrote most of it as I was still learning Swift), but if it is helpful I will share:<br>&gt; https://gist.github.com/jonhull/639e756ad5228348f93f40f06169588c &lt;https://gist.github.com/jonhull/639e756ad5228348f93f40f06169588c&gt;<br>&gt; <br>&gt; It doesn’t trap anywhere (that I know about). Some of the code which calls it does throw an error in the case of mismatched types (but it doesn’t/shouldn&#39;t crash).  Most functions which use it are generic on the associatedType.<br>&gt; <br>&gt; It does work fairly well though (even on the AppleWatch).  The main issue is that I have no way to persist the values which have been drawn into the type-erased world (or even the value-type world, really).<br>&gt; <br>&gt; Also, if anyone has a better way to write the type erasing wrapper, I would love to hear it. These are very memory intensive…<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160611/343b98c9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June 11, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; Am 11.06.2016 um 13:22 schrieb Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Here is another example from a current project: (Here there is an option to trap, if desired… but many more options not to)<br>&gt; (Note: The commented out bit was an attempt to get the compiler to play nicer with intuiting the type, but it didn’t help… leaving as data)<br>&gt; <br>&gt; struct HashableBox:Hashable {<br>&gt;     private let _value:Any<br>&gt;     private let _hash:Int<br>&gt;     private let _eq:(Any)-&gt;Bool<br>&gt;     <br>&gt;     enum Error:ErrorType {<br>&gt;         case typeMismatch<br>&gt;     }<br>&gt;     <br>&gt;     init&lt;T:Hashable&gt;(_ value:T){<br>&gt;         self._value = value<br>&gt;         self._hash = value.hashValue<br>&gt;         self._eq = { other in<br>&gt;             guard let otherT = other as? T else {return false}<br>&gt;             return value == otherT<br>&gt;         }<br>&gt;     }<br></p><p>I think there is an error in the implementation of _eq, because it should try to unpack the value as T and not the box.<br></p><p>HashableBox(1) == HashableBox(1) should be true IMO but is false with your implementation<br></p><p>This works as I would expect:<br></p><p>    private let _eq:(HashableBox)-&gt;Bool<br></p><p>    init&lt;T:Hashable&gt;(_ value:T){<br>        self._value = value<br>        self._hash = value.hashValue<br>        self._eq = { other in<br>            guard let otherValue: T = other.valueOrNil() else { return false }<br>            return value == otherValue<br>        }<br>    }<br></p><p>-Thorsten<br></p><p><br>&gt;     <br>&gt;     func valueOrCrash&lt;T:Hashable&gt;(msg:String? = nil) -&gt; T {<br>&gt;         guard let value = _value as? T else {<br>&gt;             let msg = msg ?? &quot;Attempt to retrieve value of type \(self._value.dynamicType) as \(T.self)&quot;<br>&gt;             fatalError(msg)<br>&gt;         }<br>&gt;         return value<br>&gt;     }<br>&gt;     <br>&gt;     func valueOrNil&lt;T:Hashable&gt;() -&gt; T? {//(type:T.Type = T.self) -&gt; T? {<br>&gt;         return self._value as? T<br>&gt;     }<br>&gt;     <br>&gt;     func valueOrError&lt;T:Hashable&gt;()throws -&gt; T {<br>&gt;         guard let value = _value as? T else {throw Error.typeMismatch}<br>&gt;         return value<br>&gt;     }<br>&gt;     <br>&gt;     var asAny:Any {<br>&gt;         return _value<br>&gt;     }<br>&gt;     <br>&gt;     var hashValue: Int {<br>&gt;         return _hash<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; func == (lhs:HashableBox, rhs:HashableBox) -&gt; Bool {<br>&gt;     return lhs._eq(rhs)<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt;&gt; On Jun 11, 2016, at 3:25 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; If your code has many manual type erasing wrappers corresponding to<br>&gt;&gt;&gt; protocols with associated types and/or Self requirements that also never<br>&gt;&gt;&gt; have to trap type mismatches, that would certainly be instructive<br>&gt;&gt;&gt; empirical data.  Would you care to share the protocols and wrappers you<br>&gt;&gt;&gt; are talking about?<br>&gt;&gt; This code is a bit embarrassing (I wrote most of it as I was still learning Swift), but if it is helpful I will share:<br>&gt;&gt; https://gist.github.com/jonhull/639e756ad5228348f93f40f06169588c &lt;https://gist.github.com/jonhull/639e756ad5228348f93f40f06169588c&gt;<br>&gt;&gt; <br>&gt;&gt; It doesn’t trap anywhere (that I know about). Some of the code which calls it does throw an error in the case of mismatched types (but it doesn’t/shouldn&#39;t crash).  Most functions which use it are generic on the associatedType.<br>&gt;&gt; <br>&gt;&gt; It does work fairly well though (even on the AppleWatch).  The main issue is that I have no way to persist the values which have been drawn into the type-erased world (or even the value-type world, really).<br>&gt;&gt; <br>&gt;&gt; Also, if anyone has a better way to write the type erasing wrapper, I would love to hear it. These are very memory intensive…<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160611/c43d4541/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>June 11, 2016 at 05:00:00am</p></header><div class="content"><p>Yikes!  I had intended to call rhs._value in ==.  Thank you :-)  You saved me a lot of debugging time.  I ended up fixing with your version.<br></p><p>You can see why I would love to have Swift do the thunk-ing for me… less opportunity to shoot myself in the foot with Any.<br></p><p>Thanks,<br>Jon<br></p><p>&gt; On Jun 11, 2016, at 5:25 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Am 11.06.2016 um 13:22 schrieb Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; Here is another example from a current project: (Here there is an option to trap, if desired… but many more options not to)<br>&gt;&gt; (Note: The commented out bit was an attempt to get the compiler to play nicer with intuiting the type, but it didn’t help… leaving as data)<br>&gt;&gt; <br>&gt;&gt; struct HashableBox:Hashable {<br>&gt;&gt;     private let _value:Any<br>&gt;&gt;     private let _hash:Int<br>&gt;&gt;     private let _eq:(Any)-&gt;Bool<br>&gt;&gt;     <br>&gt;&gt;     enum Error:ErrorType {<br>&gt;&gt;         case typeMismatch<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     init&lt;T:Hashable&gt;(_ value:T){<br>&gt;&gt;         self._value = value<br>&gt;&gt;         self._hash = value.hashValue<br>&gt;&gt;         self._eq = { other in<br>&gt;&gt;             guard let otherT = other as? T else {return false}<br>&gt;&gt;             return value == otherT<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt; <br>&gt; I think there is an error in the implementation of _eq, because it should try to unpack the value as T and not the box.<br>&gt; <br>&gt; HashableBox(1) == HashableBox(1) should be true IMO but is false with your implementation<br>&gt; <br>&gt; This works as I would expect:<br>&gt; <br>&gt;     private let _eq:(HashableBox)-&gt;Bool<br>&gt; <br>&gt;     init&lt;T:Hashable&gt;(_ value:T){<br>&gt;         self._value = value<br>&gt;         self._hash = value.hashValue<br>&gt;         self._eq = { other in<br>&gt;             guard let otherValue: T = other.valueOrNil() else { return false }<br>&gt;             return value == otherValue<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt;     <br>&gt;&gt;     func valueOrCrash&lt;T:Hashable&gt;(msg:String? = nil) -&gt; T {<br>&gt;&gt;         guard let value = _value as? T else {<br>&gt;&gt;             let msg = msg ?? &quot;Attempt to retrieve value of type \(self._value.dynamicType) as \(T.self)&quot;<br>&gt;&gt;             fatalError(msg)<br>&gt;&gt;         }<br>&gt;&gt;         return value<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     func valueOrNil&lt;T:Hashable&gt;() -&gt; T? {//(type:T.Type = T.self) -&gt; T? {<br>&gt;&gt;         return self._value as? T<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     func valueOrError&lt;T:Hashable&gt;()throws -&gt; T {<br>&gt;&gt;         guard let value = _value as? T else {throw Error.typeMismatch}<br>&gt;&gt;         return value<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     var asAny:Any {<br>&gt;&gt;         return _value<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     var hashValue: Int {<br>&gt;&gt;         return _hash<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func == (lhs:HashableBox, rhs:HashableBox) -&gt; Bool {<br>&gt;&gt;     return lhs._eq(rhs)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 11, 2016, at 3:25 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If your code has many manual type erasing wrappers corresponding to<br>&gt;&gt;&gt;&gt; protocols with associated types and/or Self requirements that also never<br>&gt;&gt;&gt;&gt; have to trap type mismatches, that would certainly be instructive<br>&gt;&gt;&gt;&gt; empirical data.  Would you care to share the protocols and wrappers you<br>&gt;&gt;&gt;&gt; are talking about?<br>&gt;&gt;&gt; This code is a bit embarrassing (I wrote most of it as I was still learning Swift), but if it is helpful I will share:<br>&gt;&gt;&gt; https://gist.github.com/jonhull/639e756ad5228348f93f40f06169588c &lt;https://gist.github.com/jonhull/639e756ad5228348f93f40f06169588c&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It doesn’t trap anywhere (that I know about). Some of the code which calls it does throw an error in the case of mismatched types (but it doesn’t/shouldn&#39;t crash).  Most functions which use it are generic on the associatedType.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It does work fairly well though (even on the AppleWatch).  The main issue is that I have no way to persist the values which have been drawn into the type-erased world (or even the value-type world, really).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, if anyone has a better way to write the type erasing wrapper, I would love to hear it. These are very memory intensive…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160611/16c37a1b/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 12, 2016 at 08:00:00pm</p></header><div class="content"><p>on Sat Jun 11 2016, Jonathan Hull &lt;jhull-AT-gbis.com&gt; wrote:<br></p><p>&gt;&gt; If your code has many manual type erasing wrappers corresponding to<br>&gt;&gt; protocols with associated types and/or Self requirements that also never<br>&gt;&gt; have to trap type mismatches, that would certainly be instructive<br>&gt;&gt; empirical data.  Would you care to share the protocols and wrappers you<br>&gt;&gt; are talking about?<br>&gt; This code is a bit embarrassing (I wrote most of it as I was still<br>&gt; learning Swift), but if it is helpful I will share:<br>&gt; https://gist.github.com/jonhull/639e756ad5228348f93f40f06169588c<br>&gt;<br>&gt; It doesn’t trap anywhere (that I know about). Some of the code which<br>&gt; calls it does throw an error in the case of mismatched types (but it<br>&gt; doesn’t/shouldn&#39;t crash).  <br></p><p>If that error is being thrown to handle what you consider to be a<br>programming error, that is the moral equivalent of a trap.<br></p><p>&gt; Most functions which use it are generic on the associatedType.<br>&gt;<br>&gt; It does work fairly well though (even on the AppleWatch).  The main<br>&gt; issue is that I have no way to persist the values which have been<br>&gt; drawn into the type-erased world (or even the value-type world,<br>&gt; really).<br>&gt;<br>&gt; Also, if anyone has a better way to write the type erasing wrapper, I<br>&gt; would love to hear it. These are very memory intensive…<br></p><p>It looks like you could make some gains by, instead of storing a closure<br>for each operation, using a base class with a method for each operation,<br>per the box types in<br>https://github.com/apple/swift/blob/master/stdlib/public/core/ExistentialCollection.swift.gyb<br></p><p>HTH,<br>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>June 22, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jun 12, 2016, at 8:31 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sat Jun 11 2016, Jonathan Hull &lt;jhull-AT-gbis.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; If your code has many manual type erasing wrappers corresponding to<br>&gt;&gt;&gt; protocols with associated types and/or Self requirements that also never<br>&gt;&gt;&gt; have to trap type mismatches, that would certainly be instructive<br>&gt;&gt;&gt; empirical data.  Would you care to share the protocols and wrappers you<br>&gt;&gt;&gt; are talking about?<br>&gt;&gt; This code is a bit embarrassing (I wrote most of it as I was still<br>&gt;&gt; learning Swift), but if it is helpful I will share:<br>&gt;&gt; https://gist.github.com/jonhull/639e756ad5228348f93f40f06169588c<br>&gt;&gt; <br>&gt;&gt; It doesn’t trap anywhere (that I know about). Some of the code which<br>&gt;&gt; calls it does throw an error in the case of mismatched types (but it<br>&gt;&gt; doesn’t/shouldn&#39;t crash).  <br>&gt; <br>&gt; If that error is being thrown to handle what you consider to be a<br>&gt; programming error, that is the moral equivalent of a trap.<br></p><p>Agreed.  In this case the error is thrown when two different user inputs don’t match types, and it results in a user facing error.  It basically functions as input validation.<br></p><p>It seems to me that Swift has four ways of handling failure:<br>1) Disallow it entirely<br>2) Trap (marked with !)<br>3) Throw (marked with try)<br>4) Return nil (marked with ?)<br></p><p>It seems to me that the Swift-y™ way to handle this is to disallow it until the programmer chooses the most appropriate of the other three options.<br></p><p>It may be that trapping is the right thing to do the majority of the time, but I definitely have use-cases where returning nil is the correct option.   <br></p><p><br>&gt;&gt; Most functions which use it are generic on the associatedType.<br>&gt;&gt; <br>&gt;&gt; It does work fairly well though (even on the AppleWatch).  The main<br>&gt;&gt; issue is that I have no way to persist the values which have been<br>&gt;&gt; drawn into the type-erased world (or even the value-type world,<br>&gt;&gt; really).<br>&gt;&gt; <br>&gt;&gt; Also, if anyone has a better way to write the type erasing wrapper, I<br>&gt;&gt; would love to hear it. These are very memory intensive…<br>&gt; <br>&gt; It looks like you could make some gains by, instead of storing a closure<br>&gt; for each operation, using a base class with a method for each operation,<br>&gt; per the box types in<br>&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/ExistentialCollection.swift.gyb<br></p><p>Thank you, much appreciated.<br></p><p><br>&gt; <br>&gt; HTH,<br>&gt; -- <br>&gt; Dave<br>&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
