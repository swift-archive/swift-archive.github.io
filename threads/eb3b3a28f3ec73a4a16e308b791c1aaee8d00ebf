<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Making protocol conformance inheritance controllable</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 10, 2015 at 06:00:00pm</p></header><div class="content"><p>I&#39;ve had a number of twitter conversations with users who have valiantly fought our type system and lost when trying to make their protocols interact well with non-final classes. A few from recent memory:<br></p><p>- Rob Napier struggling to implement a `copy` method that works well with subclasses: https://twitter.com/cocoaphony/status/660914612850843648<br>and making the observation that the interaction of protocol conformance and subtyping is very difficult to teach.<br></p><p>- Matt Bischoff trying to make Cocoa class clusters retroactively conform to his factory protocol:<br>https://twitter.com/anandabits/status/664294382774849536<br></p><p>and Karl Adam trying to do the same:<br>https://gist.github.com/thekarladam/c3094769cc8c87bf55e3<br></p><p>These problems stem from the way protocol conformances currently interact with class inheritance—specifically, that if a class conforms to a protocol, then all of its possible derived classes also conform. This seems like the obvious way things should be, but in practice it ends up fighting how many classes are intended to be used. Often only a base class is intended to be the public interface, and derived classes are only implementation details—Cocoa class clusters are a great example of this. The inheritance of protocol conformances also imposes a bunch of knock-on complexity on conforming classes—initializer requirements must be satisfied by `required` initializers (which then must be overridden in all derived classes, to the pain of anyone touching an NSCoding-inherited class), and methods often must return dynamic `Self` when they&#39;d really prefer to return the base class.<br></p><p>To mitigate these issues, I&#39;d like to float the idea that protocol conformances *not be* inherited by default. If you declare a class as conforming to a protocol, only exactly that class can be bound to a type parameter constrained by that protocol:<br></p><p>protocol Runcible {}<br>class A: Runcible { }<br>class B { }<br></p><p>func foo&lt;T: Runcible&gt;(x: T) {}<br></p><p>foo(B()) // calls foo with T == A<br></p><p>Since subclasses are still subtypes of the base class, in many cases client code won&#39;t have to change at all, since derived instances can implicitly upconvert to their conforming base class when used in protocol types or generics that only the base class conforms to. (There are cases like if the type parameter appears in a NonCovariant&lt;T&gt; type where this isn&#39;t possible, though.) Protocol requirements for a non-inherited conformance don&#39;t need to be `required` initializers, or maintain covariant returns:<br></p><p>protocol Fungible {<br>  init()<br>  static func funged() -&gt; Self<br>}<br></p><p>class C: Fungible {<br>  init() {} // Non-required init is fine, since subclasses aren&#39;t directly Fungible<br></p><p>  // Non-Self return is fine too<br>  class func funged() -&gt; C { return C() }<br>}<br></p><p>An individual subclass that wanted to refine the conformance could do so by `override`-ing it, and providing any necessary covariant overrides of initializers and methods:<br></p><p>class D: C, override Fungible {<br>  // D must provide its own init()<br>  init() { super.init() }<br></p><p>  // D must override funged() to return D instead of C<br>  override class func funged() -&gt; D { return D() }<br>}<br></p><p>And if a class hierarchy really wants to impose a conformance on all possible subclasses, as happens today, we could let you opt in to that:<br></p><p>class E: required Fungible {<br>  // init() must be required of all subclasses<br>  required init() { }<br></p><p>  // funged() must return a covariant object<br>  class func funged() -&gt; Self { return Self() }<br>}<br></p><p>This is undoubtedly a complication of the language, but I think it might let us more accurately model a lot of things people seem to want to do in practice with class hierarchies and protocols, and it simplifies the behavior of the arguably common case where inheritance of the conformance isn&#39;t desired. What do you all think?<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/eb3b0ebf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Making protocol conformance inheritance controllable</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 10, 2015 at 09:00:00pm</p></header><div class="content"><p>I have run into this issue myself.  It is definitely a problem and we need a solution for it.  It is exacerbated by the fact that many Cocoa types which would naturally be value types or final classes in Swift are not designed this way due to their Objective-C heritage.  If Cocoa was designed in Swift and with an emphasis on composition rather than inheritance many cases of the problem would vanish and I’m not sure whether we would have a problem or not, but unfortunately we do.<br></p><p>My initial reaction to this solution is that it is probably a good approach.  One change I would consider is making it mirror method overriding a bit more closely.  Specifically, we might want to also make it possible to specify “final” protocol conformance as well as add the ability to “require&quot; method overrides.  Aligning the capabilities would leave one less nuance for everyone to remember and reduce the complexity added by the proposal.<br></p><p>One alternative that might be worth exploring is whether we can introduce a concept supporting class clusters more directly as well as a FINAL annotation for Objective-C classes which really shouldn’t be inherited or where subclassing is of dubious value (inheriting to work around a bug is dubious IMO despite the practical value some see in it).  A combination of these two approaches might solve the problem for all or most of the classes we really care about.  I’m not suggesting this is a better approach, just sharing it for consideration.<br></p><p>Matthew<br></p><p><br>&gt; On Dec 10, 2015, at 8:04 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve had a number of twitter conversations with users who have valiantly fought our type system and lost when trying to make their protocols interact well with non-final classes. A few from recent memory:<br>&gt; <br>&gt; - Rob Napier struggling to implement a `copy` method that works well with subclasses: https://twitter.com/cocoaphony/status/660914612850843648 &lt;https://twitter.com/cocoaphony/status/660914612850843648&gt;<br>&gt; and making the observation that the interaction of protocol conformance and subtyping is very difficult to teach.<br>&gt; <br>&gt; - Matt Bischoff trying to make Cocoa class clusters retroactively conform to his factory protocol:<br>&gt; https://twitter.com/anandabits/status/664294382774849536 &lt;https://twitter.com/anandabits/status/664294382774849536&gt;<br>&gt; <br>&gt; and Karl Adam trying to do the same:<br>&gt; https://gist.github.com/thekarladam/c3094769cc8c87bf55e3 &lt;https://gist.github.com/thekarladam/c3094769cc8c87bf55e3&gt;<br>&gt; <br>&gt; These problems stem from the way protocol conformances currently interact with class inheritance—specifically, that if a class conforms to a protocol, then all of its possible derived classes also conform. This seems like the obvious way things should be, but in practice it ends up fighting how many classes are intended to be used. Often only a base class is intended to be the public interface, and derived classes are only implementation details—Cocoa class clusters are a great example of this. The inheritance of protocol conformances also imposes a bunch of knock-on complexity on conforming classes—initializer requirements must be satisfied by `required` initializers (which then must be overridden in all derived classes, to the pain of anyone touching an NSCoding-inherited class), and methods often must return dynamic `Self` when they&#39;d really prefer to return the base class.<br>&gt; <br>&gt; To mitigate these issues, I&#39;d like to float the idea that protocol conformances *not be* inherited by default. If you declare a class as conforming to a protocol, only exactly that class can be bound to a type parameter constrained by that protocol:<br>&gt; <br>&gt; protocol Runcible {}<br>&gt; class A: Runcible { }<br>&gt; class B { }<br>&gt; <br>&gt; func foo&lt;T: Runcible&gt;(x: T) {}<br>&gt; <br>&gt; foo(B()) // calls foo with T == A<br>&gt; <br>&gt; Since subclasses are still subtypes of the base class, in many cases client code won&#39;t have to change at all, since derived instances can implicitly upconvert to their conforming base class when used in protocol types or generics that only the base class conforms to. (There are cases like if the type parameter appears in a NonCovariant&lt;T&gt; type where this isn&#39;t possible, though.) Protocol requirements for a non-inherited conformance don&#39;t need to be `required` initializers, or maintain covariant returns:<br>&gt; <br>&gt; protocol Fungible {<br>&gt;   init()<br>&gt;   static func funged() -&gt; Self<br>&gt; }<br>&gt; <br>&gt; class C: Fungible {<br>&gt;   init() {} // Non-required init is fine, since subclasses aren&#39;t directly Fungible<br>&gt; <br>&gt;   // Non-Self return is fine too<br>&gt;   class func funged() -&gt; C { return C() }<br>&gt; }<br>&gt; <br>&gt; An individual subclass that wanted to refine the conformance could do so by `override`-ing it, and providing any necessary covariant overrides of initializers and methods:<br>&gt; <br>&gt; class D: C, override Fungible {<br>&gt;   // D must provide its own init()<br>&gt;   init() { super.init() }<br>&gt; <br>&gt;   // D must override funged() to return D instead of C<br>&gt;   override class func funged() -&gt; D { return D() }<br>&gt; }<br>&gt; <br>&gt; And if a class hierarchy really wants to impose a conformance on all possible subclasses, as happens today, we could let you opt in to that:<br>&gt; <br>&gt; class E: required Fungible {<br>&gt;   // init() must be required of all subclasses<br>&gt;   required init() { }<br>&gt; <br>&gt;   // funged() must return a covariant object<br>&gt;   class func funged() -&gt; Self { return Self() }<br>&gt; }<br>&gt; <br>&gt; This is undoubtedly a complication of the language, but I think it might let us more accurately model a lot of things people seem to want to do in practice with class hierarchies and protocols, and it simplifies the behavior of the arguably common case where inheritance of the conformance isn&#39;t desired. What do you all think?<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/ff7d320a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Making protocol conformance inheritance controllable</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>December 11, 2015 at 11:00:00am</p></header><div class="content"><p>Been bitten also.<br></p><p>&gt; Le 11 déc. 2015 à 04:03, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I have run into this issue myself.  It is definitely a problem and we need a solution for it.  It is exacerbated by the fact that many Cocoa types which would naturally be value types or final classes in Swift are not designed this way due to their Objective-C heritage.<br></p><p>Foundation also exposes many non-final classes such as the immutable/mutable couples NSArray/NSMutableArray etc.<br></p><p>&gt; Le 11 déc. 2015 à 03:04, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br></p><p>&gt; initializer requirements must be satisfied by `required` initializers (which then must be overridden in all derived classes, to the pain of anyone touching an NSCoding-inherited class), and methods often must return dynamic `Self` when they&#39;d really prefer to return the base class.<br></p><p>This is especially painful when you want to extend existing non-final classes, such as Foundation classes.<br></p><p>***Fortunately***, those often provide the needed constructors (including copy constructors), which alleviates the fact that one can not add a required initializer to an extension to a non-final class.<br></p><p>    protocol P {<br>        static func f() -&gt; Self?<br>    }<br></p><p>    extension NSString : P {<br>        class func f() -&gt; Self? {<br>            return self.init(string: &quot;foo&quot;)<br>        }<br>    }<br>    <br>    NSString.f()<br>    NSMutableString.f()<br></p><p>But the presence of those constructors in Foundation looks like a matter of luck.<br></p><p>Gwendal Roué<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Making protocol conformance inheritance controllable</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 11, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; It is exacerbated by the fact that many Cocoa types which would naturally be value types or final classes in Swift are not designed this way due to their Objective-C heritage.<br>&gt;&gt; <br>&gt;&gt; Foundation also exposes many non-final classes such as the immutable/mutable couples NSArray/NSMutableArray etc.<br></p><p>These are naturally value types in Swift and when designed that way don&#39;t exhibit the problem mentioned in this thread.<br></p><p>Also FWIW, it&#39;s not really safe to consider NSArray &quot;immutable&quot; because it is a reference type with a mutable subtype.  Specific instances of NSArray can be considered immutable when you know they are not actually instances of NSMutableArray and the interface to NSArray obviously does not allow mutation, but the assumption that NSArray is immutable has been the source of many bugs for many developers.  There is a reason it is not named NSImmutableArray.  The design of Cocoa could have been a lot more clear about this if it also had an NSImmutableArray class that also inherited from NSArray.<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Making protocol conformance inheritance controllable</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December 10, 2015 at 11:00:00pm</p></header><div class="content"><p>Le 10 déc. 2015 à 21:04, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br></p><p>&gt; And if a class hierarchy really wants to impose a conformance on all possible subclasses, as happens today, we could let you opt in to that:<br>&gt; <br>&gt; class E: required Fungible {<br>&gt;   // init() must be required of all subclasses<br>&gt;   required init() { }<br>&gt; <br>&gt;   // funged() must return a covariant object<br>&gt;   class func funged() -&gt; Self { return Self() }<br>&gt; }<br></p><p>I think the concept makes sense. But you&#39;re changing the default behaviour here. Is this because you expect protocols should not be inherited most of the time? That most protocols in Cocoa shouldn&#39;t be inherited? That goes against &quot;obvious way things should be&quot;.<br></p><p>Also, shouldn&#39;t this be allowed too?<br></p><p>	class F: C, required override Fungible {<br>		required init() { }<br>		class func funged() -&gt; Self { return Self() }<br>	}<br></p><p>Personally, I&#39;d tend to make &#39;required&#39; the default mode, and use &quot;static Fungible&quot; for the odd one that does not apply to subtypes. And I&#39;d get rid of override before the protocol name, just use &quot;static Fungible&quot; again in the subclass:<br></p><p>	class C: static Fungible {<br>		init() {}<br>		class func funged() -&gt; C { return C() }<br>	}<br>	class D: C, static Fungible {<br>		init() {}<br>		override class func funged() -&gt; D { return D() }<br>	}<br>	class E: Fungible {<br>		required init() {}<br>		class func funged() -&gt; Self { return Self() }<br>	}<br>	class F: C, Fungible {<br>		required init() {}<br>		override class func funged() -&gt; Self { return Self() }<br>	}<br></p><p>But in the end the syntax depends on what default behaviour is desired.<br></p><p>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Making protocol conformance inheritance controllable</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 11, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 8:04 PM, Michel Fortin &lt;michel.fortin at michelf.ca&gt; wrote:<br>&gt; <br>&gt; Le 10 déc. 2015 à 21:04, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; And if a class hierarchy really wants to impose a conformance on all possible subclasses, as happens today, we could let you opt in to that:<br>&gt;&gt; <br>&gt;&gt; class E: required Fungible {<br>&gt;&gt;  // init() must be required of all subclasses<br>&gt;&gt;  required init() { }<br>&gt;&gt; <br>&gt;&gt;  // funged() must return a covariant object<br>&gt;&gt;  class func funged() -&gt; Self { return Self() }<br>&gt;&gt; }<br>&gt; <br>&gt; I think the concept makes sense. But you&#39;re changing the default behaviour here. Is this because you expect protocols should not be inherited most of the time? That most protocols in Cocoa shouldn&#39;t be inherited? That goes against &quot;obvious way things should be&quot;.<br></p><p>It&#39;s a good question which behavior ought to be default. The good news is that the distinction is only observable for protocols with covariant requirements—initializers, methods returning Self, or properties of type Self. A more conservative change might be:<br></p><p>- preserve the current inheritance behavior for protocols without covariant requirements;<br>- when a class conforms to a protocol with covariant requirements, it must specify whether the conformance is `static` or  `required`, so that neither behavior is default.<br></p><p>&gt; Also, shouldn&#39;t this be allowed too?<br>&gt; <br>&gt; 	class F: C, required override Fungible {<br>&gt; 		required init() { }<br>&gt; 		class func funged() -&gt; Self { return Self() }<br>&gt; 	}<br></p><p>&#39;required override&#39; would be unnecessary in any case. The base class requiring the conformance implies that every derived class inherits it already, and derived classes can already influence the conformance by normal method overriding.<br></p><p>-Joe<br></p><p>&gt; Personally, I&#39;d tend to make &#39;required&#39; the default mode, and use &quot;static Fungible&quot; for the odd one that does not apply to subtypes. And I&#39;d get rid of override before the protocol name, just use &quot;static Fungible&quot; again in the subclass:<br>&gt; <br>&gt; 	class C: static Fungible {<br>&gt; 		init() {}<br>&gt; 		class func funged() -&gt; C { return C() }<br>&gt; 	}<br>&gt; 	class D: C, static Fungible {<br>&gt; 		init() {}<br>&gt; 		override class func funged() -&gt; D { return D() }<br>&gt; 	}<br>&gt; 	class E: Fungible {<br>&gt; 		required init() {}<br>&gt; 		class func funged() -&gt; Self { return Self() }<br>&gt; 	}<br>&gt; 	class F: C, Fungible {<br>&gt; 		required init() {}<br>&gt; 		override class func funged() -&gt; Self { return Self() }<br>&gt; 	}<br>&gt; <br>&gt; But in the end the syntax depends on what default behaviour is desired.<br>&gt; <br>&gt; -- <br>&gt; Michel Fortin<br>&gt; michel.fortin at michelf.ca<br>&gt; https://michelf.ca<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Making protocol conformance inheritance controllable</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December 11, 2015 at 04:00:00pm</p></header><div class="content"><p>Le 11 déc. 2015 à 15:21, Joe Groff &lt;jgroff at apple.com&gt; a écrit :<br></p><p>&gt; It&#39;s a good question which behavior ought to be default. The good news is that the distinction is only observable for protocols with covariant requirements—initializers, methods returning Self, or properties of type Self. A more conservative change might be:<br>&gt; <br>&gt; - preserve the current inheritance behavior for protocols without covariant requirements;<br>&gt; - when a class conforms to a protocol with covariant requirements, it must specify whether the conformance is `static` or  `required`, so that neither behavior is default.<br></p><p>Does it make sense to say the protocol is `required` when it contains no initializers? For instance:<br></p><p>	protocol Something {<br>		static func give() -&gt; Self?<br>	}<br>	class A: required Something {<br>		class func give() -&gt; Self? { return nil }<br>	}<br>	<br>If I then derive B from A, am I required to override func give()?<br></p><p>	class B: A {<br>		// missing func &#39;give&#39; or not?<br>	}<br></p><p>It would certainly make sense to want the protocol to be `static` in this case, to allow B.give to return a value of type A. But `required` doesn&#39;t seem to have any relevant meaning.<br></p><p><br>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Making protocol conformance inheritance controllable</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 10, 2015 at 09:00:00pm</p></header><div class="content"><p>On Dec 10, 2015, at 6:04 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; To mitigate these issues, I&#39;d like to float the idea that protocol conformances *not be* inherited by default. If you declare a class as conforming to a protocol, only exactly that class can be bound to a type parameter constrained by that protocol:<br>&gt; <br>&gt; protocol Runcible {}<br>&gt; class A: Runcible { }<br>&gt; class B : A { }<br>&gt; <br>&gt; func foo&lt;T: Runcible&gt;(x: T) {}<br>&gt; <br>&gt; foo(B()) // calls foo with T == A<br>&gt; <br>&gt; Since subclasses are still subtypes of the base class, in many cases client code won&#39;t have to change at all, since derived instances can implicitly upconvert to their conforming base class when used in protocol types or generics that only the base class conforms to.<br></p><p>Very interesting approach, I think I like it.  That said, this is subtle enough that we’d probably have to prototype it to see what falls out in practice on existing real world code.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/450baf31/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Making protocol conformance inheritance controllable</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>December 11, 2015 at 10:00:00am</p></header><div class="content"><p>I think that this is a good idea overall. I agree that `required override`<br>might necessary as well.<br></p><p>---<br>TJ<br></p><p>On Fri, Dec 11, 2015 at 7:34 AM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;ve had a number of twitter conversations with users who have valiantly<br>&gt; fought our type system and lost when trying to make their protocols<br>&gt; interact well with non-final classes. A few from recent memory:<br>&gt;<br>&gt; - Rob Napier struggling to implement a `copy` method that works well with<br>&gt; subclasses: https://twitter.com/cocoaphony/status/660914612850843648<br>&gt; and making the observation that the interaction of protocol conformance<br>&gt; and subtyping is very difficult to teach.<br>&gt;<br>&gt; - Matt Bischoff trying to make Cocoa class clusters retroactively conform<br>&gt; to his factory protocol:<br>&gt; https://twitter.com/anandabits/status/664294382774849536<br>&gt;<br>&gt; and Karl Adam trying to do the same:<br>&gt; https://gist.github.com/thekarladam/c3094769cc8c87bf55e3<br>&gt;<br>&gt; These problems stem from the way protocol conformances currently interact<br>&gt; with class inheritance—specifically, that if a class conforms to a<br>&gt; protocol, then all of its possible derived classes also conform. This seems<br>&gt; like the obvious way things should be, but in practice it ends up fighting<br>&gt; how many classes are intended to be used. Often only a base class is<br>&gt; intended to be the public interface, and derived classes are only<br>&gt; implementation details—Cocoa class clusters are a great example of this.<br>&gt; The inheritance of protocol conformances also imposes a bunch of knock-on<br>&gt; complexity on conforming classes—initializer requirements must be satisfied<br>&gt; by `required` initializers (which then must be overridden in all derived<br>&gt; classes, to the pain of anyone touching an NSCoding-inherited class), and<br>&gt; methods often must return dynamic `Self` when they&#39;d really prefer to<br>&gt; return the base class.<br>&gt;<br>&gt; To mitigate these issues, I&#39;d like to float the idea that protocol<br>&gt; conformances *not be* inherited by default. If you declare a class as<br>&gt; conforming to a protocol, only exactly that class can be bound to a type<br>&gt; parameter constrained by that protocol:<br>&gt;<br>&gt; protocol Runcible {}<br>&gt;<br>&gt; class A: Runcible { }<br>&gt; class B { }<br>&gt;<br>&gt; func foo&lt;T: Runcible&gt;(x: T) {}<br>&gt;<br>&gt; foo(B()) // calls foo with T == A<br>&gt;<br>&gt; Since subclasses are still subtypes of the base class, in many cases<br>&gt; client code won&#39;t have to change at all, since derived instances can<br>&gt; implicitly upconvert to their conforming base class when used in protocol<br>&gt; types or generics that only the base class conforms to. (There are cases<br>&gt; like if the type parameter appears in a NonCovariant&lt;T&gt; type where this<br>&gt; isn&#39;t possible, though.) Protocol requirements for a non-inherited<br>&gt; conformance don&#39;t need to be `required` initializers, or maintain covariant<br>&gt; returns:<br>&gt;<br>&gt; protocol Fungible {<br>&gt;   init()<br>&gt;   static func funged() -&gt; Self<br>&gt; }<br>&gt;<br>&gt; class C: Fungible {<br>&gt;   init() {} // Non-required init is fine, since subclasses aren&#39;t directly<br>&gt; Fungible<br>&gt;<br>&gt;   // Non-Self return is fine too<br>&gt;   class func funged() -&gt; C { return C() }<br>&gt; }<br>&gt;<br>&gt; An individual subclass that wanted to refine the conformance could do so<br>&gt; by `override`-ing it, and providing any necessary covariant overrides of<br>&gt; initializers and methods:<br>&gt;<br>&gt; class D: C, override Fungible {<br>&gt;   // D must provide its own init()<br>&gt;   init() { super.init() }<br>&gt;<br>&gt;   // D must override funged() to return D instead of C<br>&gt;   override class func funged() -&gt; D { return D() }<br>&gt; }<br>&gt;<br>&gt; And if a class hierarchy really wants to impose a conformance on all<br>&gt; possible subclasses, as happens today, we could let you opt in to that:<br>&gt;<br>&gt; class E: required Fungible {<br>&gt;   // init() must be required of all subclasses<br>&gt;   required init() { }<br>&gt;<br>&gt;   // funged() must return a covariant object<br>&gt;   class func funged() -&gt; Self { return Self() }<br>&gt; }<br>&gt;<br>&gt; This is undoubtedly a complication of the language, but I think it might<br>&gt; let us more accurately model a lot of things people seem to want to do in<br>&gt; practice with class hierarchies and protocols, and it simplifies the<br>&gt; behavior of the arguably common case where inheritance of the conformance<br>&gt; isn&#39;t desired. What do you all think?<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/42c4dfa0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8a24682926961206ad452d8455b09457?s=50"></div><header><strong>Making protocol conformance inheritance controllable</strong> from <string>thorsten at portableinnovations.de</string> &lt;thorsten at portableinnovations.de&gt;<p>December 11, 2015 at 08:00:00am</p></header><div class="content"><p>Very interesting! Looks very promising, but I will have to think it through more closely and throw some protoypes at it to get a better grasp on the idea.<br></p><p>-Thorsten<br></p><p>&gt; Am 11.12.2015 um 03:04 schrieb Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I&#39;ve had a number of twitter conversations with users who have valiantly fought our type system and lost when trying to make their protocols interact well with non-final classes. A few from recent memory:<br>&gt; <br>&gt; - Rob Napier struggling to implement a `copy` method that works well with subclasses: https://twitter.com/cocoaphony/status/660914612850843648<br>&gt; and making the observation that the interaction of protocol conformance and subtyping is very difficult to teach.<br>&gt; <br>&gt; - Matt Bischoff trying to make Cocoa class clusters retroactively conform to his factory protocol:<br>&gt; https://twitter.com/anandabits/status/664294382774849536<br>&gt; <br>&gt; and Karl Adam trying to do the same:<br>&gt; https://gist.github.com/thekarladam/c3094769cc8c87bf55e3<br>&gt; <br>&gt; These problems stem from the way protocol conformances currently interact with class inheritance—specifically, that if a class conforms to a protocol, then all of its possible derived classes also conform. This seems like the obvious way things should be, but in practice it ends up fighting how many classes are intended to be used. Often only a base class is intended to be the public interface, and derived classes are only implementation details—Cocoa class clusters are a great example of this. The inheritance of protocol conformances also imposes a bunch of knock-on complexity on conforming classes—initializer requirements must be satisfied by `required` initializers (which then must be overridden in all derived classes, to the pain of anyone touching an NSCoding-inherited class), and methods often must return dynamic `Self` when they&#39;d really prefer to return the base class.<br>&gt; <br>&gt; To mitigate these issues, I&#39;d like to float the idea that protocol conformances *not be* inherited by default. If you declare a class as conforming to a protocol, only exactly that class can be bound to a type parameter constrained by that protocol:<br>&gt; <br>&gt; protocol Runcible {}<br>&gt; class A: Runcible { }<br>&gt; class B { }<br>&gt; <br>&gt; func foo&lt;T: Runcible&gt;(x: T) {}<br>&gt; <br>&gt; foo(B()) // calls foo with T == A<br>&gt; <br>&gt; Since subclasses are still subtypes of the base class, in many cases client code won&#39;t have to change at all, since derived instances can implicitly upconvert to their conforming base class when used in protocol types or generics that only the base class conforms to. (There are cases like if the type parameter appears in a NonCovariant&lt;T&gt; type where this isn&#39;t possible, though.) Protocol requirements for a non-inherited conformance don&#39;t need to be `required` initializers, or maintain covariant returns:<br>&gt; <br>&gt; protocol Fungible {<br>&gt;   init()<br>&gt;   static func funged() -&gt; Self<br>&gt; }<br>&gt; <br>&gt; class C: Fungible {<br>&gt;   init() {} // Non-required init is fine, since subclasses aren&#39;t directly Fungible<br>&gt; <br>&gt;   // Non-Self return is fine too<br>&gt;   class func funged() -&gt; C { return C() }<br>&gt; }<br>&gt; <br>&gt; An individual subclass that wanted to refine the conformance could do so by `override`-ing it, and providing any necessary covariant overrides of initializers and methods:<br>&gt; <br>&gt; class D: C, override Fungible {<br>&gt;   // D must provide its own init()<br>&gt;   init() { super.init() }<br>&gt; <br>&gt;   // D must override funged() to return D instead of C<br>&gt;   override class func funged() -&gt; D { return D() }<br>&gt; }<br>&gt; <br>&gt; And if a class hierarchy really wants to impose a conformance on all possible subclasses, as happens today, we could let you opt in to that:<br>&gt; <br>&gt; class E: required Fungible {<br>&gt;   // init() must be required of all subclasses<br>&gt;   required init() { }<br>&gt; <br>&gt;   // funged() must return a covariant object<br>&gt;   class func funged() -&gt; Self { return Self() }<br>&gt; }<br>&gt; <br>&gt; This is undoubtedly a complication of the language, but I think it might let us more accurately model a lot of things people seem to want to do in practice with class hierarchies and protocols, and it simplifies the behavior of the arguably common case where inheritance of the conformance isn&#39;t desired. What do you all think?<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/30b359fa/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Making protocol conformance inheritance controllable</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>December 11, 2015 at 09:00:00am</p></header><div class="content"><p>The problem addressed is real but I have a few reservations about the proposal as-sketched.<br></p><p>My first reservation is that, as-described, this would seem very likely to have some very bizarre and unintuitive cross-interactions if implemented alongside any construct along these lines:<br></p><p>// extension conforming `Foo` to `Bar` whenever $Condition is met<br>extension Foo: Bar where $Condition [<br></p><p>}<br></p><p>…due to ambiguities wherein, say, a base class explicitly conforms to some protocols, and consequently obtains an additional conformance via some conditional extension; a subclass explicitly re-conforms to the same protocols the base explicitly conforms-to…should it pick up that same “additional” conformance or not?<br></p><p>My second reservation is that, as I understand the proposal, it seems you could easily create protocol constraints for which no useful type would “naturally” work; e.g. as I understand it, if I happened to have this:<br></p><p>class Whatever&lt;<br>  K:SomeBaseClass<br>  where<br>  K:ProtocolA,<br>  K:ProtocolB,<br>  K:ProtocolC&gt; <br></p><p>…then to be able to actually write this:<br></p><p>let whatever = Whatever&lt;SomeClass&gt;()<br></p><p>…we would need `SomeClass` to inherit from `SomeBaseClass` and also *explicitly* re-declare its conformance to each of `ProtocolA`, `ProtocolB`, and `ProtocolC`, correct?<br></p><p>If so, IMHO, this would be a change for the worse in the context of UI-level code; it’s quite possible there&#39;d be no specific class that could be used as `$SomeClass` (without a lot of busywork re-declarations of conformance); moreover, you’d have to do it again for each concrete type you expected to use with `Whatever`, which seems like a rather non-generic form of generics. But I might be misunderstanding.<br></p><p>Finally, as an observation, there are at least two different “flavors” of classes:<br></p><p>- value-ish classes, which mostly exist to represent some value (lots of Foundation, many “model classes”, etc.)<br>- identity-ish classes, which are specifically used as “entities” (UIView, CALayer, NSURLSession, NSOperation, etc.)<br></p><p>…and whereas the `value-ish` classes are often hitting awkward issues due to how protocol conformance and class inheritance interact, the identity-ish classes *largely* aren’t (with the main exception being due to inheriting `NSCoder` and perhaps `NSCopying`, which although awkward don’t seem awkward enough on their own to merit such a sweeping language-level change; a smaller change could address these).<br></p><p>In the identity-ish scenario I think subclasses inheriting their parent&#39;s protocol inheritance is *exactly* the usual — and useful — case, and thus I’d hope any solution to the issues encountered by value-ish classes would avoid making the creation-and-use of identity-ish classes too much more difficult / more tedious; please keep in mind that the “common” case in reports-of-problems may not be the “common” case in the field; when things work as-expected you may not hear as much about them, because there’s not much to say.<br></p><p>&gt; On Dec 10, 2015, at 8:04 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve had a number of twitter conversations with users who have valiantly fought our type system and lost when trying to make their protocols interact well with non-final classes. A few from recent memory:<br>&gt; <br>&gt; - Rob Napier struggling to implement a `copy` method that works well with subclasses: https://twitter.com/cocoaphony/status/660914612850843648 &lt;https://twitter.com/cocoaphony/status/660914612850843648&gt;<br>&gt; and making the observation that the interaction of protocol conformance and subtyping is very difficult to teach.<br>&gt; <br>&gt; - Matt Bischoff trying to make Cocoa class clusters retroactively conform to his factory protocol:<br>&gt; https://twitter.com/anandabits/status/664294382774849536 &lt;https://twitter.com/anandabits/status/664294382774849536&gt;<br>&gt; <br>&gt; and Karl Adam trying to do the same:<br>&gt; https://gist.github.com/thekarladam/c3094769cc8c87bf55e3 &lt;https://gist.github.com/thekarladam/c3094769cc8c87bf55e3&gt;<br>&gt; <br>&gt; These problems stem from the way protocol conformances currently interact with class inheritance—specifically, that if a class conforms to a protocol, then all of its possible derived classes also conform. This seems like the obvious way things should be, but in practice it ends up fighting how many classes are intended to be used. Often only a base class is intended to be the public interface, and derived classes are only implementation details—Cocoa class clusters are a great example of this. The inheritance of protocol conformances also imposes a bunch of knock-on complexity on conforming classes—initializer requirements must be satisfied by `required` initializers (which then must be overridden in all derived classes, to the pain of anyone touching an NSCoding-inherited class), and methods often must return dynamic `Self` when they&#39;d really prefer to return the base class.<br>&gt; <br>&gt; To mitigate these issues, I&#39;d like to float the idea that protocol conformances *not be* inherited by default. If you declare a class as conforming to a protocol, only exactly that class can be bound to a type parameter constrained by that protocol:<br>&gt; <br>&gt; protocol Runcible {}<br>&gt; class A: Runcible { }<br>&gt; class B { }<br>&gt; <br>&gt; func foo&lt;T: Runcible&gt;(x: T) {}<br>&gt; <br>&gt; foo(B()) // calls foo with T == A<br>&gt; <br>&gt; Since subclasses are still subtypes of the base class, in many cases client code won&#39;t have to change at all, since derived instances can implicitly upconvert to their conforming base class when used in protocol types or generics that only the base class conforms to. (There are cases like if the type parameter appears in a NonCovariant&lt;T&gt; type where this isn&#39;t possible, though.) Protocol requirements for a non-inherited conformance don&#39;t need to be `required` initializers, or maintain covariant returns:<br>&gt; <br>&gt; protocol Fungible {<br>&gt;   init()<br>&gt;   static func funged() -&gt; Self<br>&gt; }<br>&gt; <br>&gt; class C: Fungible {<br>&gt;   init() {} // Non-required init is fine, since subclasses aren&#39;t directly Fungible<br>&gt; <br>&gt;   // Non-Self return is fine too<br>&gt;   class func funged() -&gt; C { return C() }<br>&gt; }<br>&gt; <br>&gt; An individual subclass that wanted to refine the conformance could do so by `override`-ing it, and providing any necessary covariant overrides of initializers and methods:<br>&gt; <br>&gt; class D: C, override Fungible {<br>&gt;   // D must provide its own init()<br>&gt;   init() { super.init() }<br>&gt; <br>&gt;   // D must override funged() to return D instead of C<br>&gt;   override class func funged() -&gt; D { return D() }<br>&gt; }<br>&gt; <br>&gt; And if a class hierarchy really wants to impose a conformance on all possible subclasses, as happens today, we could let you opt in to that:<br>&gt; <br>&gt; class E: required Fungible {<br>&gt;   // init() must be required of all subclasses<br>&gt;   required init() { }<br>&gt; <br>&gt;   // funged() must return a covariant object<br>&gt;   class func funged() -&gt; Self { return Self() }<br>&gt; }<br>&gt; <br>&gt; This is undoubtedly a complication of the language, but I think it might let us more accurately model a lot of things people seem to want to do in practice with class hierarchies and protocols, and it simplifies the behavior of the arguably common case where inheritance of the conformance isn&#39;t desired. What do you all think?<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/38d684fe/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>Making protocol conformance inheritance controllable</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>December 13, 2015 at 12:00:00am</p></header><div class="content"><p>If for no other reason*, I would support this idea because it should allow us to make NSURL conform to StringLiteralConvertible. This was possible back when literal convertibility was handled via static methods, but the `required` initializer requirement currently prevents conforming via an extension.<br></p><p>Nate<br></p><p><br>*your other reasons are all good too<br></p><p>&gt; On Dec 10, 2015, at 8:04 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve had a number of twitter conversations with users who have valiantly fought our type system and lost when trying to make their protocols interact well with non-final classes. A few from recent memory:<br>&gt; <br>&gt; - Rob Napier struggling to implement a `copy` method that works well with subclasses: https://twitter.com/cocoaphony/status/660914612850843648 &lt;https://twitter.com/cocoaphony/status/660914612850843648&gt;<br>&gt; and making the observation that the interaction of protocol conformance and subtyping is very difficult to teach.<br>&gt; <br>&gt; - Matt Bischoff trying to make Cocoa class clusters retroactively conform to his factory protocol:<br>&gt; https://twitter.com/anandabits/status/664294382774849536 &lt;https://twitter.com/anandabits/status/664294382774849536&gt;<br>&gt; <br>&gt; and Karl Adam trying to do the same:<br>&gt; https://gist.github.com/thekarladam/c3094769cc8c87bf55e3 &lt;https://gist.github.com/thekarladam/c3094769cc8c87bf55e3&gt;<br>&gt; <br>&gt; These problems stem from the way protocol conformances currently interact with class inheritance—specifically, that if a class conforms to a protocol, then all of its possible derived classes also conform. This seems like the obvious way things should be, but in practice it ends up fighting how many classes are intended to be used. Often only a base class is intended to be the public interface, and derived classes are only implementation details—Cocoa class clusters are a great example of this. The inheritance of protocol conformances also imposes a bunch of knock-on complexity on conforming classes—initializer requirements must be satisfied by `required` initializers (which then must be overridden in all derived classes, to the pain of anyone touching an NSCoding-inherited class), and methods often must return dynamic `Self` when they&#39;d really prefer to return the base class.<br>&gt; <br>&gt; To mitigate these issues, I&#39;d like to float the idea that protocol conformances *not be* inherited by default. If you declare a class as conforming to a protocol, only exactly that class can be bound to a type parameter constrained by that protocol:<br>&gt; <br>&gt; protocol Runcible {}<br>&gt; class A: Runcible { }<br>&gt; class B { }<br>&gt; <br>&gt; func foo&lt;T: Runcible&gt;(x: T) {}<br>&gt; <br>&gt; foo(B()) // calls foo with T == A<br>&gt; <br>&gt; Since subclasses are still subtypes of the base class, in many cases client code won&#39;t have to change at all, since derived instances can implicitly upconvert to their conforming base class when used in protocol types or generics that only the base class conforms to. (There are cases like if the type parameter appears in a NonCovariant&lt;T&gt; type where this isn&#39;t possible, though.) Protocol requirements for a non-inherited conformance don&#39;t need to be `required` initializers, or maintain covariant returns:<br>&gt; <br>&gt; protocol Fungible {<br>&gt;   init()<br>&gt;   static func funged() -&gt; Self<br>&gt; }<br>&gt; <br>&gt; class C: Fungible {<br>&gt;   init() {} // Non-required init is fine, since subclasses aren&#39;t directly Fungible<br>&gt; <br>&gt;   // Non-Self return is fine too<br>&gt;   class func funged() -&gt; C { return C() }<br>&gt; }<br>&gt; <br>&gt; An individual subclass that wanted to refine the conformance could do so by `override`-ing it, and providing any necessary covariant overrides of initializers and methods:<br>&gt; <br>&gt; class D: C, override Fungible {<br>&gt;   // D must provide its own init()<br>&gt;   init() { super.init() }<br>&gt; <br>&gt;   // D must override funged() to return D instead of C<br>&gt;   override class func funged() -&gt; D { return D() }<br>&gt; }<br>&gt; <br>&gt; And if a class hierarchy really wants to impose a conformance on all possible subclasses, as happens today, we could let you opt in to that:<br>&gt; <br>&gt; class E: required Fungible {<br>&gt;   // init() must be required of all subclasses<br>&gt;   required init() { }<br>&gt; <br>&gt;   // funged() must return a covariant object<br>&gt;   class func funged() -&gt; Self { return Self() }<br>&gt; }<br>&gt; <br>&gt; This is undoubtedly a complication of the language, but I think it might let us more accurately model a lot of things people seem to want to do in practice with class hierarchies and protocols, and it simplifies the behavior of the arguably common case where inheritance of the conformance isn&#39;t desired. What do you all think?<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/fce18fce/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Making protocol conformance inheritance controllable</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 15, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 8:04 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; I&#39;ve had a number of twitter conversations with users who have valiantly fought our type system and lost when trying to make their protocols interact well with non-final classes. A few from recent memory:<br>&gt; <br>&gt; - Rob Napier struggling to implement a `copy` method that works well with subclasses: https://twitter.com/cocoaphony/status/660914612850843648 &lt;https://twitter.com/cocoaphony/status/660914612850843648&gt;<br>&gt; and making the observation that the interaction of protocol conformance and subtyping is very difficult to teach.<br>&gt; <br>&gt; - Matt Bischoff trying to make Cocoa class clusters retroactively conform to his factory protocol:<br>&gt; https://twitter.com/anandabits/status/664294382774849536 &lt;https://twitter.com/anandabits/status/664294382774849536&gt;<br>&gt; <br>&gt; and Karl Adam trying to do the same:<br>&gt; https://gist.github.com/thekarladam/c3094769cc8c87bf55e3 &lt;https://gist.github.com/thekarladam/c3094769cc8c87bf55e3&gt;<br>&gt; <br>&gt; These problems stem from the way protocol conformances currently interact with class inheritance—specifically, that if a class conforms to a protocol, then all of its possible derived classes also conform. This seems like the obvious way things should be, but in practice it ends up fighting how many classes are intended to be used. Often only a base class is intended to be the public interface, and derived classes are only implementation details—Cocoa class clusters are a great example of this. The inheritance of protocol conformances also imposes a bunch of knock-on complexity on conforming classes—initializer requirements must be satisfied by `required` initializers (which then must be overridden in all derived classes, to the pain of anyone touching an NSCoding-inherited class), and methods often must return dynamic `Self` when they&#39;d really prefer to return the base class.<br>&gt; <br>&gt; To mitigate these issues, I&#39;d like to float the idea that protocol conformances *not be* inherited by default. If you declare a class as conforming to a protocol, only exactly that class can be bound to a type parameter constrained by that protocol:<br></p><p>What exactly does that mean?<br></p><p>If A conforms to Runcible and B is derived from A that means that B is a subtype of A and can be used everywhere an A can be used (substitution principle).<br>Therefore if I can use an A where a Runcible is required, I must be able to use a B as well. Subtyping is transitive which gets somehow broken in this proposal (or maybe not, see below).<br></p><p>&gt; <br>&gt; protocol Runcible {}<br>&gt; class A: Runcible { }<br>&gt; class B : A { }<br></p><p><br>&gt; func foo&lt;T: Runcible&gt;(x: T) {}<br>&gt; <br>&gt; foo(B()) // calls foo with T == A<br></p><p>This would just hold for the static type of T, right?<br>The dynamic type of x still stays B and dynamic dispatch would respect that whereas static dispatch (e.g. for extension methods declared for A and B separately) would use the static type A (i.e. dispatch to the extension method declared for A).<br></p><p>&gt; Since subclasses are still subtypes of the base class, in many cases client code won&#39;t have to change at all, since derived instances can implicitly upconvert to their conforming base class when used in protocol types or generics that only the base class conforms to. (There are cases like if the type parameter appears in a NonCovariant&lt;T&gt; type where this isn&#39;t possible, though.)<br></p><p><br>&gt; Protocol requirements for a non-inherited conformance don&#39;t need to be `required` initializers, or maintain covariant returns:<br></p><p>The required initializers are probably the motivation for this change.<br>Is there a problem with covariant returns as well? I&#39;d think a subclass does not have to do anything to just get them, so I don&#39;t see a problem there.<br></p><p>If I understand the desire behind the proposal correctly, it is about<br>(a) stopping Self types to vary below some point in the hierarchy<br>(b) controlling the requiredness of initializers within the hierarchy (doesn’t that collide with the idea of requiring an initializer in the first place?)<br></p><p>I have the vague felling (or hope) that this can be done more nicely in other ways without tampering with subtyping.<br></p><p>Joe Groff recently proposed in another thread something similar for Self types in Equatable:<br></p><p>public protocol Equatable {<br>    typealias EquatesWith = Self where Self: EquatesWith<br>    func ==(lhs: EquatesWith, rhs: EquatesWith) -&gt; Bool<br>}<br></p><p>This way subclasses or subprotocols can decide where they want to fix EquatesWith to a fixed value:<br></p><p>protocol Fungible {<br>    typealias F = Self where Self: F<br>    static func funged() -&gt; F<br>}<br></p><p>class C: Fungible {<br>    class func funged() -&gt; F { return C() }<br>}<br></p><p>class D: C {<br>    override class func funged() -&gt; F { return D() }<br>}<br></p><p>class X: C {<br>    typealias F = C<br>}<br></p><p>D.funged() has static type D<br>X.funged() has static type C<br></p><p><br>Would this fit your expectations for the Self type issues? Or have I misunderstood the problem completely?<br></p><p>Maybe something similar can be done for requiredness of initializers.<br></p><p>-Thorsten<br></p><p><br>&gt; protocol Fungible {<br>&gt;   init()<br>&gt;   static func funged() -&gt; Self<br>&gt; }<br>&gt; <br>&gt; class C: Fungible {<br>&gt;   init() {} // Non-required init is fine, since subclasses aren&#39;t directly Fungible<br>&gt; <br>&gt;   // Non-Self return is fine too<br>&gt;   class func funged() -&gt; C { return C() }<br>&gt; }<br>&gt; <br>&gt; An individual subclass that wanted to refine the conformance could do so by `override`-ing it, and providing any necessary covariant overrides of initializers and methods:<br>&gt; <br>&gt; class D: C, override Fungible {<br>&gt;   // D must provide its own init()<br>&gt;   init() { super.init() }<br>&gt; <br>&gt;   // D must override funged() to return D instead of C<br>&gt;   override class func funged() -&gt; D { return D() }<br>&gt; }<br>&gt; <br>&gt; And if a class hierarchy really wants to impose a conformance on all possible subclasses, as happens today, we could let you opt in to that:<br>&gt; <br>&gt; class E: required Fungible {<br>&gt;   // init() must be required of all subclasses<br>&gt;   required init() { }<br>&gt; <br>&gt;   // funged() must return a covariant object<br>&gt;   class func funged() -&gt; Self { return Self() }<br>&gt; }<br>&gt; <br>&gt; This is undoubtedly a complication of the language, but I think it might let us more accurately model a lot of things people seem to want to do in practice with class hierarchies and protocols, and it simplifies the behavior of the arguably common case where inheritance of the conformance isn&#39;t desired. What do you all think?<br>&gt; <br>&gt; -Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/c0ac9852/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Making protocol conformance inheritance controllable</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 15, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 10:26 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 8:04 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve had a number of twitter conversations with users who have valiantly fought our type system and lost when trying to make their protocols interact well with non-final classes. A few from recent memory:<br>&gt;&gt; <br>&gt;&gt; - Rob Napier struggling to implement a `copy` method that works well with subclasses: https://twitter.com/cocoaphony/status/660914612850843648 &lt;https://twitter.com/cocoaphony/status/660914612850843648&gt;<br>&gt;&gt; and making the observation that the interaction of protocol conformance and subtyping is very difficult to teach.<br>&gt;&gt; <br>&gt;&gt; - Matt Bischoff trying to make Cocoa class clusters retroactively conform to his factory protocol:<br>&gt;&gt; https://twitter.com/anandabits/status/664294382774849536 &lt;https://twitter.com/anandabits/status/664294382774849536&gt;<br>&gt;&gt; <br>&gt;&gt; and Karl Adam trying to do the same:<br>&gt;&gt; https://gist.github.com/thekarladam/c3094769cc8c87bf55e3 &lt;https://gist.github.com/thekarladam/c3094769cc8c87bf55e3&gt;<br>&gt;&gt; <br>&gt;&gt; These problems stem from the way protocol conformances currently interact with class inheritance—specifically, that if a class conforms to a protocol, then all of its possible derived classes also conform. This seems like the obvious way things should be, but in practice it ends up fighting how many classes are intended to be used. Often only a base class is intended to be the public interface, and derived classes are only implementation details—Cocoa class clusters are a great example of this. The inheritance of protocol conformances also imposes a bunch of knock-on complexity on conforming classes—initializer requirements must be satisfied by `required` initializers (which then must be overridden in all derived classes, to the pain of anyone touching an NSCoding-inherited class), and methods often must return dynamic `Self` when they&#39;d really prefer to return the base class.<br>&gt;&gt; <br>&gt;&gt; To mitigate these issues, I&#39;d like to float the idea that protocol conformances *not be* inherited by default. If you declare a class as conforming to a protocol, only exactly that class can be bound to a type parameter constrained by that protocol:<br>&gt; <br>&gt; What exactly does that mean?<br>&gt; <br>&gt; If A conforms to Runcible and B is derived from A that means that B is a subtype of A and can be used everywhere an A can be used (substitution principle).<br>&gt; Therefore if I can use an A where a Runcible is required, I must be able to use a B as well. Subtyping is transitive which gets somehow broken in this proposal (or maybe not, see below).<br></p><p>B-is-subtype-of-A-is-subtype-of-Runcible still holds, but B couldn&#39;t be bound to a type variable that was constrained to be Runcible, only A. Subtyping is never quite cut and dry when interacting with parametric type systems; it&#39;s not always the case that Foo&lt;B&gt; is a subtype of Foo&lt;A&gt; even if B is a subtype of A. This adds extra edge cases, definitely.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; protocol Runcible {}<br>&gt;&gt; class A: Runcible { }<br>&gt;&gt; class B : A { }<br>&gt; <br>&gt; <br>&gt;&gt; func foo&lt;T: Runcible&gt;(x: T) {}<br>&gt;&gt; <br>&gt;&gt; foo(B()) // calls foo with T == A<br>&gt; <br>&gt; This would just hold for the static type of T, right?<br>&gt; The dynamic type of x still stays B and dynamic dispatch would respect that whereas static dispatch (e.g. for extension methods declared for A and B separately) would use the static type A (i.e. dispatch to the extension method declared for A).<br></p><p>Right, the dynamic type of the variable &#39;x&#39; would still be B, even though T == A.<br></p><p>&gt; <br>&gt;&gt; Since subclasses are still subtypes of the base class, in many cases client code won&#39;t have to change at all, since derived instances can implicitly upconvert to their conforming base class when used in protocol types or generics that only the base class conforms to. (There are cases like if the type parameter appears in a NonCovariant&lt;T&gt; type where this isn&#39;t possible, though.)<br>&gt; <br>&gt; <br>&gt;&gt; Protocol requirements for a non-inherited conformance don&#39;t need to be `required` initializers, or maintain covariant returns:<br>&gt; <br>&gt; The required initializers are probably the motivation for this change.<br>&gt; Is there a problem with covariant returns as well? I&#39;d think a subclass does not have to do anything to just get them, so I don&#39;t see a problem there.<br>&gt; <br>&gt; If I understand the desire behind the proposal correctly, it is about<br>&gt; (a) stopping Self types to vary below some point in the hierarchy<br>&gt; (b) controlling the requiredness of initializers within the hierarchy (doesn’t that collide with the idea of requiring an initializer in the first place?)<br>&gt; <br>&gt; I have the vague felling (or hope) that this can be done more nicely in other ways without tampering with subtyping.<br>&gt; <br>&gt; Joe Groff recently proposed in another thread something similar for Self types in Equatable:<br>&gt; <br>&gt; public protocol Equatable {<br>&gt;     typealias EquatesWith = Self where Self: EquatesWith<br>&gt;     func ==(lhs: EquatesWith, rhs: EquatesWith) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; This way subclasses or subprotocols can decide where they want to fix EquatesWith to a fixed value:<br>&gt; <br>&gt; protocol Fungible {<br>&gt;     typealias F = Self where Self: F<br>&gt;     static func funged() -&gt; F<br>&gt; }<br>&gt; <br>&gt; class C: Fungible {<br>&gt;     class func funged() -&gt; F { return C() }<br>&gt; }<br>&gt; <br>&gt; class D: C {<br>&gt;     override class func funged() -&gt; F { return D() }<br>&gt; }<br>&gt; <br>&gt; class X: C {<br>&gt;     typealias F = C<br>&gt; }<br>&gt; <br>&gt; D.funged() has static type D<br>&gt; X.funged() has static type C<br>&gt; <br>&gt; <br>&gt; Would this fit your expectations for the Self type issues? Or have I misunderstood the problem completely?<br></p><p>Equatable has the opposite problem that its Self requirements are contravariant, since they appear in argument position; this means Equatable itself can&#39;t naturally be used as the existential type of all Equatables, but it isn&#39;t a problem for a class hierarchy to conform all subclasses to Equatable—`Base == Base` satisfies the protocol requirement for any possible Derived type. An associated type indirection like this still wouldn&#39;t solve the factory method covariance problem, since `Self` inside protocol conformances today always refers to the potentially-derived type when classes are involved.<br></p><p>-Joe<br></p><p>&gt; <br>&gt; Maybe something similar can be done for requiredness of initializers.<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; protocol Fungible {<br>&gt;&gt;   init()<br>&gt;&gt;   static func funged() -&gt; Self<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class C: Fungible {<br>&gt;&gt;   init() {} // Non-required init is fine, since subclasses aren&#39;t directly Fungible<br>&gt;&gt; <br>&gt;&gt;   // Non-Self return is fine too<br>&gt;&gt;   class func funged() -&gt; C { return C() }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; An individual subclass that wanted to refine the conformance could do so by `override`-ing it, and providing any necessary covariant overrides of initializers and methods:<br>&gt;&gt; <br>&gt;&gt; class D: C, override Fungible {<br>&gt;&gt;   // D must provide its own init()<br>&gt;&gt;   init() { super.init() }<br>&gt;&gt; <br>&gt;&gt;   // D must override funged() to return D instead of C<br>&gt;&gt;   override class func funged() -&gt; D { return D() }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; And if a class hierarchy really wants to impose a conformance on all possible subclasses, as happens today, we could let you opt in to that:<br>&gt;&gt; <br>&gt;&gt; class E: required Fungible {<br>&gt;&gt;   // init() must be required of all subclasses<br>&gt;&gt;   required init() { }<br>&gt;&gt; <br>&gt;&gt;   // funged() must return a covariant object<br>&gt;&gt;   class func funged() -&gt; Self { return Self() }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This is undoubtedly a complication of the language, but I think it might let us more accurately model a lot of things people seem to want to do in practice with class hierarchies and protocols, and it simplifies the behavior of the arguably common case where inheritance of the conformance isn&#39;t desired. What do you all think?<br>&gt;&gt; <br>&gt;&gt; -Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/a2f6f7ad/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Making protocol conformance inheritance controllable</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 14, 2015 at 06:00:00pm</p></header><div class="content"><p>At first this didn&#39;t make any sense to me. Now it makes some kind of twisted sense, and I&#39;m working my way through the details:<br></p><p>protocol Proto { /*…*/ }<br>class Base : Proto { /*…*/ }<br>class Subclass : Base {}<br></p><p>- Protocols with no initializer requirements and no use of &#39;Self&#39; are trivially safe here, because there&#39;s no way to recover the original type.<br></p><p>- Methods returning &#39;Self&#39; will silently return the base type. This is often reasonable, but it&#39;s still a little weird. There&#39;s also no way to have a protocol that requires dynamic-self behavior for a factory method.<br></p><p>Subclass.createViaProtocol() // produces a Base<br></p><p>- Initializers are not guaranteed to be inherited. That&#39;s not weird for Swift. It&#39;s a little weird for Objective-C, but we already emit placeholders for non-inherited initializers to produce a runtime failure, which is what most NSCoder-bemoaners want anyway.<br></p><p>- Methods taking &#39;Self&#39; will silently accept the base type. If you override a conformance, you have to continue accepting the base type for these requirements, but that&#39;s just normal override rules.<br></p><p>- Overriding a conformance still doesn&#39;t let you change the associated types, even covariantly, because extensions to the base type may have used them in new positions. (Alternately, associated types and generic parameters are still invariant and we&#39;d need a language feature to make them non-invariant.)<br></p><p>- Generic constraints will have to be taught to infer the base type.<br></p><p>foo(Subclass()) // calls foo&lt;Base&gt;(Subclass())<br>let obj: Subclass = bar() // error, because bar&lt;Base&gt;() will return a Base<br></p><p>- What does &quot;subclass is Proto&quot; do? What does &quot;Subclass.self is Proto.Type&quot; do? What does &quot;Subclasses.instancesConformToProtocol(Proto.self)&quot; do? My guess is &#39;true&#39; for all three even though it&#39;s not exactly correct for Objective-C protocols with initializer requirements, but then what&#39;s the query that returns &#39;false&#39;?<br></p><p>- Given all this, what benefit does required conformance bring? Just shorthand for making all the initializers required? (Which may be important if you got some of them through protocol extensions.)<br></p><p>Gosh. Maybe we can do it.<br></p><p>Jordan<br></p><p><br>&gt; On Dec 10, 2015, at 18:04, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve had a number of twitter conversations with users who have valiantly fought our type system and lost when trying to make their protocols interact well with non-final classes. A few from recent memory:<br>&gt; <br>&gt; - Rob Napier struggling to implement a `copy` method that works well with subclasses: https://twitter.com/cocoaphony/status/660914612850843648 &lt;https://twitter.com/cocoaphony/status/660914612850843648&gt;<br>&gt; and making the observation that the interaction of protocol conformance and subtyping is very difficult to teach.<br>&gt; <br>&gt; - Matt Bischoff trying to make Cocoa class clusters retroactively conform to his factory protocol:<br>&gt; https://twitter.com/anandabits/status/664294382774849536 &lt;https://twitter.com/anandabits/status/664294382774849536&gt;<br>&gt; <br>&gt; and Karl Adam trying to do the same:<br>&gt; https://gist.github.com/thekarladam/c3094769cc8c87bf55e3 &lt;https://gist.github.com/thekarladam/c3094769cc8c87bf55e3&gt;<br>&gt; <br>&gt; These problems stem from the way protocol conformances currently interact with class inheritance—specifically, that if a class conforms to a protocol, then all of its possible derived classes also conform. This seems like the obvious way things should be, but in practice it ends up fighting how many classes are intended to be used. Often only a base class is intended to be the public interface, and derived classes are only implementation details—Cocoa class clusters are a great example of this. The inheritance of protocol conformances also imposes a bunch of knock-on complexity on conforming classes—initializer requirements must be satisfied by `required` initializers (which then must be overridden in all derived classes, to the pain of anyone touching an NSCoding-inherited class), and methods often must return dynamic `Self` when they&#39;d really prefer to return the base class.<br>&gt; <br>&gt; To mitigate these issues, I&#39;d like to float the idea that protocol conformances *not be* inherited by default. If you declare a class as conforming to a protocol, only exactly that class can be bound to a type parameter constrained by that protocol:<br>&gt; <br>&gt; protocol Runcible {}<br>&gt; class A: Runcible { }<br>&gt; class B { }<br>&gt; <br>&gt; func foo&lt;T: Runcible&gt;(x: T) {}<br>&gt; <br>&gt; foo(B()) // calls foo with T == A<br>&gt; <br>&gt; Since subclasses are still subtypes of the base class, in many cases client code won&#39;t have to change at all, since derived instances can implicitly upconvert to their conforming base class when used in protocol types or generics that only the base class conforms to. (There are cases like if the type parameter appears in a NonCovariant&lt;T&gt; type where this isn&#39;t possible, though.) Protocol requirements for a non-inherited conformance don&#39;t need to be `required` initializers, or maintain covariant returns:<br>&gt; <br>&gt; protocol Fungible {<br>&gt;   init()<br>&gt;   static func funged() -&gt; Self<br>&gt; }<br>&gt; <br>&gt; class C: Fungible {<br>&gt;   init() {} // Non-required init is fine, since subclasses aren&#39;t directly Fungible<br>&gt; <br>&gt;   // Non-Self return is fine too<br>&gt;   class func funged() -&gt; C { return C() }<br>&gt; }<br>&gt; <br>&gt; An individual subclass that wanted to refine the conformance could do so by `override`-ing it, and providing any necessary covariant overrides of initializers and methods:<br>&gt; <br>&gt; class D: C, override Fungible {<br>&gt;   // D must provide its own init()<br>&gt;   init() { super.init() }<br>&gt; <br>&gt;   // D must override funged() to return D instead of C<br>&gt;   override class func funged() -&gt; D { return D() }<br>&gt; }<br>&gt; <br>&gt; And if a class hierarchy really wants to impose a conformance on all possible subclasses, as happens today, we could let you opt in to that:<br>&gt; <br>&gt; class E: required Fungible {<br>&gt;   // init() must be required of all subclasses<br>&gt;   required init() { }<br>&gt; <br>&gt;   // funged() must return a covariant object<br>&gt;   class func funged() -&gt; Self { return Self() }<br>&gt; }<br>&gt; <br>&gt; This is undoubtedly a complication of the language, but I think it might let us more accurately model a lot of things people seem to want to do in practice with class hierarchies and protocols, and it simplifies the behavior of the arguably common case where inheritance of the conformance isn&#39;t desired. What do you all think?<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/0d2a5d5a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Making protocol conformance inheritance controllable</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>December 14, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 18:04, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve had a number of twitter conversations with users who have valiantly fought our type system and lost when trying to make their protocols interact well with non-final classes. A few from recent memory:<br>&gt; <br>&gt; - Rob Napier struggling to implement a `copy` method that works well with subclasses: https://twitter.com/cocoaphony/status/660914612850843648<br>&gt; and making the observation that the interaction of protocol conformance and subtyping is very difficult to teach.<br>&gt; <br>&gt; - Matt Bischoff trying to make Cocoa class clusters retroactively conform to his factory protocol:<br>&gt; https://twitter.com/anandabits/status/664294382774849536<br>&gt; <br>&gt; and Karl Adam trying to do the same:<br>&gt; https://gist.github.com/thekarladam/c3094769cc8c87bf55e3<br>&gt; <br>&gt; These problems stem from the way protocol conformances currently interact with class inheritance—specifically, that if a class conforms to a protocol, then all of its possible derived classes also conform. This seems like the obvious way things should be, but in practice it ends up fighting how many classes are intended to be used. Often only a base class is intended to be the public interface, and derived classes are only implementation details—Cocoa class clusters are a great example of this. The inheritance of protocol conformances also imposes a bunch of knock-on complexity on conforming classes—initializer requirements must be satisfied by `required` initializers (which then must be overridden in all derived classes, to the pain of anyone touching an NSCoding-inherited class), and methods often must return dynamic `Self` when they&#39;d really prefer to return the base class.<br>&gt; <br>&gt; To mitigate these issues, I&#39;d like to float the idea that protocol conformances *not be* inherited by default.<br></p><p>I don&#39;t like it. <br></p><p>The problems in the motivating examples all center around protocols with factory methods or other uses of Self. Changing the behavior of all protocols seems like the wrong tool to solve that problem. There must be a narrower solution that improves those cases without changing so much existing code and understanding. (Are there any other languages with similar behavior?)<br></p><p>The &quot;NSCoding is annoying&quot; example is particularly dangerous. Historically the alternatives have been:<br></p><p>* Don&#39;t require subclasses to implement init(coder:). This leads to difficult bugs where a subclass does not implement init(coder:) but somebody tries to encode and decode an instance of it. There are no compile-time errors, no runtime errors, and the resulting decoded object is corrupt.<br></p><p>* Require subclasses to implement init(coder:), even if all it does is abort(). This provides good runtime diagnostics against the bug above, at the cost of some subclass boilerplate. This is what Swift does, and what ObjC now does with the new designated initializer enforcement.<br></p><p>I fear that non-inherited protocols will reintroduce the old bugs. The subclasses will not be required to implement init(coder:), and encoding and decoding an instance of such a class will do corrupt things at runtime with no runtime diagnostics.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Making protocol conformance inheritance controllable</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 14, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; The problems in the motivating examples all center around protocols with factory methods or other uses of Self. Changing the behavior of all protocols seems like the wrong tool to solve that problem. There must be a narrower solution that improves those cases without changing so much existing code and understanding. (Are there any other languages with similar behavior?)<br></p><p>I had a Twitter exchange with Joe on this topic about a month ago as well.  It was also an initializer / factory method example where I was unable to write conformance for Foundation classes.<br></p><p>I mentioned the possible solution of allowing a protocol to specify something like Self that would be non-covarying.  I don&#39;t have any idea what a good name for this might but it would have worked for the problem I was trying to solve.   It is certainly a much narrower solution. <br></p><p>Matthew<br></p><p>If I remember correctly he<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Making protocol conformance inheritance controllable</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 15, 2015 at 06:00:00am</p></header><div class="content"><p>This is an issue that comes up constantly around me. I&#39;m probably taking the wrong view on things but it seems as if a lot of the problem comes from trying to squeeze Cocoa classes, especially UIKit ones, into a Swift system where native reference types are more often naturally final. There&#39;s a kind of turbulence that builds up between the two systems.<br></p><p>-- E<br></p><p>&gt; On Dec 14, 2015, at 7:53 PM, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 18:04, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve had a number of twitter conversations with users who have valiantly fought our type system and lost when trying to make their protocols interact well with non-final classes. A few from recent memory:<br>&gt;&gt; <br>&gt;&gt; - Rob Napier struggling to implement a `copy` method that works well with subclasses: https://twitter.com/cocoaphony/status/660914612850843648<br>&gt;&gt; and making the observation that the interaction of protocol conformance and subtyping is very difficult to teach.<br>&gt;&gt; <br>&gt;&gt; - Matt Bischoff trying to make Cocoa class clusters retroactively conform to his factory protocol:<br>&gt;&gt; https://twitter.com/anandabits/status/664294382774849536<br>&gt;&gt; <br>&gt;&gt; and Karl Adam trying to do the same:<br>&gt;&gt; https://gist.github.com/thekarladam/c3094769cc8c87bf55e3<br>&gt;&gt; <br>&gt;&gt; These problems stem from the way protocol conformances currently interact with class inheritance—specifically, that if a class conforms to a protocol, then all of its possible derived classes also conform. This seems like the obvious way things should be, but in practice it ends up fighting how many classes are intended to be used. Often only a base class is intended to be the public interface, and derived classes are only implementation details—Cocoa class clusters are a great example of this. The inheritance of protocol conformances also imposes a bunch of knock-on complexity on conforming classes—initializer requirements must be satisfied by `required` initializers (which then must be overridden in all derived classes, to the pain of anyone touching an NSCoding-inherited class), and methods often must return dynamic `Self` when they&#39;d really prefer to return the base class.<br>&gt;&gt; <br>&gt;&gt; To mitigate these issues, I&#39;d like to float the idea that protocol conformances *not be* inherited by default.<br>&gt; <br>&gt; I don&#39;t like it. <br>&gt; <br>&gt; The problems in the motivating examples all center around protocols with factory methods or other uses of Self. Changing the behavior of all protocols seems like the wrong tool to solve that problem. There must be a narrower solution that improves those cases without changing so much existing code and understanding. (Are there any other languages with similar behavior?)<br>&gt; <br>&gt; The &quot;NSCoding is annoying&quot; example is particularly dangerous. Historically the alternatives have been:<br>&gt; <br>&gt; * Don&#39;t require subclasses to implement init(coder:). This leads to difficult bugs where a subclass does not implement init(coder:) but somebody tries to encode and decode an instance of it. There are no compile-time errors, no runtime errors, and the resulting decoded object is corrupt.<br>&gt; <br>&gt; * Require subclasses to implement init(coder:), even if all it does is abort(). This provides good runtime diagnostics against the bug above, at the cost of some subclass boilerplate. This is what Swift does, and what ObjC now does with the new designated initializer enforcement.<br>&gt; <br>&gt; I fear that non-inherited protocols will reintroduce the old bugs. The subclasses will not be required to implement init(coder:), and encoding and decoding an instance of such a class will do corrupt things at runtime with no runtime diagnostics.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Making protocol conformance inheritance controllable</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 15, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 14, 2015, at 6:53 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 18:04, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve had a number of twitter conversations with users who have valiantly fought our type system and lost when trying to make their protocols interact well with non-final classes. A few from recent memory:<br>&gt;&gt; <br>&gt;&gt; - Rob Napier struggling to implement a `copy` method that works well with subclasses: https://twitter.com/cocoaphony/status/660914612850843648<br>&gt;&gt; and making the observation that the interaction of protocol conformance and subtyping is very difficult to teach.<br>&gt;&gt; <br>&gt;&gt; - Matt Bischoff trying to make Cocoa class clusters retroactively conform to his factory protocol:<br>&gt;&gt; https://twitter.com/anandabits/status/664294382774849536<br>&gt;&gt; <br>&gt;&gt; and Karl Adam trying to do the same:<br>&gt;&gt; https://gist.github.com/thekarladam/c3094769cc8c87bf55e3<br>&gt;&gt; <br>&gt;&gt; These problems stem from the way protocol conformances currently interact with class inheritance—specifically, that if a class conforms to a protocol, then all of its possible derived classes also conform. This seems like the obvious way things should be, but in practice it ends up fighting how many classes are intended to be used. Often only a base class is intended to be the public interface, and derived classes are only implementation details—Cocoa class clusters are a great example of this. The inheritance of protocol conformances also imposes a bunch of knock-on complexity on conforming classes—initializer requirements must be satisfied by `required` initializers (which then must be overridden in all derived classes, to the pain of anyone touching an NSCoding-inherited class), and methods often must return dynamic `Self` when they&#39;d really prefer to return the base class.<br>&gt;&gt; <br>&gt;&gt; To mitigate these issues, I&#39;d like to float the idea that protocol conformances *not be* inherited by default.<br>&gt; <br>&gt; I don&#39;t like it. <br>&gt; <br>&gt; The problems in the motivating examples all center around protocols with factory methods or other uses of Self. Changing the behavior of all protocols seems like the wrong tool to solve that problem. There must be a narrower solution that improves those cases without changing so much existing code and understanding. (Are there any other languages with similar behavior?)<br></p><p>The change in inheritance behavior could be constrained to only protocols with factory or initializer requirements, since it makes no difference whether the conformance is inherited if there are no covariant uses of Self in the protocol.<br></p><p>&gt; <br>&gt; The &quot;NSCoding is annoying&quot; example is particularly dangerous. Historically the alternatives have been:<br>&gt; <br>&gt; * Don&#39;t require subclasses to implement init(coder:). This leads to difficult bugs where a subclass does not implement init(coder:) but somebody tries to encode and decode an instance of it. There are no compile-time errors, no runtime errors, and the resulting decoded object is corrupt.<br>&gt; <br>&gt; * Require subclasses to implement init(coder:), even if all it does is abort(). This provides good runtime diagnostics against the bug above, at the cost of some subclass boilerplate. This is what Swift does, and what ObjC now does with the new designated initializer enforcement.<br>&gt; <br>&gt; I fear that non-inherited protocols will reintroduce the old bugs. The subclasses will not be required to implement init(coder:), and encoding and decoding an instance of such a class will do corrupt things at runtime with no runtime diagnostics.<br></p><p>You&#39;re right, NSCoding is probably a legitimate example of a case where some class hierarchies should enforce refinement by subclasses. Even here, though, there are class hierarchies where a common NSCoding implementation would be appropriate. Do NSString or NSArray subclasses usually provide their own NSCoding implementation?<br></p><p>-Joe<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Making protocol conformance inheritance controllable</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>December 14, 2015 at 09:00:00pm</p></header><div class="content"><p>I still don’t understand what this proposal is actually proposing in cases like this:<br></p><p>class Root {}<br>class ImplementerOfA : Root, ProtocolA {}<br>class ImplementerOfB : ImplementerOfA, ProtocolB {}<br>class Base : ImplementerOfB {}<br></p><p>func exampleFunction&lt;<br>  T:Base<br>  where<br>  T:ProtocolA,<br>  T:ProtocolB&gt;(target: T) -&gt; Whatever<br></p><p>…if I have this:<br></p><p>class CustomizedBase : Base {}<br></p><p>…what is supposed to happen if I try to write this:<br></p><p>let whatever = exampleFunction(CustomizedBase())<br></p><p>...?<br></p><p>If I understand the logic in the proposal, it seems like I *can’t* call `exampleFunction` here with `CustomizedBase`:<br></p><p>- it can’t be `CustomizedBase` b/c it doesn’t (re)implement `ProtocolA` or `ProtocolB`<br>- it can’t be `Base` b/c it doesn’t (re)implement `ProtocolA` or `ProtocolB`<br></p><p>…and even if we change it to this: <br></p><p>func exampleFunction&lt;<br>  T:Root<br>  where<br>  T:ProtocolA,<br>  T:ProtocolB&gt;(target: T) -&gt; Whatever<br></p><p>…then we still can’t call it with `CustomizedBase`, since:<br></p><p>- it can’t be `CustomizedBase` b/c it doesn’t (re)implement `ProtocolA` or `ProtocolB`<br>- it can’t be `Base` b/c it doesn’t (re)implement `ProtocolA` or `ProtocolB`<br>- it can’t be `ImplementerOfB` b/c it doesn’t (re)implement `ProtocolA` <br>- it can’t be `ImplementerOfA` b/c it doesn’t implement `ProtocolB` <br>- it can’t be `Root` b/c it doesn’t implement `ProtocolA` or `ProtocolB` <br></p><p>…so we can’t make this call, no?<br></p><p>Am I missing something obvious in either example? If so, which type would get matched (in either example)?<br></p><p>&gt; On Dec 14, 2015, at 8:08 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; At first this didn&#39;t make any sense to me. Now it makes some kind of twisted sense, and I&#39;m working my way through the details:<br>&gt; <br>&gt; protocol Proto { /*…*/ }<br>&gt; class Base : Proto { /*…*/ }<br>&gt; class Subclass : Base {}<br>&gt; <br>&gt; - Protocols with no initializer requirements and no use of &#39;Self&#39; are trivially safe here, because there&#39;s no way to recover the original type.<br>&gt; <br>&gt; - Methods returning &#39;Self&#39; will silently return the base type. This is often reasonable, but it&#39;s still a little weird. There&#39;s also no way to have a protocol that requires dynamic-self behavior for a factory method.<br>&gt; <br>&gt; Subclass.createViaProtocol() // produces a Base<br>&gt; <br>&gt; - Initializers are not guaranteed to be inherited. That&#39;s not weird for Swift. It&#39;s a little weird for Objective-C, but we already emit placeholders for non-inherited initializers to produce a runtime failure, which is what most NSCoder-bemoaners want anyway.<br>&gt; <br>&gt; - Methods taking &#39;Self&#39; will silently accept the base type. If you override a conformance, you have to continue accepting the base type for these requirements, but that&#39;s just normal override rules.<br>&gt; <br>&gt; - Overriding a conformance still doesn&#39;t let you change the associated types, even covariantly, because extensions to the base type may have used them in new positions. (Alternately, associated types and generic parameters are still invariant and we&#39;d need a language feature to make them non-invariant.)<br>&gt; <br>&gt; - Generic constraints will have to be taught to infer the base type.<br>&gt; <br>&gt; foo(Subclass()) // calls foo&lt;Base&gt;(Subclass())<br>&gt; let obj: Subclass = bar() // error, because bar&lt;Base&gt;() will return a Base<br>&gt; <br>&gt; - What does &quot;subclass is Proto&quot; do? What does &quot;Subclass.self is Proto.Type&quot; do? What does &quot;Subclasses.instancesConformToProtocol(Proto.self)&quot; do? My guess is &#39;true&#39; for all three even though it&#39;s not exactly correct for Objective-C protocols with initializer requirements, but then what&#39;s the query that returns &#39;false&#39;?<br>&gt; <br>&gt; - Given all this, what benefit does required conformance bring? Just shorthand for making all the initializers required? (Which may be important if you got some of them through protocol extensions.)<br>&gt; <br>&gt; Gosh. Maybe we can do it.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 18:04, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve had a number of twitter conversations with users who have valiantly fought our type system and lost when trying to make their protocols interact well with non-final classes. A few from recent memory:<br>&gt;&gt; <br>&gt;&gt; - Rob Napier struggling to implement a `copy` method that works well with subclasses: https://twitter.com/cocoaphony/status/660914612850843648 &lt;https://twitter.com/cocoaphony/status/660914612850843648&gt;<br>&gt;&gt; and making the observation that the interaction of protocol conformance and subtyping is very difficult to teach.<br>&gt;&gt; <br>&gt;&gt; - Matt Bischoff trying to make Cocoa class clusters retroactively conform to his factory protocol:<br>&gt;&gt; https://twitter.com/anandabits/status/664294382774849536 &lt;https://twitter.com/anandabits/status/664294382774849536&gt;<br>&gt;&gt; <br>&gt;&gt; and Karl Adam trying to do the same:<br>&gt;&gt; https://gist.github.com/thekarladam/c3094769cc8c87bf55e3 &lt;https://gist.github.com/thekarladam/c3094769cc8c87bf55e3&gt;<br>&gt;&gt; <br>&gt;&gt; These problems stem from the way protocol conformances currently interact with class inheritance—specifically, that if a class conforms to a protocol, then all of its possible derived classes also conform. This seems like the obvious way things should be, but in practice it ends up fighting how many classes are intended to be used. Often only a base class is intended to be the public interface, and derived classes are only implementation details—Cocoa class clusters are a great example of this. The inheritance of protocol conformances also imposes a bunch of knock-on complexity on conforming classes—initializer requirements must be satisfied by `required` initializers (which then must be overridden in all derived classes, to the pain of anyone touching an NSCoding-inherited class), and methods often must return dynamic `Self` when they&#39;d really prefer to return the base class.<br>&gt;&gt; <br>&gt;&gt; To mitigate these issues, I&#39;d like to float the idea that protocol conformances *not be* inherited by default. If you declare a class as conforming to a protocol, only exactly that class can be bound to a type parameter constrained by that protocol:<br>&gt;&gt; <br>&gt;&gt; protocol Runcible {}<br>&gt;&gt; class A: Runcible { }<br>&gt;&gt; class B { }<br>&gt;&gt; <br>&gt;&gt; func foo&lt;T: Runcible&gt;(x: T) {}<br>&gt;&gt; <br>&gt;&gt; foo(B()) // calls foo with T == A<br>&gt;&gt; <br>&gt;&gt; Since subclasses are still subtypes of the base class, in many cases client code won&#39;t have to change at all, since derived instances can implicitly upconvert to their conforming base class when used in protocol types or generics that only the base class conforms to. (There are cases like if the type parameter appears in a NonCovariant&lt;T&gt; type where this isn&#39;t possible, though.) Protocol requirements for a non-inherited conformance don&#39;t need to be `required` initializers, or maintain covariant returns:<br>&gt;&gt; <br>&gt;&gt; protocol Fungible {<br>&gt;&gt;   init()<br>&gt;&gt;   static func funged() -&gt; Self<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class C: Fungible {<br>&gt;&gt;   init() {} // Non-required init is fine, since subclasses aren&#39;t directly Fungible<br>&gt;&gt; <br>&gt;&gt;   // Non-Self return is fine too<br>&gt;&gt;   class func funged() -&gt; C { return C() }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; An individual subclass that wanted to refine the conformance could do so by `override`-ing it, and providing any necessary covariant overrides of initializers and methods:<br>&gt;&gt; <br>&gt;&gt; class D: C, override Fungible {<br>&gt;&gt;   // D must provide its own init()<br>&gt;&gt;   init() { super.init() }<br>&gt;&gt; <br>&gt;&gt;   // D must override funged() to return D instead of C<br>&gt;&gt;   override class func funged() -&gt; D { return D() }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; And if a class hierarchy really wants to impose a conformance on all possible subclasses, as happens today, we could let you opt in to that:<br>&gt;&gt; <br>&gt;&gt; class E: required Fungible {<br>&gt;&gt;   // init() must be required of all subclasses<br>&gt;&gt;   required init() { }<br>&gt;&gt; <br>&gt;&gt;   // funged() must return a covariant object<br>&gt;&gt;   class func funged() -&gt; Self { return Self() }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This is undoubtedly a complication of the language, but I think it might let us more accurately model a lot of things people seem to want to do in practice with class hierarchies and protocols, and it simplifies the behavior of the arguably common case where inheritance of the conformance isn&#39;t desired. What do you all think?<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/d6cf7621/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Making protocol conformance inheritance controllable</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 15, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 14, 2015, at 7:21 PM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I still don’t understand what this proposal is actually proposing in cases like this:<br>&gt; <br>&gt; class Root {}<br>&gt; class ImplementerOfA : Root, ProtocolA {}<br>&gt; class ImplementerOfB : ImplementerOfA, ProtocolB {}<br>&gt; class Base : ImplementerOfB {}<br>&gt; <br>&gt; func exampleFunction&lt;<br>&gt;   T:Base<br>&gt;   where<br>&gt;   T:ProtocolA,<br>&gt;   T:ProtocolB&gt;(target: T) -&gt; Whatever<br>&gt; <br>&gt; …if I have this:<br>&gt; <br>&gt; class CustomizedBase : Base {}<br>&gt; <br>&gt; …what is supposed to happen if I try to write this:<br>&gt; <br>&gt; let whatever = exampleFunction(CustomizedBase())<br>&gt; <br>&gt; ...?<br>&gt; <br>&gt; If I understand the logic in the proposal, it seems like I *can’t* call `exampleFunction` here with `CustomizedBase`:<br>&gt; <br>&gt; - it can’t be `CustomizedBase` b/c it doesn’t (re)implement `ProtocolA` or `ProtocolB`<br>&gt; - it can’t be `Base` b/c it doesn’t (re)implement `ProtocolA` or `ProtocolB`<br>&gt; <br>&gt; …and even if we change it to this: <br>&gt; <br>&gt; func exampleFunction&lt;<br>&gt;   T:Root<br>&gt;   where<br>&gt;   T:ProtocolA,<br>&gt;   T:ProtocolB&gt;(target: T) -&gt; Whatever<br>&gt; <br>&gt; …then we still can’t call it with `CustomizedBase`, since:<br>&gt; <br>&gt; - it can’t be `CustomizedBase` b/c it doesn’t (re)implement `ProtocolA` or `ProtocolB`<br>&gt; - it can’t be `Base` b/c it doesn’t (re)implement `ProtocolA` or `ProtocolB`<br>&gt; - it can’t be `ImplementerOfB` b/c it doesn’t (re)implement `ProtocolA` <br>&gt; - it can’t be `ImplementerOfA` b/c it doesn’t implement `ProtocolB` <br>&gt; - it can’t be `Root` b/c it doesn’t implement `ProtocolA` or `ProtocolB` <br>&gt; <br>&gt; …so we can’t make this call, no?<br>&gt; <br>&gt; Am I missing something obvious in either example? If so, which type would get matched (in either example)?<br></p><p>You are correct that cases like this simply wouldn&#39;t work, without ImplementerOfB explicitly refining the conformance of ProtocolA.<br></p><p>-Joe<br></p><p>&gt; <br>&gt;&gt; On Dec 14, 2015, at 8:08 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; At first this didn&#39;t make any sense to me. Now it makes some kind of twisted sense, and I&#39;m working my way through the details:<br>&gt;&gt; <br>&gt;&gt; protocol Proto { /*…*/ }<br>&gt;&gt; class Base : Proto { /*…*/ }<br>&gt;&gt; class Subclass : Base {}<br>&gt;&gt; <br>&gt;&gt; - Protocols with no initializer requirements and no use of &#39;Self&#39; are trivially safe here, because there&#39;s no way to recover the original type.<br>&gt;&gt; <br>&gt;&gt; - Methods returning &#39;Self&#39; will silently return the base type. This is often reasonable, but it&#39;s still a little weird. There&#39;s also no way to have a protocol that requires dynamic-self behavior for a factory method.<br>&gt;&gt; <br>&gt;&gt; Subclass.createViaProtocol() // produces a Base<br>&gt;&gt; <br>&gt;&gt; - Initializers are not guaranteed to be inherited. That&#39;s not weird for Swift. It&#39;s a little weird for Objective-C, but we already emit placeholders for non-inherited initializers to produce a runtime failure, which is what most NSCoder-bemoaners want anyway.<br>&gt;&gt; <br>&gt;&gt; - Methods taking &#39;Self&#39; will silently accept the base type. If you override a conformance, you have to continue accepting the base type for these requirements, but that&#39;s just normal override rules.<br>&gt;&gt; <br>&gt;&gt; - Overriding a conformance still doesn&#39;t let you change the associated types, even covariantly, because extensions to the base type may have used them in new positions. (Alternately, associated types and generic parameters are still invariant and we&#39;d need a language feature to make them non-invariant.)<br>&gt;&gt; <br>&gt;&gt; - Generic constraints will have to be taught to infer the base type.<br>&gt;&gt; <br>&gt;&gt; foo(Subclass()) // calls foo&lt;Base&gt;(Subclass())<br>&gt;&gt; let obj: Subclass = bar() // error, because bar&lt;Base&gt;() will return a Base<br>&gt;&gt; <br>&gt;&gt; - What does &quot;subclass is Proto&quot; do? What does &quot;Subclass.self is Proto.Type&quot; do? What does &quot;Subclasses.instancesConformToProtocol(Proto.self)&quot; do? My guess is &#39;true&#39; for all three even though it&#39;s not exactly correct for Objective-C protocols with initializer requirements, but then what&#39;s the query that returns &#39;false&#39;?<br>&gt;&gt; <br>&gt;&gt; - Given all this, what benefit does required conformance bring? Just shorthand for making all the initializers required? (Which may be important if you got some of them through protocol extensions.)<br>&gt;&gt; <br>&gt;&gt; Gosh. Maybe we can do it.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 18:04, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve had a number of twitter conversations with users who have valiantly fought our type system and lost when trying to make their protocols interact well with non-final classes. A few from recent memory:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Rob Napier struggling to implement a `copy` method that works well with subclasses: https://twitter.com/cocoaphony/status/660914612850843648 &lt;https://twitter.com/cocoaphony/status/660914612850843648&gt;<br>&gt;&gt;&gt; and making the observation that the interaction of protocol conformance and subtyping is very difficult to teach.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Matt Bischoff trying to make Cocoa class clusters retroactively conform to his factory protocol:<br>&gt;&gt;&gt; https://twitter.com/anandabits/status/664294382774849536 &lt;https://twitter.com/anandabits/status/664294382774849536&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and Karl Adam trying to do the same:<br>&gt;&gt;&gt; https://gist.github.com/thekarladam/c3094769cc8c87bf55e3 &lt;https://gist.github.com/thekarladam/c3094769cc8c87bf55e3&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These problems stem from the way protocol conformances currently interact with class inheritance—specifically, that if a class conforms to a protocol, then all of its possible derived classes also conform. This seems like the obvious way things should be, but in practice it ends up fighting how many classes are intended to be used. Often only a base class is intended to be the public interface, and derived classes are only implementation details—Cocoa class clusters are a great example of this. The inheritance of protocol conformances also imposes a bunch of knock-on complexity on conforming classes—initializer requirements must be satisfied by `required` initializers (which then must be overridden in all derived classes, to the pain of anyone touching an NSCoding-inherited class), and methods often must return dynamic `Self` when they&#39;d really prefer to return the base class.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To mitigate these issues, I&#39;d like to float the idea that protocol conformances *not be* inherited by default. If you declare a class as conforming to a protocol, only exactly that class can be bound to a type parameter constrained by that protocol:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Runcible {}<br>&gt;&gt;&gt; class A: Runcible { }<br>&gt;&gt;&gt; class B { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo&lt;T: Runcible&gt;(x: T) {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; foo(B()) // calls foo with T == A<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since subclasses are still subtypes of the base class, in many cases client code won&#39;t have to change at all, since derived instances can implicitly upconvert to their conforming base class when used in protocol types or generics that only the base class conforms to. (There are cases like if the type parameter appears in a NonCovariant&lt;T&gt; type where this isn&#39;t possible, though.) Protocol requirements for a non-inherited conformance don&#39;t need to be `required` initializers, or maintain covariant returns:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Fungible {<br>&gt;&gt;&gt;   init()<br>&gt;&gt;&gt;   static func funged() -&gt; Self<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class C: Fungible {<br>&gt;&gt;&gt;   init() {} // Non-required init is fine, since subclasses aren&#39;t directly Fungible<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // Non-Self return is fine too<br>&gt;&gt;&gt;   class func funged() -&gt; C { return C() }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An individual subclass that wanted to refine the conformance could do so by `override`-ing it, and providing any necessary covariant overrides of initializers and methods:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class D: C, override Fungible {<br>&gt;&gt;&gt;   // D must provide its own init()<br>&gt;&gt;&gt;   init() { super.init() }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // D must override funged() to return D instead of C<br>&gt;&gt;&gt;   override class func funged() -&gt; D { return D() }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And if a class hierarchy really wants to impose a conformance on all possible subclasses, as happens today, we could let you opt in to that:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class E: required Fungible {<br>&gt;&gt;&gt;   // init() must be required of all subclasses<br>&gt;&gt;&gt;   required init() { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // funged() must return a covariant object<br>&gt;&gt;&gt;   class func funged() -&gt; Self { return Self() }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is undoubtedly a complication of the language, but I think it might let us more accurately model a lot of things people seem to want to do in practice with class hierarchies and protocols, and it simplifies the behavior of the arguably common case where inheritance of the conformance isn&#39;t desired. What do you all think?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/8446c5d6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
