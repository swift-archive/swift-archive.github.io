<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft] Automatically deriving Equatable and Hashable for certain value types</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 26, 2016 at 11:00:00am</p></header><div class="content"><p>on Wed May 25 2016, Tony Allevato &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I was inspired to put together a draft proposal based on an older discussion in<br>&gt; the Universal Equality, Hashability, and Comparability thread<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/8919/&gt; that recently<br>&gt; got necromanced (thanks Mark Sands!).<br>&gt;<br>&gt; I&#39;m guessing that this would be a significant enough change that it&#39;s not<br>&gt; possible for the Swift 3 timeline, but it&#39;s something that would benefit enough<br>&gt; people that I want to make sure the discussion stays alive. If there are enough<br>&gt; good feelings about it, I&#39;ll move it from my gist into an actual<br>&gt; proposal PR.<br></p><p>Hi Tony,<br></p><p>As you might imagine I&#39;m intensely interested in this topic and I have<br>some strongly held views.  That said, since it&#39;s out of scope for Swift<br>3, you shouldn&#39;t expect too much participation from me  at this point.<br></p><p>&gt;<br>&gt;<br>&gt; Automatically deriving Equatable andHashable for value types<br>&gt;<br>&gt; * Proposal: SE-0000<br>&gt; * Author(s): Tony Allevato<br>&gt; * Status: Awaiting review<br>&gt; * Review manager: TBD<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Value types are prevalent throughout the Swift language, and we encourage<br>&gt; developers to think in those terms when writing their own types. Frequently,<br>&gt; developers find themselves writing large amounts of boilerplate code to support<br>&gt; equatability and hashability of value types. This proposal offers a way for the<br>&gt; compiler to automatically derive conformance toEquatable and Hashable to reduce<br>&gt; this boilerplate, in a subset of scenarios where generating the correct<br>&gt; implementation is likely to be possible.<br>&gt;<br>&gt; Swift-evolution thread: Universal Equatability, Hashability, and Comparability<br>&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Building robust value types in Swift can involve writing significant boilerplate<br>&gt; code to support concepts of hashability and equatability. Equality is pervasive<br>&gt; across many value types, and for each one users must implement the == operator<br>&gt; such that it performs a fairly rote memberwise equality test. As an example, an<br>&gt; equality test for a struct looks fairly uninteresting:<br>&gt;<br>&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;   return lhs.property1 == rhs.property1 &amp;&amp;<br>&gt;          lhs.property2 == rhs.property2 &amp;&amp;<br>&gt;          lhs.property3 == rhs.property3 &amp;&amp;<br>&gt;          ...<br>&gt; }<br>&gt;<br>&gt; What&#39;s worse is that this operator must be updated if any properties are added,<br>&gt; removed, or changed, and since it must be manually written, it&#39;s possible to get<br>&gt; it wrong, either by omission or typographical error.<br>&gt;<br>&gt; Likewise, hashability is necessary when one wishes to store a value type in a<br>&gt; Set or use one as a multi-valuedDictionary key. Writing high-quality,<br>&gt; well-distributed hash functions is not trivial so developers may not put a great<br>&gt; deal of thought into them – especially as the number of properties increases –<br>&gt; not realizing that their performance could potentially suffer as a result. And<br>&gt; as with equality, writing it manually means there is the potential to get it<br>&gt; wrong.<br>&gt;<br>&gt; In particular, the code that must be written to implement equality for enums is<br>&gt; quite verbose. One such real-world example (source):<br>&gt;<br>&gt; func ==(lhs: HandRank, rhs: HandRank) -&gt; Bool {<br>&gt;   switch (lhs, rhs) {<br>&gt;   case (.straightFlush(let lRank, let lSuit), .straightFlush(let rRank , let rSuit)):<br>&gt;     return lRank == rRank &amp;&amp; lSuit == rSuit<br>&gt;   case (.fourOfAKind(four: let lFour), .fourOfAKind(four: let rFour)):<br>&gt;     return lFour == rFour<br>&gt;   case (.fullHouse(three: let lThree), .fullHouse(three: let rThree)):<br>&gt;     return lThree == rThree<br>&gt;   case (.flush(let lRank, let lSuit), .flush(let rRank, let rSuit)):<br>&gt;     return lSuit == rSuit &amp;&amp; lRank == rRank<br>&gt;   case (.straight(high: let lRank), .straight(high: let rRank)):<br>&gt;     return lRank == rRank<br>&gt;   case (.threeOfAKind(three: let lRank), .threeOfAKind(three: let rRank)):<br>&gt;     return lRank == rRank<br>&gt;   case (.twoPair(high: let lHigh, low: let lLow, highCard: let lCard),<br>&gt;         .twoPair(high: let rHigh, low: let rLow, highCard: let rCard)):<br>&gt;     return lHigh == rHigh &amp;&amp; lLow == rLow &amp;&amp; lCard == rCard<br>&gt;   case (.onePair(let lPairRank, card1: let lCard1, card2: let lCard2, card3: let lCard3),<br>&gt;         .onePair(let rPairRank, card1: let rCard1, card2: let rCard2, card3: let rCard3)):<br>&gt;     return lPairRank == rPairRank &amp;&amp; lCard1 == rCard1 &amp;&amp; lCard2 == rCard2 &amp;&amp; lCard3 == rCard3<br>&gt;   case (.highCard(let lCard), .highCard(let rCard)):<br>&gt;     return lCard == rCard<br>&gt;   default:<br>&gt;     return false<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; Crafting a high-quality hash function for this enum would be similarly<br>&gt; inconvenient to write, involving another large switchstatement.<br>&gt;<br>&gt; Swift already provides implicit protocol conformance in some cases; notably,<br>&gt; enums with raw values conform toRawRepresentable, Equatable, and Hashable<br>&gt; without the user explicitly declaring them:<br>&gt;<br>&gt; enum Foo: Int {<br>&gt;   case one = 1<br>&gt;   case two = 2<br>&gt; }<br>&gt;<br>&gt; let x = (Foo.one == Foo.two)  // works<br>&gt; let y = Foo.one.hashValue     // also works<br>&gt; let z = Foo.one.rawValue      // also also works<br>&gt;<br>&gt; Since there is precedent for this in Swift, we propose extending this support to<br>&gt; more value types.<br>&gt;<br>&gt; Proposed solution<br>&gt;<br>&gt; We propose that a value type be Equatable/Hashable if all of its members are<br>&gt; Equatable/Hashable, with the result for the outer type being composed from its<br>&gt; members.<br>&gt;<br>&gt; Specifically, we propose the following rules for deriving Equatable:<br>&gt;<br>&gt; *   A struct implicitly conforms to Equatable if all of its fields are of types<br>&gt;   that conform to Equatable – either explicitly, or implicitly by the<br>&gt;   application of these rules. The compiler will generate an implementation of ==<br>&gt;   (lhs: T, rhs: T)that returns true if and only if lhs.x == rhs.x for all fields<br>&gt;   x in T.<br>&gt;<br>&gt; *   An enum implicitly conforms to Equatable if all of its associated values<br>&gt;   across all of its cases are of types that conform to Equatable – either<br>&gt;   explicitly, or implicitly by the application of these rules. The compiler will<br>&gt;   generate an implementation of ==(lhs: T, rhs: T) that returns true if and only<br>&gt;   if lhs and rhs are the same case and have payloads that are memberwise-equal.<br>&gt;<br>&gt; Likewise, we propose the following rules for deriving Hashable:<br>&gt;<br>&gt; *   A struct implicitly conforms to Hashable if all of its fields are of types<br>&gt;   that conform to Hashable – either explicitly, or implicitly by the application<br>&gt;   of these rules. The compiler will generate an implementation of hashValue that<br>&gt;   uses a pre-defined hash function† to compute the hash value of the struct from<br>&gt;   the hash values of its members.<br>&gt;<br>&gt;   Since order of the terms affects the hash value computation, we recommend<br>&gt;   ordering the terms in member definition order.<br>&gt;<br>&gt; *   An enum implicitly conforms to Hashable if all of its associated values<br>&gt;   across all of its cases are of types that conform to Hashable – either<br>&gt;   explicitly, or implicitly by the application of these rules. The compiler will<br>&gt;   generate an implementation of hashValue that uses a pre-defined hash function†<br>&gt;   to compute the hash value of an enum value by using the case&#39;s ordinal (i.e.,<br>&gt;   definition order) followed by the hash values of its associated values as its<br>&gt;   terms, also in definition order.<br>&gt;<br>&gt; † We leave the exact definition of the hash function unspecified here; a<br>&gt; multiplicative hash function such as Kernighan and Ritchie or Bernstein is easy<br>&gt; to implement, but we do not rule out other possibilities.<br>&gt;<br>&gt; Overriding defaults<br>&gt;<br>&gt; Any user-provided implementations of == or hashValue should override the default<br>&gt; implementations that would be provided by the compiler. This is already possible<br>&gt; today with raw-value enums so the same behavior should be extended to other<br>&gt; value types that are made to implicitly conform to these protocols.<br>&gt;<br>&gt; Open questions<br>&gt;<br>&gt; Omission of fields from generated computations<br>&gt;<br>&gt; Should it be possible to easily omit certain properties from automatically<br>&gt; generated equality tests or hash value computation? This could be valuable, for<br>&gt; example, if a property is merely used as an internal cache and does not actually<br>&gt; contribute to the &quot;value&quot; of the instance. Under the rules above, if this cached<br>&gt; value was equatable, a user would have to override == and hashValue and provide<br>&gt; their own implementations to ignore it. If there is significant evidence that<br>&gt; this pattern is common and useful, we could consider adding a custom attribute,<br>&gt; such as @transient, that would omit the property from the generated<br>&gt; computations.<br>&gt;<br>&gt; Explicit or implicit derivation<br>&gt;<br>&gt; As with raw-value enums today, should the derived conformance be completely<br>&gt; explicit, or should users have to explicitly list conformance with Equatable and<br>&gt; Hashable in order for the compiler to generate the derived implementation?<br>&gt;<br>&gt; Impact on existing code<br>&gt;<br>&gt; This change will have no impact on existing code because it is purely additive.<br>&gt; Value types that already provide custom implementations of == or hashValue but<br>&gt; satisfy the rules above would keep the custom implementation because it would<br>&gt; override the compiler-provided default.<br>&gt;<br>&gt; Alternatives considered<br>&gt;<br>&gt; The original discussion thread also included Comparable as a candidate for<br>&gt; automatic generation. Unlike equatability and hashability, however,<br>&gt; comparability requires an ordering among the members being compared.<br>&gt; Automatically using the definition order here might be too surprising for users,<br>&gt; but worse, it also means that reordering properties in the source code changes<br>&gt; the code&#39;s behavior at runtime. (This is true for hashability as well if a<br>&gt; multiplicative hash function is used, but hash values are not intended to be<br>&gt; persistent and reordering the terms does not produce a significant behavioral<br>&gt; change.)<br>&gt;<br>&gt; Acknowledgments<br>&gt;<br>&gt; Thanks to Joe Groff for spinning off the original discussion thread, Jose Cheyo<br>&gt; Jimenez for providing great real-world examples of boilerplate needed to support<br>&gt; equatability for some value types, and to Mark Sands for necromancing the<br>&gt; swift-evolution thread that convinced me to write this up.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
