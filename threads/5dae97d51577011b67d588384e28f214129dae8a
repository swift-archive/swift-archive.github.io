<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d8cb5ce1e8a83d826650c91466c7800?s=50"></div><header><strong>Anoymous Enums (Updated)</strong> from <string>Yong hee Lee</string> &lt;yonghee226 at gmail.com&gt;<p>February 22, 2016 at 03:00:00pm</p></header><div class="content"><p>please check the link below.<br></p><p>https://gist.github.com/erica/9148e2be916c7fae6f1e &lt;https://gist.github.com/erica/9148e2be916c7fae6f1e&gt;<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160222/5daeae8a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Anoymous Enums (Updated)</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>February 22, 2016 at 11:00:00am</p></header><div class="content"><p>I&#39;m not sure wether I want to see that feature added, but I think there is a &quot;structural&quot; argument for it:<br>We have anonymous functions (closures) and a (restricted) form of anonymous structs (tuples), so it would be consequent to have a anonymous variant for each fundamental entity in the language.<br>I guess it is to late to establish a unified syntax for all of those, though…<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Anoymous Enums (Updated)</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 22, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Feb 22, 2016, at 3:53 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m not sure wether I want to see that feature added, but I think there is a &quot;structural&quot; argument for it:<br>&gt; We have anonymous functions (closures) and a (restricted) form of anonymous structs (tuples), so it would be consequent to have a anonymous variant for each fundamental entity in the language.<br>&gt; I guess it is to late to establish a unified syntax for all of those, though…<br></p><p>I like the symmetry with the other anonymous types. This provides a highly focused tweak to Swift, with limited impact, and a measurable benefit to developers. (AKA the &quot;Rule of Lattner&quot;)<br></p><p>Further, the values cannot be assigned to variables or passed as arguments as they have no &quot;type&quot;.  I suspect it won&#39;t be hard to restrict them for being used with `Any` argument, limiting their use to flags and switch cases. If I&#39;m conceptualizing this correctly, the benefits are clear and the consequences are small.<br></p><p>-- Erica<br></p><p>&gt; On Feb 21, 2016, at 11:52 PM, Yong hee Lee via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; please check the link below.<br>&gt; <br>&gt; https://gist.github.com/erica/9148e2be916c7fae6f1e &lt;https://gist.github.com/erica/9148e2be916c7fae6f1e&gt;<br>&gt; <br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160222/4e59a30c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Anoymous Enums (Updated)</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>February 22, 2016 at 10:00:00am</p></header><div class="content"><p>Having this work similar to other anonymous types would be an extension to the proposal. <br></p><p>Other anonymous types can be considered equivalent by their definitions, e.g. (x:Int, y:Int) taken as input from one function can be passed to another. <br></p><p>E.g. your adjustTemperature function wanted to call a checkSafety(device:DeviceType, [low | medium | high]:temperature) -&gt; Bool function - could it?<br></p><p>what about if adjustTemperature took [low | medium | high | extreme]?<br></p><p>what about adjustTemperature having an internal var lastAdjustment:[low | medium | high] - would that work?<br></p><p>My concern is that there could many reasons to need to switch from shorthand/anonymous syntax to a full enum, and that switch will have the same fragility as changing a function from accepting a tuple to accepting a struct. If passing to another function or assigning to a variable would require a switch to a properly qualified enum, the feature seems not worth its character savings.<br></p><p>And I’m already unsure it is worth its existing character savings, especially once you start documenting the meaning of low / medium / high for other developers, and especially if you now have to do so for multiple functions rather than a single enum declaration.<br></p><p>-DW<br></p><p>&gt; On Feb 22, 2016, at 9:46 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 22, 2016, at 3:53 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure wether I want to see that feature added, but I think there is a &quot;structural&quot; argument for it:<br>&gt;&gt; We have anonymous functions (closures) and a (restricted) form of anonymous structs (tuples), so it would be consequent to have a anonymous variant for each fundamental entity in the language.<br>&gt;&gt; I guess it is to late to establish a unified syntax for all of those, though…<br>&gt; <br>&gt; I like the symmetry with the other anonymous types. This provides a highly focused tweak to Swift, with limited impact, and a measurable benefit to developers. (AKA the &quot;Rule of Lattner&quot;)<br>&gt; <br>&gt; Further, the values cannot be assigned to variables or passed as arguments as they have no &quot;type&quot;.  I suspect it won&#39;t be hard to restrict them for being used with `Any` argument, limiting their use to flags and switch cases. If I&#39;m conceptualizing this correctly, the benefits are clear and the consequences are small.<br>&gt; <br>&gt; -- Erica<br>&gt; <br>&gt;&gt; On Feb 21, 2016, at 11:52 PM, Yong hee Lee via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; please check the link below.<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/erica/9148e2be916c7fae6f1e &lt;https://gist.github.com/erica/9148e2be916c7fae6f1e&gt;<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160222/82e9e35d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Anoymous Enums (Updated)</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>February 22, 2016 at 05:00:00pm</p></header><div class="content"><p>I have similar concerns as David. I do like the idea but I see it becoming<br>a problem in not a typical usage as David outlined. You likely would never<br>want to use this in any public API or possibly any function signature for<br>that matter (again given the limits implied by the short hand). I see it<br>being useful in a given scope of code for the purpose of readability and<br>even safety. It is when it starts to escape that scope it become less<br>useful and possibly unsafe.<br></p><p>On Mon, Feb 22, 2016 at 9:12 AM David Waite via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Having this work similar to other anonymous types would be an extension to<br>&gt; the proposal.<br>&gt;<br>&gt; Other anonymous types can be considered equivalent by their definitions,<br>&gt; e.g. (x:Int, y:Int) taken as input from one function can be passed to<br>&gt; another.<br>&gt;<br>&gt; E.g. your adjustTemperature function wanted to call a<br>&gt; checkSafety(device:DeviceType, [low | medium | high]:temperature) -&gt; Bool<br>&gt; function - could it?<br>&gt;<br>&gt; what about if adjustTemperature took [low | medium | high | extreme]?<br>&gt;<br>&gt; what about adjustTemperature having an internal var lastAdjustment:[low |<br>&gt; medium | high] - would that work?<br>&gt;<br>&gt; My concern is that there could many reasons to need to switch from<br>&gt; shorthand/anonymous syntax to a full enum, and that switch will have the<br>&gt; same fragility as changing a function from accepting a tuple to accepting a<br>&gt; struct. If passing to another function or assigning to a variable would<br>&gt; require a switch to a properly qualified enum, the feature seems not worth<br>&gt; its character savings.<br>&gt;<br>&gt; And I’m already unsure it is worth its existing character savings,<br>&gt; especially once you start documenting the meaning of low / medium / high<br>&gt; for other developers, and especially if you now have to do so for multiple<br>&gt; functions rather than a single enum declaration.<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt; On Feb 22, 2016, at 9:46 AM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Feb 22, 2016, at 3:53 AM, Tino Heth via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I&#39;m not sure wether I want to see that feature added, but I think there is<br>&gt; a &quot;structural&quot; argument for it:<br>&gt; We have anonymous functions (closures) and a (restricted) form of<br>&gt; anonymous structs (tuples), so it would be consequent to have a anonymous<br>&gt; variant for each fundamental entity in the language.<br>&gt; I guess it is to late to establish a unified syntax for all of those,<br>&gt; though…<br>&gt;<br>&gt;<br>&gt; I like the symmetry with the other anonymous types. This provides a highly<br>&gt; focused tweak to Swift, with limited impact, and a measurable benefit to<br>&gt; developers. (AKA the &quot;Rule of Lattner&quot;)<br>&gt;<br>&gt; Further, the values cannot be assigned to variables or passed as arguments<br>&gt; as they have no &quot;type&quot;.  I suspect it won&#39;t be hard to restrict them for<br>&gt; being used with `Any` argument, limiting their use to flags and switch<br>&gt; cases. If I&#39;m conceptualizing this correctly, the benefits are clear and<br>&gt; the consequences are small.<br>&gt;<br>&gt; -- Erica<br>&gt;<br>&gt; On Feb 21, 2016, at 11:52 PM, Yong hee Lee via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; please check the link below.<br>&gt;<br>&gt; https://gist.github.com/erica/9148e2be916c7fae6f1e<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160222/4f2f8d9e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Anoymous Enums (Updated)</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 22, 2016 at 10:00:00am</p></header><div class="content"><p>Under what circumstances could these ever escape scope?<br></p><p>-- E<br></p><p>&gt; On Feb 22, 2016, at 10:20 AM, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt; <br>&gt; I have similar concerns as David. I do like the idea but I see it becoming a problem in not a typical usage as David outlined. You likely would never want to use this in any public API or possibly any function signature for that matter (again given the limits implied by the short hand). I see it being useful in a given scope of code for the purpose of readability and even safety. It is when it starts to escape that scope it become less useful and possibly unsafe.<br>&gt; <br>&gt; On Mon, Feb 22, 2016 at 9:12 AM David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Having this work similar to other anonymous types would be an extension to the proposal. <br>&gt; <br>&gt; Other anonymous types can be considered equivalent by their definitions, e.g. (x:Int, y:Int) taken as input from one function can be passed to another. <br>&gt; <br>&gt; E.g. your adjustTemperature function wanted to call a checkSafety(device:DeviceType, [low | medium | high]:temperature) -&gt; Bool function - could it?<br>&gt; <br>&gt; what about if adjustTemperature took [low | medium | high | extreme]?<br>&gt; <br>&gt; what about adjustTemperature having an internal var lastAdjustment:[low | medium | high] - would that work?<br>&gt; <br>&gt; My concern is that there could many reasons to need to switch from shorthand/anonymous syntax to a full enum, and that switch will have the same fragility as changing a function from accepting a tuple to accepting a struct. If passing to another function or assigning to a variable would require a switch to a properly qualified enum, the feature seems not worth its character savings.<br>&gt; <br>&gt; And I’m already unsure it is worth its existing character savings, especially once you start documenting the meaning of low / medium / high for other developers, and especially if you now have to do so for multiple functions rather than a single enum declaration.<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On Feb 22, 2016, at 9:46 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 22, 2016, at 3:53 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not sure wether I want to see that feature added, but I think there is a &quot;structural&quot; argument for it:<br>&gt;&gt;&gt; We have anonymous functions (closures) and a (restricted) form of anonymous structs (tuples), so it would be consequent to have a anonymous variant for each fundamental entity in the language.<br>&gt;&gt;&gt; I guess it is to late to establish a unified syntax for all of those, though…<br>&gt;&gt; <br>&gt;&gt; I like the symmetry with the other anonymous types. This provides a highly focused tweak to Swift, with limited impact, and a measurable benefit to developers. (AKA the &quot;Rule of Lattner&quot;)<br>&gt;&gt; <br>&gt;&gt; Further, the values cannot be assigned to variables or passed as arguments as they have no &quot;type&quot;.  I suspect it won&#39;t be hard to restrict them for being used with `Any` argument, limiting their use to flags and switch cases. If I&#39;m conceptualizing this correctly, the benefits are clear and the consequences are small.<br>&gt;&gt; <br>&gt;&gt; -- Erica<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 21, 2016, at 11:52 PM, Yong hee Lee via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; please check the link below.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://gist.github.com/erica/9148e2be916c7fae6f1e &lt;https://gist.github.com/erica/9148e2be916c7fae6f1e&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160222/54529249/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Anoymous Enums (Updated)</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>February 22, 2016 at 05:00:00pm</p></header><div class="content"><p>Likely not the best wording on my part... It by definition can&#39;t escape but<br>the coder may find they need it to conceptually escape / persist which then<br>leads to mapping it to some other form that captures the same or similar<br>state.<br></p><p>Anyway I meant to say I like it and generally support the addition. I only<br>question if the utility of it may be too limited.<br></p><p>I will play around in code examples to better clarify my thinking on this.<br></p><p>On Mon, Feb 22, 2016 at 9:22 AM Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt; Under what circumstances could these ever escape scope?<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; On Feb 22, 2016, at 10:20 AM, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt;<br>&gt; I have similar concerns as David. I do like the idea but I see it becoming<br>&gt; a problem in not a typical usage as David outlined. You likely would never<br>&gt; want to use this in any public API or possibly any function signature for<br>&gt; that matter (again given the limits implied by the short hand). I see it<br>&gt; being useful in a given scope of code for the purpose of readability and<br>&gt; even safety. It is when it starts to escape that scope it become less<br>&gt; useful and possibly unsafe.<br>&gt;<br>&gt; On Mon, Feb 22, 2016 at 9:12 AM David Waite via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Having this work similar to other anonymous types would be an extension<br>&gt;&gt; to the proposal.<br>&gt;&gt;<br>&gt;&gt; Other anonymous types can be considered equivalent by their definitions,<br>&gt;&gt; e.g. (x:Int, y:Int) taken as input from one function can be passed to<br>&gt;&gt; another.<br>&gt;&gt;<br>&gt;&gt; E.g. your adjustTemperature function wanted to call a<br>&gt;&gt; checkSafety(device:DeviceType, [low | medium | high]:temperature) -&gt; Bool<br>&gt;&gt; function - could it?<br>&gt;&gt;<br>&gt;&gt; what about if adjustTemperature took [low | medium | high | extreme]?<br>&gt;&gt;<br>&gt;&gt; what about adjustTemperature having an internal var lastAdjustment:[low |<br>&gt;&gt; medium | high] - would that work?<br>&gt;&gt;<br>&gt;&gt; My concern is that there could many reasons to need to switch from<br>&gt;&gt; shorthand/anonymous syntax to a full enum, and that switch will have the<br>&gt;&gt; same fragility as changing a function from accepting a tuple to accepting a<br>&gt;&gt; struct. If passing to another function or assigning to a variable would<br>&gt;&gt; require a switch to a properly qualified enum, the feature seems not worth<br>&gt;&gt; its character savings.<br>&gt;&gt;<br>&gt;&gt; And I’m already unsure it is worth its existing character savings,<br>&gt;&gt; especially once you start documenting the meaning of low / medium / high<br>&gt;&gt; for other developers, and especially if you now have to do so for multiple<br>&gt;&gt; functions rather than a single enum declaration.<br>&gt;&gt;<br>&gt;&gt; -DW<br>&gt;&gt;<br>&gt;&gt; On Feb 22, 2016, at 9:46 AM, Erica Sadun via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Feb 22, 2016, at 3:53 AM, Tino Heth via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I&#39;m not sure wether I want to see that feature added, but I think there<br>&gt;&gt; is a &quot;structural&quot; argument for it:<br>&gt;&gt; We have anonymous functions (closures) and a (restricted) form of<br>&gt;&gt; anonymous structs (tuples), so it would be consequent to have a anonymous<br>&gt;&gt; variant for each fundamental entity in the language.<br>&gt;&gt; I guess it is to late to establish a unified syntax for all of those,<br>&gt;&gt; though…<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I like the symmetry with the other anonymous types. This provides a<br>&gt;&gt; highly focused tweak to Swift, with limited impact, and a measurable<br>&gt;&gt; benefit to developers. (AKA the &quot;Rule of Lattner&quot;)<br>&gt;&gt;<br>&gt;&gt; Further, the values cannot be assigned to variables or passed as<br>&gt;&gt; arguments as they have no &quot;type&quot;.  I suspect it won&#39;t be hard to restrict<br>&gt;&gt; them for being used with `Any` argument, limiting their use to flags and<br>&gt;&gt; switch cases. If I&#39;m conceptualizing this correctly, the benefits are clear<br>&gt;&gt; and the consequences are small.<br>&gt;&gt;<br>&gt;&gt; -- Erica<br>&gt;&gt;<br>&gt;&gt; On Feb 21, 2016, at 11:52 PM, Yong hee Lee via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; please check the link below.<br>&gt;&gt;<br>&gt;&gt; https://gist.github.com/erica/9148e2be916c7fae6f1e<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160222/0ac4e438/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Anoymous Enums (Updated)</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 22, 2016 at 10:00:00am</p></header><div class="content"><p>&quot;An enumeration that&#39;s used in more than once place, has associated or raw values, or provides semantics beyond use as a flag is not a suitable candidate for this proposal.&quot;<br></p><p>I&#39;d suggest that self-documenting flags are in and of themselves sufficiently useful.<br></p><p>-- E<br></p><p><br>&gt; On Feb 22, 2016, at 10:32 AM, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt; <br>&gt; Likely not the best wording on my part... It by definition can&#39;t escape but the coder may find they need it to conceptually escape / persist which then leads to mapping it to some other form that captures the same or similar state.<br>&gt; <br>&gt; Anyway I meant to say I like it and generally support the addition. I only question if the utility of it may be too limited.<br>&gt; <br>&gt; I will play around in code examples to better clarify my thinking on this.<br>&gt; <br>&gt; On Mon, Feb 22, 2016 at 9:22 AM Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt; Under what circumstances could these ever escape scope?<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt;&gt; On Feb 22, 2016, at 10:20 AM, Shawn Erickson &lt;shawnce at gmail.com &lt;mailto:shawnce at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have similar concerns as David. I do like the idea but I see it becoming a problem in not a typical usage as David outlined. You likely would never want to use this in any public API or possibly any function signature for that matter (again given the limits implied by the short hand). I see it being useful in a given scope of code for the purpose of readability and even safety. It is when it starts to escape that scope it become less useful and possibly unsafe.<br>&gt;&gt; <br>&gt;&gt; On Mon, Feb 22, 2016 at 9:12 AM David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Having this work similar to other anonymous types would be an extension to the proposal. <br>&gt;&gt; <br>&gt;&gt; Other anonymous types can be considered equivalent by their definitions, e.g. (x:Int, y:Int) taken as input from one function can be passed to another. <br>&gt;&gt; <br>&gt;&gt; E.g. your adjustTemperature function wanted to call a checkSafety(device:DeviceType, [low | medium | high]:temperature) -&gt; Bool function - could it?<br>&gt;&gt; <br>&gt;&gt; what about if adjustTemperature took [low | medium | high | extreme]?<br>&gt;&gt; <br>&gt;&gt; what about adjustTemperature having an internal var lastAdjustment:[low | medium | high] - would that work?<br>&gt;&gt; <br>&gt;&gt; My concern is that there could many reasons to need to switch from shorthand/anonymous syntax to a full enum, and that switch will have the same fragility as changing a function from accepting a tuple to accepting a struct. If passing to another function or assigning to a variable would require a switch to a properly qualified enum, the feature seems not worth its character savings.<br>&gt;&gt; <br>&gt;&gt; And I’m already unsure it is worth its existing character savings, especially once you start documenting the meaning of low / medium / high for other developers, and especially if you now have to do so for multiple functions rather than a single enum declaration.<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 22, 2016, at 9:46 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 22, 2016, at 3:53 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not sure wether I want to see that feature added, but I think there is a &quot;structural&quot; argument for it:<br>&gt;&gt;&gt;&gt; We have anonymous functions (closures) and a (restricted) form of anonymous structs (tuples), so it would be consequent to have a anonymous variant for each fundamental entity in the language.<br>&gt;&gt;&gt;&gt; I guess it is to late to establish a unified syntax for all of those, though…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like the symmetry with the other anonymous types. This provides a highly focused tweak to Swift, with limited impact, and a measurable benefit to developers. (AKA the &quot;Rule of Lattner&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Further, the values cannot be assigned to variables or passed as arguments as they have no &quot;type&quot;.  I suspect it won&#39;t be hard to restrict them for being used with `Any` argument, limiting their use to flags and switch cases. If I&#39;m conceptualizing this correctly, the benefits are clear and the consequences are small.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- Erica<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 21, 2016, at 11:52 PM, Yong hee Lee via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; please check the link below.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://gist.github.com/erica/9148e2be916c7fae6f1e &lt;https://gist.github.com/erica/9148e2be916c7fae6f1e&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160222/58a71d6f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Anoymous Enums (Updated)</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>February 22, 2016 at 10:00:00am</p></header><div class="content"><p>Then maybe low/medium/high is just a bad example?<br></p><p>&gt; On Feb 22, 2016, at 10:35 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; &quot;An enumeration that&#39;s used in more than once place, has associated or raw values, or provides semantics beyond use as a flag is not a suitable candidate for this proposal.&quot;<br>&gt; <br>&gt; I&#39;d suggest that self-documenting flags are in and of themselves sufficiently useful.<br>&gt; <br>&gt; -- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Anoymous Enums (Updated)</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 22, 2016 at 06:00:00pm</p></header><div class="content"><p>A few more off the top of my head. Any of these better?<br></p><p>func startService(type: [ client | server ]) { ... }<br>func pushNewContext(colorModel: [ rgba | rgb | grayscale ] ) { ... }<br>func animateDrawer(toState: [ closed | open | hidden ] ) { ... }<br>func startRecordingAudio(quality: [ q8k | q44k | q22k ] ) { ... }<br>func performAlert(type: [ slidein | pop | flip ] ) { ... }<br>func createPath(style: [ closed | open ] ) { ... }<br>func rectifyImage(standard: [ uikit | exif ]) { ... }<br></p><p>-- E<br></p><p><br>&gt; On Feb 22, 2016, at 10:57 AM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; Then maybe low/medium/high is just a bad example?<br>&gt; <br>&gt;&gt; On Feb 22, 2016, at 10:35 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &quot;An enumeration that&#39;s used in more than once place, has associated or raw values, or provides semantics beyond use as a flag is not a suitable candidate for this proposal.&quot;<br>&gt;&gt; <br>&gt;&gt; I&#39;d suggest that self-documenting flags are in and of themselves sufficiently useful.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Anoymous Enums (Updated)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 22, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; A few more off the top of my head. Any of these better?<br></p><p><br>Frankly, I don&#39;t think so.<br></p><p>&gt; func startService(type: [ client | server ]) { ... }<br></p><p>Isn&#39;t this mixing two operations into one call which are either barely related, or probably need to be parameterized with the service type?<br></p><p>&gt; func pushNewContext(colorModel: [ rgba | rgb | grayscale ] ) { ... }<br></p><p>The context doesn&#39;t have a colorModel property?<br></p><p>&gt; func animateDrawer(toState: [ closed | open | hidden ] ) { ... }<br></p><p>There&#39;s no self.drawerState property?<br></p><p>&gt; func startRecordingAudio(quality: [ q8k | q44k | q22k ] ) { ... }<br></p><p>You don&#39;t pass this through to your audio file model?<br></p><p>&gt; func performAlert(type: [ slidein | pop | flip ] ) { ... }<br></p><p>The animation isn&#39;t performed by a method on the type?<br></p><p>&gt; func createPath(style: [ closed | open ] ) { ... }<br></p><p>There&#39;s no style property on the path you created?<br></p><p>&gt; func rectifyImage(standard: [ uikit | exif ]) { ... }<br></p><p>Why is this one method if it has two almost completely different code paths?<br></p><p>This is a clever feature, but the more examples I see, the more convinced I become that every use smells of poorly structured code.<br></p><p>(Plus, it doesn&#39;t support the one place where we genuinely *do* often have an ad-hoc group of cases which is different for every call: option sets.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Anoymous Enums (Updated)</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 22, 2016 at 08:00:00pm</p></header><div class="content"><p>I think we&#39;re seeing the world through two different eyes: big programming and little programming. <br>In big programming, everything is well architected, meant for re-use, well-documented, and probably<br>developed within a highly structured environment. In little programming, someone writes a utility here<br>or there, or creates a quick library that some friends can use. <br></p><p>A strong programming language supports both. Not everything in Swift needs to be fully structured, fully<br>organized, fully realized, although these are goals that should never be fully ignored. And yes, I see the <br>same potential as you for architecting out these use-cases for big projects. I also see the convenience in<br>offering switch-cases for small ones.<br></p><p>-- E<br></p><p>&gt; On Feb 22, 2016, at 8:31 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; A few more off the top of my head. Any of these better?<br>&gt; <br>&gt; <br>&gt; Frankly, I don&#39;t think so.<br>&gt; <br>&gt;&gt; func startService(type: [ client | server ]) { ... }<br>&gt; <br>&gt; Isn&#39;t this mixing two operations into one call which are either barely related, or probably need to be parameterized with the service type?<br>&gt; <br>&gt;&gt; func pushNewContext(colorModel: [ rgba | rgb | grayscale ] ) { ... }<br>&gt; <br>&gt; The context doesn&#39;t have a colorModel property?<br>&gt; <br>&gt;&gt; func animateDrawer(toState: [ closed | open | hidden ] ) { ... }<br>&gt; <br>&gt; There&#39;s no self.drawerState property?<br>&gt; <br>&gt;&gt; func startRecordingAudio(quality: [ q8k | q44k | q22k ] ) { ... }<br>&gt; <br>&gt; You don&#39;t pass this through to your audio file model?<br>&gt; <br>&gt;&gt; func performAlert(type: [ slidein | pop | flip ] ) { ... }<br>&gt; <br>&gt; The animation isn&#39;t performed by a method on the type?<br>&gt; <br>&gt;&gt; func createPath(style: [ closed | open ] ) { ... }<br>&gt; <br>&gt; There&#39;s no style property on the path you created?<br>&gt; <br>&gt;&gt; func rectifyImage(standard: [ uikit | exif ]) { ... }<br>&gt; <br>&gt; Why is this one method if it has two almost completely different code paths?<br>&gt; <br>&gt; This is a clever feature, but the more examples I see, the more convinced I become that every use smells of poorly structured code.<br>&gt; <br>&gt; (Plus, it doesn&#39;t support the one place where we genuinely *do* often have an ad-hoc group of cases which is different for every call: option sets.)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Anoymous Enums (Updated)</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 23, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Feb 22, 2016, at 8:31 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; (Plus, it doesn&#39;t support the one place where we genuinely *do* often have an ad-hoc group of cases which is different for every call: option sets.)<br></p><p>So, after sleeping on this, should it? Should this proposal be about option sets and not enums per se? Since the primary use case is flagging? Or support<br>both enums for boolean replacement and option sets for more complicated flags?<br></p><p>-- E<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Anoymous Enums (Updated)</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 22, 2016 at 10:00:00am</p></header><div class="content"><p>I don&#39;t believe character savings is the benefit. Stronger arguments are self-documentation in declaration, intrinsic switch support, clarity at call point, clarity of QuickHelp. All conversions from anonymous to fully qualified types involve refactoring, so I don&#39;t think this stands out as a particular issue. And I&#39;m not convinced they need to have equivalent definition support.<br></p><p>As for documenting the meaning of low/med/high/extreme, no different than a standalone enumeration type. Not seeing the issue.<br></p><p>-- E<br></p><p><br>&gt; On Feb 22, 2016, at 10:12 AM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; Having this work similar to other anonymous types would be an extension to the proposal. <br>&gt; <br>&gt; Other anonymous types can be considered equivalent by their definitions, e.g. (x:Int, y:Int) taken as input from one function can be passed to another. <br>&gt; <br>&gt; E.g. your adjustTemperature function wanted to call a checkSafety(device:DeviceType, [low | medium | high]:temperature) -&gt; Bool function - could it?<br>&gt; <br>&gt; what about if adjustTemperature took [low | medium | high | extreme]?<br>&gt; <br>&gt; what about adjustTemperature having an internal var lastAdjustment:[low | medium | high] - would that work?<br>&gt; <br>&gt; My concern is that there could many reasons to need to switch from shorthand/anonymous syntax to a full enum, and that switch will have the same fragility as changing a function from accepting a tuple to accepting a struct. If passing to another function or assigning to a variable would require a switch to a properly qualified enum, the feature seems not worth its character savings.<br>&gt; <br>&gt; And I’m already unsure it is worth its existing character savings, especially once you start documenting the meaning of low / medium / high for other developers, and especially if you now have to do so for multiple functions rather than a single enum declaration.<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On Feb 22, 2016, at 9:46 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 22, 2016, at 3:53 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not sure wether I want to see that feature added, but I think there is a &quot;structural&quot; argument for it:<br>&gt;&gt;&gt; We have anonymous functions (closures) and a (restricted) form of anonymous structs (tuples), so it would be consequent to have a anonymous variant for each fundamental entity in the language.<br>&gt;&gt;&gt; I guess it is to late to establish a unified syntax for all of those, though…<br>&gt;&gt; <br>&gt;&gt; I like the symmetry with the other anonymous types. This provides a highly focused tweak to Swift, with limited impact, and a measurable benefit to developers. (AKA the &quot;Rule of Lattner&quot;)<br>&gt;&gt; <br>&gt;&gt; Further, the values cannot be assigned to variables or passed as arguments as they have no &quot;type&quot;.  I suspect it won&#39;t be hard to restrict them for being used with `Any` argument, limiting their use to flags and switch cases. If I&#39;m conceptualizing this correctly, the benefits are clear and the consequences are small.<br>&gt;&gt; <br>&gt;&gt; -- Erica<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 21, 2016, at 11:52 PM, Yong hee Lee via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; please check the link below.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://gist.github.com/erica/9148e2be916c7fae6f1e &lt;https://gist.github.com/erica/9148e2be916c7fae6f1e&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160222/3542edbc/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
