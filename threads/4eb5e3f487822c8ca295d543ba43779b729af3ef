<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4751294e3d15558af55b89d9a3099216?s=50"></div><header><strong>NSCoding methods</strong> from <string>Daniel Strokis</string> &lt;dstrokis at icloud.com&gt;<p>December 12, 2015 at 02:00:00pm</p></header><div class="content"><p>Hi All, <br></p><p>I’ve noticed that for many classes in Foundation, encodeWithCoder and init?(coder aDecoder: NSCoder) call NSUnimplemented. Are these methods that just haven’t been implemented yet, or are we not interested in implementing these moving forward? Apologies if this has already been discussed before and I’m just out of the loop. <br></p><p>Thanks, <br>Daniel Strokis<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151212/4eb5f3ef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>NSCoding methods</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>December 12, 2015 at 12:00:00pm</p></header><div class="content"><p>These were not implemented yet since we did not have a way to actually verify archives. Part of the goal is to have archives be serializable on Darwin platforms and de-serializable on linux (and visa-versa). That way someone could presumably archive objects on an iPhone and send the archive over the wire to a linux machine and that machine would be able to de-serialize it and yield the appropriate structure. This means that we need to make certain while implementing these that they mimic the same coder keys and structural serialization order (when not initing with a keyed archiver). NSCoder itself has a start of an implementation but NSKeyedArchiver has a limitation in that we cannot yet build construction of objects dynamically from their class name. Specifically there is no NSClassFromString yet. I would say if you are looking for a place to start, perhaps coming up with a good strategy for accomplishing that in a uniform manner (for both Foundation classes as well as user classes) would be a good step in the right direction to getting this started.<br></p><p>It might also be a good start to build a verification NSCoder subclass to verify the order and keys/values for any abstract class. That way we can test and verify the coding/decoding on all platforms.<br></p><p>&gt; On Dec 12, 2015, at 11:58 AM, Daniel Strokis via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi All, <br>&gt; <br>&gt; I’ve noticed that for many classes in Foundation, encodeWithCoder and init?(coder aDecoder: NSCoder) call NSUnimplemented. Are these methods that just haven’t been implemented yet, or are we not interested in implementing these moving forward? Apologies if this has already been discussed before and I’m just out of the loop. <br>&gt; <br>&gt; Thanks, <br>&gt; Daniel Strokis<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151212/09e476f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4751294e3d15558af55b89d9a3099216?s=50"></div><header><strong>NSCoding methods</strong> from <string>Daniel Strokis</string> &lt;dstrokis at icloud.com&gt;<p>December 18, 2015 at 09:00:00pm</p></header><div class="content"><p>Is anyone currently working on this who would like to collaborate? <br></p><p>Daniel Strokis<br></p><p>Sent from my iPhone<br></p><p>&gt; On Dec 12, 2015, at 3:47 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt; These were not implemented yet since we did not have a way to actually verify archives. Part of the goal is to have archives be serializable on Darwin platforms and de-serializable on linux (and visa-versa). That way someone could presumably archive objects on an iPhone and send the archive over the wire to a linux machine and that machine would be able to de-serialize it and yield the appropriate structure. This means that we need to make certain while implementing these that they mimic the same coder keys and structural serialization order (when not initing with a keyed archiver). NSCoder itself has a start of an implementation but NSKeyedArchiver has a limitation in that we cannot yet build construction of objects dynamically from their class name. Specifically there is no NSClassFromString yet. I would say if you are looking for a place to start, perhaps coming up with a good strategy for accomplishing that in a uniform manner (for both Foundation classes as well as user classes) would be a good step in the right direction to getting this started.<br>&gt; <br>&gt; It might also be a good start to build a verification NSCoder subclass to verify the order and keys/values for any abstract class. That way we can test and verify the coding/decoding on all platforms.<br>&gt; <br>&gt;&gt; On Dec 12, 2015, at 11:58 AM, Daniel Strokis via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi All, <br>&gt;&gt; <br>&gt;&gt; I’ve noticed that for many classes in Foundation, encodeWithCoder and init?(coder aDecoder: NSCoder) call NSUnimplemented. Are these methods that just haven’t been implemented yet, or are we not interested in implementing these moving forward? Apologies if this has already been discussed before and I’m just out of the loop. <br>&gt;&gt; <br>&gt;&gt; Thanks, <br>&gt;&gt; Daniel Strokis<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt; swift-corelibs-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151218/be2b7a27/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 19, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; Specifically there is no NSClassFromString yet. I would say if you are looking for a place to start, perhaps coming up with a good strategy for accomplishing that in a uniform manner (for both Foundation classes as well as user classes) would be a good step in the right direction to getting this started.<br></p><p>Does Swift have enough runtime metadata to do this for native Swift classes?<br></p><p>-- Luke<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>NSCoding methods</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>December 19, 2015 at 01:00:00pm</p></header><div class="content"><p>Somewhat; the mangled symbols are technically searchable by dlsym but that seems like a hack. Perhaps one of the stdlib/compiler team might be able to speak more on this than myself and they may have suggestions for a better way. Foundation is at a special spot in which we can sometimes get special runtime considerations for these types of things. <br></p><p>The tricksy spot would be cases where you would need to fetch a class without the module name. <br></p><p>For example NSUUID is defined by it’s module name Foundation.NSUUID; in that a program could have it’s own NSUUID that is totally different (naming it the same thing would be confusing to read and potentially viewed as bad form but it can be done…). That would result in MyApplication.NSUUID to define the symbolic name of the item. From the perspective of NSKeyedArchiver it will encode things as NSUUID (without the namespace) in that in the realm of objc there can be only one.<br></p><p>The tl;dr is that there is no manifest of classes or table of names stored in the binaries; just symbols.<br></p><p>&gt; On Dec 18, 2015, at 10:57 PM, Luke Howard &lt;lukeh at padl.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Specifically there is no NSClassFromString yet. I would say if you are looking for a place to start, perhaps coming up with a good strategy for accomplishing that in a uniform manner (for both Foundation classes as well as user classes) would be a good step in the right direction to getting this started.<br>&gt; <br>&gt; Does Swift have enough runtime metadata to do this for native Swift classes?<br>&gt; <br>&gt; -- Luke<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 21, 2015 at 12:00:00am</p></header><div class="content"><p>&gt; Somewhat; the mangled symbols are technically searchable by dlsym but that seems like a hack. Perhaps one of the stdlib/compiler team might be able to speak more on this than myself and they may have suggestions for a better way. Foundation is at a special spot in which we can sometimes get special runtime considerations for these types of things. <br></p><p>It’d arguably be more of a hack to add a global manifest of classes if the dynamic linker already has one ;-) Here’s a toy implementation of swift_classFromString():<br></p><p>https://github.com/lhoward/SwiftRuntimeTest<br></p><p>Disclaimer: I know very little about Swift nor its implementation beyond a bit of poking around.<br></p><p>&gt; For example NSUUID is defined by it’s module name Foundation.NSUUID; in that a program could have it’s own NSUUID that is totally different (naming it the same thing would be confusing to read and potentially viewed as bad form but it can be done…). That would result in MyApplication.NSUUID to define the symbolic name of the item. From the perspective of NSKeyedArchiver it will encode things as NSUUID (without the namespace) in that in the realm of objc there can be only one.<br></p><p>What if you (re-)added the ability to annotate Swift classes with their Objective-C name on non-Apple platforms? I don’t know what the runtime costs of doing this are but it seems like it’s either this, or only allow non-namespaced names for Foundation objects.<br></p><p>— Luke<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 21, 2015 at 06:00:00pm</p></header><div class="content"><p>It&#39;s not too hard to figure out (and there are a couple of other ObjC implementations) but if Apple have any specs for the archive format, I would be keen to take a look.<br></p><p>Also regarding interoperability - perhaps it might be reasonable, for non-Foundation classes that have non-namespaced names (on non-ObjC platforms) for the caller to configure the NSKeyedArchiver with explicit class mappings?<br></p><p>-- Luke<br></p><p>Sent from my iPhone<br></p><p>&gt; On 21 Dec 2015, at 00:02, Luke Howard via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Somewhat; the mangled symbols are technically searchable by dlsym but that seems like a hack. Perhaps one of the stdlib/compiler team might be able to speak more on this than myself and they may have suggestions for a better way. Foundation is at a special spot in which we can sometimes get special runtime considerations for these types of things.<br>&gt; <br>&gt; It’d arguably be more of a hack to add a global manifest of classes if the dynamic linker already has one ;-) Here’s a toy implementation of swift_classFromString():<br>&gt; <br>&gt; https://github.com/lhoward/SwiftRuntimeTest<br>&gt; <br>&gt; Disclaimer: I know very little about Swift nor its implementation beyond a bit of poking around.<br>&gt; <br>&gt;&gt; For example NSUUID is defined by it’s module name Foundation.NSUUID; in that a program could have it’s own NSUUID that is totally different (naming it the same thing would be confusing to read and potentially viewed as bad form but it can be done…). That would result in MyApplication.NSUUID to define the symbolic name of the item. From the perspective of NSKeyedArchiver it will encode things as NSUUID (without the namespace) in that in the realm of objc there can be only one.<br>&gt; <br>&gt; What if you (re-)added the ability to annotate Swift classes with their Objective-C name on non-Apple platforms? I don’t know what the runtime costs of doing this are but it seems like it’s either this, or only allow non-namespaced names for Foundation objects.<br>&gt; <br>&gt; — Luke<br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>NSCoding methods</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 21, 2015 at 10:00:00am</p></header><div class="content"><p>IMHO on Linux NSKeyedArchiver should always use mangled names. If we want cross-platform archives, we should set up standard substitutions, but given that Swift classes exposed to Objective-C are archived with their full names it doesn&#39;t make sense to use &quot;half the name&quot; in the archive.<br></p><p>Jordan<br></p><p>&gt; On Dec 19, 2015, at 13:23 , Philippe Hausler via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Somewhat; the mangled symbols are technically searchable by dlsym but that seems like a hack. Perhaps one of the stdlib/compiler team might be able to speak more on this than myself and they may have suggestions for a better way. Foundation is at a special spot in which we can sometimes get special runtime considerations for these types of things. <br>&gt; <br>&gt; The tricksy spot would be cases where you would need to fetch a class without the module name. <br>&gt; <br>&gt; For example NSUUID is defined by it’s module name Foundation.NSUUID; in that a program could have it’s own NSUUID that is totally different (naming it the same thing would be confusing to read and potentially viewed as bad form but it can be done…). That would result in MyApplication.NSUUID to define the symbolic name of the item. From the perspective of NSKeyedArchiver it will encode things as NSUUID (without the namespace) in that in the realm of objc there can be only one.<br>&gt; <br>&gt; The tl;dr is that there is no manifest of classes or table of names stored in the binaries; just symbols.<br>&gt; <br>&gt;&gt; On Dec 18, 2015, at 10:57 PM, Luke Howard &lt;lukeh at padl.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Specifically there is no NSClassFromString yet. I would say if you are looking for a place to start, perhaps coming up with a good strategy for accomplishing that in a uniform manner (for both Foundation classes as well as user classes) would be a good step in the right direction to getting this started.<br>&gt;&gt; <br>&gt;&gt; Does Swift have enough runtime metadata to do this for native Swift classes?<br>&gt;&gt; <br>&gt;&gt; -- Luke<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 22, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On 22 Dec 2015, at 5:50 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; IMHO on Linux NSKeyedArchiver should always use mangled names. If we want cross-platform archives, we should set up standard substitutions, but given that Swift classes exposed to Objective-C are archived with their full names it doesn&#39;t make sense to use &quot;half the name&quot; in the archive.<br></p><p>You mean namespaced but unmangled yes? If so I agree.<br></p><p>BTW I found a couple of small CF nits:<br></p><p>* in CFDictionaryGetKeysAndValues(), keybuf and valuebuf are transposed in the call to CF_SWIFT_FUNCDISPATCHV(NSDictionary.getObjects())<br></p><p>* _CFSwiftDictionaryGetKeysAndValues() does not handle keybuf or valbuf being NULL (either of which are valid when calling CFDictionaryGetKeysAndValues())<br></p><p>— Luke<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 22, 2015 at 10:00:00pm</p></header><div class="content"><p>Also, I’m sure this is just my lack of Swift-fu but I’m occasionally getting EXC_BAD_INSTRUCTION in NSString.hash() where the hash code is cast to an Int. If I use unsafeBitCast() instead it seems to work, but I have no idea whether this is safe or not.<br></p><p>I’m on OS X with the 2015-12-18 snapshot.<br></p><p>— Luke<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>NSCoding methods</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>December 22, 2015 at 10:00:00am</p></header><div class="content"><p>To clarify the goals: I think it is reasonable for us to have a goal to be able to encode/decode archives from foreign targets; e.g. linux encodes an archive and mac os x decodes or iOS encodes and linux decodes. This will allow for server architecture to transmit binary archives across the wire. This will mean that we will want to have the encoded class names from the application scope to be encoded as the non mangled name but with the namespace. However this presents a problem; Foundation will have a namespace which will need to be inferred both for encoding and decoding. Thankfully there may be a reasonable way to approach this;<br></p><p>public class func classNameForClass(cls: AnyClass) -&gt; String?<br>public class func setClassName(codedName: String?, forClass cls: AnyClass)<br></p><p>These methods can be used to allow for translation of classes by registering the appropriate classes for a “shortened” name that drops the Foundation/SwiftFoundation namespace prefix during encoding.<br></p><p>&gt; On Dec 22, 2015, at 2:45 AM, Luke Howard via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 22 Dec 2015, at 5:50 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; IMHO on Linux NSKeyedArchiver should always use mangled names. If we want cross-platform archives, we should set up standard substitutions, but given that Swift classes exposed to Objective-C are archived with their full names it doesn&#39;t make sense to use &quot;half the name&quot; in the archive.<br>&gt; <br>&gt; You mean namespaced but unmangled yes? If so I agree.<br>&gt; <br>&gt; BTW I found a couple of small CF nits:<br>&gt; <br>&gt; * in CFDictionaryGetKeysAndValues(), keybuf and valuebuf are transposed in the call to CF_SWIFT_FUNCDISPATCHV(NSDictionary.getObjects())<br>&gt; <br>&gt; * _CFSwiftDictionaryGetKeysAndValues() does not handle keybuf or valbuf being NULL (either of which are valid when calling CFDictionaryGetKeysAndValues())<br>&gt; <br></p><p>This is a bit un-related to NSCoding and the transposition is probably a mistake if it is inverted (the CF method should be reversed from the NS method to mimic the objc counterpart)<br></p><p>&gt; — Luke<br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 23, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On 23 Dec 2015, at 5:16 AM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; BTW I found a couple of small CF nits:<br>&gt;&gt; <br>&gt;&gt; * in CFDictionaryGetKeysAndValues(), keybuf and valuebuf are transposed in the call to CF_SWIFT_FUNCDISPATCHV(NSDictionary.getObjects())<br>&gt;&gt; <br>&gt;&gt; * _CFSwiftDictionaryGetKeysAndValues() does not handle keybuf or valbuf being NULL (either of which are valid when calling CFDictionaryGetKeysAndValues())<br>&gt;&gt; <br>&gt; <br>&gt; This is a bit un-related to NSCoding and the transposition is probably a mistake if it is inverted (the CF method should be reversed from the NS method to mimic the objc counterpart)<br></p><p>Right, I only noticed this whilst implementing NSKeyedArchiver.<br></p><p>Should _CFSwiftDictionaryGetKeysAndValues() (== NSDictionary.getObjects) follow the ObjC or the CF parameter order? The latter makes more sense to me.<br></p><p>— Luke<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 23, 2015 at 06:00:00pm</p></header><div class="content"><p>Some work on NSKeyedArchiver below:<br></p><p>https://github.com/lhoward/swift-corelibs-foundation/tree/lhoward/nscoding<br></p><p>Very incomplete (most classes don’t have coders, there is no unarchiver, inexperienced Swift programmer).<br></p><p>— Luke<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>NSCoding methods</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 23, 2015 at 02:00:00pm</p></header><div class="content"><p>No, we cannot encode things &quot;non-mangled but with the namespace&quot;. For any type other than top-level non-generic class types, using a non-mangled name is not unique. The only correct answer for arbitrary classes is to use mangled names, or something that maps one-to-one with mangled names.<br></p><p>Now, Foundation classes are not arbitrary classes, but then I don&#39;t see why we&#39;d need to use mangled names for those. We can just use the plain old Objective-C names that the OS X classes use today.<br></p><p>Jordan<br></p><p>&gt; On Dec 22, 2015, at 10:16, Philippe Hausler via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; To clarify the goals: I think it is reasonable for us to have a goal to be able to encode/decode archives from foreign targets; e.g. linux encodes an archive and mac os x decodes or iOS encodes and linux decodes. This will allow for server architecture to transmit binary archives across the wire. This will mean that we will want to have the encoded class names from the application scope to be encoded as the non mangled name but with the namespace. However this presents a problem; Foundation will have a namespace which will need to be inferred both for encoding and decoding. Thankfully there may be a reasonable way to approach this;<br>&gt; <br>&gt; public class func classNameForClass(cls: AnyClass) -&gt; String?<br>&gt; public class func setClassName(codedName: String?, forClass cls: AnyClass)<br>&gt; <br>&gt; These methods can be used to allow for translation of classes by registering the appropriate classes for a “shortened” name that drops the Foundation/SwiftFoundation namespace prefix during encoding.<br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 2:45 AM, Luke Howard via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 22 Dec 2015, at 5:50 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMHO on Linux NSKeyedArchiver should always use mangled names. If we want cross-platform archives, we should set up standard substitutions, but given that Swift classes exposed to Objective-C are archived with their full names it doesn&#39;t make sense to use &quot;half the name&quot; in the archive.<br>&gt;&gt; <br>&gt;&gt; You mean namespaced but unmangled yes? If so I agree.<br>&gt;&gt; <br>&gt;&gt; BTW I found a couple of small CF nits:<br>&gt;&gt; <br>&gt;&gt; * in CFDictionaryGetKeysAndValues(), keybuf and valuebuf are transposed in the call to CF_SWIFT_FUNCDISPATCHV(NSDictionary.getObjects())<br>&gt;&gt; <br>&gt;&gt; * _CFSwiftDictionaryGetKeysAndValues() does not handle keybuf or valbuf being NULL (either of which are valid when calling CFDictionaryGetKeysAndValues())<br>&gt;&gt; <br>&gt; <br>&gt; This is a bit un-related to NSCoding and the transposition is probably a mistake if it is inverted (the CF method should be reversed from the NS method to mimic the objc counterpart)<br>&gt; <br>&gt;&gt; — Luke<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt; swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev &lt;https://lists.swift.org/mailman/listinfo/swift-corelibs-dev&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev &lt;https://lists.swift.org/mailman/listinfo/swift-corelibs-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151223/ad022a7a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>NSCoding methods</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>December 23, 2015 at 02:00:00pm</p></header><div class="content"><p>The archiving format encodes the names of the classes in the archive itself. Here are a few code examples and a quasi readable output from them:<br></p><p>let uuid = NSUUID()<br>let data = NSKeyedArchiver.archivedDataWithRootObject(uuid)<br>let archive = try! NSPropertyListSerialization.propertyListWithData(data, options: [], format: nil)<br>print(archive)<br></p><p>prints the following:<br></p><p>{<br>    &quot;$archiver&quot; = NSKeyedArchiver;<br>    &quot;$objects&quot; =     (<br>        &quot;$null&quot;,<br>                {<br>            &quot;$class&quot; = &quot;&lt;CFKeyedArchiverUID 0x1030025e0 [0x7fff7ab33bb0]&gt;{value = 2}&quot;;<br>            &quot;NS.uuidbytes&quot; = &lt;797639fe dad74b14 902afab3 c490448b&gt;;<br>        },<br>                {<br>            &quot;$classes&quot; =             (<br>                NSUUID,<br>                NSObject<br>            );<br>            &quot;$classname&quot; = NSUUID;<br>        }<br>    );<br>    &quot;$top&quot; =     {<br>        root = &quot;&lt;CFKeyedArchiverUID 0x103002a80 [0x7fff7ab33bb0]&gt;{value = 1}&quot;;<br>    };<br>    &quot;$version&quot; = 100000;<br>}<br></p><p>Note the $classes and $classname objects; which are what tell the internal implementation of NSKeyedUnarchiver what to construct; moreover you can create your own classes..<br></p><p>// I don’t really think this is a good naming for an application’s class but hey it might happen...<br>class NSUUID : NSObject, NSCoding {<br>    let uuid: Foundation.NSUUID<br>    required init?(coder aDecoder: NSCoder) {<br>        uuid = aDecoder.decodeObjectForKey(&quot;my.uuid&quot;) as! Foundation.NSUUID<br>    }<br>    override init() {<br>        uuid = Foundation.NSUUID()<br>    }<br>    func encodeWithCoder(aCoder: NSCoder) {<br>        aCoder.encodeObject(uuid, forKey: &quot;my.uuid&quot;)<br>    }<br>}<br></p><p>let uuid = NSUUID()<br>let data = NSKeyedArchiver.archivedDataWithRootObject(uuid)<br>let archive = try! NSPropertyListSerialization.propertyListWithData(data, options: [], format: nil)<br>print(archive)<br></p><p>prints the following:<br></p><p>{<br>    &quot;$archiver&quot; = NSKeyedArchiver;<br>    &quot;$objects&quot; =     (<br>        &quot;$null&quot;,<br>                {<br>            &quot;$class&quot; = &quot;&lt;CFKeyedArchiverUID 0x100709630 [0x7fff7ab33bb0]&gt;{value = 4}&quot;;<br>            &quot;my.uuid&quot; = &quot;&lt;CFKeyedArchiverUID 0x100708e60 [0x7fff7ab33bb0]&gt;{value = 2}&quot;;<br>        },<br>                {<br>            &quot;$class&quot; = &quot;&lt;CFKeyedArchiverUID 0x100709740 [0x7fff7ab33bb0]&gt;{value = 3}&quot;;<br>            &quot;NS.uuidbytes&quot; = &lt;546e5b5e 15c244a1 aa96eb90 30c3f7f6&gt;;<br>        },<br>                {<br>            &quot;$classes&quot; =             (<br>                NSUUID,<br>                NSObject<br>            );<br>            &quot;$classname&quot; = NSUUID;<br>        },<br>                {<br>            &quot;$classes&quot; =             (<br>                &quot;Archiver.NSUUID&quot;,<br>                NSObject<br>            );<br>            &quot;$classname&quot; = &quot;Archiver.NSUUID&quot;;<br>        }<br>    );<br>    &quot;$top&quot; =     {<br>        root = &quot;&lt;CFKeyedArchiverUID 0x100709b70 [0x7fff7ab33bb0]&gt;{value = 1}&quot;;<br>    };<br>    &quot;$version&quot; = 100000;<br>}<br></p><p>Granted this is a questionable name for a class but it illustrates which class names are encoded where and how they should be interpreted in the pre-existing archive format; which we will have to figure out some sensible way of inflating and deflating to/from disk/network etc.<br></p><p>&gt; On Dec 23, 2015, at 2:37 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; No, we cannot encode things &quot;non-mangled but with the namespace&quot;. For any type other than top-level non-generic class types, using a non-mangled name is not unique. The only correct answer for arbitrary classes is to use mangled names, or something that maps one-to-one with mangled names.<br>&gt; <br>&gt; Now, Foundation classes are not arbitrary classes, but then I don&#39;t see why we&#39;d need to use mangled names for those. We can just use the plain old Objective-C names that the OS X classes use today.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 10:16, Philippe Hausler via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; To clarify the goals: I think it is reasonable for us to have a goal to be able to encode/decode archives from foreign targets; e.g. linux encodes an archive and mac os x decodes or iOS encodes and linux decodes. This will allow for server architecture to transmit binary archives across the wire. This will mean that we will want to have the encoded class names from the application scope to be encoded as the non mangled name but with the namespace. However this presents a problem; Foundation will have a namespace which will need to be inferred both for encoding and decoding. Thankfully there may be a reasonable way to approach this;<br>&gt;&gt; <br>&gt;&gt; public class func classNameForClass(cls: AnyClass) -&gt; String?<br>&gt;&gt; public class func setClassName(codedName: String?, forClass cls: AnyClass)<br>&gt;&gt; <br>&gt;&gt; These methods can be used to allow for translation of classes by registering the appropriate classes for a “shortened” name that drops the Foundation/SwiftFoundation namespace prefix during encoding.<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 22, 2015, at 2:45 AM, Luke Howard via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 22 Dec 2015, at 5:50 AM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; IMHO on Linux NSKeyedArchiver should always use mangled names. If we want cross-platform archives, we should set up standard substitutions, but given that Swift classes exposed to Objective-C are archived with their full names it doesn&#39;t make sense to use &quot;half the name&quot; in the archive.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You mean namespaced but unmangled yes? If so I agree.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; BTW I found a couple of small CF nits:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * in CFDictionaryGetKeysAndValues(), keybuf and valuebuf are transposed in the call to CF_SWIFT_FUNCDISPATCHV(NSDictionary.getObjects())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * _CFSwiftDictionaryGetKeysAndValues() does not handle keybuf or valbuf being NULL (either of which are valid when calling CFDictionaryGetKeysAndValues())<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This is a bit un-related to NSCoding and the transposition is probably a mistake if it is inverted (the CF method should be reversed from the NS method to mimic the objc counterpart)<br>&gt;&gt; <br>&gt;&gt;&gt; — Luke<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt;&gt; swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev &lt;https://lists.swift.org/mailman/listinfo/swift-corelibs-dev&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt; swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev &lt;https://lists.swift.org/mailman/listinfo/swift-corelibs-dev&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151223/8023353c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>NSCoding methods</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 23, 2015 at 02:00:00pm</p></header><div class="content"><p>Here&#39;s another example on OS X:<br></p><p>import Foundation<br></p><p>class Outer {<br>    class Inner : NSObject, NSCoding {<br>        let uuid: Foundation.NSUUID<br>        required init?(coder aDecoder: NSCoder) {<br>            uuid = aDecoder.decodeObjectForKey(&quot;my.uuid&quot;) as! Foundation.NSUUID<br>        }<br>        override init() {<br>            uuid = Foundation.NSUUID()<br>        }<br>        func encodeWithCoder(aCoder: NSCoder) {<br>            aCoder.encodeObject(uuid, forKey: &quot;my.uuid&quot;)<br>        }<br>    }<br>}<br></p><p>NSKeyedArchiver.archiveRootObject(Outer.Inner(), toFile: &quot;/Users/jrose/Desktop/test-archive&quot;)<br></p><p><br>Which results in this archive:<br></p><p>{<br>  &quot;$version&quot; =&gt; 100000<br>  &quot;$objects&quot; =&gt; [<br>    0 =&gt; &quot;$null&quot;<br>    1 =&gt; {<br>      &quot;my.uuid&quot; =&gt; &lt;CFKeyedArchiverUID 0x7f8992c0e9d0 [0x7fff7c5acd80]&gt;{value = 2}<br>      &quot;$class&quot; =&gt; &lt;CFKeyedArchiverUID 0x7f8992c0ec90 [0x7fff7c5acd80]&gt;{value = 4}<br>    }<br>    2 =&gt; {<br>      &quot;NS.uuidbytes&quot; =&gt; &lt;67f0b08b c8274f8c b0c78d90 bd4627dc&gt;<br>      &quot;$class&quot; =&gt; &lt;CFKeyedArchiverUID 0x7f8992c0eda0 [0x7fff7c5acd80]&gt;{value = 3}<br>    }<br>    3 =&gt; {<br>      &quot;$classname&quot; =&gt; &quot;NSUUID&quot;<br>      &quot;$classes&quot; =&gt; [<br>        0 =&gt; &quot;NSUUID&quot;<br>        1 =&gt; &quot;NSObject&quot;<br>      ]<br>    }<br>    4 =&gt; {<br>      &quot;$classname&quot; =&gt; &quot;_TtCC4main5Outer5Inner&quot;<br>      &quot;$classes&quot; =&gt; [<br>        0 =&gt; &quot;_TtCC4main5Outer5Inner&quot;<br>        1 =&gt; &quot;NSObject&quot;<br>      ]<br>    }<br>  ]<br>  &quot;$archiver&quot; =&gt; &quot;NSKeyedArchiver&quot;<br>  &quot;$top&quot; =&gt; {<br>    &quot;root&quot; =&gt; &lt;CFKeyedArchiverUID 0x7f8992c0f0c0 [0x7fff7c5acd80]&gt;{value = 1}<br>  }<br>}<br></p><p>NSStringFromClass makes pretty names when they fall into the &quot;simple&quot; category, but that&#39;s not an arbitrarily extensible transformation, and NSCoding shouldn&#39;t have to know anything about it.<br></p><p>Jordan<br></p><p>&gt; On Dec 23, 2015, at 14:48, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt; The archiving format encodes the names of the classes in the archive itself. Here are a few code examples and a quasi readable output from them:<br>&gt; <br>&gt; let uuid = NSUUID()<br>&gt; let data = NSKeyedArchiver.archivedDataWithRootObject(uuid)<br>&gt; let archive = try! NSPropertyListSerialization.propertyListWithData(data, options: [], format: nil)<br>&gt; print(archive)<br>&gt; <br>&gt; prints the following:<br>&gt; <br>&gt; {<br>&gt;     &quot;$archiver&quot; = NSKeyedArchiver;<br>&gt;     &quot;$objects&quot; =     (<br>&gt;         &quot;$null&quot;,<br>&gt;                 {<br>&gt;             &quot;$class&quot; = &quot;&lt;CFKeyedArchiverUID 0x1030025e0 [0x7fff7ab33bb0]&gt;{value = 2}&quot;;<br>&gt;             &quot;NS.uuidbytes&quot; = &lt;797639fe dad74b14 902afab3 c490448b&gt;;<br>&gt;         },<br>&gt;                 {<br>&gt;             &quot;$classes&quot; =             (<br>&gt;                 NSUUID,<br>&gt;                 NSObject<br>&gt;             );<br>&gt;             &quot;$classname&quot; = NSUUID;<br>&gt;         }<br>&gt;     );<br>&gt;     &quot;$top&quot; =     {<br>&gt;         root = &quot;&lt;CFKeyedArchiverUID 0x103002a80 [0x7fff7ab33bb0]&gt;{value = 1}&quot;;<br>&gt;     };<br>&gt;     &quot;$version&quot; = 100000;<br>&gt; }<br>&gt; <br>&gt; Note the $classes and $classname objects; which are what tell the internal implementation of NSKeyedUnarchiver what to construct; moreover you can create your own classes..<br>&gt; <br>&gt; // I don’t really think this is a good naming for an application’s class but hey it might happen...<br>&gt; class NSUUID : NSObject, NSCoding {<br>&gt;     let uuid: Foundation.NSUUID<br>&gt;     required init?(coder aDecoder: NSCoder) {<br>&gt;         uuid = aDecoder.decodeObjectForKey(&quot;my.uuid&quot;) as! Foundation.NSUUID<br>&gt;     }<br>&gt;     override init() {<br>&gt;         uuid = Foundation.NSUUID()<br>&gt;     }<br>&gt;     func encodeWithCoder(aCoder: NSCoder) {<br>&gt;         aCoder.encodeObject(uuid, forKey: &quot;my.uuid&quot;)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let uuid = NSUUID()<br>&gt; let data = NSKeyedArchiver.archivedDataWithRootObject(uuid)<br>&gt; let archive = try! NSPropertyListSerialization.propertyListWithData(data, options: [], format: nil)<br>&gt; print(archive)<br>&gt; <br>&gt; prints the following:<br>&gt; <br>&gt; {<br>&gt;     &quot;$archiver&quot; = NSKeyedArchiver;<br>&gt;     &quot;$objects&quot; =     (<br>&gt;         &quot;$null&quot;,<br>&gt;                 {<br>&gt;             &quot;$class&quot; = &quot;&lt;CFKeyedArchiverUID 0x100709630 [0x7fff7ab33bb0]&gt;{value = 4}&quot;;<br>&gt;             &quot;my.uuid&quot; = &quot;&lt;CFKeyedArchiverUID 0x100708e60 [0x7fff7ab33bb0]&gt;{value = 2}&quot;;<br>&gt;         },<br>&gt;                 {<br>&gt;             &quot;$class&quot; = &quot;&lt;CFKeyedArchiverUID 0x100709740 [0x7fff7ab33bb0]&gt;{value = 3}&quot;;<br>&gt;             &quot;NS.uuidbytes&quot; = &lt;546e5b5e 15c244a1 aa96eb90 30c3f7f6&gt;;<br>&gt;         },<br>&gt;                 {<br>&gt;             &quot;$classes&quot; =             (<br>&gt;                 NSUUID,<br>&gt;                 NSObject<br>&gt;             );<br>&gt;             &quot;$classname&quot; = NSUUID;<br>&gt;         },<br>&gt;                 {<br>&gt;             &quot;$classes&quot; =             (<br>&gt;                 &quot;Archiver.NSUUID&quot;,<br>&gt;                 NSObject<br>&gt;             );<br>&gt;             &quot;$classname&quot; = &quot;Archiver.NSUUID&quot;;<br>&gt;         }<br>&gt;     );<br>&gt;     &quot;$top&quot; =     {<br>&gt;         root = &quot;&lt;CFKeyedArchiverUID 0x100709b70 [0x7fff7ab33bb0]&gt;{value = 1}&quot;;<br>&gt;     };<br>&gt;     &quot;$version&quot; = 100000;<br>&gt; }<br>&gt; <br>&gt; Granted this is a questionable name for a class but it illustrates which class names are encoded where and how they should be interpreted in the pre-existing archive format; which we will have to figure out some sensible way of inflating and deflating to/from disk/network etc.<br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 2:37 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; No, we cannot encode things &quot;non-mangled but with the namespace&quot;. For any type other than top-level non-generic class types, using a non-mangled name is not unique. The only correct answer for arbitrary classes is to use mangled names, or something that maps one-to-one with mangled names.<br>&gt;&gt; <br>&gt;&gt; Now, Foundation classes are not arbitrary classes, but then I don&#39;t see why we&#39;d need to use mangled names for those. We can just use the plain old Objective-C names that the OS X classes use today.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 22, 2015, at 10:16, Philippe Hausler via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To clarify the goals: I think it is reasonable for us to have a goal to be able to encode/decode archives from foreign targets; e.g. linux encodes an archive and mac os x decodes or iOS encodes and linux decodes. This will allow for server architecture to transmit binary archives across the wire. This will mean that we will want to have the encoded class names from the application scope to be encoded as the non mangled name but with the namespace. However this presents a problem; Foundation will have a namespace which will need to be inferred both for encoding and decoding. Thankfully there may be a reasonable way to approach this;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public class func classNameForClass(cls: AnyClass) -&gt; String?<br>&gt;&gt;&gt; public class func setClassName(codedName: String?, forClass cls: AnyClass)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These methods can be used to allow for translation of classes by registering the appropriate classes for a “shortened” name that drops the Foundation/SwiftFoundation namespace prefix during encoding.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 22, 2015, at 2:45 AM, Luke Howard via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 22 Dec 2015, at 5:50 AM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; IMHO on Linux NSKeyedArchiver should always use mangled names. If we want cross-platform archives, we should set up standard substitutions, but given that Swift classes exposed to Objective-C are archived with their full names it doesn&#39;t make sense to use &quot;half the name&quot; in the archive.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You mean namespaced but unmangled yes? If so I agree.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; BTW I found a couple of small CF nits:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * in CFDictionaryGetKeysAndValues(), keybuf and valuebuf are transposed in the call to CF_SWIFT_FUNCDISPATCHV(NSDictionary.getObjects())<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * _CFSwiftDictionaryGetKeysAndValues() does not handle keybuf or valbuf being NULL (either of which are valid when calling CFDictionaryGetKeysAndValues())<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a bit un-related to NSCoding and the transposition is probably a mistake if it is inverted (the CF method should be reversed from the NS method to mimic the objc counterpart)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; — Luke<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt;&gt;&gt; swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev &lt;https://lists.swift.org/mailman/listinfo/swift-corelibs-dev&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt;&gt; swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev &lt;https://lists.swift.org/mailman/listinfo/swift-corelibs-dev&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151223/5542ee5a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>NSCoding methods</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>December 23, 2015 at 03:00:00pm</p></header><div class="content"><p>NSCoding will have to use something to transform from strings to classes, and that satisfy the two cases (or more) that we have already shown, currently there is no thing that does that in either form; either mangled or non mangled. Basically we need something to implement NSClassFromString with. Which we have clearly shown that dlsym does not fully meet the needs since there are cases that will emit as “module.classname” and others that emit as the mangled name. The simple case is probably going to be the a very common usage pattern for consumers (and of previously built applications). The inner class should definitely be handled in addition to this case.<br></p><p>Are there any methods that can fetch the name (either the symbolic or the readable) given a AnyClass in the runtime to get work started here? I think it is definitely sensible as a start to restrict this just to descendants of the class NSObject. I would presume that since the Metadata is potentially volatile contents we should use something along the lines of swift_getTypeName etc?<br></p><p>&gt; On Dec 23, 2015, at 2:53 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; Here&#39;s another example on OS X:<br>&gt; <br>&gt; import Foundation<br>&gt; <br>&gt; class Outer {<br>&gt;     class Inner : NSObject, NSCoding {<br>&gt;         let uuid: Foundation.NSUUID<br>&gt;         required init?(coder aDecoder: NSCoder) {<br>&gt;             uuid = aDecoder.decodeObjectForKey(&quot;my.uuid&quot;) as! Foundation.NSUUID<br>&gt;         }<br>&gt;         override init() {<br>&gt;             uuid = Foundation.NSUUID()<br>&gt;         }<br>&gt;         func encodeWithCoder(aCoder: NSCoder) {<br>&gt;             aCoder.encodeObject(uuid, forKey: &quot;my.uuid&quot;)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; NSKeyedArchiver.archiveRootObject(Outer.Inner(), toFile: &quot;/Users/jrose/Desktop/test-archive&quot;)<br>&gt; <br>&gt; <br>&gt; Which results in this archive:<br>&gt; <br>&gt; {<br>&gt;   &quot;$version&quot; =&gt; 100000<br>&gt;   &quot;$objects&quot; =&gt; [<br>&gt;     0 =&gt; &quot;$null&quot;<br>&gt;     1 =&gt; {<br>&gt;       &quot;my.uuid&quot; =&gt; &lt;CFKeyedArchiverUID 0x7f8992c0e9d0 [0x7fff7c5acd80]&gt;{value = 2}<br>&gt;       &quot;$class&quot; =&gt; &lt;CFKeyedArchiverUID 0x7f8992c0ec90 [0x7fff7c5acd80]&gt;{value = 4}<br>&gt;     }<br>&gt;     2 =&gt; {<br>&gt;       &quot;NS.uuidbytes&quot; =&gt; &lt;67f0b08b c8274f8c b0c78d90 bd4627dc&gt;<br>&gt;       &quot;$class&quot; =&gt; &lt;CFKeyedArchiverUID 0x7f8992c0eda0 [0x7fff7c5acd80]&gt;{value = 3}<br>&gt;     }<br>&gt;     3 =&gt; {<br>&gt;       &quot;$classname&quot; =&gt; &quot;NSUUID&quot;<br>&gt;       &quot;$classes&quot; =&gt; [<br>&gt;         0 =&gt; &quot;NSUUID&quot;<br>&gt;         1 =&gt; &quot;NSObject&quot;<br>&gt;       ]<br>&gt;     }<br>&gt;     4 =&gt; {<br>&gt;       &quot;$classname&quot; =&gt; &quot;_TtCC4main5Outer5Inner&quot;<br>&gt;       &quot;$classes&quot; =&gt; [<br>&gt;         0 =&gt; &quot;_TtCC4main5Outer5Inner&quot;<br>&gt;         1 =&gt; &quot;NSObject&quot;<br>&gt;       ]<br>&gt;     }<br>&gt;   ]<br>&gt;   &quot;$archiver&quot; =&gt; &quot;NSKeyedArchiver&quot;<br>&gt;   &quot;$top&quot; =&gt; {<br>&gt;     &quot;root&quot; =&gt; &lt;CFKeyedArchiverUID 0x7f8992c0f0c0 [0x7fff7c5acd80]&gt;{value = 1}<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; NSStringFromClass makes pretty names when they fall into the &quot;simple&quot; category, but that&#39;s not an arbitrarily extensible transformation, and NSCoding shouldn&#39;t have to know anything about it.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 14:48, Philippe Hausler &lt;phausler at apple.com &lt;mailto:phausler at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The archiving format encodes the names of the classes in the archive itself. Here are a few code examples and a quasi readable output from them:<br>&gt;&gt; <br>&gt;&gt; let uuid = NSUUID()<br>&gt;&gt; let data = NSKeyedArchiver.archivedDataWithRootObject(uuid)<br>&gt;&gt; let archive = try! NSPropertyListSerialization.propertyListWithData(data, options: [], format: nil)<br>&gt;&gt; print(archive)<br>&gt;&gt; <br>&gt;&gt; prints the following:<br>&gt;&gt; <br>&gt;&gt; {<br>&gt;&gt;     &quot;$archiver&quot; = NSKeyedArchiver;<br>&gt;&gt;     &quot;$objects&quot; =     (<br>&gt;&gt;         &quot;$null&quot;,<br>&gt;&gt;                 {<br>&gt;&gt;             &quot;$class&quot; = &quot;&lt;CFKeyedArchiverUID 0x1030025e0 [0x7fff7ab33bb0]&gt;{value = 2}&quot;;<br>&gt;&gt;             &quot;NS.uuidbytes&quot; = &lt;797639fe dad74b14 902afab3 c490448b&gt;;<br>&gt;&gt;         },<br>&gt;&gt;                 {<br>&gt;&gt;             &quot;$classes&quot; =             (<br>&gt;&gt;                 NSUUID,<br>&gt;&gt;                 NSObject<br>&gt;&gt;             );<br>&gt;&gt;             &quot;$classname&quot; = NSUUID;<br>&gt;&gt;         }<br>&gt;&gt;     );<br>&gt;&gt;     &quot;$top&quot; =     {<br>&gt;&gt;         root = &quot;&lt;CFKeyedArchiverUID 0x103002a80 [0x7fff7ab33bb0]&gt;{value = 1}&quot;;<br>&gt;&gt;     };<br>&gt;&gt;     &quot;$version&quot; = 100000;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Note the $classes and $classname objects; which are what tell the internal implementation of NSKeyedUnarchiver what to construct; moreover you can create your own classes..<br>&gt;&gt; <br>&gt;&gt; // I don’t really think this is a good naming for an application’s class but hey it might happen...<br>&gt;&gt; class NSUUID : NSObject, NSCoding {<br>&gt;&gt;     let uuid: Foundation.NSUUID<br>&gt;&gt;     required init?(coder aDecoder: NSCoder) {<br>&gt;&gt;         uuid = aDecoder.decodeObjectForKey(&quot;my.uuid&quot;) as! Foundation.NSUUID<br>&gt;&gt;     }<br>&gt;&gt;     override init() {<br>&gt;&gt;         uuid = Foundation.NSUUID()<br>&gt;&gt;     }<br>&gt;&gt;     func encodeWithCoder(aCoder: NSCoder) {<br>&gt;&gt;         aCoder.encodeObject(uuid, forKey: &quot;my.uuid&quot;)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let uuid = NSUUID()<br>&gt;&gt; let data = NSKeyedArchiver.archivedDataWithRootObject(uuid)<br>&gt;&gt; let archive = try! NSPropertyListSerialization.propertyListWithData(data, options: [], format: nil)<br>&gt;&gt; print(archive)<br>&gt;&gt; <br>&gt;&gt; prints the following:<br>&gt;&gt; <br>&gt;&gt; {<br>&gt;&gt;     &quot;$archiver&quot; = NSKeyedArchiver;<br>&gt;&gt;     &quot;$objects&quot; =     (<br>&gt;&gt;         &quot;$null&quot;,<br>&gt;&gt;                 {<br>&gt;&gt;             &quot;$class&quot; = &quot;&lt;CFKeyedArchiverUID 0x100709630 [0x7fff7ab33bb0]&gt;{value = 4}&quot;;<br>&gt;&gt;             &quot;my.uuid&quot; = &quot;&lt;CFKeyedArchiverUID 0x100708e60 [0x7fff7ab33bb0]&gt;{value = 2}&quot;;<br>&gt;&gt;         },<br>&gt;&gt;                 {<br>&gt;&gt;             &quot;$class&quot; = &quot;&lt;CFKeyedArchiverUID 0x100709740 [0x7fff7ab33bb0]&gt;{value = 3}&quot;;<br>&gt;&gt;             &quot;NS.uuidbytes&quot; = &lt;546e5b5e 15c244a1 aa96eb90 30c3f7f6&gt;;<br>&gt;&gt;         },<br>&gt;&gt;                 {<br>&gt;&gt;             &quot;$classes&quot; =             (<br>&gt;&gt;                 NSUUID,<br>&gt;&gt;                 NSObject<br>&gt;&gt;             );<br>&gt;&gt;             &quot;$classname&quot; = NSUUID;<br>&gt;&gt;         },<br>&gt;&gt;                 {<br>&gt;&gt;             &quot;$classes&quot; =             (<br>&gt;&gt;                 &quot;Archiver.NSUUID&quot;,<br>&gt;&gt;                 NSObject<br>&gt;&gt;             );<br>&gt;&gt;             &quot;$classname&quot; = &quot;Archiver.NSUUID&quot;;<br>&gt;&gt;         }<br>&gt;&gt;     );<br>&gt;&gt;     &quot;$top&quot; =     {<br>&gt;&gt;         root = &quot;&lt;CFKeyedArchiverUID 0x100709b70 [0x7fff7ab33bb0]&gt;{value = 1}&quot;;<br>&gt;&gt;     };<br>&gt;&gt;     &quot;$version&quot; = 100000;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Granted this is a questionable name for a class but it illustrates which class names are encoded where and how they should be interpreted in the pre-existing archive format; which we will have to figure out some sensible way of inflating and deflating to/from disk/network etc.<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 23, 2015, at 2:37 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, we cannot encode things &quot;non-mangled but with the namespace&quot;. For any type other than top-level non-generic class types, using a non-mangled name is not unique. The only correct answer for arbitrary classes is to use mangled names, or something that maps one-to-one with mangled names.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now, Foundation classes are not arbitrary classes, but then I don&#39;t see why we&#39;d need to use mangled names for those. We can just use the plain old Objective-C names that the OS X classes use today.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 22, 2015, at 10:16, Philippe Hausler via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To clarify the goals: I think it is reasonable for us to have a goal to be able to encode/decode archives from foreign targets; e.g. linux encodes an archive and mac os x decodes or iOS encodes and linux decodes. This will allow for server architecture to transmit binary archives across the wire. This will mean that we will want to have the encoded class names from the application scope to be encoded as the non mangled name but with the namespace. However this presents a problem; Foundation will have a namespace which will need to be inferred both for encoding and decoding. Thankfully there may be a reasonable way to approach this;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public class func classNameForClass(cls: AnyClass) -&gt; String?<br>&gt;&gt;&gt;&gt; public class func setClassName(codedName: String?, forClass cls: AnyClass)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; These methods can be used to allow for translation of classes by registering the appropriate classes for a “shortened” name that drops the Foundation/SwiftFoundation namespace prefix during encoding.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 2:45 AM, Luke Howard via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 22 Dec 2015, at 5:50 AM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; IMHO on Linux NSKeyedArchiver should always use mangled names. If we want cross-platform archives, we should set up standard substitutions, but given that Swift classes exposed to Objective-C are archived with their full names it doesn&#39;t make sense to use &quot;half the name&quot; in the archive.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You mean namespaced but unmangled yes? If so I agree.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; BTW I found a couple of small CF nits:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * in CFDictionaryGetKeysAndValues(), keybuf and valuebuf are transposed in the call to CF_SWIFT_FUNCDISPATCHV(NSDictionary.getObjects())<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * _CFSwiftDictionaryGetKeysAndValues() does not handle keybuf or valbuf being NULL (either of which are valid when calling CFDictionaryGetKeysAndValues())<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a bit un-related to NSCoding and the transposition is probably a mistake if it is inverted (the CF method should be reversed from the NS method to mimic the objc counterpart)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; — Luke<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev &lt;https://lists.swift.org/mailman/listinfo/swift-corelibs-dev&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt;&gt;&gt; swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev &lt;https://lists.swift.org/mailman/listinfo/swift-corelibs-dev&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151223/109d3c6c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>NSCoding methods</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 23, 2015 at 03:00:00pm</p></header><div class="content"><p>&quot;We need to get ahold of a class given a name&quot; is definitely a requirement to do NSCoding right. I&#39;m not at all convinced dlsym is a valid long-term answer for that, though. If you have an &#39;internal&#39; class, it doesn&#39;t (currently) have a public symbol that you can use dlsym for.<br></p><p>This sort of goes with the existing problem of static registration: there&#39;s no pure Swift way to get all subclasses of a class, or to get a class from a name for any other reason. That&#39;s a general language problem, though, and we should discuss it on swift-dev.<br></p><p>Jordan<br></p><p><br>&gt; On Dec 23, 2015, at 15:12, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt; NSCoding will have to use something to transform from strings to classes, and that satisfy the two cases (or more) that we have already shown, currently there is no thing that does that in either form; either mangled or non mangled. Basically we need something to implement NSClassFromString with. Which we have clearly shown that dlsym does not fully meet the needs since there are cases that will emit as “module.classname” and others that emit as the mangled name. The simple case is probably going to be the a very common usage pattern for consumers (and of previously built applications). The inner class should definitely be handled in addition to this case.<br>&gt; <br>&gt; Are there any methods that can fetch the name (either the symbolic or the readable) given a AnyClass in the runtime to get work started here? I think it is definitely sensible as a start to restrict this just to descendants of the class NSObject. I would presume that since the Metadata is potentially volatile contents we should use something along the lines of swift_getTypeName etc?<br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 2:53 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Here&#39;s another example on OS X:<br>&gt;&gt; <br>&gt;&gt; import Foundation<br>&gt;&gt; <br>&gt;&gt; class Outer {<br>&gt;&gt;     class Inner : NSObject, NSCoding {<br>&gt;&gt;         let uuid: Foundation.NSUUID<br>&gt;&gt;         required init?(coder aDecoder: NSCoder) {<br>&gt;&gt;             uuid = aDecoder.decodeObjectForKey(&quot;my.uuid&quot;) as! Foundation.NSUUID<br>&gt;&gt;         }<br>&gt;&gt;         override init() {<br>&gt;&gt;             uuid = Foundation.NSUUID()<br>&gt;&gt;         }<br>&gt;&gt;         func encodeWithCoder(aCoder: NSCoder) {<br>&gt;&gt;             aCoder.encodeObject(uuid, forKey: &quot;my.uuid&quot;)<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; NSKeyedArchiver.archiveRootObject(Outer.Inner(), toFile: &quot;/Users/jrose/Desktop/test-archive&quot;)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Which results in this archive:<br>&gt;&gt; <br>&gt;&gt; {<br>&gt;&gt;   &quot;$version&quot; =&gt; 100000<br>&gt;&gt;   &quot;$objects&quot; =&gt; [<br>&gt;&gt;     0 =&gt; &quot;$null&quot;<br>&gt;&gt;     1 =&gt; {<br>&gt;&gt;       &quot;my.uuid&quot; =&gt; &lt;CFKeyedArchiverUID 0x7f8992c0e9d0 [0x7fff7c5acd80]&gt;{value = 2}<br>&gt;&gt;       &quot;$class&quot; =&gt; &lt;CFKeyedArchiverUID 0x7f8992c0ec90 [0x7fff7c5acd80]&gt;{value = 4}<br>&gt;&gt;     }<br>&gt;&gt;     2 =&gt; {<br>&gt;&gt;       &quot;NS.uuidbytes&quot; =&gt; &lt;67f0b08b c8274f8c b0c78d90 bd4627dc&gt;<br>&gt;&gt;       &quot;$class&quot; =&gt; &lt;CFKeyedArchiverUID 0x7f8992c0eda0 [0x7fff7c5acd80]&gt;{value = 3}<br>&gt;&gt;     }<br>&gt;&gt;     3 =&gt; {<br>&gt;&gt;       &quot;$classname&quot; =&gt; &quot;NSUUID&quot;<br>&gt;&gt;       &quot;$classes&quot; =&gt; [<br>&gt;&gt;         0 =&gt; &quot;NSUUID&quot;<br>&gt;&gt;         1 =&gt; &quot;NSObject&quot;<br>&gt;&gt;       ]<br>&gt;&gt;     }<br>&gt;&gt;     4 =&gt; {<br>&gt;&gt;       &quot;$classname&quot; =&gt; &quot;_TtCC4main5Outer5Inner&quot;<br>&gt;&gt;       &quot;$classes&quot; =&gt; [<br>&gt;&gt;         0 =&gt; &quot;_TtCC4main5Outer5Inner&quot;<br>&gt;&gt;         1 =&gt; &quot;NSObject&quot;<br>&gt;&gt;       ]<br>&gt;&gt;     }<br>&gt;&gt;   ]<br>&gt;&gt;   &quot;$archiver&quot; =&gt; &quot;NSKeyedArchiver&quot;<br>&gt;&gt;   &quot;$top&quot; =&gt; {<br>&gt;&gt;     &quot;root&quot; =&gt; &lt;CFKeyedArchiverUID 0x7f8992c0f0c0 [0x7fff7c5acd80]&gt;{value = 1}<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; NSStringFromClass makes pretty names when they fall into the &quot;simple&quot; category, but that&#39;s not an arbitrarily extensible transformation, and NSCoding shouldn&#39;t have to know anything about it.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 23, 2015, at 14:48, Philippe Hausler &lt;phausler at apple.com &lt;mailto:phausler at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The archiving format encodes the names of the classes in the archive itself. Here are a few code examples and a quasi readable output from them:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let uuid = NSUUID()<br>&gt;&gt;&gt; let data = NSKeyedArchiver.archivedDataWithRootObject(uuid)<br>&gt;&gt;&gt; let archive = try! NSPropertyListSerialization.propertyListWithData(data, options: [], format: nil)<br>&gt;&gt;&gt; print(archive)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; prints the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;     &quot;$archiver&quot; = NSKeyedArchiver;<br>&gt;&gt;&gt;     &quot;$objects&quot; =     (<br>&gt;&gt;&gt;         &quot;$null&quot;,<br>&gt;&gt;&gt;                 {<br>&gt;&gt;&gt;             &quot;$class&quot; = &quot;&lt;CFKeyedArchiverUID 0x1030025e0 [0x7fff7ab33bb0]&gt;{value = 2}&quot;;<br>&gt;&gt;&gt;             &quot;NS.uuidbytes&quot; = &lt;797639fe dad74b14 902afab3 c490448b&gt;;<br>&gt;&gt;&gt;         },<br>&gt;&gt;&gt;                 {<br>&gt;&gt;&gt;             &quot;$classes&quot; =             (<br>&gt;&gt;&gt;                 NSUUID,<br>&gt;&gt;&gt;                 NSObject<br>&gt;&gt;&gt;             );<br>&gt;&gt;&gt;             &quot;$classname&quot; = NSUUID;<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     );<br>&gt;&gt;&gt;     &quot;$top&quot; =     {<br>&gt;&gt;&gt;         root = &quot;&lt;CFKeyedArchiverUID 0x103002a80 [0x7fff7ab33bb0]&gt;{value = 1}&quot;;<br>&gt;&gt;&gt;     };<br>&gt;&gt;&gt;     &quot;$version&quot; = 100000;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note the $classes and $classname objects; which are what tell the internal implementation of NSKeyedUnarchiver what to construct; moreover you can create your own classes..<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // I don’t really think this is a good naming for an application’s class but hey it might happen...<br>&gt;&gt;&gt; class NSUUID : NSObject, NSCoding {<br>&gt;&gt;&gt;     let uuid: Foundation.NSUUID<br>&gt;&gt;&gt;     required init?(coder aDecoder: NSCoder) {<br>&gt;&gt;&gt;         uuid = aDecoder.decodeObjectForKey(&quot;my.uuid&quot;) as! Foundation.NSUUID<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     override init() {<br>&gt;&gt;&gt;         uuid = Foundation.NSUUID()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     func encodeWithCoder(aCoder: NSCoder) {<br>&gt;&gt;&gt;         aCoder.encodeObject(uuid, forKey: &quot;my.uuid&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let uuid = NSUUID()<br>&gt;&gt;&gt; let data = NSKeyedArchiver.archivedDataWithRootObject(uuid)<br>&gt;&gt;&gt; let archive = try! NSPropertyListSerialization.propertyListWithData(data, options: [], format: nil)<br>&gt;&gt;&gt; print(archive)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; prints the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;     &quot;$archiver&quot; = NSKeyedArchiver;<br>&gt;&gt;&gt;     &quot;$objects&quot; =     (<br>&gt;&gt;&gt;         &quot;$null&quot;,<br>&gt;&gt;&gt;                 {<br>&gt;&gt;&gt;             &quot;$class&quot; = &quot;&lt;CFKeyedArchiverUID 0x100709630 [0x7fff7ab33bb0]&gt;{value = 4}&quot;;<br>&gt;&gt;&gt;             &quot;my.uuid&quot; = &quot;&lt;CFKeyedArchiverUID 0x100708e60 [0x7fff7ab33bb0]&gt;{value = 2}&quot;;<br>&gt;&gt;&gt;         },<br>&gt;&gt;&gt;                 {<br>&gt;&gt;&gt;             &quot;$class&quot; = &quot;&lt;CFKeyedArchiverUID 0x100709740 [0x7fff7ab33bb0]&gt;{value = 3}&quot;;<br>&gt;&gt;&gt;             &quot;NS.uuidbytes&quot; = &lt;546e5b5e 15c244a1 aa96eb90 30c3f7f6&gt;;<br>&gt;&gt;&gt;         },<br>&gt;&gt;&gt;                 {<br>&gt;&gt;&gt;             &quot;$classes&quot; =             (<br>&gt;&gt;&gt;                 NSUUID,<br>&gt;&gt;&gt;                 NSObject<br>&gt;&gt;&gt;             );<br>&gt;&gt;&gt;             &quot;$classname&quot; = NSUUID;<br>&gt;&gt;&gt;         },<br>&gt;&gt;&gt;                 {<br>&gt;&gt;&gt;             &quot;$classes&quot; =             (<br>&gt;&gt;&gt;                 &quot;Archiver.NSUUID&quot;,<br>&gt;&gt;&gt;                 NSObject<br>&gt;&gt;&gt;             );<br>&gt;&gt;&gt;             &quot;$classname&quot; = &quot;Archiver.NSUUID&quot;;<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     );<br>&gt;&gt;&gt;     &quot;$top&quot; =     {<br>&gt;&gt;&gt;         root = &quot;&lt;CFKeyedArchiverUID 0x100709b70 [0x7fff7ab33bb0]&gt;{value = 1}&quot;;<br>&gt;&gt;&gt;     };<br>&gt;&gt;&gt;     &quot;$version&quot; = 100000;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Granted this is a questionable name for a class but it illustrates which class names are encoded where and how they should be interpreted in the pre-existing archive format; which we will have to figure out some sensible way of inflating and deflating to/from disk/network etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 23, 2015, at 2:37 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No, we cannot encode things &quot;non-mangled but with the namespace&quot;. For any type other than top-level non-generic class types, using a non-mangled name is not unique. The only correct answer for arbitrary classes is to use mangled names, or something that maps one-to-one with mangled names.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now, Foundation classes are not arbitrary classes, but then I don&#39;t see why we&#39;d need to use mangled names for those. We can just use the plain old Objective-C names that the OS X classes use today.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 10:16, Philippe Hausler via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To clarify the goals: I think it is reasonable for us to have a goal to be able to encode/decode archives from foreign targets; e.g. linux encodes an archive and mac os x decodes or iOS encodes and linux decodes. This will allow for server architecture to transmit binary archives across the wire. This will mean that we will want to have the encoded class names from the application scope to be encoded as the non mangled name but with the namespace. However this presents a problem; Foundation will have a namespace which will need to be inferred both for encoding and decoding. Thankfully there may be a reasonable way to approach this;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; public class func classNameForClass(cls: AnyClass) -&gt; String?<br>&gt;&gt;&gt;&gt;&gt; public class func setClassName(codedName: String?, forClass cls: AnyClass)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; These methods can be used to allow for translation of classes by registering the appropriate classes for a “shortened” name that drops the Foundation/SwiftFoundation namespace prefix during encoding.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 2:45 AM, Luke Howard via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 22 Dec 2015, at 5:50 AM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; IMHO on Linux NSKeyedArchiver should always use mangled names. If we want cross-platform archives, we should set up standard substitutions, but given that Swift classes exposed to Objective-C are archived with their full names it doesn&#39;t make sense to use &quot;half the name&quot; in the archive.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; You mean namespaced but unmangled yes? If so I agree.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; BTW I found a couple of small CF nits:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * in CFDictionaryGetKeysAndValues(), keybuf and valuebuf are transposed in the call to CF_SWIFT_FUNCDISPATCHV(NSDictionary.getObjects())<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * _CFSwiftDictionaryGetKeysAndValues() does not handle keybuf or valbuf being NULL (either of which are valid when calling CFDictionaryGetKeysAndValues())<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is a bit un-related to NSCoding and the transposition is probably a mistake if it is inverted (the CF method should be reversed from the NS method to mimic the objc counterpart)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; — Luke<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev &lt;https://lists.swift.org/mailman/listinfo/swift-corelibs-dev&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev &lt;https://lists.swift.org/mailman/listinfo/swift-corelibs-dev&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151223/8bad4026/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 24, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On 24 Dec 2015, at 10:12 AM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt; NSCoding will have to use something to transform from strings to classes, and that satisfy the two cases (or more) that we have already shown, currently there is no thing that does that in either form; either mangled or non mangled. Basically we need something to implement NSClassFromString with. Which we have clearly shown that dlsym does not fully meet the needs since there are cases that will emit as “module.classname” and others that emit as the mangled name. The simple case is probably going to be the a very common usage pattern for consumers (and of previously built applications). The inner class should definitely be handled in addition to this case.<br></p><p>* If the mangled name is present in the archive, you can re-mangle it to get the metadata accessor<br>* If it’s a one-level unmangled name representing a class, it can be mangled<br>* If it’s a zero-level unmangled name, then it seems reasonable for a first implementation to assume it’s a SwiftFoundation class (or that the caller has set an explicit mapping)<br></p><p>Noted that dlsym() will only work with public symbols.<br></p><p>&gt; Are there any methods that can fetch the name (either the symbolic or the readable) given a AnyClass in the runtime to get work started here? I think it is definitely sensible as a start to restrict this just to descendants of the class NSObject. I would presume that since the Metadata is potentially volatile contents we should use something along the lines of swift_getTypeName etc?<br></p><p><br>I have been using _typeName() but it always demangles – for interop with existing archives we need to match the behaviour of libobjc&#39;s class_getName() (equivalent to NSStringFromClass), which appears to demangle one-level classes.<br></p><p>— Luke<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151224/ce91a033/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>NSCoding methods</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>December 23, 2015 at 04:00:00pm</p></header><div class="content"><p>So one thing we can do in the interim until there is a sanctioned way for us to convert strings to classes and classes to strings is we can register the classes globally for transformation so that the Foundation or SwiftFoundation module name won’t be an issue.<br></p><p>By doing this early on in the initialization for NSKeyedArchiver, once of course.<br></p><p>    NSKeyedArchiver.setClassName(&quot;NSArray&quot;, forClass: NSArray.self)<br>    NSKeyedArchiver.setClassName(&quot;NSByteCountFormatter&quot;, forClass: NSByteCountFormatter.self)<br>    NSKeyedArchiver.setClassName(&quot;NSData&quot;, forClass: NSData.self)<br>    NSKeyedArchiver.setClassName(&quot;NSDate&quot;, forClass: NSDate.self)<br>    NSKeyedArchiver.setClassName(&quot;NSDateFormatter&quot;, forClass: NSDateFormatter.self)<br>    NSKeyedArchiver.setClassName(&quot;NSDateIntervalFormatter&quot;, forClass: NSDateIntervalFormatter.self)<br>    NSKeyedArchiver.setClassName(&quot;NSDecimalNumber&quot;, forClass: NSDecimalNumber.self)<br>    NSKeyedArchiver.setClassName(&quot;NSDictionary&quot;, forClass: NSDictionary.self)<br>    NSKeyedArchiver.setClassName(&quot;NSEnergyFormatter&quot;, forClass: NSEnergyFormatter.self)<br>    NSKeyedArchiver.setClassName(&quot;NSFormatter&quot;, forClass: NSFormatter.self)<br>    NSKeyedArchiver.setClassName(&quot;NSLengthFormatter&quot;, forClass: NSLengthFormatter.self)<br>    NSKeyedArchiver.setClassName(&quot;NSMassFormatter&quot;, forClass: NSMassFormatter.self)<br>    NSKeyedArchiver.setClassName(&quot;NSMessagePort&quot;, forClass: NSMessagePort.self)<br>    NSKeyedArchiver.setClassName(&quot;NSMutableArray&quot;, forClass: NSMutableArray.self)<br>    NSKeyedArchiver.setClassName(&quot;NSMutableData&quot;, forClass: NSMutableData.self)<br>    NSKeyedArchiver.setClassName(&quot;NSMutableDictionary&quot;, forClass: NSMutableDictionary.self)<br>    NSKeyedArchiver.setClassName(&quot;NSMutableSet&quot;, forClass: NSMutableSet.self)<br>    NSKeyedArchiver.setClassName(&quot;NSMutableString&quot;, forClass: NSMutableString.self)<br>    NSKeyedArchiver.setClassName(&quot;NSNotification&quot;, forClass: NSNotification.self)<br>    NSKeyedArchiver.setClassName(&quot;NSNumber&quot;, forClass: NSNumber.self)<br>    NSKeyedArchiver.setClassName(&quot;NSNumberFormatter&quot;, forClass: NSNumberFormatter.self)<br>    NSKeyedArchiver.setClassName(&quot;NSPersonNameComponentsFormatter&quot;, forClass: NSPersonNameComponentsFormatter.self)<br>    NSKeyedArchiver.setClassName(&quot;NSPort&quot;, forClass: NSPort.self)<br>    NSKeyedArchiver.setClassName(&quot;NSRegularExpression&quot;, forClass: NSRegularExpression.self)<br>    NSKeyedArchiver.setClassName(&quot;NSSet&quot;, forClass: NSSet.self)<br>    NSKeyedArchiver.setClassName(&quot;NSSocketPort&quot;, forClass: NSSocketPort.self)<br>    NSKeyedArchiver.setClassName(&quot;NSString&quot;, forClass: NSString.self)<br>    NSKeyedArchiver.setClassName(&quot;NSTextCheckingResult&quot;, forClass: NSTextCheckingResult.self)<br>    NSKeyedArchiver.setClassName(&quot;NSTimeZone&quot;, forClass: NSTimeZone.self)<br>    NSKeyedArchiver.setClassName(&quot;NSUUID&quot;, forClass: NSUUID.self)<br>    NSKeyedArchiver.setClassName(&quot;NSValue&quot;, forClass: NSValue.self)<br></p><p>I have a few more things that I was looking at for supporting this that might be useful depending on how far along you are.<br></p><p>This should give us at least a head start on the NSCoding compliant Foundation classes and user classes can come next once we have support.<br></p><p>&gt; On Dec 23, 2015, at 3:33 PM, Luke Howard &lt;lukeh at padl.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On 24 Dec 2015, at 10:12 AM, Philippe Hausler &lt;phausler at apple.com &lt;mailto:phausler at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; NSCoding will have to use something to transform from strings to classes, and that satisfy the two cases (or more) that we have already shown, currently there is no thing that does that in either form; either mangled or non mangled. Basically we need something to implement NSClassFromString with. Which we have clearly shown that dlsym does not fully meet the needs since there are cases that will emit as “module.classname” and others that emit as the mangled name. The simple case is probably going to be the a very common usage pattern for consumers (and of previously built applications). The inner class should definitely be handled in addition to this case.<br>&gt; <br>&gt; * If the mangled name is present in the archive, you can re-mangle it to get the metadata accessor<br>&gt; * If it’s a one-level unmangled name representing a class, it can be mangled<br>&gt; * If it’s a zero-level unmangled name, then it seems reasonable for a first implementation to assume it’s a SwiftFoundation class (or that the caller has set an explicit mapping)<br>&gt; <br>&gt; Noted that dlsym() will only work with public symbols.<br>&gt; <br>&gt;&gt; Are there any methods that can fetch the name (either the symbolic or the readable) given a AnyClass in the runtime to get work started here? I think it is definitely sensible as a start to restrict this just to descendants of the class NSObject. I would presume that since the Metadata is potentially volatile contents we should use something along the lines of swift_getTypeName etc?<br>&gt; <br>&gt; <br>&gt; I have been using _typeName() but it always demangles – for interop with existing archives we need to match the behaviour of libobjc&#39;s class_getName() (equivalent to NSStringFromClass), which appears to demangle one-level classes.<br>&gt; <br>&gt; — Luke<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151223/5438b06d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 24, 2015 at 11:00:00am</p></header><div class="content"><p>My plan was just to map any flat unmangled names to SwiftFoundation classes without the boilerplate explicit mappings, but happy to change approaches.<br></p><p>That&#39;s what the code in the branch I posted yesterday does, but I need to fix it to encode the mangled name for non-one level class types - was planning to implement NSClassFromString/NSStringFromClass at the same time so at least the logic is in one place, and those can be refined over time.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 24 Dec 2015, at 11:07, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt; So one thing we can do in the interim until there is a sanctioned way for us to convert strings to classes and classes to strings is we can register the classes globally for transformation so that the Foundation or SwiftFoundation module name won’t be an issue.<br>&gt; <br>&gt; By doing this early on in the initialization for NSKeyedArchiver, once of course.<br>&gt; <br>&gt;     NSKeyedArchiver.setClassName(&quot;NSArray&quot;, forClass: NSArray.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSByteCountFormatter&quot;, forClass: NSByteCountFormatter.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSData&quot;, forClass: NSData.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSDate&quot;, forClass: NSDate.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSDateFormatter&quot;, forClass: NSDateFormatter.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSDateIntervalFormatter&quot;, forClass: NSDateIntervalFormatter.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSDecimalNumber&quot;, forClass: NSDecimalNumber.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSDictionary&quot;, forClass: NSDictionary.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSEnergyFormatter&quot;, forClass: NSEnergyFormatter.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSFormatter&quot;, forClass: NSFormatter.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSLengthFormatter&quot;, forClass: NSLengthFormatter.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSMassFormatter&quot;, forClass: NSMassFormatter.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSMessagePort&quot;, forClass: NSMessagePort.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSMutableArray&quot;, forClass: NSMutableArray.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSMutableData&quot;, forClass: NSMutableData.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSMutableDictionary&quot;, forClass: NSMutableDictionary.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSMutableSet&quot;, forClass: NSMutableSet.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSMutableString&quot;, forClass: NSMutableString.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSNotification&quot;, forClass: NSNotification.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSNumber&quot;, forClass: NSNumber.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSNumberFormatter&quot;, forClass: NSNumberFormatter.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSPersonNameComponentsFormatter&quot;, forClass: NSPersonNameComponentsFormatter.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSPort&quot;, forClass: NSPort.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSRegularExpression&quot;, forClass: NSRegularExpression.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSSet&quot;, forClass: NSSet.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSSocketPort&quot;, forClass: NSSocketPort.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSString&quot;, forClass: NSString.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSTextCheckingResult&quot;, forClass: NSTextCheckingResult.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSTimeZone&quot;, forClass: NSTimeZone.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSUUID&quot;, forClass: NSUUID.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSValue&quot;, forClass: NSValue.self)<br>&gt; <br>&gt; I have a few more things that I was looking at for supporting this that might be useful depending on how far along you are.<br>&gt; <br>&gt; This should give us at least a head start on the NSCoding compliant Foundation classes and user classes can come next once we have support.<br>&gt; <br>&gt;&gt;&gt; On Dec 23, 2015, at 3:33 PM, Luke Howard &lt;lukeh at padl.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 24 Dec 2015, at 10:12 AM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; NSCoding will have to use something to transform from strings to classes, and that satisfy the two cases (or more) that we have already shown, currently there is no thing that does that in either form; either mangled or non mangled. Basically we need something to implement NSClassFromString with. Which we have clearly shown that dlsym does not fully meet the needs since there are cases that will emit as “module.classname” and others that emit as the mangled name. The simple case is probably going to be the a very common usage pattern for consumers (and of previously built applications). The inner class should definitely be handled in addition to this case.<br>&gt;&gt; <br>&gt;&gt; * If the mangled name is present in the archive, you can re-mangle it to get the metadata accessor<br>&gt;&gt; * If it’s a one-level unmangled name representing a class, it can be mangled<br>&gt;&gt; * If it’s a zero-level unmangled name, then it seems reasonable for a first implementation to assume it’s a SwiftFoundation class (or that the caller has set an explicit mapping)<br>&gt;&gt; <br>&gt;&gt; Noted that dlsym() will only work with public symbols.<br>&gt;&gt; <br>&gt;&gt;&gt; Are there any methods that can fetch the name (either the symbolic or the readable) given a AnyClass in the runtime to get work started here? I think it is definitely sensible as a start to restrict this just to descendants of the class NSObject. I would presume that since the Metadata is potentially volatile contents we should use something along the lines of swift_getTypeName etc?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I have been using _typeName() but it always demangles – for interop with existing archives we need to match the behaviour of libobjc&#39;s class_getName() (equivalent to NSStringFromClass), which appears to demangle one-level classes.<br>&gt;&gt; <br>&gt;&gt; — Luke<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151224/a9677909/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 24, 2015 at 11:00:00am</p></header><div class="content"><p>My plan was just to map any flat unmangled names to SwiftFoundation classes without the boilerplate explicit mappings, but happy to change approaches.<br></p><p>That&#39;s what the code in the branch I posted yesterday does, but I need to fix it to encode the mangled name for non-one level class types - was planning to implement NSClassFromString/NSStringFromClass at the same time so at least the logic is in one place, and those can be refined over time.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 24 Dec 2015, at 11:07, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt; So one thing we can do in the interim until there is a sanctioned way for us to convert strings to classes and classes to strings is we can register the classes globally for transformation so that the Foundation or SwiftFoundation module name won’t be an issue.<br>&gt; <br>&gt; By doing this early on in the initialization for NSKeyedArchiver, once of course.<br>&gt; <br>&gt;     NSKeyedArchiver.setClassName(&quot;NSArray&quot;, forClass: NSArray.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSByteCountFormatter&quot;, forClass: NSByteCountFormatter.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSData&quot;, forClass: NSData.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSDate&quot;, forClass: NSDate.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSDateFormatter&quot;, forClass: NSDateFormatter.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSDateIntervalFormatter&quot;, forClass: NSDateIntervalFormatter.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSDecimalNumber&quot;, forClass: NSDecimalNumber.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSDictionary&quot;, forClass: NSDictionary.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSEnergyFormatter&quot;, forClass: NSEnergyFormatter.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSFormatter&quot;, forClass: NSFormatter.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSLengthFormatter&quot;, forClass: NSLengthFormatter.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSMassFormatter&quot;, forClass: NSMassFormatter.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSMessagePort&quot;, forClass: NSMessagePort.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSMutableArray&quot;, forClass: NSMutableArray.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSMutableData&quot;, forClass: NSMutableData.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSMutableDictionary&quot;, forClass: NSMutableDictionary.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSMutableSet&quot;, forClass: NSMutableSet.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSMutableString&quot;, forClass: NSMutableString.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSNotification&quot;, forClass: NSNotification.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSNumber&quot;, forClass: NSNumber.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSNumberFormatter&quot;, forClass: NSNumberFormatter.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSPersonNameComponentsFormatter&quot;, forClass: NSPersonNameComponentsFormatter.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSPort&quot;, forClass: NSPort.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSRegularExpression&quot;, forClass: NSRegularExpression.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSSet&quot;, forClass: NSSet.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSSocketPort&quot;, forClass: NSSocketPort.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSString&quot;, forClass: NSString.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSTextCheckingResult&quot;, forClass: NSTextCheckingResult.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSTimeZone&quot;, forClass: NSTimeZone.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSUUID&quot;, forClass: NSUUID.self)<br>&gt;     NSKeyedArchiver.setClassName(&quot;NSValue&quot;, forClass: NSValue.self)<br>&gt; <br>&gt; I have a few more things that I was looking at for supporting this that might be useful depending on how far along you are.<br>&gt; <br>&gt; This should give us at least a head start on the NSCoding compliant Foundation classes and user classes can come next once we have support.<br>&gt; <br>&gt;&gt;&gt; On Dec 23, 2015, at 3:33 PM, Luke Howard &lt;lukeh at padl.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 24 Dec 2015, at 10:12 AM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; NSCoding will have to use something to transform from strings to classes, and that satisfy the two cases (or more) that we have already shown, currently there is no thing that does that in either form; either mangled or non mangled. Basically we need something to implement NSClassFromString with. Which we have clearly shown that dlsym does not fully meet the needs since there are cases that will emit as “module.classname” and others that emit as the mangled name. The simple case is probably going to be the a very common usage pattern for consumers (and of previously built applications). The inner class should definitely be handled in addition to this case.<br>&gt;&gt; <br>&gt;&gt; * If the mangled name is present in the archive, you can re-mangle it to get the metadata accessor<br>&gt;&gt; * If it’s a one-level unmangled name representing a class, it can be mangled<br>&gt;&gt; * If it’s a zero-level unmangled name, then it seems reasonable for a first implementation to assume it’s a SwiftFoundation class (or that the caller has set an explicit mapping)<br>&gt;&gt; <br>&gt;&gt; Noted that dlsym() will only work with public symbols.<br>&gt;&gt; <br>&gt;&gt;&gt; Are there any methods that can fetch the name (either the symbolic or the readable) given a AnyClass in the runtime to get work started here? I think it is definitely sensible as a start to restrict this just to descendants of the class NSObject. I would presume that since the Metadata is potentially volatile contents we should use something along the lines of swift_getTypeName etc?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I have been using _typeName() but it always demangles – for interop with existing archives we need to match the behaviour of libobjc&#39;s class_getName() (equivalent to NSStringFromClass), which appears to demangle one-level classes.<br>&gt;&gt; <br>&gt;&gt; — Luke<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151224/ad3b77c3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 24, 2015 at 01:00:00pm</p></header><div class="content"><p>I’m planning to use this for now:<br></p><p>https://github.com/lhoward/swift-corelibs-foundation/commit/177e7d9f945db58217edec70d90d5cb53cba0245 &lt;https://github.com/lhoward/swift-corelibs-foundation/commit/177e7d9f945db58217edec70d90d5cb53cba0245&gt;<br></p><p>Noted that it won’t work for non-public symbols, but at least I can see how far I can get with NSKeyedArchiver/Unarchiver in the meantime.<br></p><p>— Luke<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151224/88df4d30/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 25, 2015 at 10:00:00am</p></header><div class="content"><p>NSKeyedUnarchiver is working, at least for a few classes for which I’ve implemented initWithCoder:. Promisingly encoding and decoding nested Swift classes works, using name mangling we discussed yesterday.<br></p><p>It does use NSPropertyListSerialization to read the entire property list into memory, whereas it appears Foundation incrementally decodes the archive directly. I’m not sure if I’ll have time to implement incremental decoding but at least this should be a start.<br></p><p>— Luke<br></p><p>&gt; On 24 Dec 2015, at 1:51 PM, Luke Howard via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m planning to use this for now:<br>&gt; <br>&gt; https://github.com/lhoward/swift-corelibs-foundation/commit/177e7d9f945db58217edec70d90d5cb53cba0245 &lt;https://github.com/lhoward/swift-corelibs-foundation/commit/177e7d9f945db58217edec70d90d5cb53cba0245&gt;<br>&gt; <br>&gt; Noted that it won’t work for non-public symbols, but at least I can see how far I can get with NSKeyedArchiver/Unarchiver in the meantime.<br>&gt; <br>&gt; — Luke<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br></p><p>--<br>www.lukehoward.com<br>soundcloud.com/lukehoward<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151225/178b0ea5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 25, 2015 at 09:00:00pm</p></header><div class="content"><p>Looking at decodeObjectOfClasses/allowedClasses – what is the element type in the set of allowed classes? It seems like it should be AnyClass but that can’t be added to a Set because it doesn’t implement Hashable (nor to an NSSet because the initialiser unconditionally casts to NSObject).<br></p><p>— Luke<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>NSCoding methods</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>December 25, 2015 at 10:00:00am</p></header><div class="content"><p>Likely we will have to change that signature to instead of being NSSet and Set&lt;NSObject&gt; respectively to be more compatible; however this will be an API change. It might be good to mock up a swift translation layer for these APIs to simulate what it would be like on Darwin if we altered these to be renamed in swift and presented with a better interface via the SDK overlays. Note: this will have to go through our evolution proposal system and be weighed in by the component owners of NSKeyedArchiver and the API teams associated with that to make such a change.<br></p><p>In my opinion since AnyClass should be unique it by nature should be Hashable - however I am not certain we can actually do that without language changes.<br></p><p>Perhaps for the time being we could alter the signatures to be:<br></p><p>public func decodeObjectOfClasses(classes: [AnyClass], forKey key: String) -&gt; AnyObject?<br></p><p>public var allowedClasses: [AnyClass]?<br></p><p><br>&gt; On Dec 25, 2015, at 2:01 AM, Luke Howard via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Looking at decodeObjectOfClasses/allowedClasses – what is the element type in the set of allowed classes? It seems like it should be AnyClass but that can’t be added to a Set because it doesn’t implement Hashable (nor to an NSSet because the initialiser unconditionally casts to NSObject).<br>&gt; <br>&gt; — Luke<br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151225/55d920b5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 26, 2015 at 08:00:00pm</p></header><div class="content"><p>Thanks - also the WithObjCType methods could have a nicer interface (make the type an enum of Character, take Any instead of an unsafe pointer).<br></p><p>Sent from my iPhone<br></p><p>&gt; On 26 Dec 2015, at 05:46, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt; Likely we will have to change that signature to instead of being NSSet and Set&lt;NSObject&gt; respectively to be more compatible; however this will be an API change. It might be good to mock up a swift translation layer for these APIs to simulate what it would be like on Darwin if we altered these to be renamed in swift and presented with a better interface via the SDK overlays. Note: this will have to go through our evolution proposal system and be weighed in by the component owners of NSKeyedArchiver and the API teams associated with that to make such a change.<br>&gt; <br>&gt; In my opinion since AnyClass should be unique it by nature should be Hashable - however I am not certain we can actually do that without language changes.<br>&gt; <br>&gt; Perhaps for the time being we could alter the signatures to be:<br>&gt; <br>&gt; public func decodeObjectOfClasses(classes: [AnyClass], forKey key: String) -&gt; AnyObject?<br>&gt; <br>&gt; public var allowedClasses: [AnyClass]?<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 25, 2015, at 2:01 AM, Luke Howard via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Looking at decodeObjectOfClasses/allowedClasses – what is the element type in the set of allowed classes? It seems like it should be AnyClass but that can’t be added to a Set because it doesn’t implement Hashable (nor to an NSSet because the initialiser unconditionally casts to NSObject).<br>&gt;&gt; <br>&gt;&gt; — Luke<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt; swift-corelibs-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151226/f779bd5f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 26, 2015 at 08:00:00pm</p></header><div class="content"><p>Thanks - also the encodeValueOfObjCType methods could have a nicer interface (make the type an enum of Character, take Any instead of an unsafe pointer)...<br></p><p>Sent from my iPhone<br></p><p>&gt; On 26 Dec 2015, at 05:46, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt; Likely we will have to change that signature to instead of being NSSet and Set&lt;NSObject&gt; respectively to be more compatible; however this will be an API change. It might be good to mock up a swift translation layer for these APIs to simulate what it would be like on Darwin if we altered these to be renamed in swift and presented with a better interface via the SDK overlays. Note: this will have to go through our evolution proposal system and be weighed in by the component owners of NSKeyedArchiver and the API teams associated with that to make such a change.<br>&gt; <br>&gt; In my opinion since AnyClass should be unique it by nature should be Hashable - however I am not certain we can actually do that without language changes.<br>&gt; <br>&gt; Perhaps for the time being we could alter the signatures to be:<br>&gt; <br>&gt; public func decodeObjectOfClasses(classes: [AnyClass], forKey key: String) -&gt; AnyObject?<br>&gt; <br>&gt; public var allowedClasses: [AnyClass]?<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 25, 2015, at 2:01 AM, Luke Howard via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Looking at decodeObjectOfClasses/allowedClasses – what is the element type in the set of allowed classes? It seems like it should be AnyClass but that can’t be added to a Set because it doesn’t implement Hashable (nor to an NSSet because the initialiser unconditionally casts to NSObject).<br>&gt;&gt; <br>&gt;&gt; — Luke<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt; swift-corelibs-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151226/07049b88/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 27, 2015 at 01:00:00am</p></header><div class="content"><p>Another language thing I ran into – using classForKeyedArchiver/classForCoder is impossible because declarations from extensions cannot be overridden yet.<br></p><p>For example I’d like to do:<br></p><p>internal class _NSCFString : NSMutableString {<br>… <br>    override var classForCoder: AnyClass {<br>        return NSMutableString.self<br>    }<br>}<br></p><p>There are a few ways I can work around it but perhaps we can put these extensions directly on NSObject for now?<br></p><p>— Luke<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151227/ea26431a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>NSCoding methods</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>December 26, 2015 at 08:00:00am</p></header><div class="content"><p>Totally reasonable since that is a limitation that will cause subclassers to not be able to implement that even outside of Foundation.<br></p><p>What would help most for unit testing what you have so far?<br></p><p>I have a few init?(coder:) implementations that should match the implementations on darwin; primarily I was focused on getting the plist types done first and then moving onto the other classes.<br></p><p><br>&gt; On Dec 26, 2015, at 6:01 AM, Luke Howard &lt;lukeh at padl.com&gt; wrote:<br>&gt; <br>&gt; Another language thing I ran into – using classForKeyedArchiver/classForCoder is impossible because declarations from extensions cannot be overridden yet.<br>&gt; <br>&gt; For example I’d like to do:<br>&gt; <br>&gt; internal class _NSCFString : NSMutableString {<br>&gt; … <br>&gt;     override var classForCoder: AnyClass {<br>&gt;         return NSMutableString.self<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; There are a few ways I can work around it but perhaps we can put these extensions directly on NSObject for now?<br>&gt; <br>&gt; — Luke<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151226/3dcae6eb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 27, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On 27 Dec 2015, at 3:45 AM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt; Totally reasonable since that is a limitation that will cause subclassers to not be able to implement that even outside of Foundation.<br>&gt; <br>&gt; What would help most for unit testing what you have so far?<br>&gt; <br>&gt; I have a few init?(coder:) implementations that should match the implementations on darwin; primarily I was focused on getting the plist types done first and then moving onto the other classes.<br></p><p>I’ve done the plist classes and a few others such as NSURL, NSLocale, NSUUID. I’m going to look at the rest today, other remaining todos are:<br></p><p>* encodeValueOfObjCType()<br>* reviewing fatal vs non-fatal error cases<br>* testing reading/writing from a stream (vs memory), seem to be some issues with this<br>* unit tests<br>* incremental decoding (probably will not get to this)<br></p><p>Also I’m only looking at NSKeyedArchiver – do we need to support NSArchiver?<br></p><p>Finally, I filed a few bugs (with patches) for things I bumped into along the way:<br></p><p>* SR-378: Uninitialised memory in NSDictionary initialiser<br>* SR-379: CFDictionaryGetKeysAndValues() bridges in wrong order<br>* SR-380: Occasional crashes in NSString.hash.getter<br>* SR-381: Request for API to return mangled nominal type name<br>* SR-386: NSLog() API<br></p><p>— Luke<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>NSCoding methods</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>December 26, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 26, 2015, at 3:33 PM, Luke Howard &lt;lukeh at padl.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 27 Dec 2015, at 3:45 AM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Totally reasonable since that is a limitation that will cause subclassers to not be able to implement that even outside of Foundation.<br>&gt;&gt; <br>&gt;&gt; What would help most for unit testing what you have so far?<br>&gt;&gt; <br>&gt;&gt; I have a few init?(coder:) implementations that should match the implementations on darwin; primarily I was focused on getting the plist types done first and then moving onto the other classes.<br>&gt; <br>&gt; I’ve done the plist classes and a few others such as NSURL, NSLocale, NSUUID. I’m going to look at the rest today, other remaining todos are:<br>&gt; <br>&gt; * encodeValueOfObjCType()<br>&gt; * reviewing fatal vs non-fatal error cases<br>&gt; * testing reading/writing from a stream (vs memory), seem to be some issues with this<br>&gt; * unit tests<br>&gt; * incremental decoding (probably will not get to this)<br>&gt; <br>&gt; Also I’m only looking at NSKeyedArchiver – do we need to support NSArchiver?<br>&gt; <br>&gt; Finally, I filed a few bugs (with patches) for things I bumped into along the way:<br>&gt; <br>&gt; * SR-378: Uninitialised memory in NSDictionary initialiser<br>&gt; * SR-379: CFDictionaryGetKeysAndValues() bridges in wrong order<br>&gt; * SR-380: Occasional crashes in NSString.hash.getter<br>&gt; * SR-381: Request for API to return mangled nominal type name<br>&gt; * SR-386: NSLog() API<br>&gt; <br>&gt; — Luke<br></p><p>I was looking over some of the init and encode methods you have, there are a few bits that might need some touch ups to match behavioral differences but I think I can probably merge in some of the work I have done as an addendum to what you have already gotten done.<br></p><p>It might be good for review side of things to break out those other issues into their own pull requests. Is there a reason to implement NSLog and not just use print?<br></p><p>SR-380; that is a compiler issue? or runtime?<br></p><p> NSArchiver is old and not very cross platform on the darwin side of things anyhow. I think we should just focus on NSCoder/NSKeyedArchiver and user subclasses of each case.<br></p><p>Have you tested yet on ubuntu?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 27, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; I was looking over some of the init and encode methods you have, there are a few bits that might need some touch ups to match behavioral differences but I think I can probably merge in some of the work I have done as an addendum to what you have already gotten done.<br></p><p>Great, I just gave you write access to the branch.<br></p><p>&gt; It might be good for review side of things to break out those other issues into their own pull requests. Is there a reason to implement NSLog and not just use print?<br></p><p>Not really, just trying to make the messages look similar to Foundation.<br></p><p>&gt; SR-380; that is a compiler issue? or runtime?<br></p><p>Haven’t done enough research to say I’m afraid, I just did a quick fix and moved on.<br></p><p>&gt; NSArchiver is old and not very cross platform on the darwin side of things anyhow. I think we should just focus on NSCoder/NSKeyedArchiver and user subclasses of each case.<br></p><p>Agreed.<br></p><p>&gt; Have you tested yet on ubuntu?<br></p><p><br>Not yet, but will do once I’ve made a bit more progress.<br></p><p>— Luke<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 27, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On 27 Dec 2015, at 1:54 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt; It might be good for review side of things to break out those other issues into their own pull requests.<br></p><p>Agreed – I’ll do this soon.<br></p><p>— Luke<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>NSCoding methods</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>December 26, 2015 at 07:00:00pm</p></header><div class="content"><p>I think what I might do to help get this ball rolling is actually create a branch on the official repo; That way I can kick off CI etc on it.<br></p><p>&gt; On Dec 26, 2015, at 7:09 PM, Luke Howard &lt;lukeh at padl.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 27 Dec 2015, at 1:54 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It might be good for review side of things to break out those other issues into their own pull requests.<br>&gt; <br>&gt; Agreed – I’ll do this soon.<br>&gt; <br>&gt; — Luke<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>NSCoding methods</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>December 26, 2015 at 08:00:00pm</p></header><div class="content"><p>So a few results so far from the linux side: I ran across a few compiler crashes in the function metadataFromAccessorName; I need to dive a bit deeper into why it is failing.<br>I have a few cross platform corrections that I will be pushing shortly for you.<br></p><p>&gt; On Dec 26, 2015, at 7:29 PM, Philippe Hausler via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I think what I might do to help get this ball rolling is actually create a branch on the official repo; That way I can kick off CI etc on it.<br>&gt; <br>&gt;&gt; On Dec 26, 2015, at 7:09 PM, Luke Howard &lt;lukeh at padl.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 27 Dec 2015, at 1:54 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It might be good for review side of things to break out those other issues into their own pull requests.<br>&gt;&gt; <br>&gt;&gt; Agreed – I’ll do this soon.<br>&gt;&gt; <br>&gt;&gt; — Luke<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 27, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On 27 Dec 2015, at 3:09 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt; So a few results so far from the linux side: I ran across a few compiler crashes in the function metadataFromAccessorName; I need to dive a bit deeper into why it is failing.<br>&gt; I have a few cross platform corrections that I will be pushing shortly for you.<br></p><p>Thanks! With metadataFromAccessorName(), I guess just check the string is valid for starters; I’m surprised it even built as _CFCopyNominalTypeNameForClass() is C++ ABI-fragile.<br></p><p>— Luke<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>NSCoding methods</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>December 26, 2015 at 08:00:00pm</p></header><div class="content"><p>Yea that seems to work on linux just fine. I made some more linux portability corrections and it is now buildable on ubuntu 14.<br></p><p>&gt; On Dec 26, 2015, at 8:15 PM, Luke Howard &lt;lukeh at padl.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 27 Dec 2015, at 3:09 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; So a few results so far from the linux side: I ran across a few compiler crashes in the function metadataFromAccessorName; I need to dive a bit deeper into why it is failing.<br>&gt;&gt; I have a few cross platform corrections that I will be pushing shortly for you.<br>&gt; <br>&gt; Thanks! With metadataFromAccessorName(), I guess just check the string is valid for starters; I’m surprised it even built as _CFCopyNominalTypeNameForClass() is C++ ABI-fragile.<br>&gt; <br>&gt; — Luke<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 27, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On 27 Dec 2015, at 3:09 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt; So a few results so far from the linux side: I ran across a few compiler crashes in the function metadataFromAccessorName; I need to dive a bit deeper into why it is failing.<br>&gt; I have a few cross platform corrections that I will be pushing shortly for you.<br></p><p>Thanks Philippe, integrated most of these except for the changes to metadataFromAccessorName() – the symbol prefix was wrong and I think it’s better to stick with the approach of indirecting the metadata lookup through the accessor. Obviously if there’s a compiler issue on Linux we should fix it :)<br></p><p>(Hopefully I didn’t miss anything on the merge, unfortunately rebasing to master before merging your changes made it a bit fiddly.)<br></p><p>I’ve implemented but not extensively tested decodeValueOfObjCType(). Do we need to support NSConcreteValue?<br></p><p>— Luke<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 29, 2015 at 12:00:00am</p></header><div class="content"><p>&gt; On 27 Dec 2015, at 9:31 PM, Luke Howard via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I’ve implemented but not extensively tested decodeValueOfObjCType(). Do we need to support NSConcreteValue?<br></p><p>I started looking at NSConcreteValue (commit 1a9fe560) and decoding it is fine (notwithstanding implementing all the special cases).<br></p><p>What’s the plan for instantiating concrete of NSValue though?<br></p><p>* Class clusters seem impossible to implement in Swift<br>* Factory methods are an API change<br>* NSValue becoming concrete seems to muck up CF bridging (also, fragile base class problem)<br>* I looked a little into using ManagedBuffer to size instances dynamically but it’s not much help by the time init() is called<br>* A lookaside table works and is straightforward to implement, but is pretty ugly<br></p><p>— Luke<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>NSCoding methods</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>December 28, 2015 at 08:00:00am</p></header><div class="content"><p>Responses inline; <br></p><p>&gt; On Dec 28, 2015, at 5:01 AM, Luke Howard via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 27 Dec 2015, at 9:31 PM, Luke Howard via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’ve implemented but not extensively tested decodeValueOfObjCType(). Do we need to support NSConcreteValue?<br>&gt; <br>&gt; I started looking at NSConcreteValue (commit 1a9fe560) and decoding it is fine (notwithstanding implementing all the special cases).<br>&gt; <br>&gt; What’s the plan for instantiating concrete of NSValue though?<br>&gt; <br>&gt; * Class clusters seem impossible to implement in Swift<br></p><p>Yep, there are a few things in the evolution list to propose this.<br></p><p>&gt; * Factory methods are an API change<br></p><p>We need factory init methods to make this work which is not yet supported by the language. <br></p><p>&gt; * NSValue becoming concrete seems to muck up CF bridging (also, fragile base class problem)<br></p><p>It will end up being a real rats nest to even get it close to working. In the end we will have two choices if we don’t have factory init methods, we can have NSValue or have NSNumber. My guess is that NSNumber is more commonly used in swift than NSValue.<br></p><p>&gt; * I looked a little into using ManagedBuffer to size instances dynamically but it’s not much help by the time init() is called<br></p><p>If need be somethings can be dropped out to C as well<br></p><p>&gt; * A lookaside table works and is straightforward to implement, but is pretty ugly<br></p><p>Not certain what you mean there; each NSValue is just a identity of a key in a dictionary to a NSConcreteValue that the methods forward to? That would mean that each method call would be a dictionary lookup… that does not sound scalable from a performance standpoint.<br></p><p>&gt; <br>&gt; — Luke<br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br></p><p><br>In summary - I think perhaps it would be better to start thinking about batching up parts of the NSCoder work and getting it merged before tackling NSValue<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 29, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On 29 Dec 2015, at 3:01 AM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt; Not certain what you mean there; each NSValue is just a identity of a key in a dictionary to a NSConcreteValue that the methods forward to? That would mean that each method call would be a dictionary lookup… that does not sound scalable from a performance standpoint.<br></p><p>That is what I meant – and yes I agree.<br></p><p>&gt; In summary - I think perhaps it would be better to start thinking about batching up parts of the NSCoder work and getting it merged before tackling NSValue<br></p><p><br>Cool, I want to test on Linux first and then reorganise/cleanup the commit history.<br></p><p>— Luke<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 29, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On 29 Dec 2015, at 3:01 AM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt; Not certain what you mean there; each NSValue is just a identity of a key in a dictionary to a NSConcreteValue that the methods forward to? That would mean that each method call would be a dictionary lookup… that does not sound scalable from a performance standpoint.<br></p><p>Although didn’t NSObject do something similar for managing the retain count when it didn’t fit inline? I’m too lazy to go look it up...<br></p><p>— Luke<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>NSCoding methods</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>December 28, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 28, 2015, at 3:10 PM, Luke Howard &lt;lukeh at padl.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 29 Dec 2015, at 3:01 AM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Not certain what you mean there; each NSValue is just a identity of a key in a dictionary to a NSConcreteValue that the methods forward to? That would mean that each method call would be a dictionary lookup… that does not sound scalable from a performance standpoint.<br>&gt; <br>&gt; Although didn’t NSObject do something similar for managing the retain count when it didn’t fit inline? I’m too lazy to go look it up...<br>&gt; <br>&gt; — Luke<br></p><p>Yea the objc runtime has side tables for things like that; I guess I would have to see a proposed implementation and play with it to see what the performance hit would be like.<br></p><p>So you were thinking something like (note this is just something I drafted in a few minutes so it is a bit rough):<br></p><p>diff --git a/Foundation/NSDecimalNumber.swift b/Foundation/NSDecimalNumber.swift<br>index 927be14..2e6791f 100644<br>--- a/Foundation/NSDecimalNumber.swift<br>+++ b/Foundation/NSDecimalNumber.swift<br>@@ -96,7 +96,7 @@ public class NSDecimalNumber : NSNumber {<br>     //   ignore exactnessException<br>     //   raise on overflow, underflow and divide by zero.<br>     <br>-    public var objCType: UnsafePointer&lt;Int8&gt; { NSUnimplemented() }<br>+    public override var objCType: UnsafePointer&lt;Int8&gt; { NSUnimplemented() }<br>     // return &#39;d&#39; for double<br>     <br>     public override var doubleValue: Double { NSUnimplemented() }<br>diff --git a/Foundation/NSValue.swift b/Foundation/NSValue.swift<br>index eefb3b9..6f495a0 100644<br>--- a/Foundation/NSValue.swift<br>+++ b/Foundation/NSValue.swift<br>@@ -8,10 +8,68 @@<br> //<br> <br> <br>+internal class NSConcreteValue : NSValue {<br>+    internal var _value: UnsafeMutablePointer&lt;Void&gt; = nil<br>+    internal var _size: Int = 0<br>+    internal var _objCType: UnsafePointer&lt;Int8&gt; = nil<br>+    <br>+    internal override init() {<br>+        super.init()<br>+    }<br>+<br>+    required init?(coder aDecoder: NSCoder) {<br>+        NSUnimplemented()<br>+    }<br>+    <br>+    override func getValue(value: UnsafeMutablePointer&lt;Void&gt;) {<br>+        value.assignFrom(_value, count: _size)<br>+    }<br>+    <br>+    override var objCType: UnsafePointer&lt;Int8&gt; {<br>+        return _objCType<br>+    }<br>+}<br>+<br>+private var _NSValueSideTable = [ObjectIdentifier : NSConcreteValue]()<br>+private var _NSValueSideTableLock = NSLock()<br>+<br> public class NSValue : NSObject, NSCopying, NSSecureCoding, NSCoding {<br>     <br>     internal override init() {<br>-        <br>+        super.init()<br>+        if self.dynamicType == NSValue.self {<br>+            _NSValueSideTableLock.synchronized {<br>+                _NSValueSideTable[ObjectIdentifier(self)] = NSConcreteValue()<br>+            }<br>+        }<br>+    }<br>+    <br>+    deinit {<br>+        if self.dynamicType == NSValue.self {<br>+            _NSValueSideTableLock.synchronized {<br>+                _NSValueSideTable[ObjectIdentifier(self)] = nil<br>+            }<br>+        }<br>+    }<br>+    <br>+    public func getValue(value: UnsafeMutablePointer&lt;Void&gt;) {<br>+        if self.dynamicType == NSValue.self {<br>+            _NSValueSideTableLock.synchronized {<br>+                _NSValueSideTable[ObjectIdentifier(self)]!.getValue(value)<br>+            }<br>+        } else {<br>+            NSRequiresConcreteImplementation()<br>+        }<br>+    }<br>+    <br>+    public var objCType: UnsafePointer&lt;Int8&gt; {<br>+        if self.dynamicType == NSValue.self {<br>+            return _NSValueSideTableLock.synchronized {<br>+                return _NSValueSideTable[ObjectIdentifier(self)]!.objCType<br>+            }<br>+        } else {<br>+            NSRequiresConcreteImplementation()<br>+        }<br>     }<br>     <br>     public required init?(coder aDecoder: NSCoder) {<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 29, 2015 at 10:00:00am</p></header><div class="content"><p>Yeah, that’s what I implemented (although I forgot the synchronized bit, ahem). I backed it out though after your earlier email. I’ll try your patch…<br></p><p>&gt; On 29 Dec 2015, at 10:46 AM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 28, 2015, at 3:10 PM, Luke Howard &lt;lukeh at padl.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 29 Dec 2015, at 3:01 AM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not certain what you mean there; each NSValue is just a identity of a key in a dictionary to a NSConcreteValue that the methods forward to? That would mean that each method call would be a dictionary lookup… that does not sound scalable from a performance standpoint.<br>&gt;&gt; <br>&gt;&gt; Although didn’t NSObject do something similar for managing the retain count when it didn’t fit inline? I’m too lazy to go look it up...<br>&gt;&gt; <br>&gt;&gt; — Luke<br>&gt; <br>&gt; Yea the objc runtime has side tables for things like that; I guess I would have to see a proposed implementation and play with it to see what the performance hit would be like.<br>&gt; <br>&gt; So you were thinking something like (note this is just something I drafted in a few minutes so it is a bit rough):<br>&gt; <br>&gt; diff --git a/Foundation/NSDecimalNumber.swift b/Foundation/NSDecimalNumber.swift<br>&gt; index 927be14..2e6791f 100644<br>&gt; --- a/Foundation/NSDecimalNumber.swift<br>&gt; +++ b/Foundation/NSDecimalNumber.swift<br>&gt; @@ -96,7 +96,7 @@ public class NSDecimalNumber : NSNumber {<br>&gt;     //   ignore exactnessException<br>&gt;     //   raise on overflow, underflow and divide by zero.<br>&gt; <br>&gt; -    public var objCType: UnsafePointer&lt;Int8&gt; { NSUnimplemented() }<br>&gt; +    public override var objCType: UnsafePointer&lt;Int8&gt; { NSUnimplemented() }<br>&gt;     // return &#39;d&#39; for double<br>&gt; <br>&gt;     public override var doubleValue: Double { NSUnimplemented() }<br>&gt; diff --git a/Foundation/NSValue.swift b/Foundation/NSValue.swift<br>&gt; index eefb3b9..6f495a0 100644<br>&gt; --- a/Foundation/NSValue.swift<br>&gt; +++ b/Foundation/NSValue.swift<br>&gt; @@ -8,10 +8,68 @@<br>&gt; //<br>&gt; <br>&gt; <br>&gt; +internal class NSConcreteValue : NSValue {<br>&gt; +    internal var _value: UnsafeMutablePointer&lt;Void&gt; = nil<br>&gt; +    internal var _size: Int = 0<br>&gt; +    internal var _objCType: UnsafePointer&lt;Int8&gt; = nil<br>&gt; +    <br>&gt; +    internal override init() {<br>&gt; +        super.init()<br>&gt; +    }<br>&gt; +<br>&gt; +    required init?(coder aDecoder: NSCoder) {<br>&gt; +        NSUnimplemented()<br>&gt; +    }<br>&gt; +    <br>&gt; +    override func getValue(value: UnsafeMutablePointer&lt;Void&gt;) {<br>&gt; +        value.assignFrom(_value, count: _size)<br>&gt; +    }<br>&gt; +    <br>&gt; +    override var objCType: UnsafePointer&lt;Int8&gt; {<br>&gt; +        return _objCType<br>&gt; +    }<br>&gt; +}<br>&gt; +<br>&gt; +private var _NSValueSideTable = [ObjectIdentifier : NSConcreteValue]()<br>&gt; +private var _NSValueSideTableLock = NSLock()<br>&gt; +<br>&gt; public class NSValue : NSObject, NSCopying, NSSecureCoding, NSCoding {<br>&gt; <br>&gt;     internal override init() {<br>&gt; -        <br>&gt; +        super.init()<br>&gt; +        if self.dynamicType == NSValue.self {<br>&gt; +            _NSValueSideTableLock.synchronized {<br>&gt; +                _NSValueSideTable[ObjectIdentifier(self)] = NSConcreteValue()<br>&gt; +            }<br>&gt; +        }<br>&gt; +    }<br>&gt; +    <br>&gt; +    deinit {<br>&gt; +        if self.dynamicType == NSValue.self {<br>&gt; +            _NSValueSideTableLock.synchronized {<br>&gt; +                _NSValueSideTable[ObjectIdentifier(self)] = nil<br>&gt; +            }<br>&gt; +        }<br>&gt; +    }<br>&gt; +    <br>&gt; +    public func getValue(value: UnsafeMutablePointer&lt;Void&gt;) {<br>&gt; +        if self.dynamicType == NSValue.self {<br>&gt; +            _NSValueSideTableLock.synchronized {<br>&gt; +                _NSValueSideTable[ObjectIdentifier(self)]!.getValue(value)<br>&gt; +            }<br>&gt; +        } else {<br>&gt; +            NSRequiresConcreteImplementation()<br>&gt; +        }<br>&gt; +    }<br>&gt; +    <br>&gt; +    public var objCType: UnsafePointer&lt;Int8&gt; {<br>&gt; +        if self.dynamicType == NSValue.self {<br>&gt; +            return _NSValueSideTableLock.synchronized {<br>&gt; +                return _NSValueSideTable[ObjectIdentifier(self)]!.objCType<br>&gt; +            }<br>&gt; +        } else {<br>&gt; +            NSRequiresConcreteImplementation()<br>&gt; +        }<br>&gt;     }<br>&gt; <br>&gt;     public required init?(coder aDecoder: NSCoder) {<br></p><p>--<br>www.lukehoward.com<br>soundcloud.com/lukehoward<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 29, 2015 at 10:00:00am</p></header><div class="content"><p>NSConcreteValue is in the current nscoding branch BTW, it works for decoding (non-special types, special is todo).<br></p><p>— Luke<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>NSCoding methods</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>December 28, 2015 at 03:00:00pm</p></header><div class="content"><p>It is ok on the special types; those are harder than they may seem… NSValue in Darwin has some limitations like that especially when it comes to secure coding or non standard aligned values.<br></p><p>&gt; On Dec 28, 2015, at 3:52 PM, Luke Howard &lt;lukeh at padl.com&gt; wrote:<br>&gt; <br>&gt; NSConcreteValue is in the current nscoding branch BTW, it works for decoding (non-special types, special is todo).<br>&gt; <br>&gt; — Luke<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 30, 2015 at 12:00:00am</p></header><div class="content"><p>OK, so I’ve cleaned up the commit history for the NSCoding branch, you can find it here still:<br></p><p>https://github.com/lhoward/swift-corelibs-foundation/tree/lhoward/nscoding &lt;https://github.com/lhoward/swift-corelibs-foundation/tree/lhoward/nscoding&gt;<br></p><p>I haven’t opened a pull request as I’d like to get it working on Linux first. Having a bit of trouble though. (I’m using Ubuntu 15.10 with the latest snapshot.)<br></p><p>Firstly, build-wise:<br></p><p>* Changing anything in Foundation/ seems to trigger a recompile of everything Swift. Is there a way to do correct dependency analysis? My clock is OK.<br></p><p>* swift/utils/build-script with —debug-foundation still seems to build a release version. I worked around by building everything debug, but that takes up a lot of disk space.<br></p><p>* lldb crashes all the time when printing variables (actually I also see this on OS X as well with the snapshot)<br></p><p>Related to testing:<br></p><p>* Something weird is going on with casting over which completely breaks NSKeyedArchiver. I can reproduce it with the following:<br></p><p>    let foo = (NSMutableArray() as? AnyObject) as? NSCoding<br></p><p>which the compiler tells me always succeeds (as I believe it should), but at runtime returns foo==nil. No issue if it is a locally defined class that conforms to NSCoding. It’s failing in _dynamicCastToExistential()’s check for _conformsToProtocols() but I haven’t dug deeper yet.<br></p><p>FYI: my LD_LIBRARY_PATH is pointing to the right libswiftCore/libFoundation. I removed the module maps for Foundation/CoreFoundation from the snapshot directory.<br></p><p>* Subclassing NSObject fails outside Foundation (see SR-272) is also an issue but not a blocking one<br></p><p>— Luke<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151230/677d4f77/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 30, 2015 at 12:00:00am</p></header><div class="content"><p>&gt; On 30 Dec 2015, at 12:03 AM, Luke Howard &lt;lukeh at padl.com&gt; wrote:<br>&gt; <br>&gt; * Something weird is going on with casting over which completely breaks NSKeyedArchiver. I can reproduce it with the following:<br>&gt; <br>&gt;     let foo = (NSMutableArray() as? AnyObject) as? NSCoding<br></p><p><br>More details at:<br></p><p>https://bugs.swift.org/browse/SR-404 &lt;https://bugs.swift.org/browse/SR-404&gt;<br></p><p>— Luke<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151230/65b0c415/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>NSCoding methods</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>December 29, 2015 at 11:00:00am</p></header><div class="content"><p>Responses inline:<br></p><p>&gt; On Dec 29, 2015, at 5:03 AM, Luke Howard &lt;lukeh at padl.com&gt; wrote:<br>&gt; <br>&gt; OK, so I’ve cleaned up the commit history for the NSCoding branch, you can find it here still:<br>&gt; <br>&gt; https://github.com/lhoward/swift-corelibs-foundation/tree/lhoward/nscoding &lt;https://github.com/lhoward/swift-corelibs-foundation/tree/lhoward/nscoding&gt;<br>&gt; <br>&gt; I haven’t opened a pull request as I’d like to get it working on Linux first. Having a bit of trouble though. (I’m using Ubuntu 15.10 with the latest snapshot.)<br>&gt; <br>&gt; Firstly, build-wise:<br>&gt; <br>&gt; * Changing anything in Foundation/ seems to trigger a recompile of everything Swift. Is there a way to do correct dependency analysis? My clock is OK.<br></p><p>Yep; probably should be a “known issue” the ninja script will emit the other swift files as deps since there might be cross file dependencies - it is a bit slow when the compiler is in debug mode<br></p><p>&gt; <br>&gt; * swift/utils/build-script with —debug-foundation still seems to build a release version. I worked around by building everything debug, but that takes up a lot of disk space.<br></p><p>My trick that I do is I will build a release build and then hand edit the `.configuration` file of Foundation to be debug; so that way the next `ninja reconfigure` will reconfig it as debug and give juicy debugging info but the rest of the runtime and compiler is in release mode. (I have been considering adding this as a specialized reconfigure option<br></p><p>&gt; <br>&gt; * lldb crashes all the time when printing variables (actually I also see this on OS X as well with the snapshot)<br></p><p>po or p?<br></p><p>&gt; <br>&gt; Related to testing:<br>&gt; <br>&gt; * Something weird is going on with casting over which completely breaks NSKeyedArchiver. I can reproduce it with the following:<br>&gt; <br>&gt;     let foo = (NSMutableArray() as? AnyObject) as? NSCoding<br>&gt; <br>&gt; which the compiler tells me always succeeds (as I believe it should), but at runtime returns foo==nil. No issue if it is a locally defined class that conforms to NSCoding. It’s failing in _dynamicCastToExistential()’s check for _conformsToProtocols() but I haven’t dug deeper yet.<br>&gt; <br>&gt; FYI: my LD_LIBRARY_PATH is pointing to the right libswiftCore/libFoundation. I removed the module maps for Foundation/CoreFoundation from the snapshot directory.<br></p><p>The removal of the module map is usually only needed when building directly to an installed root. Most of the build process for incremental builds don’t need to have module map removal shenanigans.<br></p><p>&gt; <br>&gt; * Subclassing NSObject fails outside Foundation (see SR-272) is also an issue but not a blocking one<br>&gt; <br>&gt; — Luke<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151229/6000f966/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 30, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On 30 Dec 2015, at 6:20 AM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; * Something weird is going on with casting over which completely breaks NSKeyedArchiver. I can reproduce it with the following:<br>&gt;&gt; <br>&gt;&gt;     let foo = (NSMutableArray() as? AnyObject) as? NSCoding<br></p><p>https://github.com/lhoward/swift-corelibs-foundation/commit/0de79438392d94ebff45c602bad144aefd1bff13 &lt;https://github.com/lhoward/swift-corelibs-foundation/commit/0de79438392d94ebff45c602bad144aefd1bff13&gt;<br></p><p>seems to fix this specific issue<br></p><p>— Luke<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151230/80dc411f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 30, 2015 at 04:00:00pm</p></header><div class="content"><p>OK, it is working on Linux (lightly tested). It needs a compiler fix though, see [SR-412].<br></p><p>— Luke<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 31, 2015 at 02:00:00am</p></header><div class="content"><p>I’ve written a few unit tests for NSKeyedArchiver/NSKeyedUnarchiver but it could do with lots more (if anyone is interested!). We are gated by some methods not having isEqual() implementations yet (which is used to verify the test results).<br></p><p>The tests pass on both Linux and OS X, although presently the user class test is disabled for Linux as subclassing NSObject outside of Foundation is broken.<br></p><p>The NSKeyedArchiver tests encode an object (graph), decode it and check it matches. The NSKeyedUnarchiver tests decode an object (graph) that was encoded using OS X Foundation. We currently don’t exercise NSKeyedArchiver writing to a file, although it does work on both platforms.<br></p><p>— Luke<br></p><p>Executed 24 tests, with 0 failures (0 unexpected) in 0.001 (0.022) seconds<br>Test Case &#39;TestNSKeyedArchiver.test_archive_array&#39; started.<br>Test Case &#39;TestNSKeyedArchiver.test_archive_array&#39; passed (0.01 seconds).<br>Test Case &#39;TestNSKeyedArchiver.test_archive_dictionary&#39; started.<br>Test Case &#39;TestNSKeyedArchiver.test_archive_dictionary&#39; passed (0.013 seconds).<br>Test Case &#39;TestNSKeyedArchiver.test_archive_string&#39; started.<br>Test Case &#39;TestNSKeyedArchiver.test_archive_string&#39; passed (0.003 seconds).<br>Test Case &#39;TestNSKeyedArchiver.test_archive_mutable_array&#39; started.<br>Test Case &#39;TestNSKeyedArchiver.test_archive_mutable_array&#39; passed (0.01 seconds).<br>Test Case &#39;TestNSKeyedArchiver.test_archive_mutable_dictionary&#39; started.<br>Test Case &#39;TestNSKeyedArchiver.test_archive_mutable_dictionary&#39; passed (0.008 seconds).<br>Test Case &#39;TestNSKeyedArchiver.test_archive_null&#39; started.<br>Test Case &#39;TestNSKeyedArchiver.test_archive_null&#39; passed (0.006 seconds).<br>Test Case &#39;TestNSKeyedArchiver.test_archive_set&#39; started.<br>Test Case &#39;TestNSKeyedArchiver.test_archive_set&#39; passed (0.006 seconds).<br>Test Case &#39;TestNSKeyedArchiver.test_archive_url&#39; started.<br>Test Case &#39;TestNSKeyedArchiver.test_archive_url&#39; passed (0.007 seconds).<br>Test Case &#39;TestNSKeyedArchiver.test_archive_user_class&#39; started.<br>Test Case &#39;TestNSKeyedArchiver.test_archive_user_class&#39; passed (0.0 seconds).<br>Test Case &#39;TestNSKeyedArchiver.test_archive_uuid&#39; started.<br>Test Case &#39;TestNSKeyedArchiver.test_archive_uuid&#39; passed (0.008 seconds).<br>Executed 10 tests, with 0 failures (0 unexpected) in 0.007 (0.071) seconds<br>Test Case &#39;TestNSKeyedUnarchiver.test_unarchive_array&#39; started.<br>Test Case &#39;TestNSKeyedUnarchiver.test_unarchive_array&#39; passed (0.004 seconds).<br>Test Case &#39;TestNSKeyedUnarchiver.test_unarchive_complex&#39; started.<br>Test Case &#39;TestNSKeyedUnarchiver.test_unarchive_complex&#39; passed (0.012 seconds).<br>Test Case &#39;TestNSKeyedUnarchiver.test_unarchive_concrete_value&#39; started.<br>Test Case &#39;TestNSKeyedUnarchiver.test_unarchive_concrete_value&#39; passed (0.01 seconds).<br>Test Case &#39;TestNSKeyedUnarchiver.test_unarchive_url&#39; started.<br>Test Case &#39;TestNSKeyedUnarchiver.test_unarchive_url&#39; passed (0.005 seconds).<br>Test Case &#39;TestNSKeyedUnarchiver.test_unarchive_uuid&#39; started.<br>Test Case &#39;TestNSKeyedUnarchiver.test_unarchive_uuid&#39; passed (0.003 seconds).<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151231/2a52297c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>January  2, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On 29 Dec 2015, at 10:54 AM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt; It is ok on the special types; those are harder than they may seem… NSValue in Darwin has some limitations like that especially when it comes to secure coding or non standard aligned values.<br></p><p>I have a solution that’s not too inelegant, see:<br></p><p>https://github.com/lhoward/swift-corelibs-foundation/blob/lhoward/nscoding/Foundation/NSSpecialValue.swift<br></p><p>This takes advantage of the fact that structures can implement protocols in Swift. NSRect, etc implement NSCoding (by way of NSSpecialValueCoding). The structures are then boxed by NSSpecialValue (a subclass of NSValue). It would have been nice to make NSSpecialValue a generic class but unfortunately it doesn’t appear you can specialise at runtime, which the unarchiver would need to do.<br></p><p>e.g.<br></p><p>extension CGPoint: NSSpecialValueCoding {<br>    public init?(coder aDecoder: NSCoder) {<br>        if aDecoder.allowsKeyedCoding {<br>            self = aDecoder.decodePointForKey(&quot;NS.pointval&quot;)<br>        } else {<br>            self = aDecoder.decodePoint()<br>        }<br>    }<br>    <br>    public func encodeWithCoder(aCoder: NSCoder) {<br>        if aCoder.allowsKeyedCoding {<br>            aCoder.encodePoint(self, forKey: &quot;NS.pointval&quot;)<br>        } else {<br>            aCoder.encodePoint(self)<br>        }<br>    }<br>    <br>    public static func supportsSecureCoding() -&gt; Bool {<br>        return true<br>    }<br>    <br>    static func objCType() -&gt; String {<br>        return &quot;{CGPoint=dd}&quot;<br>    }<br></p><p>    func isEqual(aValue: Any) -&gt; Bool {<br>        if let other = aValue as? CGPoint {<br>            return other == self<br>        } else {<br>            return false<br>        }<br>    }<br>}<br></p><p>There’s still NSConcreteValue for ObjC type representations but I found it difficult to merge the two (for reasons I can explain later).<br></p><p>Happy new year!<br></p><p>— Luke<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20160102/7d63dcbc/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 29, 2015 at 11:00:00am</p></header><div class="content"><p>https://github.com/lhoward/swift-corelibs-foundation/commit/49164ea312f0515c8a743d9cb322a78e513085f5<br></p><p>— Luke<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ffe95d2e2584a3b4adda3ca0e19c375d?s=50"></div><header><strong>NSCoding methods</strong> from <string>Luke Howard</string> &lt;lukeh at padl.com&gt;<p>December 24, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On 24 Dec 2015, at 9:37 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; No, we cannot encode things &quot;non-mangled but with the namespace&quot;. For any type other than top-level non-generic class types, using a non-mangled name is not unique. The only correct answer for arbitrary classes is to use mangled names, or something that maps one-to-one with mangled names.<br></p><p>Ah, thanks for pointing this out!<br></p><p>NSClassFromString() – which it appears Foundation uses when coding – returns a non-mangled name for a one/top-level non-generic class type (e.g. “scoderTest.CodableTest”) but otherwise the mangled type name (e.g. “_TtCC10scoderTest11CodableTest6Nested”).<br></p><p>Is there an equivalent function in Swift stdlib?<br></p><p>— Luke<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
