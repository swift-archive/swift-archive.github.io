<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>An Alternative for Extensibility Modifiers</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>July 12, 2016 at 02:00:00am</p></header><div class="content"><p>With all the controversy around proposal 0117, I thought I would take a stab at an alternative approach that attempts to balance the concerns of both sides of the argument.  I don’t know that it would be everyone&#39;s first choice, but I think/hope it would be acceptable to the vast majority.<br></p><p>Take a look here and let me know if you think it is worth flushing out:<br>https://gist.github.com/jonhull/a5ac84a16b7a0ffc0c00747998f390d9<br></p><p><br>The basic idea (for those who hate clicking links) is to create 3 levels of extensibility:<br>	• Open -  The class or method is open to be extended through subclassing/override.<br>	• Sealed - Attempting to subclass/override the class/method will result in a compiler error saying that it is not intended to be extended. Using the ‘unsafe&#39; keyword will allow compilation.<br>	• Final - The class or method can not be subclassed/overridden. Attempting to do so will result in a compiler error.<br></p><p>These would be orthogonal to access modifiers.  Thus you would write ‘public open’, which is admittedly two words… but together they are actually shorter than the single ‘subclassable’ keyword<br></p><p>You can also specify different levels of extensibility at different levels of visibility (e.g. ‘public final internal(open)’)<br></p><p>The default would be ‘sealed internal(open)’ which means it is publicly sealed, but open within the defining module.  This is similar to the default of 0117, except it allows overriding using the ‘unsafe’ keyword (where the user explicitly acknowledges that subclassing/overriding is not supported by the API).<br></p><p>Thus, we lose some compiler optimizations in the default case (vs 0117), but these can easily be regained by explicitly marking parts of the API as final.  The semantic meaning of the 0117 default is kept, with an escape hatch for problematic API.  Thoughtful framework writers would go through and mark API as either ‘public open’ or ‘public final’.  Less thoughtful framework authors would still get feedback asking them to do so, since nobody likes having the word ‘unsafe’ in their code when they don’t have to.<br></p><p>This design feels much Swiftier™ to me because it has opt-out safety and opt-in risk.  It protects you from accidentally causing trouble, but gets out of your way when you tell it you know what you are doing.<br></p><p>Thoughts?<br></p><p>Thanks,<br>Jon<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>An Alternative for Extensibility Modifiers</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>July 12, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jul 12, 2016, at 11:12 AM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; With all the controversy around proposal 0117, I thought I would take a stab at an alternative approach that attempts to balance the concerns of both sides of the argument.  I don’t know that it would be everyone&#39;s first choice, but I think/hope it would be acceptable to the vast majority.<br>&gt; <br>&gt; Take a look here and let me know if you think it is worth flushing out:<br>&gt; https://gist.github.com/jonhull/a5ac84a16b7a0ffc0c00747998f390d9<br>&gt; <br>&gt; <br>&gt; The basic idea (for those who hate clicking links) is to create 3 levels of extensibility:<br>&gt; 	• Open -  The class or method is open to be extended through subclassing/override.<br>&gt; 	• Sealed - Attempting to subclass/override the class/method will result in a compiler error saying that it is not intended to be extended. Using the ‘unsafe&#39; keyword will allow compilation.<br>&gt; 	• Final - The class or method can not be subclassed/overridden. Attempting to do so will result in a compiler error.<br>&gt; <br>&gt; These would be orthogonal to access modifiers.  Thus you would write ‘public open’, which is admittedly two words… but together they are actually shorter than the single ‘subclassable’ keyword<br>&gt; <br>&gt; You can also specify different levels of extensibility at different levels of visibility (e.g. ‘public final internal(open)’)<br>&gt; <br>&gt; The default would be ‘sealed internal(open)’ which means it is publicly sealed, but open within the defining module.  This is similar to the default of 0117, except it allows overriding using the ‘unsafe’ keyword (where the user explicitly acknowledges that subclassing/overriding is not supported by the API).<br></p><p>This not only looses some of the whole-module optimization benefits but also renders many other future proposals moot. For example the exhaustive switch based on a sealed class:<br></p><p>let x: MySealedClass = ...<br>switch x {<br>case let obj as X: <br>	...<br>case let obj as Y: <br>	...<br>}<br></p><p>where X and Y are subclasses of MySealedClass. The benefit of this is no &quot;default&quot; case and a compile-time check that all the cases are handled, just like with an enum (since the class is sealed, the compiler knows all possible cases). You can probably imagine how would this get broken when if you used &quot;unsafe&quot; subclassing.<br></p><p>Sure, there could be an implicit default: fatalError(&quot;You&#39;ve subclassed what should never have been subclassed.&quot;), but it just doesn&#39;t feel right.<br></p><p>&gt; <br>&gt; Thus, we lose some compiler optimizations in the default case (vs 0117), but these can easily be regained by explicitly marking parts of the API as final.  The semantic meaning of the 0117 default is kept, with an escape hatch for problematic API.  Thoughtful framework writers would go through and mark API as either ‘public open’ or ‘public final’.  Less thoughtful framework authors would still get feedback asking them to do so, since nobody likes having the word ‘unsafe’ in their code when they don’t have to.<br>&gt; <br>&gt; This design feels much Swiftier™ to me because it has opt-out safety and opt-in risk.  It protects you from accidentally causing trouble, but gets out of your way when you tell it you know what you are doing.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>An Alternative for Extensibility Modifiers</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>July 12, 2016 at 12:00:00pm</p></header><div class="content"><p>I think sealing classes already existi in Swift it&#39;s called Private :)<br></p><p>*___________________________________*<br></p><p>*James⎥Head of Trolls*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On 12 July 2016 at 12:20, Charlie Monroe via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jul 12, 2016, at 11:12 AM, Jonathan Hull via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; With all the controversy around proposal 0117, I thought I would take a<br>&gt; stab at an alternative approach that attempts to balance the concerns of<br>&gt; both sides of the argument.  I don’t know that it would be everyone&#39;s first<br>&gt; choice, but I think/hope it would be acceptable to the vast majority.<br>&gt; &gt;<br>&gt; &gt; Take a look here and let me know if you think it is worth flushing out:<br>&gt; &gt; https://gist.github.com/jonhull/a5ac84a16b7a0ffc0c00747998f390d9<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; The basic idea (for those who hate clicking links) is to create 3 levels<br>&gt; of extensibility:<br>&gt; &gt;       • Open -  The class or method is open to be extended through<br>&gt; subclassing/override.<br>&gt; &gt;       • Sealed - Attempting to subclass/override the class/method will<br>&gt; result in a compiler error saying that it is not intended to be extended.<br>&gt; Using the ‘unsafe&#39; keyword will allow compilation.<br>&gt; &gt;       • Final - The class or method can not be subclassed/overridden.<br>&gt; Attempting to do so will result in a compiler error.<br>&gt; &gt;<br>&gt; &gt; These would be orthogonal to access modifiers.  Thus you would write<br>&gt; ‘public open’, which is admittedly two words… but together they are<br>&gt; actually shorter than the single ‘subclassable’ keyword<br>&gt; &gt;<br>&gt; &gt; You can also specify different levels of extensibility at different<br>&gt; levels of visibility (e.g. ‘public final internal(open)’)<br>&gt; &gt;<br>&gt; &gt; The default would be ‘sealed internal(open)’ which means it is publicly<br>&gt; sealed, but open within the defining module.  This is similar to the<br>&gt; default of 0117, except it allows overriding using the ‘unsafe’ keyword<br>&gt; (where the user explicitly acknowledges that subclassing/overriding is not<br>&gt; supported by the API).<br>&gt;<br>&gt; This not only looses some of the whole-module optimization benefits but<br>&gt; also renders many other future proposals moot. For example the exhaustive<br>&gt; switch based on a sealed class:<br>&gt;<br>&gt; let x: MySealedClass = ...<br>&gt; switch x {<br>&gt; case let obj as X:<br>&gt;         ...<br>&gt; case let obj as Y:<br>&gt;         ...<br>&gt; }<br>&gt;<br>&gt; where X and Y are subclasses of MySealedClass. The benefit of this is no<br>&gt; &quot;default&quot; case and a compile-time check that all the cases are handled,<br>&gt; just like with an enum (since the class is sealed, the compiler knows all<br>&gt; possible cases). You can probably imagine how would this get broken when if<br>&gt; you used &quot;unsafe&quot; subclassing.<br>&gt;<br>&gt; Sure, there could be an implicit default: fatalError(&quot;You&#39;ve subclassed<br>&gt; what should never have been subclassed.&quot;), but it just doesn&#39;t feel right.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; Thus, we lose some compiler optimizations in the default case (vs 0117),<br>&gt; but these can easily be regained by explicitly marking parts of the API as<br>&gt; final.  The semantic meaning of the 0117 default is kept, with an escape<br>&gt; hatch for problematic API.  Thoughtful framework writers would go through<br>&gt; and mark API as either ‘public open’ or ‘public final’.  Less thoughtful<br>&gt; framework authors would still get feedback asking them to do so, since<br>&gt; nobody likes having the word ‘unsafe’ in their code when they don’t have to.<br>&gt; &gt;<br>&gt; &gt; This design feels much Swiftier™ to me because it has opt-out safety and<br>&gt; opt-in risk.  It protects you from accidentally causing trouble, but gets<br>&gt; out of your way when you tell it you know what you are doing.<br>&gt; &gt;<br>&gt; &gt; Thoughts?<br>&gt; &gt;<br>&gt; &gt; Thanks,<br>&gt; &gt; Jon<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/46441d8e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>An Alternative for Extensibility Modifiers</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>July 12, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; On Jul 12, 2016, at 4:20 AM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jul 12, 2016, at 11:12 AM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; With all the controversy around proposal 0117, I thought I would take a stab at an alternative approach that attempts to balance the concerns of both sides of the argument.  I don’t know that it would be everyone&#39;s first choice, but I think/hope it would be acceptable to the vast majority.<br>&gt;&gt; <br>&gt;&gt; Take a look here and let me know if you think it is worth flushing out:<br>&gt;&gt; https://gist.github.com/jonhull/a5ac84a16b7a0ffc0c00747998f390d9<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The basic idea (for those who hate clicking links) is to create 3 levels of extensibility:<br>&gt;&gt; 	• Open -  The class or method is open to be extended through subclassing/override.<br>&gt;&gt; 	• Sealed - Attempting to subclass/override the class/method will result in a compiler error saying that it is not intended to be extended. Using the ‘unsafe&#39; keyword will allow compilation.<br>&gt;&gt; 	• Final - The class or method can not be subclassed/overridden. Attempting to do so will result in a compiler error.<br>&gt;&gt; <br>&gt;&gt; These would be orthogonal to access modifiers.  Thus you would write ‘public open’, which is admittedly two words… but together they are actually shorter than the single ‘subclassable’ keyword<br>&gt;&gt; <br>&gt;&gt; You can also specify different levels of extensibility at different levels of visibility (e.g. ‘public final internal(open)’)<br>&gt;&gt; <br>&gt;&gt; The default would be ‘sealed internal(open)’ which means it is publicly sealed, but open within the defining module.  This is similar to the default of 0117, except it allows overriding using the ‘unsafe’ keyword (where the user explicitly acknowledges that subclassing/overriding is not supported by the API).<br>&gt; <br>&gt; This not only looses some of the whole-module optimization benefits but also renders many other future proposals moot. For example the exhaustive switch based on a sealed class:<br>&gt; <br>&gt; let x: MySealedClass = ...<br>&gt; switch x {<br>&gt; case let obj as X: <br>&gt; 	...<br>&gt; case let obj as Y: <br>&gt; 	...<br>&gt; }<br>&gt; <br>&gt; where X and Y are subclasses of MySealedClass. The benefit of this is no &quot;default&quot; case and a compile-time check that all the cases are handled, just like with an enum (since the class is sealed, the compiler knows all possible cases). You can probably imagine how would this get broken when if you used &quot;unsafe&quot; subclassing.<br>&gt; <br>&gt; Sure, there could be an implicit default: fatalError(&quot;You&#39;ve subclassed what should never have been subclassed.&quot;), but it just doesn&#39;t feel right.<br>&gt; <br></p><p>You get all of these back by declaring things ‘final’.  Final does not have the escape hatch.  The escape hatch is only for ‘sealed’.  Make sure you actually read the proposal I made… the terminology is slightly different than 0117.<br></p><p>Thanks,<br>Jon<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/090f257f/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>An Alternative for Extensibility Modifiers</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 13, 2016 at 10:00:00am</p></header><div class="content"><p>Imho overall this is a good proposal, yet it saddens me to read this thread, because it&#39;s a good proof for the dogmatism I mentioned before: <br>You address all issues of proposal 0117 in a more consistent way with less confusing keywords, even adding some features that are actually handy — but yet the tenor of the replies is pushback…<br></p><p>As a liberal, those discussions are a tough battle, because you accept other people&#39;s opinions and strive for compromise, while the other side keeps pushing their case as hard as possible to enforce their agenda:<br>- We need to have &quot;sealed&quot;!<br>- It has to be the default!<br>- There has to be no way out of it!<br></p><p>To add some more constructive thoughts:<br>Given the fact that we are talking about changing a situation where it&#39;s absolutely legitimate to override (it is the way Swift has been designed!), I really thing there is no need for an extra &quot;unsafe&quot;-keyword — a simple exclamation-mark would do.<br></p><p>Tino<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
