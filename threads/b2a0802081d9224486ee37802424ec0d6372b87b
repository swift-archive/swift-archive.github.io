<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Version-pinned patching of public declarations</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 31, 2015 at 11:00:00am</p></header><div class="content"><p>A lot of the discussion around the final/sealed-by-default issue focused on the ability in ObjC to extend frameworks or fix bugs in unforeseen ways. Framework developers aren&#39;t perfect, and being able to patch a broken framework method can be the difference between shipping and not. On the other hand, these patches become compatibility liabilities for libraries, which have to contend not only with preserving their own designed interface but all the undesigned interactions with shipping apps based on those libraries. The Objective-C model of monkey-patchable-everything has problems, but so does the buttoned-down everything-is-static C++ world many of us rightly fear. However, with the work we&#39;re putting into Swift for resilience and strong versioning support, I think we&#39;re in a good position to try to find a reasonable compromise. I&#39;d like to sketch out a rough idea of how that might look. Public interfaces fundamentally correspond to one or more dynamic library symbols; the same resilience that lets a new framework version interact with older apps gives us an opportunity to patch resilient interfaces at process load time. We could embrace this by allowing applications to provide `@patch` implementations overriding imported non-fragile public APIs at specific versions:<br></p><p>import Foundation<br></p><p>extension NSFoo {<br>  @patch(OSX 10.22, iOS 17)<br>  func foo() { ... }<br>}<br></p><p>By tying the patch to a specific framework version, we lessen the compatibility liability for the framework; it&#39;s clear that, in most cases, the app developer is responsible for testing their app with new framework versions to see if their patch is still needed with each new version. Of course, that&#39;s not always possible—If the framework developer determines during compatibility testing that their new version breaks a must-not-break app, and they aren&#39;t able to adopt a fix on their end for whatever reason (it breaks other apps, or the app&#39;s patch is flawed), the framework could declare that their new version accepts patches for other framework versions too:<br></p><p>// in Foundation, OSX 10.23<br>public class NSFoo {<br>  // Compatibility: AwesomeApp patched the 10.22 version of NSFoo.foo.<br>  // However, RadicalApp and BodaciousApp rely on the unpatched 10.22 behavior, so<br>  // we can&#39;t change it.<br>  @accepts_patch_from(AwesomeApp, OSX 10.22)<br>  public func foo() { ... }<br>}<br></p><p>A sufficiently smart dynamic linker could perhaps resolve these patches at process load time (and probably summarily reject patches for dylibs loaded dynamically with dlopen), avoiding some of the security issues with arbitrary runtime patching. For public entry points to be effectively patchable, we&#39;d have to also avoid any interprocedural optimization of the implementations within the originating module, so there is a performance cost to allowing this patching by default. Sufficiently mature (or arrogant) interfaces could perhaps declare themselves &quot;unpatchable&quot; to admit IPO within their own module. (Note that &#39;fragile&#39; interfaces which admit cross-module inlining would inherently be unpatchable, and those are likely to be the most performance-sensitive interfaces to begin with.)<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/b2a0b87b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Version-pinned patching of public declarations</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 01:00:00pm</p></header><div class="content"><p>Hi Joe,<br></p><p>Can you compare the developer experience with/without this feature, e.g. paint some scenarios and describe what one would have to do to deal with it?<br></p><p>Thanks,<br>Dave<br></p><p>&gt; On Dec 31, 2015, at 11:13 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A lot of the discussion around the final/sealed-by-default issue focused on the ability in ObjC to extend frameworks or fix bugs in unforeseen ways. Framework developers aren&#39;t perfect, and being able to patch a broken framework method can be the difference between shipping and not. On the other hand, these patches become compatibility liabilities for libraries, which have to contend not only with preserving their own designed interface but all the undesigned interactions with shipping apps based on those libraries. The Objective-C model of monkey-patchable-everything has problems, but so does the buttoned-down everything-is-static C++ world many of us rightly fear. However, with the work we&#39;re putting into Swift for resilience and strong versioning support, I think we&#39;re in a good position to try to find a reasonable compromise. I&#39;d like to sketch out a rough idea of how that might look. Public interfaces fundamentally correspond to one or more dynamic library symbols; the same resilience that lets a new framework version interact with older apps gives us an opportunity to patch resilient interfaces at process load time. We could embrace this by allowing applications to provide `@patch` implementations overriding imported non-fragile public APIs at specific versions:<br>&gt; <br>&gt; import Foundation<br>&gt; <br>&gt; extension NSFoo {<br>&gt;   @patch(OSX 10.22, iOS 17)<br>&gt;   func foo() { ... }<br>&gt; }<br>&gt; <br>&gt; By tying the patch to a specific framework version, we lessen the compatibility liability for the framework; it&#39;s clear that, in most cases, the app developer is responsible for testing their app with new framework versions to see if their patch is still needed with each new version. Of course, that&#39;s not always possible—If the framework developer determines during compatibility testing that their new version breaks a must-not-break app, and they aren&#39;t able to adopt a fix on their end for whatever reason (it breaks other apps, or the app&#39;s patch is flawed), the framework could declare that their new version accepts patches for other framework versions too:<br>&gt; <br>&gt; // in Foundation, OSX 10.23<br>&gt; public class NSFoo {<br>&gt;   // Compatibility: AwesomeApp patched the 10.22 version of NSFoo.foo.<br>&gt;   // However, RadicalApp and BodaciousApp rely on the unpatched 10.22 behavior, so<br>&gt;   // we can&#39;t change it.<br>&gt;   @accepts_patch_from(AwesomeApp, OSX 10.22)<br>&gt;   public func foo() { ... }<br>&gt; }<br>&gt; <br>&gt; A sufficiently smart dynamic linker could perhaps resolve these patches at process load time (and probably summarily reject patches for dylibs loaded dynamically with dlopen), avoiding some of the security issues with arbitrary runtime patching. For public entry points to be effectively patchable, we&#39;d have to also avoid any interprocedural optimization of the implementations within the originating module, so there is a performance cost to allowing this patching by default. Sufficiently mature (or arrogant) interfaces could perhaps declare themselves &quot;unpatchable&quot; to admit IPO within their own module. (Note that &#39;fragile&#39; interfaces which admit cross-module inlining would inherently be unpatchable, and those are likely to be the most performance-sensitive interfaces to begin with.)<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/21ff1972/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Version-pinned patching of public declarations</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 31, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 1:20 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi Joe,<br>&gt; <br>&gt; Can you compare the developer experience with/without this feature, e.g. paint some scenarios and describe what one would have to do to deal with it?<br></p><p>If a binary framework ships with a bug, and that bug is exercised as a second-order effect of other framework functionality, then without dynamic patching, your choices amount to trying to avoid or work around the bug, or reimplementing the functionality between you and the bug yourself (or replacing it with a third party library). If the bug lies somewhere deep like in text layout or affine transform math, or in something complex like PDF rendering (all bugs that have really shipped), replacing the functionality might not be practical, and avoiding the bug might not be possible.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Version-pinned patching of public declarations</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 4:16 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 31, 2015, at 1:20 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Joe,<br>&gt;&gt; <br>&gt;&gt; Can you compare the developer experience with/without this feature, e.g. paint some scenarios and describe what one would have to do to deal with it?<br>&gt; <br>&gt; If a binary framework ships with a bug, and that bug is exercised as a second-order effect of other framework functionality, then without dynamic patching, your choices amount to trying to avoid or work around the bug, or reimplementing the functionality between you and the bug yourself (or replacing it with a third party library). If the bug lies somewhere deep like in text layout or affine transform math, or in something complex like PDF rendering (all bugs that have really shipped), replacing the functionality might not be practical, and avoiding the bug might not be possible.<br></p><p>Sorry, I had something much more specific, including code examples, in mind.  You’re not telling me how you’d use this feature to solve the problem, or what the alternative solutions would look like without this feature.  That’s what I need to see in order to understand the proposal.<br></p><p>-Dave<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[Pitch] Version-pinned patching of public declarations</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>January  1, 2016 at 10:00:00am</p></header><div class="content"><p>I definitely feel this is a great direction for a compromise. This outlines the issues involved well.<br></p><p>Rod<br></p><p>&gt; On 1 Jan 2016, at 6:13 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A lot of the discussion around the final/sealed-by-default issue focused on the ability in ObjC to extend frameworks or fix bugs in unforeseen ways. Framework developers aren&#39;t perfect, and being able to patch a broken framework method can be the difference between shipping and not. On the other hand, these patches become compatibility liabilities for libraries, which have to contend not only with preserving their own designed interface but all the undesigned interactions with shipping apps based on those libraries. The Objective-C model of monkey-patchable-everything has problems, but so does the buttoned-down everything-is-static C++ world many of us rightly fear. However, with the work we&#39;re putting into Swift for resilience and strong versioning support, I think we&#39;re in a good position to try to find a reasonable compromise. I&#39;d like to sketch out a rough idea of how that might look. Public interfaces fundamentally correspond to one or more dynamic library symbols; the same resilience that lets a new framework version interact with older apps gives us an opportunity to patch resilient interfaces at process load time. We could embrace this by allowing applications to provide `@patch` implementations overriding imported non-fragile public APIs at specific versions:<br>&gt; <br>&gt; import Foundation<br>&gt; <br>&gt; extension NSFoo {<br>&gt;   @patch(OSX 10.22, iOS 17)<br>&gt;   func foo() { ... }<br>&gt; }<br>&gt; <br>&gt; By tying the patch to a specific framework version, we lessen the compatibility liability for the framework; it&#39;s clear that, in most cases, the app developer is responsible for testing their app with new framework versions to see if their patch is still needed with each new version. Of course, that&#39;s not always possible—If the framework developer determines during compatibility testing that their new version breaks a must-not-break app, and they aren&#39;t able to adopt a fix on their end for whatever reason (it breaks other apps, or the app&#39;s patch is flawed), the framework could declare that their new version accepts patches for other framework versions too:<br>&gt; <br>&gt; // in Foundation, OSX 10.23<br>&gt; public class NSFoo {<br>&gt;   // Compatibility: AwesomeApp patched the 10.22 version of NSFoo.foo.<br>&gt;   // However, RadicalApp and BodaciousApp rely on the unpatched 10.22 behavior, so<br>&gt;   // we can&#39;t change it.<br>&gt;   @accepts_patch_from(AwesomeApp, OSX 10.22)<br>&gt;   public func foo() { ... }<br>&gt; }<br>&gt; <br>&gt; A sufficiently smart dynamic linker could perhaps resolve these patches at process load time (and probably summarily reject patches for dylibs loaded dynamically with dlopen), avoiding some of the security issues with arbitrary runtime patching. For public entry points to be effectively patchable, we&#39;d have to also avoid any interprocedural optimization of the implementations within the originating module, so there is a performance cost to allowing this patching by default. Sufficiently mature (or arrogant) interfaces could perhaps declare themselves &quot;unpatchable&quot; to admit IPO within their own module. (Note that &#39;fragile&#39; interfaces which admit cross-module inlining would inherently be unpatchable, and those are likely to be the most performance-sensitive interfaces to begin with.)<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/4ddd9d36/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Pitch] Version-pinned patching of public declarations</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January  1, 2016 at 03:00:00pm</p></header><div class="content"><p>How would this extend to third-party libraries that evolve independently of Apple&#39;s release schedule and to the Linux compiler?<br></p><p>Is a patch scoped to the executable object that declares it? For instance, if I have a patch in a library, do applications that link against it see the patch? If I have a Mach-O plugin, does it see the patches that my program made (and vice-versa)? (I&#39;m assuming that the patches go at the PLT/stub level, but let&#39;s be sure that this is what we need and that it doesn&#39;t cause any security interference)<br></p><p>Should patching be allowed in contexts where DYLD_INSERT_LIBRARIES/LD_PRELOAD are currently disallowed?<br></p><p>Félix<br></p><p>&gt; Le 31 déc. 2015 à 14:13:47, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; A lot of the discussion around the final/sealed-by-default issue focused on the ability in ObjC to extend frameworks or fix bugs in unforeseen ways. Framework developers aren&#39;t perfect, and being able to patch a broken framework method can be the difference between shipping and not. On the other hand, these patches become compatibility liabilities for libraries, which have to contend not only with preserving their own designed interface but all the undesigned interactions with shipping apps based on those libraries. The Objective-C model of monkey-patchable-everything has problems, but so does the buttoned-down everything-is-static C++ world many of us rightly fear. However, with the work we&#39;re putting into Swift for resilience and strong versioning support, I think we&#39;re in a good position to try to find a reasonable compromise. I&#39;d like to sketch out a rough idea of how that might look. Public interfaces fundamentally correspond to one or more dynamic library symbols; the same resilience that lets a new framework version interact with older apps gives us an opportunity to patch resilient interfaces at process load time. We could embrace this by allowing applications to provide `@patch` implementations overriding imported non-fragile public APIs at specific versions:<br>&gt; <br>&gt; import Foundation<br>&gt; <br>&gt; extension NSFoo {<br>&gt;   @patch(OSX 10.22, iOS 17)<br>&gt;   func foo() { ... }<br>&gt; }<br>&gt; <br>&gt; By tying the patch to a specific framework version, we lessen the compatibility liability for the framework; it&#39;s clear that, in most cases, the app developer is responsible for testing their app with new framework versions to see if their patch is still needed with each new version. Of course, that&#39;s not always possible—If the framework developer determines during compatibility testing that their new version breaks a must-not-break app, and they aren&#39;t able to adopt a fix on their end for whatever reason (it breaks other apps, or the app&#39;s patch is flawed), the framework could declare that their new version accepts patches for other framework versions too:<br>&gt; <br>&gt; // in Foundation, OSX 10.23<br>&gt; public class NSFoo {<br>&gt;   // Compatibility: AwesomeApp patched the 10.22 version of NSFoo.foo.<br>&gt;   // However, RadicalApp and BodaciousApp rely on the unpatched 10.22 behavior, so<br>&gt;   // we can&#39;t change it.<br>&gt;   @accepts_patch_from(AwesomeApp, OSX 10.22)<br>&gt;   public func foo() { ... }<br>&gt; }<br>&gt; <br>&gt; A sufficiently smart dynamic linker could perhaps resolve these patches at process load time (and probably summarily reject patches for dylibs loaded dynamically with dlopen), avoiding some of the security issues with arbitrary runtime patching. For public entry points to be effectively patchable, we&#39;d have to also avoid any interprocedural optimization of the implementations within the originating module, so there is a performance cost to allowing this patching by default. Sufficiently mature (or arrogant) interfaces could perhaps declare themselves &quot;unpatchable&quot; to admit IPO within their own module. (Note that &#39;fragile&#39; interfaces which admit cross-module inlining would inherently be unpatchable, and those are likely to be the most performance-sensitive interfaces to begin with.)<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/84e83830/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1381c6221c0977f290530ae63827af41?s=50"></div><header><strong>[Pitch] Version-pinned patching of public declarations</strong> from <string>Louis Gerbarg</string> &lt;lgg at apple.com&gt;<p>January  3, 2016 at 12:00:00am</p></header><div class="content"><p>As one of the engineers working on dyld I have a few thoughts on this:<br></p><p>1)	I am not comfortable with one image altering the lazy pointers/PLT/stubs used to call between other images, at least during normal operation. While most OSes don’t actively prevent people from doing this today (if you want to walk through the image lists and the symbol data you can totally find where another image’s function pointers are and rewrite them), allowing it is a way to subvert control flow (think ROP/JOP). There is a good write up about it at &lt;https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/di-frederico&gt;. Suffice it to say, I think most platforms are going to end up having to (further) restrict the ability to interpose in order to protect against these sorts of attacks, so building a language feature around it seems like a bad idea in terms of future proofing/portability.<br></p><p>2)	I am conceptually fine with the semantics that would be exposed by a library rewriting its own lazy pointers/PLT/stubs, though at a practical level I am not comfortable guaranteeing enough stability in the internal interfaces to allow a binary image to embed that machinery inside of itself necessary to do that. Of course, those semantics could be achieved purely in the compiler/static linker by having the @patch generate glue wrapping the patched function that decides whether to call through or use the patched implementation.<br>	This has the virtue of being insulated from the semantic differences between dyld and ld.so, though it is also admittedly a much weaker form of patching then what can be achieved by directing the dynamic linkers to rewrite the pointers of other images.<br></p><p>More comments inline:<br></p><p>&gt; On Jan 1, 2016, at 12:28 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; How would this extend to third-party libraries that evolve independently of Apple&#39;s release schedule and to the Linux compiler?<br>&gt; <br>&gt; Is a patch scoped to the executable object that declares it? For instance, if I have a patch in a library, do applications that link against it see the patch? If I have a Mach-O plugin, does it see the patches that my program made (and vice-versa)? (I&#39;m assuming that the patches go at the PLT/stub level, but let&#39;s be sure that this is what we need and that it doesn&#39;t cause any security interference)<br></p><p>It has to be scoped to the executable image declaring it if you implement it as glue. If it were done through a dynamic linker feature it could conceivably allow other images to be patched, but as stated above, in my view that makes the feature a lot more fragile and insecure. <br></p><p>&gt; Should patching be allowed in contexts where DYLD_INSERT_LIBRARIES/LD_PRELOAD are currently disallowed?<br></p><p>If it is done as glue then this falls out naturally, it should be perfectly safe to allow patches in restricted contexts as it only patches the code explicitly requesting it get it, though it would require more thought. It also should provide rational behavior for dlopen()’ing dylibs that contain patches.<br></p><p>&gt; Félix<br>&gt; <br>&gt;&gt; Le 31 déc. 2015 à 14:13:47, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; A lot of the discussion around the final/sealed-by-default issue focused on the ability in ObjC to extend frameworks or fix bugs in unforeseen ways. Framework developers aren&#39;t perfect, and being able to patch a broken framework method can be the difference between shipping and not. On the other hand, these patches become compatibility liabilities for libraries, which have to contend not only with preserving their own designed interface but all the undesigned interactions with shipping apps based on those libraries. The Objective-C model of monkey-patchable-everything has problems, but so does the buttoned-down everything-is-static C++ world many of us rightly fear. However, with the work we&#39;re putting into Swift for resilience and strong versioning support, I think we&#39;re in a good position to try to find a reasonable compromise. I&#39;d like to sketch out a rough idea of how that might look. Public interfaces fundamentally correspond to one or more dynamic library symbols; the same resilience that lets a new framework version interact with older apps gives us an opportunity to patch resilient interfaces at process load time. We could embrace this by allowing applications to provide `@patch` implementations overriding imported non-fragile public APIs at specific versions:<br>&gt;&gt; <br>&gt;&gt; import Foundation<br>&gt;&gt; <br>&gt;&gt; extension NSFoo {<br>&gt;&gt;  @patch(OSX 10.22, iOS 17)<br>&gt;&gt;  func foo() { ... }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; By tying the patch to a specific framework version, we lessen the compatibility liability for the framework; it&#39;s clear that, in most cases, the app developer is responsible for testing their app with new framework versions to see if their patch is still needed with each new version. Of course, that&#39;s not always possible—If the framework developer determines during compatibility testing that their new version breaks a must-not-break app, and they aren&#39;t able to adopt a fix on their end for whatever reason (it breaks other apps, or the app&#39;s patch is flawed), the framework could declare that their new version accepts patches for other framework versions too:<br>&gt;&gt; <br>&gt;&gt; // in Foundation, OSX 10.23<br>&gt;&gt; public class NSFoo {<br>&gt;&gt;  // Compatibility: AwesomeApp patched the 10.22 version of NSFoo.foo.<br>&gt;&gt;  // However, RadicalApp and BodaciousApp rely on the unpatched 10.22 behavior, so<br>&gt;&gt;  // we can&#39;t change it.<br>&gt;&gt;  @accepts_patch_from(AwesomeApp, OSX 10.22)<br>&gt;&gt;  public func foo() { ... }<br>&gt;&gt; }<br>&gt;&gt; <br></p><p>In a glue model @accepts_patch_from still can be implemented, but rather than the dynamic linker deciding what is patched it would be used to feed data into a runtime call that the @patch generated glue would call into. Again this has the plus side of insulating us from the underlying platforms.<br></p><p>I would really want @accepts_patch_from to also take the version of the AwesomeApp so it conditionally turns off when the version is revved, causing the developer to re-evaluate their code and determine if they can do away with the patch, or if they need to explicitly extend it to the new version.<br></p><p>&gt;&gt; A sufficiently smart dynamic linker could perhaps resolve these patches at process load time (and probably summarily reject patches for dylibs loaded dynamically with dlopen), avoiding some of the security issues with arbitrary runtime patching. For public entry points to be effectively patchable, we&#39;d have to also avoid any interprocedural optimization of the implementations within the originating module, so there is a performance cost to allowing this patching by default. Sufficiently mature (or arrogant) interfaces could perhaps declare themselves &quot;unpatchable&quot; to admit IPO within their own module. (Note that &#39;fragile&#39; interfaces which admit cross-module inlining would inherently be unpatchable, and those are likely to be the most performance-sensitive interfaces to begin with.)<br></p><p>Sufficiently smart dynamic linkers! If you want this implemented as a dynamic linker feature it has to be done in dyld for Darwin and ld.so for Linux. And then implemented in the dynamic linkers for every other port people do. Also various environments may have runtimes that complicate this. For example in some cases (most symbols shipped with iOS/tvOS/watchOS for instance) the jumps into the PLT may be replaced by direct cross image jumps, which breaks the ability to interpose a symbol in between them. As you mentioned above, any patchable interfaces would require jumps through the PLT not just between images, but even within a single dynamic image. While it is an optimization and could be turned off, in practice it is a large optimization and would result in significant performance regressions if we disabled it.<br></p><p>In a glue model the dlopen()ed images behave just like all other images (their patches only impact themselves). In a model where you get the dynamic linker to rewrite other peoples pointers it poses a security risk, but simply disabling it may not viable either. What happens when an image is both dlopen()ed and dynamically linked by another dylib (that is itself perhaps dlopen()ed)? I think it would require a lot of effort to figure out how it would work, how to do it safely, what the semantics would be like, how hot would cope with differences between OSes (Two level namespaces vs flat namespaces, etc).<br></p><p>Again, the glue model is substantially weaker patching (really it is just sugar for writing wrappers and runtime management for activating them), but as I said above, building in support for patching out our stubs and adding all the machinery to support general interposing for all APIs seems like it would present portability, performance, and security issues.<br></p><p>Louis<br></p><p>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -------------- next part --------------<br>&gt; An HTML attachment was scrubbed...<br>&gt; URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/84e83830/attachment.html&gt;<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Version-pinned patching of public declarations</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  3, 2016 at 09:00:00am</p></header><div class="content"><p>Sorry if this should be clear already, but are you suggesting that @patch would allow patching of final or sealed types thus making them more palatable as defaults?  This would surprise me, but if that is not what you are suggesting I don&#39;t follow how it relates to the final / sealed discussion.<br></p><p>Matthew<br></p><p>Sent from my iPad<br></p><p>&gt; On Dec 31, 2015, at 1:13 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A lot of the discussion around the final/sealed-by-default issue focused on the ability in ObjC to extend frameworks or fix bugs in unforeseen ways. Framework developers aren&#39;t perfect, and being able to patch a broken framework method can be the difference between shipping and not. On the other hand, these patches become compatibility liabilities for libraries, which have to contend not only with preserving their own designed interface but all the undesigned interactions with shipping apps based on those libraries. The Objective-C model of monkey-patchable-everything has problems, but so does the buttoned-down everything-is-static C++ world many of us rightly fear. However, with the work we&#39;re putting into Swift for resilience and strong versioning support, I think we&#39;re in a good position to try to find a reasonable compromise. I&#39;d like to sketch out a rough idea of how that might look. Public interfaces fundamentally correspond to one or more dynamic library symbols; the same resilience that lets a new framework version interact with older apps gives us an opportunity to patch resilient interfaces at process load time. We could embrace this by allowing applications to provide `@patch` implementations overriding imported non-fragile public APIs at specific versions:<br>&gt; <br>&gt; import Foundation<br>&gt; <br>&gt; extension NSFoo {<br>&gt;   @patch(OSX 10.22, iOS 17)<br>&gt;   func foo() { ... }<br>&gt; }<br>&gt; <br>&gt; By tying the patch to a specific framework version, we lessen the compatibility liability for the framework; it&#39;s clear that, in most cases, the app developer is responsible for testing their app with new framework versions to see if their patch is still needed with each new version. Of course, that&#39;s not always possible—If the framework developer determines during compatibility testing that their new version breaks a must-not-break app, and they aren&#39;t able to adopt a fix on their end for whatever reason (it breaks other apps, or the app&#39;s patch is flawed), the framework could declare that their new version accepts patches for other framework versions too:<br>&gt; <br>&gt; // in Foundation, OSX 10.23<br>&gt; public class NSFoo {<br>&gt;   // Compatibility: AwesomeApp patched the 10.22 version of NSFoo.foo.<br>&gt;   // However, RadicalApp and BodaciousApp rely on the unpatched 10.22 behavior, so<br>&gt;   // we can&#39;t change it.<br>&gt;   @accepts_patch_from(AwesomeApp, OSX 10.22)<br>&gt;   public func foo() { ... }<br>&gt; }<br>&gt; <br>&gt; A sufficiently smart dynamic linker could perhaps resolve these patches at process load time (and probably summarily reject patches for dylibs loaded dynamically with dlopen), avoiding some of the security issues with arbitrary runtime patching. For public entry points to be effectively patchable, we&#39;d have to also avoid any interprocedural optimization of the implementations within the originating module, so there is a performance cost to allowing this patching by default. Sufficiently mature (or arrogant) interfaces could perhaps declare themselves &quot;unpatchable&quot; to admit IPO within their own module. (Note that &#39;fragile&#39; interfaces which admit cross-module inlining would inherently be unpatchable, and those are likely to be the most performance-sensitive interfaces to begin with.)<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160103/c6fee33c/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
