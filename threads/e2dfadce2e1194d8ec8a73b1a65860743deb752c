<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March 24, 2016 at 01:00:00pm</p></header><div class="content"><p>When I started using Swift I was initially very enthusiastic about trailing closures, but I’ve actually kind of gone off them somewhat and I’d like to discuss why.<br></p><p>Firstly, here are two ways to write a common example using the .map() method:<br></p><p>	let foo = myArray.map { $0 + 1 }<br>	let foo = myArray.map({ $0 + 1 })<br></p><p>It’s tough to say that the first form is any neater than the second, other than the second having more brackets. However, the first form is somewhat ambiguous, as .map in this case looks like a property rather than a method, it also visually looks like a statement, followed by a closure rather than the two things logically being related. Of course it’s quick to learn that these are related, but for consistency I’m starting to now prefer the use of parenthesis in almost all cases.<br></p><p>The other advantage of trailing closures is the omission of the label, but trailing closures aren’t strictly necessary for this, as we can already omit external labels for parameters if we want to, and the example above shows that a trailing closure isn’t necessary for this. The only real difference is that the trailing closure form makes a label optional, because you can either provide the closure with label in parenthesis (if the label is required) or omit it by trailing, like so:<br></p><p>	something.someMethod(foo: 1, predicate: { $0 &lt; $1})<br>	something.someMethod(foo: 1) { $0 &lt; $1}<br></p><p>However this kind of arbitrarily makes the following impossible:<br></p><p>	something.someMethod(foo: 1, { $0 &lt; $1 })<br></p><p>With this in mind it seems to me that we might be better served by the ability to make external labels optional, as this would allow us to be just as succinct, while being completely clear about what is being passed into this method.<br></p><p><br>The only real remaining advantage that I see to trailing closures is the ability to define pseudo language constructs, for example:<br></p><p>	func repeatUntilEmpty&lt;C:CollectionType&gt;(collection:C, @noescape _ body:() throws -&gt; Void) rethrows { while !collection.isEmpty { body() } }<br>	repeatUntilEmpty(myArray) {<br>		/* Do something over and over until myArray is empty */<br>	}<br></p><p>Which I think is a pretty uncommon type of structure, but could be useful in some specialised situations. To support this though we could easily use a new @trailing attribute instead to indicate that the closure can be used in this way. My example isn’t very good as I can’t think of a case that really, really needs this, but I think they’re probably out there.<br></p><p><br>To summarise, having come down off my initial enthusiasm for trailing closures I’m not sure that they really add that much syntactically, especially in the most common cases, while actually being a little ambiguous looking and adding inconsistency to the language. I think they should remain for the less common cases that can really benefit from them, but as a feature that is opted into, so that we can go for consistency by default.<br></p><p>I’m interested to hear other people’s thoughts.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/e2df752c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/27ca9066ad05bd8aa9ec366115f3cd38?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>Kurt Werle</string> &lt;kurt at circlew.org&gt;<p>March 24, 2016 at 07:00:00am</p></header><div class="content"><p>Coming from ruby, I&#39;m quite fond of trailing closures.  I couldn&#39;t really<br>give you a concrete reason why - putting them in the ()&#39;s really isn&#39;t that<br>big a deal.  But I&#39;ll say that I move them outside every single time...<br></p><p>I will say that your examples are the most trivial possible and that the<br>more complex the closure (describing context variables and return types,<br>throws, etc) the uglier it seem to me to put it inside parens.<br></p><p>On Thu, Mar 24, 2016 at 6:57 AM, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; When I started using Swift I was initially very enthusiastic about<br>&gt; trailing closures, but I’ve actually kind of gone off them somewhat and I’d<br>&gt; like to discuss why.<br>&gt;<br>&gt; Firstly, here are two ways to write a common example using the .map()<br>&gt; method:<br>&gt;<br>&gt; let foo = myArray.map { $0 + 1 }<br>&gt; let foo = myArray.map({ $0 + 1 })<br>&gt;<br>&gt; It’s tough to say that the first form is any neater than the second, other<br>&gt; than the second having more brackets. However, the first form is somewhat<br>&gt; ambiguous, as .map in this case looks like a property rather than a method,<br>&gt; it also visually looks like a statement, followed by a closure rather than<br>&gt; the two things logically being related. Of course it’s quick to learn that<br>&gt; these are related, but for consistency I’m starting to now prefer the use<br>&gt; of parenthesis in almost all cases.<br>&gt;<br>&gt; The other advantage of trailing closures is the omission of the label, but<br>&gt; trailing closures aren’t strictly necessary for this, as we can already<br>&gt; omit external labels for parameters if we want to, and the example above<br>&gt; shows that a trailing closure isn’t necessary for this. The only real<br>&gt; difference is that the trailing closure form makes a label optional,<br>&gt; because you can either provide the closure with label in parenthesis (if<br>&gt; the label is required) or omit it by trailing, like so:<br>&gt;<br>&gt; something.someMethod(foo: 1, predicate: { $0 &lt; $1})<br>&gt; something.someMethod(foo: 1) { $0 &lt; $1}<br>&gt;<br>&gt; However this kind of arbitrarily makes the following impossible:<br>&gt;<br>&gt; something.someMethod(foo: 1, { $0 &lt; $1 })<br>&gt;<br>&gt; With this in mind it seems to me that we might be better served by the<br>&gt; ability to make external labels optional, as this would allow us to be just<br>&gt; as succinct, while being completely clear about what is being passed into<br>&gt; this method.<br>&gt;<br>&gt;<br>&gt; The only real remaining advantage that I see to trailing closures is the<br>&gt; ability to define pseudo language constructs, for example:<br>&gt;<br>&gt; func repeatUntilEmpty&lt;C:CollectionType&gt;(collection:C, @noescape _ body:()<br>&gt; throws -&gt; Void) rethrows { while !collection.isEmpty { body() } }<br>&gt; repeatUntilEmpty(myArray) {<br>&gt; /* Do something over and over until myArray is empty */<br>&gt; }<br>&gt;<br>&gt; Which I think is a pretty uncommon type of structure, but could be useful<br>&gt; in some specialised situations. To support this though we could easily use<br>&gt; a new @trailing attribute instead to indicate that the closure can be used<br>&gt; in this way. My example isn’t very good as I can’t think of a case that<br>&gt; really, really needs this, but I think they’re probably out there.<br>&gt;<br>&gt;<br>&gt; To summarise, having come down off my initial enthusiasm for trailing<br>&gt; closures I’m not sure that they really add that much syntactically,<br>&gt; especially in the most common cases, while actually being a little<br>&gt; ambiguous looking and adding inconsistency to the language. I think they<br>&gt; should remain for the less common cases that can really benefit from them,<br>&gt; but as a feature that is opted into, so that we can go for consistency by<br>&gt; default.<br>&gt;<br>&gt; I’m interested to hear other people’s thoughts.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>kurt at CircleW.org<br>http://www.CircleW.org/kurt/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/d62f06f5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March 24, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On 24 Mar 2016, at 14:18, Kurt Werle &lt;kurt at circlew.org&gt; wrote:<br>&gt; <br>&gt; Coming from ruby, I&#39;m quite fond of trailing closures.  I couldn&#39;t really give you a concrete reason why - putting them in the ()&#39;s really isn&#39;t that big a deal.  But I&#39;ll say that I move them outside every single time...<br>&gt; <br>&gt; I will say that your examples are the most trivial possible and that the more complex the closure (describing context variables and return types, throws, etc) the uglier it seem to me to put it inside parens.<br></p><p>Perhaps, but if you’re getting that onto a single line then it starts to look ugly regardless IMO, whereas splitting it across multiple lines isn’t really any different with or without being in the parenthesis, except that the closing parenthesis at least clarifies that it was a method you’re closing, for example:<br></p><p>	var modifier = true<br>	let foo = myArray.map({<br>		var result = $0<br>		if modifier { result = -result }<br></p><p>		modifier = !modifier<br>		return result<br>	})<br></p><p>I dunno, I guess I’m just struggling to find cases in my own code where they really offer much of an advantage to justify having a distinctly different way of doing things, with the ambiguity and inconsistency that represents, which is why I’ve brought it up to discuss; i.e- do we use them just because they exist? Trivial aesthetic difference? Personal preference only?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/0d4dfbbd/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b9904260218b6d7942782c2b2355f2aa?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>William Dillon</string> &lt;william at housedillon.com&gt;<p>March 24, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Mar 24, 2016, at 7:18 AM, Kurt Werle via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Coming from ruby, I&#39;m quite fond of trailing closures.  I couldn&#39;t really give you a concrete reason why - putting them in the ()&#39;s really isn&#39;t that big a deal.  But I&#39;ll say that I move them outside every single time...<br>&gt; <br>&gt; I will say that your examples are the most trivial possible and that the more complex the closure (describing context variables and return types, throws, etc) the uglier it seem to me to put it inside parens.<br>&gt; <br></p><p>Agree.<br></p><p>Another thing I like about trailing closures is that it allows me to make custom constructs that feel more like a part of the language.  For example, I really love this extension for NSLock that I have:<br></p><p>extension NSLock {<br>    func protect(action: (Void) -&gt; Void) {<br>        self.lock()<br>        action()<br>        self.unlock()<br>    }<br>}<br></p><p>Now, whenever I need to use my lock, I can just do:<br></p><p>peersLock.protect {<br>    outputString += &quot;\(self.peers.count) peers:\n&quot;<br>    for (_, peer) in self.peers {<br>        outputString += &quot;\(peer)\n&quot;<br>    }<br>}<br></p><p>To me, it looks cleaner to me to not have this paren dangling around at the end.  On this one I’d definitely say that if you don’t like it, don’t use it.  I don’t *think* that you’re forced to use it anywhere.  It’s a hard sell to take it away from everyone.<br></p><p>- Will<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/a9176cb1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>March 24, 2016 at 04:00:00pm</p></header><div class="content"><p>I think the feature should stay but we need community guidelines on when<br>and when not to use them.<br></p><p>*___________________________________*<br></p><p>*James⎥Head Of CEO*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On Thu, Mar 24, 2016 at 4:13 PM, William Dillon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Mar 24, 2016, at 7:18 AM, Kurt Werle via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Coming from ruby, I&#39;m quite fond of trailing closures.  I couldn&#39;t really<br>&gt; give you a concrete reason why - putting them in the ()&#39;s really isn&#39;t that<br>&gt; big a deal.  But I&#39;ll say that I move them outside every single time...<br>&gt;<br>&gt; I will say that your examples are the most trivial possible and that the<br>&gt; more complex the closure (describing context variables and return types,<br>&gt; throws, etc) the uglier it seem to me to put it inside parens.<br>&gt;<br>&gt;<br>&gt; Agree.<br>&gt;<br>&gt; Another thing I like about trailing closures is that it allows me to make<br>&gt; custom constructs that feel more like a part of the language.  For example,<br>&gt; I really love this extension for NSLock that I have:<br>&gt;<br>&gt; extension NSLock {<br>&gt;     func protect(action: (Void) -&gt; Void) {<br>&gt;         self.lock()<br>&gt;         action()<br>&gt;         self.unlock()<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Now, whenever I need to use my lock, I can just do:<br>&gt;<br>&gt; peersLock.protect {<br>&gt;     outputString += &quot;\(self.peers.count) peers:\n&quot;<br>&gt;     for (_, peer) in self.peers {<br>&gt;         outputString += &quot;\(peer)\n&quot;<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; To me, it looks cleaner to me to not have this paren dangling around at<br>&gt; the end.  On this one I’d definitely say that if you don’t like it, don’t<br>&gt; use it.  I don’t *think* that you’re forced to use it anywhere.  It’s a<br>&gt; hard sell to take it away from everyone.<br>&gt;<br>&gt; - Will<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/73fb8e2d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9df2c06d044639a33128b3b66f0b6509?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>Juan Ignacio Laube</string> &lt;juanignaciolaube at gmail.com&gt;<p>March 24, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; I think the feature should stay but we need community guidelines on when and when not to use them.<br></p><p>I agree with James here.<br></p><p><br>&gt; On Mar 24, 2016, at 1:15 PM, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think the feature should stay but we need community guidelines on when and when not to use them.<br>&gt; <br>&gt; ___________________________________<br>&gt; <br>&gt; James⎥Head Of CEO<br>&gt; <br>&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com/&gt;<br>&gt; Sup<br>&gt; <br>&gt; Runway East &gt; <br>&gt; <br>&gt; 10 Finsbury Square<br>&gt; <br>&gt; London<br>&gt; <br>&gt;  &gt; EC2A 1AF <br>&gt; <br>&gt; <br>&gt; On Thu, Mar 24, 2016 at 4:13 PM, William Dillon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; On Mar 24, 2016, at 7:18 AM, Kurt Werle via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Coming from ruby, I&#39;m quite fond of trailing closures.  I couldn&#39;t really give you a concrete reason why - putting them in the ()&#39;s really isn&#39;t that big a deal.  But I&#39;ll say that I move them outside every single time...<br>&gt;&gt; <br>&gt;&gt; I will say that your examples are the most trivial possible and that the more complex the closure (describing context variables and return types, throws, etc) the uglier it seem to me to put it inside parens.<br>&gt;&gt; <br>&gt; <br>&gt; Agree.<br>&gt; <br>&gt; Another thing I like about trailing closures is that it allows me to make custom constructs that feel more like a part of the language.  For example, I really love this extension for NSLock that I have:<br>&gt; <br>&gt; extension NSLock {<br>&gt;     func protect(action: (Void) -&gt; Void) {<br>&gt;         self.lock()<br>&gt;         action()<br>&gt;         self.unlock()<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Now, whenever I need to use my lock, I can just do:<br>&gt; <br>&gt; peersLock.protect {<br>&gt;     outputString += &quot;\(self.peers.count) peers:\n&quot;<br>&gt;     for (_, peer) in self.peers {<br>&gt;         outputString += &quot;\(peer)\n&quot;<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; To me, it looks cleaner to me to not have this paren dangling around at the end.  On this one I’d definitely say that if you don’t like it, don’t use it.  I don’t *think* that you’re forced to use it anywhere.  It’s a hard sell to take it away from everyone.<br>&gt; <br>&gt; - Will<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/8c7dd7c3/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March 24, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On 24 Mar 2016, at 16:13, William Dillon &lt;william at housedillon.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Mar 24, 2016, at 7:18 AM, Kurt Werle via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Coming from ruby, I&#39;m quite fond of trailing closures.  I couldn&#39;t really give you a concrete reason why - putting them in the ()&#39;s really isn&#39;t that big a deal.  But I&#39;ll say that I move them outside every single time...<br>&gt;&gt; <br>&gt;&gt; I will say that your examples are the most trivial possible and that the more complex the closure (describing context variables and return types, throws, etc) the uglier it seem to me to put it inside parens.<br>&gt;&gt; <br>&gt; <br>&gt; Agree.<br>&gt; <br>&gt; Another thing I like about trailing closures is that it allows me to make custom constructs that feel more like a part of the language.  For example, I really love this extension for NSLock that I have:<br>&gt; <br>&gt; extension NSLock {<br>&gt;     func protect(action: (Void) -&gt; Void) {<br>&gt;         self.lock()<br>&gt;         action()<br>&gt;         self.unlock()<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Now, whenever I need to use my lock, I can just do:<br>&gt; <br>&gt; peersLock.protect {<br>&gt;     outputString += &quot;\(self.peers.count) peers:\n&quot;<br>&gt;     for (_, peer) in self.peers {<br>&gt;         outputString += &quot;\(peer)\n&quot;<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; To me, it looks cleaner to me to not have this paren dangling around at the end.  On this one I’d definitely say that if you don’t like it, don’t use it.  I don’t *think* that you’re forced to use it anywhere.  It’s a hard sell to take it away from everyone.<br>&gt; <br>&gt; - Will<br></p><p>I’m not proposing to remove them entirely, in fact your lock example is a perfect example of when a trailing closure makes the most sense, as a form of customised language feature. But I’m wondering if perhaps cases like these should be created using an attribute that specifically enables it? e.g- your definition could become:<br></p><p>	func protect(action: @trailing (Void) -&gt; Void) { … }<br></p><p>It’s other cases like common usages of .map() and similar methods where I’ve found myself using the closure in its trailing form less and less, and am not as sure if it’s really needed, or may actually be more of a detriment to the language than a benefit.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/17180f78/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 24, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 24, 2016, at 10:41 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On 24 Mar 2016, at 16:13, William Dillon &lt;william at housedillon.com &lt;mailto:william at housedillon.com&gt;&gt; wrote:<br>&gt;&gt; Another thing I like about trailing closures is that it allows me to make custom constructs that feel more like a part of the language.  For example, I really love this extension for NSLock that I have:<br>&gt;&gt; <br>&gt;&gt; extension NSLock {<br>&gt;&gt;     func protect(action: (Void) -&gt; Void) {<br>&gt;&gt;         self.lock()<br>&gt;&gt;         action()<br>&gt;&gt;         self.unlock()<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Now, whenever I need to use my lock, I can just do:<br>&gt;&gt; <br>&gt;&gt; peersLock.protect {<br>&gt;&gt;     outputString += &quot;\(self.peers.count) peers:\n&quot;<br>&gt;&gt;     for (_, peer) in self.peers {<br>&gt;&gt;         outputString += &quot;\(peer)\n&quot;<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; To me, it looks cleaner to me to not have this paren dangling around at the end.  On this one I’d definitely say that if you don’t like it, don’t use it.  I don’t *think* that you’re forced to use it anywhere.  It’s a hard sell to take it away from everyone.<br>&gt;&gt; <br>&gt;&gt; - Will<br>&gt; <br>&gt; I’m not proposing to remove them entirely, in fact your lock example is a perfect example of when a trailing closure makes the most sense, as a form of customised language feature. But I’m wondering if perhaps cases like these should be created using an attribute that specifically enables it? e.g- your definition could become:<br>&gt; <br>&gt; 	func protect(action: @trailing (Void) -&gt; Void) { … }<br>&gt; <br>&gt; It’s other cases like common usages of .map() and similar methods where I’ve found myself using the closure in its trailing form less and less, and am not as sure if it’s really needed, or may actually be more of a detriment to the language than a benefit.<br></p><p>I follow the &quot;Rule of Kevin&quot;, which is not language enforced. Parens around functional <br>closures (-&gt;T), not around procedural (-&gt;Void) ones.  This promotes &quot;language construct&quot;-like <br>Void calls, avoids compiler parsing issues when chaining (or using &quot;guard&quot;, &quot;if&quot;, etc). It lets<br>me know instantly how the closure is used. <br></p><p>While I was originally reluctant to adopt it, its advantages have become self-evident over time. <br>This ends up being slightly wordier, especially in the few cases you need to use argument labels. <br></p><p>I think it&#39;s worth it.<br></p><p>-- E<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/35688485/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/49f329a0267f5a1773a77017882a82a8?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>Rainer Brockerhoff</string> &lt;rainer at brockerhoff.net&gt;<p>March 24, 2016 at 02:00:00pm</p></header><div class="content"><p>On 3/24/16 13:59, Erica Sadun via swift-evolution wrote:<br>&gt;&gt; On Mar 24, 2016, at 10:41 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 24 Mar 2016, at 16:13, William Dillon &lt;william at housedillon.com &lt;mailto:william at housedillon.com&gt;&gt; wrote:<br>&gt;&gt;&gt; Another thing I like about trailing closures is that it allows me to make custom constructs that feel more like a part of the language.  For example, I really love this extension for NSLock that I have:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension NSLock {<br>&gt;&gt;&gt;     func protect(action: (Void) -&gt; Void) {<br>&gt;&gt;&gt;         self.lock()<br>&gt;&gt;&gt;         action()<br>&gt;&gt;&gt;         self.unlock()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Now, whenever I need to use my lock, I can just do:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; peersLock.protect {<br>&gt;&gt;&gt;     outputString += &quot;\(self.peers.count) peers:\n&quot;<br>&gt;&gt;&gt;     for (_, peer) in self.peers {<br>&gt;&gt;&gt;         outputString += &quot;\(peer)\n&quot;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; To me, it looks cleaner to me to not have this paren dangling around at the end.  On this one I’d definitely say that if you don’t like it, don’t use it.  I don’t *think* that you’re forced to use it anywhere.  It’s a hard sell to take it away from everyone.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Will<br>&gt;&gt;<br>&gt;&gt; I’m not proposing to remove them entirely, in fact your lock example is a perfect example of when a trailing closure makes the most sense, as a form of customised language feature. But I’m wondering if perhaps cases like these should be created using an attribute that specifically enables it? e.g- your definition could become:<br>&gt;&gt;<br>&gt;&gt; 	func protect(action: @trailing (Void) -&gt; Void) { … }<br>&gt;&gt;<br>&gt;&gt; It’s other cases like common usages of .map() and similar methods where I’ve found myself using the closure in its trailing form less and less, and am not as sure if it’s really needed, or may actually be more of a detriment to the language than a benefit.<br>&gt; <br>&gt; I follow the &quot;Rule of Kevin&quot;, which is not language enforced. Parens around functional <br>&gt; closures (-&gt;T), not around procedural (-&gt;Void) ones.  This promotes &quot;language construct&quot;-like <br>&gt; Void calls, avoids compiler parsing issues when chaining (or using &quot;guard&quot;, &quot;if&quot;, etc). It lets<br>&gt; me know instantly how the closure is used. <br>&gt; <br>&gt; While I was originally reluctant to adopt it, its advantages have become self-evident over time. <br>&gt; This ends up being slightly wordier, especially in the few cases you need to use argument labels. <br></p><p>I find trailing closures extremely valuable for APIs like GCD and<br>NSURLSession and derivates. No more dangling )s.<br></p><p>It&#39;s probably my own (style) fault, but in ObjC I sometimes see lines like<br>	})]}));<br>making my own code become read-only :-)<br></p><p>-- <br>Rainer Brockerhoff  &lt;rainer at brockerhoff.net&gt;<br>Belo Horizonte, Brazil<br>&quot;In the affairs of others even fools are wise<br>In their own business even sages err.&quot;<br>http://brockerhoff.net/blog/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March 24, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 24 Mar 2016, at 16:59, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; I follow the &quot;Rule of Kevin&quot;, which is not language enforced. Parens around functional <br>&gt; closures (-&gt;T), not around procedural (-&gt;Void) ones.  This promotes &quot;language construct&quot;-like <br>&gt; Void calls, avoids compiler parsing issues when chaining (or using &quot;guard&quot;, &quot;if&quot;, etc). It lets<br>&gt; me know instantly how the closure is used. <br>&gt; <br>&gt; While I was originally reluctant to adopt it, its advantages have become self-evident over time. <br>&gt; This ends up being slightly wordier, especially in the few cases you need to use argument labels. <br>&gt; <br>&gt; I think it&#39;s worth it.<br></p><p>That’s a pretty good rule, and I think it’s what I’m now doing myself as well. Any thoughts on whether it should be enforced, though?<br>There’s a thread currently about allowing trailing closures within guard etc., but personally I think that that’s a bad idea, and that it may actually be better to head in the opposite direction (use them less), but currently it’s an automatic feature which I’m not sure is a good thing.<br></p><p>Given your “Rule of Kevin” we could have the a rule for closures as a last parameter that if they have a non-Void return type, they must add a new @trailing attribute, otherwise trailing is implied.<br></p><p><br>I realise there’s an argument to be made that it should just be up to linters or personal preference, but I’m concerned that many developers like myself will use trailing closures everywhere they’re permitted because it seems like the right thing to do, and only later start to consider whether it’s a good idea to actually use them in specific cases. But for consistency’s sake I’d say it’s not good to use them except for language construct type calls (like .forEach actually, which I always forget about too), which is where the main advantage lies.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/f0fba8ed/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 24, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Mar 24, 2016, at 11:57 AM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 24 Mar 2016, at 16:59, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I follow the &quot;Rule of Kevin&quot;, which is not language enforced. Parens around functional <br>&gt;&gt; closures (-&gt;T), not around procedural (-&gt;Void) ones.  This promotes &quot;language construct&quot;-like <br>&gt;&gt; Void calls, avoids compiler parsing issues when chaining (or using &quot;guard&quot;, &quot;if&quot;, etc). It lets<br>&gt;&gt; me know instantly how the closure is used. <br>&gt;&gt; <br>&gt;&gt; While I was originally reluctant to adopt it, its advantages have become self-evident over time. <br>&gt;&gt; This ends up being slightly wordier, especially in the few cases you need to use argument labels. <br>&gt;&gt; <br>&gt;&gt; I think it&#39;s worth it.<br>&gt; <br>&gt; That’s a pretty good rule, and I think it’s what I’m now doing myself as well. Any thoughts on whether it should be enforced, though?<br>&gt; There’s a thread currently about allowing trailing closures within guard etc., but personally I think that that’s a bad idea, and that it may actually be better to head in the opposite direction (use them less), but currently it’s an automatic feature which I’m not sure is a good thing.<br>&gt; <br>&gt; Given your “Rule of Kevin” we could have the a rule for closures as a last parameter that if they have a non-Void return type, they must add a new @trailing attribute, otherwise trailing is implied.<br>&gt; <br>&gt; <br>&gt; I realise there’s an argument to be made that it should just be up to linters or personal preference, but I’m concerned that many developers like myself will use trailing closures everywhere they’re permitted because it seems like the right thing to do, and only later start to consider whether it’s a good idea to actually use them in specific cases. But for consistency’s sake I’d say it’s not good to use them except for language construct type calls (like .forEach actually, which I always forget about too), which is where the main advantage lies.<br></p><p>I&#39;m agnostic on enforcement. I&#39;m unthrilled about adding `@trailing`.<br></p><p>-- E<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/3c4af5b5/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>March 31, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On 24 Mar 2016, at 18:57, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; That’s a pretty good rule, and I think it’s what I’m now doing myself as well. Any thoughts on whether it should be enforced, though?<br>&gt; There’s a thread currently about allowing trailing closures within guard etc., but personally I think that that’s a bad idea, and that it may actually be better to head in the opposite direction (use them less), but currently it’s an automatic feature which I’m not sure is a good thing.<br>&gt; <br>&gt; Given your “Rule of Kevin” we could have the a rule for closures as a last parameter that if they have a non-Void return type, they must add a new @trailing attribute, otherwise trailing is implied.<br>&gt; <br>&gt; <br>&gt; I realise there’s an argument to be made that it should just be up to linters or personal preference, but I’m concerned that many developers like myself will use trailing closures everywhere they’re permitted because it seems like the right thing to do, and only later start to consider whether it’s a good idea to actually use them in specific cases. But for consistency’s sake I’d say it’s not good to use them except for language construct type calls (like .forEach actually, which I always forget about too), which is where the main advantage lies.<br>&gt; _______________________________________________<br></p><p><br>I don’t see how trailing closures, or lack thereof, is special enough to enforce like that. I mean, you could say that about so many features. Should we even allow “init?” and leave it up to personal preference, if only later will developers consider if it’s actually a good idea and they shouldn’t use “init throws”?<br></p><p>I’d be sad to see trailing closures go, but it’s a reasonable proposal to make. However, enforcing usage of trailing closures (a mainly stylistic choice that doesn’t even have the same safety concerns as the “remove implicit self” discussion) seems pointless.<br></p><p>— Radek<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/dd788e42/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>March 31, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt;&gt; I’m not proposing to remove them entirely, in fact your lock example is a perfect example of when a trailing closure makes the most sense, as a form of customised language feature. But I’m wondering if perhaps cases like these should be created using an attribute that specifically enables it? e.g- your definition could become:<br>&gt;&gt; <br>&gt;&gt; 	func protect(action: @trailing (Void) -&gt; Void) { … }<br>&gt;&gt; <br>&gt;&gt; It’s other cases like common usages of .map() and similar methods where I’ve found myself using the closure in its trailing form less and less, and am not as sure if it’s really needed, or may actually be more of a detriment to the language than a benefit.<br>&gt; <br>&gt; I follow the &quot;Rule of Kevin&quot;, which is not language enforced. Parens around functional <br>&gt; closures (-&gt;T), not around procedural (-&gt;Void) ones.  This promotes &quot;language construct&quot;-like <br>&gt; Void calls, avoids compiler parsing issues when chaining (or using &quot;guard&quot;, &quot;if&quot;, etc). It lets<br>&gt; me know instantly how the closure is used. <br>&gt; <br>&gt; While I was originally reluctant to adopt it, its advantages have become self-evident over time. <br>&gt; This ends up being slightly wordier, especially in the few cases you need to use argument labels. <br>&gt; <br>&gt; I think it&#39;s worth it.<br></p><p>I don’t follow the Rule of Kevin myself, although I’m not against it either, and I see why some people would like it.<br></p><p>But, if we’re going to have trailing closures at all (which seems desirable for creating things that look like language features), enforcement based on syntactic preference doesn’t make sense to me.<br></p><p>This really reminds me of a “remove implicit self” discussion. Some people (me included) were against, because they disliked the noisiness of “self” everywhere. Others argued that the implicitness is somewhat unsafe. A valid position to take. But it’s a kind of thing teams can use a linter for, if they want to enforce it as a rule.<br></p><p>Trailing closures seem like a similar thing. We could remove it altogether (although I think that would be a shame), or let’s just leave it up to preference (and developing guidelines) on where to use them.<br></p><p>Best,<br>— Radek<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/c75f7e8e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 31, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Mar 31, 2016, at 5:56 AM, Radosław Pietruszewski &lt;radexpl at gmail.com&gt; wrote:<br>&gt;&gt; I follow the &quot;Rule of Kevin&quot;, which is not language enforced. Parens around functional <br>&gt;&gt; closures (-&gt;T), not around procedural (-&gt;Void) ones.  This promotes &quot;language construct&quot;-like <br>&gt;&gt; Void calls, avoids compiler parsing issues when chaining (or using &quot;guard&quot;, &quot;if&quot;, etc). It lets<br>&gt;&gt; me know instantly how the closure is used. <br>&gt;&gt; <br>&gt;&gt; While I was originally reluctant to adopt it, its advantages have become self-evident over time. <br>&gt;&gt; This ends up being slightly wordier, especially in the few cases you need to use argument labels. <br>&gt;&gt; <br>&gt;&gt; I think it&#39;s worth it.<br>&gt; <br>&gt; I don’t follow the Rule of Kevin myself, although I’m not against it either, and I see why some people would like it.<br>&gt; <br>&gt; But, if we’re going to have trailing closures at all (which seems desirable for creating things that look like language features), enforcement based on syntactic preference doesn’t make sense to me.<br>&gt; <br>&gt; This really reminds me of a “remove implicit self” discussion. Some people (me included) were against, because they disliked the noisiness of “self” everywhere. Others argued that the implicitness is somewhat unsafe. A valid position to take. But it’s a kind of thing teams can use a linter for, if they want to enforce it as a rule.<br>&gt; <br>&gt; Trailing closures seem like a similar thing. We could remove it altogether (although I think that would be a shame), or let’s just leave it up to preference (and developing guidelines) on where to use them.<br>&gt; <br>&gt; Best,<br>&gt; — Radek<br></p><p>Following a style rule is just like using a linter. It&#39;s not language mandated and I have not argued for enforcement.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/3dbc1283/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>April  1, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 31 Mar 2016, at 16:08, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 31, 2016, at 5:56 AM, Radosław Pietruszewski &lt;radexpl at gmail.com &lt;mailto:radexpl at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; I follow the &quot;Rule of Kevin&quot;, which is not language enforced. Parens around functional <br>&gt;&gt;&gt; closures (-&gt;T), not around procedural (-&gt;Void) ones.  This promotes &quot;language construct&quot;-like <br>&gt;&gt;&gt; Void calls, avoids compiler parsing issues when chaining (or using &quot;guard&quot;, &quot;if&quot;, etc). It lets<br>&gt;&gt;&gt; me know instantly how the closure is used. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While I was originally reluctant to adopt it, its advantages have become self-evident over time. <br>&gt;&gt;&gt; This ends up being slightly wordier, especially in the few cases you need to use argument labels. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it&#39;s worth it.<br>&gt;&gt; <br>&gt;&gt; I don’t follow the Rule of Kevin myself, although I’m not against it either, and I see why some people would like it.<br>&gt;&gt; <br>&gt;&gt; But, if we’re going to have trailing closures at all (which seems desirable for creating things that look like language features), enforcement based on syntactic preference doesn’t make sense to me.<br>&gt;&gt; <br>&gt;&gt; This really reminds me of a “remove implicit self” discussion. Some people (me included) were against, because they disliked the noisiness of “self” everywhere. Others argued that the implicitness is somewhat unsafe. A valid position to take. But it’s a kind of thing teams can use a linter for, if they want to enforce it as a rule.<br>&gt;&gt; <br>&gt;&gt; Trailing closures seem like a similar thing. We could remove it altogether (although I think that would be a shame), or let’s just leave it up to preference (and developing guidelines) on where to use them.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; — Radek<br>&gt; <br>&gt; Following a style rule is just like using a linter. It&#39;s not language mandated and I have not argued for enforcement.<br>&gt; <br>&gt; -- E<br></p><p>Apologies, I didn’t mean to suggest you argued for enforcement. Just adding my 2¢ about why enforcement makes no sense to me.<br></p><p>Best,<br>— Radek<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160401/4966aca3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March 24, 2016 at 04:00:00pm</p></header><div class="content"><p>Coming from Smalltalk where there are no native control structures at all, i.e. all control structures are built using closures, I&#39;m very used to creating control structure-like methods or mini DSLs. For these trailing closures are indispensable.<br>That is also very common in other languages like Ruby or Scala.<br></p><p>(Smalltalk was even better because it has no parenthesis around argument lists which allowed for multiple closure arguments looking as nice as trailing closures.)<br></p><p>-Thorsten <br></p><p>&gt; Am 24.03.2016 um 14:57 schrieb Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; When I started using Swift I was initially very enthusiastic about trailing closures, but I’ve actually kind of gone off them somewhat and I’d like to discuss why.<br>&gt; <br>&gt; Firstly, here are two ways to write a common example using the .map() method:<br>&gt; <br>&gt; 	let foo = myArray.map { $0 + 1 }<br>&gt; 	let foo = myArray.map({ $0 + 1 })<br>&gt; <br>&gt; It’s tough to say that the first form is any neater than the second, other than the second having more brackets. However, the first form is somewhat ambiguous, as .map in this case looks like a property rather than a method, it also visually looks like a statement, followed by a closure rather than the two things logically being related. Of course it’s quick to learn that these are related, but for consistency I’m starting to now prefer the use of parenthesis in almost all cases.<br>&gt; <br>&gt; The other advantage of trailing closures is the omission of the label, but trailing closures aren’t strictly necessary for this, as we can already omit external labels for parameters if we want to, and the example above shows that a trailing closure isn’t necessary for this. The only real difference is that the trailing closure form makes a label optional, because you can either provide the closure with label in parenthesis (if the label is required) or omit it by trailing, like so:<br>&gt; <br>&gt; 	something.someMethod(foo: 1, predicate: { $0 &lt; $1})<br>&gt; 	something.someMethod(foo: 1) { $0 &lt; $1}<br>&gt; <br>&gt; However this kind of arbitrarily makes the following impossible:<br>&gt; <br>&gt; 	something.someMethod(foo: 1, { $0 &lt; $1 })<br>&gt; <br>&gt; With this in mind it seems to me that we might be better served by the ability to make external labels optional, as this would allow us to be just as succinct, while being completely clear about what is being passed into this method.<br>&gt; <br>&gt; <br>&gt; The only real remaining advantage that I see to trailing closures is the ability to define pseudo language constructs, for example:<br>&gt; <br>&gt; 	func repeatUntilEmpty&lt;C:CollectionType&gt;(collection:C, @noescape _ body:() throws -&gt; Void) rethrows { while !collection.isEmpty { body() } }<br>&gt; 	repeatUntilEmpty(myArray) {<br>&gt; 		/* Do something over and over until myArray is empty */<br>&gt; 	}<br>&gt; <br>&gt; Which I think is a pretty uncommon type of structure, but could be useful in some specialised situations. To support this though we could easily use a new @trailing attribute instead to indicate that the closure can be used in this way. My example isn’t very good as I can’t think of a case that really, really needs this, but I think they’re probably out there.<br>&gt; <br>&gt; <br>&gt; To summarise, having come down off my initial enthusiasm for trailing closures I’m not sure that they really add that much syntactically, especially in the most common cases, while actually being a little ambiguous looking and adding inconsistency to the language. I think they should remain for the less common cases that can really benefit from them, but as a feature that is opted into, so that we can go for consistency by default.<br>&gt; <br>&gt; I’m interested to hear other people’s thoughts.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/60f40d17/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 25, 2016 at 08:00:00am</p></header><div class="content"><p>I use trailing closures all the time because I find the brackets too noisy,<br>like ; at the end of a line is too noisy. The sort of code I use is:<br></p><p>    let foo = myArray<br>        .filter { $0 &amp; 1 == 1 }<br>        .map { $0 + 1 }<br>        .reduce(0) { $0 + $1 }<br></p><p>On Friday, 25 March 2016, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; When I started using Swift I was initially very enthusiastic about<br>&gt; trailing closures, but I’ve actually kind of gone off them somewhat and I’d<br>&gt; like to discuss why.<br>&gt;<br>&gt; Firstly, here are two ways to write a common example using the .map()<br>&gt; method:<br>&gt;<br>&gt; let foo = myArray.map { $0 + 1 }<br>&gt; let foo = myArray.map({ $0 + 1 })<br>&gt;<br>&gt; It’s tough to say that the first form is any neater than the second, other<br>&gt; than the second having more brackets. However, the first form is somewhat<br>&gt; ambiguous, as .map in this case looks like a property rather than a method,<br>&gt; it also visually looks like a statement, followed by a closure rather than<br>&gt; the two things logically being related. Of course it’s quick to learn that<br>&gt; these are related, but for consistency I’m starting to now prefer the use<br>&gt; of parenthesis in almost all cases.<br>&gt;<br>&gt; The other advantage of trailing closures is the omission of the label, but<br>&gt; trailing closures aren’t strictly necessary for this, as we can already<br>&gt; omit external labels for parameters if we want to, and the example above<br>&gt; shows that a trailing closure isn’t necessary for this. The only real<br>&gt; difference is that the trailing closure form makes a label optional,<br>&gt; because you can either provide the closure with label in parenthesis (if<br>&gt; the label is required) or omit it by trailing, like so:<br>&gt;<br>&gt; something.someMethod(foo: 1, predicate: { $0 &lt; $1})<br>&gt; something.someMethod(foo: 1) { $0 &lt; $1}<br>&gt;<br>&gt; However this kind of arbitrarily makes the following impossible:<br>&gt;<br>&gt; something.someMethod(foo: 1, { $0 &lt; $1 })<br>&gt;<br>&gt; With this in mind it seems to me that we might be better served by the<br>&gt; ability to make external labels optional, as this would allow us to be just<br>&gt; as succinct, while being completely clear about what is being passed into<br>&gt; this method.<br>&gt;<br>&gt;<br>&gt; The only real remaining advantage that I see to trailing closures is the<br>&gt; ability to define pseudo language constructs, for example:<br>&gt;<br>&gt; func repeatUntilEmpty&lt;C:CollectionType&gt;(collection:C, @noescape _ body:()<br>&gt; throws -&gt; Void) rethrows { while !collection.isEmpty { body() } }<br>&gt; repeatUntilEmpty(myArray) {<br>&gt; /* Do something over and over until myArray is empty */<br>&gt; }<br>&gt;<br>&gt; Which I think is a pretty uncommon type of structure, but could be useful<br>&gt; in some specialised situations. To support this though we could easily use<br>&gt; a new @trailing attribute instead to indicate that the closure can be used<br>&gt; in this way. My example isn’t very good as I can’t think of a case that<br>&gt; really, really needs this, but I think they’re probably out there.<br>&gt;<br>&gt;<br>&gt; To summarise, having come down off my initial enthusiasm for trailing<br>&gt; closures I’m not sure that they really add that much syntactically,<br>&gt; especially in the most common cases, while actually being a little<br>&gt; ambiguous looking and adding inconsistency to the language. I think they<br>&gt; should remain for the less common cases that can really benefit from them,<br>&gt; but as a feature that is opted into, so that we can go for consistency by<br>&gt; default.<br>&gt;<br>&gt; I’m interested to hear other people’s thoughts.<br>&gt;<br></p><p><br>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160325/09b7bc26/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>March 25, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; I use trailing closures all the time because I find the brackets too noisy, like ; at the end of a line is too noisy. The sort of code I use is:<br>&gt; <br>&gt;     let foo = myArray<br>&gt;         .filter { $0 &amp; 1 == 1 }<br>&gt;         .map { $0 + 1 }<br>&gt;         .reduce(0) { $0 + $1 } <br></p><p>+1 to this. Please don&#39;t remove them, they&#39;re great.<br></p><p>A.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160325/ca3cf456/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March 31, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Am 24.03.2016 um 22:31 schrieb Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; I use trailing closures all the time because I find the brackets too noisy, like ; at the end of a line is too noisy. The sort of code I use is:<br>&gt;&gt; <br>&gt;&gt;     let foo = myArray<br>&gt;&gt;         .filter { $0 &amp; 1 == 1 }<br>&gt;&gt;         .map { $0 + 1 }<br>&gt;&gt;         .reduce(0) { $0 + $1 } <br>&gt; <br>&gt; +1 to this. Please don&#39;t remove them, they&#39;re great.<br></p><p>+1 from me as well.<br></p><p>-Thorsten <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/706abe99/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March 25, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 24 Mar 2016, at 21:08, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; I use trailing closures all the time because I find the brackets too noisy, like ; at the end of a line is too noisy. The sort of code I use is:<br>&gt; <br>&gt;     let foo = myArray<br>&gt;         .filter { $0 &amp; 1 == 1 }<br>&gt;         .map { $0 + 1 }<br>&gt;         .reduce(0) { $0 + $1 } <br></p><p>This doesn’t really seem much neater or more readable to me than:<br></p><p>	let foo = myArray<br>		.filter({ $0 &amp; 1 == 1 })<br>		.map({ $0 + 1 })<br>		.reduce(0, { $0 + $1 })<br></p><p>While they may add a small amount of noise, in the latter case the parenthesis clarifies that each is a method, and what all of its arguments are, and don’t use any custom syntax. Of course this assumes that .reduce() would have an optional label on its closure argument.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160325/611a0481/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3d3a2cce932eca144b8c13a63966404?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>Alex Blewitt</string> &lt;alex.blewitt at gmail.com&gt;<p>March 25, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 25 Mar 2016, at 08:10, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 24 Mar 2016, at 21:08, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I use trailing closures all the time because I find the brackets too noisy, like ; at the end of a line is too noisy. The sort of code I use is:<br>&gt;&gt; <br>&gt;&gt;     let foo = myArray<br>&gt;&gt;         .filter { $0 &amp; 1 == 1 }<br>&gt;&gt;         .map { $0 + 1 }<br>&gt;&gt;         .reduce(0) { $0 + $1 } <br>&gt; <br>&gt; This doesn’t really seem much neater or more readable to me than:<br>&gt; <br>&gt; 	let foo = myArray<br>&gt; 		.filter({ $0 &amp; 1 == 1 })<br>&gt; 		.map({ $0 + 1 })<br>&gt; 		.reduce(0, { $0 + $1 })<br>&gt; <br>&gt; While they may add a small amount of noise, in the latter case the parenthesis clarifies that each is a method, and what all of its arguments are, and don’t use any custom syntax. Of course this assumes that .reduce() would have an optional label on its closure argument.<br></p><p>On the other hand, I find the addition of the parenthesis makes it less readable than the one without. So please don&#39;t assume that what is equally readable for you applies to everyone else. <br></p><p>Alex<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160325/4e7eccd3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 25, 2016 at 05:00:00am</p></header><div class="content"><p>&gt;&gt;     let foo = myArray<br>&gt;&gt;         .filter { $0 &amp; 1 == 1 }<br>&gt;&gt;         .map { $0 + 1 }<br>&gt;&gt;         .reduce(0) { $0 + $1 } <br>&gt; <br>&gt; This doesn’t really seem much neater or more readable to me than:<br>&gt; <br>&gt; 	let foo = myArray<br>&gt; 		.filter({ $0 &amp; 1 == 1 })<br>&gt; 		.map({ $0 + 1 })<br>&gt; 		.reduce(0, { $0 + $1 })<br></p><p>I, on the other hand, cannot imagine how you would not see a difference between the two. The paren-less form is *far* more readable to me; when you put a parenthesis and a curly bracket next to each other, the curly bracket disappears and I can no longer see that the expression is a closure.<br></p><p>Swift generally doesn&#39;t mandate any particular style. I think this is a good time to continue that tradition.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>March 25, 2016 at 07:00:00am</p></header><div class="content"><p>Agreed.<br></p><p>Sent from my iPhone<br></p><p>On Mar 25, 2016, at 07:44, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt;&gt;    let foo = myArray<br>&gt;&gt;&gt;        .filter { $0 &amp; 1 == 1 }<br>&gt;&gt;&gt;        .map { $0 + 1 }<br>&gt;&gt;&gt;        .reduce(0) { $0 + $1 }<br>&gt;&gt; <br>&gt;&gt; This doesn’t really seem much neater or more readable to me than:<br>&gt;&gt; <br>&gt;&gt;    let foo = myArray<br>&gt;&gt;        .filter({ $0 &amp; 1 == 1 })<br>&gt;&gt;        .map({ $0 + 1 })<br>&gt;&gt;        .reduce(0, { $0 + $1 })<br>&gt; <br>&gt; I, on the other hand, cannot imagine how you would not see a difference between the two. The paren-less form is *far* more readable to me; when you put a parenthesis and a curly bracket next to each other, the curly bracket disappears and I can no longer see that the expression is a closure.<br>&gt; <br>&gt; Swift generally doesn&#39;t mandate any particular style. I think this is a good time to continue that tradition.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March 31, 2016 at 03:00:00pm</p></header><div class="content"><p>Am 25.03.2016 um 13:44 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p>&gt;&gt;&gt;    let foo = myArray<br>&gt;&gt;&gt;        .filter { $0 &amp; 1 == 1 }<br>&gt;&gt;&gt;        .map { $0 + 1 }<br>&gt;&gt;&gt;        .reduce(0) { $0 + $1 }<br>&gt;&gt; <br>&gt;&gt; This doesn’t really seem much neater or more readable to me than:<br>&gt;&gt; <br>&gt;&gt;    let foo = myArray<br>&gt;&gt;        .filter({ $0 &amp; 1 == 1 })<br>&gt;&gt;        .map({ $0 + 1 })<br>&gt;&gt;        .reduce(0, { $0 + $1 })<br>&gt; <br>&gt; I, on the other hand, cannot imagine how you would not see a difference between the two. The paren-less form is *far* more readable to me; when you put a parenthesis and a curly bracket next to each other, the curly bracket disappears and I can no longer see that the expression is a closure.<br></p><p>Same for me!<br> <br></p><p>&gt; Swift generally doesn&#39;t mandate any particular style. I think this is a good time to continue that tradition.<br></p><p>Indeed.<br></p><p>-Thorsten<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>March 31, 2016 at 02:00:00pm</p></header><div class="content"><p>I have to admit I’m quite fond of the trailing closure syntax. This is partly because of my earlier experiences with Ruby. But partly I just really found it more readable to see a separation between a regular function call, with just normal parameters passed in, and higher order functions, like the `map` example you’ve made. Having two sets of parentheses/braces like foo({ … }) really makes them blend in and I don’t notice the curly braces as much. Having a stylistic separation between:<br></p><p>	foo(argument)<br>	foo { code }<br></p><p>helps me catch the difference between the two.<br></p><p>But it is a stylistic choice. Like I mentioned in a different reply, if we’re going to have trailing closures at all, I don’t see a point in enforcing this other than with a linter.<br></p><p>* * *<br></p><p>The only way I see this working is if the trailing closure syntax has *other* semantics as well. For example, there’s been a discussion about allowing specially marked closures to return/break/continue in the scope of the caller function, not the closure’s scope (like Ruby’s blocks do). Now, that would make a bit more sense. You’d have a special attribute (can’t think of a name, but let’s stick with your @trailing), that would imply:<br></p><p>- required trailing closure syntax<br>- @noescape, I think<br>- and return/break/continue affects outside functions<br></p><p>And you could use that to make your own pseudo-language-constructs. This would enforce trailing closure syntax, and nothing else could use trailing closure syntax.<br></p><p>Now, I wouldn’t be super happy about not being able to write `map { foo }` myself 😁 — but _that_ proposal would make sense to me. It wouldn’t just be enforcement of a stylistic choice, but the syntax would actually convey some important semantics.<br></p><p>What do you think?<br></p><p>— Radek<br></p><p>&gt; On 24 Mar 2016, at 14:57, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; When I started using Swift I was initially very enthusiastic about trailing closures, but I’ve actually kind of gone off them somewhat and I’d like to discuss why.<br>&gt; <br>&gt; Firstly, here are two ways to write a common example using the .map() method:<br>&gt; <br>&gt; 	let foo = myArray.map { $0 + 1 }<br>&gt; 	let foo = myArray.map({ $0 + 1 })<br>&gt; <br>&gt; It’s tough to say that the first form is any neater than the second, other than the second having more brackets. However, the first form is somewhat ambiguous, as .map in this case looks like a property rather than a method, it also visually looks like a statement, followed by a closure rather than the two things logically being related. Of course it’s quick to learn that these are related, but for consistency I’m starting to now prefer the use of parenthesis in almost all cases.<br>&gt; <br>&gt; The other advantage of trailing closures is the omission of the label, but trailing closures aren’t strictly necessary for this, as we can already omit external labels for parameters if we want to, and the example above shows that a trailing closure isn’t necessary for this. The only real difference is that the trailing closure form makes a label optional, because you can either provide the closure with label in parenthesis (if the label is required) or omit it by trailing, like so:<br>&gt; <br>&gt; 	something.someMethod(foo: 1, predicate: { $0 &lt; $1})<br>&gt; 	something.someMethod(foo: 1) { $0 &lt; $1}<br>&gt; <br>&gt; However this kind of arbitrarily makes the following impossible:<br>&gt; <br>&gt; 	something.someMethod(foo: 1, { $0 &lt; $1 })<br>&gt; <br>&gt; With this in mind it seems to me that we might be better served by the ability to make external labels optional, as this would allow us to be just as succinct, while being completely clear about what is being passed into this method.<br>&gt; <br>&gt; <br>&gt; The only real remaining advantage that I see to trailing closures is the ability to define pseudo language constructs, for example:<br>&gt; <br>&gt; 	func repeatUntilEmpty&lt;C:CollectionType&gt;(collection:C, @noescape _ body:() throws -&gt; Void) rethrows { while !collection.isEmpty { body() } }<br>&gt; 	repeatUntilEmpty(myArray) {<br>&gt; 		/* Do something over and over until myArray is empty */<br>&gt; 	}<br>&gt; <br>&gt; Which I think is a pretty uncommon type of structure, but could be useful in some specialised situations. To support this though we could easily use a new @trailing attribute instead to indicate that the closure can be used in this way. My example isn’t very good as I can’t think of a case that really, really needs this, but I think they’re probably out there.<br>&gt; <br>&gt; <br>&gt; To summarise, having come down off my initial enthusiasm for trailing closures I’m not sure that they really add that much syntactically, especially in the most common cases, while actually being a little ambiguous looking and adding inconsistency to the language. I think they should remain for the less common cases that can really benefit from them, but as a feature that is opted into, so that we can go for consistency by default.<br>&gt; <br>&gt; I’m interested to hear other people’s thoughts.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/0f034538/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 31, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; The only way I see this working is if the trailing closure syntax has *other* semantics as well. For example, there’s been a discussion about allowing specially marked closures to return/break/continue in the scope of the caller function, not the closure’s scope (like Ruby’s blocks do). Now, that would make a bit more sense. You’d have a special attribute (can’t think of a name, but let’s stick with your @trailing), that would imply:<br>&gt; <br>&gt; - required trailing closure syntax<br>&gt; - @noescape, I think<br>&gt; - and return/break/continue affects outside functions<br>&gt; <br>&gt; And you could use that to make your own pseudo-language-constructs. This would enforce trailing closure syntax, and nothing else could use trailing closure syntax.<br>&gt; …<br>&gt; What do you think?<br></p><p>First of all, you&#39;re right that a block that could return/break/continue/etc. would need to be @noescape. Otherwise, what would those keywords do if the function had already returned?<br></p><p>I think requring trailing closures to be @noescape would take away some very compelling use cases for them. In particular, you would lose the ability to use trailing closures for asynchronous code, like completion functions. I, for one, would be sad to lose those—they are often some of the largest, most block-like pieces of code that you put into a closure.<br></p><p>At the same time, many of the things which people seem to think shouldn&#39;t be trailing closures, like `map` blocks, seem like good candidates for early returns or other control flow.<br></p><p>Basically, if you imagine a Venn diagram of &quot;closures it would be useful to break out of early&quot; and &quot;closures you might want to use trailing closure syntax with&quot;, I don&#39;t think there&#39;s a particularly large amount of overlap between the two circles.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>Deprecating Trailing Closures</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>March 31, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; I think requring trailing closures to be @noescape would take away some very compelling use cases for them. In particular, you would lose the ability to use trailing closures for asynchronous code, like completion functions. I, for one, would be sad to lose those—they are often some of the largest, most block-like pieces of code that you put into a closure.<br></p><p>I, too, would be sad about that — but aside from a syntactic/stylistic choice, there aren’t any important-to-the-compiler semantics conveyed by the trailing closure, are there?<br></p><p>&gt; <br>&gt; At the same time, many of the things which people seem to think shouldn&#39;t be trailing closures, like `map` blocks, seem like good candidates for early returns or other control flow.<br></p><p>I *don’t* think `map` blocks should be able to control the outside scope. Map should map, that is transform. `forEach` should probably be able to do outside function control flow, and the use of trailing closure would be consistent with the Rule of Kevin.<br></p><p>&gt; Basically, if you imagine a Venn diagram of &quot;closures it would be useful to break out of early&quot; and &quot;closures you might want to use trailing closure syntax with&quot;, I don&#39;t think there&#39;s a particularly large amount of overlap between the two circles.<br></p><p>Aside from `map`, do you have other examples where there is no overlap?<br></p><p>— Radek<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
