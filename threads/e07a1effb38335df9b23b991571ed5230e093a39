<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e841a2a33b72c728c55ff99200275784?s=50"></div><header><strong>Suppress unused result warnings on try? if attempted statement does not return</strong> from <string>James Froggatt</string> &lt;james.froggatt at me.com&gt;<p>June 18, 2016 at 02:00:00am</p></header><div class="content"><p>More generally, this is the issue of whether the automatic discardability of Void should be extended to Optional&lt;Void&gt;. This could also apply to the result of optional chaining.<br></p><p>EG:<br>observer?.update() //returns ()?<br></p><p>compared to:<br>if let unwrapped = observer {<br>    unwrapped.update() //returns ()<br>}<br></p><p>Since ()? (or Void?) is almost certainly a side-effect of optional chaining of some form, I&#39;d be in favour of this extension to the rule.<br></p><p><br></p><p>As an interesting side note, the counter-point to this change I can think of is one of symmetry, potentially relevant in some high-level generic code. Failable functions often follow the pattern of returning an Optional, which is nil on failure. Extending this rule to, for example, an in-place load() function, one may consider returning ()? to indicate whether the function was successful. This would be deliberate use of Optional&lt;()&gt;, and so it would make sense not to make this particular result discardable, which would be impossible with this change.<br></p><p>The precedent of languages without optionals and a real Void/Unit type has been established, which is to return a Bool value to indicate success, and if this weren&#39;t such a fundamental expectation, it&#39;s arguable ()? may actually be clearer in these cases: load() -&gt; Bool could be read as a function which loads a Bool value, whereas load() -&gt; ()? is unambiguous.<br></p><p>While this is unlikely to become an established convention, I love that Swift is able to make such ideas possible. :)<br>Just the simple things which do away with implementation-driven corner cases in favour of a reliable, clear set of rules, really make the language more powerful.<br></p><p>------------ Begin Message ------------ <br>Group: gmane.comp.lang.swift.evolution <br>MsgID: &lt;B04DCF76-0AA6-4E80-9930-04E1B710E9A0 at icloud.com&gt; <br></p><p>I propose that the compiler warnings for unused results are removed from try? if the statement being ‘tried’ does not return itself. This is inline with how try works and although try? does have a possible return value itself (nil) the warning isn’t adding/helping any if the result is either going to be nil or void.<br></p><p>When try? is used in this way, it is essentially the caller saying they don’t care if the operation fails and any consequences of that failure will be handled later on.<br></p><p>I have a slightly contrived example here on gist of where this could be useful https://gist.github.com/joncottonskyuk/abc6caad8be137193d4e1e58cc8d2e06<br></p><p>basically, in the person model, I don’t always care if the emailAddress is set, but in some cases I do, to differentiate between the two use cases, the caller can choose to use either try when they do care and want to handle the specific error, or try? if they don’t care about the failure and just want to carry on with the usual execution path.<br></p><p>The alternative is to just leave this as it is and the caller must then use _ = try? … to suppress the warnings. However, whilst _ = is very useful for suppressing this warning in most cases, as it shows intent for future maintainers of the code, in this case I don’t think it really adds any value. If the statement being attempted does not return itself then you are left with no choice but to assign to nothing to suppress the warning as opposed to assigning to some local reference and then just throwing that away.<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>------------- End Message ------------- <br></p><p><br></p><p>From James F<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9ae1f2ed10d2ef77cce06bbb5a2dcf7e?s=50"></div><header><strong>Suppress unused result warnings on try? if attempted statement does not return</strong> from <string>Alex Hoppen</string> &lt;alex at ateamer.de&gt;<p>June 18, 2016 at 08:00:00am</p></header><div class="content"><p>I discussed the same issue in a WWDC lab with Doug yesterday and we came to the conclusion that warnings about unused return values of type Optional&lt;Void&gt; were a bug. The basic line of argumentation was that if you have<br></p><p>class Foo {<br>  func bar() {}<br>}<br></p><p>then<br></p><p>foo?.bar() returns Optional&lt;Void&gt; but does not warn about an unused result, which is totally expected behaviour.<br></p><p>It feels inconsistent that this behaviour differs if the return value of Optional&lt;Void&gt; is used in a more complicated expression, e.g.<br></p><p>true ? foo?.bar() : foo?.bar()<br></p><p>Hence we decided that Optional&lt;Void&gt; simply shouldn&#39;t generate any warnings about unused results. Note that this does not prevent the user of such an API to still check the result, if he wants to do so.<br></p><p>Implementation of this change is pending in this PR: https://github.com/apple/swift/pull/3057 &lt;https://github.com/apple/swift/pull/3057&gt;.<br></p><p>– Alex<br></p><p><br>&gt; On 17 Jun 2016, at 18:26, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; More generally, this is the issue of whether the automatic discardability of Void should be extended to Optional&lt;Void&gt;. This could also apply to the result of optional chaining.<br>&gt; <br>&gt; EG:<br>&gt; observer?.update() //returns ()?<br>&gt; <br>&gt; compared to:<br>&gt; if let unwrapped = observer {<br>&gt;    unwrapped.update() //returns ()<br>&gt; }<br>&gt; <br>&gt; Since ()? (or Void?) is almost certainly a side-effect of optional chaining of some form, I&#39;d be in favour of this extension to the rule.<br>&gt; <br>&gt; <br>&gt; <br>&gt; As an interesting side note, the counter-point to this change I can think of is one of symmetry, potentially relevant in some high-level generic code. Failable functions often follow the pattern of returning an Optional, which is nil on failure. Extending this rule to, for example, an in-place load() function, one may consider returning ()? to indicate whether the function was successful. This would be deliberate use of Optional&lt;()&gt;, and so it would make sense not to make this particular result discardable, which would be impossible with this change.<br>&gt; <br>&gt; The precedent of languages without optionals and a real Void/Unit type has been established, which is to return a Bool value to indicate success, and if this weren&#39;t such a fundamental expectation, it&#39;s arguable ()? may actually be clearer in these cases: load() -&gt; Bool could be read as a function which loads a Bool value, whereas load() -&gt; ()? is unambiguous.<br>&gt; <br>&gt; While this is unlikely to become an established convention, I love that Swift is able to make such ideas possible. :)<br>&gt; Just the simple things which do away with implementation-driven corner cases in favour of a reliable, clear set of rules, really make the language more powerful.<br>&gt; <br>&gt; ------------ Begin Message ------------ <br>&gt; Group: gmane.comp.lang.swift.evolution <br>&gt; MsgID: &lt;B04DCF76-0AA6-4E80-9930-04E1B710E9A0 at icloud.com&gt; <br>&gt; <br>&gt; I propose that the compiler warnings for unused results are removed from try? if the statement being ‘tried’ does not return itself. This is inline with how try works and although try? does have a possible return value itself (nil) the warning isn’t adding/helping any if the result is either going to be nil or void.<br>&gt; <br>&gt; When try? is used in this way, it is essentially the caller saying they don’t care if the operation fails and any consequences of that failure will be handled later on.<br>&gt; <br>&gt; I have a slightly contrived example here on gist of where this could be useful https://gist.github.com/joncottonskyuk/abc6caad8be137193d4e1e58cc8d2e06<br>&gt; <br>&gt; basically, in the person model, I don’t always care if the emailAddress is set, but in some cases I do, to differentiate between the two use cases, the caller can choose to use either try when they do care and want to handle the specific error, or try? if they don’t care about the failure and just want to carry on with the usual execution path.<br>&gt; <br>&gt; The alternative is to just leave this as it is and the caller must then use _ = try? … to suppress the warnings. However, whilst _ = is very useful for suppressing this warning in most cases, as it shows intent for future maintainers of the code, in this case I don’t think it really adds any value. If the statement being attempted does not return itself then you are left with no choice but to assign to nothing to suppress the warning as opposed to assigning to some local reference and then just throwing that away.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; ------------- End Message ------------- <br>&gt; <br>&gt; <br>&gt; <br>&gt; From James F<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160618/cbbb622e/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
