<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9a0d717cf09146b2efca53351ab9b094?s=50"></div><header><strong>Three questions about a more &quot;dynamic&quot; Swift for InfoQ</strong> from <string>sergio</string> &lt;zergyo at gmail.com&gt;<p>September 26, 2016 at 10:00:00pm</p></header><div class="content"><p>HI all,<br></p><p>a debate has recently taken place within the Objective-C/Swift dev community concerning the lack in Swift of something “equivalent” to Objective-C runtime programming. When using Swift exclusively, there seems to be no easy equivalent for Cocoa fundamental design patterns such as the Responder Chain, NSUndoManager, KVC/KVO/Bindings — and in general for code that leverages Objective-C&#39;s dynamic features (i.e., runtime programming). <br></p><p>According to some developers, dynamic features in Ocjective-C grant easy coding and high decoupling and there are concerns that Swift might make harder a number of common Objective-C tasks (e.g., by increasing boilerplate code, lowering readability, making high use of switch, etc.) and eventually increase development time.<br></p><p>In this context, is interesting to know how those concerns are viewed within the Swift dev community and how they could be tackled. Thus, I would like to ask three questions that will be the base for an InfoQ article on the topic:<br></p><p><br>1.     Do you envision a more dynamic Swift? Should some level of dynamism be added at the language or framework level (e.g., to make dynamic dispatch or some form of message passing possible, while ruling out trickier features such as method swizzling and others) possible ? Should Swift be dynamic at all?<br></p><p>2.     What is the challenge of making a more dynamic Swift (or adding features to it to help solve the same kind of issues that are solved in ObjC through dynamism)? How could that be achieved without making Swift a less safe language? [e.g., reflection, macros, etc.]<br></p><p>3.     Are you aware of any work that has been/is being done in Swift development (Swift 3/Swift 4) to make Swift more capable of addressing the above mentioned concerns?<br></p><p><br>Thanks a lot in advance!<br>Sergio<br></p><p>—<br></p><p>Sergio De Simone<br>https://www.infoq.com/author/Sergio-De-Simone<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160926/80127b17/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Three questions about a more &quot;dynamic&quot; Swift for InfoQ</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>September 26, 2016 at 05:00:00pm</p></header><div class="content"><p>~Robert Widmann<br></p><p>2016/09/26 16:29、sergio via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; HI all,<br>&gt; <br>&gt; a debate has recently taken place within the Objective-C/Swift dev community concerning the lack in Swift of something “equivalent” to Objective-C runtime programming. When using Swift exclusively, there seems to be no easy equivalent for Cocoa fundamental design patterns such as the Responder Chain, NSUndoManager, KVC/KVO/Bindings ― and in general for code that leverages Objective-C&#39;s dynamic features (i.e., runtime programming). <br>&gt; <br>&gt; According to some developers, dynamic features in Ocjective-C grant easy coding and high decoupling and there are concerns that Swift might make harder a number of common Objective-C tasks (e.g., by increasing boilerplate code, lowering readability, making high use of switch, etc.) and eventually increase development time.<br>&gt; <br>&gt; In this context, is interesting to know how those concerns are viewed within the Swift dev community and how they could be tackled. Thus, I would like to ask three questions that will be the base for an InfoQ article on the topic:<br>&gt; <br>&gt; <br>&gt; 1.     Do you envision a more dynamic Swift? Should some level of dynamism be added at the language or framework level (e.g., to make dynamic dispatch or some form of message passing possible, while ruling out trickier features such as method swizzling and others) possible ? Should Swift be dynamic at all?<br></p><p>No, and I think moving towards a more dynamic Swift now without as-of-yet-seen significant justification would be a mistake.  Swift should be as static as possible.  We should be making every attempt to pare down the existing runtime and quietly transition those that rely on dynamism to checked reflection (yes, that is not in fact an oxymoron).  The more the compiler knows about your program, the better it does.  Period.<br></p><p>&gt; <br>&gt; 2.     What is the challenge of making a more dynamic Swift (or adding features to it to help solve the same kind of issues that are solved in ObjC through dynamism)? How could that be achieved without making Swift a less safe language? [e.g., reflection, macros, etc.]<br></p><p>There are very few dynamic patterns that aren&#39;t subsumed by the current model.  That said, two big ones I know of are Realm&#39;s approach of using &quot;runtime-metaprogramming&quot; to derive models and combining static typing with Clojure-style coercible data structures that share a common core.   The first can be subsumed by better reflection primitives, the second is more difficult.  Static Swift means room for potential optimizations that could destroy the integrity of any system that thinks it knows enough to coerce terms around itself (this kind of programming is powerful precisely because of this knowledge).  Perhaps that&#39;s not a bad thing.  If you know your types ahead of time - which you do if you&#39;re trying to perform coercions - you should be able to write down something to convince the type checker.  If you can&#39;t, it&#39;s an expressiveness problem we should deal with at the level of the type system.<br></p><p>&gt; <br>&gt; Thanks a lot in advance!<br>&gt; Sergio<br>&gt; <br>&gt; ―<br>&gt; <br>&gt; Sergio De Simone<br>&gt; https://www.infoq.com/author/Sergio-De-Simone<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160926/c7ed6fb2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d5db2751088467d55d9bf0a187346ec5?s=50"></div><header><strong>Three questions about a more &quot;dynamic&quot; Swift for InfoQ</strong> from <string>Johannes Neubauer</string> &lt;johannes.neubauer at udo.edu&gt;<p>September 26, 2016 at 11:00:00pm</p></header><div class="content"><p>Von meinem iPhone gesendet<br></p><p>&gt; Am 26.09.2016 um 23:32 schrieb Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/09/26 16:29、sergio via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt; <br>&gt;&gt; HI all,<br>&gt;&gt; <br>&gt;&gt; a debate has recently taken place within the Objective-C/Swift dev community concerning the lack in Swift of something “equivalent” to Objective-C runtime programming. When using Swift exclusively, there seems to be no easy equivalent for Cocoa fundamental design patterns such as the Responder Chain, NSUndoManager, KVC/KVO/Bindings — and in general for code that leverages Objective-C&#39;s dynamic features (i.e., runtime programming). <br>&gt;&gt; <br>&gt;&gt; According to some developers, dynamic features in Ocjective-C grant easy coding and high decoupling and there are concerns that Swift might make harder a number of common Objective-C tasks (e.g., by increasing boilerplate code, lowering readability, making high use of switch, etc.) and eventually increase development time.<br>&gt;&gt; <br>&gt;&gt; In this context, is interesting to know how those concerns are viewed within the Swift dev community and how they could be tackled. Thus, I would like to ask three questions that will be the base for an InfoQ article on the topic:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 1.     Do you envision a more dynamic Swift? Should some level of dynamism be added at the language or framework level (e.g., to make dynamic dispatch or some form of message passing possible, while ruling out trickier features such as method swizzling and others) possible ? Should Swift be dynamic at all?<br>&gt; <br>&gt; No, and I think moving towards a more dynamic Swift now without as-of-yet-seen significant justification would be a mistake.  Swift should be as static as possible.  We should be making every attempt to pare down the existing runtime and quietly transition those that rely on dynamism to checked reflection (yes, that is not in fact an oxymoron).  The more the compiler knows about your program, the better it does.  Period.<br></p><p>I do not agree (fully). Although static type checking is great, object orientation is too. Dynamic dispatch and therefore (subtype) polymorphism is a wonderful thing. Going down the road to make every call static is an extreme that won&#39;t help anybody. As always the right balance makes the deal.<br></p><p>All the best<br>Johannes<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; 2.     What is the challenge of making a more dynamic Swift (or adding features to it to help solve the same kind of issues that are solved in ObjC through dynamism)? How could that be achieved without making Swift a less safe language? [e.g., reflection, macros, etc.]<br>&gt; <br>&gt; There are very few dynamic patterns that aren&#39;t subsumed by the current model.  That said, two big ones I know of are Realm&#39;s approach of using &quot;runtime-metaprogramming&quot; to derive models and combining static typing with Clojure-style coercible data structures that share a common core.   The first can be subsumed by better reflection primitives, the second is more difficult.  Static Swift means room for potential optimizations that could destroy the integrity of any system that thinks it knows enough to coerce terms around itself (this kind of programming is powerful precisely because of this knowledge).  Perhaps that&#39;s not a bad thing.  If you know your types ahead of time - which you do if you&#39;re trying to perform coercions - you should be able to write down something to convince the type checker.  If you can&#39;t, it&#39;s an expressiveness problem we should deal with at the level of the type system.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Thanks a lot in advance!<br>&gt;&gt; Sergio<br>&gt;&gt; <br>&gt;&gt; —<br>&gt;&gt; <br>&gt;&gt; Sergio De Simone<br>&gt;&gt; https://www.infoq.com/author/Sergio-De-Simone<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160926/d7a8d619/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>Three questions about a more &quot;dynamic&quot; Swift for InfoQ</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>September 27, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Sep 26, 2016, at 5:32 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; No, and I think moving towards a more dynamic Swift now without as-of-yet-seen significant justification would be a mistake.  Swift should be as static as possible.  We should be making every attempt to pare down the existing runtime and quietly transition those that rely on dynamism to checked reflection (yes, that is not in fact an oxymoron).  The more the compiler knows about your program, the better it does.  Period.<br>&gt; <br>How would you implement something like Core Data in pure Swift on the server where the Obj-C runtime is not available?<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160927/c40dea11/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Three questions about a more &quot;dynamic&quot; Swift for InfoQ</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>September 27, 2016 at 12:00:00pm</p></header><div class="content"><p>Statically typed persistent storage solutions are far and away superior to Core Data.  Whether you’re looking for queries that are correct-by-construction with DSLs or looking for easy model construction and composability, or even just modularity and ease of use.  The ability to have the type system check your work is not antithetical to the idea of marshaling data - if anything it’s far more effective.  <br></p><p>- Begin with a protocol for serializable things to teach the framework about your schema:<br></p><p>///     decode • encode == id<br>public protocol Serializable {<br>	/// Encode a value.<br>	var serialize : Put&lt;Format&gt; { get }<br>	/// Decode a value.<br>	static var deserialize : Get&lt;Self&gt; { get }<br>}<br></p><p>- Provide combinators and functions attached to `Get` and `Put` to make [de]serializing aggregates easy.  <br></p><p>struct Person : Equatable {<br>	let age : UInt32<br>	let weight : UInt32<br>}<br></p><p>extension Person : Serializable {<br>	static var deserialize : Get&lt;Person&gt; {<br>		return Get.zip(<br>			UInt32.deserialize,<br>		).map(Person.init)<br>	}<br></p><p>	var serialize : Put&lt;Person&gt; {<br>		return self.age.serialize<br>			.then(self.weight.serialize)<br>	}<br>}<br></p><p>- Select a backend<br></p><p>public struct SqlBackend : Backend {<br>		func prepare(statement : String) -&gt; Statement { }<br>	func insert&lt;Entity : Serializable&gt;(_ entity : Entity) -&gt; Result { }<br>	// etc.<br>}<br></p><p>- Maybe put a little DSL on top if you’re feeling cheeky<br></p><p>let p : SQLQuery&lt;[Person]&gt; =<br>	select &lt;|<br>	from { p in<br>		(where_ &lt;|  exists &lt;|<br>			from { (p : Person) -&gt; SQLQuery&lt;()&gt; in<br>				where_(val(p.age) &lt;= val(18))<br>			}).then(SQLQuery&lt;Person&gt;.pure(p))<br>}<br></p><p>- Serve immediately<br></p><p>&gt; On Sep 27, 2016, at 12:29 PM, Ricardo Parada &lt;rparada at mac.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 26, 2016, at 5:32 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; No, and I think moving towards a more dynamic Swift now without as-of-yet-seen significant justification would be a mistake.  Swift should be as static as possible.  We should be making every attempt to pare down the existing runtime and quietly transition those that rely on dynamism to checked reflection (yes, that is not in fact an oxymoron).  The more the compiler knows about your program, the better it does.  Period.<br>&gt;&gt; <br>&gt; How would you implement something like Core Data in pure Swift on the server where the Obj-C runtime is not available?<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160927/af9af120/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Three questions about a more &quot;dynamic&quot; Swift for InfoQ</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>September 27, 2016 at 12:00:00pm</p></header><div class="content"><p>* Up to errors in my pseudo-code, of course.<br></p><p>	static func deserialize : Get&lt;Person&gt; {<br>		return Get.zip(<br>			UInt32.deserialize,<br>			UInt32.deserialize<br>		).map(Person.init)<br>	}<br></p><p>&gt; On Sep 27, 2016, at 12:44 PM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; UInt32.deserialize,<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160927/a11180c7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4c198ffcf0853e6011f58fdcdd32a111?s=50"></div><header><strong>Three questions about a more &quot;dynamic&quot; Swift for InfoQ</strong> from <string>Benjamin Spratling</string> &lt;bspratling at mac.com&gt;<p>September 26, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Sep 26, 2016, at 3:29 PM, sergio via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; HI all,<br>&gt; <br>&gt; a debate has recently taken place within the Objective-C/Swift dev community concerning the lack in Swift of something “equivalent” to Objective-C runtime programming. When using Swift exclusively, there seems to be no easy equivalent for Cocoa fundamental design patterns such as the Responder Chain, NSUndoManager, KVC/KVO/Bindings — and in general for code that leverages Objective-C&#39;s dynamic features (i.e., runtime programming). <br></p><p>NSUndoManager<br>Generic, block-based undo would be much better in Swift than the old NSUndoManager.  Certainly, “invocation-based” undo is just plain gone in Swift, and not necessary in Obj-C.  I’m toying with a from-scratch new undo manager that dynamically persists a cache of large amounts of data that are filling up RAM.  If you’re interested, maybe I’ll post it on git hub.<br></p><p>Responder Chain<br>The easy way around Swift’s lack of a “respondsTo&quot; is for a controller to provide a reference to the “next” controller in the chain.  Each controller class optionally conforms to a protocol, and the protocol would have the method the control wants to call.  I have used this extensively, and it works pretty well.  I’ve also discovered that a more “iOS” way of building UIs reduces the levels of disconnection between the Control and the Controller that was present in OS X, eliminating the problem in most cases.<br></p><p>KVO was my favorite way to do things in Obj-C; I even wrote some helper classes to prevent the pesky “you didn’t clean up your observers before dealloc” thing.  (I’m using ARC, quit bothering me with that already!)  Unfortunately, Swift’s init/deinit order made those classes impossible (as far as I can tell), so I ditched all KVO.  In the last year, developing 5 apps in pure Swift, I haven’t needed KVO, but I haven’t been working closely with AV modules, which used KVO as its preferred pattern, so I’m not sure how cumbersome the became.  For the one thing I did use AV- for, there was a closure-based API, and there wasn’t an issue.  So I’m preferring closures.  It would be nice (sigh) to use a more declarative approach.  I’ve recently noticed “ReativeSwift”, but haven’t had time to evaluate if it saves me work.<br></p><p>The one thing I wish I did have in the KVO genre is a callback when a weak var went to nil.  For example, reactively removing items from the UndoManager stack when the controller it references is deinit’d.  The iOS way for doing this is for the controller to own the undo manager <br></p><p>KVC is inherently unsafe in Obj-C, and Swift is all about the safety.  Really all that’s happened, as best I can tell, is I have to write explicit adapters to create objects.  Making a protocol that implements a init?(json:JSON) method, and storing a reference to the protocol and calling it as needed isn’t that bad.  So my need for KVC has disappeared.  I get that bindings were a little different, but I never got that in to bindings in the first place.  It seemed like a whole lot of guesswork and non-safe “stringly-typed” code.  I much prefer knowing at the call site what my types need to be.  (CoreImage drives me nuts).<br></p><p>So I think in general, I need to see with more compelling use case than the ones listed for warrant the kind of dynamic features you’re talking about.  Part of the benefit of Swift to me is the safety.  Taking the time to write my code in a safer way is a large part of the task of making it safe in the first place, but now, the compiler can catch accidental mistakes.<br></p><p>If anything,  I’d like to be able to dependency-inject data when a controller is unarchived from a .nib, for instance.<br></p><p>-Ben Spratling<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Three questions about a more &quot;dynamic&quot; Swift for InfoQ</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>September 27, 2016 at 09:00:00pm</p></header><div class="content"><p>On Sep 26, 2016, at 1:29 PM, sergio via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; HI all,<br>&gt; <br>&gt; a debate has recently taken place within the Objective-C/Swift dev community concerning the lack in Swift of something “equivalent” to Objective-C runtime programming. When using Swift exclusively, there seems to be no easy equivalent for Cocoa fundamental design patterns such as the Responder Chain, NSUndoManager, KVC/KVO/Bindings — and in general for code that leverages Objective-C&#39;s dynamic features (i.e., runtime programming). <br></p><p>Yep, many of us saw it.  Thank you for asking on swift-evolution, which is the proper place to discuss the future of Swift.<br></p><p>&gt; According to some developers, dynamic features in Ocjective-C grant easy coding and high decoupling and there are concerns that Swift might make harder a number of common Objective-C tasks (e.g., by increasing boilerplate code, lowering readability, making high use of switch, etc.) and eventually increase development time.<br>&gt; <br>&gt; In this context, is interesting to know how those concerns are viewed within the Swift dev community and how they could be tackled. <br></p><p>This is just my personal opinion, not meant to represent that of the entire core team:<br></p><p>&gt; 1.     Do you envision a more dynamic Swift? Should some level of dynamism be added at the language or framework level (e.g., to make dynamic dispatch or some form of message passing possible, while ruling out trickier features such as method swizzling and others) possible ? Should Swift be dynamic at all?<br></p><p>Yes, I personally think that adding “dynamic” features to Swift is absolutely essential.  That said, one of the things I’ve observed in the “blogger debate” that happened a few months ago is that everyone has different ideas of what “dynamic” means.  I don’t think that it is interesting to provide the “equivalent” features to Objective-C, but I do think it is important that Swift be able to solve the same sorts of problems (including your list of Responder Chain, NSUndoManager, KVC/KVO/Bindings, …) in an fluent/expressive way, even if it works differently.<br></p><p>In fact, one piece of this was the first candidate listed in the Swift 4 stage 2 goals, adding a reflection API:<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160725/025676.html<br>This included the statement: &quot;The core team is committed to adding powerful dynamic features to Swift.&quot;<br></p><p><br>The primary reason that Swift currently lacks these features is simple prioritization.  It has unfortunately not been the highest priority to build, because we already have working systems for all of those in Cocoa, and things like source stability and binary stability (among other things) are more important to the Swift community in the moment.  As Swift evolves, they will bubble up in the priority list. <br></p><p>I know that having a read/write data reflection API is the top of the list for many people, and having the ability to reflect on methods is also important for some patterns.  I look forward to the community having the bandwidth to properly design and debate these things, because I’m confident that there are good answers for these. <br></p><p>That said, to be clear, this is definitely out of scope for Swift 4 Stage 1, which is our current mode.  We need to stay focused in the short term on the most pressing issues, which revolve around Source and ABI stability.<br></p><p>&gt; 2.     What is the challenge of making a more dynamic Swift (or adding features to it to help solve the same kind of issues that are solved in ObjC through dynamism)? How could that be achieved without making Swift a less safe language? [e.g., reflection, macros, etc.]<br></p><p>It is a bit pedantic, but Swift isn’t a “safe&quot; language: it is a “safe by default” language which gives you direct access to unsafe constructs when you explicitly ask for them (e.g. UnsafePointer).  <br></p><p>Regardless of that, I don’t see any conflict with adding reflective capabilities, and I don’t see how having them would present a safety problem.  I expect that they’d end up being somewhat different than the Objective-C analogues of these features, but that is true about everything else in Swift (e.g. method call syntax in the two languages is pretty different).<br></p><p>&gt; 3.     Are you aware of any work that has been/is being done in Swift development (Swift 3/Swift 4) to make Swift more capable of addressing the above mentioned concerns?<br></p><p>The most relevant is the extensive work on data reflection metadata that was put into Swift 3.  It is key to enabling the Xcode 8 memory visualization / debugger feature, and is a fundamental building block for a data reflection API.  In fact, if I recall correctly, a 3rd party framework already build a custom data reflection API around this metadata already (Zewo?).<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160927/29081c4d/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
