<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2679e7a28cb46e207a562ad4e7fc45fc?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>James F</string> &lt;conductator at ntlworld.com&gt;<p>April 21, 2016 at 12:00:00pm</p></header><div class="content"><p>I sometimes find myself wanting to use private protocols + extensions to try to add public functions to a set of types. Something like this:<br></p><p>private protocol ArrayBackedType {<br>    var data: [String] {get set}<br>}<br>public extension ArrayBackedType: UITableViewDataSource {<br>    /*standard table view methods here*/<br>}<br></p><p>This would currently require two changes to the language: public extensions to private protocols, and support for ObjC-compatible functions in extensions (which should be possible for private/internal protocols).<br></p><p>Additionally, extensions could get the ability to add storage to the (non-imported) type they extend, so:<br></p><p>internal protocol ArrayBackedType {}<br>public extension ArrayBackedType: UITableViewDataSource {<br>    private var data: [String] = []<br>    dynamic func tableView(…)<br>}<br></p><p>The separate protocol &amp; extension declarations could then get some syntactic sugar:<br></p><p>/*can&#39;t be public, since it can add properties, internal availability matches that of the protocol in the previous example*/<br>internal protocol extension ArrayBackedType { … }<br></p><p>or even more concisely:<br>internal trait ArrayBackedType { … }<br></p><p>Could traits be constructed from protocol extensions in this way, or otherwise end up competing with them if just some of these features were to be added? My concern is that adding traits as a separate language feature could put them in direct competition with protocol extensions.<br></p><p>------------ Begin Message ------------ <br>Group: gmane.comp.lang.swift.evolution <br>MsgID: &lt;CAEbsasTVGD6NEZdnFhTMWVwuNc7EBDqatJAJhZFn4vOxdVPBiA at mail.gmail.com&gt; <br></p><p>Another traits implemenation<br></p><p>http://php.net/manual/en/language.oop5.traits.php<br>On Apr 21, 2016 5:53 PM, &quot;Niall Young via swift-evolution&quot; &lt;<br>swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br></p><p>&gt;At Tue Mar 1 19:00:21 CST 2016, Brian Pratt brian at pratt.io wrote:<br>&gt;<br>&gt;I feel like the solution to the Arrow/Enemy problem that best fits with<br>&gt;&gt;Swift&#39;s current available tools is neither a protocol (which, as you<br>&gt;&gt;mentioned, doesn&#39;t get rid of the initialization/configuration of the<br>&gt;&gt;member data) or inheritance (which, as you mentioned, can only have one<br>&gt;&gt;base type) -- it&#39;s to extract a third type that handles<br>&gt;&gt;<br>&gt;<br>&gt;What you&#39;re describing sounds _exactly_ like Traits :-)<br>&gt;<br>&gt;http://scg.unibe.ch/research/traits<br>&gt;<br>&gt;Traits could be a peer of extensions, filling a niche that isn&#39;t quite the<br>&gt;same niche as a default implementation, but it could be consistently and<br>&gt;safely consumed like an extension, with its own rules of consumption<br>&gt;(flattening) - to implement any need or explicit protocol requirement that<br>&gt;a Class, Value Type or Protocol has at compile-time.<br>&gt;<br>&gt;Think of a Trait as providing a consumable set of functions.  Now imagine<br>&gt;that we&#39;re combining the collective declarations of 1..N Traits all<br>&gt;together, consumed by a Class or Value Type (or Protocol!) in a predicable<br>&gt;and safe way (flattening: see the first Traits white paper).<br>&gt;<br>&gt;i.e. we get the same result regardless of the order of consumption, how<br>&gt;many times any given Trait(s) were consumed, Traits dependent on other<br>&gt;Traits etc.  Predictable results, given the same input we always get the<br>&gt;same output.  This is flattening, but read the white papers for more detail.<br>&gt;<br>&gt;The process of flattening itself could be a peer of the existing rules<br>&gt;around static dispatch vs. dynamic dispatch around<br>&gt;default-implementations/extensions vs. class overrides.<br>&gt;<br>&gt;A Trait declaration could look something ~like:<br>&gt;<br>&gt;trait TraitX (ProtocolAdherenceY): DependentTrait1,<br>&gt;DependentTrait2 {<br>&gt;<br>&gt;private var foo<br>&gt;private let bah { .. }<br>&gt;<br>&gt;func fooify { .. }<br>&gt;mutating func bahify { .. }<br>&gt;private func hah { .. }<br>&gt;<br>&gt;}<br>&gt;<br>&gt;with a Trait being a closure, where _only private_ data Properties can be<br>&gt;declared, providing 1..N function implementations.  It could conform<br>&gt;_towards_ a Protocol (partial to full conformance), and also be dependent<br>&gt;upon other names Traits, which would be consumed in parallel as a<br>&gt;first-class citizen with the Trait that depends on it.<br>&gt;<br>&gt;Traits could be consumed by a class or value type, to provide function<br>&gt;implementations which could be satisfying a Protocol implementation<br>&gt;requirement, along with its own private functions and private data for its<br>&gt;(private to Trait) local state etc.  The consumption syntax I&#39;m still<br>&gt;unsure of, but a clear declarative &quot;flattens Trait1, Trait2, .. , TraitN&quot;<br>&gt;or similar would do.<br>&gt;<br>&gt;The consuming Class or Value Type would remain fully responsible for its<br>&gt;own Protocol conformance, and if any of the consumed Trait public<br>&gt;implementations conflict or overlap with each other, then the conflicts<br>&gt;must be resolved explicitly by the Class or Value Type itself, where it is<br>&gt;consumed.<br>&gt;<br>&gt;The resulting &quot;flattened&quot; set of Traits would be input towards the Type&#39;s<br>&gt;own compiler requirements, with the author being required to explicitly<br>&gt;resolve any and all conflicts at compile-time.  Cconsumption at run-time<br>&gt;could be a later feature as Swift&#39;s core stabilises and specific run-time<br>&gt;metaprogramming facilities are exposed.<br>&gt;<br>&gt;Explicit conflict resolution, via a flattened 2D matrix of Trait:func<br>&gt;identifying conflicts that need to be resolved by the consumer, also gives<br>&gt;reliable results with no cognitive overhead as Brian&#39;s identified in<br>&gt;resolving Mixin consumption.  Plus there is no diamond-problem, as there is<br>&gt;no inheritance.  With Traits, it _must_ be resolved explicitly in code,<br>&gt;with suitable compiler errors for malformed Types that have consumed 1..N<br>&gt;Trait(s).<br>&gt;<br>&gt;Stateful Traits suggest that as long as the data is private _to the Trait_<br>&gt;then we can safely ignore some of the complexity of state in Traits - it<br>&gt;just isn&#39;t exposed as the Trait declaration itself is a closure.<br>&gt;Dependency on state in the consumer could proxy to<br>&gt;class/instance/value-type data via Protocol.<br>&gt;<br>&gt;Swift and Protocols seem like a perfect match for &quot;capital-T&quot; Traits.  Any<br>&gt;thoughts on if this is suitable for a 3.0 or 4.0 Proposal?<br>&gt;<br>&gt;I&#39;ve recently built similar mechanisms exploring these concepts with basic<br>&gt;metaprogramming and a common root class in a dynamic language, but as a<br>&gt;core language feature of Swift I think it could very much complement the<br>&gt;existing protocols and extension concepts, with 1..N re-usable<br>&gt;implementations, and it also could help to resolves the uncertainty/rules<br>&gt;around static vs. dynamic dispatch: static could remain the domain of<br>&gt;extensions / default implementations; with dynamic dispatch available to<br>&gt;Classes and Traits?<br>&gt;<br>&gt;More Reading:<br>&gt;<br>&gt;http://scg.unibe.ch/research/traits<br>&gt;<br>&gt;Cheers,<br>&gt;<br>&gt;--<br>&gt;Niall Young<br>&gt;niall-AFFH1GffN5hPR4JQBCEnsQ at public.gmane.org<br>&gt;<br>&gt;<br>&gt;At Tue Mar 1 19:00:21 CST 2016, Brian Pratt brian at pratt.io wrote:<br>&gt;<br>&gt;I think this sort of composition is preferable to inheritance in a lot of<br>&gt;&gt;ways, and Swift has some built-in tools that can augment it: a robust<br>&gt;&gt;protocol and extension system, a type constraint system that allows for<br>&gt;&gt;lots of flexibility at compile-time, etc.<br>&gt;&gt;<br>&gt;&gt;Mixins (and in general, the sharing of code primarily via inheritance)<br>&gt;&gt;tend<br>&gt;&gt;to create large objects with lots of responsibilities, and that tends to<br>&gt;&gt;bloat APIs as you need to either pick extremely specific names to avoid<br>&gt;&gt;collisions, or worse, keep the cognitive overhead of &quot;shoot, what is this<br>&gt;&gt;method aliased to again?&quot; in your head all the time. If something *is*<br>&gt;&gt;both<br>&gt;&gt;an A and a B, it needs to act like (and speak the same language of) an A<br>&gt;&gt;or<br>&gt;&gt;a B *all* of the time.<br>&gt;&gt;<br>&gt;&gt;Beyond this, I think it&#39;s going to be extremely complex managing<br>&gt;&gt;compile-time type constraints with renames in place. Let&#39;s say I have a<br>&gt;&gt;class C that inherits from bases A and B, which implement protocol P and Q<br>&gt;&gt;respectively, and there&#39;s a naming collision. Functions that expect Ps or<br>&gt;&gt;Qs will have to know about the renaming of conflicts from the combination<br>&gt;&gt;of A+B? Unless I&#39;m missing something, it feels like this complexity would<br>&gt;&gt;continue to spread out to all sorts of collaborators, when the current<br>&gt;&gt;system isolates it much more effectively.<br>&gt;&gt;<br>&gt;<br>&gt;I think protocols and protocol extensions (mixed with lots of composition)<br>&gt;&gt;is a better scenario than abstract classes or multiple inheritance, and<br>&gt;&gt;therefore, I&#39;m still a -1 on mixins in Swift (strictly on principle; this<br>&gt;&gt;proposal actually argues the case very well).<br>&gt;&gt;<br>&gt;&gt;- Brian<br>&gt;&gt;<br>&gt;<br>&gt;And agreed Thorsten!:<br>&gt;<br>&gt;Unfortunately the current discussions about Mixins, abstract classes, POP<br>&gt;&gt;&gt;vs. OOP suffer from having forgotten achievements of the past which<br>&gt;&gt;&gt;results<br>&gt;&gt;&gt;in creating differences where none should be.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;It is unfortunate and IMO just for historical reasons that there is a<br>&gt;&gt;&gt;dichotomy between protocols and classes at all instead of having just<br>&gt;&gt;&gt;classes with multiple inheritance done right (and abstract methods).<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;- We should extend protocols to support real multiple inheritance with<br>&gt;&gt;&gt;renaming<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;-Thorsten<br>&gt;&gt;&gt;<br>&gt;&gt;_______________________________________________<br>&gt;swift-evolution mailing list<br>&gt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org<br>&gt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>------------- End Message ------------- <br></p><p><br></p><p>From James F<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a03106b2fbee9e0ada822057dfd0b6d3?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Tal Atlas</string> &lt;me at tal.by&gt;<p>April 21, 2016 at 08:00:00am</p></header><div class="content"><p>I agree that the solution to any of these problems would be better done<br>with improvements to protocol extensions. Having multiple tools to get the<br>same trick done doesn’t seem worth it in this case.<br></p><p>-Tal<br></p><p>On Thu, Apr 21, 2016 at 7:00 AM, James Froggatt via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I sometimes find myself wanting to use private protocols + extensions to<br>&gt; try to add public functions to a set of types. Something like this:<br>&gt;<br>&gt; private protocol ArrayBackedType {<br>&gt;     var data: [String] {get set}<br>&gt; }<br>&gt; public extension ArrayBackedType: UITableViewDataSource {<br>&gt;     /*standard table view methods here*/<br>&gt; }<br>&gt;<br>&gt; This would currently require two changes to the language: public<br>&gt; extensions to private protocols, and support for ObjC-compatible functions<br>&gt; in extensions (which should be possible for private/internal protocols).<br>&gt;<br>&gt; Additionally, extensions could get the ability to add storage to the<br>&gt; (non-imported) type they extend, so:<br>&gt;<br>&gt; internal protocol ArrayBackedType {}<br>&gt; public extension ArrayBackedType: UITableViewDataSource {<br>&gt;     private var data: [String] = []<br>&gt;     dynamic func tableView(…)<br>&gt; }<br>&gt;<br>&gt; The separate protocol &amp; extension declarations could then get some<br>&gt; syntactic sugar:<br>&gt;<br>&gt; /*can&#39;t be public, since it can add properties, internal availability<br>&gt; matches that of the protocol in the previous example*/<br>&gt; internal protocol extension ArrayBackedType { … }<br>&gt;<br>&gt; or even more concisely:<br>&gt; internal trait ArrayBackedType { … }<br>&gt;<br>&gt; Could traits be constructed from protocol extensions in this way, or<br>&gt; otherwise end up competing with them if just some of these features were to<br>&gt; be added? My concern is that adding traits as a separate language feature<br>&gt; could put them in direct competition with protocol extensions.<br>&gt;<br>&gt; ------------ Begin Message ------------<br>&gt; Group: gmane.comp.lang.swift.evolution<br>&gt; MsgID: &lt;CAEbsasTVGD6NEZdnFhTMWVwuNc7EBDqatJAJhZFn4vOxdVPBiA at mail.gmail.com<br>&gt; &gt;<br>&gt;<br>&gt; Another traits implemenation<br>&gt;<br>&gt; http://php.net/manual/en/language.oop5.traits.php<br>&gt; On Apr 21, 2016 5:53 PM, &quot;Niall Young via swift-evolution&quot; &lt;<br>&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br>&gt;<br>&gt; &gt;At Tue Mar 1 19:00:21 CST 2016, Brian Pratt brian at pratt.io wrote:<br>&gt; &gt;<br>&gt; &gt;I feel like the solution to the Arrow/Enemy problem that best fits with<br>&gt; &gt;&gt;Swift&#39;s current available tools is neither a protocol (which, as you<br>&gt; &gt;&gt;mentioned, doesn&#39;t get rid of the initialization/configuration of the<br>&gt; &gt;&gt;member data) or inheritance (which, as you mentioned, can only have one<br>&gt; &gt;&gt;base type) -- it&#39;s to extract a third type that handles<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt;What you&#39;re describing sounds _exactly_ like Traits :-)<br>&gt; &gt;<br>&gt; &gt;http://scg.unibe.ch/research/traits<br>&gt; &gt;<br>&gt; &gt;Traits could be a peer of extensions, filling a niche that isn&#39;t quite the<br>&gt; &gt;same niche as a default implementation, but it could be consistently and<br>&gt; &gt;safely consumed like an extension, with its own rules of consumption<br>&gt; &gt;(flattening) - to implement any need or explicit protocol requirement that<br>&gt; &gt;a Class, Value Type or Protocol has at compile-time.<br>&gt; &gt;<br>&gt; &gt;Think of a Trait as providing a consumable set of functions.  Now imagine<br>&gt; &gt;that we&#39;re combining the collective declarations of 1..N Traits all<br>&gt; &gt;together, consumed by a Class or Value Type (or Protocol!) in a predicable<br>&gt; &gt;and safe way (flattening: see the first Traits white paper).<br>&gt; &gt;<br>&gt; &gt;i.e. we get the same result regardless of the order of consumption, how<br>&gt; &gt;many times any given Trait(s) were consumed, Traits dependent on other<br>&gt; &gt;Traits etc.  Predictable results, given the same input we always get the<br>&gt; &gt;same output.  This is flattening, but read the white papers for more<br>&gt; detail.<br>&gt; &gt;<br>&gt; &gt;The process of flattening itself could be a peer of the existing rules<br>&gt; &gt;around static dispatch vs. dynamic dispatch around<br>&gt; &gt;default-implementations/extensions vs. class overrides.<br>&gt; &gt;<br>&gt; &gt;A Trait declaration could look something ~like:<br>&gt; &gt;<br>&gt; &gt;trait TraitX (ProtocolAdherenceY): DependentTrait1,<br>&gt; &gt;DependentTrait2 {<br>&gt; &gt;<br>&gt; &gt;private var foo<br>&gt; &gt;private let bah { .. }<br>&gt; &gt;<br>&gt; &gt;func fooify { .. }<br>&gt; &gt;mutating func bahify { .. }<br>&gt; &gt;private func hah { .. }<br>&gt; &gt;<br>&gt; &gt;}<br>&gt; &gt;<br>&gt; &gt;with a Trait being a closure, where _only private_ data Properties can be<br>&gt; &gt;declared, providing 1..N function implementations.  It could conform<br>&gt; &gt;_towards_ a Protocol (partial to full conformance), and also be dependent<br>&gt; &gt;upon other names Traits, which would be consumed in parallel as a<br>&gt; &gt;first-class citizen with the Trait that depends on it.<br>&gt; &gt;<br>&gt; &gt;Traits could be consumed by a class or value type, to provide function<br>&gt; &gt;implementations which could be satisfying a Protocol implementation<br>&gt; &gt;requirement, along with its own private functions and private data for its<br>&gt; &gt;(private to Trait) local state etc.  The consumption syntax I&#39;m still<br>&gt; &gt;unsure of, but a clear declarative &quot;flattens Trait1, Trait2, .. , TraitN&quot;<br>&gt; &gt;or similar would do.<br>&gt; &gt;<br>&gt; &gt;The consuming Class or Value Type would remain fully responsible for its<br>&gt; &gt;own Protocol conformance, and if any of the consumed Trait public<br>&gt; &gt;implementations conflict or overlap with each other, then the conflicts<br>&gt; &gt;must be resolved explicitly by the Class or Value Type itself, where it is<br>&gt; &gt;consumed.<br>&gt; &gt;<br>&gt; &gt;The resulting &quot;flattened&quot; set of Traits would be input towards the Type&#39;s<br>&gt; &gt;own compiler requirements, with the author being required to explicitly<br>&gt; &gt;resolve any and all conflicts at compile-time.  Cconsumption at run-time<br>&gt; &gt;could be a later feature as Swift&#39;s core stabilises and specific run-time<br>&gt; &gt;metaprogramming facilities are exposed.<br>&gt; &gt;<br>&gt; &gt;Explicit conflict resolution, via a flattened 2D matrix of Trait:func<br>&gt; &gt;identifying conflicts that need to be resolved by the consumer, also gives<br>&gt; &gt;reliable results with no cognitive overhead as Brian&#39;s identified in<br>&gt; &gt;resolving Mixin consumption.  Plus there is no diamond-problem, as there<br>&gt; is<br>&gt; &gt;no inheritance.  With Traits, it _must_ be resolved explicitly in code,<br>&gt; &gt;with suitable compiler errors for malformed Types that have consumed 1..N<br>&gt; &gt;Trait(s).<br>&gt; &gt;<br>&gt; &gt;Stateful Traits suggest that as long as the data is private _to the Trait_<br>&gt; &gt;then we can safely ignore some of the complexity of state in Traits - it<br>&gt; &gt;just isn&#39;t exposed as the Trait declaration itself is a closure.<br>&gt; &gt;Dependency on state in the consumer could proxy to<br>&gt; &gt;class/instance/value-type data via Protocol.<br>&gt; &gt;<br>&gt; &gt;Swift and Protocols seem like a perfect match for &quot;capital-T&quot; Traits.  Any<br>&gt; &gt;thoughts on if this is suitable for a 3.0 or 4.0 Proposal?<br>&gt; &gt;<br>&gt; &gt;I&#39;ve recently built similar mechanisms exploring these concepts with basic<br>&gt; &gt;metaprogramming and a common root class in a dynamic language, but as a<br>&gt; &gt;core language feature of Swift I think it could very much complement the<br>&gt; &gt;existing protocols and extension concepts, with 1..N re-usable<br>&gt; &gt;implementations, and it also could help to resolves the uncertainty/rules<br>&gt; &gt;around static vs. dynamic dispatch: static could remain the domain of<br>&gt; &gt;extensions / default implementations; with dynamic dispatch available to<br>&gt; &gt;Classes and Traits?<br>&gt; &gt;<br>&gt; &gt;More Reading:<br>&gt; &gt;<br>&gt; &gt;http://scg.unibe.ch/research/traits<br>&gt; &gt;<br>&gt; &gt;Cheers,<br>&gt; &gt;<br>&gt; &gt;--<br>&gt; &gt;Niall Young<br>&gt; &gt;niall-AFFH1GffN5hPR4JQBCEnsQ at public.gmane.org<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;At Tue Mar 1 19:00:21 CST 2016, Brian Pratt brian at pratt.io wrote:<br>&gt; &gt;<br>&gt; &gt;I think this sort of composition is preferable to inheritance in a lot of<br>&gt; &gt;&gt;ways, and Swift has some built-in tools that can augment it: a robust<br>&gt; &gt;&gt;protocol and extension system, a type constraint system that allows for<br>&gt; &gt;&gt;lots of flexibility at compile-time, etc.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;Mixins (and in general, the sharing of code primarily via inheritance)<br>&gt; &gt;&gt;tend<br>&gt; &gt;&gt;to create large objects with lots of responsibilities, and that tends to<br>&gt; &gt;&gt;bloat APIs as you need to either pick extremely specific names to avoid<br>&gt; &gt;&gt;collisions, or worse, keep the cognitive overhead of &quot;shoot, what is this<br>&gt; &gt;&gt;method aliased to again?&quot; in your head all the time. If something *is*<br>&gt; &gt;&gt;both<br>&gt; &gt;&gt;an A and a B, it needs to act like (and speak the same language of) an A<br>&gt; &gt;&gt;or<br>&gt; &gt;&gt;a B *all* of the time.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;Beyond this, I think it&#39;s going to be extremely complex managing<br>&gt; &gt;&gt;compile-time type constraints with renames in place. Let&#39;s say I have a<br>&gt; &gt;&gt;class C that inherits from bases A and B, which implement protocol P and<br>&gt; Q<br>&gt; &gt;&gt;respectively, and there&#39;s a naming collision. Functions that expect Ps or<br>&gt; &gt;&gt;Qs will have to know about the renaming of conflicts from the combination<br>&gt; &gt;&gt;of A+B? Unless I&#39;m missing something, it feels like this complexity would<br>&gt; &gt;&gt;continue to spread out to all sorts of collaborators, when the current<br>&gt; &gt;&gt;system isolates it much more effectively.<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt;I think protocols and protocol extensions (mixed with lots of composition)<br>&gt; &gt;&gt;is a better scenario than abstract classes or multiple inheritance, and<br>&gt; &gt;&gt;therefore, I&#39;m still a -1 on mixins in Swift (strictly on principle; this<br>&gt; &gt;&gt;proposal actually argues the case very well).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;- Brian<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt;And agreed Thorsten!:<br>&gt; &gt;<br>&gt; &gt;Unfortunately the current discussions about Mixins, abstract classes, POP<br>&gt; &gt;&gt;&gt;vs. OOP suffer from having forgotten achievements of the past which<br>&gt; &gt;&gt;&gt;results<br>&gt; &gt;&gt;&gt;in creating differences where none should be.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;It is unfortunate and IMO just for historical reasons that there is a<br>&gt; &gt;&gt;&gt;dichotomy between protocols and classes at all instead of having just<br>&gt; &gt;&gt;&gt;classes with multiple inheritance done right (and abstract methods).<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;- We should extend protocols to support real multiple inheritance with<br>&gt; &gt;&gt;&gt;renaming<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;-Thorsten<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;_______________________________________________<br>&gt; &gt;swift-evolution mailing list<br>&gt; &gt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org<br>&gt; &gt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; ------------- End Message -------------<br>&gt;<br>&gt;<br>&gt;<br>&gt; From James F<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160421/c256e0fb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>April 21, 2016 at 03:00:00pm</p></header><div class="content"><p>FWIW:<br></p><p>Im working on a proposal to cover this points, using protocols a few days.<br>One or two days i will post...<br></p><p>Em qui, 21 de abr de 2016 09:27, Tal Atlas via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt; I agree that the solution to any of these problems would be better done<br>&gt; with improvements to protocol extensions. Having multiple tools to get the<br>&gt; same trick done doesn’t seem worth it in this case.<br>&gt;<br>&gt; -Tal<br>&gt;<br>&gt; On Thu, Apr 21, 2016 at 7:00 AM, James Froggatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I sometimes find myself wanting to use private protocols + extensions to<br>&gt;&gt; try to add public functions to a set of types. Something like this:<br>&gt;&gt;<br>&gt;&gt; private protocol ArrayBackedType {<br>&gt;&gt;     var data: [String] {get set}<br>&gt;&gt; }<br>&gt;&gt; public extension ArrayBackedType: UITableViewDataSource {<br>&gt;&gt;     /*standard table view methods here*/<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; This would currently require two changes to the language: public<br>&gt;&gt; extensions to private protocols, and support for ObjC-compatible functions<br>&gt;&gt; in extensions (which should be possible for private/internal protocols).<br>&gt;&gt;<br>&gt;&gt; Additionally, extensions could get the ability to add storage to the<br>&gt;&gt; (non-imported) type they extend, so:<br>&gt;&gt;<br>&gt;&gt; internal protocol ArrayBackedType {}<br>&gt;&gt; public extension ArrayBackedType: UITableViewDataSource {<br>&gt;&gt;     private var data: [String] = []<br>&gt;&gt;     dynamic func tableView(…)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; The separate protocol &amp; extension declarations could then get some<br>&gt;&gt; syntactic sugar:<br>&gt;&gt;<br>&gt;&gt; /*can&#39;t be public, since it can add properties, internal availability<br>&gt;&gt; matches that of the protocol in the previous example*/<br>&gt;&gt; internal protocol extension ArrayBackedType { … }<br>&gt;&gt;<br>&gt;&gt; or even more concisely:<br>&gt;&gt; internal trait ArrayBackedType { … }<br>&gt;&gt;<br>&gt;&gt; Could traits be constructed from protocol extensions in this way, or<br>&gt;&gt; otherwise end up competing with them if just some of these features were to<br>&gt;&gt; be added? My concern is that adding traits as a separate language feature<br>&gt;&gt; could put them in direct competition with protocol extensions.<br>&gt;&gt;<br>&gt;&gt; ------------ Begin Message ------------<br>&gt;&gt; Group: gmane.comp.lang.swift.evolution<br>&gt;&gt; MsgID: &lt;<br>&gt;&gt; CAEbsasTVGD6NEZdnFhTMWVwuNc7EBDqatJAJhZFn4vOxdVPBiA at mail.gmail.com&gt;<br>&gt;&gt;<br>&gt;&gt; Another traits implemenation<br>&gt;&gt;<br>&gt;&gt; http://php.net/manual/en/language.oop5.traits.php<br>&gt;&gt; On Apr 21, 2016 5:53 PM, &quot;Niall Young via swift-evolution&quot; &lt;<br>&gt;&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt;At Tue Mar 1 19:00:21 CST 2016, Brian Pratt brian at pratt.io wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;I feel like the solution to the Arrow/Enemy problem that best fits with<br>&gt;&gt; &gt;&gt;Swift&#39;s current available tools is neither a protocol (which, as you<br>&gt;&gt; &gt;&gt;mentioned, doesn&#39;t get rid of the initialization/configuration of the<br>&gt;&gt; &gt;&gt;member data) or inheritance (which, as you mentioned, can only have one<br>&gt;&gt; &gt;&gt;base type) -- it&#39;s to extract a third type that handles<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;What you&#39;re describing sounds _exactly_ like Traits :-)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;http://scg.unibe.ch/research/traits<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;Traits could be a peer of extensions, filling a niche that isn&#39;t quite<br>&gt;&gt; the<br>&gt;&gt; &gt;same niche as a default implementation, but it could be consistently and<br>&gt;&gt; &gt;safely consumed like an extension, with its own rules of consumption<br>&gt;&gt; &gt;(flattening) - to implement any need or explicit protocol requirement<br>&gt;&gt; that<br>&gt;&gt; &gt;a Class, Value Type or Protocol has at compile-time.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;Think of a Trait as providing a consumable set of functions.  Now imagine<br>&gt;&gt; &gt;that we&#39;re combining the collective declarations of 1..N Traits all<br>&gt;&gt; &gt;together, consumed by a Class or Value Type (or Protocol!) in a<br>&gt;&gt; predicable<br>&gt;&gt; &gt;and safe way (flattening: see the first Traits white paper).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;i.e. we get the same result regardless of the order of consumption, how<br>&gt;&gt; &gt;many times any given Trait(s) were consumed, Traits dependent on other<br>&gt;&gt; &gt;Traits etc.  Predictable results, given the same input we always get the<br>&gt;&gt; &gt;same output.  This is flattening, but read the white papers for more<br>&gt;&gt; detail.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;The process of flattening itself could be a peer of the existing rules<br>&gt;&gt; &gt;around static dispatch vs. dynamic dispatch around<br>&gt;&gt; &gt;default-implementations/extensions vs. class overrides.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;A Trait declaration could look something ~like:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;trait TraitX (ProtocolAdherenceY): DependentTrait1,<br>&gt;&gt; &gt;DependentTrait2 {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;private var foo<br>&gt;&gt; &gt;private let bah { .. }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;func fooify { .. }<br>&gt;&gt; &gt;mutating func bahify { .. }<br>&gt;&gt; &gt;private func hah { .. }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;}<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;with a Trait being a closure, where _only private_ data Properties can be<br>&gt;&gt; &gt;declared, providing 1..N function implementations.  It could conform<br>&gt;&gt; &gt;_towards_ a Protocol (partial to full conformance), and also be dependent<br>&gt;&gt; &gt;upon other names Traits, which would be consumed in parallel as a<br>&gt;&gt; &gt;first-class citizen with the Trait that depends on it.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;Traits could be consumed by a class or value type, to provide function<br>&gt;&gt; &gt;implementations which could be satisfying a Protocol implementation<br>&gt;&gt; &gt;requirement, along with its own private functions and private data for<br>&gt;&gt; its<br>&gt;&gt; &gt;(private to Trait) local state etc.  The consumption syntax I&#39;m still<br>&gt;&gt; &gt;unsure of, but a clear declarative &quot;flattens Trait1, Trait2, .. , TraitN&quot;<br>&gt;&gt; &gt;or similar would do.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;The consuming Class or Value Type would remain fully responsible for its<br>&gt;&gt; &gt;own Protocol conformance, and if any of the consumed Trait public<br>&gt;&gt; &gt;implementations conflict or overlap with each other, then the conflicts<br>&gt;&gt; &gt;must be resolved explicitly by the Class or Value Type itself, where it<br>&gt;&gt; is<br>&gt;&gt; &gt;consumed.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;The resulting &quot;flattened&quot; set of Traits would be input towards the Type&#39;s<br>&gt;&gt; &gt;own compiler requirements, with the author being required to explicitly<br>&gt;&gt; &gt;resolve any and all conflicts at compile-time.  Cconsumption at run-time<br>&gt;&gt; &gt;could be a later feature as Swift&#39;s core stabilises and specific run-time<br>&gt;&gt; &gt;metaprogramming facilities are exposed.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;Explicit conflict resolution, via a flattened 2D matrix of Trait:func<br>&gt;&gt; &gt;identifying conflicts that need to be resolved by the consumer, also<br>&gt;&gt; gives<br>&gt;&gt; &gt;reliable results with no cognitive overhead as Brian&#39;s identified in<br>&gt;&gt; &gt;resolving Mixin consumption.  Plus there is no diamond-problem, as there<br>&gt;&gt; is<br>&gt;&gt; &gt;no inheritance.  With Traits, it _must_ be resolved explicitly in code,<br>&gt;&gt; &gt;with suitable compiler errors for malformed Types that have consumed 1..N<br>&gt;&gt; &gt;Trait(s).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;Stateful Traits suggest that as long as the data is private _to the<br>&gt;&gt; Trait_<br>&gt;&gt; &gt;then we can safely ignore some of the complexity of state in Traits - it<br>&gt;&gt; &gt;just isn&#39;t exposed as the Trait declaration itself is a closure.<br>&gt;&gt; &gt;Dependency on state in the consumer could proxy to<br>&gt;&gt; &gt;class/instance/value-type data via Protocol.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;Swift and Protocols seem like a perfect match for &quot;capital-T&quot; Traits.<br>&gt;&gt; Any<br>&gt;&gt; &gt;thoughts on if this is suitable for a 3.0 or 4.0 Proposal?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;I&#39;ve recently built similar mechanisms exploring these concepts with<br>&gt;&gt; basic<br>&gt;&gt; &gt;metaprogramming and a common root class in a dynamic language, but as a<br>&gt;&gt; &gt;core language feature of Swift I think it could very much complement the<br>&gt;&gt; &gt;existing protocols and extension concepts, with 1..N re-usable<br>&gt;&gt; &gt;implementations, and it also could help to resolves the uncertainty/rules<br>&gt;&gt; &gt;around static vs. dynamic dispatch: static could remain the domain of<br>&gt;&gt; &gt;extensions / default implementations; with dynamic dispatch available to<br>&gt;&gt; &gt;Classes and Traits?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;More Reading:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;http://scg.unibe.ch/research/traits<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;Cheers,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;--<br>&gt;&gt; &gt;Niall Young<br>&gt;&gt; &gt;niall-AFFH1GffN5hPR4JQBCEnsQ at public.gmane.org<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;At Tue Mar 1 19:00:21 CST 2016, Brian Pratt brian at pratt.io wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;I think this sort of composition is preferable to inheritance in a lot of<br>&gt;&gt; &gt;&gt;ways, and Swift has some built-in tools that can augment it: a robust<br>&gt;&gt; &gt;&gt;protocol and extension system, a type constraint system that allows for<br>&gt;&gt; &gt;&gt;lots of flexibility at compile-time, etc.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;Mixins (and in general, the sharing of code primarily via inheritance)<br>&gt;&gt; &gt;&gt;tend<br>&gt;&gt; &gt;&gt;to create large objects with lots of responsibilities, and that tends to<br>&gt;&gt; &gt;&gt;bloat APIs as you need to either pick extremely specific names to avoid<br>&gt;&gt; &gt;&gt;collisions, or worse, keep the cognitive overhead of &quot;shoot, what is<br>&gt;&gt; this<br>&gt;&gt; &gt;&gt;method aliased to again?&quot; in your head all the time. If something *is*<br>&gt;&gt; &gt;&gt;both<br>&gt;&gt; &gt;&gt;an A and a B, it needs to act like (and speak the same language of) an A<br>&gt;&gt; &gt;&gt;or<br>&gt;&gt; &gt;&gt;a B *all* of the time.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;Beyond this, I think it&#39;s going to be extremely complex managing<br>&gt;&gt; &gt;&gt;compile-time type constraints with renames in place. Let&#39;s say I have a<br>&gt;&gt; &gt;&gt;class C that inherits from bases A and B, which implement protocol P<br>&gt;&gt; and Q<br>&gt;&gt; &gt;&gt;respectively, and there&#39;s a naming collision. Functions that expect Ps<br>&gt;&gt; or<br>&gt;&gt; &gt;&gt;Qs will have to know about the renaming of conflicts from the<br>&gt;&gt; combination<br>&gt;&gt; &gt;&gt;of A+B? Unless I&#39;m missing something, it feels like this complexity<br>&gt;&gt; would<br>&gt;&gt; &gt;&gt;continue to spread out to all sorts of collaborators, when the current<br>&gt;&gt; &gt;&gt;system isolates it much more effectively.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;I think protocols and protocol extensions (mixed with lots of<br>&gt;&gt; composition)<br>&gt;&gt; &gt;&gt;is a better scenario than abstract classes or multiple inheritance, and<br>&gt;&gt; &gt;&gt;therefore, I&#39;m still a -1 on mixins in Swift (strictly on principle;<br>&gt;&gt; this<br>&gt;&gt; &gt;&gt;proposal actually argues the case very well).<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;- Brian<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;And agreed Thorsten!:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;Unfortunately the current discussions about Mixins, abstract classes, POP<br>&gt;&gt; &gt;&gt;&gt;vs. OOP suffer from having forgotten achievements of the past which<br>&gt;&gt; &gt;&gt;&gt;results<br>&gt;&gt; &gt;&gt;&gt;in creating differences where none should be.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;It is unfortunate and IMO just for historical reasons that there is a<br>&gt;&gt; &gt;&gt;&gt;dichotomy between protocols and classes at all instead of having just<br>&gt;&gt; &gt;&gt;&gt;classes with multiple inheritance done right (and abstract methods).<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;- We should extend protocols to support real multiple inheritance with<br>&gt;&gt; &gt;&gt;&gt;renaming<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;-Thorsten<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;_______________________________________________<br>&gt;&gt; &gt;swift-evolution mailing list<br>&gt;&gt; &gt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org<br>&gt;&gt; &gt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; ------------- End Message -------------<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; From James F<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160421/a0cad009/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
