<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pitch: Copy constructors for structs</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December 23, 2015 at 03:00:00pm</p></header><div class="content"><p>Introduction:<br></p><p>This is a request for a copy constructor mechanism for structs in Swift.<br></p><p>Motivation:<br></p><p>Suppose you have a class stored inside a struct, like so:<br></p><p>class C {<br>	func copy() -&gt; C { … }<br>}<br></p><p>struct S {<br>	var i: Int<br>	var c: C<br>}<br></p><p>and you create a couple of the structs, like so:<br></p><p>let c = C()<br>let foo = S(i: 1, c: c)<br>var bar = foo<br>bar.i = 2<br></p><p>Since the ‘bar’ variable was mutated, it now contains a copy of the original ‘foo’ struct. However, both structs still carry the same pointer to ‘c&#39;. There may be cases where you would want a copy of the struct to make a copy of any reference types stored within; however, that does not seem to be possible currently.<br></p><p>Proposed Solution:<br></p><p>Adding a copy constructor to S that would be called when a copy of the struct is about to be made. This constructor would simply create a new instance, initialize it, and return it. The copy constructor would look like this:<br></p><p>struct S {<br>	var i: Int<br>	var c: C<br></p><p>	copy {<br>		return S(i: self.i, c: self.c.copy())<br>	}<br>}<br></p><p>Structs that do not implement the copy constructor would get the same behavior as they do currently.<br></p><p>Impact on Existing Code:<br></p><p>There should be no impact on existing code that does not implement the copy constructor.<br></p><p>Charles<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Pitch: Copy constructors for structs</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 23, 2015 at 01:00:00pm</p></header><div class="content"><p>Currently, in most places where this is desired, we treat the reference type&#39;s interface as part of the value&#39;s interface and use copy-on-write to manage the referenced storage, as with arrays, dictionaries, and sets. Eager copying by a C++-like mechanism is interesting, and we designed the runtime with an eye toward future C++ interop, but this still has pretty massive impacts on the rest of the language and implementation that need deeper consideration than &quot;no impact on existing code&quot;. When exactly are copy constructors run? When, if ever, is the compiler allowed to elide copies? Is move optimization possible? Do you have destructors, and if so, when are they run? How and when do we know copying a shared value can be done in a thread-safe way? In addition to looking at the C++ model, I&#39;d also recommend thinking about simply allowing custom retain/release of otherwise bitwise-identical copies, or something like D&#39;s &quot;post-blit constructor&quot;, the design of which avoids some of the pitfalls of C++.<br></p><p>-Joe<br></p><p>&gt; On Dec 23, 2015, at 1:03 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Introduction:<br>&gt; <br>&gt; This is a request for a copy constructor mechanism for structs in Swift.<br>&gt; <br>&gt; Motivation:<br>&gt; <br>&gt; Suppose you have a class stored inside a struct, like so:<br>&gt; <br>&gt; class C {<br>&gt; 	func copy() -&gt; C { … }<br>&gt; }<br>&gt; <br>&gt; struct S {<br>&gt; 	var i: Int<br>&gt; 	var c: C<br>&gt; }<br>&gt; <br>&gt; and you create a couple of the structs, like so:<br>&gt; <br>&gt; let c = C()<br>&gt; let foo = S(i: 1, c: c)<br>&gt; var bar = foo<br>&gt; bar.i = 2<br>&gt; <br>&gt; Since the ‘bar’ variable was mutated, it now contains a copy of the original ‘foo’ struct. However, both structs still carry the same pointer to ‘c&#39;. There may be cases where you would want a copy of the struct to make a copy of any reference types stored within; however, that does not seem to be possible currently.<br>&gt; <br>&gt; Proposed Solution:<br>&gt; <br>&gt; Adding a copy constructor to S that would be called when a copy of the struct is about to be made. This constructor would simply create a new instance, initialize it, and return it. The copy constructor would look like this:<br>&gt; <br>&gt; struct S {<br>&gt; 	var i: Int<br>&gt; 	var c: C<br>&gt; <br>&gt; 	copy {<br>&gt; 		return S(i: self.i, c: self.c.copy())<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; Structs that do not implement the copy constructor would get the same behavior as they do currently.<br>&gt; <br>&gt; Impact on Existing Code:<br>&gt; <br>&gt; There should be no impact on existing code that does not implement the copy constructor.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Pitch: Copy constructors for structs</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 23, 2015 at 05:00:00pm</p></header><div class="content"><p>The &quot;when exactly are copy constructors run&quot; and &quot;when is the compiler allowed to elide copies&quot; parts are very important and not always obvious in current Swift code. For instance:<br></p><p>&gt; struct Point {<br>&gt; 	var x: Int<br>&gt; 	var y: Int<br>&gt; }<br>&gt; <br>&gt; class Foo {<br>&gt; 	var point: Point<br>&gt; }<br>&gt; <br>&gt; let foo = Foo()<br>&gt; foo.point.x = 4<br></p><p>This code &quot;expands&quot; to:<br></p><p>&gt; var point = foo.point<br>&gt; point.x = 4<br>&gt; foo.point = point<br></p><p>in which you have two copies, whereas in C++ you would have none.<br></p><p>Félix<br></p><p>&gt; Le 23 déc. 2015 à 16:25:50, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Currently, in most places where this is desired, we treat the reference type&#39;s interface as part of the value&#39;s interface and use copy-on-write to manage the referenced storage, as with arrays, dictionaries, and sets. Eager copying by a C++-like mechanism is interesting, and we designed the runtime with an eye toward future C++ interop, but this still has pretty massive impacts on the rest of the language and implementation that need deeper consideration than &quot;no impact on existing code&quot;. When exactly are copy constructors run? When, if ever, is the compiler allowed to elide copies? Is move optimization possible? Do you have destructors, and if so, when are they run? How and when do we know copying a shared value can be done in a thread-safe way? In addition to looking at the C++ model, I&#39;d also recommend thinking about simply allowing custom retain/release of otherwise bitwise-identical copies, or something like D&#39;s &quot;post-blit constructor&quot;, the design of which avoids some of the pitfalls of C++.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 1:03 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Introduction:<br>&gt;&gt; <br>&gt;&gt; This is a request for a copy constructor mechanism for structs in Swift.<br>&gt;&gt; <br>&gt;&gt; Motivation:<br>&gt;&gt; <br>&gt;&gt; Suppose you have a class stored inside a struct, like so:<br>&gt;&gt; <br>&gt;&gt; class C {<br>&gt;&gt; 	func copy() -&gt; C { … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt; 	var i: Int<br>&gt;&gt; 	var c: C<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; and you create a couple of the structs, like so:<br>&gt;&gt; <br>&gt;&gt; let c = C()<br>&gt;&gt; let foo = S(i: 1, c: c)<br>&gt;&gt; var bar = foo<br>&gt;&gt; bar.i = 2<br>&gt;&gt; <br>&gt;&gt; Since the ‘bar’ variable was mutated, it now contains a copy of the original ‘foo’ struct. However, both structs still carry the same pointer to ‘c&#39;. There may be cases where you would want a copy of the struct to make a copy of any reference types stored within; however, that does not seem to be possible currently.<br>&gt;&gt; <br>&gt;&gt; Proposed Solution:<br>&gt;&gt; <br>&gt;&gt; Adding a copy constructor to S that would be called when a copy of the struct is about to be made. This constructor would simply create a new instance, initialize it, and return it. The copy constructor would look like this:<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt; 	var i: Int<br>&gt;&gt; 	var c: C<br>&gt;&gt; <br>&gt;&gt; 	copy {<br>&gt;&gt; 		return S(i: self.i, c: self.c.copy())<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Structs that do not implement the copy constructor would get the same behavior as they do currently.<br>&gt;&gt; <br>&gt;&gt; Impact on Existing Code:<br>&gt;&gt; <br>&gt;&gt; There should be no impact on existing code that does not implement the copy constructor.<br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Pitch: Copy constructors for structs</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 24, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 2:18 PM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; The &quot;when exactly are copy constructors run&quot; and &quot;when is the compiler allowed to elide copies&quot; parts are very important and not always obvious in current Swift code. For instance:<br>&gt; <br>&gt;&gt; struct Point {<br>&gt;&gt; 	var x: Int<br>&gt;&gt; 	var y: Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Foo {<br>&gt;&gt; 	var point: Point<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let foo = Foo()<br>&gt;&gt; foo.point.x = 4<br>&gt; <br>&gt; This code &quot;expands&quot; to:<br>&gt; <br>&gt;&gt; var point = foo.point<br>&gt;&gt; point.x = 4<br>&gt;&gt; foo.point = point<br>&gt; <br>&gt; in which you have two copies, whereas in C++ you would have none.<br></p><p>As a point of fact, no: when the class property is actually stored, the modifications are dynamically performed in place due to the materializeForSet optimization.<br></p><p>John.<br></p><p>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 23 déc. 2015 à 16:25:50, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Currently, in most places where this is desired, we treat the reference type&#39;s interface as part of the value&#39;s interface and use copy-on-write to manage the referenced storage, as with arrays, dictionaries, and sets. Eager copying by a C++-like mechanism is interesting, and we designed the runtime with an eye toward future C++ interop, but this still has pretty massive impacts on the rest of the language and implementation that need deeper consideration than &quot;no impact on existing code&quot;. When exactly are copy constructors run? When, if ever, is the compiler allowed to elide copies? Is move optimization possible? Do you have destructors, and if so, when are they run? How and when do we know copying a shared value can be done in a thread-safe way? In addition to looking at the C++ model, I&#39;d also recommend thinking about simply allowing custom retain/release of otherwise bitwise-identical copies, or something like D&#39;s &quot;post-blit constructor&quot;, the design of which avoids some of the pitfalls of C++.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 23, 2015, at 1:03 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introduction:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a request for a copy constructor mechanism for structs in Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Suppose you have a class stored inside a struct, like so:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class C {<br>&gt;&gt;&gt; 	func copy() -&gt; C { … }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt; 	var i: Int<br>&gt;&gt;&gt; 	var c: C<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and you create a couple of the structs, like so:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let c = C()<br>&gt;&gt;&gt; let foo = S(i: 1, c: c)<br>&gt;&gt;&gt; var bar = foo<br>&gt;&gt;&gt; bar.i = 2<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since the ‘bar’ variable was mutated, it now contains a copy of the original ‘foo’ struct. However, both structs still carry the same pointer to ‘c&#39;. There may be cases where you would want a copy of the struct to make a copy of any reference types stored within; however, that does not seem to be possible currently.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed Solution:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Adding a copy constructor to S that would be called when a copy of the struct is about to be made. This constructor would simply create a new instance, initialize it, and return it. The copy constructor would look like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt; 	var i: Int<br>&gt;&gt;&gt; 	var c: C<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	copy {<br>&gt;&gt;&gt; 		return S(i: self.i, c: self.c.copy())<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Structs that do not implement the copy constructor would get the same behavior as they do currently.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on Existing Code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There should be no impact on existing code that does not implement the copy constructor.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Charles<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Pitch: Copy constructors for structs</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 24, 2015 at 04:00:00pm</p></header><div class="content"><p>At which point does that happen? The O0 SIL for it has an alloc_stack $Point in main.<br></p><p>Otherwise, that&#39;s hard-to-predict copy elision at work anyway.<br></p><p>Félix<br></p><p>&gt; Le 24 déc. 2015 à 14:40:13, John McCall &lt;rjmccall at apple.com&gt; a écrit :<br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 2:18 PM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; The &quot;when exactly are copy constructors run&quot; and &quot;when is the compiler allowed to elide copies&quot; parts are very important and not always obvious in current Swift code. For instance:<br>&gt;&gt; <br>&gt;&gt;&gt; struct Point {<br>&gt;&gt;&gt; 	var x: Int<br>&gt;&gt;&gt; 	var y: Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Foo {<br>&gt;&gt;&gt; 	var point: Point<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let foo = Foo()<br>&gt;&gt;&gt; foo.point.x = 4<br>&gt;&gt; <br>&gt;&gt; This code &quot;expands&quot; to:<br>&gt;&gt; <br>&gt;&gt;&gt; var point = foo.point<br>&gt;&gt;&gt; point.x = 4<br>&gt;&gt;&gt; foo.point = point<br>&gt;&gt; <br>&gt;&gt; in which you have two copies, whereas in C++ you would have none.<br>&gt; <br>&gt; As a point of fact, no: when the class property is actually stored, the modifications are dynamically performed in place due to the materializeForSet optimization.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 23 déc. 2015 à 16:25:50, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently, in most places where this is desired, we treat the reference type&#39;s interface as part of the value&#39;s interface and use copy-on-write to manage the referenced storage, as with arrays, dictionaries, and sets. Eager copying by a C++-like mechanism is interesting, and we designed the runtime with an eye toward future C++ interop, but this still has pretty massive impacts on the rest of the language and implementation that need deeper consideration than &quot;no impact on existing code&quot;. When exactly are copy constructors run? When, if ever, is the compiler allowed to elide copies? Is move optimization possible? Do you have destructors, and if so, when are they run? How and when do we know copying a shared value can be done in a thread-safe way? In addition to looking at the C++ model, I&#39;d also recommend thinking about simply allowing custom retain/release of otherwise bitwise-identical copies, or something like D&#39;s &quot;post-blit constructor&quot;, the design of which avoids some of the pitfalls of C++.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 23, 2015, at 1:03 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Introduction:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a request for a copy constructor mechanism for structs in Swift.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Motivation:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Suppose you have a class stored inside a struct, like so:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class C {<br>&gt;&gt;&gt;&gt; 	func copy() -&gt; C { … }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt; 	var i: Int<br>&gt;&gt;&gt;&gt; 	var c: C<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; and you create a couple of the structs, like so:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let c = C()<br>&gt;&gt;&gt;&gt; let foo = S(i: 1, c: c)<br>&gt;&gt;&gt;&gt; var bar = foo<br>&gt;&gt;&gt;&gt; bar.i = 2<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since the ‘bar’ variable was mutated, it now contains a copy of the original ‘foo’ struct. However, both structs still carry the same pointer to ‘c&#39;. There may be cases where you would want a copy of the struct to make a copy of any reference types stored within; however, that does not seem to be possible currently.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposed Solution:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Adding a copy constructor to S that would be called when a copy of the struct is about to be made. This constructor would simply create a new instance, initialize it, and return it. The copy constructor would look like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt; 	var i: Int<br>&gt;&gt;&gt;&gt; 	var c: C<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	copy {<br>&gt;&gt;&gt;&gt; 		return S(i: self.i, c: self.c.copy())<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Structs that do not implement the copy constructor would get the same behavior as they do currently.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Impact on Existing Code:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There should be no impact on existing code that does not implement the copy constructor.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151224/95c15b46/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Pitch: Copy constructors for structs</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 24, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 24, 2015, at 1:04 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; At which point does that happen? The O0 SIL for it has an alloc_stack $Point in main.<br>&gt; <br>&gt; Otherwise, that&#39;s hard-to-predict copy elision at work anyway.<br></p><p>The alloc_stack is passed into materializeForSet, but it&#39;s not required to take advantage of it. materializeForSet will either initialize the stack space with the temporary result of `get` from a computed property and return the stack address back, or leave it uninitialized and return the original physical address of a stored property.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Pitch: Copy constructors for structs</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 24, 2015 at 04:00:00pm</p></header><div class="content"><p>Oh well. I thought I had done due diligence! One less thing to be wrong about in the future.<br></p><p>Félix<br></p><p>&gt; Le 24 déc. 2015 à 16:07:25, Joe Groff &lt;jgroff at apple.com&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 24, 2015, at 1:04 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; At which point does that happen? The O0 SIL for it has an alloc_stack $Point in main.<br>&gt;&gt; <br>&gt;&gt; Otherwise, that&#39;s hard-to-predict copy elision at work anyway.<br>&gt; <br>&gt; The alloc_stack is passed into materializeForSet, but it&#39;s not required to take advantage of it. materializeForSet will either initialize the stack space with the temporary result of `get` from a computed property and return the stack address back, or leave it uninitialized and return the original physical address of a stored property.<br>&gt; <br>&gt; -Joe<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
