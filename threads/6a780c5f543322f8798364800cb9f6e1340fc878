<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e828f637e91f7d986b7a79574dc0c45a?s=50"></div><header><strong>Proposal: named invariants for variable declarations</strong> from <string>Amir Michail</string> &lt;a.michail at me.com&gt;<p>January  4, 2016 at 12:00:00pm</p></header><div class="content"><p>Examples:<br></p><p>invariant vectorIndex(v:Int) { return 0..&lt;3 ~= v }<br></p><p>var i:Int,vectorIndex: = 2<br>i = 3 // run-time error<br></p><p>invariant positive(v:Int) { return v &gt; 0 }<br>invariant odd(v:Int) { return v % 2 == 1 }<br></p><p>var x:Int, positive, odd = 5<br></p><p>x = 2 // run-time error<br></p><p>func f(z:Int, positive, odd) {<br>…<br>}<br></p><p>f(-3) // run-time error<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Proposal: named invariants for variable declarations</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January  5, 2016 at 07:00:00am</p></header><div class="content"><p>Alternatively the Properties Behaviour syntax proposal could be applied to any declaration, assuming that it is accepted. <br></p><p><br>&gt; On 5 Jan 2016, at 4:18 AM, Amir Michail via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Examples:<br>&gt; <br>&gt; invariant vectorIndex(v:Int) { return 0..&lt;3 ~= v }<br>&gt; <br>&gt; var i:Int,vectorIndex: = 2<br>&gt; i = 3 // run-time error<br>&gt; <br>&gt; invariant positive(v:Int) { return v &gt; 0 }<br>&gt; invariant odd(v:Int) { return v % 2 == 1 }<br>&gt; <br>&gt; var x:Int, positive, odd = 5<br>&gt; <br>&gt; x = 2 // run-time error<br>&gt; <br>&gt; func f(z:Int, positive, odd) {<br>&gt; …<br>&gt; }<br>&gt; <br>&gt; f(-3) // run-time error<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e5b8fa5e4f9e527ea335031bf2ec9a03?s=50"></div><header><strong>Proposal: named invariants for variable declarations</strong> from <string>Árpád Goretity</string> &lt;arpad.goretity at gmail.com&gt;<p>January  5, 2016 at 07:00:00am</p></header><div class="content"><p>This suspiciously starts to resemble a mixture of dependent types and explicit contracts (something like the Midori variant of C#).<br></p><p>By the way, while we are at it: if the compiler supports this kind of feature, we could (and should) statically check most of the constraints. Accordingly, in your example, f(-3) would be a compiler error (the two pure invariants applied to the constant argument would both trivially constant-fold to false).<br></p><p>Sent from my iPhone<br></p><p>&gt; On 04 Jan 2016, at 21:33, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; Alternatively the Properties Behaviour syntax proposal could be applied to any declaration, assuming that it is accepted. <br>&gt; <br>&gt; <br>&gt;&gt; On 5 Jan 2016, at 4:18 AM, Amir Michail via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Examples:<br>&gt;&gt; <br>&gt;&gt; invariant vectorIndex(v:Int) { return 0..&lt;3 ~= v }<br>&gt;&gt; <br>&gt;&gt; var i:Int,vectorIndex: = 2<br>&gt;&gt; i = 3 // run-time error<br>&gt;&gt; <br>&gt;&gt; invariant positive(v:Int) { return v &gt; 0 }<br>&gt;&gt; invariant odd(v:Int) { return v % 2 == 1 }<br>&gt;&gt; <br>&gt;&gt; var x:Int, positive, odd = 5<br>&gt;&gt; <br>&gt;&gt; x = 2 // run-time error<br>&gt;&gt; <br>&gt;&gt; func f(z:Int, positive, odd) {<br>&gt;&gt; …<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; f(-3) // run-time error<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8da0cba30fa0e47cf4fb26ebb968e552?s=50"></div><header><strong>Proposal: named invariants for variable declarations</strong> from <string>Jérôme Duquennoy</string> &lt;jerome+swift at duquennoy.fr&gt;<p>January  7, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi everyone<br></p><p>There are multiple discussions ongoing related to typing currently.<br>Two other discussions that are related are :<br>- Support for newtype feature/typesafe calculations<br>- Type Safe Algorithms<br></p><p>I also have the feeling all those discussions are moving toward a more advanced typing system, with things such as type hierarchy, and contracts.<br>One such system I have worked with is implemented the Ada language (a language that also emphasise on making code secure).<br>In that language, you have the possibility to build a full hierarchy of types and subtypes. For exemple, by default, there is a Natural type, that is a subtype of Integer, that can only receive values &gt;= 0. There is another subtype called Positive, that can only receive values &gt; 0.<br>Ada has plenty of possibilities that can be great thanks to that typing system. For exemple:<br>- there is a notion of compatibility between types and subtypes, which enable such things as declaring a “NumberOfMelons” type and a “NumberOfApples” type, and have the compiler warn you that you cannot add melons and apple when you try to do such operations.<br>- it makes it possible to declare mod types, with values that will cycle between two values<br>- it makes it possible to request a float type that will provide a given precision on a range of values (no need for the dev to think “should I use a double or would a simple float be enough ?”<br>- ...<br></p><p>Type invariants and subtypes predicates were added in Ada 2012 (see https://books.google.fr/books?id=req3AwAAQBAJ&amp;pg=PA399&amp;lpg=PA399&amp;dq=ada+type+invariants&amp;source=bl&amp;ots=5pinYE9PSc&amp;sig=aKeNIEfsG0r2xeiNBOcPoEkvERw&amp;hl=fr&amp;sa=X&amp;sqi=2&amp;ved=0ahUKEwjVxd6g_pfKAhWH1xQKHZh6BroQ6AEIXjAI).<br>There is an explanation of the Ada typing system here : https://en.wikibooks.org/wiki/Ada_Programming/Type_System<br></p><p>The system is pretty complex (maybe a bit too much sometimes), but maybe it could be a great source of inspiration for a big evolution toward a typing system that would be even more robust that Swift’s current one.<br>That might address all three discussions (this one, and the two other ones, listed at the beginning of this message).<br>I haven’t thought a lot about that, and it is probably beyong my current skills to design a typing system. So i’m just throwing some vague ideas here. But I definitely find that topic very interesting : Swift’s orientation toward code safety is super appealing to me, if we can take it one step further with an evolution of the typing system, I’m all for it :-).<br></p><p>What do you think guys ?<br></p><p>Jerome<br></p><p><br>&gt; On 05 Jan 2016, at 07:20, Árpád Goretity via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This suspiciously starts to resemble a mixture of dependent types and explicit contracts (something like the Midori variant of C#).<br>&gt; <br>&gt; By the way, while we are at it: if the compiler supports this kind of feature, we could (and should) statically check most of the constraints. Accordingly, in your example, f(-3) would be a compiler error (the two pure invariants applied to the constant argument would both trivially constant-fold to false).<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 04 Jan 2016, at 21:33, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Alternatively the Properties Behaviour syntax proposal could be applied to any declaration, assuming that it is accepted. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 5 Jan 2016, at 4:18 AM, Amir Michail via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Examples:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; invariant vectorIndex(v:Int) { return 0..&lt;3 ~= v }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var i:Int,vectorIndex: = 2<br>&gt;&gt;&gt; i = 3 // run-time error<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; invariant positive(v:Int) { return v &gt; 0 }<br>&gt;&gt;&gt; invariant odd(v:Int) { return v % 2 == 1 }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var x:Int, positive, odd = 5<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; x = 2 // run-time error<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func f(z:Int, positive, odd) {<br>&gt;&gt;&gt; …<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; f(-3) // run-time error<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/1a4272b6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: named invariants for variable declarations</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  7, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 9:32 AM, Jérôme Duquennoy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi everyone<br>&gt; <br>&gt; There are multiple discussions ongoing related to typing currently.<br>&gt; Two other discussions that are related are :<br>&gt; - Support for newtype feature/typesafe calculations<br>&gt; - Type Safe Algorithms<br>&gt; <br>&gt; I also have the feeling all those discussions are moving toward a more advanced typing system, with things such as type hierarchy, and contracts.<br>&gt; One such system I have worked with is implemented the Ada language (a language that also emphasise on making code secure).<br>&gt; In that language, you have the possibility to build a full hierarchy of types and subtypes. For exemple, by default, there is a Natural type, that is a subtype of Integer, that can only receive values &gt;= 0. There is another subtype called Positive, that can only receive values &gt; 0.<br>&gt; Ada has plenty of possibilities that can be great thanks to that typing system. For exemple:<br>&gt; - there is a notion of compatibility between types and subtypes, which enable such things as declaring a “NumberOfMelons” type and a “NumberOfApples” type, and have the compiler warn you that you cannot add melons and apple when you try to do such operations.<br>&gt; - it makes it possible to declare mod types, with values that will cycle between two values<br>&gt; - it makes it possible to request a float type that will provide a given precision on a range of values (no need for the dev to think “should I use a double or would a simple float be enough ?”<br>&gt; - ...<br>&gt; <br>&gt; Type invariants and subtypes predicates were added in Ada 2012 (see https://books.google.fr/books?id=req3AwAAQBAJ&amp;pg=PA399&amp;lpg=PA399&amp;dq=ada+type+invariants&amp;source=bl&amp;ots=5pinYE9PSc&amp;sig=aKeNIEfsG0r2xeiNBOcPoEkvERw&amp;hl=fr&amp;sa=X&amp;sqi=2&amp;ved=0ahUKEwjVxd6g_pfKAhWH1xQKHZh6BroQ6AEIXjAI &lt;https://books.google.fr/books?id=req3AwAAQBAJ&amp;pg=PA399&amp;lpg=PA399&amp;dq=ada+type+invariants&amp;source=bl&amp;ots=5pinYE9PSc&amp;sig=aKeNIEfsG0r2xeiNBOcPoEkvERw&amp;hl=fr&amp;sa=X&amp;sqi=2&amp;ved=0ahUKEwjVxd6g_pfKAhWH1xQKHZh6BroQ6AEIXjAI&gt;).<br>&gt; There is an explanation of the Ada typing system here : https://en.wikibooks.org/wiki/Ada_Programming/Type_System &lt;https://en.wikibooks.org/wiki/Ada_Programming/Type_System&gt;<br>&gt; <br>&gt; The system is pretty complex (maybe a bit too much sometimes), but maybe it could be a great source of inspiration for a big evolution toward a typing system that would be even more robust that Swift’s current one.<br>&gt; That might address all three discussions (this one, and the two other ones, listed at the beginning of this message).<br>&gt; I haven’t thought a lot about that, and it is probably beyong my current skills to design a typing system. So i’m just throwing some vague ideas here. But I definitely find that topic very interesting : Swift’s orientation toward code safety is super appealing to me, if we can take it one step further with an evolution of the typing system, I’m all for it :-).<br>&gt; <br>&gt; What do you think guys ?<br></p><p>I don’t know Ada so I won’t comment on that part.<br></p><p>As far as type system enhancements go, refinement types look very interesting as a possible direction supporting the kind of thing discussed in this thread.  I don’t expect enhancements like this will be considered any time soon though.<br></p><p>&gt; <br>&gt; Jerome<br>&gt; <br>&gt; <br>&gt;&gt; On 05 Jan 2016, at 07:20, Árpád Goretity via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This suspiciously starts to resemble a mixture of dependent types and explicit contracts (something like the Midori variant of C#).<br>&gt;&gt; <br>&gt;&gt; By the way, while we are at it: if the compiler supports this kind of feature, we could (and should) statically check most of the constraints. Accordingly, in your example, f(-3) would be a compiler error (the two pure invariants applied to the constant argument would both trivially constant-fold to false).<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On 04 Jan 2016, at 21:33, Howard Lovatt &lt;howard.lovatt at gmail.com &lt;mailto:howard.lovatt at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatively the Properties Behaviour syntax proposal could be applied to any declaration, assuming that it is accepted. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 5 Jan 2016, at 4:18 AM, Amir Michail via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Examples:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; invariant vectorIndex(v:Int) { return 0..&lt;3 ~= v }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var i:Int,vectorIndex: = 2<br>&gt;&gt;&gt;&gt; i = 3 // run-time error<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; invariant positive(v:Int) { return v &gt; 0 }<br>&gt;&gt;&gt;&gt; invariant odd(v:Int) { return v % 2 == 1 }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var x:Int, positive, odd = 5<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; x = 2 // run-time error<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func f(z:Int, positive, odd) {<br>&gt;&gt;&gt;&gt; …<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; f(-3) // run-time error<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/e25d1c10/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec8a60462a511e833c5c4a83b424c958?s=50"></div><header><strong>Proposal: named invariants for variable declarations</strong> from <string>Dennis Weissmann</string> &lt;dennis at dennisweissmann.me&gt;<p>January  8, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; As far as type system enhancements go, refinement types look very interesting as a possible direction supporting the kind of thing discussed in this thread.  I don’t expect enhancements like this will be considered any time soon though.<br></p><p>So do I. Refinement types are very interesting and promising (I have a radar open on that) and I think that powerful type systems are the future.<br></p><p>However, what do you (all) think about going one step further and introducing dependent types (Disclaimer: I’m not at all an expert on dependent types - just learning Idris right now.)?<br></p><p>“Dependent types” basically means that types are first-class citizens (i.e. they can be passed as arguments, returned from functions and be used and manipulated just like values) and can be computed from (or be dependent on) a value.<br></p><p>This allows (e.g.) for<br>making sure you’re not accessing an array’s element that is out of bounds (without runtime checks)<br>validating that a string conforms to a specific DSL (e.g. Regular expressions, Autolayout, printf-like strings [e.g. NSLocalizedString])<br>calculate types of functions (e.g. the number and type of it’s arguments, the return type) based on one or more values<br>formally proving a program (or a function) correct<br>And all this happens at compile time!<br></p><p>Just like refinement types they can be used where you *want* (or need) them (data model, etc.) but you don’t have to use them (e.g. UI).<br></p><p>This is not (if at all) gonna happen anytime soon but maybe it’s worth discussing this change now (at least superficially) as it touches upon some of the discussions in other threads, too. In addition to that, I have no idea whether or not dependent types (or refinement types for that matter) have an implication on the language ABI which will be finalized later this year - so maybe we need to discuss a bit of this now to make sure nothing prevents it from being implemented in the future.<br></p><p>- Dennis<br></p><p>&gt; On Jan 7, 2016, at 7:31 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 7, 2016, at 9:32 AM, Jérôme Duquennoy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi everyone<br>&gt;&gt; <br>&gt;&gt; There are multiple discussions ongoing related to typing currently.<br>&gt;&gt; Two other discussions that are related are :<br>&gt;&gt; - Support for newtype feature/typesafe calculations<br>&gt;&gt; - Type Safe Algorithms<br>&gt;&gt; <br>&gt;&gt; I also have the feeling all those discussions are moving toward a more advanced typing system, with things such as type hierarchy, and contracts.<br>&gt;&gt; One such system I have worked with is implemented the Ada language (a language that also emphasise on making code secure).<br>&gt;&gt; In that language, you have the possibility to build a full hierarchy of types and subtypes. For exemple, by default, there is a Natural type, that is a subtype of Integer, that can only receive values &gt;= 0. There is another subtype called Positive, that can only receive values &gt; 0.<br>&gt;&gt; Ada has plenty of possibilities that can be great thanks to that typing system. For exemple:<br>&gt;&gt; - there is a notion of compatibility between types and subtypes, which enable such things as declaring a “NumberOfMelons” type and a “NumberOfApples” type, and have the compiler warn you that you cannot add melons and apple when you try to do such operations.<br>&gt;&gt; - it makes it possible to declare mod types, with values that will cycle between two values<br>&gt;&gt; - it makes it possible to request a float type that will provide a given precision on a range of values (no need for the dev to think “should I use a double or would a simple float be enough ?”<br>&gt;&gt; - ...<br>&gt;&gt; <br>&gt;&gt; Type invariants and subtypes predicates were added in Ada 2012 (see https://books.google.fr/books?id=req3AwAAQBAJ&amp;pg=PA399&amp;lpg=PA399&amp;dq=ada+type+invariants&amp;source=bl&amp;ots=5pinYE9PSc&amp;sig=aKeNIEfsG0r2xeiNBOcPoEkvERw&amp;hl=fr&amp;sa=X&amp;sqi=2&amp;ved=0ahUKEwjVxd6g_pfKAhWH1xQKHZh6BroQ6AEIXjAI &lt;https://books.google.fr/books?id=req3AwAAQBAJ&amp;pg=PA399&amp;lpg=PA399&amp;dq=ada+type+invariants&amp;source=bl&amp;ots=5pinYE9PSc&amp;sig=aKeNIEfsG0r2xeiNBOcPoEkvERw&amp;hl=fr&amp;sa=X&amp;sqi=2&amp;ved=0ahUKEwjVxd6g_pfKAhWH1xQKHZh6BroQ6AEIXjAI&gt;).<br>&gt;&gt; There is an explanation of the Ada typing system here : https://en.wikibooks.org/wiki/Ada_Programming/Type_System &lt;https://en.wikibooks.org/wiki/Ada_Programming/Type_System&gt;<br>&gt;&gt; <br>&gt;&gt; The system is pretty complex (maybe a bit too much sometimes), but maybe it could be a great source of inspiration for a big evolution toward a typing system that would be even more robust that Swift’s current one.<br>&gt;&gt; That might address all three discussions (this one, and the two other ones, listed at the beginning of this message).<br>&gt;&gt; I haven’t thought a lot about that, and it is probably beyong my current skills to design a typing system. So i’m just throwing some vague ideas here. But I definitely find that topic very interesting : Swift’s orientation toward code safety is super appealing to me, if we can take it one step further with an evolution of the typing system, I’m all for it :-).<br>&gt;&gt; <br>&gt;&gt; What do you think guys ?<br>&gt; <br>&gt; I don’t know Ada so I won’t comment on that part.<br>&gt; <br>&gt; As far as type system enhancements go, refinement types look very interesting as a possible direction supporting the kind of thing discussed in this thread.  I don’t expect enhancements like this will be considered any time soon though.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Jerome<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 05 Jan 2016, at 07:20, Árpád Goretity via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This suspiciously starts to resemble a mixture of dependent types and explicit contracts (something like the Midori variant of C#).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; By the way, while we are at it: if the compiler supports this kind of feature, we could (and should) statically check most of the constraints. Accordingly, in your example, f(-3) would be a compiler error (the two pure invariants applied to the constant argument would both trivially constant-fold to false).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 04 Jan 2016, at 21:33, Howard Lovatt &lt;howard.lovatt at gmail.com &lt;mailto:howard.lovatt at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternatively the Properties Behaviour syntax proposal could be applied to any declaration, assuming that it is accepted. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 5 Jan 2016, at 4:18 AM, Amir Michail via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Examples:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; invariant vectorIndex(v:Int) { return 0..&lt;3 ~= v }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; var i:Int,vectorIndex: = 2<br>&gt;&gt;&gt;&gt;&gt; i = 3 // run-time error<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; invariant positive(v:Int) { return v &gt; 0 }<br>&gt;&gt;&gt;&gt;&gt; invariant odd(v:Int) { return v % 2 == 1 }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; var x:Int, positive, odd = 5<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; x = 2 // run-time error<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func f(z:Int, positive, odd) {<br>&gt;&gt;&gt;&gt;&gt; …<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; f(-3) // run-time error<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/a1fe2fb3/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: named invariants for variable declarations</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  8, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 11:16 AM, Dennis Weissmann &lt;dennis at dennisweissmann.me&gt; wrote:<br>&gt; <br>&gt;&gt; As far as type system enhancements go, refinement types look very interesting as a possible direction supporting the kind of thing discussed in this thread.  I don’t expect enhancements like this will be considered any time soon though.<br>&gt; <br>&gt; So do I. Refinement types are very interesting and promising (I have a radar open on that) and I think that powerful type systems are the future.<br>&gt; <br>&gt; However, what do you (all) think about going one step further and introducing dependent types (Disclaimer: I’m not at all an expert on dependent types - just learning Idris right now.)?<br>&gt; <br>&gt; “Dependent types” basically means that types are first-class citizens (i.e. they can be passed as arguments, returned from functions and be used and manipulated just like values) and can be computed from (or be dependent on) a value.<br></p><p>Dependent types are interesting, but add a lot of complexity to the programmer model.  The most interesting thing about refinement types is that they can achieve many of the same safety guarantees as dependent types, but with a much simpler programmer model.  <br></p><p>The good news is that they are not mutually exclusive.<br></p><p>&gt; <br>&gt; This allows (e.g.) for<br>&gt; making sure you’re not accessing an array’s element that is out of bounds (without runtime checks)<br>I’m pretty sure refinement types can do this, at least in many cases.  I’m not sure about the rest of your list.<br></p><p>&gt; validating that a string conforms to a specific DSL (e.g. Regular expressions, Autolayout, printf-like strings [e.g. NSLocalizedString])<br>&gt; calculate types of functions (e.g. the number and type of it’s arguments, the return type) based on one or more values<br>&gt; formally proving a program (or a function) correct<br>&gt; And all this happens at compile time!<br>&gt; <br>&gt; Just like refinement types they can be used where you *want* (or need) them (data model, etc.) but you don’t have to use them (e.g. UI).<br>&gt; <br>&gt; This is not (if at all) gonna happen anytime soon but maybe it’s worth discussing this change now (at least superficially) as it touches upon some of the discussions in other threads, too. In addition to that, I have no idea whether or not dependent types (or refinement types for that matter) have an implication on the language ABI which will be finalized later this year - so maybe we need to discuss a bit of this now to make sure nothing prevents it from being implemented in the future.<br>&gt; <br>&gt; - Dennis<br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 7:31 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 7, 2016, at 9:32 AM, Jérôme Duquennoy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi everyone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are multiple discussions ongoing related to typing currently.<br>&gt;&gt;&gt; Two other discussions that are related are :<br>&gt;&gt;&gt; - Support for newtype feature/typesafe calculations<br>&gt;&gt;&gt; - Type Safe Algorithms<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I also have the feeling all those discussions are moving toward a more advanced typing system, with things such as type hierarchy, and contracts.<br>&gt;&gt;&gt; One such system I have worked with is implemented the Ada language (a language that also emphasise on making code secure).<br>&gt;&gt;&gt; In that language, you have the possibility to build a full hierarchy of types and subtypes. For exemple, by default, there is a Natural type, that is a subtype of Integer, that can only receive values &gt;= 0. There is another subtype called Positive, that can only receive values &gt; 0.<br>&gt;&gt;&gt; Ada has plenty of possibilities that can be great thanks to that typing system. For exemple:<br>&gt;&gt;&gt; - there is a notion of compatibility between types and subtypes, which enable such things as declaring a “NumberOfMelons” type and a “NumberOfApples” type, and have the compiler warn you that you cannot add melons and apple when you try to do such operations.<br>&gt;&gt;&gt; - it makes it possible to declare mod types, with values that will cycle between two values<br>&gt;&gt;&gt; - it makes it possible to request a float type that will provide a given precision on a range of values (no need for the dev to think “should I use a double or would a simple float be enough ?”<br>&gt;&gt;&gt; - ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Type invariants and subtypes predicates were added in Ada 2012 (see https://books.google.fr/books?id=req3AwAAQBAJ&amp;pg=PA399&amp;lpg=PA399&amp;dq=ada+type+invariants&amp;source=bl&amp;ots=5pinYE9PSc&amp;sig=aKeNIEfsG0r2xeiNBOcPoEkvERw&amp;hl=fr&amp;sa=X&amp;sqi=2&amp;ved=0ahUKEwjVxd6g_pfKAhWH1xQKHZh6BroQ6AEIXjAI &lt;https://books.google.fr/books?id=req3AwAAQBAJ&amp;pg=PA399&amp;lpg=PA399&amp;dq=ada+type+invariants&amp;source=bl&amp;ots=5pinYE9PSc&amp;sig=aKeNIEfsG0r2xeiNBOcPoEkvERw&amp;hl=fr&amp;sa=X&amp;sqi=2&amp;ved=0ahUKEwjVxd6g_pfKAhWH1xQKHZh6BroQ6AEIXjAI&gt;).<br>&gt;&gt;&gt; There is an explanation of the Ada typing system here : https://en.wikibooks.org/wiki/Ada_Programming/Type_System &lt;https://en.wikibooks.org/wiki/Ada_Programming/Type_System&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The system is pretty complex (maybe a bit too much sometimes), but maybe it could be a great source of inspiration for a big evolution toward a typing system that would be even more robust that Swift’s current one.<br>&gt;&gt;&gt; That might address all three discussions (this one, and the two other ones, listed at the beginning of this message).<br>&gt;&gt;&gt; I haven’t thought a lot about that, and it is probably beyong my current skills to design a typing system. So i’m just throwing some vague ideas here. But I definitely find that topic very interesting : Swift’s orientation toward code safety is super appealing to me, if we can take it one step further with an evolution of the typing system, I’m all for it :-).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What do you think guys ?<br>&gt;&gt; <br>&gt;&gt; I don’t know Ada so I won’t comment on that part.<br>&gt;&gt; <br>&gt;&gt; As far as type system enhancements go, refinement types look very interesting as a possible direction supporting the kind of thing discussed in this thread.  I don’t expect enhancements like this will be considered any time soon though.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jerome<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 05 Jan 2016, at 07:20, Árpád Goretity via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This suspiciously starts to resemble a mixture of dependent types and explicit contracts (something like the Midori variant of C#).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; By the way, while we are at it: if the compiler supports this kind of feature, we could (and should) statically check most of the constraints. Accordingly, in your example, f(-3) would be a compiler error (the two pure invariants applied to the constant argument would both trivially constant-fold to false).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 04 Jan 2016, at 21:33, Howard Lovatt &lt;howard.lovatt at gmail.com &lt;mailto:howard.lovatt at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Alternatively the Properties Behaviour syntax proposal could be applied to any declaration, assuming that it is accepted. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 5 Jan 2016, at 4:18 AM, Amir Michail via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Examples:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; invariant vectorIndex(v:Int) { return 0..&lt;3 ~= v }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; var i:Int,vectorIndex: = 2<br>&gt;&gt;&gt;&gt;&gt;&gt; i = 3 // run-time error<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; invariant positive(v:Int) { return v &gt; 0 }<br>&gt;&gt;&gt;&gt;&gt;&gt; invariant odd(v:Int) { return v % 2 == 1 }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; var x:Int, positive, odd = 5<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; x = 2 // run-time error<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func f(z:Int, positive, odd) {<br>&gt;&gt;&gt;&gt;&gt;&gt; …<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; f(-3) // run-time error<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/17245c62/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
