<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pitch: @autoreleasepool attribute for loops</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January  8, 2016 at 07:00:00pm</p></header><div class="content"><p>When dealing with Objective-C code, especially older code that predates ARC, much of which can be found in standard Apple frameworks such as Foundation and AppKit, one is sure to generate a lot of autoreleased objects. In cases where a lot of autoreleased objects are generated inside a loop, this can lead to excessive memory usage unless one puts the body of the loop inside an autorelease pool. Traditionally, this would have been done in Objective-C like so:<br></p><p>for id foo in bar @autoreleasepool {<br>    …<br>}<br></p><p>The Swift equivalent of this would be:<br></p><p>for foo in bar {<br>    autoreleasepool {<br>        …<br>    }<br>}<br></p><p>However, due to Swift’s “autoreleasepool” function being implemented via a closure, this introduces a new scope, causing many forms of flow control not to work. Most problematically, the ‘break’ and ‘continue’ statements no longer function, since the control flow is no longer considered to be inside a loop, but there are other consequences too, such as not being able to early-return out of the method, or throw an error. The latter issue can be solved by writing a custom version of the “autoreleasepool” function that takes a throwing closure and rethrows it, but I can’t think of any workaround for the lack of “break” and “continue” with the current system other than breaking up the loop body into lots of smaller autoreleasepool statements.<br></p><p>I propose adding an @autoreleasepool attribute that could be added to loops, like so:<br></p><p>@autoreleasepool for foo in bar {<br>	...<br>}<br></p><p>This would wrap the loop body inside an autorelease pool, without disabling the usual flow control statements.<br></p><p>What do you think?<br></p><p>Charles<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Pitch: @autoreleasepool attribute for loops</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January  8, 2016 at 10:00:00pm</p></header><div class="content"><p>I sympathize with the problem statement, but I wonder if we should instead<br>be considering ways of allowing control-flow statements (break, continue,<br>return) to work from inside @noescape closures.<br></p><p>Another possible solution would be to expose __pushAutoreleasePool() and<br>__popAutoreleasePool() as public API. This would also allow more careful<br>manual use of autorelease pools (for instance, draining the pool after<br>every 5 loop iterations, rather than every iteration).<br></p><p>Jacob<br></p><p>On Fri, Jan 8, 2016 at 5:32 PM, Charles Srstka via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; When dealing with Objective-C code, especially older code that predates<br>&gt; ARC, much of which can be found in standard Apple frameworks such as<br>&gt; Foundation and AppKit, one is sure to generate a lot of autoreleased<br>&gt; objects. In cases where a lot of autoreleased objects are generated inside<br>&gt; a loop, this can lead to excessive memory usage unless one puts the body of<br>&gt; the loop inside an autorelease pool. Traditionally, this would have been<br>&gt; done in Objective-C like so:<br>&gt;<br>&gt; for id foo in bar @autoreleasepool {<br>&gt;     …<br>&gt; }<br>&gt;<br>&gt; The Swift equivalent of this would be:<br>&gt;<br>&gt; for foo in bar {<br>&gt;     autoreleasepool {<br>&gt;         …<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; However, due to Swift’s “autoreleasepool” function being implemented via a<br>&gt; closure, this introduces a new scope, causing many forms of flow control<br>&gt; not to work. Most problematically, the ‘break’ and ‘continue’ statements no<br>&gt; longer function, since the control flow is no longer considered to be<br>&gt; inside a loop, but there are other consequences too, such as not being able<br>&gt; to early-return out of the method, or throw an error. The latter issue can<br>&gt; be solved by writing a custom version of the “autoreleasepool” function<br>&gt; that takes a throwing closure and rethrows it, but I can’t think of any<br>&gt; workaround for the lack of “break” and “continue” with the current system<br>&gt; other than breaking up the loop body into lots of smaller autoreleasepool<br>&gt; statements.<br>&gt;<br>&gt; I propose adding an @autoreleasepool attribute that could be added to<br>&gt; loops, like so:<br>&gt;<br>&gt; @autoreleasepool for foo in bar {<br>&gt;         ...<br>&gt; }<br>&gt;<br>&gt; This would wrap the loop body inside an autorelease pool, without<br>&gt; disabling the usual flow control statements.<br>&gt;<br>&gt; What do you think?<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/3ec222a9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Pitch: @autoreleasepool attribute for loops</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  9, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 10:00 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I sympathize with the problem statement, but I wonder if we should instead be considering ways of allowing control-flow statements (break, continue, return) to work from inside @noescape closures.<br></p><p>Agreed, this seems like the right path forward.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Pitch: @autoreleasepool attribute for loops</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 11, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 09.01.2016 um 19:47 schrieb Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; On Jan 8, 2016, at 10:00 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I sympathize with the problem statement, but I wonder if we should instead be considering ways of allowing control-flow statements (break, continue, return) to work from inside @noescape closures.<br>&gt; <br>&gt; Agreed, this seems like the right path forward.<br></p><p>+1<br>This would be helpful in several other cases that have come up on this list, e.g. it would allow creating new control statements with trailing closures which could offer expected behavior, e.g. a timesRepeat method instead of adding new looping syntax for that as discussed in another thread.<br>Furthermore it might allow &quot;return&quot; to be used for non-local return.<br></p><p>-Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Pitch: @autoreleasepool attribute for loops</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 11, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 11:13 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 09.01.2016 um 19:47 schrieb Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 8, 2016, at 10:00 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I sympathize with the problem statement, but I wonder if we should instead be considering ways of allowing control-flow statements (break, continue, return) to work from inside @noescape closures.<br>&gt;&gt; <br>&gt;&gt; Agreed, this seems like the right path forward.<br>&gt; <br>&gt; +1<br>&gt; This would be helpful in several other cases that have come up on this list, e.g. it would allow creating new control statements with trailing closures which could offer expected behavior, e.g. a timesRepeat method instead of adding new looping syntax for that as discussed in another thread.<br>&gt; Furthermore it might allow &quot;return&quot; to be used for non-local return.<br></p><p>+1 <br></p><p>&gt; <br>&gt; -Thorsten <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Pitch: @autoreleasepool attribute for loops</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>January  9, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 10:00 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I sympathize with the problem statement, but I wonder if we should instead be considering ways of allowing control-flow statements (break, continue, return) to work from inside @noescape closures.<br></p><p>@noescape is insufficient to allow that. You need more constraints on the closure&#39;s caller, perhaps even cooperation from the closure&#39;s caller depending on how the control flow is supposed to work.<br></p><p>Off the top of my head:<br>* The closure&#39;s caller can&#39;t call the closure more than once. Or if it does, it needs to participate in the control flow system somehow. (Example: what does `break` do in the middle of map().)<br>* Return values are complicated. You might need to limit the system to void returning closures only.<br>* Defining the closure in one place and handing it off in another is complicated. You might need to limit the system to closure literals only.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/9ab0b2f5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Pitch: @autoreleasepool attribute for loops</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 11, 2016 at 06:00:00pm</p></header><div class="content"><p>Ruby has rules for how &quot;return&quot;, &quot;next&quot; (= continue) and &quot;break&quot; behave in closures which match the expectations quite well. It allows next and break to return values, too.<br></p><p>-Thorsten <br></p><p>&gt; Am 09.01.2016 um 21:21 schrieb Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 8, 2016, at 10:00 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I sympathize with the problem statement, but I wonder if we should instead be considering ways of allowing control-flow statements (break, continue, return) to work from inside @noescape closures.<br>&gt; <br>&gt; @noescape is insufficient to allow that. You need more constraints on the closure&#39;s caller, perhaps even cooperation from the closure&#39;s caller depending on how the control flow is supposed to work.<br>&gt; <br>&gt; Off the top of my head:<br>&gt; * The closure&#39;s caller can&#39;t call the closure more than once. Or if it does, it needs to participate in the control flow system somehow. (Example: what does `break` do in the middle of map().)<br>&gt; * Return values are complicated. You might need to limit the system to void returning closures only.<br>&gt; * Defining the closure in one place and handing it off in another is complicated. You might need to limit the system to closure literals only.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/61257836/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Pitch: @autoreleasepool attribute for loops</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 11, 2016 at 06:00:00pm</p></header><div class="content"><p>Forgot to add this link describing the rules:<br>http://stackoverflow.com/questions/1402757/how-to-break-out-from-a-ruby-block<br></p><p>They are stated somewhere in Ruby&#39;s documentation as well but I don&#39;t have that link at hand right now.<br></p><p>-Thorsten <br></p><p>&gt; Am 11.01.2016 um 18:15 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Ruby has rules for how &quot;return&quot;, &quot;next&quot; (= continue) and &quot;break&quot; behave in closures which match the expectations quite well. It allows next and break to return values, too.<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt;&gt; Am 09.01.2016 um 21:21 schrieb Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 8, 2016, at 10:00 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I sympathize with the problem statement, but I wonder if we should instead be considering ways of allowing control-flow statements (break, continue, return) to work from inside @noescape closures.<br>&gt;&gt; <br>&gt;&gt; @noescape is insufficient to allow that. You need more constraints on the closure&#39;s caller, perhaps even cooperation from the closure&#39;s caller depending on how the control flow is supposed to work.<br>&gt;&gt; <br>&gt;&gt; Off the top of my head:<br>&gt;&gt; * The closure&#39;s caller can&#39;t call the closure more than once. Or if it does, it needs to participate in the control flow system somehow. (Example: what does `break` do in the middle of map().)<br>&gt;&gt; * Return values are complicated. You might need to limit the system to void returning closures only.<br>&gt;&gt; * Defining the closure in one place and handing it off in another is complicated. You might need to limit the system to closure literals only.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/f6e96a84/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Pitch: @autoreleasepool attribute for loops</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 11, 2016 at 10:00:00am</p></header><div class="content"><p>I’ve pondered proposing adding break and continue as results from a closure the same way return and ErrorType are today, and a modifier flag on function declarations similar to “throws” to indicate support. <br></p><p>The main complexity seemed to be in supporting labels (as well as when to not support them - labels would only make sense when the closure was declared inline.) Another thought was that it did not make sense for closure-level return, break, and continue to all be available at once <br></p><p>-DW<br>  <br>&gt; On Jan 9, 2016, at 1:21 PM, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 8, 2016, at 10:00 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I sympathize with the problem statement, but I wonder if we should instead be considering ways of allowing control-flow statements (break, continue, return) to work from inside @noescape closures.<br>&gt; <br>&gt; @noescape is insufficient to allow that. You need more constraints on the closure&#39;s caller, perhaps even cooperation from the closure&#39;s caller depending on how the control flow is supposed to work.<br>&gt; <br>&gt; Off the top of my head:<br>&gt; * The closure&#39;s caller can&#39;t call the closure more than once. Or if it does, it needs to participate in the control flow system somehow. (Example: what does `break` do in the middle of map().)<br>&gt; * Return values are complicated. You might need to limit the system to void returning closures only.<br>&gt; * Defining the closure in one place and handing it off in another is complicated. You might need to limit the system to closure literals only.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/27f74481/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
