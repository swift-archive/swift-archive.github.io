<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>A sample Rational number type</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>October  2, 2016 at 05:00:00pm</p></header><div class="content"><p>on Fri Sep 30 2016, Hooman Mehr &lt;swift-users-AT-swift.org&gt; wrote:<br></p><p>&gt; For anybody who is interested: This gist<br>&gt; &lt;https://gist.github.com/hooman/6e08c48e1e06ee19e06e5b09f664f9be&gt;<br>&gt; contains a Rational number implementation for Swift 3.0. It is a<br>&gt; single file that you can paste in a playground and take a look, or<br>&gt; remove the last few lines and drop the file into your own module. The<br>&gt; recommended way to create a rational number is specifying Rational<br>&gt; type as in:<br>&gt;<br>&gt; let r: Rational = 18/64<br>&gt; // or<br>&gt; let x = 5 + 2/3 as Rational<br>&gt;<br>&gt; or use tolerance operator `±` to convert from floating point:<br>&gt;<br>&gt; let r2 = 2.109±0.0005 // 2⁷⁄₆₄<br></p><p>Presumably you mean:<br></p><p>  let r2 = r±0.0005 // turn a Rational into a Double with no more than<br>                    // .0005 rounding error<br></p><p>? That is supercute!<br></p><p>&gt; Rational type conforms to AbsoluteValuable (hence Equatable,<br>&gt; Comparable, ExpressibleByIntegerLiteral, SignedNumber), Strideable,<br>&gt; and CustomStringConvertible.<br></p><p>Have you thought about what this would look like after we land<br>https://github.com/apple/swift/pull/3796 (see<br>https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md)<br>?<br></p><p>You can also find a working prototype of that code at<br>https://github.com/apple/swift/blob/b7622b41756e33bdf3f3415320ffec52aec73281/test/Prototypes/Integers.swift.gyb<br>It would be great to know that the protocols we&#39;ve designed actually<br>work out for Rational numbers.  With these protocols, can you make your<br>Rational generic on the underlying integer type?<br></p><p>There&#39;s a BigInt implementation based on these protocols here:<br>https://github.com/natecook1000/swift/commit/45c52a75dcc15024649a5e093a5da4ee031595c2<br></p><p>It would be really cool to see it work with a generic version of your<br>Rational type.<br></p><p>&gt; It always uses fully-reduced representation for simplicity and clarity<br>&gt; of comparisons and uses LCM (lowest common multiple) for addition &amp;<br>&gt; subtraction to reduce the chance of overflow in the middle of<br>&gt; computations. The disadvantage of these design choices are: It is not<br>&gt; guaranteed to keep the nominator and denominator as specified during<br>&gt; construction, and GCD / LCM computations reduce its performance.<br>&gt;<br>&gt; The performance trade-off is not huge and is usually acceptable for<br>&gt; typical rational number use cases. Preserving denominator can be<br>&gt; addressed with a number formatter for rational numbers that I will add<br>&gt; later. GCD is computed with Stein&#39;s algorithm (binary GCD algorithm).<br></p><p>It&#39;s interesting to see that one wants a different algorithm for GCD<br>when using BigInts:<br>https://en.wikipedia.org/wiki/Binary_GCD_algorithm#cite_note-11<br></p><p>I wonder how that should be dispatched...<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7e554db1f80d7d6041d92edd5145698?s=50"></div><header><strong>A sample Rational number type</strong> from <string>Hooman Mehr</string> &lt;hooman at mac.com&gt;<p>October  2, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Oct 2, 2016, at 5:23 PM, Dave Abrahams via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; Presumably you mean:<br>&gt; <br>&gt;  let r2 = r±0.0005 // turn a Rational into a Double with no more than<br>&gt;                    // .0005 rounding error<br>&gt; <br>&gt; ? That is supercute!<br>&gt; <br></p><p>It is actually the other way around: It returns a rational given a double so that the maximum difference of the created rational with the input double is the specified tolerance.<br></p><p>&gt; Have you thought about what this would look like after we land<br>&gt; https://github.com/apple/swift/pull/3796 (see<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md)<br>&gt; ?<br>&gt; <br></p><p>That is the next thing I want to look at, the next chance I get. For now, it isn’t much more than a quick hack on a slow Friday… <br></p><p>&gt; You can also find a working prototype of that code at<br>&gt; https://github.com/apple/swift/blob/b7622b41756e33bdf3f3415320ffec52aec73281/test/Prototypes/Integers.swift.gyb<br>&gt; It would be great to know that the protocols we&#39;ve designed actually<br>&gt; work out for Rational numbers.  With these protocols, can you make your<br>&gt; Rational generic on the underlying integer type?<br>&gt; <br>&gt; There&#39;s a BigInt implementation based on these protocols here:<br>&gt; https://github.com/natecook1000/swift/commit/45c52a75dcc15024649a5e093a5da4ee031595c2<br>&gt; <br>&gt; It would be really cool to see it work with a generic version of your<br>&gt; Rational type.<br></p><p>Interesting idea. A BigInt type can really lift Rational to new levels. Interesting case study to see how well the new protocols work.<br></p><p>&gt; It&#39;s interesting to see that one wants a different algorithm for GCD<br>&gt; when using BigInts:<br>&gt; https://en.wikipedia.org/wiki/Binary_GCD_algorithm#cite_note-11<br>&gt; <br>&gt; I wonder how that should be dispatched…<br></p><p>Moreover, there is something I ran into after posting: On today’s CPU architectures with fast integer divide, simple binary CGD is slower than basic Euler’s algorithm using remainders. Binary GCD needs the equivalent of __builtin_ctz to run faster. It would be nice if compiler could detect the shift loops and replace the whole loop with x86 BSFL instruction.<br></p><p>I need to put some thought on whether there is an efficient means of switching the algorithm based on the actual size (or nature) of the given Int type, otherwise we may have to specialize, which is not good from a generics standpoint.<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
