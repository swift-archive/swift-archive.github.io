<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>API Guidelines Update</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 24, 2016 at 03:00:00pm</p></header><div class="content"><p>on Wed Feb 24 2016, David Owens II &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Feb 24, 2016, at 11:25 AM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed Feb 24 2016, David Owens II &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 22, 2016, at 11:02 AM, Jordan Rose via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In case it&#39;s been lost in all the discussion, the -ing/-ed rule is<br>&gt;&gt;&gt;&gt; essentially the rule Objective-C uses, minus the noun labels for the<br>&gt;&gt;&gt;&gt; return value and types and the word &quot;by&quot;. It&#39;s definitely very<br>&gt;&gt;&gt;&gt; different grammatically from most other API guidelines, but so are<br>&gt;&gt;&gt;&gt; Objective-C&#39;s guidelines.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sure, but I&#39;d actually argue that the noun-labels in ObjC are what<br>&gt;&gt;&gt; actually provide the context of the non-mutating nature of the<br>&gt;&gt;&gt; function. <br>&gt;&gt; <br>&gt;&gt; I disagree with that assertion.  The nouns tell you what type is going<br>&gt;&gt; to be returned and what type is being passed, not whether there will be<br>&gt;&gt; mutation to the receiver.<br>&gt;<br>&gt; The noun tells you the object that will be worked with.<br>&gt;<br>&gt; `stringByTrimmingCharactersInSet(_:)` - return a string by trimming characters in set<br>&gt;<br>&gt; `trimCharactersInSet(_:)`, `trim(_:)`, and `trimming(_:)` all read:<br>&gt; return myself by trimming characters in set; there is no noun, so it<br>&gt; is implied that it&#39;s the caller of the function.<br></p><p>I disagree. The first two form imperative verb phrases, and do not imply<br>to me that anything will be returned.  Furthermore, I think for anyone<br>who works in a language with mutation it is natural to assume that<br>imperative-verb-phrase methods might mutate the receiver and return<br>nothing.  This is not a new idea; Cocoa already does things this way.<br></p><p>&gt; The first two guidelines already captures this sentiment as well:<br>&gt;<br>&gt;   1. &quot;Those without side-effects should read as noun phrases&quot;.<br>&gt;   2. &quot;Those with side-effects should read as imperative verb phrases.&quot;<br></p><p>I know what the guidelines say and what they&#39;re supposed to mean, and I<br>can&#39;t see how they support your point in any way.  Neither “trimming b”<br>nor “a trimming b” is an imperative verb phrase in English.  It is<br>always a noun phrase.<br></p><p>&gt;&gt;&gt; I think we are opening ourselves up to the potential of many confusing<br>&gt;&gt;&gt; APIs when an -ed/-ing form of a function name is an appropriate<br>&gt;&gt;&gt; candidate with the opposite meaning that the guidelines set out.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The -ed/-ing suffix choice doesn&#39;t seem outright bad, but it does seem<br>&gt;&gt;&gt; to be &quot;death by paper cuts&quot; bad, at least to me. The guidelines are<br>&gt;&gt;&gt; already a bit complicated in this area. Also, like others, I find the<br>&gt;&gt;&gt; -ing suffix to imply a state of work to be done that will be completed<br>&gt;&gt;&gt; later or cover an extended amount of time; mutation has no bearing on<br>&gt;&gt;&gt; the implementation choice here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Side note: the guidelines are also unintentionally narrow: &quot;Use the<br>&gt;&gt;&gt; “ed/ing” rule to name the nonmutating counterpart of a mutating<br>&gt;&gt;&gt; method.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We should *always* be following this pattern regardless of the<br>&gt;&gt;&gt; existence of a nonmutating counterpart. Otherwise, if you implement<br>&gt;&gt;&gt; just a non-mutating function for sorting without the counterpart, you<br>&gt;&gt;&gt; need to use a noun-phrase, like `sortBy`. Then if you later add a<br>&gt;&gt;&gt; mutating version, you need to rename the `sortBy` to `sorted`. That<br>&gt;&gt;&gt; seems like the wrong outcome of the guidelines.<br>&gt;&gt; <br>&gt;&gt; I think you&#39;re confused: `sortBy(x)`—or more properly, `sort(by:<br>&gt;&gt; x)`—isn&#39;t a noun-phrase; it&#39;s an imperative verb phrase, so it would be<br>&gt;&gt; an ineligible form for a nonmutating method call.<br>&gt;<br>&gt; I think you threw out the baby with the bathwater because of a<br>&gt; technicality there. Let&#39;s try again.<br></p><p>OK.<br></p><p>&gt; The stages of an API development process might look like this:<br>&gt;<br>&gt; version 1: &quot;Those without side-effects should read as noun phrases&quot;<br>&gt;<br>&gt; func contentsOf(filter:) -&gt; Self  // returns a copy<br>&gt;<br>&gt; version 2: &quot;Those with side-effects should read as imperative verb phrases&quot;<br>&gt;<br>&gt; func contentsOf(filter:) -&gt; Self  // returns a copy<br>&gt; mutating func filter(by:)         // honestly, I&#39;m not sure where the preposition debate has landed...<br>&gt;<br>&gt; version 3, bug comes in that the API doesn&#39;t meet the guidelines.<br>&gt;<br>&gt; func filtered(by:) -&gt; Self  // returns a copy<br>&gt; mutating func filter(by:)<br>&gt;<br>&gt; Unless I&#39;m misunderstanding the guidelines, this is the natural<br>&gt; progression of the API (minus the `by` preposition, which is<br>&gt; irrelevant to this discussion).<br>&gt;<br>&gt; In my opinion, the guidelines should not lead us down breaking API<br>&gt; changes as the API evolves. The entire -ed/-ing confuses the entire<br>&gt; section, and requires future knowledge of what the future API will<br>&gt; look like beforehand. This circles back to my first point about the<br>&gt; noun actually serving as more information that the type.<br></p><p>Yes, that&#39;s true.  You have to think ahead about API evolution if you<br>don&#39;t want to break users.  That goes for naming as well as anything<br>else.  If I said, “related APIs should form a distinguishable family,”<br>you probably wouldn&#39;t argue (would you?) but that guideline could lead<br>to exactly the same sequence of events.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>API Guidelines Update</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>February 24, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt;&gt; The noun tells you the object that will be worked with.<br>&gt;&gt; <br>&gt;&gt; `stringByTrimmingCharactersInSet(_:)` - return a string by trimming characters in set<br>&gt;&gt; <br>&gt;&gt; `trimCharactersInSet(_:)`, `trim(_:)`, and `trimming(_:)` all read:<br>&gt;&gt; return myself by trimming characters in set; there is no noun, so it<br>&gt;&gt; is implied that it&#39;s the caller of the function.<br>&gt; <br>&gt; I disagree. The first two form imperative verb phrases, and do not imply<br>&gt; to me that anything will be returned.  Furthermore, I think for anyone<br>&gt; who works in a language with mutation it is natural to assume that<br>&gt; imperative-verb-phrase methods might mutate the receiver and return<br>&gt; nothing.  This is not a new idea; Cocoa already does things this way.<br></p><p>&quot;return myself&quot; was a poor word choice; &quot;perform on myself&quot; would have been better and more accurate. <br></p><p>There are many contexts where chaining is preferred, so foo.trim().trim().filter().trim() would be a valid use case. That was the sample running in my head when I wrote that section and why I wrote &quot;return myself&quot;. <br></p><p>I also agree with you that an imperative verb phrase implies mutation, and I think that part is covered in the guidelines well.<br></p><p>&gt;&gt; The first two guidelines already captures this sentiment as well:<br>&gt;&gt; <br>&gt;&gt;  1. &quot;Those without side-effects should read as noun phrases&quot;.<br>&gt;&gt;  2. &quot;Those with side-effects should read as imperative verb phrases.&quot;<br>&gt; <br>&gt; I know what the guidelines say and what they&#39;re supposed to mean, and I<br>&gt; can&#39;t see how they support your point in any way.  Neither “trimming b”<br>&gt; nor “a trimming b” is an imperative verb phrase in English.  It is<br>&gt; always a noun phrase.<br></p><p>True, `trimming` is not an imperative verb phrase; strike it from my example list.<br></p><p>&gt; Yes, that&#39;s true.  You have to think ahead about API evolution if you<br>&gt; don&#39;t want to break users.  That goes for naming as well as anything<br>&gt; else.  If I said, “related APIs should form a distinguishable family,”<br>&gt; you probably wouldn&#39;t argue (would you?) but that guideline could lead<br>&gt; to exactly the same sequence of events.<br></p><p>Maybe, but I don&#39;t necessarily think that grouping mutable and non-mutable into the same family is the right approach. <br></p><p>-David<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47e3aeeaf151d4f51ee15fc7871bf584?s=50"></div><header><strong>API Guidelines Update</strong> from <string>Rudolf Adamkovič</string> &lt;salutis at me.com&gt;<p>February 25, 2016 at 06:00:00pm</p></header><div class="content"><p>Is there a reason we can’t use the type system to do the work for us? So, instead of:<br></p><p>A.trim(B)<br>A.trimming(B)<br></p><p>… we would have:<br></p><p>A.trim(B)<br>A.trim(B) -&gt; A<br></p><p>In cases like “dropFirst” where the function returns something, we would use an “out” parameter:<br></p><p>A.dropFirst(B)<br>A.dropFirst(B, out: X)<br></p><p>In this case X is the dropped element.<br></p><p>So, this approach would require implementing “out” parameters (in addition to “inout” we have today).<br></p><p>I’m no expert and I’m probably missing something here. Is there additional ambiguity I’m not aware of?<br></p><p>R+<br></p><p>&gt; On 25 Feb 2016, at 02:10, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; The noun tells you the object that will be worked with.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `stringByTrimmingCharactersInSet(_:)` - return a string by trimming characters in set<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `trimCharactersInSet(_:)`, `trim(_:)`, and `trimming(_:)` all read:<br>&gt;&gt;&gt; return myself by trimming characters in set; there is no noun, so it<br>&gt;&gt;&gt; is implied that it&#39;s the caller of the function.<br>&gt;&gt; <br>&gt;&gt; I disagree. The first two form imperative verb phrases, and do not imply<br>&gt;&gt; to me that anything will be returned.  Furthermore, I think for anyone<br>&gt;&gt; who works in a language with mutation it is natural to assume that<br>&gt;&gt; imperative-verb-phrase methods might mutate the receiver and return<br>&gt;&gt; nothing.  This is not a new idea; Cocoa already does things this way.<br>&gt; <br>&gt; &quot;return myself&quot; was a poor word choice; &quot;perform on myself&quot; would have been better and more accurate. <br>&gt; <br>&gt; There are many contexts where chaining is preferred, so foo.trim().trim().filter().trim() would be a valid use case. That was the sample running in my head when I wrote that section and why I wrote &quot;return myself&quot;. <br>&gt; <br>&gt; I also agree with you that an imperative verb phrase implies mutation, and I think that part is covered in the guidelines well.<br>&gt; <br>&gt;&gt;&gt; The first two guidelines already captures this sentiment as well:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. &quot;Those without side-effects should read as noun phrases&quot;.<br>&gt;&gt;&gt; 2. &quot;Those with side-effects should read as imperative verb phrases.&quot;<br>&gt;&gt; <br>&gt;&gt; I know what the guidelines say and what they&#39;re supposed to mean, and I<br>&gt;&gt; can&#39;t see how they support your point in any way.  Neither “trimming b”<br>&gt;&gt; nor “a trimming b” is an imperative verb phrase in English.  It is<br>&gt;&gt; always a noun phrase.<br>&gt; <br>&gt; True, `trimming` is not an imperative verb phrase; strike it from my example list.<br>&gt; <br>&gt;&gt; Yes, that&#39;s true.  You have to think ahead about API evolution if you<br>&gt;&gt; don&#39;t want to break users.  That goes for naming as well as anything<br>&gt;&gt; else.  If I said, “related APIs should form a distinguishable family,”<br>&gt;&gt; you probably wouldn&#39;t argue (would you?) but that guideline could lead<br>&gt;&gt; to exactly the same sequence of events.<br>&gt; <br>&gt; Maybe, but I don&#39;t necessarily think that grouping mutable and non-mutable into the same family is the right approach. <br>&gt; <br>&gt; -David<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>API Guidelines Update</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 25, 2016 at 09:00:00am</p></header><div class="content"><p>on Thu Feb 25 2016, Rudolf Adamkovič &lt;salutis-AT-me.com&gt; wrote:<br></p><p>&gt; Is there a reason we can’t use the type system to do the work for us? So, instead of:<br>&gt;<br>&gt; A.trim(B)<br>&gt; A.trimming(B)<br>&gt;<br>&gt; … we would have:<br>&gt;<br>&gt; A.trim(B)<br>&gt; A.trim(B) -&gt; A<br>&gt;<br>&gt; In cases like “dropFirst” where the function returns something, we would use an “out” parameter:<br>&gt;<br>&gt; A.dropFirst(B)<br>&gt; A.dropFirst(B, out: X)<br>&gt;<br>&gt; In this case X is the dropped element.<br>&gt;<br>&gt; So, this approach would require implementing “out” parameters (in addition to “inout” we have today).<br>&gt;<br>&gt; I’m no expert and I’m probably missing something here. Is there additional ambiguity I’m not aware of?<br></p><p>Hi Rudolf,<br></p><p>This possibility has been discussed in earlier threads.  I suggest<br>you read those, then ask again if you still have questions.<br></p><p>Thanks!<br></p><p>&gt; R+<br>&gt;<br>&gt;&gt; On 25 Feb 2016, at 02:10, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; The noun tells you the object that will be worked with.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `stringByTrimmingCharactersInSet(_:)` - return a string by trimming characters in set<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `trimCharactersInSet(_:)`, `trim(_:)`, and `trimming(_:)` all read:<br>&gt;&gt;&gt;&gt; return myself by trimming characters in set; there is no noun, so it<br>&gt;&gt;&gt;&gt; is implied that it&#39;s the caller of the function.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I disagree. The first two form imperative verb phrases, and do not imply<br>&gt;&gt;&gt; to me that anything will be returned.  Furthermore, I think for anyone<br>&gt;&gt;&gt; who works in a language with mutation it is natural to assume that<br>&gt;&gt;&gt; imperative-verb-phrase methods might mutate the receiver and return<br>&gt;&gt;&gt; nothing.  This is not a new idea; Cocoa already does things this way.<br>&gt;&gt; <br>&gt;&gt; &quot;return myself&quot; was a poor word choice; &quot;perform on myself&quot; would have been better and more accurate. <br>&gt;&gt; <br>&gt;&gt; There are many contexts where chaining is preferred, so<br>&gt;&gt; foo.trim().trim().filter().trim() would be a valid use case. That<br>&gt;&gt; was the sample running in my head when I wrote that section and why<br>&gt;&gt; I wrote &quot;return myself&quot;.<br>&gt;&gt; <br>&gt;&gt; I also agree with you that an imperative verb phrase implies<br>&gt;&gt; mutation, and I think that part is covered in the guidelines well.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; The first two guidelines already captures this sentiment as well:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. &quot;Those without side-effects should read as noun phrases&quot;.<br>&gt;&gt;&gt;&gt; 2. &quot;Those with side-effects should read as imperative verb phrases.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I know what the guidelines say and what they&#39;re supposed to mean, and I<br>&gt;&gt;&gt; can&#39;t see how they support your point in any way.  Neither “trimming b”<br>&gt;&gt;&gt; nor “a trimming b” is an imperative verb phrase in English.  It is<br>&gt;&gt;&gt; always a noun phrase.<br>&gt;&gt; <br>&gt;&gt; True, `trimming` is not an imperative verb phrase; strike it from my example list.<br>&gt;&gt; <br>&gt;&gt;&gt; Yes, that&#39;s true.  You have to think ahead about API evolution if you<br>&gt;&gt;&gt; don&#39;t want to break users.  That goes for naming as well as anything<br>&gt;&gt;&gt; else.  If I said, “related APIs should form a distinguishable family,”<br>&gt;&gt;&gt; you probably wouldn&#39;t argue (would you?) but that guideline could lead<br>&gt;&gt;&gt; to exactly the same sequence of events.<br>&gt;&gt; <br>&gt;&gt; Maybe, but I don&#39;t necessarily think that grouping mutable and<br>&gt;&gt; non-mutable into the same family is the right approach.<br>&gt;&gt; <br>&gt;&gt; -David<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47e3aeeaf151d4f51ee15fc7871bf584?s=50"></div><header><strong>API Guidelines Update</strong> from <string>Rudolf Adamkovič</string> &lt;salutis at me.com&gt;<p>February 25, 2016 at 07:00:00pm</p></header><div class="content"><p>Oh, all right then.<br></p><p>R+<br></p><p>Sent from my iPhone<br></p><p>&gt; On 25 Feb 2016, at 18:17, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; on Thu Feb 25 2016, Rudolf Adamkovič &lt;salutis-AT-me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Is there a reason we can’t use the type system to do the work for us? So, instead of:<br>&gt;&gt; <br>&gt;&gt; A.trim(B)<br>&gt;&gt; A.trimming(B)<br>&gt;&gt; <br>&gt;&gt; … we would have:<br>&gt;&gt; <br>&gt;&gt; A.trim(B)<br>&gt;&gt; A.trim(B) -&gt; A<br>&gt;&gt; <br>&gt;&gt; In cases like “dropFirst” where the function returns something, we would use an “out” parameter:<br>&gt;&gt; <br>&gt;&gt; A.dropFirst(B)<br>&gt;&gt; A.dropFirst(B, out: X)<br>&gt;&gt; <br>&gt;&gt; In this case X is the dropped element.<br>&gt;&gt; <br>&gt;&gt; So, this approach would require implementing “out” parameters (in addition to “inout” we have today).<br>&gt;&gt; <br>&gt;&gt; I’m no expert and I’m probably missing something here. Is there additional ambiguity I’m not aware of?<br>&gt; <br>&gt; Hi Rudolf,<br>&gt; <br>&gt; This possibility has been discussed in earlier threads.  I suggest<br>&gt; you read those, then ask again if you still have questions.<br>&gt; <br>&gt; Thanks!<br>&gt; <br>&gt;&gt; R+<br>&gt;&gt; <br>&gt;&gt;&gt; On 25 Feb 2016, at 02:10, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The noun tells you the object that will be worked with.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; `stringByTrimmingCharactersInSet(_:)` - return a string by trimming characters in set<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; `trimCharactersInSet(_:)`, `trim(_:)`, and `trimming(_:)` all read:<br>&gt;&gt;&gt;&gt;&gt; return myself by trimming characters in set; there is no noun, so it<br>&gt;&gt;&gt;&gt;&gt; is implied that it&#39;s the caller of the function.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I disagree. The first two form imperative verb phrases, and do not imply<br>&gt;&gt;&gt;&gt; to me that anything will be returned.  Furthermore, I think for anyone<br>&gt;&gt;&gt;&gt; who works in a language with mutation it is natural to assume that<br>&gt;&gt;&gt;&gt; imperative-verb-phrase methods might mutate the receiver and return<br>&gt;&gt;&gt;&gt; nothing.  This is not a new idea; Cocoa already does things this way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;return myself&quot; was a poor word choice; &quot;perform on myself&quot; would have been better and more accurate. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are many contexts where chaining is preferred, so<br>&gt;&gt;&gt; foo.trim().trim().filter().trim() would be a valid use case. That<br>&gt;&gt;&gt; was the sample running in my head when I wrote that section and why<br>&gt;&gt;&gt; I wrote &quot;return myself&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I also agree with you that an imperative verb phrase implies<br>&gt;&gt;&gt; mutation, and I think that part is covered in the guidelines well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The first two guidelines already captures this sentiment as well:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. &quot;Those without side-effects should read as noun phrases&quot;.<br>&gt;&gt;&gt;&gt;&gt; 2. &quot;Those with side-effects should read as imperative verb phrases.&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I know what the guidelines say and what they&#39;re supposed to mean, and I<br>&gt;&gt;&gt;&gt; can&#39;t see how they support your point in any way.  Neither “trimming b”<br>&gt;&gt;&gt;&gt; nor “a trimming b” is an imperative verb phrase in English.  It is<br>&gt;&gt;&gt;&gt; always a noun phrase.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; True, `trimming` is not an imperative verb phrase; strike it from my example list.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, that&#39;s true.  You have to think ahead about API evolution if you<br>&gt;&gt;&gt;&gt; don&#39;t want to break users.  That goes for naming as well as anything<br>&gt;&gt;&gt;&gt; else.  If I said, “related APIs should form a distinguishable family,”<br>&gt;&gt;&gt;&gt; you probably wouldn&#39;t argue (would you?) but that guideline could lead<br>&gt;&gt;&gt;&gt; to exactly the same sequence of events.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe, but I don&#39;t necessarily think that grouping mutable and<br>&gt;&gt;&gt; non-mutable into the same family is the right approach.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -David<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
