<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-users] Problem with COW optimization</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>September 19, 2016 at 11:00:00pm</p></header><div class="content"><p>on Mon Sep 19 2016, Adrian Zubarev &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I think I just found a solution to my problem:<br>&gt;<br>&gt; /// - Parameter child: The new `child` to add to the `children` array.<br>&gt; public mutating func add(_ child: Element) {<br>&gt;<br>&gt;    let clonedChildReference = Reference(cloning: child.reference)<br>&gt;    let index = self.reference.children.endIndex<br>&gt;<br>&gt;    self.mutableInsert(clonedChildReference, at: index, isNotOwnReference: child.reference !== self.reference)<br>&gt; }<br>&gt;<br>&gt; /// Warning: Pass only clonded nodes of type Element to this function!<br></p><p>I don&#39;t understand why any explicit cloning should be needed.  An XML<br>tree can be modeled perfectly well using arrays of value types, which<br>will “clone” themselves as needed to maintain value semantics.<br></p><p>&gt; private mutating func mutableInsert(_ node: XML.Node, at index: Int,<br>&gt; isNotOwnReference: Bool) {<br>&gt;<br>&gt;    // * If `self.reference` is NOT uniquely referenced and `node` is a String,<br>&gt;    //   we should rebuilt own reference.<br>&gt;    // * If `self.reference` is NOT uniquely referenced and `node` is a Reference<br>&gt;    //   `isNotOwnReference` is true, we should rebuilt own reference.<br>&gt;    // * If `self.reference` is NOT uniquely referenced and `node` is a clone  <br>&gt;    //   reference to `self.reference` where is `isNotOwnReference` is false, we<br>&gt;    //   should check if there are more than **two** strong references to rebuild<br>&gt;    //   own reference, otherwise it&#39;s an implementation artifact and we can keep<br>&gt;    //   old reference (any `node` of type Reference is cloned before it&#39;s added  <br>&gt;    //   to the child array).<br>&gt;    let isNotKnownUniquelyReferenced = !isKnownUniquelyReferenced(&amp;self.reference)<br>&gt;<br>&gt;    var shouldRebuildReference = false<br>&gt;<br>&gt;    switch node.kind {<br>&gt;<br>&gt;    case .element(_):<br>&gt;       let hasMoreThanTwoStrongReferences = (CFGetRetainCount(self.reference) - 1) &gt; 2<br>&gt;       shouldRebuildReference = (isNotKnownUniquelyReferenced &amp;&amp; isNotOwnReference) || hasMoreThanTwoStrongReferences<br>&gt;<br>&gt;    case .text(_):<br>&gt;       shouldRebuildReference = isNotKnownUniquelyReferenced<br>&gt;    }<br>&gt;<br>&gt;    if shouldRebuildReference {<br>&gt;<br>&gt;       self.reference = Reference(cloning: self.reference, wholeTree: true)<br>&gt;    }<br>&gt;<br>&gt;    self.reference.insert(node, at: index)<br>&gt; }<br>&gt; I’m using CFGetRetainCount(self.reference) to catch that implementation artifact.<br>&gt;<br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 19. September 2016 um 09:59:24, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br>&gt;<br>&gt; Hello Dave,<br>&gt;<br>&gt; thank you for trying to help me. I’ll try to explain the issue with some more details.<br>&gt;<br>&gt; First here is some code:<br>&gt;<br>&gt; extension XML {<br>&gt;<br>&gt;     public struct Element {<br>&gt;<br>&gt;         // public for testing   <br>&gt;         public var reference: Reference<br>&gt;<br>&gt;         public var name: String { return self.reference.name }<br>&gt;<br>&gt;         public var children: [Element] {<br>&gt;<br>&gt;             return self.reference.children.flatMap {<br>&gt;<br>&gt;                 guard case .element(let element) = $0.kind else { return nil }<br>&gt;                 return Element(wrapping: element)<br>&gt;             }<br>&gt;         }<br>&gt;<br>&gt;         public init(name: String) {<br>&gt;<br>&gt;             self.reference = Reference(name: name)<br>&gt;         }<br>&gt;<br>&gt;         public mutating func add(_ child: Element) {<br>&gt;<br>&gt;             self.mutableInsert(Reference(cloning: child.reference), at: self.reference.children.endIndex)<br>&gt;         }<br>&gt;<br>&gt;         // Ignore XML.Node, it&#39;s a String or Reference<br>&gt;         // Parameter `Node` is assumed to be a clone of a reference passed to `add` or `insert` method.<br>&gt;         private mutating func mutableInsert(_ node: XML.Node, at index: Int) {<br>&gt;<br>&gt;             // Clone own reference all way up to the root<br>&gt;             if !isKnownUniquelyReferenced(&amp;self.reference) {<br>&gt;<br>&gt;                 self.reference = Reference(cloning: self.reference, wholeTree: true)<br>&gt;             }<br>&gt;<br>&gt;             // Extract a reference or just insert a string as a child<br>&gt;             guard case .element(let nodeReference) = node.kind else {<br>&gt;<br>&gt;                 self.reference.insert(node, at: index)<br>&gt;                 return<br>&gt;             }<br>&gt;<br>&gt;             // Check for possible debelopment bug<br>&gt;             if nodeReference === self.reference {<br>&gt;<br>&gt;                 fatalError(&quot;wrong usage of `mutableInsert` function&quot;)<br>&gt;             }<br>&gt;<br>&gt;             self.reference.insert(nodeReference, at: index)<br>&gt;         }<br>&gt;<br>&gt;         ...<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; extension XML.Element {<br>&gt;<br>&gt;     // public for testing<br>&gt;     public class Reference : XML.Node {<br>&gt;<br>&gt;         let name: String<br>&gt;<br>&gt;         private(set) weak var parent: Reference?<br>&gt;<br>&gt;         private(set) var children: [XML.Node]<br>&gt;<br>&gt;         var kind: XML.Node.Kind { return .element(self) }<br>&gt;<br>&gt;         ...<br>&gt;     }<br>&gt; }<br>&gt; Now lets focus on the problem.<br>&gt;<br>&gt; Every Element is baked with it’s own Reference to be able to traverse the tree from any of it’s node all way up to the root for example.<br>&gt;<br>&gt; Lets look again at the scenario I already described:<br>&gt;<br>&gt; var root = XML.Element(name: &quot;root&quot;)<br>&gt; var elem = XML.Element(name: &quot;elem&quot;)<br>&gt;<br>&gt; ObjectIdentifier(root.reference) // 0x000060000026ab40<br>&gt; ObjectIdentifier(elem.reference) // 0x000060800026bb00<br>&gt;<br>&gt; isKnownUniquelyReferenced(&amp;root.reference) // true<br>&gt; isKnownUniquelyReferenced(&amp;elem.reference) // true<br>&gt;<br>&gt; root.add(elem)<br>&gt;<br>&gt; isKnownUniquelyReferenced(&amp;root.reference) // true<br>&gt;<br>&gt; root.add(root)<br>&gt;<br>&gt; // The reference of root has changed even if the second child   <br>&gt; // was cloned and added as a new object to the reference.<br>&gt; // 0x000060000026ab40 &lt;-- was thrown away<br>&gt; isKnownUniquelyReferenced(&amp;root.reference) // true<br>&gt;<br>&gt; ObjectIdentifier(root.reference) // 0x000060000026c680 &lt;— new one<br>&gt; The way I’m adding children to the tree is that every passed element of type XML.Element stores a Reference, which will be cloned and added as a new standalone object to the children array.<br>&gt;<br>&gt; The same happens when we try adding root as it’s own child. We copy root struct which contains the same reference, then we clone it inside add method, then we pass the new object to the mutableInsert function. At that point we don’t need the old reference anymore, I’m speaking of root.add(root). The problem here is that at that time root.reference has 2 strong references which I cannot escape.<br>&gt;<br>&gt; I could workaround the problem if I knew the reference counter value, because I could check if the passed Element contains the same reference first. And if it does and we have exactly 2 strong references, I don’t need to recreate root.reference here.<br>&gt;<br>&gt; But I couldn’t find any API for that. :/<br>&gt;<br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 19. September 2016 um 05:50:57, Dave Abrahams via swift-users (swift-users at swift.org) schrieb:<br>&gt;<br>&gt; on Sun Sep 18 2016, Adrian Zubarev &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Dear Swift community,<br>&gt;&gt;<br>&gt;&gt; currently I’m building a value type XML library which is baked behind<br>&gt;&gt; the scene with a reference type to manage graph traversing between<br>&gt;&gt; nodes. I also like to COW optimize the xml graph, but I run into one<br>&gt;&gt; single problem atm.<br>&gt;&gt;<br>&gt;&gt; Image this xml tree:<br>&gt;&gt;<br>&gt;&gt; &lt;root&gt;<br>&gt;&gt; &lt;item/&gt;<br>&gt;&gt; &lt;/root&gt;<br>&gt;&gt; It’s just a root element with one single child. As for value types it<br>&gt;&gt; should be totally fine to do something like this:<br>&gt;&gt;<br>&gt;&gt; // The given xml tree<br>&gt;&gt; var root = XML.Element(name: &quot;root&quot;)<br>&gt;&gt; let item = XML.Element(name: &quot;item&quot;)<br>&gt;&gt; root.add(item)<br>&gt;&gt;<br>&gt;&gt; // The problematic behavior<br>&gt;&gt; root.add(root)<br>&gt;&gt; If this would be a simple value type without any references behind the<br>&gt;&gt; scenes you could imagine that the result of the last code line will<br>&gt;&gt; look like this:<br>&gt;&gt;<br>&gt;&gt; &lt;root&gt;<br>&gt;&gt; &lt;item/&gt;<br>&gt;&gt; &lt;root&gt;<br>&gt;&gt; &lt;item/&gt;<br>&gt;&gt; &lt;/root&gt;<br>&gt;&gt; &lt;/root&gt;<br>&gt;<br>&gt; Yep, that&#39;s exactly the right answer for a tree with value semantics.<br>&gt; The simplest way to implement this tree is to use an Array for the child<br>&gt; nodes.<br>&gt;<br>&gt;&gt; Basically we copied the whole tree and added it as the second child<br>&gt;&gt; into the original root element.<br>&gt;&gt;<br>&gt;&gt; As for COW optimization this is a problem, just because the passed<br>&gt;&gt; root is a copy of a struct that contains the exact same reference as<br>&gt;&gt; the original root element.<br>&gt;<br>&gt; I don&#39;t understand why that&#39;s a problem.<br>&gt;<br>&gt;&gt; isKnownUniquelyReferenced(&amp;self.reference) will result in false inside<br>&gt;&gt; the add method.<br>&gt;<br>&gt; ...as it should.<br>&gt;<br>&gt;&gt; Is there any chance I could force my program to decrease the reference<br>&gt;&gt; counter of that last item after I’m sure I don’t need it?!<br>&gt;<br>&gt; Which last item? When are you sure you don&#39;t need it? What result do<br>&gt; you hope for?<br>&gt;<br>&gt;&gt; A few more details: inside the add method I’m always cloning the<br>&gt;&gt; passed reference just because graphs aren’t that trivial and otherwise<br>&gt;&gt; I could possibly end up with a cycle graph, which would be really<br>&gt;&gt; bad. After that job I’m sure that I don’t need the passed reference<br>&gt;&gt; anymore and I need a way to escape from it.<br>&gt;&gt;<br>&gt;&gt; I’d appreciate any suggestions and help. :)<br>&gt;<br>&gt; It&#39;s not clear what you want to acheive nor can I picture the code<br>&gt; you&#39;re using to acheive it, so it&#39;s hard to give useful feedback.<br>&gt;<br>&gt; Sorry,<br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[swift-users] Problem with COW optimization</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>September 20, 2016 at 09:00:00am</p></header><div class="content"><p>True, but how do you traverse back the tree from an inner node?<br></p><p>Lets look at this simple tree:<br></p><p>&lt;root&gt;<br>   &lt;first&gt;<br>      &lt;second/&gt;<br>   &lt;/first&gt;<br>&lt;/root&gt;<br>let second = /* get the second node */<br></p><p>second.parent // &lt;— How would you implement this with pure value type?<br>If parent were only a struct without a reference type behind the scenes the parent will also contain the current child, where every child has the parent and so one. The reference type is there as a layer to achieve this.<br></p><p>What kind of a layer does indirect add on enums?<br>Can indirect solve the problem here and can it be added to structs as well?<br>If I’m missing here something, and there might be a true value type solution for this problem, I’d throw the whole project away and rebuild it from the beginning. :)<br></p><p>Best regards,<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 20. September 2016 um 08:56:20, Dave Abrahams via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p><br>on Mon Sep 19 2016, Adrian Zubarev &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I think I just found a solution to my problem:<br>&gt;<br>&gt; /// - Parameter child: The new `child` to add to the `children` array.<br>&gt; public mutating func add(_ child: Element) {<br>&gt;<br>&gt; let clonedChildReference = Reference(cloning: child.reference)<br>&gt; let index = self.reference.children.endIndex<br>&gt;<br>&gt; self.mutableInsert(clonedChildReference, at: index, isNotOwnReference: child.reference !== self.reference)<br>&gt; }<br>&gt;<br>&gt; /// Warning: Pass only clonded nodes of type Element to this function!<br></p><p>I don&#39;t understand why any explicit cloning should be needed. An XML<br>tree can be modeled perfectly well using arrays of value types, which<br>will “clone” themselves as needed to maintain value semantics.<br></p><p>&gt; private mutating func mutableInsert(_ node: XML.Node, at index: Int,<br>&gt; isNotOwnReference: Bool) {<br>&gt;<br>&gt; // * If `self.reference` is NOT uniquely referenced and `node` is a String,<br>&gt; // we should rebuilt own reference.<br>&gt; // * If `self.reference` is NOT uniquely referenced and `node` is a Reference<br>&gt; // `isNotOwnReference` is true, we should rebuilt own reference.<br>&gt; // * If `self.reference` is NOT uniquely referenced and `node` is a clone  <br>&gt; // reference to `self.reference` where is `isNotOwnReference` is false, we<br>&gt; // should check if there are more than **two** strong references to rebuild<br>&gt; // own reference, otherwise it&#39;s an implementation artifact and we can keep<br>&gt; // old reference (any `node` of type Reference is cloned before it&#39;s added  <br>&gt; // to the child array).<br>&gt; let isNotKnownUniquelyReferenced = !isKnownUniquelyReferenced(&amp;self.reference)<br>&gt;<br>&gt; var shouldRebuildReference = false<br>&gt;<br>&gt; switch node.kind {<br>&gt;<br>&gt; case .element(_):<br>&gt; let hasMoreThanTwoStrongReferences = (CFGetRetainCount(self.reference) - 1) &gt; 2<br>&gt; shouldRebuildReference = (isNotKnownUniquelyReferenced &amp;&amp; isNotOwnReference) || hasMoreThanTwoStrongReferences<br>&gt;<br>&gt; case .text(_):<br>&gt; shouldRebuildReference = isNotKnownUniquelyReferenced<br>&gt; }<br>&gt;<br>&gt; if shouldRebuildReference {<br>&gt;<br>&gt; self.reference = Reference(cloning: self.reference, wholeTree: true)<br>&gt; }<br>&gt;<br>&gt; self.reference.insert(node, at: index)<br>&gt; }<br>&gt; I’m using CFGetRetainCount(self.reference) to catch that implementation artifact.<br>&gt;<br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 19. September 2016 um 09:59:24, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br>&gt;<br>&gt; Hello Dave,<br>&gt;<br>&gt; thank you for trying to help me. I’ll try to explain the issue with some more details.<br>&gt;<br>&gt; First here is some code:<br>&gt;<br>&gt; extension XML {<br>&gt;<br>&gt; public struct Element {<br>&gt;<br>&gt; // public for testing  <br>&gt; public var reference: Reference<br>&gt;<br>&gt; public var name: String { return self.reference.name }<br>&gt;<br>&gt; public var children: [Element] {<br>&gt;<br>&gt; return self.reference.children.flatMap {<br>&gt;<br>&gt; guard case .element(let element) = $0.kind else { return nil }<br>&gt; return Element(wrapping: element)<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; public init(name: String) {<br>&gt;<br>&gt; self.reference = Reference(name: name)<br>&gt; }<br>&gt;<br>&gt; public mutating func add(_ child: Element) {<br>&gt;<br>&gt; self.mutableInsert(Reference(cloning: child.reference), at: self.reference.children.endIndex)<br>&gt; }<br>&gt;<br>&gt; // Ignore XML.Node, it&#39;s a String or Reference<br>&gt; // Parameter `Node` is assumed to be a clone of a reference passed to `add` or `insert` method.<br>&gt; private mutating func mutableInsert(_ node: XML.Node, at index: Int) {<br>&gt;<br>&gt; // Clone own reference all way up to the root<br>&gt; if !isKnownUniquelyReferenced(&amp;self.reference) {<br>&gt;<br>&gt; self.reference = Reference(cloning: self.reference, wholeTree: true)<br>&gt; }<br>&gt;<br>&gt; // Extract a reference or just insert a string as a child<br>&gt; guard case .element(let nodeReference) = node.kind else {<br>&gt;<br>&gt; self.reference.insert(node, at: index)<br>&gt; return<br>&gt; }<br>&gt;<br>&gt; // Check for possible debelopment bug<br>&gt; if nodeReference === self.reference {<br>&gt;<br>&gt; fatalError(&quot;wrong usage of `mutableInsert` function&quot;)<br>&gt; }<br>&gt;<br>&gt; self.reference.insert(nodeReference, at: index)<br>&gt; }<br>&gt;<br>&gt; ...<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; extension XML.Element {<br>&gt;<br>&gt; // public for testing<br>&gt; public class Reference : XML.Node {<br>&gt;<br>&gt; let name: String<br>&gt;<br>&gt; private(set) weak var parent: Reference?<br>&gt;<br>&gt; private(set) var children: [XML.Node]<br>&gt;<br>&gt; var kind: XML.Node.Kind { return .element(self) }<br>&gt;<br>&gt; ...<br>&gt; }<br>&gt; }<br>&gt; Now lets focus on the problem.<br>&gt;<br>&gt; Every Element is baked with it’s own Reference to be able to traverse the tree from any of it’s node all way up to the root for example.<br>&gt;<br>&gt; Lets look again at the scenario I already described:<br>&gt;<br>&gt; var root = XML.Element(name: &quot;root&quot;)<br>&gt; var elem = XML.Element(name: &quot;elem&quot;)<br>&gt;<br>&gt; ObjectIdentifier(root.reference) // 0x000060000026ab40<br>&gt; ObjectIdentifier(elem.reference) // 0x000060800026bb00<br>&gt;<br>&gt; isKnownUniquelyReferenced(&amp;root.reference) // true<br>&gt; isKnownUniquelyReferenced(&amp;elem.reference) // true<br>&gt;<br>&gt; root.add(elem)<br>&gt;<br>&gt; isKnownUniquelyReferenced(&amp;root.reference) // true<br>&gt;<br>&gt; root.add(root)<br>&gt;<br>&gt; // The reference of root has changed even if the second child  <br>&gt; // was cloned and added as a new object to the reference.<br>&gt; // 0x000060000026ab40 &lt;-- was thrown away<br>&gt; isKnownUniquelyReferenced(&amp;root.reference) // true<br>&gt;<br>&gt; ObjectIdentifier(root.reference) // 0x000060000026c680 &lt;— new one<br>&gt; The way I’m adding children to the tree is that every passed element of type XML.Element stores a Reference, which will be cloned and added as a new standalone object to the children array.<br>&gt;<br>&gt; The same happens when we try adding root as it’s own child. We copy root struct which contains the same reference, then we clone it inside add method, then we pass the new object to the mutableInsert function. At that point we don’t need the old reference anymore, I’m speaking of root.add(root). The problem here is that at that time root.reference has 2 strong references which I cannot escape.<br>&gt;<br>&gt; I could workaround the problem if I knew the reference counter value, because I could check if the passed Element contains the same reference first. And if it does and we have exactly 2 strong references, I don’t need to recreate root.reference here.<br>&gt;<br>&gt; But I couldn’t find any API for that. :/<br>&gt;<br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 19. September 2016 um 05:50:57, Dave Abrahams via swift-users (swift-users at swift.org) schrieb:<br>&gt;<br>&gt; on Sun Sep 18 2016, Adrian Zubarev &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Dear Swift community,<br>&gt;&gt;<br>&gt;&gt; currently I’m building a value type XML library which is baked behind<br>&gt;&gt; the scene with a reference type to manage graph traversing between<br>&gt;&gt; nodes. I also like to COW optimize the xml graph, but I run into one<br>&gt;&gt; single problem atm.<br>&gt;&gt;<br>&gt;&gt; Image this xml tree:<br>&gt;&gt;<br>&gt;&gt; &lt;root&gt;<br>&gt;&gt; &lt;item/&gt;<br>&gt;&gt; &lt;/root&gt;<br>&gt;&gt; It’s just a root element with one single child. As for value types it<br>&gt;&gt; should be totally fine to do something like this:<br>&gt;&gt;<br>&gt;&gt; // The given xml tree<br>&gt;&gt; var root = XML.Element(name: &quot;root&quot;)<br>&gt;&gt; let item = XML.Element(name: &quot;item&quot;)<br>&gt;&gt; root.add(item)<br>&gt;&gt;<br>&gt;&gt; // The problematic behavior<br>&gt;&gt; root.add(root)<br>&gt;&gt; If this would be a simple value type without any references behind the<br>&gt;&gt; scenes you could imagine that the result of the last code line will<br>&gt;&gt; look like this:<br>&gt;&gt;<br>&gt;&gt; &lt;root&gt;<br>&gt;&gt; &lt;item/&gt;<br>&gt;&gt; &lt;root&gt;<br>&gt;&gt; &lt;item/&gt;<br>&gt;&gt; &lt;/root&gt;<br>&gt;&gt; &lt;/root&gt;<br>&gt;<br>&gt; Yep, that&#39;s exactly the right answer for a tree with value semantics.<br>&gt; The simplest way to implement this tree is to use an Array for the child<br>&gt; nodes.<br>&gt;<br>&gt;&gt; Basically we copied the whole tree and added it as the second child<br>&gt;&gt; into the original root element.<br>&gt;&gt;<br>&gt;&gt; As for COW optimization this is a problem, just because the passed<br>&gt;&gt; root is a copy of a struct that contains the exact same reference as<br>&gt;&gt; the original root element.<br>&gt;<br>&gt; I don&#39;t understand why that&#39;s a problem.<br>&gt;<br>&gt;&gt; isKnownUniquelyReferenced(&amp;self.reference) will result in false inside<br>&gt;&gt; the add method.<br>&gt;<br>&gt; ...as it should.<br>&gt;<br>&gt;&gt; Is there any chance I could force my program to decrease the reference<br>&gt;&gt; counter of that last item after I’m sure I don’t need it?!<br>&gt;<br>&gt; Which last item? When are you sure you don&#39;t need it? What result do<br>&gt; you hope for?<br>&gt;<br>&gt;&gt; A few more details: inside the add method I’m always cloning the<br>&gt;&gt; passed reference just because graphs aren’t that trivial and otherwise<br>&gt;&gt; I could possibly end up with a cycle graph, which would be really<br>&gt;&gt; bad. After that job I’m sure that I don’t need the passed reference<br>&gt;&gt; anymore and I need a way to escape from it.<br>&gt;&gt;<br>&gt;&gt; I’d appreciate any suggestions and help. :)<br>&gt;<br>&gt; It&#39;s not clear what you want to acheive nor can I picture the code<br>&gt; you&#39;re using to acheive it, so it&#39;s hard to give useful feedback.<br>&gt;<br>&gt; Sorry,<br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>--  <br>-Dave<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160920/087f5d33/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[swift-users] Problem with COW optimization</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>September 20, 2016 at 09:00:00am</p></header><div class="content"><p>One note about the cloning:<br></p><p>&lt;root&gt;<br>   &lt;first&gt;<br>      &lt;second/&gt;<br>   &lt;/first&gt;<br>&lt;/root&gt;<br>var root = XML.Element(name: &quot;root&quot;)<br>var first = XML.Element(name: &quot;first&quot;)<br>var second = XML.Element(name: &quot;second&quot;)<br>first.add(second)<br></p><p>root[first][second].add(root) // Lets say we don&#39;t clone here anything<br>In that scenario we would add root as the first item to second.<br></p><p>&lt;root&gt;<br>   &lt;first&gt;<br>      &lt;second&gt;   &lt;- - - - - - - -+<br>         &lt;root&gt;                  | That would be the same item (baked with a class)<br>            &lt;first&gt;              | and that means that the inner `second` also has<br>               &lt;second/&gt; &lt;- - - -+ a child `root` =&gt; cycle graph.<br>            &lt;/first&gt;             |<br>         &lt;/root&gt;                 |<br>      &lt;/second&gt;  &lt;- - - - - - - -+<br>   &lt;/first&gt;<br>&lt;/root&gt;<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 20. September 2016 um 09:37:22, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>True, but how do you traverse back the tree from an inner node?<br></p><p>Lets look at this simple tree:<br></p><p>&lt;root&gt;<br>   &lt;first&gt;<br>      &lt;second/&gt;<br>   &lt;/first&gt;<br>&lt;/root&gt;<br>let second = /* get the second node */<br></p><p>second.parent // &lt;— How would you implement this with pure value type?<br>If parent were only a struct without a reference type behind the scenes the parent will also contain the current child, where every child has the parent and so one. The reference type is there as a layer to achieve this.<br></p><p>What kind of a layer does indirect add on enums?<br>Can indirect solve the problem here and can it be added to structs as well?<br>If I’m missing here something, and there might be a true value type solution for this problem, I’d throw the whole project away and rebuild it from the beginning. :)<br></p><p>Best regards,<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 20. September 2016 um 08:56:20, Dave Abrahams via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p><br>on Mon Sep 19 2016, Adrian Zubarev &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I think I just found a solution to my problem:<br>&gt;<br>&gt; /// - Parameter child: The new `child` to add to the `children` array.<br>&gt; public mutating func add(_ child: Element) {<br>&gt;<br>&gt; let clonedChildReference = Reference(cloning: child.reference)<br>&gt; let index = self.reference.children.endIndex<br>&gt;<br>&gt; self.mutableInsert(clonedChildReference, at: index, isNotOwnReference: child.reference !== self.reference)<br>&gt; }<br>&gt;<br>&gt; /// Warning: Pass only clonded nodes of type Element to this function!<br></p><p>I don&#39;t understand why any explicit cloning should be needed. An XML<br>tree can be modeled perfectly well using arrays of value types, which<br>will “clone” themselves as needed to maintain value semantics.<br></p><p>&gt; private mutating func mutableInsert(_ node: XML.Node, at index: Int,<br>&gt; isNotOwnReference: Bool) {<br>&gt;<br>&gt; // * If `self.reference` is NOT uniquely referenced and `node` is a String,<br>&gt; // we should rebuilt own reference.<br>&gt; // * If `self.reference` is NOT uniquely referenced and `node` is a Reference<br>&gt; // `isNotOwnReference` is true, we should rebuilt own reference.<br>&gt; // * If `self.reference` is NOT uniquely referenced and `node` is a clone<br>&gt; // reference to `self.reference` where is `isNotOwnReference` is false, we<br>&gt; // should check if there are more than **two** strong references to rebuild<br>&gt; // own reference, otherwise it&#39;s an implementation artifact and we can keep<br>&gt; // old reference (any `node` of type Reference is cloned before it&#39;s added<br>&gt; // to the child array).<br>&gt; let isNotKnownUniquelyReferenced = !isKnownUniquelyReferenced(&amp;self.reference)<br>&gt;<br>&gt; var shouldRebuildReference = false<br>&gt;<br>&gt; switch node.kind {<br>&gt;<br>&gt; case .element(_):<br>&gt; let hasMoreThanTwoStrongReferences = (CFGetRetainCount(self.reference) - 1) &gt; 2<br>&gt; shouldRebuildReference = (isNotKnownUniquelyReferenced &amp;&amp; isNotOwnReference) || hasMoreThanTwoStrongReferences<br>&gt;<br>&gt; case .text(_):<br>&gt; shouldRebuildReference = isNotKnownUniquelyReferenced<br>&gt; }<br>&gt;<br>&gt; if shouldRebuildReference {<br>&gt;<br>&gt; self.reference = Reference(cloning: self.reference, wholeTree: true)<br>&gt; }<br>&gt;<br>&gt; self.reference.insert(node, at: index)<br>&gt; }<br>&gt; I’m using CFGetRetainCount(self.reference) to catch that implementation artifact.<br>&gt;<br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 19. September 2016 um 09:59:24, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br>&gt;<br>&gt; Hello Dave,<br>&gt;<br>&gt; thank you for trying to help me. I’ll try to explain the issue with some more details.<br>&gt;<br>&gt; First here is some code:<br>&gt;<br>&gt; extension XML {<br>&gt;<br>&gt; public struct Element {<br>&gt;<br>&gt; // public for testing<br>&gt; public var reference: Reference<br>&gt;<br>&gt; public var name: String { return self.reference.name }<br>&gt;<br>&gt; public var children: [Element] {<br>&gt;<br>&gt; return self.reference.children.flatMap {<br>&gt;<br>&gt; guard case .element(let element) = $0.kind else { return nil }<br>&gt; return Element(wrapping: element)<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; public init(name: String) {<br>&gt;<br>&gt; self.reference = Reference(name: name)<br>&gt; }<br>&gt;<br>&gt; public mutating func add(_ child: Element) {<br>&gt;<br>&gt; self.mutableInsert(Reference(cloning: child.reference), at: self.reference.children.endIndex)<br>&gt; }<br>&gt;<br>&gt; // Ignore XML.Node, it&#39;s a String or Reference<br>&gt; // Parameter `Node` is assumed to be a clone of a reference passed to `add` or `insert` method.<br>&gt; private mutating func mutableInsert(_ node: XML.Node, at index: Int) {<br>&gt;<br>&gt; // Clone own reference all way up to the root<br>&gt; if !isKnownUniquelyReferenced(&amp;self.reference) {<br>&gt;<br>&gt; self.reference = Reference(cloning: self.reference, wholeTree: true)<br>&gt; }<br>&gt;<br>&gt; // Extract a reference or just insert a string as a child<br>&gt; guard case .element(let nodeReference) = node.kind else {<br>&gt;<br>&gt; self.reference.insert(node, at: index)<br>&gt; return<br>&gt; }<br>&gt;<br>&gt; // Check for possible debelopment bug<br>&gt; if nodeReference === self.reference {<br>&gt;<br>&gt; fatalError(&quot;wrong usage of `mutableInsert` function&quot;)<br>&gt; }<br>&gt;<br>&gt; self.reference.insert(nodeReference, at: index)<br>&gt; }<br>&gt;<br>&gt; ...<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; extension XML.Element {<br>&gt;<br>&gt; // public for testing<br>&gt; public class Reference : XML.Node {<br>&gt;<br>&gt; let name: String<br>&gt;<br>&gt; private(set) weak var parent: Reference?<br>&gt;<br>&gt; private(set) var children: [XML.Node]<br>&gt;<br>&gt; var kind: XML.Node.Kind { return .element(self) }<br>&gt;<br>&gt; ...<br>&gt; }<br>&gt; }<br>&gt; Now lets focus on the problem.<br>&gt;<br>&gt; Every Element is baked with it’s own Reference to be able to traverse the tree from any of it’s node all way up to the root for example.<br>&gt;<br>&gt; Lets look again at the scenario I already described:<br>&gt;<br>&gt; var root = XML.Element(name: &quot;root&quot;)<br>&gt; var elem = XML.Element(name: &quot;elem&quot;)<br>&gt;<br>&gt; ObjectIdentifier(root.reference) // 0x000060000026ab40<br>&gt; ObjectIdentifier(elem.reference) // 0x000060800026bb00<br>&gt;<br>&gt; isKnownUniquelyReferenced(&amp;root.reference) // true<br>&gt; isKnownUniquelyReferenced(&amp;elem.reference) // true<br>&gt;<br>&gt; root.add(elem)<br>&gt;<br>&gt; isKnownUniquelyReferenced(&amp;root.reference) // true<br>&gt;<br>&gt; root.add(root)<br>&gt;<br>&gt; // The reference of root has changed even if the second child<br>&gt; // was cloned and added as a new object to the reference.<br>&gt; // 0x000060000026ab40 &lt;-- was thrown away<br>&gt; isKnownUniquelyReferenced(&amp;root.reference) // true<br>&gt;<br>&gt; ObjectIdentifier(root.reference) // 0x000060000026c680 &lt;— new one<br>&gt; The way I’m adding children to the tree is that every passed element of type XML.Element stores a Reference, which will be cloned and added as a new standalone object to the children array.<br>&gt;<br>&gt; The same happens when we try adding root as it’s own child. We copy root struct which contains the same reference, then we clone it inside add method, then we pass the new object to the mutableInsert function. At that point we don’t need the old reference anymore, I’m speaking of root.add(root). The problem here is that at that time root.reference has 2 strong references which I cannot escape.<br>&gt;<br>&gt; I could workaround the problem if I knew the reference counter value, because I could check if the passed Element contains the same reference first. And if it does and we have exactly 2 strong references, I don’t need to recreate root.reference here.<br>&gt;<br>&gt; But I couldn’t find any API for that. :/<br>&gt;<br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 19. September 2016 um 05:50:57, Dave Abrahams via swift-users (swift-users at swift.org) schrieb:<br>&gt;<br>&gt; on Sun Sep 18 2016, Adrian Zubarev &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Dear Swift community,<br>&gt;&gt;<br>&gt;&gt; currently I’m building a value type XML library which is baked behind<br>&gt;&gt; the scene with a reference type to manage graph traversing between<br>&gt;&gt; nodes. I also like to COW optimize the xml graph, but I run into one<br>&gt;&gt; single problem atm.<br>&gt;&gt;<br>&gt;&gt; Image this xml tree:<br>&gt;&gt;<br>&gt;&gt; &lt;root&gt;<br>&gt;&gt; &lt;item/&gt;<br>&gt;&gt; &lt;/root&gt;<br>&gt;&gt; It’s just a root element with one single child. As for value types it<br>&gt;&gt; should be totally fine to do something like this:<br>&gt;&gt;<br>&gt;&gt; // The given xml tree<br>&gt;&gt; var root = XML.Element(name: &quot;root&quot;)<br>&gt;&gt; let item = XML.Element(name: &quot;item&quot;)<br>&gt;&gt; root.add(item)<br>&gt;&gt;<br>&gt;&gt; // The problematic behavior<br>&gt;&gt; root.add(root)<br>&gt;&gt; If this would be a simple value type without any references behind the<br>&gt;&gt; scenes you could imagine that the result of the last code line will<br>&gt;&gt; look like this:<br>&gt;&gt;<br>&gt;&gt; &lt;root&gt;<br>&gt;&gt; &lt;item/&gt;<br>&gt;&gt; &lt;root&gt;<br>&gt;&gt; &lt;item/&gt;<br>&gt;&gt; &lt;/root&gt;<br>&gt;&gt; &lt;/root&gt;<br>&gt;<br>&gt; Yep, that&#39;s exactly the right answer for a tree with value semantics.<br>&gt; The simplest way to implement this tree is to use an Array for the child<br>&gt; nodes.<br>&gt;<br>&gt;&gt; Basically we copied the whole tree and added it as the second child<br>&gt;&gt; into the original root element.<br>&gt;&gt;<br>&gt;&gt; As for COW optimization this is a problem, just because the passed<br>&gt;&gt; root is a copy of a struct that contains the exact same reference as<br>&gt;&gt; the original root element.<br>&gt;<br>&gt; I don&#39;t understand why that&#39;s a problem.<br>&gt;<br>&gt;&gt; isKnownUniquelyReferenced(&amp;self.reference) will result in false inside<br>&gt;&gt; the add method.<br>&gt;<br>&gt; ...as it should.<br>&gt;<br>&gt;&gt; Is there any chance I could force my program to decrease the reference<br>&gt;&gt; counter of that last item after I’m sure I don’t need it?!<br>&gt;<br>&gt; Which last item? When are you sure you don&#39;t need it? What result do<br>&gt; you hope for?<br>&gt;<br>&gt;&gt; A few more details: inside the add method I’m always cloning the<br>&gt;&gt; passed reference just because graphs aren’t that trivial and otherwise<br>&gt;&gt; I could possibly end up with a cycle graph, which would be really<br>&gt;&gt; bad. After that job I’m sure that I don’t need the passed reference<br>&gt;&gt; anymore and I need a way to escape from it.<br>&gt;&gt;<br>&gt;&gt; I’d appreciate any suggestions and help. :)<br>&gt;<br>&gt; It&#39;s not clear what you want to acheive nor can I picture the code<br>&gt; you&#39;re using to acheive it, so it&#39;s hard to give useful feedback.<br>&gt;<br>&gt; Sorry,<br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>--<br>-Dave<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160920/e1d6934f/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-users] Problem with COW optimization</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>September 28, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Am 20.09.2016 um 09:37 schrieb Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; True, but how do you traverse back the tree from an inner node?<br>&gt; <br>&gt; Lets look at this simple tree:<br>&gt; <br>&gt; &lt;root&gt;<br>&gt;    &lt;first&gt;<br>&gt;       &lt;second/&gt;<br>&gt;    &lt;/first&gt;<br>&gt; &lt;/root&gt;<br>&gt; let second = /* get the second node */<br>&gt; <br>&gt; second.parent // &lt;— How would you implement this with pure value type?<br>If you really want to reference the parent node wouldn&#39;t it be more appropriate to just use reference types in the first place?<br></p><p>The other question I have is: what do you need this for? Maybe your problem can be solved differently by keeping track of the parent in the algorothm working on the elements?<br></p><p>-Thorsten <br></p><p><br>&gt; If parent were only a struct without a reference type behind the scenes the parent will also contain the current child, where every child has the parent and so one. The reference type is there as a layer to achieve this.<br>&gt; <br>&gt; What kind of a layer does indirect add on enums?<br>&gt; Can indirect solve the problem here and can it be added to structs as well?<br>&gt; If I’m missing here something, and there might be a true value type solution for this problem, I’d throw the whole project away and rebuild it from the beginning. :)<br>&gt; <br>&gt; Best regards,<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 20. September 2016 um 08:56:20, Dave Abrahams via swift-evolution (swift-evolution at swift.org) schrieb:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon Sep 19 2016, Adrian Zubarev &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; I think I just found a solution to my problem:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; /// - Parameter child: The new `child` to add to the `children` array.<br>&gt;&gt; &gt; public mutating func add(_ child: Element) {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; let clonedChildReference = Reference(cloning: child.reference)<br>&gt;&gt; &gt; let index = self.reference.children.endIndex<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; self.mutableInsert(clonedChildReference, at: index, isNotOwnReference: child.reference !== self.reference)<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; /// Warning: Pass only clonded nodes of type Element to this function!<br>&gt;&gt; <br>&gt;&gt; I don&#39;t understand why any explicit cloning should be needed. An XML<br>&gt;&gt; tree can be modeled perfectly well using arrays of value types, which<br>&gt;&gt; will “clone” themselves as needed to maintain value semantics.<br>&gt;&gt; <br>&gt;&gt; &gt; private mutating func mutableInsert(_ node: XML.Node, at index: Int,<br>&gt;&gt; &gt; isNotOwnReference: Bool) {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; // * If `self.reference` is NOT uniquely referenced and `node` is a String,<br>&gt;&gt; &gt; // we should rebuilt own reference.<br>&gt;&gt; &gt; // * If `self.reference` is NOT uniquely referenced and `node` is a Reference<br>&gt;&gt; &gt; // `isNotOwnReference` is true, we should rebuilt own reference.<br>&gt;&gt; &gt; // * If `self.reference` is NOT uniquely referenced and `node` is a clone <br>&gt;&gt; &gt; // reference to `self.reference` where is `isNotOwnReference` is false, we<br>&gt;&gt; &gt; // should check if there are more than **two** strong references to rebuild<br>&gt;&gt; &gt; // own reference, otherwise it&#39;s an implementation artifact and we can keep<br>&gt;&gt; &gt; // old reference (any `node` of type Reference is cloned before it&#39;s added <br>&gt;&gt; &gt; // to the child array).<br>&gt;&gt; &gt; let isNotKnownUniquelyReferenced = !isKnownUniquelyReferenced(&amp;self.reference)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; var shouldRebuildReference = false<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; switch node.kind {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case .element(_):<br>&gt;&gt; &gt; let hasMoreThanTwoStrongReferences = (CFGetRetainCount(self.reference) - 1) &gt; 2<br>&gt;&gt; &gt; shouldRebuildReference = (isNotKnownUniquelyReferenced &amp;&amp; isNotOwnReference) || hasMoreThanTwoStrongReferences<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; case .text(_):<br>&gt;&gt; &gt; shouldRebuildReference = isNotKnownUniquelyReferenced<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; if shouldRebuildReference {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; self.reference = Reference(cloning: self.reference, wholeTree: true)<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; self.reference.insert(node, at: index)<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt; I’m using CFGetRetainCount(self.reference) to catch that implementation artifact.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -- <br>&gt;&gt; &gt; Adrian Zubarev<br>&gt;&gt; &gt; Sent with Airmail<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Am 19. September 2016 um 09:59:24, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Hello Dave,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; thank you for trying to help me. I’ll try to explain the issue with some more details.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; First here is some code:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; extension XML {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; public struct Element {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; // public for testing <br>&gt;&gt; &gt; public var reference: Reference<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; public var name: String { return self.reference.name }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; public var children: [Element] {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; return self.reference.children.flatMap {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; guard case .element(let element) = $0.kind else { return nil }<br>&gt;&gt; &gt; return Element(wrapping: element)<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; public init(name: String) {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; self.reference = Reference(name: name)<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; public mutating func add(_ child: Element) {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; self.mutableInsert(Reference(cloning: child.reference), at: self.reference.children.endIndex)<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; // Ignore XML.Node, it&#39;s a String or Reference<br>&gt;&gt; &gt; // Parameter `Node` is assumed to be a clone of a reference passed to `add` or `insert` method.<br>&gt;&gt; &gt; private mutating func mutableInsert(_ node: XML.Node, at index: Int) {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; // Clone own reference all way up to the root<br>&gt;&gt; &gt; if !isKnownUniquelyReferenced(&amp;self.reference) {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; self.reference = Reference(cloning: self.reference, wholeTree: true)<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; // Extract a reference or just insert a string as a child<br>&gt;&gt; &gt; guard case .element(let nodeReference) = node.kind else {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; self.reference.insert(node, at: index)<br>&gt;&gt; &gt; return<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; // Check for possible debelopment bug<br>&gt;&gt; &gt; if nodeReference === self.reference {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; fatalError(&quot;wrong usage of `mutableInsert` function&quot;)<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; self.reference.insert(nodeReference, at: index)<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ...<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; extension XML.Element {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; // public for testing<br>&gt;&gt; &gt; public class Reference : XML.Node {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; let name: String<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; private(set) weak var parent: Reference?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; private(set) var children: [XML.Node]<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; var kind: XML.Node.Kind { return .element(self) }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ...<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt; Now lets focus on the problem.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Every Element is baked with it’s own Reference to be able to traverse the tree from any of it’s node all way up to the root for example.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Lets look again at the scenario I already described:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; var root = XML.Element(name: &quot;root&quot;)<br>&gt;&gt; &gt; var elem = XML.Element(name: &quot;elem&quot;)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ObjectIdentifier(root.reference) // 0x000060000026ab40<br>&gt;&gt; &gt; ObjectIdentifier(elem.reference) // 0x000060800026bb00<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; isKnownUniquelyReferenced(&amp;root.reference) // true<br>&gt;&gt; &gt; isKnownUniquelyReferenced(&amp;elem.reference) // true<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; root.add(elem)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; isKnownUniquelyReferenced(&amp;root.reference) // true<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; root.add(root)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; // The reference of root has changed even if the second child <br>&gt;&gt; &gt; // was cloned and added as a new object to the reference.<br>&gt;&gt; &gt; // 0x000060000026ab40 &lt;-- was thrown away<br>&gt;&gt; &gt; isKnownUniquelyReferenced(&amp;root.reference) // true<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ObjectIdentifier(root.reference) // 0x000060000026c680 &lt;— new one<br>&gt;&gt; &gt; The way I’m adding children to the tree is that every passed element of type XML.Element stores a Reference, which will be cloned and added as a new standalone object to the children array.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The same happens when we try adding root as it’s own child. We copy root struct which contains the same reference, then we clone it inside add method, then we pass the new object to the mutableInsert function. At that point we don’t need the old reference anymore, I’m speaking of root.add(root). The problem here is that at that time root.reference has 2 strong references which I cannot escape.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I could workaround the problem if I knew the reference counter value, because I could check if the passed Element contains the same reference first. And if it does and we have exactly 2 strong references, I don’t need to recreate root.reference here.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; But I couldn’t find any API for that. :/<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -- <br>&gt;&gt; &gt; Adrian Zubarev<br>&gt;&gt; &gt; Sent with Airmail<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Am 19. September 2016 um 05:50:57, Dave Abrahams via swift-users (swift-users at swift.org) schrieb:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; on Sun Sep 18 2016, Adrian Zubarev &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Dear Swift community,<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; currently I’m building a value type XML library which is baked behind<br>&gt;&gt; &gt;&gt; the scene with a reference type to manage graph traversing between<br>&gt;&gt; &gt;&gt; nodes. I also like to COW optimize the xml graph, but I run into one<br>&gt;&gt; &gt;&gt; single problem atm.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Image this xml tree:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &lt;root&gt;<br>&gt;&gt; &gt;&gt; &lt;item/&gt;<br>&gt;&gt; &gt;&gt; &lt;/root&gt;<br>&gt;&gt; &gt;&gt; It’s just a root element with one single child. As for value types it<br>&gt;&gt; &gt;&gt; should be totally fine to do something like this:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; // The given xml tree<br>&gt;&gt; &gt;&gt; var root = XML.Element(name: &quot;root&quot;)<br>&gt;&gt; &gt;&gt; let item = XML.Element(name: &quot;item&quot;)<br>&gt;&gt; &gt;&gt; root.add(item)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; // The problematic behavior<br>&gt;&gt; &gt;&gt; root.add(root)<br>&gt;&gt; &gt;&gt; If this would be a simple value type without any references behind the<br>&gt;&gt; &gt;&gt; scenes you could imagine that the result of the last code line will<br>&gt;&gt; &gt;&gt; look like this:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &lt;root&gt;<br>&gt;&gt; &gt;&gt; &lt;item/&gt;<br>&gt;&gt; &gt;&gt; &lt;root&gt;<br>&gt;&gt; &gt;&gt; &lt;item/&gt;<br>&gt;&gt; &gt;&gt; &lt;/root&gt;<br>&gt;&gt; &gt;&gt; &lt;/root&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Yep, that&#39;s exactly the right answer for a tree with value semantics.<br>&gt;&gt; &gt; The simplest way to implement this tree is to use an Array for the child<br>&gt;&gt; &gt; nodes.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Basically we copied the whole tree and added it as the second child<br>&gt;&gt; &gt;&gt; into the original root element.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; As for COW optimization this is a problem, just because the passed<br>&gt;&gt; &gt;&gt; root is a copy of a struct that contains the exact same reference as<br>&gt;&gt; &gt;&gt; the original root element.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I don&#39;t understand why that&#39;s a problem.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; isKnownUniquelyReferenced(&amp;self.reference) will result in false inside<br>&gt;&gt; &gt;&gt; the add method.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ...as it should.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Is there any chance I could force my program to decrease the reference<br>&gt;&gt; &gt;&gt; counter of that last item after I’m sure I don’t need it?!<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Which last item? When are you sure you don&#39;t need it? What result do<br>&gt;&gt; &gt; you hope for?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; A few more details: inside the add method I’m always cloning the<br>&gt;&gt; &gt;&gt; passed reference just because graphs aren’t that trivial and otherwise<br>&gt;&gt; &gt;&gt; I could possibly end up with a cycle graph, which would be really<br>&gt;&gt; &gt;&gt; bad. After that job I’m sure that I don’t need the passed reference<br>&gt;&gt; &gt;&gt; anymore and I need a way to escape from it.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I’d appreciate any suggestions and help. :)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; It&#39;s not clear what you want to acheive nor can I picture the code<br>&gt;&gt; &gt; you&#39;re using to acheive it, so it&#39;s hard to give useful feedback.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Sorry,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; -Dave<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-users mailing list<br>&gt;&gt; &gt; swift-users at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/c2f943ec/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
