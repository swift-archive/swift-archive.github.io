<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ca02c0ca5c5d6a28bc48eebb3b000c7?s=50"></div><header><strong>Optional variables from a non-optional source with type inference</strong> from <string>Michael Henson</string> &lt;mikehenson at gmail.com&gt;<p>January 25, 2016 at 04:00:00pm</p></header><div class="content"><p>While reading the summary of a newsletter&#39;s notification about the<br>acceptance of SE-0021&#39;s new syntax, a thought occurred to me:<br></p><p>let fn = someView.insertSubview(_:at:)<br>&gt; let fn1 = someView.insertSubview(_:aboveSubview:)<br>&gt; let fn2 = someView.insertSubview(_:belowSubview:)<br></p><p><br>That code will create variables fn, fn1, fn2 of the correct type to hold<br>each of the named functions.<br></p><p>As I understand it, the following things are true:<br></p><p>1. Member functions on instances of a class type are curried functions that<br>strongly capture &#39;self&#39;.<br>2. Any strong reference to those member functions will also prevent that<br>instance from ever reaching ref count 0.<br>3. This isn&#39;t a new problem, just one that will become more important now<br>that this use case is easier to... use.<br></p><p>The easy fix for this situation would be to declare fn, fn1, and fn2 as<br>weakened optionals so they don&#39;t keep someView around if it should have<br>been dallocated. The question is... how? Is there existing syntax that<br>means &quot;infer the type from the right-hand-side production, except as an<br>optional / weakened optional&quot;?<br></p><p>Mike<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160125/b26e6b5e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Optional variables from a non-optional source with type inference</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 26, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 25, 2016, at 16:16 , Michael Henson via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; While reading the summary of a newsletter&#39;s notification about the acceptance of SE-0021&#39;s new syntax, a thought occurred to me:<br>&gt; <br>&gt; let fn = someView.insertSubview(_:at:)<br>&gt; let fn1 = someView.insertSubview(_:aboveSubview:)<br>&gt; let fn2 = someView.insertSubview(_:belowSubview:)<br>&gt; <br>&gt; That code will create variables fn, fn1, fn2 of the correct type to hold each of the named functions.<br>&gt; <br>&gt; As I understand it, the following things are true:<br>&gt; <br>&gt; 1. Member functions on instances of a class type are curried functions that strongly capture &#39;self&#39;.<br>&gt; 2. Any strong reference to those member functions will also prevent that instance from ever reaching ref count 0.<br>&gt; 3. This isn&#39;t a new problem, just one that will become more important now that this use case is easier to... use.<br>&gt; <br>&gt; The easy fix for this situation would be to declare fn, fn1, and fn2 as weakened optionals so they don&#39;t keep someView around if it should have been dallocated. The question is... how? Is there existing syntax that means &quot;infer the type from the right-hand-side production, except as an optional / weakened optional&quot;?<br></p><p>Hey, Mike. There&#39;s no existing syntax for this today; the best you can get is a custom closure. The type can still be inferred, though:<br></p><p>let fn3 = { [weak someView] in someView?.insertSubview($0, belowSubview: $1) }<br></p><p>This works because the closure is a single expression, so the body can be type-checked together with the enclosing statement. If the body has actual statements in it then it is type-checked separately.<br></p><p>We don&#39;t currently have any other syntax for this, but personally I think it&#39;s not common enough to warrant it. I&#39;d actually rather consider disallowing binding member functions like this unless the resulting closure is @noescape. That also keeps you from accidentally introducing retain cycles. But any serious language change here would have to go through the Swift Evolution Process &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;.<br></p><p>Best,<br>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160126/cd91af2b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>Optional variables from a non-optional source with type inference</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>January 28, 2016 at 11:00:00pm</p></header><div class="content"><p>I wrote a small library a while back that handles this problem without<br>needing a new closure:<br>https://github.com/klundberg/weakify<br></p><p>...which should be SwiftPM compatible on top of the more established<br>distribution methods.<br></p><p>On 1/26/2016 10:39 PM, Jordan Rose via swift-users wrote:<br>&gt;<br>&gt;&gt; On Jan 25, 2016, at 16:16 , Michael Henson via swift-users<br>&gt;&gt; &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; While reading the summary of a newsletter&#39;s notification about the<br>&gt;&gt; acceptance of SE-0021&#39;s new syntax, a thought occurred to me:<br>&gt;&gt;<br>&gt;&gt;     let fn = someView.insertSubview(_:at:) |let fn1 =<br>&gt;&gt;     someView.insertSubview(_:aboveSubview:)<br>&gt;&gt;     ||let fn2 = someView.insertSubview(_:belowSubview:)|<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That code will create variables fn, fn1, fn2 of the correct type to<br>&gt;&gt; hold each of the named functions.<br>&gt;&gt;<br>&gt;&gt; As I understand it, the following things are true:<br>&gt;&gt;<br>&gt;&gt; 1. Member functions on instances of a class type are curried<br>&gt;&gt; functions that strongly capture &#39;self&#39;.<br>&gt;&gt; 2. Any strong reference to those member functions will also prevent<br>&gt;&gt; that instance from ever reaching ref count 0.<br>&gt;&gt; 3. This isn&#39;t a new problem, just one that will become more important<br>&gt;&gt; now that this use case is easier to... use.<br>&gt;&gt;<br>&gt;&gt; The easy fix for this situation would be to declare fn, fn1, and fn2<br>&gt;&gt; as weakened optionals so they don&#39;t keep someView around if it should<br>&gt;&gt; have been dallocated. The question is... how? Is there existing<br>&gt;&gt; syntax that means &quot;infer the type from the right-hand-side<br>&gt;&gt; production, except as an optional / weakened optional&quot;?<br>&gt;<br>&gt; Hey, Mike. There&#39;s no existing syntax for this today; the best you can<br>&gt; get is a custom closure. The type can still be inferred, though:<br>&gt;<br>&gt;     let fn3 = { [weak someView] in someView?.insertSubview($0,<br>&gt;     belowSubview: $1) }<br>&gt;<br>&gt;<br>&gt; This works because the closure is a single expression, so the body can<br>&gt; be type-checked together with the enclosing statement. If the body has<br>&gt; actual statements in it then it is type-checked separately.<br>&gt;<br>&gt; We don&#39;t currently have any other syntax for this, but personally I<br>&gt; think it&#39;s not common enough to warrant it. I&#39;d actually rather<br>&gt; consider /disallowing/ binding member functions like this unless the<br>&gt; resulting closure is @noescape. That also keeps you from accidentally<br>&gt; introducing retain cycles. But any serious language change here would<br>&gt; have to go through the Swift Evolution Process<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;.<br>&gt;<br>&gt; Best,<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160128/bb33616a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
