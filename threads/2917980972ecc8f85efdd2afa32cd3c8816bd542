<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 22, 2016 at 01:00:00pm</p></header><div class="content"><p>on Sun May 22 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; What I am arguing for is the ability to distinguish aggregates which<br>&gt; are logically isolated from aggregates which contain salient<br>&gt; references to shared mutable state. <br></p><p>Everything with value semantics is logically isolated in that way.<br></p><p>&gt; To be honest, I am really struggling to understand why this<br>&gt; distinction seems unimportant to you.<br></p><p>The non-exposure of shared mutable state is a hugely important property<br>of well-encapsulated design.  However, I don&#39;t believe it&#39;s appropriate<br>to represent that with a protocol, because I don&#39;t believe there exist<br>any generic components whose correctness depends on it.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 22, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On May 22, 2016, at 3:42 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sun May 22 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; What I am arguing for is the ability to distinguish aggregates which<br>&gt;&gt; are logically isolated from aggregates which contain salient<br>&gt;&gt; references to shared mutable state. <br>&gt; <br>&gt; Everything with value semantics is logically isolated in that way.<br></p><p>Array&lt;UIView&gt; has salient references whose referent is shared mutable state.  The references are salient attributes. You’re saying the referent doesn’t matter because the boundary of the value stops at the reference.  I’m saying it does matter in that it means the aggregate is no longer logically isolated because shared mutable state is reachable through the aggregate.  Therefore it is not isolated in that way that I was intending to describe.  <br></p><p>&gt; <br>&gt;&gt; To be honest, I am really struggling to understand why this<br>&gt;&gt; distinction seems unimportant to you.<br>&gt; <br>&gt; The non-exposure of shared mutable state is a hugely important property<br>&gt; of well-encapsulated design.  However, I don&#39;t believe it&#39;s appropriate<br>&gt; to represent that with a protocol, because I don&#39;t believe there exist<br>&gt; any generic components whose correctness depends on it.<br></p><p>Do you believe it is appropriate to represent this in some other way that allows us to state architectural intent and introduce constraints for the purpose of structuring a large code base?<br></p><p>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 23, 2016 at 07:00:00am</p></header><div class="content"><p>on Sun May 22 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;&gt; On May 22, 2016, at 3:42 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sun May 22 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; What I am arguing for is the ability to distinguish aggregates which<br>&gt;&gt;&gt; are logically isolated from aggregates which contain salient<br>&gt;&gt;&gt; references to shared mutable state. <br>&gt;&gt; <br>&gt;&gt; Everything with value semantics is logically isolated in that way.<br>&gt;<br>&gt; Array&lt;UIView&gt; has salient references whose referent is shared mutable<br>&gt; state.  The references are salient attributes. You’re saying the<br>&gt; referent doesn’t matter because the boundary of the value stops at the<br>&gt; reference.  <br></p><p>I&#39;m saying you can define things that way, and it helps to make the<br>model for generic programming coherent.  Without something like this, it<br>becomes almost impossible to specify the behavior of generic components<br>in an understandable way without simultaneously preventing the use of<br>reference values as simple object identities, which *are* values.  As I<br>mentioned elsewhere, we could force users to wrap these reference values<br>to produce something that doesn&#39;t have easily identifiable reference<br>semantics, but the requirement of your `PureValue` that there should be<br>*no way* to derive access to the referenced instance from the wrapped<br>reference is too limiting.<br></p><p>&gt; I’m saying it does matter in that it means the aggregate is no longer<br>&gt; logically isolated because shared mutable state is reachable through<br>&gt; the aggregate.  Therefore it is not isolated in that way that I was<br>&gt; intending to describe.<br></p><p>This, again, is a matter of your mental model.  I do think it&#39;s<br>reasonable to say that—especially in Swift where reference-ness is often<br>syntactically invisible—asking people to adopt a mental model that<br>*directly* treats references as values is simply unrealistic.  In that<br>case, using some kind of wrapper to represent object identity might be<br>the only practical way to do this.<br></p><p>&gt;&gt;&gt; To be honest, I am really struggling to understand why this<br>&gt;&gt;&gt; distinction seems unimportant to you.<br>&gt;&gt; <br>&gt;&gt; The non-exposure of shared mutable state is a hugely important<br>&gt;&gt; property of well-encapsulated design.  However, I don&#39;t believe it&#39;s<br>&gt;&gt; appropriate to represent that with a protocol, because I don&#39;t<br>&gt;&gt; believe there exist any generic components whose correctness depends<br>&gt;&gt; on it.<br>&gt;<br>&gt; Do you believe it is appropriate to represent this in some other way<br>&gt; that allows us to state architectural intent and introduce constraints<br>&gt; for the purpose of structuring a large code base?<br></p><p>Sure, if it makes your life better, you should define it; I just don&#39;t<br>see yet that it has any place in the standard library.  It is a<br>principle of generic programming that protocols (concepts) are<br>*discovered* through a specific process.  In the standard library, we<br>don&#39;t define a new protocol until we have identified a family of<br>concrete components that can be generalized based that protocol and<br>whose correctness depends on the protocol&#39;s constraints.<br></p><p>HTH,<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 23, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 23, 2016, at 9:22 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sun May 22 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On May 22, 2016, at 3:42 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Sun May 22 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What I am arguing for is the ability to distinguish aggregates which<br>&gt;&gt;&gt;&gt; are logically isolated from aggregates which contain salient<br>&gt;&gt;&gt;&gt; references to shared mutable state. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Everything with value semantics is logically isolated in that way.<br>&gt;&gt; <br>&gt;&gt; Array&lt;UIView&gt; has salient references whose referent is shared mutable<br>&gt;&gt; state.  The references are salient attributes. You’re saying the<br>&gt;&gt; referent doesn’t matter because the boundary of the value stops at the<br>&gt;&gt; reference.  <br>&gt; <br>&gt; I&#39;m saying you can define things that way, and it helps to make the<br>&gt; model for generic programming coherent.  Without something like this, it<br>&gt; becomes almost impossible to specify the behavior of generic components<br>&gt; in an understandable way without simultaneously preventing the use of<br>&gt; reference values as simple object identities, which *are* values.  As I<br>&gt; mentioned elsewhere, we could force users to wrap these reference values<br>&gt; to produce something that doesn&#39;t have easily identifiable reference<br>&gt; semantics, but the requirement of your `PureValue` that there should be<br>&gt; *no way* to derive access to the referenced instance from the wrapped<br>&gt; reference is too limiting.<br>&gt; <br>&gt;&gt; I’m saying it does matter in that it means the aggregate is no longer<br>&gt;&gt; logically isolated because shared mutable state is reachable through<br>&gt;&gt; the aggregate.  Therefore it is not isolated in that way that I was<br>&gt;&gt; intending to describe.<br>&gt; <br>&gt; This, again, is a matter of your mental model.  I do think it&#39;s<br>&gt; reasonable to say that—especially in Swift where reference-ness is often<br>&gt; syntactically invisible—asking people to adopt a mental model that<br>&gt; *directly* treats references as values is simply unrealistic.  In that<br>&gt; case, using some kind of wrapper to represent object identity might be<br>&gt; the only practical way to do this.<br></p><p>I think the lack of syntax is a good point.  I have wondered how this would play out in Swift.<br></p><p>However, I think it goes deeper than just being syntactically invisible.  If Swift used C-like pointer syntax that would give us a syntactic distinction but not a semantic one.<br></p><p>Consider your `Set&lt;DrawableObject&gt;` example.  In this case, maybe you really do just care about object identity so you can test set membership.  In this case you really are just viewing the references as values.  In this case you really do view `Set&lt;DrawableObject&gt;` as a pure value.<br></p><p>Consider another example - an `Order` with an `Array&lt;LineItem&gt;`.  In this case, you are looking at the array as a part of an aggregate.  You don’t care about the values of the references at all, except as a means to get you the object.  In this case `Array&lt;LineItem&gt;` isn’t a pure value (if `LineItem` is a type with reference semantics).<br></p><p>If we simply referred to all reference types with `*DrawableObject` syntax we would have to do that in both `Set&lt;*DrawableObject&gt;` and `Array&lt;*LineItem&gt;`.  The semantic distinction isn’t captured.<br></p><p>However, if we use an opaque wrapper type like you suggest we actually *can* capture the distinction.  We can say `Set&lt;Identity&lt;DrawableObject&gt;&gt;`.  It would be perfectly acceptable to me to view this as a pure value because it is clear that you are only looking at the value of the reference, not actually following the reference.  And if we really needed to include “unsafeDereference” or something like that for performance reasons I could probably live with that.  At least your intention is explicit.  If desired we could even introduce syntactic sugar for this wrapper like we have for `Optional`, `Array`, and `Dictionary` so you can talk about it more concisely.<br></p><p><br>&gt; <br>&gt;&gt;&gt;&gt; To be honest, I am really struggling to understand why this<br>&gt;&gt;&gt;&gt; distinction seems unimportant to you.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The non-exposure of shared mutable state is a hugely important<br>&gt;&gt;&gt; property of well-encapsulated design.  However, I don&#39;t believe it&#39;s<br>&gt;&gt;&gt; appropriate to represent that with a protocol, because I don&#39;t<br>&gt;&gt;&gt; believe there exist any generic components whose correctness depends<br>&gt;&gt;&gt; on it.<br>&gt;&gt; <br>&gt;&gt; Do you believe it is appropriate to represent this in some other way<br>&gt;&gt; that allows us to state architectural intent and introduce constraints<br>&gt;&gt; for the purpose of structuring a large code base?<br>&gt; <br>&gt; Sure, if it makes your life better, you should define it; I just don&#39;t<br>&gt; see yet that it has any place in the standard library.  It is a<br>&gt; principle of generic programming that protocols (concepts) are<br>&gt; *discovered* through a specific process.  In the standard library, we<br>&gt; don&#39;t define a new protocol until we have identified a family of<br>&gt; concrete components that can be generalized based that protocol and<br>&gt; whose correctness depends on the protocol&#39;s constraints.<br></p><p>I hope I am not coming across like I believe we should introduce this right now, or like I am attached to the specific mechanism of a PureValue protocol.  I am trying to advocate that there should be a long term goal in Swift that allows us to talk about types from which you cannot reach shared mutable state, hopefully have these types verified by the compiler, and use this as a generic constraint.  I could easily see the mechanism being at the language level: `pure struct`, `pure enum` and a `pure` protocol constraint similar to the `class` protocol constraint we have today (and of course `pure func` as well).  I know this is not going to happen in Swift 3 and probably not Swift 4, but I do think it is a very worthwhile goal.<br></p><p>Going on a tangent a bit.  I agree with the general goal of keeping the standard library very focused.  On the other hand, I do think this criteria for protocols is a bit to restrictive.  How do you define the criteria for whether a type gets into the standard library or not?  Why not just use that same criteria for protocols?  If it would be very useful to the Swift community to share a common protocol that is always available why would it be excluded just because no component of the standard library depends on that protocol for its correctness? <br></p><p>A good example of this is the `Map` protocol that came up recently.  It is reasonably common to have code which only depends on the ability to read and / or write to a key value data structure and doesn’t need to be concerned with the underlying implementation.  It can be very useful to use a `Map` abstraction to hide the implementation.  The standard library includes types that could conform to this protocol.  It seems to me like a good idea to include a protocol like this in the standard library even if the implementation of its components does not depend on this protocol for correctness.<br></p><p>&gt; <br>&gt; HTH,<br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/c0df99b6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
