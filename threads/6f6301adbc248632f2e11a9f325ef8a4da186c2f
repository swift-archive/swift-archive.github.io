<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Idea] catching functions for composable and cps error handling</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 16, 2015 at 11:00:00pm</p></header><div class="content"><p>I came up with an interesting idea that might make a nice enhancement to Swift’s current error handling.  I’m curious to see whether others think it is worth pursuing or not.<br></p><p>There are two motivating examples for this.  It could provide the obvious way to flow errors through code written in continuation passing style (whether asynchronous or not).  It could also provide a way to abstract over common error handling code.<br></p><p>The basic idea is to allow catching functions that would be a complement to throwing functions.  Catching functions would have one or more catch blocks at the top level and could also accept arguments:<br></p><p>func handler(int i: Int, str: String) catches {<br>  // i and str are in scope<br>} catch VendingMachineError.InvalidSelection {<br>  // i and str are not in scope<br>} catch VendingMachineError.OutOfStock {<br>  // i and str are not in scope<br>}<br></p><p><br>The function could be called as normal: <br>handler(int: 1, str: “”)  <br></p><p>In this case the body would be executed.<br></p><p>The function could also be called with a “catch” clause: <br>handler(catch VendingMachineError.InvalidSelection)<br></p><p>In this case the top level catch clauses would be evaluated as if they part of a do-catch statement in which an error was thrown.<br></p><p>Note that there is no colon after the `catch` in the function call.  This would avoid conflicting with a potential argument named catch and would also call attention to the fact that it is not a normal argument.  I don’t think 	`throw` would be appropriate here as that could be ambiguous if the function containing the call to `handler` was a throwing function and also because an error would not be thrown up the stack, but rather caught directly by `handler`.<br></p><p>It may be worthwhile to consider requiring a catching function to handle all errors if it wishes to return a value so that it is able to return a value when catching an error no matter what the error is.  <br></p><p>Alternatively, (and maybe more interesting) since the compiler knows at the call site whether the function was provided regular arguments or an error to catch these two cases could be handled independently, with the body returning a value and the result of a “catching” call returning a value indicating whether the error was handled or not (or something similar).<br></p><p><br>Here is how this would look when it is applied to the motivating examples.  <br></p><p>First is a cps example using a catching closure.<br></p><p>// @exhaustive requires the catching function to catch all errors<br>func cps(then: Int -&gt; () @exhaustive catches) {<br>  if (checkSomeState) {<br>    then(42)<br>  } else {<br>    then(catch VendingMachineError.InvalidSelection)<br>  }<br>}<br></p><p>cps() { i: Int in<br>  // do some work using i<br>} catch VendingMachineError.InvalidSelection {<br>  // handle the error, i is not in scope<br>} catch VendingMachineError.OutOfStock {<br>  // handle the error, i is not in scope<br>} catch {<br>  // handle all other errors<br>}<br></p><p>Second is an example showing how this could be used to abstract over error handling logic:<br></p><p>func handler() catches {<br>catch VendingMachineError.InvalidSelection {<br>  // some common code handling InvalidSelection<br>catch VendingMachineError.OutOfStock {<br>  // some common code handling OutOfStock<br>// handle some other cases as well<br>}<br></p><p>func doSomething() {<br></p><p>  do {<br></p><p>    try someThrowingFunction()<br></p><p>  } catch handler { // compiler inserts call: handler(catch errorThatWasThrown)<br></p><p>    // not sure if a body would make sense here<br>    // if it does it would only be executed when handler actually handled the error<br></p><p>  // we only proceed to the next case if handler did not handle the error<br>  } catch VendingMachineError.InsufficientFunds(let coinsNeeded) {<br></p><p>  // we can provide arguments to the error handling logic by calling a function that returns a catching closure<br>  } catch someFunctionReturningAClosureThatCatches(arg: someValueDeterminingHowToHandleErrors)<br>  }<br></p><p>}<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/6f636c2f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal Idea] catching functions for composable and cps error handling</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 16, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; The basic idea is to allow catching functions that would be a complement to throwing functions.<br></p><p>I have an enormous proposal on the subject of formalizing completion handlers which includes catching functions. I haven’t posted it because I figured it’d be out of scope for Swift 3, but I can if there’s interest.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Idea] catching functions for composable and cps error handling</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 17, 2015 at 09:00:00am</p></header><div class="content"><p>I am definitely interested in seeing your proposal if you’ve already written it.<br></p><p>Async / concurrency, etc is explicitly out of scope.  I think features like catching functions which have applications in asynchronous code but do not specifically address concurrency, synchronization, etc are at least worth discussing unless / until the core team specifically rules them out.  My thought is that catching functions could be a natural evolution of the error handling introduced in Swift 2.<br></p><p>&gt; On Dec 16, 2015, at 11:42 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; The basic idea is to allow catching functions that would be a complement to throwing functions.<br>&gt; <br>&gt; I have an enormous proposal on the subject of formalizing completion handlers which includes catching functions. I haven’t posted it because I figured it’d be out of scope for Swift 3, but I can if there’s interest.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal Idea] catching functions for composable and cps error handling</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 17, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; I am definitely interested in seeing your proposal if you’ve already written it.<br></p><p>[Proposal follows.]<br></p><p><br></p><p>Swift 2 codified error parameters, turning them into a language feature with dedicated syntax. I think most people are pretty happy with that. Everyone wants to do the same for async APIs, replacing the pyramids of nested completion handlers with something more sensible. But this is a difficult problem and will take time to figure out.<br></p><p>In the mean time, though, I think we can improve tremendously on completion handlers by codifying them and giving them dedicated syntax. And it won’t really change our eventual pyramid-of-doom replacement. There are hundreds of existing APIs which use completion handlers; whatever we come up with in the future will have to be compatible with them, and therefore, with this proposal.<br></p><p>My proposal comes in three parts.<br></p><p><br></p><p>CATCHING FUNCTIONS<br>----------------------------------<br></p><p>A function type can be marked as `catching`.<br></p><p>	catching T -&gt; U<br></p><p>A catching function or closure has one or more `catch` blocks appended to it.<br></p><p>	func foo() {<br>		// Normal, non-error behavior<br>	}<br>	catch {<br>		// Handle errors thrown to this function<br>		// Possible point of confusion: errors thrown *in* the main body of foo() do *not* go here.<br>	}<br></p><p>	cloudKitQueryOp.queryCompletionBlock = { cursor in<br>		// non-error behavior<br>	}<br>	catch CKErrorCode.NotAuthenticated {<br>		nagUserToEnableCloud()<br>	}<br>	catch CKErrorCode.RequestRateLimited {<br>		retryLater()<br>	}<br>	catch {<br>		displayCloudError(error)<br>	}<br></p><p>Catching functions must be exhaustive (i.e. must include a plain `catch` block), with two exceptions to be described later.<br></p><p>Catch blocks have the same return type as the regular block of their function. For instance, the catch blocks of a `catching Void -&gt; Int` must return `Int`s. If the function is marked `throws`, then the catch blocks can `throw`.<br></p><p>	func convertOnlyCloudErrors() throws -&gt; String {<br>		return “OK”<br>	}<br>	catch let error as CKErrorCode {<br>		return error.description<br>	}<br>	catch {<br>		throw error<br>	}<br></p><p>Here’s the first exception to catch exhaustiveness: a `catching throws` function has an implicit `catch { throw error }` block added if necessary. So that second catch block in the previous example is redundant.<br></p><p>To call the function normally, just…call it normally.<br></p><p>	foo()<br>	cloudKitQueryOp.queryCompletionBlock!(cursor)<br></p><p>To send an error to it, use one of these:<br></p><p>	foo(throw error)<br>	foo(try someOperationThatMightFail())		// unconditionally calls foo() with the result, whether error or datum<br>	foo(try? someOperationThatMightFail())		// if an error is thrown, calls foo with the error and returns nil; if not, returns the result of the operation without calling foo<br></p><p>I’m not totally satisfied with this syntax, and we should probably try to come up with something better. BUT NOT RIGHT NOW. Bikeshedding can wait.<br></p><p>One issue with this is the question of whether a `throw` or non-optional `try` with a catching function implicitly `return`s immediately after calling the catching function. My current thinking is that it does *not* cause an immediate return, so you can come up with a return value yourself. But this is not entirely satisfying.<br></p><p>To Objective-C, a catching function is a block with the same parameters, only nullable, followed by a nullable NSError. If there are no parameters, then an initial BOOL parameter is inserted.<br></p><p>	@property (nonatomic, copy, nullable) void (^queryCompletionBlock)(CKQueryCursor * __nullable cursor, NSError * __nullable operationError); <br>	var queryCompletionBlock: (catching CKQueryCursor -&gt; Void)?<br></p><p><br></p><p>ONCE ATTRIBUTE<br>--------------------------<br></p><p>This one is not strictly necessary, but it&#39;s very helpful for safety.<br></p><p>The `@once` attribute on a function-typed parameter indicates that the parameter will be called exactly once. Not zero times, not two times. Thrice is right out. Throwing to a catching function counts as “calling” it.<br></p><p>	func tooMany(@once fn: Void -&gt; Void) {<br>		fn()<br>		fn()<br>	}<br>	func tooFew(@once fn: Void -&gt; Void) {<br>	}<br>	func justRight(@once fn: Void -&gt; Void) {<br>		fn()<br>	}<br></p><p>@once makes no guarantees about *when* the parameter will be called; it does not imply @noescape. It may be called asynchronously, after the function it’s passed to has finished executing. But it will still be called exactly once.<br></p><p>To the extent possible, swiftc should try to validate that the parameter really is called exactly once. Obviously, this won’t be possible if the parameter is called in a closure, unless that closure is passed to a parameter which is itself marked @once.<br></p><p>Note: It may be desirable to apply @once to function-typed properties as well—NSOperation and CloudKit’s NSOperation subclasses could certainly use it.<br></p><p><br></p><p>ASYNC FUNCTIONS<br>-----------------------------<br></p><p>A function may be marked `async`. This keyword goes after the argument list, but before `throws` or the return type arrow. An `async` function is simply one that takes a completion handler. So these two are equivalent:<br></p><p>	func fetch() async<br>	func fetch(@once completion: Void -&gt; Void)<br></p><p>You can probably say `async(bar)` to rename the completion argument to `bar`, and `async(bar baz)` to name the variable `baz` and the keyword `bar`. Whatever—it’s not very important.<br></p><p>The `async` keyword is magical in that it hijacks the function’s return type, turning it into an argument to the completion. So these two are equivalent:<br></p><p>	func fetch() async -&gt; MyRecord<br>	func fetch(@once completion: MyRecord -&gt; Void)<br></p><p>It also hijacks the `throws` specifier, turning it into a `catching` specifier on the completion. So these two are equivalent:<br></p><p>	func delete() async throws<br>	func delete(@once completion: catching Void -&gt; Void)<br></p><p>As are these:<br></p><p>	func fetch() async throws -&gt; MyRecord<br>	func fetch(@once completion: catching MyRecord -&gt; Void)<br></p><p>Inside the body of an `async throws` function, all errors thrown with `try` or `throw`, and otherwise not caught by anything, are implicitly directed to `completion`.<br></p><p>	func fetch() async throws -&gt; MyRecord {<br>		guard let recordURL = recordURL else {<br>			throw MyRecordError.NoRecordURL	// this is really `completion(throw MyRecordError.NoRecordURL); return`<br>		}<br>		<br>		fetchURL(recordURL) { data in<br>			let record = try MyRecord(data: data)	// this is really something like `let record = completion(try? MyRecord(data: data)) ?? return`<br>			completion(record)<br>		}<br>		catch {<br>			throw error	// this is also really `completion(throw error); return`<br>		}<br>	}<br></p><p>Note that this occurs even in the main body of the async function. That means the completion may be called before the async function returns.<br></p><p>Remember how I said there was a second exception to the rule that `catching` functions must have an exhaustive set of `catch` clauses? That exception is inside an `async throws` function. There, they automatically have a `catch { completion(throw error) }` clause added. To indicate this hidden `throw`, however, you have to add `try` to the statement that creates the closure. So the above could have been written:<br></p><p>	func fetch() async throws -&gt; MyRecord {<br>		try fetchURL(recordURL) { data in<br>			let record = try MyRecord(data: data)<br>			completion(record)<br>		}<br>		// Look, Ma, no catch!<br>	}<br></p><p>At the site where an `async` function is called, absolutely nothing changes. It is exactly equivalent to the completion-block form.<br></p><p>Objective-C APIs with a trailing block parameter labeled `completion` or `completionHandler` should have `@once` implicitly added to this parameter, allowing them to be treated as `async` methods.<br></p><p><br></p><p>CONCLUSION<br>--------------------<br></p><p>This proposal radically improves the experience of creating an asynchronous call by formalizing the notion of a function which takes a result-or-error, hugely reducing the amount of boilerplate involved in defining an async function, and introducing new safety checks to help you ensure you return data properly from an async function. It even improves the call site modestly by better organizing error-handling code. And it doesn’t interfere with any future work on new ways of representing calls to asynchronous functions.<br></p><p><br></p><p><br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Idea] catching functions for composable and cps error handling</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 17, 2015 at 10:00:00am</p></header><div class="content"><p>Brent, thanks for sharing this.  It’s interesting that we independently came up with such similar approaches.  That seems to indicate that it is definitely worthy of consideration.<br></p><p>IMO your proposal is actually three proposals.  I obviously think “catching functions” might have a chance for consideration right now.  I also think @once is a very good idea and probably has a good chance for consideration as an independent proposal.  Obviously async is going to have to wait.<br></p><p>I’m going to comment on differences between our approaches to catching functions and include the rationale for my decisions.  I hope you will do the same and maybe we can reach a consensus on the best approach.<br></p><p>&gt; A function type can be marked as `catching`.<br>&gt; <br>&gt; 	catching T -&gt; U<br></p><p>I prefer the T -&gt; U catches syntax as it more closely matches the syntax for throws, but the syntax is the least important part of this to me and I would be happy with anything sensible.<br></p><p>&gt; Catching functions must be exhaustive (i.e. must include a plain `catch` block), with two exceptions to be described later.<br></p><p>Rather than requiring this I introduced an @exhaustive attribute that can be specified when required, as well as the ability of the caller to find out whether the error was handled or not.  I did this partly because of the comparability use case and partly because it affords more flexibility without losing the exhaustive behavior when that is necessary.<br></p><p>&gt; Catch blocks have the same return type as the regular block of their function. For instance, the catch blocks of a `catching Void -&gt; Int` must return `Int`s. If the function is marked `throws`, then the catch blocks can `throw`.<br>&gt; <br>&gt; 	func convertOnlyCloudErrors() throws -&gt; String {<br>&gt; 		return “OK”<br>&gt; 	}<br>&gt; 	catch let error as CKErrorCode {<br>&gt; 		return error.description<br>&gt; 	}<br>&gt; 	catch {<br>&gt; 		throw error<br>&gt; 	}<br></p><p>Did you intend to mark this function as `catching`?  I’ll assume so as it includes top level `catch` clauses.  <br></p><p>This approach is reasonable, but I’m interested in hearing what you think of the other alternative I explored which goes hand-in-hand with non-exhaustive catching functions.<br></p><p><br>&gt; Here’s the first exception to catch exhaustiveness: a `catching throws` function has an implicit `catch { throw error }` block added if necessary. So that second catch block in the previous example is redundant.<br></p><p>I don’t like this.  I think it is better to keep things explicit.  It would also preclude non-exhaustive `catching` functions which I think have interesting use cases.<br></p><p>&gt; <br>&gt; To call the function normally, just…call it normally.<br>&gt; <br>&gt; 	foo()<br>&gt; 	cloudKitQueryOp.queryCompletionBlock!(cursor)<br>&gt; <br>&gt; To send an error to it, use one of these:<br>&gt; <br>&gt; 	foo(throw error)<br>&gt; 	foo(try someOperationThatMightFail())		// unconditionally calls foo() with the result, whether error or datum<br>&gt; 	foo(try? someOperationThatMightFail())		// if an error is thrown, calls foo with the error and returns nil; if not, returns the result of the operation without calling foo<br>&gt; <br>&gt; I’m not totally satisfied with this syntax, and we should probably try to come up with something better. BUT NOT RIGHT NOW. Bikeshedding can wait.<br></p><p>I don’t mean to bikeshed but I do think this particular syntax has serious problems:<br></p><p>func bar() throws {<br>  // in both cases, should the error be thrown or caught by foo?<br>  foo(throw error) <br>  foo(try someOperationThatMightFail())<br>}<br></p><p>It might be possible to define this problem away, but even then you would not know the answer without knowing the signature of `foo`.  That is really bad for readability.  <br></p><p>What do you think of the syntax I used, which is similar to yours while avoiding these issues?<br></p><p>foo(catch error) <br></p><p><br>&gt; One issue with this is the question of whether a `throw` or non-optional `try` with a catching function implicitly `return`s immediately after calling the catching function. My current thinking is that it does *not* cause an immediate return, so you can come up with a return value yourself. But this is not entirely satisfying.<br></p><p>This is only a problem because your syntax overloaded the existing throw and try keywords and because of that introduced semantic confusion.<br></p><p>&gt; To Objective-C, a catching function is a block with the same parameters, only nullable, followed by a nullable NSError. If there are no parameters, then an initial BOOL parameter is inserted.<br>&gt; <br>&gt; 	@property (nonatomic, copy, nullable) void (^queryCompletionBlock)(CKQueryCursor * __nullable cursor, NSError * __nullable operationError); <br>&gt; 	var queryCompletionBlock: (catching CKQueryCursor -&gt; Void)?<br></p><p>Glad to see you address Objective-C interop.  I hadn’t considered that yet.<br></p><p>Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19e063a2e39db5f58ed5ab02d14c1879?s=50"></div><header><strong>[Proposal Idea] catching functions for composable and cps error handling</strong> from <string>Matthew Johnson</string> &lt;musical.matthew at mac.com&gt;<p>December 18, 2015 at 10:00:00am</p></header><div class="content"><p>I’m bumping this post in case you missed it Brent.  I would find any comments you have on the differences between our approaches very interesting.  Thanks!<br></p><p>&gt; On Dec 17, 2015, at 10:36 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Brent, thanks for sharing this.  It’s interesting that we independently came up with such similar approaches.  That seems to indicate that it is definitely worthy of consideration.<br>&gt; <br>&gt; IMO your proposal is actually three proposals.  I obviously think “catching functions” might have a chance for consideration right now.  I also think @once is a very good idea and probably has a good chance for consideration as an independent proposal.  Obviously async is going to have to wait.<br>&gt; <br>&gt; I’m going to comment on differences between our approaches to catching functions and include the rationale for my decisions.  I hope you will do the same and maybe we can reach a consensus on the best approach.<br>&gt; <br>&gt;&gt; A function type can be marked as `catching`.<br>&gt;&gt; <br>&gt;&gt; 	catching T -&gt; U<br>&gt; <br>&gt; I prefer the T -&gt; U catches syntax as it more closely matches the syntax for throws, but the syntax is the least important part of this to me and I would be happy with anything sensible.<br>&gt; <br>&gt;&gt; Catching functions must be exhaustive (i.e. must include a plain `catch` block), with two exceptions to be described later.<br>&gt; <br>&gt; Rather than requiring this I introduced an @exhaustive attribute that can be specified when required, as well as the ability of the caller to find out whether the error was handled or not.  I did this partly because of the comparability use case and partly because it affords more flexibility without losing the exhaustive behavior when that is necessary.<br>&gt; <br>&gt;&gt; Catch blocks have the same return type as the regular block of their function. For instance, the catch blocks of a `catching Void -&gt; Int` must return `Int`s. If the function is marked `throws`, then the catch blocks can `throw`.<br>&gt;&gt; <br>&gt;&gt; 	func convertOnlyCloudErrors() throws -&gt; String {<br>&gt;&gt; 		return “OK”<br>&gt;&gt; 	}<br>&gt;&gt; 	catch let error as CKErrorCode {<br>&gt;&gt; 		return error.description<br>&gt;&gt; 	}<br>&gt;&gt; 	catch {<br>&gt;&gt; 		throw error<br>&gt;&gt; 	}<br>&gt; <br>&gt; Did you intend to mark this function as `catching`?  I’ll assume so as it includes top level `catch` clauses.  <br>&gt; <br>&gt; This approach is reasonable, but I’m interested in hearing what you think of the other alternative I explored which goes hand-in-hand with non-exhaustive catching functions.<br>&gt; <br>&gt; <br>&gt;&gt; Here’s the first exception to catch exhaustiveness: a `catching throws` function has an implicit `catch { throw error }` block added if necessary. So that second catch block in the previous example is redundant.<br>&gt; <br>&gt; I don’t like this.  I think it is better to keep things explicit.  It would also preclude non-exhaustive `catching` functions which I think have interesting use cases.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; To call the function normally, just…call it normally.<br>&gt;&gt; <br>&gt;&gt; 	foo()<br>&gt;&gt; 	cloudKitQueryOp.queryCompletionBlock!(cursor)<br>&gt;&gt; <br>&gt;&gt; To send an error to it, use one of these:<br>&gt;&gt; <br>&gt;&gt; 	foo(throw error)<br>&gt;&gt; 	foo(try someOperationThatMightFail())		// unconditionally calls foo() with the result, whether error or datum<br>&gt;&gt; 	foo(try? someOperationThatMightFail())		// if an error is thrown, calls foo with the error and returns nil; if not, returns the result of the operation without calling foo<br>&gt;&gt; <br>&gt;&gt; I’m not totally satisfied with this syntax, and we should probably try to come up with something better. BUT NOT RIGHT NOW. Bikeshedding can wait.<br>&gt; <br>&gt; I don’t mean to bikeshed but I do think this particular syntax has serious problems:<br>&gt; <br>&gt; func bar() throws {<br>&gt;  // in both cases, should the error be thrown or caught by foo?<br>&gt;  foo(throw error) <br>&gt;  foo(try someOperationThatMightFail())<br>&gt; }<br>&gt; <br>&gt; It might be possible to define this problem away, but even then you would not know the answer without knowing the signature of `foo`.  That is really bad for readability.  <br>&gt; <br>&gt; What do you think of the syntax I used, which is similar to yours while avoiding these issues?<br>&gt; <br>&gt; foo(catch error) <br>&gt; <br>&gt; <br>&gt;&gt; One issue with this is the question of whether a `throw` or non-optional `try` with a catching function implicitly `return`s immediately after calling the catching function. My current thinking is that it does *not* cause an immediate return, so you can come up with a return value yourself. But this is not entirely satisfying.<br>&gt; <br>&gt; This is only a problem because your syntax overloaded the existing throw and try keywords and because of that introduced semantic confusion.<br>&gt; <br>&gt;&gt; To Objective-C, a catching function is a block with the same parameters, only nullable, followed by a nullable NSError. If there are no parameters, then an initial BOOL parameter is inserted.<br>&gt;&gt; <br>&gt;&gt; 	@property (nonatomic, copy, nullable) void (^queryCompletionBlock)(CKQueryCursor * __nullable cursor, NSError * __nullable operationError); <br>&gt;&gt; 	var queryCompletionBlock: (catching CKQueryCursor -&gt; Void)?<br>&gt; <br>&gt; Glad to see you address Objective-C interop.  I hadn’t considered that yet.<br>&gt; <br>&gt; Matthew<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal Idea] catching functions for composable and cps error handling</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 17, 2015 at 07:00:00am</p></header><div class="content"><p>What about just writing the following (see below)? To enable the same behaviour we would have to add non-local return which would be nice for other reasons. <br></p><p>func handler&lt;T&gt;(block: () -&gt; T) rethrows {<br>        do {<br>                let result = try block()<br>                return result<br>        } catch VendingMachineError .InvalidSelection {<br>                // some common code handling InvalidSelection<br>        } catch VendingMachineError.OutOfStock {<br>               // some common code handling OutOfStock<br>               // handle some other cases as well<br>        }<br>}<br></p><p>func doSomething() {<br>        do {<br>                handler {<br>                        try someThrowingFunction()<br>                }<br>        } catch VendingMachineError.InsufficientFunds(let coinsNeeded) {<br>                // special case handled here<br>        }<br>}<br></p><p>For covering your third case using a handler function with an argument, you could add an argument to the func handler.<br>For chaining handler functions you could introduce an operator for composing handler functions.<br></p><p>-Thorsten<br></p><p>&gt; Am 17.12.2015 um 06:27 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I came up with an interesting idea that might make a nice enhancement to Swift’s current error handling.  I’m curious to see whether others think it is worth pursuing or not.<br>&gt; <br>&gt; There are two motivating examples for this.  It could provide the obvious way to flow errors through code written in continuation passing style (whether asynchronous or not).  It could also provide a way to abstract over common error handling code.<br>&gt; <br>&gt; The basic idea is to allow catching functions that would be a complement to throwing functions.  Catching functions would have one or more catch blocks at the top level and could also accept arguments:<br>&gt; <br>&gt; func handler(int i: Int, str: String) catches {<br>&gt;   // i and str are in scope<br>&gt; } catch VendingMachineError.InvalidSelection {<br>&gt;   // i and str are not in scope<br>&gt; } catch VendingMachineError.OutOfStock {<br>&gt;   // i and str are not in scope<br>&gt; }<br>&gt; <br>&gt; <br>&gt; The function could be called as normal: <br>&gt; handler(int: 1, str: “”)  <br>&gt; <br>&gt; In this case the body would be executed.<br>&gt; <br>&gt; The function could also be called with a “catch” clause: <br>&gt; handler(catch VendingMachineError.InvalidSelection)<br>&gt; <br>&gt; In this case the top level catch clauses would be evaluated as if they part of a do-catch statement in which an error was thrown.<br>&gt; <br>&gt; Note that there is no colon after the `catch` in the function call.  This would avoid conflicting with a potential argument named catch and would also call attention to the fact that it is not a normal argument.  I don’t think 	`throw` would be appropriate here as that could be ambiguous if the function containing the call to `handler` was a throwing function and also because an error would not be thrown up the stack, but rather caught directly by `handler`.<br>&gt; <br>&gt; It may be worthwhile to consider requiring a catching function to handle all errors if it wishes to return a value so that it is able to return a value when catching an error no matter what the error is.  <br>&gt; <br>&gt; Alternatively, (and maybe more interesting) since the compiler knows at the call site whether the function was provided regular arguments or an error to catch these two cases could be handled independently, with the body returning a value and the result of a “catching” call returning a value indicating whether the error was handled or not (or something similar).<br>&gt; <br>&gt; <br>&gt; Here is how this would look when it is applied to the motivating examples.  <br>&gt; <br>&gt; First is a cps example using a catching closure.<br>&gt; <br>&gt; // @exhaustive requires the catching function to catch all errors<br>&gt; func cps(then: Int -&gt; () @exhaustive catches) {<br>&gt;   if (checkSomeState) {<br>&gt;     then(42)<br>&gt;   } else {<br>&gt;     then(catch VendingMachineError.InvalidSelection)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; cps() { i: Int in<br>&gt;   // do some work using i<br>&gt; } catch VendingMachineError.InvalidSelection {<br>&gt;   // handle the error, i is not in scope<br>&gt; } catch VendingMachineError.OutOfStock {<br>&gt;   // handle the error, i is not in scope<br>&gt; } catch {<br>&gt;   // handle all other errors<br>&gt; }<br>&gt; <br>&gt; Second is an example showing how this could be used to abstract over error handling logic:<br>&gt; <br>&gt; func handler() catches {<br>&gt; catch VendingMachineError .InvalidSelection {<br>&gt;   // some common code handling InvalidSelection<br>&gt; catch VendingMachineError.OutOfStock {<br>&gt;   // some common code handling OutOfStock<br>&gt; // handle some other cases as well<br>&gt; }<br>&gt; <br>&gt; func doSomething() {<br>&gt; <br>&gt;   do {<br>&gt; <br>&gt;     try someThrowingFunction()<br>&gt; <br>&gt;   } catch handler { // compiler inserts call: handler(catch errorThatWasThrown)<br>&gt; <br>&gt;     // not sure if a body would make sense here<br>&gt;     // if it does it would only be executed when handler actually handled the error<br>&gt; <br>&gt;   // we only proceed to the next case if handler did not handle the error<br>&gt;   } catch VendingMachineError.InsufficientFunds(let coinsNeeded) {<br>&gt; <br>&gt;   // we can provide arguments to the error handling logic by calling a function that returns a catching closure<br>&gt;   } catch someFunctionReturningAClosureThatCatches(arg: someValueDeterminingHowToHandleErrors)<br>&gt;   }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/522127b2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Idea] catching functions for composable and cps error handling</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 17, 2015 at 09:00:00am</p></header><div class="content"><p>Yes of course you can do these things.  And you could use a Result type for error handling before Swift 2.  The problem is that these are ad-hoc approaches and everyone will do it slightly differently.<br></p><p>Error handling is important enough to justify a language feature that aids correctness and establishes a common practice.  This idea may or not be the right solution.  Either way I do believe Swift will be better off with a language level solution.<br></p><p><br>&gt; On Dec 17, 2015, at 12:13 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; What about just writing the following (see below)? To enable the same behaviour we would have to add non-local return which would be nice for other reasons. <br>&gt; <br>&gt; func handler&lt;T&gt;(block: () -&gt; T) rethrows {<br>&gt;         do {<br>&gt;                 let result = try block()<br>&gt;                 return result<br>&gt;         } catch VendingMachineError .InvalidSelection {<br>&gt;                 // some common code handling InvalidSelection<br>&gt;         } catch VendingMachineError.OutOfStock {<br>&gt;                // some common code handling OutOfStock<br>&gt;                // handle some other cases as well<br>&gt;         }<br>&gt; }<br>&gt; <br>&gt; func doSomething() {<br>&gt;         do {<br>&gt;                 handler {<br>&gt;                         try someThrowingFunction()<br>&gt;                 }<br>&gt;         } catch VendingMachineError.InsufficientFunds(let coinsNeeded) {<br>&gt;                 // special case handled here<br>&gt;         }<br>&gt; }<br>&gt; <br>&gt; For covering your third case using a handler function with an argument, you could add an argument to the func handler.<br>&gt; For chaining handler functions you could introduce an operator for composing handler functions.<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; Am 17.12.2015 um 06:27 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; I came up with an interesting idea that might make a nice enhancement to Swift’s current error handling.  I’m curious to see whether others think it is worth pursuing or not.<br>&gt;&gt; <br>&gt;&gt; There are two motivating examples for this.  It could provide the obvious way to flow errors through code written in continuation passing style (whether asynchronous or not).  It could also provide a way to abstract over common error handling code.<br>&gt;&gt; <br>&gt;&gt; The basic idea is to allow catching functions that would be a complement to throwing functions.  Catching functions would have one or more catch blocks at the top level and could also accept arguments:<br>&gt;&gt; <br>&gt;&gt; func handler(int i: Int, str: String) catches {<br>&gt;&gt;   // i and str are in scope<br>&gt;&gt; } catch VendingMachineError.InvalidSelection {<br>&gt;&gt;   // i and str are not in scope<br>&gt;&gt; } catch VendingMachineError.OutOfStock {<br>&gt;&gt;   // i and str are not in scope<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The function could be called as normal: <br>&gt;&gt; handler(int: 1, str: “”)  <br>&gt;&gt; <br>&gt;&gt; In this case the body would be executed.<br>&gt;&gt; <br>&gt;&gt; The function could also be called with a “catch” clause: <br>&gt;&gt; handler(catch VendingMachineError.InvalidSelection)<br>&gt;&gt; <br>&gt;&gt; In this case the top level catch clauses would be evaluated as if they part of a do-catch statement in which an error was thrown.<br>&gt;&gt; <br>&gt;&gt; Note that there is no colon after the `catch` in the function call.  This would avoid conflicting with a potential argument named catch and would also call attention to the fact that it is not a normal argument.  I don’t think 	`throw` would be appropriate here as that could be ambiguous if the function containing the call to `handler` was a throwing function and also because an error would not be thrown up the stack, but rather caught directly by `handler`.<br>&gt;&gt; <br>&gt;&gt; It may be worthwhile to consider requiring a catching function to handle all errors if it wishes to return a value so that it is able to return a value when catching an error no matter what the error is.  <br>&gt;&gt; <br>&gt;&gt; Alternatively, (and maybe more interesting) since the compiler knows at the call site whether the function was provided regular arguments or an error to catch these two cases could be handled independently, with the body returning a value and the result of a “catching” call returning a value indicating whether the error was handled or not (or something similar).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Here is how this would look when it is applied to the motivating examples.  <br>&gt;&gt; <br>&gt;&gt; First is a cps example using a catching closure.<br>&gt;&gt; <br>&gt;&gt; // @exhaustive requires the catching function to catch all errors<br>&gt;&gt; func cps(then: Int -&gt; () @exhaustive catches) {<br>&gt;&gt;   if (checkSomeState) {<br>&gt;&gt;     then(42)<br>&gt;&gt;   } else {<br>&gt;&gt;     then(catch VendingMachineError.InvalidSelection)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; cps() { i: Int in<br>&gt;&gt;   // do some work using i<br>&gt;&gt; } catch VendingMachineError.InvalidSelection {<br>&gt;&gt;   // handle the error, i is not in scope<br>&gt;&gt; } catch VendingMachineError.OutOfStock {<br>&gt;&gt;   // handle the error, i is not in scope<br>&gt;&gt; } catch {<br>&gt;&gt;   // handle all other errors<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Second is an example showing how this could be used to abstract over error handling logic:<br>&gt;&gt; <br>&gt;&gt; func handler() catches {<br>&gt;&gt; catch VendingMachineError .InvalidSelection {<br>&gt;&gt;   // some common code handling InvalidSelection<br>&gt;&gt; catch VendingMachineError.OutOfStock {<br>&gt;&gt;   // some common code handling OutOfStock<br>&gt;&gt; // handle some other cases as well<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func doSomething() {<br>&gt;&gt; <br>&gt;&gt;   do {<br>&gt;&gt; <br>&gt;&gt;     try someThrowingFunction()<br>&gt;&gt; <br>&gt;&gt;   } catch handler { // compiler inserts call: handler(catch errorThatWasThrown)<br>&gt;&gt; <br>&gt;&gt;     // not sure if a body would make sense here<br>&gt;&gt;     // if it does it would only be executed when handler actually handled the error<br>&gt;&gt; <br>&gt;&gt;   // we only proceed to the next case if handler did not handle the error<br>&gt;&gt;   } catch VendingMachineError.InsufficientFunds(let coinsNeeded) {<br>&gt;&gt; <br>&gt;&gt;   // we can provide arguments to the error handling logic by calling a function that returns a catching closure<br>&gt;&gt;   } catch someFunctionReturningAClosureThatCatches(arg: someValueDeterminingHowToHandleErrors)<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/03310253/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
