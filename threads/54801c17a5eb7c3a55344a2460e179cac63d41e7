<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Object declarations</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 11, 2015 at 11:00:00pm</p></header><div class="content"><p>Hey guys,<br></p><p>I am working on a proposal which touches (and could even partially depend<br>on) another interesting concept which I think would be a great addition for<br>Swift.<br></p><p>Object declarations could be a way to declare a class or struct with<br>exactly one instance. They are perfect for singletons, anonymous subclasses<br>and to anonymously implement a protocol.<br></p><p>Here some examples how it could look like:<br></p><p>// singleton<br>object GlobalResource {<br>    func doSomething() { … }<br>}<br></p><p>let resource = GlobalResource<br></p><p>// could all be the same<br>resource.doSomething()<br>GlobalResource.doSomething()<br>GlobalResource.Type.doSomething()<br></p><p><br>// anonymous subclass<br>class ViewController: UIViewController {<br></p><p>    override func loadView() {<br>        view = object: UIView {<br>            // configure view<br>        }<br>    }<br>}<br></p><p><br>// anonymous protocol implementation<br>protocol TapHandler {<br>    func handleTap()<br>}<br></p><p>view.tapHandler = object: TapHandler {<br>    func handleTap() {<br>        // …<br>    }<br>}<br></p><p><br>Kotlin is an example for a a modern language which uses this concept:<br>https://kotlinlang.org/docs/reference/object-declarations.html<br></p><p><br>What do you think about such an addition?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/548041e7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Object declarations</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 11, 2015 at 11:00:00pm</p></header><div class="content"><p>I like it. Just a minor suggestion: as an object is a value and not a type it should have a name starting with lower case, i.e.<br></p><p>object globalResource { ... }<br></p><p>-Thorsten <br></p><p>&gt; Am 11.12.2015 um 23:07 schrieb Marc Knaup via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Hey guys,<br>&gt; <br>&gt; I am working on a proposal which touches (and could even partially depend on) another interesting concept which I think would be a great addition for Swift.<br>&gt; <br>&gt; Object declarations could be a way to declare a class or struct with exactly one instance. They are perfect for singletons, anonymous subclasses and to anonymously implement a protocol.<br>&gt; <br>&gt; Here some examples how it could look like:<br>&gt; <br>&gt; // singleton<br>&gt; object GlobalResource {<br>&gt;     func doSomething() { … }<br>&gt; }<br>&gt; <br>&gt; let resource = GlobalResource<br>&gt; <br>&gt; // could all be the same<br>&gt; resource.doSomething()<br>&gt; GlobalResource.doSomething()<br>&gt; GlobalResource.Type.doSomething()<br>&gt; <br>&gt; <br>&gt; // anonymous subclass<br>&gt; class ViewController: UIViewController {<br>&gt; <br>&gt;     override func loadView() {<br>&gt;         view = object: UIView {<br>&gt;             // configure view<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; // anonymous protocol implementation<br>&gt; protocol TapHandler {<br>&gt;     func handleTap()<br>&gt; }<br>&gt; <br>&gt; view.tapHandler = object: TapHandler {<br>&gt;     func handleTap() {<br>&gt;         // …<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Kotlin is an example for a a modern language which uses this concept:<br>&gt; https://kotlinlang.org/docs/reference/object-declarations.html<br>&gt; <br>&gt; <br>&gt; What do you think about such an addition?<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/5a054e25/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Object declarations</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 11, 2015 at 11:00:00pm</p></header><div class="content"><p>Actually it&#39;s both - an object and a type. It&#39;s an object which describes<br>itself.<br></p><p>Btw. I have the same problem with enum cases. They&#39;re values so why are<br>they uppercase?<br></p><p>On Fri, Dec 11, 2015 at 11:25 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt;<br>wrote:<br></p><p>&gt; I like it. Just a minor suggestion: as an object is a value and not a type<br>&gt; it should have a name starting with lower case, i.e.<br>&gt;<br>&gt; object globalResource { ... }<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt; Am 11.12.2015 um 23:07 schrieb Marc Knaup via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; Hey guys,<br>&gt;<br>&gt; I am working on a proposal which touches (and could even partially depend<br>&gt; on) another interesting concept which I think would be a great addition for<br>&gt; Swift.<br>&gt;<br>&gt; Object declarations could be a way to declare a class or struct with<br>&gt; exactly one instance. They are perfect for singletons, anonymous subclasses<br>&gt; and to anonymously implement a protocol.<br>&gt;<br>&gt; Here some examples how it could look like:<br>&gt;<br>&gt; // singleton<br>&gt; object GlobalResource {<br>&gt;     func doSomething() { … }<br>&gt; }<br>&gt;<br>&gt; let resource = GlobalResource<br>&gt;<br>&gt; // could all be the same<br>&gt; resource.doSomething()<br>&gt; GlobalResource.doSomething()<br>&gt; GlobalResource.Type.doSomething()<br>&gt;<br>&gt;<br>&gt; // anonymous subclass<br>&gt; class ViewController: UIViewController {<br>&gt;<br>&gt;     override func loadView() {<br>&gt;         view = object: UIView {<br>&gt;             // configure view<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; // anonymous protocol implementation<br>&gt; protocol TapHandler {<br>&gt;     func handleTap()<br>&gt; }<br>&gt;<br>&gt; view.tapHandler = object: TapHandler {<br>&gt;     func handleTap() {<br>&gt;         // …<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Kotlin is an example for a a modern language which uses this concept:<br>&gt; https://kotlinlang.org/docs/reference/object-declarations.html<br>&gt;<br>&gt;<br>&gt; What do you think about such an addition?<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/34761033/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Object declarations</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 11, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; Am 11.12.2015 um 23:28 schrieb Marc Knaup &lt;marc at knaup.koeln&gt;:<br>&gt; <br>&gt; Actually it&#39;s both - an object and a type. It&#39;s an object which describes itself.<br></p><p>If it was a type then I would expect to be able to <br>- derive a subclass from it<br>- use it as type in variable or parameter declarations<br></p><p>I don&#39;t think either makes sense, or does it?<br></p><p>&gt; Btw. I have the same problem with enum cases. They&#39;re values so why are they uppercase?<br></p><p>Hmm, good point. Guess I&#39;m just used to it :-)<br></p><p>-Thorsten<br></p><p>&gt;&gt; On Fri, Dec 11, 2015 at 11:25 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; I like it. Just a minor suggestion: as an object is a value and not a type it should have a name starting with lower case, i.e.<br>&gt;&gt; <br>&gt;&gt; object globalResource { ... }<br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt;&gt; Am 11.12.2015 um 23:07 schrieb Marc Knaup via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hey guys,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am working on a proposal which touches (and could even partially depend on) another interesting concept which I think would be a great addition for Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Object declarations could be a way to declare a class or struct with exactly one instance. They are perfect for singletons, anonymous subclasses and to anonymously implement a protocol.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here some examples how it could look like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // singleton<br>&gt;&gt;&gt; object GlobalResource {<br>&gt;&gt;&gt;     func doSomething() { … }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let resource = GlobalResource<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // could all be the same<br>&gt;&gt;&gt; resource.doSomething()<br>&gt;&gt;&gt; GlobalResource.doSomething()<br>&gt;&gt;&gt; GlobalResource.Type.doSomething()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // anonymous subclass<br>&gt;&gt;&gt; class ViewController: UIViewController {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     override func loadView() {<br>&gt;&gt;&gt;         view = object: UIView {<br>&gt;&gt;&gt;             // configure view<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // anonymous protocol implementation<br>&gt;&gt;&gt; protocol TapHandler {<br>&gt;&gt;&gt;     func handleTap()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; view.tapHandler = object: TapHandler {<br>&gt;&gt;&gt;     func handleTap() {<br>&gt;&gt;&gt;         // …<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Kotlin is an example for a a modern language which uses this concept:<br>&gt;&gt;&gt; https://kotlinlang.org/docs/reference/object-declarations.html<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What do you think about such an addition?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/f1aa4ea0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Object declarations</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 11, 2015 at 11:00:00pm</p></header><div class="content"><p>The type is still necessary in various locations:<br></p><p>Generics:<br>let x = SomeGenericClass&lt;SingletonObject&gt;<br></p><p>Type checking:<br>let x: Any = SingletonObject<br>let x: SingletonObject? = x as? SingletonObject<br></p><p>Passing the type dynamically:<br>func foo(type: Any.Type) { … }<br>foo(SingletonObject)<br></p><p>Since there can only be one instance the &quot;object class&quot; (if it isn&#39;t a<br>struct) would be final.<br></p><p>On Fri, Dec 11, 2015 at 11:34 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; Am 11.12.2015 um 23:28 schrieb Marc Knaup &lt;marc at knaup.koeln&gt;:<br>&gt;<br>&gt; Actually it&#39;s both - an object and a type. It&#39;s an object which describes<br>&gt; itself.<br>&gt;<br>&gt;<br>&gt; If it was a type then I would expect to be able to<br>&gt; - derive a subclass from it<br>&gt; - use it as type in variable or parameter declarations<br>&gt;<br>&gt; I don&#39;t think either makes sense, or does it?<br>&gt;<br>&gt; Btw. I have the same problem with enum cases. They&#39;re values so why are<br>&gt; they uppercase?<br>&gt;<br>&gt;<br>&gt; Hmm, good point. Guess I&#39;m just used to it :-)<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt; On Fri, Dec 11, 2015 at 11:25 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; I like it. Just a minor suggestion: as an object is a value and not a<br>&gt;&gt; type it should have a name starting with lower case, i.e.<br>&gt;&gt;<br>&gt;&gt; object globalResource { ... }<br>&gt;&gt;<br>&gt;&gt; -Thorsten<br>&gt;&gt;<br>&gt;&gt; Am 11.12.2015 um 23:07 schrieb Marc Knaup via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt; Hey guys,<br>&gt;&gt;<br>&gt;&gt; I am working on a proposal which touches (and could even partially depend<br>&gt;&gt; on) another interesting concept which I think would be a great addition for<br>&gt;&gt; Swift.<br>&gt;&gt;<br>&gt;&gt; Object declarations could be a way to declare a class or struct with<br>&gt;&gt; exactly one instance. They are perfect for singletons, anonymous subclasses<br>&gt;&gt; and to anonymously implement a protocol.<br>&gt;&gt;<br>&gt;&gt; Here some examples how it could look like:<br>&gt;&gt;<br>&gt;&gt; // singleton<br>&gt;&gt; object GlobalResource {<br>&gt;&gt;     func doSomething() { … }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; let resource = GlobalResource<br>&gt;&gt;<br>&gt;&gt; // could all be the same<br>&gt;&gt; resource.doSomething()<br>&gt;&gt; GlobalResource.doSomething()<br>&gt;&gt; GlobalResource.Type.doSomething()<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; // anonymous subclass<br>&gt;&gt; class ViewController: UIViewController {<br>&gt;&gt;<br>&gt;&gt;     override func loadView() {<br>&gt;&gt;         view = object: UIView {<br>&gt;&gt;             // configure view<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; // anonymous protocol implementation<br>&gt;&gt; protocol TapHandler {<br>&gt;&gt;     func handleTap()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; view.tapHandler = object: TapHandler {<br>&gt;&gt;     func handleTap() {<br>&gt;&gt;         // …<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Kotlin is an example for a a modern language which uses this concept:<br>&gt;&gt; https://kotlinlang.org/docs/reference/object-declarations.html<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; What do you think about such an addition?<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/5de56d4a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Object declarations</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 11, 2015 at 11:00:00pm</p></header><div class="content"><p>You are right! <br>That means can keep the upper case name :-)<br></p><p>-Thorsten <br></p><p>&gt; Am 11.12.2015 um 23:43 schrieb Marc Knaup &lt;marc at knaup.koeln&gt;:<br>&gt; <br>&gt; The type is still necessary in various locations:<br>&gt; <br>&gt; Generics:<br>&gt; let x = SomeGenericClass&lt;SingletonObject&gt;<br>&gt; <br>&gt; Type checking:<br>&gt; let x: Any = SingletonObject<br>&gt; let x: SingletonObject? = x as? SingletonObject<br>&gt; <br>&gt; Passing the type dynamically:<br>&gt; func foo(type: Any.Type) { … }<br>&gt; foo(SingletonObject)<br>&gt; <br>&gt; Since there can only be one instance the &quot;object class&quot; (if it isn&#39;t a struct) would be final.<br>&gt; <br>&gt;&gt; On Fri, Dec 11, 2015 at 11:34 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Am 11.12.2015 um 23:28 schrieb Marc Knaup &lt;marc at knaup.koeln&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Actually it&#39;s both - an object and a type. It&#39;s an object which describes itself.<br>&gt;&gt; <br>&gt;&gt; If it was a type then I would expect to be able to <br>&gt;&gt; - derive a subclass from it<br>&gt;&gt; - use it as type in variable or parameter declarations<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think either makes sense, or does it?<br>&gt;&gt; <br>&gt;&gt;&gt; Btw. I have the same problem with enum cases. They&#39;re values so why are they uppercase?<br>&gt;&gt; <br>&gt;&gt; Hmm, good point. Guess I&#39;m just used to it :-)<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Fri, Dec 11, 2015 at 11:25 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt; I like it. Just a minor suggestion: as an object is a value and not a type it should have a name starting with lower case, i.e.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; object globalResource { ... }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 11.12.2015 um 23:07 schrieb Marc Knaup via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hey guys,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I am working on a proposal which touches (and could even partially depend on) another interesting concept which I think would be a great addition for Swift.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Object declarations could be a way to declare a class or struct with exactly one instance. They are perfect for singletons, anonymous subclasses and to anonymously implement a protocol.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Here some examples how it could look like:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // singleton<br>&gt;&gt;&gt;&gt;&gt; object GlobalResource {<br>&gt;&gt;&gt;&gt;&gt;     func doSomething() { … }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let resource = GlobalResource<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // could all be the same<br>&gt;&gt;&gt;&gt;&gt; resource.doSomething()<br>&gt;&gt;&gt;&gt;&gt; GlobalResource.doSomething()<br>&gt;&gt;&gt;&gt;&gt; GlobalResource.Type.doSomething()<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // anonymous subclass<br>&gt;&gt;&gt;&gt;&gt; class ViewController: UIViewController {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     override func loadView() {<br>&gt;&gt;&gt;&gt;&gt;         view = object: UIView {<br>&gt;&gt;&gt;&gt;&gt;             // configure view<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // anonymous protocol implementation<br>&gt;&gt;&gt;&gt;&gt; protocol TapHandler {<br>&gt;&gt;&gt;&gt;&gt;     func handleTap()<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; view.tapHandler = object: TapHandler {<br>&gt;&gt;&gt;&gt;&gt;     func handleTap() {<br>&gt;&gt;&gt;&gt;&gt;         // …<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Kotlin is an example for a a modern language which uses this concept:<br>&gt;&gt;&gt;&gt;&gt; https://kotlinlang.org/docs/reference/object-declarations.html<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What do you think about such an addition?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/70a73cdc/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Object declarations</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 11, 2015 at 02:00:00pm</p></header><div class="content"><p>-1. Enforced singletons lead to code that can&#39;t be unit-tested. Local types are occasionally convenient and they can&#39;t be unit-tested either, but spending one extra line to name the thing isn&#39;t going to hurt. You also can&#39;t pick an initializer here (at least not in this version).<br></p><p>IMHO, this just adds &quot;another kind of thing&quot; just to make code shorter, and &quot;shorter&quot; is not the right goal for Swift.<br></p><p>Best,<br>Jordan<br></p><p><br>&gt; On Dec 11, 2015, at 14:07, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hey guys,<br>&gt; <br>&gt; I am working on a proposal which touches (and could even partially depend on) another interesting concept which I think would be a great addition for Swift.<br>&gt; <br>&gt; Object declarations could be a way to declare a class or struct with exactly one instance. They are perfect for singletons, anonymous subclasses and to anonymously implement a protocol.<br>&gt; <br>&gt; Here some examples how it could look like:<br>&gt; <br>&gt; // singleton<br>&gt; object GlobalResource {<br>&gt;     func doSomething() { … }<br>&gt; }<br>&gt; <br>&gt; let resource = GlobalResource<br>&gt; <br>&gt; // could all be the same<br>&gt; resource.doSomething()<br>&gt; GlobalResource.doSomething()<br>&gt; GlobalResource.Type.doSomething()<br>&gt; <br>&gt; <br>&gt; // anonymous subclass<br>&gt; class ViewController: UIViewController {<br>&gt; <br>&gt;     override func loadView() {<br>&gt;         view = object: UIView {<br>&gt;             // configure view<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; // anonymous protocol implementation<br>&gt; protocol TapHandler {<br>&gt;     func handleTap()<br>&gt; }<br>&gt; <br>&gt; view.tapHandler = object: TapHandler {<br>&gt;     func handleTap() {<br>&gt;         // …<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Kotlin is an example for a a modern language which uses this concept:<br>&gt; https://kotlinlang.org/docs/reference/object-declarations.html &lt;https://kotlinlang.org/docs/reference/object-declarations.html&gt;<br>&gt; <br>&gt; <br>&gt; What do you think about such an addition?<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/520d4d85/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>Object declarations</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>December 11, 2015 at 06:00:00pm</p></header><div class="content"><p>It&#39;s an interesting idea, but I have to agree from a not-promoting-singletons standpoint. One can just add a static let to a class to return an instance and make the init private to get similar behavior. <br></p><p>&gt; On Dec 11, 2015, at 5:55 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; -1. Enforced singletons lead to code that can&#39;t be unit-tested. Local types are occasionally convenient and they can&#39;t be unit-tested either, but spending one extra line to name the thing isn&#39;t going to hurt. You also can&#39;t pick an initializer here (at least not in this version).<br>&gt; <br>&gt; IMHO, this just adds &quot;another kind of thing&quot; just to make code shorter, and &quot;shorter&quot; is not the right goal for Swift.<br>&gt; <br>&gt; Best,<br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 14:07, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey guys,<br>&gt;&gt; <br>&gt;&gt; I am working on a proposal which touches (and could even partially depend on) another interesting concept which I think would be a great addition for Swift.<br>&gt;&gt; <br>&gt;&gt; Object declarations could be a way to declare a class or struct with exactly one instance. They are perfect for singletons, anonymous subclasses and to anonymously implement a protocol.<br>&gt;&gt; <br>&gt;&gt; Here some examples how it could look like:<br>&gt;&gt; <br>&gt;&gt; // singleton<br>&gt;&gt; object GlobalResource {<br>&gt;&gt;     func doSomething() { … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let resource = GlobalResource<br>&gt;&gt; <br>&gt;&gt; // could all be the same<br>&gt;&gt; resource.doSomething()<br>&gt;&gt; GlobalResource.doSomething()<br>&gt;&gt; GlobalResource.Type.doSomething()<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // anonymous subclass<br>&gt;&gt; class ViewController: UIViewController {<br>&gt;&gt; <br>&gt;&gt;     override func loadView() {<br>&gt;&gt;         view = object: UIView {<br>&gt;&gt;             // configure view<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // anonymous protocol implementation<br>&gt;&gt; protocol TapHandler {<br>&gt;&gt;     func handleTap()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; view.tapHandler = object: TapHandler {<br>&gt;&gt;     func handleTap() {<br>&gt;&gt;         // …<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Kotlin is an example for a a modern language which uses this concept:<br>&gt;&gt; https://kotlinlang.org/docs/reference/object-declarations.html &lt;https://kotlinlang.org/docs/reference/object-declarations.html&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; What do you think about such an addition?<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/2f218192/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Object declarations</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 11, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; -1. Enforced singletons lead to code that can&#39;t be unit-tested. Local types are occasionally convenient and they can&#39;t be unit-tested either, but spending one extra line to name the thing isn&#39;t going to hurt. You also can&#39;t pick an initializer here (at least not in this version).<br></p><p>I’ve also found lately that my singletons tend not to stay single; it usually turns out there’s some way to reuse them. -1 from me as well.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9ea02b9a2f6e3d188e9e974e30d565e0?s=50"></div><header><strong>Object declarations</strong> from <string>Riley Avron</string> &lt;ravron at dropbox.com&gt;<p>December 11, 2015 at 04:00:00pm</p></header><div class="content"><p>-1. Agreed for all of Jordan&#39;s reasons.<br></p><p><br>Riley<br></p><p>On 11 December 2015 at 14:55, Jordan Rose via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; -1. Enforced singletons lead to code that can&#39;t be unit-tested. Local<br>&gt; types are occasionally convenient and they can&#39;t be unit-tested either, but<br>&gt; spending one extra line to name the thing isn&#39;t going to hurt. You also<br>&gt; can&#39;t pick an initializer here (at least not in this version).<br>&gt;<br>&gt; IMHO, this just adds &quot;another kind of thing&quot; just to make code shorter,<br>&gt; and &quot;shorter&quot; is not the right goal for Swift.<br>&gt;<br>&gt; Best,<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On Dec 11, 2015, at 14:07, Marc Knaup via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hey guys,<br>&gt;<br>&gt; I am working on a proposal which touches (and could even partially depend<br>&gt; on) another interesting concept which I think would be a great addition for<br>&gt; Swift.<br>&gt;<br>&gt; Object declarations could be a way to declare a class or struct with<br>&gt; exactly one instance. They are perfect for singletons, anonymous subclasses<br>&gt; and to anonymously implement a protocol.<br>&gt;<br>&gt; Here some examples how it could look like:<br>&gt;<br>&gt; // singleton<br>&gt; object GlobalResource {<br>&gt;     func doSomething() { … }<br>&gt; }<br>&gt;<br>&gt; let resource = GlobalResource<br>&gt;<br>&gt; // could all be the same<br>&gt; resource.doSomething()<br>&gt; GlobalResource.doSomething()<br>&gt; GlobalResource.Type.doSomething()<br>&gt;<br>&gt;<br>&gt; // anonymous subclass<br>&gt; class ViewController: UIViewController {<br>&gt;<br>&gt;     override func loadView() {<br>&gt;         view = object: UIView {<br>&gt;             // configure view<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; // anonymous protocol implementation<br>&gt; protocol TapHandler {<br>&gt;     func handleTap()<br>&gt; }<br>&gt;<br>&gt; view.tapHandler = object: TapHandler {<br>&gt;     func handleTap() {<br>&gt;         // …<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Kotlin is an example for a a modern language which uses this concept:<br>&gt; https://kotlinlang.org/docs/reference/object-declarations.html<br>&gt;<br>&gt;<br>&gt; What do you think about such an addition?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/e7173697/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8da0cba30fa0e47cf4fb26ebb968e552?s=50"></div><header><strong>Object declarations</strong> from <string>Jérôme Duquennoy</string> &lt;jerome+swift at duquennoy.fr&gt;<p>December 12, 2015 at 01:00:00am</p></header><div class="content"><p>I am working on a software in which singleton has been used in tons of places to &quot;simplify&quot; design.<br>Today, some parts of the code base are pretty impossible to test, and hard to evolve since all parts have strong links with other parts.<br></p><p>So I completely agree with Jordan : the singleton is a template that should be used in very specific cases and with care. I think making it a first citizen of the language by dedicating a keyword to it will not push good code design.<br></p><p>Jerome<br></p><p>&gt; Le 12 déc. 2015 à 01:09, Riley Avron via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt; <br>&gt; -1. Agreed for all of Jordan&#39;s reasons.<br>&gt; <br>&gt; <br>&gt; Riley<br>&gt; <br>&gt; On 11 December 2015 at 14:55, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; -1. Enforced singletons lead to code that can&#39;t be unit-tested. Local types are occasionally convenient and they can&#39;t be unit-tested either, but spending one extra line to name the thing isn&#39;t going to hurt. You also can&#39;t pick an initializer here (at least not in this version).<br>&gt; <br>&gt; IMHO, this just adds &quot;another kind of thing&quot; just to make code shorter, and &quot;shorter&quot; is not the right goal for Swift.<br>&gt; <br>&gt; Best,<br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 14:07, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey guys,<br>&gt;&gt; <br>&gt;&gt; I am working on a proposal which touches (and could even partially depend on) another interesting concept which I think would be a great addition for Swift.<br>&gt;&gt; <br>&gt;&gt; Object declarations could be a way to declare a class or struct with exactly one instance. They are perfect for singletons, anonymous subclasses and to anonymously implement a protocol.<br>&gt;&gt; <br>&gt;&gt; Here some examples how it could look like:<br>&gt;&gt; <br>&gt;&gt; // singleton<br>&gt;&gt; object GlobalResource {<br>&gt;&gt;     func doSomething() { … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let resource = GlobalResource<br>&gt;&gt; <br>&gt;&gt; // could all be the same<br>&gt;&gt; resource.doSomething()<br>&gt;&gt; GlobalResource.doSomething()<br>&gt;&gt; GlobalResource.Type.doSomething()<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // anonymous subclass<br>&gt;&gt; class ViewController: UIViewController {<br>&gt;&gt; <br>&gt;&gt;     override func loadView() {<br>&gt;&gt;         view = object: UIView {<br>&gt;&gt;             // configure view<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // anonymous protocol implementation<br>&gt;&gt; protocol TapHandler {<br>&gt;&gt;     func handleTap()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; view.tapHandler = object: TapHandler {<br>&gt;&gt;     func handleTap() {<br>&gt;&gt;         // …<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Kotlin is an example for a a modern language which uses this concept:<br>&gt;&gt; https://kotlinlang.org/docs/reference/object-declarations.html &lt;https://kotlinlang.org/docs/reference/object-declarations.html&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; What do you think about such an addition?<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/20de5f03/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Object declarations</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 12, 2015 at 07:00:00am</p></header><div class="content"><p>I think that anonymous classes got lost amongst all the singletonphobia here, and yet making an anonymous local delegate class is often helpful.<br></p><p>Perhaps we don&#39;t need an additional keyword, though; something like this could work too:<br></p><p>view.delegate = class: SomeDelegate {<br>  ...<br>}()<br></p><p>or perhaps you want a slightly customized object:<br></p><p>view = class: UITextField {<br>  func canBecomeFirstResponder() -&gt; Bool { return false }<br>}()<br></p><p>Of course, we could just use a named local class, like others have pointed out, but unless you really want to name that thing (and the name would often be stupid), that&#39;s a just workaround for a lack of anonymous classes.<br></p><p>A.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Object declarations</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 12, 2015 at 02:00:00am</p></header><div class="content"><p>@Andrey<br></p><p>   - Note that it should also be possible to create structs anonymously as<br>   they also can implement protocols.<br>   - Delegates are a bit tricky because they are usually retained weakly so<br>   the anonymous object would be deallocated immediately.<br>   - Also using &quot;class: XYZ {}&quot; doesn&#39;t allow creating named objects<br>like &quot;class object<br>   EmptyObject {}&quot;.<br></p><p>When talking about singletons people tend to first think at a very large<br>scale and about abstraction, factories, testability and whatever.<br>It&#39;s the little things which capture my interest more, like NSNull for<br>example.<br></p><p>class object NSNull {}<br></p><p>Or maybe a JSON Null:<br></p><p>protocol JSONNode {}<br>struct JSON {<br>    struct object Null: JSONNode {}<br>    struct Bool { … } // not an object but a type<br></p><p>    // …<br>}<br></p><p>Now the interesting part about a singleton NSNull (or the JSON one) is that<br>it represents both, a type and an instance.<br></p><p>array.append(NSNull)<br></p><p>Note that we cannot use a class and call NSNull() as this would create a<br>new instance instead of returning the singleton instance.<br>We would have to make a silly workaround like NSNull.null or<br>NSNull.sharedInstance.<br></p><p>Examples for JSON.Null:<br></p><p>jsonArray.append(JSON.Null) // used as instance<br></p><p>if jsonNode is JSON.Null { // used as type<br>   // …<br>}<br></p><p>let expectedJsonTypes: [JSONNode.Type] = [JSON.Null, JSON.Bool, …]<br></p><p>if jsonNode is JSON.Null { // used as type<br>   // …<br>}<br>if jsonNode == JSON.Null { // used as instance (assuming Equatable<br>conformance)<br>   // …<br>}<br></p><p><br></p><p><br></p><p><br>On Sat, Dec 12, 2015 at 2:29 AM, Andrey Tarantsov via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I think that anonymous classes got lost amongst all the singletonphobia<br>&gt; here, and yet making an anonymous local delegate class is often helpful.<br>&gt;<br>&gt; Perhaps we don&#39;t need an additional keyword, though; something like this<br>&gt; could work too:<br>&gt;<br>&gt; view.delegate = class: SomeDelegate {<br>&gt;   ...<br>&gt; }()<br>&gt;<br>&gt; or perhaps you want a slightly customized object:<br>&gt;<br>&gt; view = class: UITextField {<br>&gt;   func canBecomeFirstResponder() -&gt; Bool { return false }<br>&gt; }()<br>&gt;<br>&gt; Of course, we could just use a named local class, like others have pointed<br>&gt; out, but unless you really want to name that thing (and the name would<br>&gt; often be stupid), that&#39;s a just workaround for a lack of anonymous classes.<br>&gt;<br>&gt; A.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/2431477f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c638dc69b46afe03e3491dea47620cf4?s=50"></div><header><strong>Object declarations</strong> from <string>crk at fastmail.com</string> &lt;crk at fastmail.com&gt;<p>December 13, 2015 at 06:00:00pm</p></header><div class="content"><p>I think anonymous classes run counter to Swift&#39;s goals of clarity. You don&#39;t even have to pollute your whole module with the class, you can declare a private class in the same file and use it where you need it. This is, in my opinion far cleaner. Additionally, anonymous classes are really difficult for people to understand if they&#39;ve not encountered the concept before.<br></p><p>&gt; On Dec 11, 2015, at 19:48, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; @Andrey<br>&gt; Note that it should also be possible to create structs anonymously as they also can implement protocols.<br>&gt; Delegates are a bit tricky because they are usually retained weakly so the anonymous object would be deallocated immediately.<br>&gt; Also using &quot;class: XYZ {}&quot; doesn&#39;t allow creating named objects like &quot;class object EmptyObject {}&quot;.<br>&gt; When talking about singletons people tend to first think at a very large scale and about abstraction, factories, testability and whatever.<br>&gt; It&#39;s the little things which capture my interest more, like NSNull for example.<br>&gt; <br>&gt; class object NSNull {}<br>&gt; <br>&gt; Or maybe a JSON Null:<br>&gt; <br>&gt; protocol JSONNode {}<br>&gt; struct JSON {<br>&gt;     struct object Null: JSONNode {}<br>&gt;     struct Bool { … } // not an object but a type<br>&gt; <br>&gt;     // …<br>&gt; }<br>&gt; <br>&gt; Now the interesting part about a singleton NSNull (or the JSON one) is that it represents both, a type and an instance.<br>&gt; <br>&gt; array.append(NSNull)<br>&gt; <br>&gt; Note that we cannot use a class and call NSNull() as this would create a new instance instead of returning the singleton instance.<br>&gt; We would have to make a silly workaround like NSNull.null or NSNull.sharedInstance.<br>&gt; <br>&gt; Examples for JSON.Null:<br>&gt; <br>&gt; jsonArray.append(JSON.Null) // used as instance<br>&gt; <br>&gt; if jsonNode is JSON.Null { // used as type<br>&gt;    // …<br>&gt; }<br>&gt; <br>&gt; let expectedJsonTypes: [JSONNode.Type] = [JSON.Null, JSON.Bool, …]<br>&gt; <br>&gt; if jsonNode is JSON.Null { // used as type<br>&gt;    // …<br>&gt; }<br>&gt; if jsonNode == JSON.Null { // used as instance (assuming Equatable conformance)<br>&gt;    // …<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Sat, Dec 12, 2015 at 2:29 AM, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I think that anonymous classes got lost amongst all the singletonphobia here, and yet making an anonymous local delegate class is often helpful.<br>&gt;&gt; <br>&gt;&gt; Perhaps we don&#39;t need an additional keyword, though; something like this could work too:<br>&gt;&gt; <br>&gt;&gt; view.delegate = class: SomeDelegate {<br>&gt;&gt;   ...<br>&gt;&gt; }()<br>&gt;&gt; <br>&gt;&gt; or perhaps you want a slightly customized object:<br>&gt;&gt; <br>&gt;&gt; view = class: UITextField {<br>&gt;&gt;   func canBecomeFirstResponder() -&gt; Bool { return false }<br>&gt;&gt; }()<br>&gt;&gt; <br>&gt;&gt; Of course, we could just use a named local class, like others have pointed out, but unless you really want to name that thing (and the name would often be stupid), that&#39;s a just workaround for a lack of anonymous classes.<br>&gt;&gt; <br>&gt;&gt; A.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/fd9287b1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Object declarations</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 14, 2015 at 01:00:00am</p></header><div class="content"><p>Well anonymous objects are one way object declarations could be used. They<br>may or may not be reduce clarity - I have no strong preference here.<br></p><p>But they can also be named. This is what interests me most.<br></p><p>Additionally when the compiler knows that there is always exactly one<br>instance it can probably optimize the code even further.<br>But I cannot answer that question.<br></p><p>On Mon, Dec 14, 2015 at 1:17 AM, Cole Kurkowski &lt;crk at fastmail.com&gt; wrote:<br></p><p>&gt; I think anonymous classes run counter to Swift&#39;s goals of clarity. You<br>&gt; don&#39;t even have to pollute your whole module with the class, you can<br>&gt; declare a private class in the same file and use it where you need it. This<br>&gt; is, in my opinion far cleaner. Additionally, anonymous classes are really<br>&gt; difficult for people to understand if they&#39;ve not encountered the concept<br>&gt; before.<br>&gt;<br>&gt; On Dec 11, 2015, at 19:48, Marc Knaup via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; @Andrey<br>&gt;<br>&gt;    - Note that it should also be possible to create structs anonymously<br>&gt;    as they also can implement protocols.<br>&gt;    - Delegates are a bit tricky because they are usually retained weakly<br>&gt;    so the anonymous object would be deallocated immediately.<br>&gt;    - Also using &quot;class: XYZ {}&quot; doesn&#39;t allow creating named objects like<br>&gt;    &quot;class object EmptyObject {}&quot;.<br>&gt;<br>&gt; When talking about singletons people tend to first think at a very large<br>&gt; scale and about abstraction, factories, testability and whatever.<br>&gt; It&#39;s the little things which capture my interest more, like NSNull for<br>&gt; example.<br>&gt;<br>&gt; class object NSNull {}<br>&gt;<br>&gt; Or maybe a JSON Null:<br>&gt;<br>&gt; protocol JSONNode {}<br>&gt; struct JSON {<br>&gt;     struct object Null: JSONNode {}<br>&gt;     struct Bool { … } // not an object but a type<br>&gt;<br>&gt;     // …<br>&gt; }<br>&gt;<br>&gt; Now the interesting part about a singleton NSNull (or the JSON one) is<br>&gt; that it represents both, a type and an instance.<br>&gt;<br>&gt; array.append(NSNull)<br>&gt;<br>&gt; Note that we cannot use a class and call NSNull() as this would create a<br>&gt; new instance instead of returning the singleton instance.<br>&gt; We would have to make a silly workaround like NSNull.null or<br>&gt; NSNull.sharedInstance.<br>&gt;<br>&gt; Examples for JSON.Null:<br>&gt;<br>&gt; jsonArray.append(JSON.Null) // used as instance<br>&gt;<br>&gt; if jsonNode is JSON.Null { // used as type<br>&gt;    // …<br>&gt; }<br>&gt;<br>&gt; let expectedJsonTypes: [JSONNode.Type] = [JSON.Null, JSON.Bool, …]<br>&gt;<br>&gt; if jsonNode is JSON.Null { // used as type<br>&gt;    // …<br>&gt; }<br>&gt; if jsonNode == JSON.Null { // used as instance (assuming Equatable<br>&gt; conformance)<br>&gt;    // …<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Sat, Dec 12, 2015 at 2:29 AM, Andrey Tarantsov via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I think that anonymous classes got lost amongst all the singletonphobia<br>&gt;&gt; here, and yet making an anonymous local delegate class is often helpful.<br>&gt;&gt;<br>&gt;&gt; Perhaps we don&#39;t need an additional keyword, though; something like this<br>&gt;&gt; could work too:<br>&gt;&gt;<br>&gt;&gt; view.delegate = class: SomeDelegate {<br>&gt;&gt;   ...<br>&gt;&gt; }()<br>&gt;&gt;<br>&gt;&gt; or perhaps you want a slightly customized object:<br>&gt;&gt;<br>&gt;&gt; view = class: UITextField {<br>&gt;&gt;   func canBecomeFirstResponder() -&gt; Bool { return false }<br>&gt;&gt; }()<br>&gt;&gt;<br>&gt;&gt; Of course, we could just use a named local class, like others have<br>&gt;&gt; pointed out, but unless you really want to name that thing (and the name<br>&gt;&gt; would often be stupid), that&#39;s a just workaround for a lack of anonymous<br>&gt;&gt; classes.<br>&gt;&gt;<br>&gt;&gt; A.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/50aaace3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c638dc69b46afe03e3491dea47620cf4?s=50"></div><header><strong>Object declarations</strong> from <string>crk at fastmail.com</string> &lt;crk at fastmail.com&gt;<p>December 13, 2015 at 07:00:00pm</p></header><div class="content"><p>Ahh, I misunderstood a piece of your initial proposal. I don&#39;t have any strong opposition to a named object declaration, and there have been several occasions where I might have used such a construct (whether or not you&#39;re a fan of singletons they are very much a part of Cocoa and associated software).<br></p><p>That being said there are concerns (unit testing especially as was already mentioned) that may cause problems. <br></p><p>&gt; On Dec 13, 2015, at 18:28, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt; <br>&gt; Well anonymous objects are one way object declarations could be used. They may or may not be reduce clarity - I have no strong preference here.<br>&gt; <br>&gt; But they can also be named. This is what interests me most.<br>&gt; <br>&gt; Additionally when the compiler knows that there is always exactly one instance it can probably optimize the code even further.<br>&gt; But I cannot answer that question.<br>&gt; <br>&gt;&gt; On Mon, Dec 14, 2015 at 1:17 AM, Cole Kurkowski &lt;crk at fastmail.com&gt; wrote:<br>&gt;&gt; I think anonymous classes run counter to Swift&#39;s goals of clarity. You don&#39;t even have to pollute your whole module with the class, you can declare a private class in the same file and use it where you need it. This is, in my opinion far cleaner. Additionally, anonymous classes are really difficult for people to understand if they&#39;ve not encountered the concept before.<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 11, 2015, at 19:48, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @Andrey<br>&gt;&gt;&gt; Note that it should also be possible to create structs anonymously as they also can implement protocols.<br>&gt;&gt;&gt; Delegates are a bit tricky because they are usually retained weakly so the anonymous object would be deallocated immediately.<br>&gt;&gt;&gt; Also using &quot;class: XYZ {}&quot; doesn&#39;t allow creating named objects like &quot;class object EmptyObject {}&quot;.<br>&gt;&gt;&gt; When talking about singletons people tend to first think at a very large scale and about abstraction, factories, testability and whatever.<br>&gt;&gt;&gt; It&#39;s the little things which capture my interest more, like NSNull for example.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class object NSNull {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or maybe a JSON Null:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol JSONNode {}<br>&gt;&gt;&gt; struct JSON {<br>&gt;&gt;&gt;     struct object Null: JSONNode {}<br>&gt;&gt;&gt;     struct Bool { … } // not an object but a type<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // …<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now the interesting part about a singleton NSNull (or the JSON one) is that it represents both, a type and an instance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; array.append(NSNull)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that we cannot use a class and call NSNull() as this would create a new instance instead of returning the singleton instance.<br>&gt;&gt;&gt; We would have to make a silly workaround like NSNull.null or NSNull.sharedInstance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Examples for JSON.Null:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; jsonArray.append(JSON.Null) // used as instance<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if jsonNode is JSON.Null { // used as type<br>&gt;&gt;&gt;    // …<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let expectedJsonTypes: [JSONNode.Type] = [JSON.Null, JSON.Bool, …]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if jsonNode is JSON.Null { // used as type<br>&gt;&gt;&gt;    // …<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; if jsonNode == JSON.Null { // used as instance (assuming Equatable conformance)<br>&gt;&gt;&gt;    // …<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sat, Dec 12, 2015 at 2:29 AM, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; I think that anonymous classes got lost amongst all the singletonphobia here, and yet making an anonymous local delegate class is often helpful.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Perhaps we don&#39;t need an additional keyword, though; something like this could work too:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; view.delegate = class: SomeDelegate {<br>&gt;&gt;&gt;&gt;   ...<br>&gt;&gt;&gt;&gt; }()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; or perhaps you want a slightly customized object:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; view = class: UITextField {<br>&gt;&gt;&gt;&gt;   func canBecomeFirstResponder() -&gt; Bool { return false }<br>&gt;&gt;&gt;&gt; }()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Of course, we could just use a named local class, like others have pointed out, but unless you really want to name that thing (and the name would often be stupid), that&#39;s a just workaround for a lack of anonymous classes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/0740695b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Object declarations</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 13, 2015 at 07:00:00pm</p></header><div class="content"><p>-1 from me as well.  In addition to those points, syntax optimizing shared global state encourages its use.  This is problematic for threading and many other things as well.<br></p><p>-Chris<br></p><p>&gt; On Dec 11, 2015, at 4:09 PM, Riley Avron via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; -1. Agreed for all of Jordan&#39;s reasons.<br>&gt; <br>&gt; <br>&gt; Riley<br>&gt; <br>&gt; On 11 December 2015 at 14:55, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; -1. Enforced singletons lead to code that can&#39;t be unit-tested. Local types are occasionally convenient and they can&#39;t be unit-tested either, but spending one extra line to name the thing isn&#39;t going to hurt. You also can&#39;t pick an initializer here (at least not in this version).<br>&gt; <br>&gt; IMHO, this just adds &quot;another kind of thing&quot; just to make code shorter, and &quot;shorter&quot; is not the right goal for Swift.<br>&gt; <br>&gt; Best,<br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 14:07, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey guys,<br>&gt;&gt; <br>&gt;&gt; I am working on a proposal which touches (and could even partially depend on) another interesting concept which I think would be a great addition for Swift.<br>&gt;&gt; <br>&gt;&gt; Object declarations could be a way to declare a class or struct with exactly one instance. They are perfect for singletons, anonymous subclasses and to anonymously implement a protocol.<br>&gt;&gt; <br>&gt;&gt; Here some examples how it could look like:<br>&gt;&gt; <br>&gt;&gt; // singleton<br>&gt;&gt; object GlobalResource {<br>&gt;&gt;     func doSomething() { … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let resource = GlobalResource<br>&gt;&gt; <br>&gt;&gt; // could all be the same<br>&gt;&gt; resource.doSomething()<br>&gt;&gt; GlobalResource.doSomething()<br>&gt;&gt; GlobalResource.Type.doSomething()<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // anonymous subclass<br>&gt;&gt; class ViewController: UIViewController {<br>&gt;&gt; <br>&gt;&gt;     override func loadView() {<br>&gt;&gt;         view = object: UIView {<br>&gt;&gt;             // configure view<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // anonymous protocol implementation<br>&gt;&gt; protocol TapHandler {<br>&gt;&gt;     func handleTap()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; view.tapHandler = object: TapHandler {<br>&gt;&gt;     func handleTap() {<br>&gt;&gt;         // …<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Kotlin is an example for a a modern language which uses this concept:<br>&gt;&gt; https://kotlinlang.org/docs/reference/object-declarations.html &lt;https://kotlinlang.org/docs/reference/object-declarations.html&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; What do you think about such an addition?<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/42fc6615/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
