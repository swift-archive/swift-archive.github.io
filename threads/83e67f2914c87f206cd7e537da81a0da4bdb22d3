<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 24, 2016 at 03:00:00pm</p></header><div class="content"><p>on Sun Jan 24 2016, David Owens II &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Jan 23, 2016, at 11:53 AM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Jan 22 2016, David Owens II &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Be Grammatical<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When a mutating method is described by a verb, name its non-mutating<br>&gt;&gt;&gt;&gt; counterpart according to the “ed/ing” rule, e.g. the non-mutating<br>&gt;&gt;&gt;&gt; versions of x.sort() and x.append(y) are x.sorted() and<br>&gt;&gt;&gt;&gt; x.appending(y).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is this guideline suggesting that we should design our APIs to<br>&gt;&gt;&gt; generally have both mutating and non-mutaging counterparts?<br>&gt;&gt; <br>&gt;&gt; Definitely not.<br>&gt;&gt; <br>&gt;&gt;&gt; As other have pointed out, this is also very hard to do all the<br>&gt;&gt;&gt; time. I think the alternatives are worse. <br>&gt;&gt; <br>&gt;&gt; The alternatives to always creating mutating/nonmutating pairs?  What<br>&gt;&gt; alternatives have you considered, and what do you see the consequences<br>&gt;&gt; to be?<br>&gt;&gt; <br>&gt;&gt;&gt; It would be nice if there were a way to annotate all member functions<br>&gt;&gt;&gt; as mutating/non-mutating to really by-pass this ambiguity.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know what you mean by that.  Can you explain?<br>&gt;&gt; <br>&gt;&gt; FWIW, there are potential language-level approaches to this problem<br>&gt;&gt; (e.g. https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst),<br>&gt;&gt; but in the absence of language features, it&#39;s something we need a<br>&gt;&gt; convention for.<br>&gt;<br>&gt; Exactly. It seems like this convention is a work-around for a language<br>&gt; design deficiency. In the case of value types, there are indeed other<br>&gt; solutions that could even allow the same name for functions to be used<br>&gt; for both mutating and non-mutating. The key thing of importance is<br>&gt; bringing that clarity to the call site.<br>&gt;<br>&gt; I think there are some interesting proposals in the link provided. Another potential:<br>&gt;<br>&gt; var items = [...]<br>&gt; mut items.sort()            // sorts the items in-place<br>&gt; let copy = items.sort()     // sorts a copy of the items and returns that copy<br>&gt;<br>&gt; let items = [...]<br>&gt; mut items.sort()            // error: unable to mutate a constant value<br>&gt;<br>&gt; The other potential thing to look it is what it means for class-types<br>&gt; to allow mutation. I simply cannot trust a class-type that has a<br>&gt; function named with the correct guidelines or an &quot;InPlace&quot; suffix to<br>&gt; actually return a real copy of the class type.<br></p><p>I&#39;d love to discuss langauge features for handling this, but let&#39;s take<br>all of that into a separate thread, please.<br></p><p>&gt; I guess my point is this: codifying a convention seems pre-mature as<br>&gt; that convention doesn&#39;t bring the safety goals of the language into a<br>&gt; place that&#39;s verifiable. All of the other guidelines are simply about<br>&gt; clarity of use, this convention has a far reaching impact.<br></p><p>Sorry, could you clarify what you mean by &quot;bring the safety goals of the<br>language into a place that&#39;s verifiable&quot; and clarify why having a &quot;far<br>reaching impact&quot; would somehow conflict with being &quot;about clarity of use?&quot;<br></p><p>It seems to me that this convention is about how to express whether a<br>method is going to mutate so it&#39;s clear at the use-site.  What am I<br>missing?<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 24, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt;&gt; I guess my point is this: codifying a convention seems pre-mature as<br>&gt;&gt; that convention doesn&#39;t bring the safety goals of the language into a<br>&gt;&gt; place that&#39;s verifiable. All of the other guidelines are simply about<br>&gt;&gt; clarity of use, this convention has a far reaching impact.<br>&gt; <br>&gt; Sorry, could you clarify what you mean by &quot;bring the safety goals of the<br>&gt; language into a place that&#39;s verifiable&quot; and clarify why having a &quot;far<br>&gt; reaching impact&quot; would somehow conflict with being &quot;about clarity of use?&quot;<br>&gt; <br>&gt; It seems to me that this convention is about how to express whether a<br>&gt; method is going to mutate so it&#39;s clear at the use-site.  What am I<br>&gt; missing?<br></p><p><br>The problem is it&#39;s unclear to me whether you mean mutate in the true sense of the word or only applied to a struct with a function annotated with the mutating keyword.<br></p><p>The naming convention provides no safety when dealing with non-struct types as we cannot enforce that a method on a class does not mutate it&#39;s internal members.<br></p><p>That&#39;s the clarity I&#39;m looking for.<br></p><p>Given this API set:<br></p><p>protocol InPlaceable {<br>    mutating func doInPlace()<br>}<br></p><p>public struct Foo: InPlaceable {<br>    mutating func doInPlace() {}<br>}<br></p><p>public class Bar: InPlaceable {<br>    func doInPlace() {}<br>}<br></p><p>var lie: InPlaceable = Bar()<br>lie.doInPlace()<br></p><p>let lie2 = Bar()<br>lie2.doInPlace()<br></p><p>The convention will tell us a lie unless we are extremely careful. It&#39;s this lie that concerns me. We cannot guarantee that the &quot;doInPlace&quot; truly matches the definition we are seeking.<br></p><p><br>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/84441e29/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 24, 2016 at 05:00:00pm</p></header><div class="content"><p>Sorry, I meant to add the do() version too in order to show the difference better. /sigh<br></p><p><br>&gt; On Jan 24, 2016, at 4:53 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; I guess my point is this: codifying a convention seems pre-mature as<br>&gt;&gt;&gt; that convention doesn&#39;t bring the safety goals of the language into a<br>&gt;&gt;&gt; place that&#39;s verifiable. All of the other guidelines are simply about<br>&gt;&gt;&gt; clarity of use, this convention has a far reaching impact.<br>&gt;&gt; <br>&gt;&gt; Sorry, could you clarify what you mean by &quot;bring the safety goals of the<br>&gt;&gt; language into a place that&#39;s verifiable&quot; and clarify why having a &quot;far<br>&gt;&gt; reaching impact&quot; would somehow conflict with being &quot;about clarity of use?&quot;<br>&gt;&gt; <br>&gt;&gt; It seems to me that this convention is about how to express whether a<br>&gt;&gt; method is going to mutate so it&#39;s clear at the use-site.  What am I<br>&gt;&gt; missing?<br>&gt; <br>&gt; <br>&gt; The problem is it&#39;s unclear to me whether you mean mutate in the true sense of the word or only applied to a struct with a function annotated with the mutating keyword.<br>&gt; <br>&gt; The naming convention provides no safety when dealing with non-struct types as we cannot enforce that a method on a class does not mutate it&#39;s internal members.<br>&gt; <br>&gt; That&#39;s the clarity I&#39;m looking for.<br>&gt; <br>&gt; Given this API set:<br>&gt; <br>&gt; protocol InPlaceable {<br>&gt;     mutating func doInPlace()<br>&gt; }<br>&gt; <br>&gt; public struct Foo: InPlaceable {<br>&gt;     mutating func doInPlace() {}<br>&gt; }<br>&gt; <br>&gt; public class Bar: InPlaceable {<br>&gt;     func doInPlace() {}<br>&gt; }<br>&gt; <br>&gt; var lie: InPlaceable = Bar()<br>&gt; lie.doInPlace()<br>&gt; <br>&gt; let lie2 = Bar()<br>&gt; lie2.doInPlace()<br>&gt; <br>&gt; The convention will tell us a lie unless we are extremely careful. It&#39;s this lie that concerns me. We cannot guarantee that the &quot;doInPlace&quot; truly matches the definition we are seeking.<br>&gt; <br>&gt; <br>&gt; -David<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/c6b69796/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 24, 2016 at 07:00:00pm</p></header><div class="content"><p>on Sun Jan 24 2016, David Owens II &lt;david-AT-owensd.io&gt; wrote:<br></p><p>&gt; Sorry, I meant to add the do() version too in order to show the<br>&gt; difference better. /sigh<br></p><p>do() version?<br></p><p>&gt;<br>&gt;&gt; On Jan 24, 2016, at 4:53 PM, David Owens II via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; I guess my point is this: codifying a convention seems pre-mature as<br>&gt;&gt;&gt;&gt; that convention doesn&#39;t bring the safety goals of the language into a<br>&gt;&gt;&gt;&gt; place that&#39;s verifiable. All of the other guidelines are simply about<br>&gt;&gt;&gt;&gt; clarity of use, this convention has a far reaching impact.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, could you clarify what you mean by &quot;bring the safety goals of the<br>&gt;&gt;&gt; language into a place that&#39;s verifiable&quot; and clarify why having a &quot;far<br>&gt;&gt;&gt; reaching impact&quot; would somehow conflict with being &quot;about clarity of use?&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems to me that this convention is about how to express whether a<br>&gt;&gt;&gt; method is going to mutate so it&#39;s clear at the use-site.  What am I<br>&gt;&gt;&gt; missing?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The problem is it&#39;s unclear to me whether you mean mutate in the<br>&gt;&gt; true sense of the word or only applied to a struct with a function<br>&gt;&gt; annotated with the mutating keyword.<br>&gt;&gt; <br>&gt;&gt; The naming convention provides no safety when dealing with<br>&gt;&gt; non-struct types as we cannot enforce that a method on a class does<br>&gt;&gt; not mutate it&#39;s internal members.<br>&gt;&gt; <br>&gt;&gt; That&#39;s the clarity I&#39;m looking for.<br>&gt;&gt; <br>&gt;&gt; Given this API set:<br>&gt;&gt; <br>&gt;&gt; protocol InPlaceable {<br>&gt;&gt;     mutating func doInPlace()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public struct Foo: InPlaceable {<br>&gt;&gt;     mutating func doInPlace() {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public class Bar: InPlaceable {<br>&gt;&gt;     func doInPlace() {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; var lie: InPlaceable = Bar()<br>&gt;&gt; lie.doInPlace()<br>&gt;&gt; <br>&gt;&gt; let lie2 = Bar()<br>&gt;&gt; lie2.doInPlace()<br>&gt;&gt; <br>&gt;&gt; The convention will tell us a lie unless we are extremely<br>&gt;&gt; careful. It&#39;s this lie that concerns me. We cannot guarantee that<br>&gt;&gt; the &quot;doInPlace&quot; truly matches the definition we are seeking.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -David<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 25, 2016 at 09:00:00am</p></header><div class="content"><p>Let’s try again with less of a sleepy-sick stupor. =)<br></p><p>My concern is that the name of the function is the only indicator for non-struct types when looking at the signature. For structs, we can get more assurance; e.g. the bug demonstrated below cannot happen. However, that doesn’t mean the opposite bug is avoidable: return a copying instead of mutating self.<br></p><p>The problem I was trying to illustrate, and did a really poor job at, is that the convention doesn’t actually provide us with any guarantees that our implementations are correct. So when I say this:<br></p><p>&gt; I guess my point is this: codifying a convention seems pre-mature as that convention doesn&#39;t bring the safety goals of the language into a place that&#39;s verifiable. All of the other guidelines are simply about clarity of use, this convention has a far reaching impact.<br></p><p><br>Here’s a demonstration of when the guidelines was applied incorrectly, either due to ignorance of the guidelines or simply a copy/paste type bug.<br></p><p>var bar = Bar(items: [2, 1, 3])<br>let filteredBar = bar.filter { $0 != 3 }<br></p><p>bar.items                      // output: [2, 1 3]<br>filteredBar.items              // output: [2, 1]<br></p><p>let filteredSortedBar = bar<br>    .filter { $0 != 3 }<br>    .sort()<br></p><p>bar.items                      // output: [2, 1, 3]<br>filteredSortedBar.items        // output: [1, 2]<br></p><p>let sortedFilterBar = bar<br>    .sort()<br>    .filter { $0 != 3 }<br></p><p>bar.items                      // output: [1, 2, 3] WHAT?<br>sortedFilterBar.items          // output: [1, 2]<br></p><p>var expected = Bar(items: [2, 1, 3])<br>expected<br>    .filterInPlace { $0 != 3 }<br>    .sortInPlace()<br></p><p>expected.items                 // output: [1, 2]<br></p><p>When reading the code with an understanding of the guidelines, this code is misleading as to what it should be doing. That’s what I find dangerous. Of course, we can argue on the merits of these types of bugs, but we’ve all seen conventions misused and it sucks.<br></p><p>If this convention is just a stop-gap until a language feature can be built to help with this, then ok. <br></p><p>-David<br></p><p><br>sample implementation that demonstrates the bug that gets us out-of-sync with the guidelines:<br></p><p>public class Bar&lt;T : Comparable&gt; {<br>    var items: [T]<br>    <br>    init(items: [T]) {<br>        self.items = items<br>    }<br>    <br>    func sortInPlace() -&gt; Self {<br>        self.items.sortInPlace { $0 &lt; $1 }<br>        return self<br>    }<br>    <br>    func sort() -&gt; Self {<br>        self.items.sortInPlace { $0 &lt; $1 }<br>        return self<br>    }<br>    <br>    func filterInPlace(includeElement: (T) -&gt; Bool) -&gt; Self {<br>        self.items = self.items.filter(includeElement)<br>        return self<br>    }<br>    <br>    func filter(includeElement: (T) -&gt; Bool) -&gt; Bar&lt;T&gt; {<br>        let newItems: [T] = self.items.filter(includeElement)<br>        return Bar(items: newItems)<br>    }<br>}<br></p><p>&gt; On Jan 24, 2016, at 7:18 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sun Jan 24 2016, David Owens II &lt;david-AT-owensd.io&gt; wrote:<br>&gt; <br>&gt;&gt; Sorry, I meant to add the do() version too in order to show the<br>&gt;&gt; difference better. /sigh<br>&gt; <br>&gt; do() version?<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 24, 2016, at 4:53 PM, David Owens II via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I guess my point is this: codifying a convention seems pre-mature as<br>&gt;&gt;&gt;&gt;&gt; that convention doesn&#39;t bring the safety goals of the language into a<br>&gt;&gt;&gt;&gt;&gt; place that&#39;s verifiable. All of the other guidelines are simply about<br>&gt;&gt;&gt;&gt;&gt; clarity of use, this convention has a far reaching impact.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sorry, could you clarify what you mean by &quot;bring the safety goals of the<br>&gt;&gt;&gt;&gt; language into a place that&#39;s verifiable&quot; and clarify why having a &quot;far<br>&gt;&gt;&gt;&gt; reaching impact&quot; would somehow conflict with being &quot;about clarity of use?&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems to me that this convention is about how to express whether a<br>&gt;&gt;&gt;&gt; method is going to mutate so it&#39;s clear at the use-site.  What am I<br>&gt;&gt;&gt;&gt; missing?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The problem is it&#39;s unclear to me whether you mean mutate in the<br>&gt;&gt;&gt; true sense of the word or only applied to a struct with a function<br>&gt;&gt;&gt; annotated with the mutating keyword.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The naming convention provides no safety when dealing with<br>&gt;&gt;&gt; non-struct types as we cannot enforce that a method on a class does<br>&gt;&gt;&gt; not mutate it&#39;s internal members.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s the clarity I&#39;m looking for.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given this API set:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol InPlaceable {<br>&gt;&gt;&gt;    mutating func doInPlace()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public struct Foo: InPlaceable {<br>&gt;&gt;&gt;    mutating func doInPlace() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public class Bar: InPlaceable {<br>&gt;&gt;&gt;    func doInPlace() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var lie: InPlaceable = Bar()<br>&gt;&gt;&gt; lie.doInPlace()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let lie2 = Bar()<br>&gt;&gt;&gt; lie2.doInPlace()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The convention will tell us a lie unless we are extremely<br>&gt;&gt;&gt; careful. It&#39;s this lie that concerns me. We cannot guarantee that<br>&gt;&gt;&gt; the &quot;doInPlace&quot; truly matches the definition we are seeking.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -David<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/583f88c4/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 24, 2016 at 07:00:00pm</p></header><div class="content"><p>on Sun Jan 24 2016, David Owens II &lt;david-AT-owensd.io&gt; wrote:<br></p><p>&gt;&gt;&gt; I guess my point is this: codifying a convention seems pre-mature as<br>&gt;&gt;&gt; that convention doesn&#39;t bring the safety goals of the language into a<br>&gt;&gt;&gt; place that&#39;s verifiable. All of the other guidelines are simply about<br>&gt;&gt;&gt; clarity of use, this convention has a far reaching impact.<br>&gt;&gt; <br>&gt;&gt; Sorry, could you clarify what you mean by &quot;bring the safety goals of the<br>&gt;&gt; language into a place that&#39;s verifiable&quot; and clarify why having a &quot;far<br>&gt;&gt; reaching impact&quot; would somehow conflict with being &quot;about clarity of use?&quot;<br>&gt;&gt; <br>&gt;&gt; It seems to me that this convention is about how to express whether a<br>&gt;&gt; method is going to mutate so it&#39;s clear at the use-site.  What am I<br>&gt;&gt; missing?<br>&gt;<br>&gt; The problem is it&#39;s unclear to me whether you mean mutate in the true<br>&gt; sense of the word or only applied to a struct with a function<br>&gt; annotated with the mutating keyword.<br>&gt;<br>&gt; The naming convention provides no safety when dealing with non-struct<br>&gt; types as we cannot enforce that a method on a class does not mutate<br>&gt; it&#39;s internal members.<br>&gt;<br>&gt; That&#39;s the clarity I&#39;m looking for.<br></p><p>I think I understand what you&#39;re going for.  The word &quot;mutating&quot; sounds<br>like it might literally mean what is expressed by the corresponding<br>keyword.  I think rephrasing in terms of side-effects, as Erica has<br>suggested, is one possible fix.  A more limited approach to your<br>confusion would be to rephrase in terms of &quot;methods that mutate the<br>receiver.&quot;<br></p><p>&gt; Given this API set:<br>&gt;<br>&gt; protocol InPlaceable {<br>&gt;     mutating func doInPlace()<br>&gt; }<br>&gt;<br>&gt; public struct Foo: InPlaceable {<br>&gt;     mutating func doInPlace() {}<br>&gt; }<br>&gt;<br>&gt; public class Bar: InPlaceable {<br>&gt;     func doInPlace() {}<br>&gt; }<br>&gt;<br>&gt; var lie: InPlaceable = Bar()<br>&gt; lie.doInPlace()<br>&gt;<br>&gt; let lie2 = Bar()<br>&gt; lie2.doInPlace()<br>&gt;<br>&gt; The convention will tell us a lie unless we are extremely<br>&gt; careful. It&#39;s this lie that concerns me. We cannot guarantee that the<br>&gt; &quot;doInPlace&quot; truly matches the definition we are seeking.<br></p><p>Wow, you&#39;ve completely lost me.  I don&#39;t see anything that looks like a<br>lie, here.  What do you mean?<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
