<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal] mapValues</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 13, 2016 at 04:00:00pm</p></header><div class="content"><p>on Wed Apr 13 2016, Nate Cook &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;     On Apr 13, 2016, at 12:02 PM, Jacob Bandes-Storch via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     To adhere to the API Design Guidelines, I think it should be named<br>&gt;     &quot;mappingValues&quot;, right?<br>&gt;<br>&gt;     On Wed, Apr 13, 2016 at 4:23 AM, Vladimir.S via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     As for mapKeys and many values into a single key. I believe we should have a<br>&gt;         choice - do we expect multiply values for the same key or not. Just like<br>&gt;         &quot;+&quot; and integer overflow : by default it raises the error, but if &quot;&amp;+&quot; -<br>&gt;         we expect the overflow. I can imagine situations when it is ok for me to<br>&gt;         have different values for the same key(if I don&#39;t care which of values<br>&gt;         should be for that key in result dictionary).<br>&gt;         So my proposal is some additional mapKey(allowMultiplyValues: true)<br>&gt;         {...} or in any other form/name.<br>&gt;<br>&gt; There&#39;s a proposal (awaiting merging) to add Dictionary initializers and methods<br>&gt; that work with key/value pairs. These provide different ways of dealing with the<br>&gt; duplicate key issue after a call to the regular Collection.map method.<br>&gt;<br>&gt;     https://github.com/natecook1000/swift-evolution/blob/natecook-dictionary-merge/proposals/0000-add-sequence-based-init-and-merge-to-dictionary.md<br></p><p>Ah, yes, that reminds me of your answer to the question about whether we<br>need a “uniquingKeys” label on that init(), which IMO is a good one: no,<br>we don&#39;t need it, because the one without the label traps on duplicate<br>keys.<br></p><p>&gt; I&#39;d be interested in a `mapValues` or `transformValues` method that would modify<br>&gt; values in place while leaving keys alone.<br></p><p>Is that enough of an improvement over<br></p><p>   Dictionary(d.lazy.map { (k,v) in (k, transform(v)) })<br></p><p>(once we get that initializer) to make it worth expanding the Dictionary<br>API?<br></p><p>&gt; Another useful method (that could be used to build mapValues more efficiently)<br>&gt; would be `Dictionary.updateValue(value: Value, at index: DictionaryIndex)`, so<br>&gt; you could write:<br>&gt;<br>&gt; var dict = [&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3]<br>&gt; if let i = dict.index(where: { $0.value == 3 }) {<br>&gt; dict.updateValue(100, at: i)<br>&gt; }<br>&gt; // dict == [&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 100]<br></p><p>Indeed it would!<br></p><p>&gt; -Nate<br>&gt;<br>&gt;         On 13.04.2016 13:38, Ross O&#39;Brien via swift-evolution wrote:<br>&gt;<br>&gt;         +1 on mapValues.<br>&gt;<br>&gt;             DictionaryLiteral already throws an exception if it includes<br>&gt;             duplicate<br>&gt;             keys, so I&#39;d expect mapKeys to throw an error if multiple source<br>&gt;             keys<br>&gt;             mapped to the same destination key.<br>&gt;<br>&gt;             On Wed, Apr 13, 2016 at 11:28 AM, Miguel Angel Quinones via<br>&gt;             swift-evolution<br>&gt;             &lt;swift-evolution at swift.org<br>&gt;             &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;             wrote:<br>&gt;<br>&gt;             I&#39;m +1 for adding mapValues. Very useful functionality and trivial<br>&gt;             to<br>&gt;             implement.<br>&gt;<br>&gt;             &gt; &gt; I.e. I suggest to implement and mapKeys() also. It could be also<br>&gt;             useful in some situations.<br>&gt;             &gt; `mapKeys` is much more dangerous, because you could end up mapping<br>&gt;             many values into a single key. You kind of need to combine the<br>&gt;             values somehow. Perhaps:<br>&gt;             &gt;<br>&gt;             &gt; extension Dictionary {<br>&gt;             &gt; func mapValues__(_ valueTransform: @noescape Value throws<br>&gt;             -&gt;OutValue) rethrows -&gt;[Key: OutValue] { … }<br>&gt;             &gt;<br>&gt;             &gt; func mapKeys__(_ keyTransform: @noescape Key throws -&gt;OutKey)<br>&gt;             rethrows -&gt;[OutKey: [Value]] { … }<br>&gt;             &gt;<br>&gt;             &gt; // Possibly flatMap variants, too?<br>&gt;             &gt; }<br>&gt;             &gt;<br>&gt;             &gt; extension Dictionary where Value: Sequence {<br>&gt;             &gt; func reduceValues__(_ initial: OutValue, combine: @noescape<br>&gt;             (OutValue, Value.Iterator.Element) throws -&gt;OutValue) rethrows -&gt;<br>&gt;             [Key:<br>&gt;             OutValue] {<br>&gt;             &gt; return mapValues { $0.reduce(initial, combine: combine) }<br>&gt;             &gt; }<br>&gt;             &gt; }<br>&gt;             &gt;<br>&gt;             &gt; Which you would end up using like this:<br>&gt;             &gt;<br>&gt;             &gt; let wordFrequencies: [String: Int] = …<br>&gt;             &gt; let firstLetterFrequencies: [Character: Int] =<br>&gt;             wordFrequencies.mapKeys { $0.characters.first! }.reduceValues(0,<br>&gt;             combine: +)<br>&gt;             &gt;<br>&gt;             &gt; --<br>&gt;             &gt; Brent Royal-Gordon<br>&gt;             &gt; Architechies<br>&gt;             &gt;<br>&gt;             &gt;<br>&gt;             &gt;<br>&gt;             &gt;______<br>&gt;<br>&gt;             --<br>&gt;             Miguel Angel Quinones<br>&gt;<br>&gt;             _______________________________________________<br>&gt;             swift-evolution mailing list<br>&gt;             swift-evolution at swift.org<br>&gt;             &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;             _______________________________________________<br>&gt;             swift-evolution mailing list<br>&gt;             swift-evolution at swift.org<br>&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;         _______________________________________________<br>&gt;         swift-evolution mailing list<br>&gt;         swift-evolution at swift.org<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Proposal] mapValues</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>April 14, 2016 at 09:00:00am</p></header><div class="content"><p>I don&#39;t think I&#39;ve ever called map on a dictionary in production code, only<br>a mapValue function like this thread discusses. When do we actually want to<br>call map on a dictionary? I feel like mapValue should be the default.<br></p><p>I&#39;m wondering if `Dictionary&lt;String,Int&gt;.Element`should be `Value`, instead<br>of `(Key,Value)`.<br></p><p><br>With an array you can do this:<br></p><p>for (key, value) in [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].enumerate() {<br></p><p>    print(key, value) // 0 a, 1 b, 2 c<br></p><p>}<br></p><p><br>Shouldn&#39;t the equivalent for a dictionary be this?<br></p><p><br>for (key, value) in [&quot;a&quot;: 0, &quot;b&quot;: 1, &quot;c&quot;: 2].enumerate() {<br></p><p>    print(key, value) // a 0, b 1, c 2<br></p><p>}<br></p><p><br>Not this:<br></p><p><br>for (key, value) in [&quot;a&quot;: 0, &quot;b&quot;: 1, &quot;c&quot;: 2] {<br></p><p>    print(key, value) // a 0, b 1, c 2<br></p><p>}<br></p><p><br>Presumably the old syntax would produce only values:<br></p><p><br>for value in [&quot;a&quot;: 0, &quot;b&quot;: 1, &quot;c&quot;: 2] {<br></p><p>    print(value) // 0, 1, 2<br></p><p>}<br></p><p><br>You can still iterate the keys like this:<br></p><p><br>for key in [&quot;a&quot;: 0, &quot;b&quot;: 1, &quot;c&quot;: 2].keys {<br></p><p>    print(key) // a, b, c<br></p><p>}<br></p><p>I think I understand the reasoning for Dictionary the way it is, but I<br>think it only provides consistency to the implementation, not the interface.<br></p><p>The result of all this being that Dictionary is more consistent (IMO), and<br>map would work on the values of all collection types, not a mix of values<br>and key/value pairs.<br></p><p>What do you think?<br></p><p><br></p><p>On Thu, Apr 14, 2016 at 9:07 AM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Wed Apr 13 2016, Nate Cook &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt;     On Apr 13, 2016, at 12:02 PM, Jacob Bandes-Storch via swift-evolution<br>&gt; &gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;     To adhere to the API Design Guidelines, I think it should be named<br>&gt; &gt;     &quot;mappingValues&quot;, right?<br>&gt; &gt;<br>&gt; &gt;     On Wed, Apr 13, 2016 at 4:23 AM, Vladimir.S via swift-evolution<br>&gt; &gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;     As for mapKeys and many values into a single key. I believe we<br>&gt; should have a<br>&gt; &gt;         choice - do we expect multiply values for the same key or not.<br>&gt; Just like<br>&gt; &gt;         &quot;+&quot; and integer overflow : by default it raises the error, but<br>&gt; if &quot;&amp;+&quot; -<br>&gt; &gt;         we expect the overflow. I can imagine situations when it is ok<br>&gt; for me to<br>&gt; &gt;         have different values for the same key(if I don&#39;t care which of<br>&gt; values<br>&gt; &gt;         should be for that key in result dictionary).<br>&gt; &gt;         So my proposal is some additional mapKey(allowMultiplyValues:<br>&gt; true)<br>&gt; &gt;         {...} or in any other form/name.<br>&gt; &gt;<br>&gt; &gt; There&#39;s a proposal (awaiting merging) to add Dictionary initializers and<br>&gt; methods<br>&gt; &gt; that work with key/value pairs. These provide different ways of dealing<br>&gt; with the<br>&gt; &gt; duplicate key issue after a call to the regular Collection.map method.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; https://github.com/natecook1000/swift-evolution/blob/natecook-dictionary-merge/proposals/0000-add-sequence-based-init-and-merge-to-dictionary.md<br>&gt;<br>&gt; Ah, yes, that reminds me of your answer to the question about whether we<br>&gt; need a “uniquingKeys” label on that init(), which IMO is a good one: no,<br>&gt; we don&#39;t need it, because the one without the label traps on duplicate<br>&gt; keys.<br>&gt;<br>&gt; &gt; I&#39;d be interested in a `mapValues` or `transformValues` method that<br>&gt; would modify<br>&gt; &gt; values in place while leaving keys alone.<br>&gt;<br>&gt; Is that enough of an improvement over<br>&gt;<br>&gt;    Dictionary(d.lazy.map { (k,v) in (k, transform(v)) })<br>&gt;<br>&gt; (once we get that initializer) to make it worth expanding the Dictionary<br>&gt; API?<br>&gt;<br>&gt; &gt; Another useful method (that could be used to build mapValues more<br>&gt; efficiently)<br>&gt; &gt; would be `Dictionary.updateValue(value: Value, at index:<br>&gt; DictionaryIndex)`, so<br>&gt; &gt; you could write:<br>&gt; &gt;<br>&gt; &gt; var dict = [&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3]<br>&gt; &gt; if let i = dict.index(where: { $0.value == 3 }) {<br>&gt; &gt; dict.updateValue(100, at: i)<br>&gt; &gt; }<br>&gt; &gt; // dict == [&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 100]<br>&gt;<br>&gt; Indeed it would!<br>&gt;<br>&gt; &gt; -Nate<br>&gt; &gt;<br>&gt; &gt;         On 13.04.2016 13:38, Ross O&#39;Brien via swift-evolution wrote:<br>&gt; &gt;<br>&gt; &gt;         +1 on mapValues.<br>&gt; &gt;<br>&gt; &gt;             DictionaryLiteral already throws an exception if it includes<br>&gt; &gt;             duplicate<br>&gt; &gt;             keys, so I&#39;d expect mapKeys to throw an error if multiple<br>&gt; source<br>&gt; &gt;             keys<br>&gt; &gt;             mapped to the same destination key.<br>&gt; &gt;<br>&gt; &gt;             On Wed, Apr 13, 2016 at 11:28 AM, Miguel Angel Quinones via<br>&gt; &gt;             swift-evolution<br>&gt; &gt;             &lt;swift-evolution at swift.org<br>&gt; &gt;             &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;             wrote:<br>&gt; &gt;<br>&gt; &gt;             I&#39;m +1 for adding mapValues. Very useful functionality and<br>&gt; trivial<br>&gt; &gt;             to<br>&gt; &gt;             implement.<br>&gt; &gt;<br>&gt; &gt;             &gt; &gt; I.e. I suggest to implement and mapKeys() also. It could<br>&gt; be also<br>&gt; &gt;             useful in some situations.<br>&gt; &gt;             &gt; `mapKeys` is much more dangerous, because you could end up<br>&gt; mapping<br>&gt; &gt;             many values into a single key. You kind of need to combine<br>&gt; the<br>&gt; &gt;             values somehow. Perhaps:<br>&gt; &gt;             &gt;<br>&gt; &gt;             &gt; extension Dictionary {<br>&gt; &gt;             &gt; func mapValues__(_ valueTransform: @noescape Value throws<br>&gt; &gt;             -&gt;OutValue) rethrows -&gt;[Key: OutValue] { … }<br>&gt; &gt;             &gt;<br>&gt; &gt;             &gt; func mapKeys__(_ keyTransform: @noescape Key throws<br>&gt; -&gt;OutKey)<br>&gt; &gt;             rethrows -&gt;[OutKey: [Value]] { … }<br>&gt; &gt;             &gt;<br>&gt; &gt;             &gt; // Possibly flatMap variants, too?<br>&gt; &gt;             &gt; }<br>&gt; &gt;             &gt;<br>&gt; &gt;             &gt; extension Dictionary where Value: Sequence {<br>&gt; &gt;             &gt; func reduceValues__(_ initial: OutValue, combine: @noescape<br>&gt; &gt;             (OutValue, Value.Iterator.Element) throws -&gt;OutValue)<br>&gt; rethrows -&gt;<br>&gt; &gt;             [Key:<br>&gt; &gt;             OutValue] {<br>&gt; &gt;             &gt; return mapValues { $0.reduce(initial, combine: combine) }<br>&gt; &gt;             &gt; }<br>&gt; &gt;             &gt; }<br>&gt; &gt;             &gt;<br>&gt; &gt;             &gt; Which you would end up using like this:<br>&gt; &gt;             &gt;<br>&gt; &gt;             &gt; let wordFrequencies: [String: Int] = …<br>&gt; &gt;             &gt; let firstLetterFrequencies: [Character: Int] =<br>&gt; &gt;             wordFrequencies.mapKeys { $0.characters.first!<br>&gt; }.reduceValues(0,<br>&gt; &gt;             combine: +)<br>&gt; &gt;             &gt;<br>&gt; &gt;             &gt; --<br>&gt; &gt;             &gt; Brent Royal-Gordon<br>&gt; &gt;             &gt; Architechies<br>&gt; &gt;             &gt;<br>&gt; &gt;             &gt;<br>&gt; &gt;             &gt;<br>&gt; &gt;             &gt;______<br>&gt; &gt;<br>&gt; &gt;             --<br>&gt; &gt;             Miguel Angel Quinones<br>&gt; &gt;<br>&gt; &gt;             _______________________________________________<br>&gt; &gt;             swift-evolution mailing list<br>&gt; &gt;             swift-evolution at swift.org<br>&gt; &gt;             &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;             _______________________________________________<br>&gt; &gt;             swift-evolution mailing list<br>&gt; &gt;             swift-evolution at swift.org<br>&gt; &gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;         _______________________________________________<br>&gt; &gt;         swift-evolution mailing list<br>&gt; &gt;         swift-evolution at swift.org<br>&gt; &gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;     _______________________________________________<br>&gt; &gt;     swift-evolution mailing list<br>&gt; &gt;     swift-evolution at swift.org<br>&gt; &gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/61f44e19/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal] mapValues</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 14, 2016 at 09:00:00am</p></header><div class="content"><p>on Wed Apr 13 2016, Andrew Bennett &lt;cacoyi-AT-gmail.com&gt; wrote:<br></p><p>&gt; I&#39;m wondering if `Dictionary&lt;String,Int&gt;.Element`should be `Value`,<br>&gt; instead of `(Key,Value)`.<br></p><p><br>I think(?) it&#39;s fairly unprecedented.  Python sets the<br>*opposite* precedent, FWIW (a dict is a sequence of its keys).<br></p><p>One possible upside is that Dictionary becomes a MutableCollection.<br></p><p>&gt; With an array you can do this:<br>&gt;<br>&gt; for (key, value) in [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].enumerate() {<br>&gt;<br>&gt; print(key, value) // 0 a, 1 b, 2 c<br>&gt;<br>&gt; }<br>&gt;<br>&gt; Shouldn&#39;t the equivalent for a dictionary be this? <br>&gt;<br>&gt; for (key, value) in [&quot;a&quot;: 0, &quot;b&quot;: 1, &quot;c&quot;: 2].enumerate() {<br>&gt;<br>&gt; print(key, value) // a 0, b 1, c 2<br>&gt;<br>&gt; }<br></p><p>Not unless you can come up with a generic definition of the semantics of<br>enumerate() that allows the first element of the pair to be the index in<br>some cases and the key in others.  Right now, enumerate() works on<br>sequences, which you would probably have to drop.  Also, don&#39;t forget,<br>Dictionaries still need indices distinct from their keys, because you<br>shouldn&#39;t have to do a hash lookup just to advance to the next element.<br></p><p>&gt; Not this: <br>&gt;<br>&gt; for (key, value) in [&quot;a&quot;: 0, &quot;b&quot;: 1, &quot;c&quot;: 2] {<br>&gt;<br>&gt; print(key, value) // a 0, b 1, c 2<br>&gt;<br>&gt; }<br>&gt;<br>&gt; Presumably the old syntax would produce only values:<br>&gt;<br>&gt; for value in [&quot;a&quot;: 0, &quot;b&quot;: 1, &quot;c&quot;: 2] {<br>&gt;<br>&gt; print(value) // 0, 1, 2<br>&gt;<br>&gt; }<br>&gt;<br>&gt; You can still iterate the keys like this:<br>&gt;<br>&gt; for key in [&quot;a&quot;: 0, &quot;b&quot;: 1, &quot;c&quot;: 2].keys {<br>&gt;<br>&gt; print(key) // a, b, c<br>&gt;<br>&gt; }<br></p><p>To get them both, I suppose you&#39;d write zip(d.keys, d.values).<br></p><p>&gt; I think I understand the reasoning for Dictionary the way it is, but I<br>&gt; think it only provides consistency to the implementation, not the<br>&gt; interface.<br></p><p>Dictionary was not defined the way it is for implementation reasons.  In<br>fact, the keys and values are currently stored in separate arrays.  You<br>are suggesting a different conceptual model for dictionaries, and it<br>might even be an improvement, but that doesn&#39;t mean the current design<br>is implementation-driven.<br></p><p>&gt; The result of all this being that Dictionary is more consistent (IMO), and map<br>&gt; would work on the values of all collection types, not a mix of values and<br>&gt; key/value pairs.<br>&gt;<br>&gt; What do you think?<br></p><p>It&#39;s an interesting idea, worthy of consideration.  I suspect there are<br>probably lots more arguments to be made here, that haven&#39;t occurred to<br>either of us yet, and maybe some serious downsides.  I hope to hear more<br>about it from others.<br></p><p>&gt; On Thu, Apr 14, 2016 at 9:07 AM, Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     on Wed Apr 13 2016, Nate Cook &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     &gt; On Apr 13, 2016, at 12:02 PM, Jacob Bandes-Storch via swift-evolution<br>&gt;     &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;     &gt;<br>&gt;     &gt; To adhere to the API Design Guidelines, I think it should be named<br>&gt;     &gt; &quot;mappingValues&quot;, right?<br>&gt;     &gt;<br>&gt;     &gt; On Wed, Apr 13, 2016 at 4:23 AM, Vladimir.S via swift-evolution<br>&gt;     &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;     &gt;<br>&gt;     &gt; As for mapKeys and many values into a single key. I believe we should have<br>&gt;     a<br>&gt;     &gt; choice - do we expect multiply values for the same key or not. Just like<br>&gt;     &gt; &quot;+&quot; and integer overflow : by default it raises the error, but if &quot;&amp;+&quot; -<br>&gt;     &gt; we expect the overflow. I can imagine situations when it is ok for me to<br>&gt;     &gt; have different values for the same key(if I don&#39;t care which of values<br>&gt;     &gt; should be for that key in result dictionary).<br>&gt;     &gt; So my proposal is some additional mapKey(allowMultiplyValues: true)<br>&gt;     &gt; {...} or in any other form/name.<br>&gt;     &gt;<br>&gt;     &gt; There&#39;s a proposal (awaiting merging) to add Dictionary initializers and<br>&gt;     methods<br>&gt;     &gt; that work with key/value pairs. These provide different ways of dealing<br>&gt;     with the<br>&gt;     &gt; duplicate key issue after a call to the regular Collection.map method.<br>&gt;     &gt;<br>&gt;     &gt;<br>&gt;     https://github.com/natecook1000/swift-evolution/blob/natecook-dictionary-merge/proposals/0000-add-sequence-based-init-and-merge-to-dictionary.md<br>&gt;<br>&gt;     Ah, yes, that reminds me of your answer to the question about whether we<br>&gt;     need a “uniquingKeys” label on that init(), which IMO is a good one: no,<br>&gt;     we don&#39;t need it, because the one without the label traps on duplicate<br>&gt;     keys.<br>&gt;<br>&gt;     &gt; I&#39;d be interested in a `mapValues` or `transformValues` method that would<br>&gt;     modify<br>&gt;     &gt; values in place while leaving keys alone.<br>&gt;<br>&gt;     Is that enough of an improvement over<br>&gt;<br>&gt;     Dictionary(d.lazy.map { (k,v) in (k, transform(v)) })<br>&gt;<br>&gt;     (once we get that initializer) to make it worth expanding the Dictionary<br>&gt;     API?<br>&gt;<br>&gt;     &gt; Another useful method (that could be used to build mapValues more<br>&gt;     efficiently)<br>&gt;     &gt; would be `Dictionary.updateValue(value: Value, at index: DictionaryIndex)<br>&gt;     `, so<br>&gt;     &gt; you could write:<br>&gt;     &gt;<br>&gt;     &gt; var dict = [&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3]<br>&gt;     &gt; if let i = dict.index(where: { $0.value == 3 }) {<br>&gt;     &gt; dict.updateValue(100, at: i)<br>&gt;     &gt; }<br>&gt;     &gt; // dict == [&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 100]<br>&gt;<br>&gt;     Indeed it would!<br>&gt;<br>&gt;     &gt; -Nate<br>&gt;     &gt;<br>&gt;     &gt; On 13.04.2016 13:38, Ross O&#39;Brien via swift-evolution wrote:<br>&gt;     &gt;<br>&gt;     &gt; +1 on mapValues.<br>&gt;     &gt;<br>&gt;     &gt; DictionaryLiteral already throws an exception if it includes<br>&gt;     &gt; duplicate<br>&gt;     &gt; keys, so I&#39;d expect mapKeys to throw an error if multiple source<br>&gt;     &gt; keys<br>&gt;     &gt; mapped to the same destination key.<br>&gt;     &gt;<br>&gt;     &gt; On Wed, Apr 13, 2016 at 11:28 AM, Miguel Angel Quinones via<br>&gt;     &gt; swift-evolution<br>&gt;     &gt; &lt;swift-evolution at swift.org<br>&gt;     &gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;     &gt; wrote:<br>&gt;     &gt;<br>&gt;     &gt; I&#39;m +1 for adding mapValues. Very useful functionality and trivial<br>&gt;     &gt; to<br>&gt;     &gt; implement.<br>&gt;     &gt;<br>&gt;     &gt; &gt; &gt; I.e. I suggest to implement and mapKeys() also. It could be also<br>&gt;     &gt; useful in some situations.<br>&gt;     &gt; &gt; `mapKeys` is much more dangerous, because you could end up mapping<br>&gt;     &gt; many values into a single key. You kind of need to combine the<br>&gt;     &gt; values somehow. Perhaps:<br>&gt;     &gt; &gt;<br>&gt;     &gt; &gt; extension Dictionary {<br>&gt;     &gt; &gt; func mapValues__(_ valueTransform: @noescape Value throws<br>&gt;     &gt; -&gt;OutValue) rethrows -&gt;[Key: OutValue] { … }<br>&gt;     &gt; &gt;<br>&gt;     &gt; &gt; func mapKeys__(_ keyTransform: @noescape Key throws -&gt;OutKey)<br>&gt;     &gt; rethrows -&gt;[OutKey: [Value]] { … }<br>&gt;     &gt; &gt;<br>&gt;     &gt; &gt; // Possibly flatMap variants, too?<br>&gt;     &gt; &gt; }<br>&gt;     &gt; &gt;<br>&gt;     &gt; &gt; extension Dictionary where Value: Sequence {<br>&gt;     &gt; &gt; func reduceValues__(_ initial: OutValue, combine: @noescape<br>&gt;     &gt; (OutValue, Value.Iterator.Element) throws -&gt;OutValue) rethrows -&gt;<br>&gt;     &gt; [Key:<br>&gt;     &gt; OutValue] {<br>&gt;     &gt; &gt; return mapValues { $0.reduce(initial, combine: combine) }<br>&gt;     &gt; &gt; }<br>&gt;     &gt; &gt; }<br>&gt;     &gt; &gt;<br>&gt;     &gt; &gt; Which you would end up using like this:<br>&gt;     &gt; &gt;<br>&gt;     &gt; &gt; let wordFrequencies: [String: Int] = …<br>&gt;     &gt; &gt; let firstLetterFrequencies: [Character: Int] =<br>&gt;     &gt; wordFrequencies.mapKeys { $0.characters.first! }.reduceValues(0,<br>&gt;     &gt; combine: +)<br>&gt;     &gt; &gt;<br>&gt;     &gt; &gt; --<br>&gt;     &gt; &gt; Brent Royal-Gordon<br>&gt;     &gt; &gt; Architechies<br>&gt;     &gt; &gt;<br>&gt;     &gt; &gt;<br>&gt;     &gt; &gt;<br>&gt;     &gt; &gt;______<br>&gt;     &gt;<br>&gt;     &gt; --<br>&gt;     &gt; Miguel Angel Quinones<br>&gt;     &gt;<br>&gt;     &gt; _______________________________________________<br>&gt;     &gt; swift-evolution mailing list<br>&gt;     &gt; swift-evolution at swift.org<br>&gt;     &gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &gt;<br>&gt;     &gt; _______________________________________________<br>&gt;     &gt; swift-evolution mailing list<br>&gt;     &gt; swift-evolution at swift.org<br>&gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &gt;<br>&gt;     &gt; _______________________________________________<br>&gt;     &gt; swift-evolution mailing list<br>&gt;     &gt; swift-evolution at swift.org<br>&gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &gt;<br>&gt;     &gt; _______________________________________________<br>&gt;     &gt; swift-evolution mailing list<br>&gt;     &gt; swift-evolution at swift.org<br>&gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &gt;<br>&gt;     &gt; _______________________________________________<br>&gt;     &gt; swift-evolution mailing list<br>&gt;     &gt; swift-evolution at swift.org<br>&gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;     --<br>&gt;     Dave<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Proposal] mapValues</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>April 15, 2016 at 09:00:00pm</p></header><div class="content"><p>This is a clarification on what I meant (I haven&#39;t had much time to test<br>it, but I think it&#39;s representative):<br></p><p>https://gist.github.com/therealbnut/c223d90a34bb14448b65fc6cc0ec70ac<br></p><p>Sorry if I&#39;ve derailed this conversation, I&#39;m in support of mapValues, but<br>I feel like map itself should be mapping the values. Let me know if I<br>should discuss this in another thread.<br></p><p><br>On Fri, Apr 15, 2016 at 2:23 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; on Wed Apr 13 2016, Andrew Bennett &lt;cacoyi-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt; &gt; I&#39;m wondering if `Dictionary&lt;String,Int&gt;.Element`should be `Value`,<br>&gt; &gt; instead of `(Key,Value)`.<br>&gt;<br>&gt;<br>&gt; I think(?) it&#39;s fairly unprecedented.  Python sets the<br>&gt; *opposite* precedent, FWIW (a dict is a sequence of its keys).<br>&gt;<br>&gt; One possible upside is that Dictionary becomes a MutableCollection.<br>&gt;<br>&gt; &gt; With an array you can do this:<br>&gt; &gt;<br>&gt; &gt; for (key, value) in [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].enumerate() {<br>&gt; &gt;<br>&gt; &gt; print(key, value) // 0 a, 1 b, 2 c<br>&gt; &gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Shouldn&#39;t the equivalent for a dictionary be this?<br>&gt; &gt;<br>&gt; &gt; for (key, value) in [&quot;a&quot;: 0, &quot;b&quot;: 1, &quot;c&quot;: 2].enumerate() {<br>&gt; &gt;<br>&gt; &gt; print(key, value) // a 0, b 1, c 2<br>&gt; &gt;<br>&gt; &gt; }<br>&gt;<br>&gt; Not unless you can come up with a generic definition of the semantics of<br>&gt; enumerate() that allows the first element of the pair to be the index in<br>&gt; some cases and the key in others.  Right now, enumerate() works on<br>&gt; sequences, which you would probably have to drop.  Also, don&#39;t forget,<br>&gt; Dictionaries still need indices distinct from their keys, because you<br>&gt; shouldn&#39;t have to do a hash lookup just to advance to the next element.<br>&gt;<br>&gt; &gt; Not this:<br>&gt; &gt;<br>&gt; &gt; for (key, value) in [&quot;a&quot;: 0, &quot;b&quot;: 1, &quot;c&quot;: 2] {<br>&gt; &gt;<br>&gt; &gt; print(key, value) // a 0, b 1, c 2<br>&gt; &gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Presumably the old syntax would produce only values:<br>&gt; &gt;<br>&gt; &gt; for value in [&quot;a&quot;: 0, &quot;b&quot;: 1, &quot;c&quot;: 2] {<br>&gt; &gt;<br>&gt; &gt; print(value) // 0, 1, 2<br>&gt; &gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; You can still iterate the keys like this:<br>&gt; &gt;<br>&gt; &gt; for key in [&quot;a&quot;: 0, &quot;b&quot;: 1, &quot;c&quot;: 2].keys {<br>&gt; &gt;<br>&gt; &gt; print(key) // a, b, c<br>&gt; &gt;<br>&gt; &gt; }<br>&gt;<br>&gt; To get them both, I suppose you&#39;d write zip(d.keys, d.values).<br>&gt;<br>&gt; &gt; I think I understand the reasoning for Dictionary the way it is, but I<br>&gt; &gt; think it only provides consistency to the implementation, not the<br>&gt; &gt; interface.<br>&gt;<br>&gt; Dictionary was not defined the way it is for implementation reasons.  In<br>&gt; fact, the keys and values are currently stored in separate arrays.  You<br>&gt; are suggesting a different conceptual model for dictionaries, and it<br>&gt; might even be an improvement, but that doesn&#39;t mean the current design<br>&gt; is implementation-driven.<br>&gt;<br>&gt; &gt; The result of all this being that Dictionary is more consistent (IMO),<br>&gt; and map<br>&gt; &gt; would work on the values of all collection types, not a mix of values and<br>&gt; &gt; key/value pairs.<br>&gt; &gt;<br>&gt; &gt; What do you think?<br>&gt;<br>&gt; It&#39;s an interesting idea, worthy of consideration.  I suspect there are<br>&gt; probably lots more arguments to be made here, that haven&#39;t occurred to<br>&gt; either of us yet, and maybe some serious downsides.  I hope to hear more<br>&gt; about it from others.<br>&gt;<br>&gt; &gt; On Thu, Apr 14, 2016 at 9:07 AM, Dave Abrahams via swift-evolution<br>&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;     on Wed Apr 13 2016, Nate Cook &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;     &gt; On Apr 13, 2016, at 12:02 PM, Jacob Bandes-Storch via<br>&gt; swift-evolution<br>&gt; &gt;     &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; To adhere to the API Design Guidelines, I think it should be named<br>&gt; &gt;     &gt; &quot;mappingValues&quot;, right?<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; On Wed, Apr 13, 2016 at 4:23 AM, Vladimir.S via swift-evolution<br>&gt; &gt;     &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; As for mapKeys and many values into a single key. I believe we<br>&gt; should have<br>&gt; &gt;     a<br>&gt; &gt;     &gt; choice - do we expect multiply values for the same key or not.<br>&gt; Just like<br>&gt; &gt;     &gt; &quot;+&quot; and integer overflow : by default it raises the error, but if<br>&gt; &quot;&amp;+&quot; -<br>&gt; &gt;     &gt; we expect the overflow. I can imagine situations when it is ok for<br>&gt; me to<br>&gt; &gt;     &gt; have different values for the same key(if I don&#39;t care which of<br>&gt; values<br>&gt; &gt;     &gt; should be for that key in result dictionary).<br>&gt; &gt;     &gt; So my proposal is some additional mapKey(allowMultiplyValues: true)<br>&gt; &gt;     &gt; {...} or in any other form/name.<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; There&#39;s a proposal (awaiting merging) to add Dictionary<br>&gt; initializers and<br>&gt; &gt;     methods<br>&gt; &gt;     &gt; that work with key/value pairs. These provide different ways of<br>&gt; dealing<br>&gt; &gt;     with the<br>&gt; &gt;     &gt; duplicate key issue after a call to the regular Collection.map<br>&gt; method.<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt;<br>&gt; &gt;<br>&gt; https://github.com/natecook1000/swift-evolution/blob/natecook-dictionary-merge/proposals/0000-add-sequence-based-init-and-merge-to-dictionary.md<br>&gt; &gt;<br>&gt; &gt;     Ah, yes, that reminds me of your answer to the question about<br>&gt; whether we<br>&gt; &gt;     need a “uniquingKeys” label on that init(), which IMO is a good one:<br>&gt; no,<br>&gt; &gt;     we don&#39;t need it, because the one without the label traps on<br>&gt; duplicate<br>&gt; &gt;     keys.<br>&gt; &gt;<br>&gt; &gt;     &gt; I&#39;d be interested in a `mapValues` or `transformValues` method<br>&gt; that would<br>&gt; &gt;     modify<br>&gt; &gt;     &gt; values in place while leaving keys alone.<br>&gt; &gt;<br>&gt; &gt;     Is that enough of an improvement over<br>&gt; &gt;<br>&gt; &gt;     Dictionary(d.lazy.map { (k,v) in (k, transform(v)) })<br>&gt; &gt;<br>&gt; &gt;     (once we get that initializer) to make it worth expanding the<br>&gt; Dictionary<br>&gt; &gt;     API?<br>&gt; &gt;<br>&gt; &gt;     &gt; Another useful method (that could be used to build mapValues more<br>&gt; &gt;     efficiently)<br>&gt; &gt;     &gt; would be `Dictionary.updateValue(value: Value, at index:<br>&gt; DictionaryIndex)<br>&gt; &gt;     `, so<br>&gt; &gt;     &gt; you could write:<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; var dict = [&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3]<br>&gt; &gt;     &gt; if let i = dict.index(where: { $0.value == 3 }) {<br>&gt; &gt;     &gt; dict.updateValue(100, at: i)<br>&gt; &gt;     &gt; }<br>&gt; &gt;     &gt; // dict == [&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 100]<br>&gt; &gt;<br>&gt; &gt;     Indeed it would!<br>&gt; &gt;<br>&gt; &gt;     &gt; -Nate<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; On 13.04.2016 13:38, Ross O&#39;Brien via swift-evolution wrote:<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; +1 on mapValues.<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; DictionaryLiteral already throws an exception if it includes<br>&gt; &gt;     &gt; duplicate<br>&gt; &gt;     &gt; keys, so I&#39;d expect mapKeys to throw an error if multiple source<br>&gt; &gt;     &gt; keys<br>&gt; &gt;     &gt; mapped to the same destination key.<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; On Wed, Apr 13, 2016 at 11:28 AM, Miguel Angel Quinones via<br>&gt; &gt;     &gt; swift-evolution<br>&gt; &gt;     &gt; &lt;swift-evolution at swift.org<br>&gt; &gt;     &gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;     &gt; wrote:<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; I&#39;m +1 for adding mapValues. Very useful functionality and trivial<br>&gt; &gt;     &gt; to<br>&gt; &gt;     &gt; implement.<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; &gt; &gt; I.e. I suggest to implement and mapKeys() also. It could be<br>&gt; also<br>&gt; &gt;     &gt; useful in some situations.<br>&gt; &gt;     &gt; &gt; `mapKeys` is much more dangerous, because you could end up<br>&gt; mapping<br>&gt; &gt;     &gt; many values into a single key. You kind of need to combine the<br>&gt; &gt;     &gt; values somehow. Perhaps:<br>&gt; &gt;     &gt; &gt;<br>&gt; &gt;     &gt; &gt; extension Dictionary {<br>&gt; &gt;     &gt; &gt; func mapValues__(_ valueTransform: @noescape Value throws<br>&gt; &gt;     &gt; -&gt;OutValue) rethrows -&gt;[Key: OutValue] { … }<br>&gt; &gt;     &gt; &gt;<br>&gt; &gt;     &gt; &gt; func mapKeys__(_ keyTransform: @noescape Key throws -&gt;OutKey)<br>&gt; &gt;     &gt; rethrows -&gt;[OutKey: [Value]] { … }<br>&gt; &gt;     &gt; &gt;<br>&gt; &gt;     &gt; &gt; // Possibly flatMap variants, too?<br>&gt; &gt;     &gt; &gt; }<br>&gt; &gt;     &gt; &gt;<br>&gt; &gt;     &gt; &gt; extension Dictionary where Value: Sequence {<br>&gt; &gt;     &gt; &gt; func reduceValues__(_ initial: OutValue, combine: @noescape<br>&gt; &gt;     &gt; (OutValue, Value.Iterator.Element) throws -&gt;OutValue) rethrows -&gt;<br>&gt; &gt;     &gt; [Key:<br>&gt; &gt;     &gt; OutValue] {<br>&gt; &gt;     &gt; &gt; return mapValues { $0.reduce(initial, combine: combine) }<br>&gt; &gt;     &gt; &gt; }<br>&gt; &gt;     &gt; &gt; }<br>&gt; &gt;     &gt; &gt;<br>&gt; &gt;     &gt; &gt; Which you would end up using like this:<br>&gt; &gt;     &gt; &gt;<br>&gt; &gt;     &gt; &gt; let wordFrequencies: [String: Int] = …<br>&gt; &gt;     &gt; &gt; let firstLetterFrequencies: [Character: Int] =<br>&gt; &gt;     &gt; wordFrequencies.mapKeys { $0.characters.first! }.reduceValues(0,<br>&gt; &gt;     &gt; combine: +)<br>&gt; &gt;     &gt; &gt;<br>&gt; &gt;     &gt; &gt; --<br>&gt; &gt;     &gt; &gt; Brent Royal-Gordon<br>&gt; &gt;     &gt; &gt; Architechies<br>&gt; &gt;     &gt; &gt;<br>&gt; &gt;     &gt; &gt;<br>&gt; &gt;     &gt; &gt;<br>&gt; &gt;     &gt; &gt;______<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; --<br>&gt; &gt;     &gt; Miguel Angel Quinones<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; _______________________________________________<br>&gt; &gt;     &gt; swift-evolution mailing list<br>&gt; &gt;     &gt; swift-evolution at swift.org<br>&gt; &gt;     &gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; _______________________________________________<br>&gt; &gt;     &gt; swift-evolution mailing list<br>&gt; &gt;     &gt; swift-evolution at swift.org<br>&gt; &gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; _______________________________________________<br>&gt; &gt;     &gt; swift-evolution mailing list<br>&gt; &gt;     &gt; swift-evolution at swift.org<br>&gt; &gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; _______________________________________________<br>&gt; &gt;     &gt; swift-evolution mailing list<br>&gt; &gt;     &gt; swift-evolution at swift.org<br>&gt; &gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; _______________________________________________<br>&gt; &gt;     &gt; swift-evolution mailing list<br>&gt; &gt;     &gt; swift-evolution at swift.org<br>&gt; &gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;     --<br>&gt; &gt;     Dave<br>&gt; &gt;<br>&gt; &gt;     _______________________________________________<br>&gt; &gt;     swift-evolution mailing list<br>&gt; &gt;     swift-evolution at swift.org<br>&gt; &gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/999f6c41/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] mapValues</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 15, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; This is a clarification on what I meant (I haven&#39;t had much time to test it, but I think it&#39;s representative):<br>&gt; <br>&gt; https://gist.github.com/therealbnut/c223d90a34bb14448b65fc6cc0ec70ac<br></p><p>There are a number of problems with this:<br></p><p>* Given just an `Index`, you need to be able to calculate the next `Index`, and check if it lies before the `endIndex`. The complexity of this is hidden in your example because you&#39;re relying on a traditional `DictionaryIndex` to perform these tasks. Thus, the `Index` type in your dictionary design would be some sort of wrapper-around-the-key, not the key itself. That&#39;s the source of the `subscript(_: Index) -&gt; Value` which apparently confused you.<br></p><p>* Generic `SequenceType` and `CollectionType` operations now use only the values, not the keys and values. That means that `Array(newDictionary)` gets you an array of values, `filter` returns an array of values, `reduce` operates only on the values, etc; all of these operations throw away the keys. That&#39;s not necessarily wrong, but I&#39;m not sure that you&#39;re aware of it.<br></p><p>* Your `map` is overloading `SequenceType.map` merely by return type. That means you can no longer assign it directly to a newly-declared variable, or use it in many other contexts where the type has to be inferred.<br></p><p>* Your `enumerate` is similarly overloading by return type. It&#39;s also further confusing an already confused semantic. `enumerate` does not pair elements with their indices; it pairs them with integers starting at zero. This *happens* to correspond to their array indices, but that&#39;s not necessarily true of any other Collection. (I&#39;m going to start another thread about this.)<br></p><p>Basically, in this conception of Dictionary:<br></p><p>* The keys are disposable and the values are the important part—most operations on a Dictionary would throw away the keys and use only the values.<br>* Index still would not be a Key—it would be some kind of instance which wrapped or converted into a Key.<br>* You still would need to name Dictionary-creating `map` and similar functions differently from their Array-generating cousins.<br>* Iterating over keys and values together would require some kind of Dictionary-specific API, not something that was available on other collections or sequences.<br></p><p>Maybe that would be an improvement, but I&#39;m skeptical.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Proposal] mapValues</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>April 16, 2016 at 10:00:00am</p></header><div class="content"><p>Thanks Brent for your in-depth response - I&#39;ve responded in another thread<br>so we don&#39;t pollute this one (sorry Jonathan):<br>http://thread.gmane.org/gmane.comp.lang.swift.evolution/14665<br></p><p>I think mapValues is great, and really needed in Swift.<br></p><p>I&#39;m a definite +1 on a version of map that only maps the values.<br></p><p><br>On Sat, Apr 16, 2016 at 7:56 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; This is a clarification on what I meant (I haven&#39;t had much time to test<br>&gt; it, but I think it&#39;s representative):<br>&gt; &gt;<br>&gt; &gt; https://gist.github.com/therealbnut/c223d90a34bb14448b65fc6cc0ec70ac<br>&gt;<br>&gt; There are a number of problems with this:<br>&gt;<br>&gt; * Given just an `Index`, you need to be able to calculate the next<br>&gt; `Index`, and check if it lies before the `endIndex`. The complexity of this<br>&gt; is hidden in your example because you&#39;re relying on a traditional<br>&gt; `DictionaryIndex` to perform these tasks. Thus, the `Index` type in your<br>&gt; dictionary design would be some sort of wrapper-around-the-key, not the key<br>&gt; itself. That&#39;s the source of the `subscript(_: Index) -&gt; Value` which<br>&gt; apparently confused you.<br>&gt;<br>&gt; * Generic `SequenceType` and `CollectionType` operations now use only the<br>&gt; values, not the keys and values. That means that `Array(newDictionary)`<br>&gt; gets you an array of values, `filter` returns an array of values, `reduce`<br>&gt; operates only on the values, etc; all of these operations throw away the<br>&gt; keys. That&#39;s not necessarily wrong, but I&#39;m not sure that you&#39;re aware of<br>&gt; it.<br>&gt;<br>&gt; * Your `map` is overloading `SequenceType.map` merely by return type. That<br>&gt; means you can no longer assign it directly to a newly-declared variable, or<br>&gt; use it in many other contexts where the type has to be inferred.<br>&gt;<br>&gt; * Your `enumerate` is similarly overloading by return type. It&#39;s also<br>&gt; further confusing an already confused semantic. `enumerate` does not pair<br>&gt; elements with their indices; it pairs them with integers starting at zero.<br>&gt; This *happens* to correspond to their array indices, but that&#39;s not<br>&gt; necessarily true of any other Collection. (I&#39;m going to start another<br>&gt; thread about this.)<br>&gt;<br>&gt; Basically, in this conception of Dictionary:<br>&gt;<br>&gt; * The keys are disposable and the values are the important part—most<br>&gt; operations on a Dictionary would throw away the keys and use only the<br>&gt; values.<br>&gt; * Index still would not be a Key—it would be some kind of instance which<br>&gt; wrapped or converted into a Key.<br>&gt; * You still would need to name Dictionary-creating `map` and similar<br>&gt; functions differently from their Array-generating cousins.<br>&gt; * Iterating over keys and values together would require some kind of<br>&gt; Dictionary-specific API, not something that was available on other<br>&gt; collections or sequences.<br>&gt;<br>&gt; Maybe that would be an improvement, but I&#39;m skeptical.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160416/9d42c42b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
