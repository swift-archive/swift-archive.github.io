<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>March  3, 2016 at 05:00:00pm</p></header><div class="content"><p>*Situation*<br>Currently GeneratorType.next() requires callers to not call next() after it<br>has returned nil once, even encouraging a preconditionFailure() if this is<br>violated:<br></p><p>  /// - Requires: `next()` has not been applied to a copy of `self`<br></p><p>  ///   since the copy was made, and no preceding call to `self.next()`<br></p><p>  ///   has returned `nil`.  Specific implementations of this protocol<br></p><p>  ///   are encouraged to respond to violations of this requirement by<br></p><p>  ///   calling `preconditionFailure(&quot;...&quot;)`.<br></p><p>However, all 28 GeneratorTypes in the standard library actually do return<br>nil on repeated calls past the end.<br></p><p><br>*Silent corner case*<br>Because basically all generators keep returning nil, it&#39;s not unlikely<br>people will write their code based on the assumption it will always return<br>nil (breaking the requirement) and that will almost always work – until<br>someone passes in a GeneratorType that actually does raise the recommended<br>preconditionFailure(). It becomes a silent corner case.<br></p><p>*Adds caller burden*<br>To avoid breaking the requirement, the caller will not uncommonly have to<br>track extra state and branch (e.g. keep a done/atEnd boolean). For example<br>the UTF-8 &amp; UTF-16 decoders do this (incidentally introducing an extra<br>branch into a hot code path), while the UTF-32 decoder doesn&#39;t actually<br>check – passing the requirement on to its caller (without this being<br>documented). From personal experience implementing several custom<br>generators I&#39;ve found that respecting the requirement invariably adds<br>complexity to the implementation.<br></p><p>*Doesn&#39;t prevent bugs*<br>There seems to be little advantage to having it crash on past-the-end calls<br>to next(). So far I haven&#39;t seen any examples where not crashing would<br>silently hide a bug – and again even if there was it wouldn&#39;t help much<br>considering almost no generators actually do crash.<br></p><p><br>*Proposal*<br>Change the guarantee for GeneratorType.next() to keep returning nil<br>indefinitely after it has been exhausted.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/e3508d04/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March  3, 2016 at 08:00:00am</p></header><div class="content"><p>+1 from me on the grounds that I had no idea that this was an expectation of GeneratorType.next(), so yeah; all my generators currently return `nil` infinitely past the end. Does anyone know the history of this requirement? Perhaps it’s a newer one and I didn’t notice it being added?<br></p><p>The only advantage to a failure vs continuing nil that I can think of is if the generator is returning an optional type anyway; if the developer doesn’t check correctly for nil from the generator vs a stored value of nil then they could end up with an infinite loop, but this seems unlikely given that they’d be dealing with a type of Element?? rather than Element?, so whatever they’re doing with the results should fail due to type mismatches anyway.<br></p><p>So yeah, there’s possibly (and I stress possibly) a narrow case in which failure might catch a bug, but in most cases the optional behaviour should be enough, and the generator itself should be handling indices correctly internally to prevent issues with stepping past .endIndex etc.<br></p><p>&gt; On 3 Mar 2016, at 06:47, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Situation<br>&gt; Currently GeneratorType.next() requires callers to not call next() after it has returned nil once, even encouraging a preconditionFailure() if this is violated:<br>&gt; <br>&gt;   /// - Requires: `next()` has not been applied to a copy of `self`<br>&gt;   ///   since the copy was made, and no preceding call to `self.next()`<br>&gt;   ///   has returned `nil`.  Specific implementations of this protocol<br>&gt;   ///   are encouraged to respond to violations of this requirement by<br>&gt;   ///   calling `preconditionFailure(&quot;...&quot;)`.<br>&gt; <br>&gt; However, all 28 GeneratorTypes in the standard library actually do return nil on repeated calls past the end.<br>&gt; <br>&gt; <br>&gt; Silent corner case<br>&gt; Because basically all generators keep returning nil, it&#39;s not unlikely people will write their code based on the assumption it will always return nil (breaking the requirement) and that will almost always work – until someone passes in a GeneratorType that actually does raise the recommended preconditionFailure(). It becomes a silent corner case.<br>&gt; <br>&gt; Adds caller burden<br>&gt; To avoid breaking the requirement, the caller will not uncommonly have to track extra state and branch (e.g. keep a done/atEnd boolean). For example the UTF-8 &amp; UTF-16 decoders do this (incidentally introducing an extra branch into a hot code path), while the UTF-32 decoder doesn&#39;t actually check – passing the requirement on to its caller (without this being documented). From personal experience implementing several custom generators I&#39;ve found that respecting the requirement invariably adds complexity to the implementation.<br>&gt; <br>&gt; Doesn&#39;t prevent bugs<br>&gt; There seems to be little advantage to having it crash on past-the-end calls to next(). So far I haven&#39;t seen any examples where not crashing would silently hide a bug – and again even if there was it wouldn&#39;t help much considering almost no generators actually do crash.<br>&gt; <br>&gt; <br>&gt; Proposal<br>&gt; Change the guarantee for GeneratorType.next() to keep returning nil indefinitely after it has been exhausted.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/e642252a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>March  3, 2016 at 01:00:00am</p></header><div class="content"><p>On Wed, Mar 2, 2016 at 10:47 PM, Patrick Pijnappel via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Situation<br>&gt; Currently GeneratorType.next() requires callers to not call next() after it<br>&gt; has returned nil once, even encouraging a preconditionFailure() if this is<br>&gt; violated:<br>&gt;<br>&gt;   /// - Requires: `next()` has not been applied to a copy of `self`<br>&gt;   ///   since the copy was made, and no preceding call to `self.next()`<br>&gt;   ///   has returned `nil`.  Specific implementations of this protocol<br>&gt;   ///   are encouraged to respond to violations of this requirement by<br>&gt;   ///   calling `preconditionFailure(&quot;...&quot;)`.<br></p><p>I&#39;d like to add more context to this discussion.  We added this<br>requirement a while ago.  [1]  The reason for introducing it was not<br>an attempt to flag bugs in client code.  Rather, we were not convinced<br>that all generators can return nil repeatedly without loss of<br>efficiency or extra storage burden.<br></p><p>[1] https://github.com/apple/swift/commit/304b4f33ae74a5abd09da485bbc435dfa2ade522<br>and rdar://problem/17392226<br></p><p>&gt; Adds caller burden<br>&gt; To avoid breaking the requirement, the caller will not uncommonly have to track extra state and branch<br></p><p>I would actually say the opposite -- running a non-trivial algorithm<br>on generators is a very uncommon thing to do.  The 99% use case for<br>generators is implicit usage from the for-in loop.  This is why<br>allowing generators to be as simple as possible and pushing the<br>requirement for extra branches into non-trivial algorithms made sense<br>for us when we introduced this requirement.<br></p><p>&gt; Silent corner case<br>&gt; Because basically all generators keep returning nil, it&#39;s not unlikely people will write their code based on the assumption it will always return nil<br></p><p>This is what concerns me the most about the current rules.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>March  3, 2016 at 10:00:00pm</p></header><div class="content"><p>Hmm I see.<br></p><p>Do we have any example cases where returning nil repeatedly would require<br>extra branches or state?<br></p><p>The generators in the standard library don&#39;t (*) – the usual pattern is<br>either of the following:<br>- 1) Check state if we&#39;re at end, if so return nil 2) get return value 3)<br>advance state. Since the state is not mutated before returning nil,<br>repeating nil is automatic.<br>- 1) Call next() on one or more wrapped generators 2) return some<br>transformation of that. If the wrapped generators repeat nil, repeating nil<br>is also automatic for the wrapper.<br></p><p>If you would have a generator setup that doesn&#39;t automatically repeat nil,<br>omitting a nil-repeat check might be dangerous considering the risk other<br>code hadn&#39;t considered the case.<br></p><p>(*) StrideThroughGenerator &amp; ZipGenerator have a done flag, but need these<br>even without repeating nil. JoinGenerator has an .End state but actually<br>doesn&#39;t have to – even to repeat nil.<br></p><p>On Thu, Mar 3, 2016 at 8:12 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br></p><p>&gt; On Wed, Mar 2, 2016 at 10:47 PM, Patrick Pijnappel via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; Situation<br>&gt; &gt; Currently GeneratorType.next() requires callers to not call next() after<br>&gt; it<br>&gt; &gt; has returned nil once, even encouraging a preconditionFailure() if this<br>&gt; is<br>&gt; &gt; violated:<br>&gt; &gt;<br>&gt; &gt;   /// - Requires: `next()` has not been applied to a copy of `self`<br>&gt; &gt;   ///   since the copy was made, and no preceding call to `self.next()`<br>&gt; &gt;   ///   has returned `nil`.  Specific implementations of this protocol<br>&gt; &gt;   ///   are encouraged to respond to violations of this requirement by<br>&gt; &gt;   ///   calling `preconditionFailure(&quot;...&quot;)`.<br>&gt;<br>&gt; I&#39;d like to add more context to this discussion.  We added this<br>&gt; requirement a while ago.  [1]  The reason for introducing it was not<br>&gt; an attempt to flag bugs in client code.  Rather, we were not convinced<br>&gt; that all generators can return nil repeatedly without loss of<br>&gt; efficiency or extra storage burden.<br>&gt;<br>&gt; [1]<br>&gt; https://github.com/apple/swift/commit/304b4f33ae74a5abd09da485bbc435dfa2ade522<br>&gt; and rdar://problem/17392226<br>&gt;<br>&gt; &gt; Adds caller burden<br>&gt; &gt; To avoid breaking the requirement, the caller will not uncommonly have<br>&gt; to track extra state and branch<br>&gt;<br>&gt; I would actually say the opposite -- running a non-trivial algorithm<br>&gt; on generators is a very uncommon thing to do.  The 99% use case for<br>&gt; generators is implicit usage from the for-in loop.  This is why<br>&gt; allowing generators to be as simple as possible and pushing the<br>&gt; requirement for extra branches into non-trivial algorithms made sense<br>&gt; for us when we introduced this requirement.<br>&gt;<br>&gt; &gt; Silent corner case<br>&gt; &gt; Because basically all generators keep returning nil, it&#39;s not unlikely<br>&gt; people will write their code based on the assumption it will always return<br>&gt; nil<br>&gt;<br>&gt; This is what concerns me the most about the current rules.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160303/373a9230/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>March  5, 2016 at 11:00:00am</p></header><div class="content"><p>On Thu, Mar 3, 2016, at 03:24 AM, Patrick Pijnappel via swift-evolution wrote:<br>&gt; Hmm I see.<br>&gt;<br>&gt; Do we have any example cases where returning nil repeatedly would<br>&gt; require extra branches or state?<br></p><p>Yes. My proposed .takeWhile() and .dropWhile() sequence adaptors<br>(https://github.com/apple/swift-evolution/pull/95) would hit this case.<br>Both of those adaptors would need to keep around extra state and in<br>order to keep returning nil.<br></p><p>My preferred solution for this case is to add a new Generator adaptor<br>called a FuseGenerator, with a convenience method .fuse(). All this<br>adaptor does is include the extra state in order to ensure it keeps<br>returning nil forever. This way Generators don&#39;t have to keep the state<br>for that guarantee, and the majority case where client codes doesn&#39;t<br>rely on this guarantee doesn&#39;t need the check either, and in the rare<br>case where this guarantee is important all the user has to do is call<br>.fuse() on the generator and use the result of that instead.<br></p><p>All that said, I would be strongly in favor of dropping the language<br>about triggering a precondition failure. I&#39;d prefer to leave it as implementation-<br>defined behavior, which an encouragement to keep returning nil if it&#39;s<br>easy to do so. A benefit of this is Generators could opt to explicitly<br>define their post-nil behavior, e.g. TakeWhileGenerator could explicitly<br>document that after it has returned nil, subsequent calls to .next()<br>will continue to consume the underlying generator and return another<br>stream of elements terminating in `nil` (with the caveat that if the<br>underlying generator is exhausted then behavior depends on the<br>underlying generator&#39;s post-nil behavior). Granted, this probably isn&#39;t<br>useful in most cases, but it could be useful upon occasion as a way to<br>lazily split a sequence without building intermediate data structures<br>(assuming that the underlying generator is fused or defines its post-nil<br>behavior as returning nil forever).<br></p><p>FWIW, Rust uses precisely the solution I&#39;ve described here (and in fact<br>I&#39;m responsible for its std::iter::Fuse iterator). It defines<br>Iterator::next() such that calling .next() after it has returned None<br>may or may not return more elements (but Iterators are not supposed to<br>assert in this case, they should always return something). And it has<br>the .fuse() convenience method that returns a std::iter::Fuse iterator<br>that provides the always-returns-None guarantee. And in practice, almost<br>nobody ever has to actually use .fuse(), since almost nobody writes<br>algorithms that cares about the behavior after next() returns None (and<br>in the rare case where they do, they&#39;re typically using some concrete<br>Iterator that has defined behavior, as opposed to working on arbitrary<br>Iterators).<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160305/40181e0a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  5, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Yes. My proposed .takeWhile() and .dropWhile() sequence adaptors (https://github.com/apple/swift-evolution/pull/95) would hit this case. Both of those adaptors would need to keep around extra state and in order to keep returning nil.<br></p><p><br>How much extra state? If it&#39;s merely &quot;an extra Bool&quot; or &quot;wrap the inner generator in an Optional and nil it when you hit the end&quot;, it might be worth it.<br></p><p>(Actually, can we see the implementations you&#39;re thinking of using? Because the ones I can imagine for `dropWhile`, at least, would keep returning `nil` as long as the underlying generator did.)<br></p><p>&gt; All that said, I would be strongly in favor of dropping the language about triggering a precondition failure. I&#39;d prefer to leave it as implementation-defined behavior, which an encouragement to keep returning nil if it&#39;s easy to do so.<br></p><p>I think &quot;try to return `nil` but it&#39;s okay if you can&#39;t&quot; is the worst of all worlds from a reliability standpoint. If most, but not all, generators continue to return `nil`, then people will write code assuming that all generators continue to return `nil`.<br></p><p>One thing that might help is to make sure we have examples of the full range of generator behaviors—multi-pass and single-pass, nil forever and not, etc.—in the standard library and list an example of each in the SequenceType documentation along with an encouragement to test with all of them. But a lot of people will miss that.<br></p><p>(Another reason to lean towards always returning `nil`: it&#39;s testable. In fact, I was thinking it might be nice to have something in XCTest where you could hand it a Sequence, or perhaps a closure that creates one, and an array containing the values you expect it to have, and it would assert the basic properties we expect from a Sequence, like that the elements come out in the right order, it returns nil at the end, `underestimateCount()` is not incorrect, etc. The `nil` semantic, unlike the other possible ones, is something you could include in that test.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>March  5, 2016 at 01:00:00pm</p></header><div class="content"><p>On Sat, Mar 5, 2016, at 12:47 PM, Brent Royal-Gordon wrote:<br>&gt; &gt; Yes. My proposed .takeWhile() and .dropWhile() sequence adaptors (https://github.com/apple/swift-evolution/pull/95) would hit this case. Both of those adaptors would need to keep around extra state and in order to keep returning nil.<br>&gt; <br>&gt; <br>&gt; How much extra state? If it&#39;s merely &quot;an extra Bool&quot; or &quot;wrap the inner generator in an Optional and nil it when you hit the end&quot;, it might be worth it.<br>&gt; <br>&gt; (Actually, can we see the implementations you&#39;re thinking of using? Because the ones I can imagine for `dropWhile`, at least, would keep returning `nil` as long as the underlying generator did.)<br></p><p>Oh you&#39;re right, it&#39;s just takeWhile() that would actually have usable post-nil behavior. dropWhile() would end up with the exact same post-nil behavior as its underlying generator.<br></p><p>&gt; &gt; All that said, I would be strongly in favor of dropping the language about triggering a precondition failure. I&#39;d prefer to leave it as implementation-defined behavior, which an encouragement to keep returning nil if it&#39;s easy to do so.<br>&gt; <br>&gt; I think &quot;try to return `nil` but it&#39;s okay if you can&#39;t&quot; is the worst of all worlds from a reliability standpoint. If most, but not all, generators continue to return `nil`, then people will write code assuming that all generators continue to return `nil`.<br></p><p>Most people don&#39;t write code that relies on the post-nil behavior of generators at all. Heck, most people don&#39;t even deal with generators directly, they deal with sequences, and sequences already have implementation-defined behavior of calling .generate() twice.<br></p><p>In fact, I don&#39;t think the post-nil behavior of generators is even the biggest potential gotcha. A much bigger issue is how generators behave when you make copies of them. If you ever copy a generator you&#39;re supposed to never touch the original again, but it&#39;s easy to violate that accidentally, and most generators actually behave sanely when copied anyway.<br></p><p>&gt; One thing that might help is to make sure we have examples of the full range of generator behaviors—multi-pass and single-pass, nil forever and not, etc.—in the standard library and list an example of each in the SequenceType documentation along with an encouragement to test with all of them. But a lot of people will miss that.<br></p><p>I agree that having more examples is a good thing.<br></p><p>&gt; (Another reason to lean towards always returning `nil`: it&#39;s testable. In fact, I was thinking it might be nice to have something in XCTest where you could hand it a Sequence, or perhaps a closure that creates one, and an array containing the values you expect it to have, and it would assert the basic properties we expect from a Sequence, like that the elements come out in the right order, it returns nil at the end, `underestimateCount()` is not incorrect, etc. The `nil` semantic, unlike the other possible ones, is something you could include in that test.)<br></p><p>Defining the post-nil behavior as implementation-defined means that, by definition, you don&#39;t need to test how arbitrary generators behave there. For specific concrete GeneratorTypes that define their post-nil semantics (and I think we&#39;d want to try and define this for all of the stdlib GeneratorTypes) you can test the documented semantics. For any generator that defines it as returning nil forever (which I&#39;d expect e.g. IndexingGenerator to do) you can easily test that semantic. And for generators like TakeWhileGenerator that effectively reset their behavior when returning nil, you can test that behavior too (e.g. `(1..&lt;10).takeWhile({ $0 % 4 != 0 })` would return the sequences `[1,2,3]`, `[5,6,7]`, `[9]`, and then start returning nil forever).<br></p><p>Besides, you can&#39;t actually test that a given GeneratorType returns nil forever, you can only test that it returns nil for some finite number of calls to next(). It would be entirely possible to have a GeneratorType whose behavior depends on some external signal and will return nil until such time as that external signal has data again. For example, you could have a GeneratorType that reads lines from stdin in a non-blocking fashion, and so it would return nil until the user has typed another line of text. Or you could have a GeneratorType that represents an atomic FIFO queue and returns nil if the queue is empty.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  5, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; In fact, I don&#39;t think the post-nil behavior of generators is even the biggest potential gotcha. A much bigger issue is how generators behave when you make copies of them. If you ever copy a generator you&#39;re supposed to never touch the original again, but it&#39;s easy to violate that accidentally, and most generators actually behave sanely when copied anyway.<br></p><p>That&#39;s true, but it&#39;s just not addressable until we have some kind of borrowing system in place.<br></p><p>&gt;&gt; (Another reason to lean towards always returning `nil`: it&#39;s testable. In fact, I was thinking it might be nice to have something in XCTest where you could hand it a Sequence, or perhaps a closure that creates one, and an array containing the values you expect it to have, and it would assert the basic properties we expect from a Sequence, like that the elements come out in the right order, it returns nil at the end, `underestimateCount()` is not incorrect, etc. The `nil` semantic, unlike the other possible ones, is something you could include in that test.)<br>&gt; <br>&gt; Defining the post-nil behavior as implementation-defined means that, by definition, you don&#39;t need to test how arbitrary generators behave there.<br></p><p>True, but then you&#39;re imposing a constraint on the clients of generators: &quot;Don&#39;t call next() again after it turns nil&quot;. I think it will be far easier to write generic tests of any generator than it will be to write generic tests of any function that *uses* a generic generator.<br></p><p>(Although I suppose you could assist in that testing by writing a wrapper around any sequence/collection/generator which enforces all rules as strictly as possible.)<br></p><p>&gt; Besides, you can&#39;t actually test that a given GeneratorType returns nil forever, you can only test that it returns nil for some finite number of calls to next(). It would be entirely possible to have a GeneratorType whose behavior depends on some external signal and will return nil until such time as that external signal has data again. For example, you could have a GeneratorType that reads lines from stdin in a non-blocking fashion, and so it would return nil until the user has typed another line of text. Or you could have a GeneratorType that represents an atomic FIFO queue and returns nil if the queue is empty.<br></p><p>That&#39;s true, but you can still usefully test the common cases.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>March  5, 2016 at 05:00:00pm</p></header><div class="content"><p>On Sat, Mar 5, 2016 at 5:40 PM, Brent Royal-Gordon via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; In fact, I don&#39;t think the post-nil behavior of generators is even the biggest potential gotcha. A much bigger issue is how generators behave when you make copies of them. If you ever copy a generator you&#39;re supposed to never touch the original again, but it&#39;s easy to violate that accidentally, and most generators actually behave sanely when copied anyway.<br>&gt;<br>&gt; That&#39;s true, but it&#39;s just not addressable until we have some kind of borrowing system in place.<br>&gt;<br>&gt;&gt;&gt; (Another reason to lean towards always returning `nil`: it&#39;s testable. In fact, I was thinking it might be nice to have something in XCTest where you could hand it a Sequence, or perhaps a closure that creates one, and an array containing the values you expect it to have, and it would assert the basic properties we expect from a Sequence, like that the elements come out in the right order, it returns nil at the end, `underestimateCount()` is not incorrect, etc. The `nil` semantic, unlike the other possible ones, is something you could include in that test.)<br>&gt;&gt;<br>&gt;&gt; Defining the post-nil behavior as implementation-defined means that, by definition, you don&#39;t need to test how arbitrary generators behave there.<br>&gt;<br>&gt; True, but then you&#39;re imposing a constraint on the clients of generators: &quot;Don&#39;t call next() again after it turns nil&quot;. I think it will be far easier to write generic tests of any generator than it will be to write generic tests of any function that *uses* a generic generator.<br>&gt;<br>&gt; (Although I suppose you could assist in that testing by writing a wrapper around any sequence/collection/generator which enforces all rules as strictly as possible.)<br></p><p>See stdlib/private/StdlibCollectionUnittest/MinimalCollections.swift.gyb.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>March  5, 2016 at 08:00:00pm</p></header><div class="content"><p>On Sat, Mar 5, 2016, at 05:40 PM, Brent Royal-Gordon wrote:<br>&gt; &gt; In fact, I don&#39;t think the post-nil behavior of generators is even the biggest potential gotcha. A much bigger issue is how generators behave when you make copies of them. If you ever copy a generator you&#39;re supposed to never touch the original again, but it&#39;s easy to violate that accidentally, and most generators actually behave sanely when copied anyway.<br>&gt; <br>&gt; That&#39;s true, but it&#39;s just not addressable until we have some kind of borrowing system in place.<br>&gt; <br>&gt; &gt;&gt; (Another reason to lean towards always returning `nil`: it&#39;s testable. In fact, I was thinking it might be nice to have something in XCTest where you could hand it a Sequence, or perhaps a closure that creates one, and an array containing the values you expect it to have, and it would assert the basic properties we expect from a Sequence, like that the elements come out in the right order, it returns nil at the end, `underestimateCount()` is not incorrect, etc. The `nil` semantic, unlike the other possible ones, is something you could include in that test.)<br>&gt; &gt; <br>&gt; &gt; Defining the post-nil behavior as implementation-defined means that, by definition, you don&#39;t need to test how arbitrary generators behave there.<br>&gt; <br>&gt; True, but then you&#39;re imposing a constraint on the clients of generators: &quot;Don&#39;t call next() again after it turns nil&quot;.<br></p><p>Sure, but as I&#39;ve already stated, I believe very few people ever write code that depends on post-nil behavior anyway. In fact, it wouldn&#39;t surprise me to learn that far more people have to deal with this case while writing their own GeneratorTypes than there are people who hit this merely by using pre-existing GeneratorTypes.<br></p><p>&gt; I think it will be far easier to write generic tests of any generator than it will be to write generic tests of any function that *uses* a generic generator.<br>&gt; <br>&gt; (Although I suppose you could assist in that testing by writing a wrapper around any sequence/collection/generator which enforces all rules as strictly as possible.)<br></p><p>You could always just test the behavior of the FuseGenerator wrapping it, if you really want to be able to rely on always-returning-nil behavior. But I&#39;m not sure what tests you&#39;d write that even hits this case, except for a test that&#39;s designed specifically to test the post-nil behavior (which we&#39;ve already established isn&#39;t necessary to check for arbitrary generators if GeneratorType leaves that as implementation-defined).<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  5, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt;&gt; I think it will be far easier to write generic tests of any generator than it will be to write generic tests of any function that *uses* a generic generator.<br>&gt;&gt; <br>&gt;&gt; (Although I suppose you could assist in that testing by writing a wrapper around any sequence/collection/generator which enforces all rules as strictly as possible.)<br>&gt; <br>&gt; You could always just test the behavior of the FuseGenerator wrapping it, if you really want to be able to rely on always-returning-nil behavior. But I&#39;m not sure what tests you&#39;d write that even hits this case, except for a test that&#39;s designed specifically to test the post-nil behavior (which we&#39;ve already established isn&#39;t necessary to check for arbitrary generators if GeneratorType leaves that as implementation-defined).<br></p><p>The fuse generator wouldn&#39;t do what I&#39;m talking about. What I mean is that it might be useful for testing purposes to be able to wrap a collection/sequence in a StrictCollection/StrictSequence (with corresponding StrictGenerators, StrictIndexes,etc.) which would do things like:<br></p><p>* Detect if you copy a generator and then use both copies<br>* Detect if you call next() on a generator after it returns nil<br>* StrictCollection only: Invalidate all indices retrieved before any mutation<br>* StrictSequence only: Prevent you from making a generator more than once<br></p><p>The idea is that, when you&#39;re writing a piece of code that&#39;s generic on any collection or sequence type, your unit tests could pass in a StrictCollection/StrictSequence-wrapped version of whatever your actual data is, and if your code doesn&#39;t crash you can be pretty sure it&#39;s not violating any of those protocols&#39; unevenly enforced requirements.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>March  7, 2016 at 12:00:00am</p></header><div class="content"><p>My intuition says the extra state &amp; branch needed for generators like<br>TakeWhile could very well be optimized away in most cases if you dont<br>make use of its post-nil behavior. Say TakeWhile is implemented as such:<br></p><p>if done { return nil }<br>guard let element = base.next() where predicate(element) else {<br>  done = true<br>  return nil<br>}<br>return element<br></p><p>If the generator is then used in the common case:<br></p><p>let generator = TakeWhileGenerator(...)<br>while let element = generator.next() {<br>  foo(element)<br>}<br></p><p>Should give us effectively:<br></p><p>var base = ...<br>let predicate = ...<br>var done = false<br>while true {<br>  if done { break }<br>  guard let element = base.next() where predicate(element) else {<br>    done = true<br>    break<br>  }<br>  foo(element)<br>}<br></p><p>The optimizer should see (or at least could see) `done` is never read after<br>it&#39;s written to (thus removing the assignment), and therefore<br>when checking the condition it can only be false (thus it can also be<br>removed).<br></p><p>I don&#39;t have a machine to test this on atm though.<br></p><p><br>On Sunday, 6 March 2016, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt;&gt; I think it will be far easier to write generic tests of any generator<br>&gt; than it will be to write generic tests of any function that *uses* a<br>&gt; generic generator.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; (Although I suppose you could assist in that testing by writing a<br>&gt; wrapper around any sequence/collection/generator which enforces all rules<br>&gt; as strictly as possible.)<br>&gt; &gt;<br>&gt; &gt; You could always just test the behavior of the FuseGenerator wrapping<br>&gt; it, if you really want to be able to rely on always-returning-nil behavior.<br>&gt; But I&#39;m not sure what tests you&#39;d write that even hits this case, except<br>&gt; for a test that&#39;s designed specifically to test the post-nil behavior<br>&gt; (which we&#39;ve already established isn&#39;t necessary to check for arbitrary<br>&gt; generators if GeneratorType leaves that as implementation-defined).<br>&gt;<br>&gt; The fuse generator wouldn&#39;t do what I&#39;m talking about. What I mean is that<br>&gt; it might be useful for testing purposes to be able to wrap a<br>&gt; collection/sequence in a StrictCollection/StrictSequence (with<br>&gt; corresponding StrictGenerators, StrictIndexes,etc.) which would do things<br>&gt; like:<br>&gt;<br>&gt; * Detect if you copy a generator and then use both copies<br>&gt; * Detect if you call next() on a generator after it returns nil<br>&gt; * StrictCollection only: Invalidate all indices retrieved before any<br>&gt; mutation<br>&gt; * StrictSequence only: Prevent you from making a generator more than once<br>&gt;<br>&gt; The idea is that, when you&#39;re writing a piece of code that&#39;s generic on<br>&gt; any collection or sequence type, your unit tests could pass in a<br>&gt; StrictCollection/StrictSequence-wrapped version of whatever your actual<br>&gt; data is, and if your code doesn&#39;t crash you can be pretty sure it&#39;s not<br>&gt; violating any of those protocols&#39; unevenly enforced requirements.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160307/1a327cf2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>March  6, 2016 at 06:00:00pm</p></header><div class="content"><p>On Sun, Mar 6, 2016, at 05:46 AM, Patrick Pijnappel wrote:<br>&gt; My intuition says the extra state &amp; branch needed for generators like TakeWhile could very well be optimized away in most cases if you dont make use of its post-nil behavior. Say TakeWhile is implemented as such:<br>&gt;<br>&gt; if done { return nil } guard let element = base.next() where<br>&gt; predicate(element) else {  done = true  return nil } return element<br>&gt;<br>&gt; If the generator is then used in the common case:<br>&gt;<br>&gt; let generator = TakeWhileGenerator(...) while let element =<br>&gt; generator.next() {  foo(element) }<br>&gt;<br>&gt; Should give us effectively:<br>&gt;<br>&gt; var base = ... let predicate = ... var done = false while true {  if<br>&gt; done { break }  guard let element = base.next() where<br>&gt; predicate(element) else {    done = true    break  }  foo(element) }<br>&gt;<br>&gt; The optimizer should see (or at least could see) `done` is never read<br>&gt; after it&#39;s written to (thus removing the assignment), and therefore<br>&gt; when checking the condition it can only be false (thus it can also be<br>&gt; removed).<br></p><p>This may be doable for stdlib generators, but Swift currently has a<br>limitation where generic types/functions defined outside the current<br>file (or module with -whole-module-optimization) are only specialized<br>for their parameters if they come from the stdlib. Any such<br>types/functions defined in third-party libraries (or in other files if<br>you&#39;re not using -whole-module-optimization) use virtual dispatch on the<br>generic parameters instead. This means that any generic GeneratorTypes<br>defined in third-party libraries won&#39;t be able to optimize away this<br>check as it won&#39;t be able to tell that it isn&#39;t needed.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160306/3305d6ff/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>March  8, 2016 at 11:00:00am</p></header><div class="content"><p>On Sun, Mar 6, 2016 at 6:16 PM, Kevin Ballard via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; On Sun, Mar 6, 2016, at 05:46 AM, Patrick Pijnappel wrote:<br>&gt;<br>&gt; My intuition says the extra state &amp; branch needed for generators like<br>&gt; TakeWhile could very well be optimized away in most cases if you dont make<br>&gt; use of its post-nil behavior. Say TakeWhile is implemented as such:<br>&gt;<br>&gt; if done { return nil }<br>&gt; guard let element = base.next() where predicate(element) else {<br>&gt;   done = true<br>&gt;   return nil<br>&gt; }<br>&gt; return element<br>&gt;<br>&gt; If the generator is then used in the common case:<br>&gt;<br>&gt; let generator = TakeWhileGenerator(...)<br>&gt; while let element = generator.next() {<br>&gt;   foo(element)<br>&gt; }<br>&gt;<br>&gt; Should give us effectively:<br>&gt;<br>&gt; var base = ...<br>&gt; let predicate = ...<br>&gt; var done = false<br>&gt; while true {<br>&gt;   if done { break }<br>&gt;   guard let element = base.next() where predicate(element) else {<br>&gt;     done = true<br>&gt;     break<br>&gt;   }<br>&gt;   foo(element)<br>&gt; }<br>&gt;<br>&gt; The optimizer should see (or at least could see) `done` is never read after<br>&gt; it&#39;s written to (thus removing the assignment), and therefore when checking<br>&gt; the condition it can only be false (thus it can also be removed).<br>&gt;<br>&gt;<br>&gt; This may be doable for stdlib generators, but Swift currently has a<br>&gt; limitation where generic types/functions defined outside the current file<br>&gt; (or module with -whole-module-optimization) are only specialized for their<br>&gt; parameters if they come from the stdlib. Any such types/functions defined in<br>&gt; third-party libraries (or in other files if you&#39;re not using<br>&gt; -whole-module-optimization) use virtual dispatch on the generic parameters<br>&gt; instead. This means that any generic GeneratorTypes defined in third-party<br>&gt; libraries won&#39;t be able to optimize away this check as it won&#39;t be able to<br>&gt; tell that it isn&#39;t needed.<br></p><p>This is a current limitation of the compiler.  The resilience effort<br>should make the specialization available for user-defined modules.<br>Thus, I don&#39;t think it makes sense to factor in the current limitation<br>into a long-term decision.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March  8, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Mar 8, 2016, at 11:38, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Sun, Mar 6, 2016 at 6:16 PM, Kevin Ballard via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Sun, Mar 6, 2016, at 05:46 AM, Patrick Pijnappel wrote:<br>&gt;&gt; <br>&gt;&gt; My intuition says the extra state &amp; branch needed for generators like<br>&gt;&gt; TakeWhile could very well be optimized away in most cases if you dont make<br>&gt;&gt; use of its post-nil behavior. Say TakeWhile is implemented as such:<br>&gt;&gt; <br>&gt;&gt; if done { return nil }<br>&gt;&gt; guard let element = base.next() where predicate(element) else {<br>&gt;&gt;  done = true<br>&gt;&gt;  return nil<br>&gt;&gt; }<br>&gt;&gt; return element<br>&gt;&gt; <br>&gt;&gt; If the generator is then used in the common case:<br>&gt;&gt; <br>&gt;&gt; let generator = TakeWhileGenerator(...)<br>&gt;&gt; while let element = generator.next() {<br>&gt;&gt;  foo(element)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Should give us effectively:<br>&gt;&gt; <br>&gt;&gt; var base = ...<br>&gt;&gt; let predicate = ...<br>&gt;&gt; var done = false<br>&gt;&gt; while true {<br>&gt;&gt;  if done { break }<br>&gt;&gt;  guard let element = base.next() where predicate(element) else {<br>&gt;&gt;    done = true<br>&gt;&gt;    break<br>&gt;&gt;  }<br>&gt;&gt;  foo(element)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The optimizer should see (or at least could see) `done` is never read after<br>&gt;&gt; it&#39;s written to (thus removing the assignment), and therefore when checking<br>&gt;&gt; the condition it can only be false (thus it can also be removed).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This may be doable for stdlib generators, but Swift currently has a<br>&gt;&gt; limitation where generic types/functions defined outside the current file<br>&gt;&gt; (or module with -whole-module-optimization) are only specialized for their<br>&gt;&gt; parameters if they come from the stdlib. Any such types/functions defined in<br>&gt;&gt; third-party libraries (or in other files if you&#39;re not using<br>&gt;&gt; -whole-module-optimization) use virtual dispatch on the generic parameters<br>&gt;&gt; instead. This means that any generic GeneratorTypes defined in third-party<br>&gt;&gt; libraries won&#39;t be able to optimize away this check as it won&#39;t be able to<br>&gt;&gt; tell that it isn&#39;t needed.<br>&gt; <br>&gt; This is a current limitation of the compiler.  The resilience effort<br>&gt; should make the specialization available for user-defined modules.<br>&gt; Thus, I don&#39;t think it makes sense to factor in the current limitation<br>&gt; into a long-term decision.<br></p><p>That&#39;s not really true; in fact I&#39;d say it&#39;s the opposite. Any library that&#39;s not shipped with the app has the freedom to change its generator implementation in the future, and therefore you&#39;ll get even fewer guarantees about the generator than you have today.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/74345db8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>March  8, 2016 at 04:00:00pm</p></header><div class="content"><p>On Tue, Mar 8, 2016 at 2:52 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;<br>&gt; On Mar 8, 2016, at 11:38, Dmitri Gribenko via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; This is a current limitation of the compiler.  The resilience effort<br>&gt; should make the specialization available for user-defined modules.<br>&gt; Thus, I don&#39;t think it makes sense to factor in the current limitation<br>&gt; into a long-term decision.<br>&gt;<br>&gt;<br>&gt; That&#39;s not really true; in fact I&#39;d say it&#39;s the opposite. Any library<br>&gt; that&#39;s not shipped with the app has the freedom to change its generator<br>&gt; implementation in the future, and therefore you&#39;ll get even fewer guarantees<br>&gt; about the generator than you have today.<br></p><p>What I meant is that we would allow user-defined modules to opt into<br>specialization.  Currently it is not possible for user-defined modules<br>at all.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Change guarantee for GeneratorType.next() to always return nil past end</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>March  6, 2016 at 06:00:00pm</p></header><div class="content"><p>On Sat, Mar 5, 2016, at 10:35 PM, Brent Royal-Gordon wrote:<br>&gt; &gt;&gt; I think it will be far easier to write generic tests of any generator than it will be to write generic tests of any function that *uses* a generic generator.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; (Although I suppose you could assist in that testing by writing a wrapper around any sequence/collection/generator which enforces all rules as strictly as possible.)<br>&gt; &gt; <br>&gt; &gt; You could always just test the behavior of the FuseGenerator wrapping it, if you really want to be able to rely on always-returning-nil behavior. But I&#39;m not sure what tests you&#39;d write that even hits this case, except for a test that&#39;s designed specifically to test the post-nil behavior (which we&#39;ve already established isn&#39;t necessary to check for arbitrary generators if GeneratorType leaves that as implementation-defined).<br>&gt; <br>&gt; The fuse generator wouldn&#39;t do what I&#39;m talking about. What I mean is that it might be useful for testing purposes to be able to wrap a collection/sequence in a StrictCollection/StrictSequence (with corresponding StrictGenerators, StrictIndexes,etc.) which would do things like:<br>&gt; <br>&gt; * Detect if you copy a generator and then use both copies<br>&gt; * Detect if you call next() on a generator after it returns nil<br>&gt; * StrictCollection only: Invalidate all indices retrieved before any mutation<br>&gt; * StrictSequence only: Prevent you from making a generator more than once<br>&gt;<br>&gt; The idea is that, when you&#39;re writing a piece of code that&#39;s generic on any collection or sequence type, your unit tests could pass in a StrictCollection/StrictSequence-wrapped version of whatever your actual data is, and if your code doesn&#39;t crash you can be pretty sure it&#39;s not violating any of those protocols&#39; unevenly enforced requirements.<br></p><p>If you&#39;re working with a generic collection/sequence, then it&#39;s still perfectly reasonable to detect if you call next() on a generator after it returns nil regardless of how the post-nil behavior is defined. After all, if you&#39;re working with a generic sequence/generator, and the post-nil behavior is implementation-defined, then your generic code probably doesn&#39;t want to invoke post-nil behavior because it doesn&#39;t know what will happen. Defining post-nil behavior as always returning nil simply lets you skip this check in your StrictGenerator, but having post-nil behavior being implementation-defined certainly doesn&#39;t make testing this any harder.<br></p><p>And if you want to use this same StrictSequence/StrictGenerator when you&#39;re using a sequence/generator that you explicitly know defines post-nil behavior as something useful (or if you&#39;re writing a sequence/generator adaptor where your adaptor&#39;s post-nil behavior naturally matches the underlying generator&#39;s, and you want to test your code with clients that may be relying on specific post-nil behavior) then you can parameterize your StrictSequence/StrictGenerator with a flag that tells it whether to check the post-nil behavior. In fact, you may want to do that anyway to enable disabling of any of the checks, because it&#39;s certainly possible for a concrete SequenceType/GeneratorType implementation to relax any of these requirements you&#39;re checking. For example, a specific GeneratorType implementation could explicitly document that copying the generator is safe and both copies then yield the same sequence of elements.<br></p><p>-Kevin Ballard<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
