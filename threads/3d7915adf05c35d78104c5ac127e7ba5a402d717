<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 25, 2016 at 06:00:00pm</p></header><div class="content"><p>on Sun Jul 24 2016, Chris Lattner &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;SE-0132: Rationalizing Sequence end-operation names&quot;<br>&gt; begins now and runs through July 26.  Apologies for the short review<br>&gt; cycle, but we’re right up against the end of source breaking changes<br>&gt; for Swift 3.  The proposal is available here:<br>&gt;<br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0132-sequence-end-ops.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All<br>&gt; reviews should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of<br>&gt; Swift. When writing your review, here are some questions you might<br>&gt; want to answer in your review:<br>&gt;<br>&gt; 	* What is your evaluation of the proposal?<br></p><p>I&#39;m mostly very much in favor of this proposal, but I have some<br>thoughts.<br></p><p>First, though, I have to apologize for those wide tables, since I&#39;m<br>listed as a co-author (because of a small design contribution).  The<br>only way I&#39;ve been able to read them is by looking at the markdown<br>source, so that&#39;s how I&#39;m going to quote it here.<br></p><p>[Note to future authors: if you need to include a table, this is how you<br>can make it narrow enough:<br>https://github.com/apple/swift-evolution/blob/master/proposals/0118-closure-parameter-names-and-labels.md#proposed-solution.<br>The source is awful to read but it renders OK.]<br></p><p><br>&gt; ## Proposed solution<br>&gt; <br>&gt; We sever the index-taking APIs from the others, forming two separate <br>&gt; families, which we will call the &quot;Sequence-end operations&quot; and the <br>&gt; &quot;index-based operations&quot;. We then consider and redesign them along <br>&gt; separate lines.<br>&gt; <br>&gt; ### Sequence-end operations<br>&gt; <br>&gt; Each of these APIs should be renamed to use a directional word based on <br>&gt; its row in the table:<br>&gt; <br>&gt; | Operand                          | Directional word   |<br>&gt; | -------------------------------- | ------------------ |<br>&gt; | **Fixed Size**                   |<br>&gt; | First 1                          | first              |<br>&gt; | Last 1                           | last               |<br>&gt; | First (n: Int)                   | prefix             |<br>&gt; |             ...with closure      | prefix             |<br>&gt; | Last (n: Int)                    | suffix             |<br>&gt; |             ...with closure      | suffix             |<br>&gt; | **Searching From End**           |<br>&gt; | First      matching      element | first              |<br>&gt; |             ...with closure      | first              |<br>&gt; | Last matching element            | last               |<br>&gt; |             ...with closure      | last               |<br>&gt; <br>&gt; To accomplish this, `starts(with:)` should be renamed to<br>&gt; `hasPrefix(_:)`, and other APIs should have directional words replaced<br>&gt; or added as appropriate.<br>&gt; <br>&gt; Additionally, the word `drop` in the &quot;Exclude&quot; APIs should be replaced<br>&gt; with `removing`. These operations omit the same elements which the<br>&gt; `remove` operations delete, so even though the types are not always<br>&gt; the same (`removing` returns `SubSequence`, not `Self`), we think they<br>&gt; are similar enough to deserve to be treated as nonmutating forms.<br></p><p>Unfortunately there&#39;s a semantic difference that I hadn&#39;t noticed<br>before: the mutating “remove” operations have a precondition that there<br>be at least as many elements as are being removed.  “Drop,” like “pop,”<br>is forgiving of such overruns.  I think this is solvable; my suggestion<br>is below<br></p><p>&gt; These changes yield (altered names **bold**):<br>&gt; <br>&gt; |                                  | Get                           | Index                                 | Exclude                                   | Remove (1)            | Pop (1)      | Equate (2)                                 |<br>&gt; | -------------------------------- | ----------------------------- | ------------------------------------- | ----------------------------------------- | --------------------- | ------------ | ------------------------------------------ |<br>&gt; | **Fixed Size**                   |<br>&gt; | First 1                          | C.first                       | -                                     | **S.removingFirst()**                     | C.removeFirst()       | C.popFirst() | -                                          |<br>&gt; | Last 1                           | C.last                        | -                                     | **S.removingLast()**                      | C.removeLast()        | C.popLast()  | -                                          |<br>&gt; | First (n: Int)                   | S.prefix(3)                   | -                                     | **S.removingPrefix(3)**                   | **C.removePrefix(3)** | -            | **S.hasPrefix([x,y,z])**                   |<br>&gt; |             ...with closure      | S.prefix(while:      isPrime) | -                                     | **S.removingPrefix(while:      isPrime)** | -                     | -            | **S.hasPrefix([x,y,z],      by:      ==)** |<br>&gt; | Last (n: Int)                    | S.suffix(3)                   | -                                     | **S.removingSuffix(3)**                   | **C.removeSuffix(3)** | -            | -                                          |<br>&gt; |             ...with closure      | -                             | -                                     | -                                         | -                     | -            | -                                          |<br>&gt; | **Searching From End**           |<br>&gt; | First      matching      element | -                             | **C.firstIndex(of:      x)**          | -                                         | -                     | -            | -                                          |<br>&gt; |             ...with closure      | S.first(where:      isPrime)  | **C.firstIndex(where:      isPrime)** | -                                         | -                     | -            | -                                          |<br>&gt; | Last matching element            | -                             | -                                     | -                                         | -                     | -            | -                                          |<br>&gt; |             ...with closure      | -                             | -                                     | -                                         | -                     | -            | -                                          |<br></p><p>My suggestion would be to make the remove()<br>operations more forgiving:<br></p><p>   rename popFirst() to removeFirst()<br>   rename popLast() to removeLast()<br></p><p>   kill removeFirst(n)<br>   kill removeLast(n)<br></p><p>The “forgiving” forms of x.removeFirst(n) and x.removeLast(n) can be<br>expressed as:<br></p><p>   let i = x.index(x.startIndex, offsetBy: n, limitedBy: x.endIndex)<br>   x.removeSubrange(..&lt;i)<br></p><p>   let i = x.index(x.endIndexIndex, offsetBy: -n, limitedBy: x.startIndex)<br>   x.removeSubrange(i..&lt;)<br></p><p>I realize that&#39;s quite verbose.  We could of course just make<br>removePrefix(n) and removeSuffix(n) forgiving, but I have long believed<br>that the “prefix/suffix” methods should go one of two ways:<br></p><p>a. they get a label that clarifies the meaning of the argument, e.g.<br></p><p>   x.removePrefix(ofMaxLength: n)<br>   x.removeSuffix(ofMaxLength: n)<br></p><p>b. they are given a recognizable domain-specific notation such as:<br></p><p>   x.removeSubrange($+n..&lt;)<br>   x.removeSubrange(..&lt;$-n)<br></p><p>   I am strongly in favor of this answer (which is implementable within<br>   the framework of this proposal) because of the way it reduces API<br>   surface area and leverages the user&#39;s understanding of how ranges<br>   work.<br></p><p>   It also implies we can replace<br></p><p>     x.removingPrefix(n)<br>     x.removingSuffix(n)<br></p><p>   with<br></p><p>     x[$+n..&lt;]<br>     x[..&lt;$-n]<br></p><p>  for Collections.  <br></p><p>  That would admittedly leave single-pass Sequences without an API for<br>  dropping the first N elements. I am inclined to think that interface<br>  should be moved to Iterator.<br></p><p>  The introduction of such notation raises the question of whether we<br>  need unary range operators, and could instead go with<br></p><p>     x[i..&lt;$] and x[$..&lt;i]<br></p><p>  which is after all only one character longer than<br></p><p>     x[i..&lt;] and x[..&lt;i]<br></p><p>  and stays out of the territory of the prefix/suffix “pack/unpack”<br>  operators that are likely to be used for generic variadics.<br></p><p>&gt; ### Index-based operations<br>&gt; <br>&gt; Because these APIs look up elements based on their indices, we believe <br>&gt; these operations should be exposed as subscripts, and ideally should <br>&gt; look like other slicing operations:<br>&gt; <br>&gt; ```swift<br>&gt; let head = people[..&lt;i]<br>&gt; let tail = people[i..&lt;]<br>&gt; let rearrangedPeople = tail + head<br>&gt; ```<br>&gt; <br>&gt; &lt;!-- Comment to make my editor happy --&gt;<br>&gt; <br>&gt; We will accomplish this by introducing two new types, `IncompleteRange` <br>&gt; and `IncompleteClosedRange`. These are similar to `Range` and <br>&gt; `ClosedRange`, except that the bounds are optional.<br>&gt; <br>&gt; To construct them, we will introduce both prefix and suffix operators <br>&gt; taking a non-optional bound, and infix operators taking optional bounds. <br>&gt; (We offer both because `c[..&lt;i]` is more convenient than `c[nil ..&lt; i]`, <br>&gt; but doesn&#39;t allow you to dynamically choose between supplying and <br>&gt; omitting a bound.) These will follow the existing convention: `..&lt;` will <br>&gt; construct the half-open `IncompleteRange`, while `...` will construct <br>&gt; `IncompleteClosedRange`.<br></p><p>I believe the `$+n..&lt;i` idea is still implementable with these basic<br>types, just with an enum instead of optionals.  I&#39;ll take a shot at it<br>tonight if I can get a few minutes.<br></p><p>&gt; Rather than continuing to proliferate overloads of slicing subscripts, <br>&gt; we will also introduce a new `RangeExpression` protocol which allows <br>&gt; any range-like type to convert itself into a plain `Range&lt;Index&gt;` <br>&gt; appropriate to the collection in question. Thus, there should only be <br>&gt; two range subscripts: one taking `Range&lt;Index&gt;`, and one taking <br>&gt; everything else.<br>&gt; <br>&gt; We will also modify the existing `removeSubrange(_:)` and <br>&gt; `replaceSubrange(_:with:)` calls to take `RangeExpression` instances, <br>&gt; thereby merging many existing variants into one while simultaneously <br>&gt; extending them to support `IncompleteRange` and `IncompleteClosedRange`.<br>&gt; Though technically additive, we believe this is an easy win.<br>&gt; <br>&gt; Thus, the table above becomes:<br>&gt; <br>&gt; |                                                  | Type                              | Get                  | Remove                              | Replace                                                     |<br>&gt; | ------------------------------------------------ | --------------------------------- | -------------------- | ----------------------------------- | ----------------------------------------------------------- |<br>&gt; | **Based      on      Index,      Arbitrary**     |<br>&gt; | (i: Index) ..&lt; (j: Index)                        | Range\&lt;Index&gt;                     | C[i      ..&lt;      j] | C.removeSubrange(i      ..&lt;      j) | C.replaceSubrange(i      ..&lt;      j,      with:      [x,y]) |<br>&gt; |             ...Countable                         | CountableRange\&lt;Index&gt;            | C[i ..&lt; j]           | C.removeSubrange(i      ..&lt;      j) | C.replaceSubrange(i      ..&lt;      j,      with:      [x,y]) |<br>&gt; | (i: Index) ... (j: Index)                        | ClosedRange\&lt;Index&gt;               | C[i ... j]           | C.removeSubrange(i ... j)           | C.replaceSubrange(i ... j, with: [x,y])                     |<br>&gt; |             ...Countable                         | CountableClosedRange\&lt;Index&gt;      | C[i ... j]           | C.removeSubrange(i ... j)           | C.replaceSubrange(i ... j, with: [x,y])                     |<br>&gt; | **Based      on      Index,      From      End** |<br>&gt; | startIndex ..&lt; (i: Index)                        | **IncompleteRange\&lt;Index&gt;**       | **C[..\&lt;i]**         | **C.removeSubrange(..\&lt;i)**         | **C.replaceSubrange(..\&lt;i,      with:      [x,y])**         |<br>&gt; | (i: Index) ..&lt; endIndex                          | **IncompleteRange\&lt;Index&gt;**       | **C[i..\&lt;]**         | **C.removeSubrange(i..\&lt;)**         | **C.replaceSubrange(i..\&lt;, with: [x,y])**                   |<br>&gt; | startIndex ... (i: Index)                        | **IncompleteClosedRange\&lt;Index&gt;** | **C[...i]**          | **C.removeSubrange(...i)**          | **C.replaceSubrange(...i, with: [x,y])**                    |<br>&gt; <br>&gt; However, it should be implemented with merely:<br>&gt; <br>&gt; |                                               | Type                                                | Get                  | Remove                              | Replace                                                     |<br>&gt; | --------------------------------------------- | --------------------------------------------------- | -------------------- | ----------------------------------- | ----------------------------------------------------------- |<br>&gt; | (i:      Index)      ..&lt;      (j:      Index) | Range\&lt;Index&gt;                                       | C[i      ..&lt;      j] | C.removeSubrange(i      ..&lt;      j) | C.replaceSubrange(i      ..&lt;      j,      with:      [x,y]) |<br>&gt; | Everything else                               | RangeExpression where      Bound      ==      Index | C[i      ...      j] | C.removeSubrange(i      ...      j) | C.replaceSubrange(i      ...      j,      with:      [x,y]) |<br>&gt;<br>&gt; ## Detailed design<br>&gt; <br>&gt; ### Sequence-end operations<br>&gt; <br>&gt; The following methods should be renamed as follows wherever they appear <br>&gt; in the standard library. These are simple textual substitutions; we <br>&gt; propose no changes whatsoever to types, parameter interpretations, or <br>&gt; other semantics.<br>&gt; <br>&gt; | Old method                                        | New method                                              |<br>&gt; | ------------------------------------------------- | ------------------------------------------------------- |<br>&gt; | `dropFirst() -&gt; SubSequence`                      | `removingFirst() -&gt; SubSequence`                        |<br>&gt; | `dropLast() -&gt; SubSequence`                       | `removingLast() -&gt; SubSequence`                         |<br>&gt; | `dropFirst(_ n: Int) -&gt; SubSequence`              | `removingPrefix(_ n: Int) -&gt; SubSequence`               |<br>&gt; | `drop(@noescape while predicate: (Iterator.Element) throws -&gt; Bool) rethrows -&gt; SubSequence` | `removingPrefix(@noescape while predicate: (Iterator.Element) throws -&gt; Bool) rethrows -&gt; SubSequence` |<br></p><p>I&#39;m concerned with how the above fits into the scheme.  Writing it out<br>is:<br></p><p>    x[(x.firstIndex(where: {!predicate($0)}) ?? x.endIndex)..&lt;$]<br></p><p>and that&#39;s just for Collections.  Drat; we might not be able to get rid<br>of these “removingPrefix” operations altogether.  OK, I&#39;m out of time so<br>I&#39;ll have to get back to this.  <br></p><p><br>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 25, 2016 at 11:00:00pm</p></header><div class="content"><p>On Mon, Jul 25, 2016 at 8:35 PM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Sun Jul 24 2016, Chris Lattner &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; Hello Swift community,<br>&gt; &gt;<br>&gt; &gt; The review of &quot;SE-0132: Rationalizing Sequence end-operation names&quot;<br>&gt; &gt; begins now and runs through July 26.  Apologies for the short review<br>&gt; &gt; cycle, but we’re right up against the end of source breaking changes<br>&gt; &gt; for Swift 3.  The proposal is available here:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0132-sequence-end-ops.md<br>&gt; &gt;<br>&gt; &gt; Reviews are an important part of the Swift evolution process. All<br>&gt; &gt; reviews should be sent to the swift-evolution mailing list at<br>&gt; &gt;<br>&gt; &gt;       https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt; &gt;<br>&gt; &gt; What goes into a review?<br>&gt; &gt;<br>&gt; &gt; The goal of the review process is to improve the proposal under review<br>&gt; &gt; through constructive criticism and contribute to the direction of<br>&gt; &gt; Swift. When writing your review, here are some questions you might<br>&gt; &gt; want to answer in your review:<br>&gt; &gt;<br>&gt; &gt;       * What is your evaluation of the proposal?<br>&gt;<br>&gt; I&#39;m mostly very much in favor of this proposal, but I have some<br>&gt; thoughts.<br>&gt;<br>&gt; First, though, I have to apologize for those wide tables, since I&#39;m<br>&gt; listed as a co-author (because of a small design contribution).  The<br>&gt; only way I&#39;ve been able to read them is by looking at the markdown<br>&gt; source, so that&#39;s how I&#39;m going to quote it here.<br>&gt;<br>&gt; [Note to future authors: if you need to include a table, this is how you<br>&gt; can make it narrow enough:<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0118-closure-parameter-names-and-labels.md#proposed-solution<br>&gt; .<br>&gt; The source is awful to read but it renders OK.]<br>&gt;<br>&gt;<br>&gt; &gt; ## Proposed solution<br>&gt; &gt;<br>&gt; &gt; We sever the index-taking APIs from the others, forming two separate<br>&gt; &gt; families, which we will call the &quot;Sequence-end operations&quot; and the<br>&gt; &gt; &quot;index-based operations&quot;. We then consider and redesign them along<br>&gt; &gt; separate lines.<br>&gt; &gt;<br>&gt; &gt; ### Sequence-end operations<br>&gt; &gt;<br>&gt; &gt; Each of these APIs should be renamed to use a directional word based on<br>&gt; &gt; its row in the table:<br>&gt; &gt;<br>&gt; &gt; | Operand                          | Directional word   |<br>&gt; &gt; | -------------------------------- | ------------------ |<br>&gt; &gt; | **Fixed Size**                   |<br>&gt; &gt; | First 1                          | first              |<br>&gt; &gt; | Last 1                           | last               |<br>&gt; &gt; | First (n: Int)                   | prefix             |<br>&gt; &gt; |             ...with closure      | prefix             |<br>&gt; &gt; | Last (n: Int)                    | suffix             |<br>&gt; &gt; |             ...with closure      | suffix             |<br>&gt; &gt; | **Searching From End**           |<br>&gt; &gt; | First      matching      element | first              |<br>&gt; &gt; |             ...with closure      | first              |<br>&gt; &gt; | Last matching element            | last               |<br>&gt; &gt; |             ...with closure      | last               |<br>&gt; &gt;<br>&gt; &gt; To accomplish this, `starts(with:)` should be renamed to<br>&gt; &gt; `hasPrefix(_:)`, and other APIs should have directional words replaced<br>&gt; &gt; or added as appropriate.<br>&gt; &gt;<br>&gt; &gt; Additionally, the word `drop` in the &quot;Exclude&quot; APIs should be replaced<br>&gt; &gt; with `removing`. These operations omit the same elements which the<br>&gt; &gt; `remove` operations delete, so even though the types are not always<br>&gt; &gt; the same (`removing` returns `SubSequence`, not `Self`), we think they<br>&gt; &gt; are similar enough to deserve to be treated as nonmutating forms.<br>&gt;<br>&gt; Unfortunately there&#39;s a semantic difference that I hadn&#39;t noticed<br>&gt; before: the mutating “remove” operations have a precondition that there<br>&gt; be at least as many elements as are being removed.  “Drop,” like “pop,”<br>&gt; is forgiving of such overruns.  I think this is solvable; my suggestion<br>&gt; is below<br>&gt;<br>&gt; &gt; These changes yield (altered names **bold**):<br>&gt; &gt;<br>&gt; &gt; |                                  | Get                           |<br>&gt; Index                                 | Exclude<br>&gt;        | Remove (1)            | Pop (1)      | Equate (2)<br>&gt;                |<br>&gt; &gt; | -------------------------------- | ----------------------------- |<br>&gt; ------------------------------------- |<br>&gt; ----------------------------------------- | --------------------- |<br>&gt; ------------ | ------------------------------------------ |<br>&gt; &gt; | **Fixed Size**                   |<br>&gt; &gt; | First 1                          | C.first                       | -<br>&gt;                                    | **S.removingFirst()**<br>&gt;    | C.removeFirst()       | C.popFirst() | -<br>&gt;             |<br>&gt; &gt; | Last 1                           | C.last                        | -<br>&gt;                                    | **S.removingLast()**<br>&gt;     | C.removeLast()        | C.popLast()  | -<br>&gt;             |<br>&gt; &gt; | First (n: Int)                   | S.prefix(3)                   | -<br>&gt;                                    | **S.removingPrefix(3)**<br>&gt;    | **C.removePrefix(3)** | -            | **S.hasPrefix([x,y,z])**<br>&gt;            |<br>&gt; &gt; |             ...with closure      | S.prefix(while:      isPrime) | -<br>&gt;                                    | **S.removingPrefix(while:<br>&gt; isPrime)** | -                     | -            | **S.hasPrefix([x,y,z],<br>&gt;     by:      ==)** |<br>&gt; &gt; | Last (n: Int)                    | S.suffix(3)                   | -<br>&gt;                                    | **S.removingSuffix(3)**<br>&gt;    | **C.removeSuffix(3)** | -            | -<br>&gt;             |<br>&gt; &gt; |             ...with closure      | -                             | -<br>&gt;                                    | -<br>&gt;    | -                     | -            | -<br>&gt;             |<br>&gt; &gt; | **Searching From End**           |<br>&gt; &gt; | First      matching      element | -                             |<br>&gt; **C.firstIndex(of:      x)**          | -<br>&gt;        | -                     | -            | -<br>&gt;                 |<br>&gt; &gt; |             ...with closure      | S.first(where:      isPrime)  |<br>&gt; **C.firstIndex(where:      isPrime)** | -<br>&gt;        | -                     | -            | -<br>&gt;                 |<br>&gt; &gt; | Last matching element            | -                             | -<br>&gt;                                    | -<br>&gt;    | -                     | -            | -<br>&gt;             |<br>&gt; &gt; |             ...with closure      | -                             | -<br>&gt;                                    | -<br>&gt;    | -                     | -            | -<br>&gt;             |<br>&gt;<br>&gt; My suggestion would be to make the remove()<br>&gt; operations more forgiving:<br>&gt;<br>&gt;    rename popFirst() to removeFirst()<br>&gt;    rename popLast() to removeLast()<br>&gt;<br>&gt;    kill removeFirst(n)<br>&gt;    kill removeLast(n)<br>&gt;<br></p><p>+1 to this.<br></p><p><br>&gt; The “forgiving” forms of x.removeFirst(n) and x.removeLast(n) can be<br>&gt; expressed as:<br>&gt;<br>&gt;    let i = x.index(x.startIndex, offsetBy: n, limitedBy: x.endIndex)<br>&gt;    x.removeSubrange(..&lt;i)<br>&gt;<br>&gt;    let i = x.index(x.endIndexIndex, offsetBy: -n, limitedBy: x.startIndex)<br>&gt;    x.removeSubrange(i..&lt;)<br>&gt;<br>&gt; I realize that&#39;s quite verbose.  We could of course just make<br>&gt; removePrefix(n) and removeSuffix(n) forgiving, but I have long believed<br>&gt; that the “prefix/suffix” methods should go one of two ways:<br>&gt;<br>&gt; a. they get a label that clarifies the meaning of the argument, e.g.<br>&gt;<br>&gt;    x.removePrefix(ofMaxLength: n)<br>&gt;    x.removeSuffix(ofMaxLength: n)<br>&gt;<br>&gt; b. they are given a recognizable domain-specific notation such as:<br>&gt;<br>&gt;    x.removeSubrange($+n..&lt;)<br>&gt;    x.removeSubrange(..&lt;$-n)<br>&gt;<br>&gt;    I am strongly in favor of this answer (which is implementable within<br>&gt;    the framework of this proposal) because of the way it reduces API<br>&gt;    surface area and leverages the user&#39;s understanding of how ranges<br>&gt;    work.<br>&gt;<br>&gt;    It also implies we can replace<br>&gt;<br>&gt;      x.removingPrefix(n)<br>&gt;      x.removingSuffix(n)<br>&gt;<br>&gt;    with<br>&gt;<br>&gt;      x[$+n..&lt;]<br>&gt;      x[..&lt;$-n]<br>&gt;<br>&gt;   for Collections.<br>&gt;<br></p><p>I&#39;m not enamored of this suggestion. It succeeds in reducing API surface<br>area, but at a severe cost to readability. You&#39;d replace an unambiguous<br>phrase (removing prefix or suffix), the meaning of which is further<br>clarified by the consistent usage proposed in SE-0132, with a wordless<br>spelling using some combination of [$+.&lt;]. Cognitively, also, it<br>substantially increases the burden for the reader: it replaces a single<br>argument with a nested series of arguments; first, one must understand the<br>meaning of the $ placeholder, then one must consider an addition or<br>subtraction operation, then the formation of a range, and in the last<br>example, the use of that range as a subscript argument--again, all<br>wordlessly. Finally, subscripts have so far not been &quot;forgiving,&quot; while<br>today&#39;s `dropLast` very much is; this suggestion would add inconsistency by<br>using a subscript for a forgiving or &quot;lenient&quot; operation.<br></p><p><br>&gt;<br>&gt;   That would admittedly leave single-pass Sequences without an API for<br>&gt;   dropping the first N elements. I am inclined to think that interface<br>&gt;   should be moved to Iterator.<br>&gt;<br>&gt;   The introduction of such notation raises the question of whether we<br>&gt;   need unary range operators, and could instead go with<br>&gt;<br>&gt;      x[i..&lt;$] and x[$..&lt;i]<br>&gt;<br>&gt;   which is after all only one character longer than<br>&gt;<br>&gt;      x[i..&lt;] and x[..&lt;i]<br>&gt;<br>&gt;   and stays out of the territory of the prefix/suffix “pack/unpack”<br>&gt;   operators that are likely to be used for generic variadics.<br>&gt;<br></p><p>Pyry&#39;s comments about the precedence issues with unary range operators are,<br>I think, serious enough that the unary operators should be reconsidered.<br>This suggestion might work but I wonder if we could do better than $.<br></p><p><br>&gt; &gt; ### Index-based operations<br>&gt; &gt;<br>&gt; &gt; Because these APIs look up elements based on their indices, we believe<br>&gt; &gt; these operations should be exposed as subscripts, and ideally should<br>&gt; &gt; look like other slicing operations:<br>&gt; &gt;<br>&gt; &gt; ```swift<br>&gt; &gt; let head = people[..&lt;i]<br>&gt; &gt; let tail = people[i..&lt;]<br>&gt; &gt; let rearrangedPeople = tail + head<br>&gt; &gt; ```<br>&gt; &gt;<br>&gt; &gt; &lt;!-- Comment to make my editor happy --&gt;<br>&gt; &gt;<br>&gt; &gt; We will accomplish this by introducing two new types, `IncompleteRange`<br>&gt; &gt; and `IncompleteClosedRange`. These are similar to `Range` and<br>&gt; &gt; `ClosedRange`, except that the bounds are optional.<br>&gt; &gt;<br>&gt; &gt; To construct them, we will introduce both prefix and suffix operators<br>&gt; &gt; taking a non-optional bound, and infix operators taking optional bounds.<br>&gt; &gt; (We offer both because `c[..&lt;i]` is more convenient than `c[nil ..&lt; i]`,<br>&gt; &gt; but doesn&#39;t allow you to dynamically choose between supplying and<br>&gt; &gt; omitting a bound.) These will follow the existing convention: `..&lt;` will<br>&gt; &gt; construct the half-open `IncompleteRange`, while `...` will construct<br>&gt; &gt; `IncompleteClosedRange`.<br>&gt;<br>&gt; I believe the `$+n..&lt;i` idea is still implementable with these basic<br>&gt; types, just with an enum instead of optionals.  I&#39;ll take a shot at it<br>&gt; tonight if I can get a few minutes.<br>&gt;<br>&gt; &gt; Rather than continuing to proliferate overloads of slicing subscripts,<br>&gt; &gt; we will also introduce a new `RangeExpression` protocol which allows<br>&gt; &gt; any range-like type to convert itself into a plain `Range&lt;Index&gt;`<br>&gt; &gt; appropriate to the collection in question. Thus, there should only be<br>&gt; &gt; two range subscripts: one taking `Range&lt;Index&gt;`, and one taking<br>&gt; &gt; everything else.<br>&gt; &gt;<br>&gt; &gt; We will also modify the existing `removeSubrange(_:)` and<br>&gt; &gt; `replaceSubrange(_:with:)` calls to take `RangeExpression` instances,<br>&gt; &gt; thereby merging many existing variants into one while simultaneously<br>&gt; &gt; extending them to support `IncompleteRange` and `IncompleteClosedRange`.<br>&gt; &gt; Though technically additive, we believe this is an easy win.<br>&gt; &gt;<br>&gt; &gt; Thus, the table above becomes:<br>&gt; &gt;<br>&gt; &gt; |                                                  | Type<br>&gt;               | Get                  | Remove<br>&gt; | Replace                                                     |<br>&gt; &gt; | ------------------------------------------------ |<br>&gt; --------------------------------- | -------------------- |<br>&gt; ----------------------------------- |<br>&gt; ----------------------------------------------------------- |<br>&gt; &gt; | **Based      on      Index,      Arbitrary**     |<br>&gt; &gt; | (i: Index) ..&lt; (j: Index)                        | Range\&lt;Index&gt;<br>&gt;                | C[i      ..&lt;      j] | C.removeSubrange(i      ..&lt;      j)<br>&gt; | C.replaceSubrange(i      ..&lt;      j,      with:      [x,y]) |<br>&gt; &gt; |             ...Countable                         |<br>&gt; CountableRange\&lt;Index&gt;            | C[i ..&lt; j]           |<br>&gt; C.removeSubrange(i      ..&lt;      j) | C.replaceSubrange(i      ..&lt;      j,<br>&gt;     with:      [x,y]) |<br>&gt; &gt; | (i: Index) ... (j: Index)                        |<br>&gt; ClosedRange\&lt;Index&gt;               | C[i ... j]           |<br>&gt; C.removeSubrange(i ... j)           | C.replaceSubrange(i ... j, with:<br>&gt; [x,y])                     |<br>&gt; &gt; |             ...Countable                         |<br>&gt; CountableClosedRange\&lt;Index&gt;      | C[i ... j]           |<br>&gt; C.removeSubrange(i ... j)           | C.replaceSubrange(i ... j, with:<br>&gt; [x,y])                     |<br>&gt; &gt; | **Based      on      Index,      From      End** |<br>&gt; &gt; | startIndex ..&lt; (i: Index)                        |<br>&gt; **IncompleteRange\&lt;Index&gt;**       | **C[..\&lt;i]**         |<br>&gt; **C.removeSubrange(..\&lt;i)**         | **C.replaceSubrange(..\&lt;i,<br>&gt; with:      [x,y])**         |<br>&gt; &gt; | (i: Index) ..&lt; endIndex                          |<br>&gt; **IncompleteRange\&lt;Index&gt;**       | **C[i..\&lt;]**         |<br>&gt; **C.removeSubrange(i..\&lt;)**         | **C.replaceSubrange(i..\&lt;, with:<br>&gt; [x,y])**                   |<br>&gt; &gt; | startIndex ... (i: Index)                        |<br>&gt; **IncompleteClosedRange\&lt;Index&gt;** | **C[...i]**          |<br>&gt; **C.removeSubrange(...i)**          | **C.replaceSubrange(...i, with:<br>&gt; [x,y])**                    |<br>&gt; &gt;<br>&gt; &gt; However, it should be implemented with merely:<br>&gt; &gt;<br>&gt; &gt; |                                               | Type<br>&gt;                               | Get                  | Remove<br>&gt;                 | Replace<br>&gt;    |<br>&gt; &gt; | --------------------------------------------- |<br>&gt; --------------------------------------------------- | --------------------<br>&gt; | ----------------------------------- |<br>&gt; ----------------------------------------------------------- |<br>&gt; &gt; | (i:      Index)      ..&lt;      (j:      Index) | Range\&lt;Index&gt;<br>&gt;                              | C[i      ..&lt;      j] | C.removeSubrange(i<br>&gt;   ..&lt;      j) | C.replaceSubrange(i      ..&lt;      j,      with:      [x,y])<br>&gt; |<br>&gt; &gt; | Everything else                               | RangeExpression where<br>&gt;     Bound      ==      Index | C[i      ...      j] | C.removeSubrange(i<br>&gt;   ...      j) | C.replaceSubrange(i      ...      j,      with:      [x,y])<br>&gt; |<br>&gt; &gt;<br>&gt; &gt; ## Detailed design<br>&gt; &gt;<br>&gt; &gt; ### Sequence-end operations<br>&gt; &gt;<br>&gt; &gt; The following methods should be renamed as follows wherever they appear<br>&gt; &gt; in the standard library. These are simple textual substitutions; we<br>&gt; &gt; propose no changes whatsoever to types, parameter interpretations, or<br>&gt; &gt; other semantics.<br>&gt; &gt;<br>&gt; &gt; | Old method                                        | New method<br>&gt;                                       |<br>&gt; &gt; | ------------------------------------------------- |<br>&gt; ------------------------------------------------------- |<br>&gt; &gt; | `dropFirst() -&gt; SubSequence`                      | `removingFirst()<br>&gt; -&gt; SubSequence`                        |<br>&gt; &gt; | `dropLast() -&gt; SubSequence`                       | `removingLast() -&gt;<br>&gt; SubSequence`                         |<br>&gt; &gt; | `dropFirst(_ n: Int) -&gt; SubSequence`              | `removingPrefix(_<br>&gt; n: Int) -&gt; SubSequence`               |<br>&gt; &gt; | `drop(@noescape while predicate: (Iterator.Element) throws -&gt; Bool)<br>&gt; rethrows -&gt; SubSequence` | `removingPrefix(@noescape while predicate:<br>&gt; (Iterator.Element) throws -&gt; Bool) rethrows -&gt; SubSequence` |<br>&gt;<br>&gt; I&#39;m concerned with how the above fits into the scheme.  Writing it out<br>&gt; is:<br>&gt;<br>&gt;     x[(x.firstIndex(where: {!predicate($0)}) ?? x.endIndex)..&lt;$]<br>&gt;<br>&gt; and that&#39;s just for Collections.  Drat; we might not be able to get rid<br>&gt; of these “removingPrefix” operations altogether.  OK, I&#39;m out of time so<br>&gt; I&#39;ll have to get back to this.<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160725/45ff1163/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>July 26, 2016 at 08:00:00am</p></header><div class="content"><p>On 26 Jul 2016, at 06:50, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt;    surface area and leverages the user&#39;s understanding of how ranges<br>&gt;&gt;    work.<br>&gt;&gt; <br>&gt;&gt;    It also implies we can replace<br>&gt;&gt; <br>&gt;&gt;      x.removingPrefix(n)<br>&gt;&gt;      x.removingSuffix(n)<br>&gt;&gt; <br>&gt;&gt;    with<br>&gt;&gt; <br>&gt;&gt;      x[$+n..&lt;]<br>&gt;&gt;      x[..&lt;$-n]<br>&gt;&gt; <br>&gt;&gt;   for Collections.<br>&gt; <br>&gt; I&#39;m not enamored of this suggestion. It succeeds in reducing API surface area, but at a severe cost to readability. You&#39;d replace an unambiguous phrase (removing prefix or suffix), the meaning of which is further clarified by the consistent usage proposed in SE-0132, with a wordless spelling using some combination of [$+.&lt;]. Cognitively, also, it substantially increases the burden for the reader: it replaces a single argument with a nested series of arguments; first, one must understand the meaning of the $ placeholder, then one must consider an addition or subtraction operation, then the formation of a range, and in the last example, the use of that range as a subscript argument--again, all wordlessly. Finally, subscripts have so far not been &quot;forgiving,&quot; while today&#39;s `dropLast` very much is; this suggestion would add inconsistency by using a subscript for a forgiving or &quot;lenient&quot; operation.<br></p><p>I second Xiaodi. I am against the slicing subscripts and the ones above look even more unreadable and inscrutable than those in the proposal. I don&#39;t understand the rational.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160726/056e9748/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>July 26, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Jul 25, 2016, at 11:32 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On 26 Jul 2016, at 06:50, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;    surface area and leverages the user&#39;s understanding of how ranges<br>&gt;&gt;    work.<br>&gt;&gt; <br>&gt;&gt;    It also implies we can replace<br>&gt;&gt; <br>&gt;&gt;      x.removingPrefix(n)<br>&gt;&gt;      x.removingSuffix(n)<br>&gt;&gt; <br>&gt;&gt;    with<br>&gt;&gt; <br>&gt;&gt;      x[$+n..&lt;]<br>&gt;&gt;      x[..&lt;$-n]<br>&gt;&gt; <br>&gt;&gt;   for Collections.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not enamored of this suggestion. It succeeds in reducing API surface area, but at a severe cost to readability. You&#39;d replace an unambiguous phrase (removing prefix or suffix), the meaning of which is further clarified by the consistent usage proposed in SE-0132, with a wordless spelling using some combination of [$+.&lt;]. Cognitively, also, it substantially increases the burden for the reader: it replaces a single argument with a nested series of arguments; first, one must understand the meaning of the $ placeholder, then one must consider an addition or subtraction operation, then the formation of a range, and in the last example, the use of that range as a subscript argument--again, all wordlessly. Finally, subscripts have so far not been &quot;forgiving,&quot; while today&#39;s `dropLast` very much is; this suggestion would add inconsistency by using a subscript for a forgiving or &quot;lenient&quot; operation.<br>&gt; <br>&gt; I second Xiaodi. I am against the slicing subscripts and the ones above look even more unreadable and inscrutable than those in the proposal. I don&#39;t understand the rational.<br></p><p>The inspiration is D: https://dlang.org/d-array-article.html &lt;https://dlang.org/d-array-article.html&gt;<br></p><p>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160726/ab89f45b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 26, 2016 at 03:00:00am</p></header><div class="content"><p>On Tue, Jul 26, 2016 at 2:01 AM, Daniel Duan &lt;daniel at duan.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jul 25, 2016, at 11:32 PM, David Hart via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; On 26 Jul 2016, at 06:50, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;    surface area and leverages the user&#39;s understanding of how ranges<br>&gt;&gt;    work.<br>&gt;&gt;<br>&gt;&gt;    It also implies we can replace<br>&gt;&gt;<br>&gt;&gt;      x.removingPrefix(n)<br>&gt;&gt;      x.removingSuffix(n)<br>&gt;&gt;<br>&gt;&gt;    with<br>&gt;&gt;<br>&gt;&gt;      x[$+n..&lt;]<br>&gt;&gt;      x[..&lt;$-n]<br>&gt;&gt;<br>&gt;&gt;   for Collections.<br>&gt;&gt;<br>&gt;<br>&gt; I&#39;m not enamored of this suggestion. It succeeds in reducing API surface<br>&gt; area, but at a severe cost to readability. You&#39;d replace an unambiguous<br>&gt; phrase (removing prefix or suffix), the meaning of which is further<br>&gt; clarified by the consistent usage proposed in SE-0132, with a wordless<br>&gt; spelling using some combination of [$+.&lt;]. Cognitively, also, it<br>&gt; substantially increases the burden for the reader: it replaces a single<br>&gt; argument with a nested series of arguments; first, one must understand the<br>&gt; meaning of the $ placeholder, then one must consider an addition or<br>&gt; subtraction operation, then the formation of a range, and in the last<br>&gt; example, the use of that range as a subscript argument--again, all<br>&gt; wordlessly. Finally, subscripts have so far not been &quot;forgiving,&quot; while<br>&gt; today&#39;s `dropLast` very much is; this suggestion would add inconsistency by<br>&gt; using a subscript for a forgiving or &quot;lenient&quot; operation.<br>&gt;<br>&gt;<br>&gt; I second Xiaodi. I am against the slicing subscripts and the ones above<br>&gt; look even more unreadable and inscrutable than those in the proposal. I<br>&gt; don&#39;t understand the rational.<br>&gt;<br>&gt;<br>&gt; The inspiration is D: https://dlang.org/d-array-article.html<br>&gt;<br></p><p>Neat. However, $+n and $-n remain problematic for me, one additional reason<br>being that these suggest indices move themselves, which they no longer do<br>in Swift 3. Of course, we could (and, in fact, we would have to) say that<br>$+n is short for `x.index(x.startIndex, offsetBy: n)`, but that&#39;d be a<br>pretty big contortion for the + operator.<br></p><p>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160726/b14629f8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 26, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; On Jul 25, 2016, at 6:35 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; First, though, I have to apologize for those wide tables, since I&#39;m<br>&gt; listed as a co-author (because of a small design contribution).  The<br>&gt; only way I&#39;ve been able to read them is by looking at the markdown<br>&gt; source, so that&#39;s how I&#39;m going to quote it here.<br></p><p>Sorry about that. I felt that the systematic way the names were arranged couldn&#39;t be conveyed in any other way, but the resulting formatting is regrettably difficult to read.<br></p><p>&gt; Unfortunately there&#39;s a semantic difference that I hadn&#39;t noticed<br>&gt; before: the mutating “remove” operations have a precondition that there<br>&gt; be at least as many elements as are being removed.  “Drop,” like “pop,”<br>&gt; is forgiving of such overruns.  I think this is solvable; my suggestion<br>&gt; is below<br></p><p>Wow, there&#39;s a lot going on in this next section.<br></p><p>To preface this discussion, I&#39;ll merely point out that, in writing this proposal, I tried to narrowly focus on renaming. My inability to rename `prefix(upTo/through:)` and `suffix(from:)` in a way that made sense led me to a more aggressive redesign, but for the other calls I considered larger redesigns out of scope. I say this not as an argument against redesigning the `remove` calls, but merely to explain why I didn&#39;t fiddle with their semantics already.<br></p><p>To address things one at a time:<br></p><p>&gt; My suggestion would be to make the remove()<br>&gt; operations more forgiving:<br>&gt; <br>&gt;   rename popFirst() to removeFirst()<br>&gt;   rename popLast() to removeLast()<br></p><p>I actually quite agree that `removeFirst/Last()` and `popFirst/Last()` are redundant. I think I briefly touched on that in &quot;Future Directions&quot;.<br></p><p>Going out of order for a moment:<br></p><p>&gt; We could of course just make<br>&gt; removePrefix(n) and removeSuffix(n) forgiving,<br></p><p>If we&#39;re going to go beyond renaming, this is the approach I favor, because it is the most straightforward and readable. When you see a piece of code that says `removePrefix(n)`, it doesn&#39;t take much effort to figure out that it&#39;s removing a series of elements from the beginning of the sequence.<br></p><p>Specifically, if we go this route, I would:<br></p><p>* Remove the `popFirst/Last` methods.<br>* Remove the preconditions on removeFirst/Last/Prefix/Suffix requiring the collection to not be smaller than the number of elements to be removed.<br>* Change the signatures to something like:<br></p><p>	@discardableResult<br>	func removeFirst() -&gt; Iterator.Element?<br>	@discardableResult<br>	func removeLast() -&gt; Iterator.Element?<br>	@discardableResult<br>	func removePrefix(_ n: Int) -&gt; [Iterator.Element]	// or SubSequence<br>	@discardableResult<br>	func removeSuffix(_ n: Int) -&gt; [Iterator.Element]	// or SubSequence<br></p><p>I&#39;ve added return types to `removePrefix/Suffix` so that they follow our general rule about not throwing away information that isn&#39;t necessarily easy to compute, but that part of the change isn&#39;t strictly necessary.<br></p><p>&gt; but I have long believed<br>&gt; that the “prefix/suffix” methods should go one of two ways:<br>&gt; <br>&gt; a. they get a label that clarifies the meaning of the argument, e.g.<br>&gt; <br>&gt;   x.removePrefix(ofMaxLength: n)<br>&gt;   x.removeSuffix(ofMaxLength: n)<br></p><p>I struggled for a while to find a good label for the count parameters, but couldn&#39;t find a good convention.<br></p><p>The fundamental problem is that English counting grammar doesn&#39;t line up with Swift syntax. In English, you would like to say &quot;prefix of 3 elements&quot;, but you can&#39;t put a label after a parameter in Swift. Thus, there may not be an idiomatic way to label these parameters. (This is a problem throughout the standard library, actually; I ran into the same issues when I was looking at the UnsafeRawPointer proposal.)<br></p><p>Labels like `ofMaxLength` are verbose, and the use of &quot;length&quot; in particular isn&#39;t great when the standard library otherwise uses &quot;count&quot;. If you put a gun to my head and demanded I add a label, I would make it `x.removePrefix(ofUpTo: n)` or just `x.removePrefix(of: n)`. But I&#39;m not convinced any of these bring enough to the table. When you see an unlabeled Int parameter to a call with a name like `removePrefix`, there&#39;s really only a couple of things it could mean, and the count is an unsurprising one.<br></p><p>On the other hand, the internal parameter name should probably not be `n`; it should be something like `count` or even `countToRemove`.<br></p><p>(Probably obvious, but worth mentioning explicitly: if we add a label, we should apply it consistently to all `prefix` and `suffix` calls which take a count.)<br></p><p>Okay, back to the right order:<br></p><p>&gt;   kill removeFirst(n)<br>&gt;   kill removeLast(n)<br>&gt; <br>&gt; The “forgiving” forms of x.removeFirst(n) and x.removeLast(n) can be<br>&gt; expressed as:<br>&gt; <br>&gt;   let i = x.index(x.startIndex, offsetBy: n, limitedBy: x.endIndex)<br>&gt;   x.removeSubrange(..&lt;i)<br>&gt; <br>&gt;   let i = x.index(x.endIndexIndex, offsetBy: -n, limitedBy: x.startIndex)<br>&gt;   x.removeSubrange(i..&lt;)<br>&gt; <br>&gt; I realize that&#39;s quite verbose.<br></p><p><br>No kidding. It requires:<br></p><p>* Two statements, four references to the collection, and 88 characters (for an example with one-letter variable names)<br>* The use of a complex index-manipulation function<br>* The simultaneous use of the startIndex, endIndex, and a sign on the count, all of which must be coordinated<br></p><p>I think that, if `removePrefix/Suffix(_:)` were not in the standard library, people would be forced to invent them.<br></p><p>&gt; b. they are given a recognizable domain-specific notation such as:<br>&gt; <br>&gt;   x.removeSubrange($+n..&lt;)<br>&gt;   x.removeSubrange(..&lt;$-n)<br></p><p>Does $ represent the start, the end, or either one depending on which side of the range we&#39;re on? Because if it&#39;s the third option, I think these two operations are actually inverted: the first is removing everything *except* the `prefix(n)`, and the second is removing everything except the `suffix(n)`.<br></p><p>(Or maybe it&#39;s based on the sign, with a negative offset going from the endIndex, and a positive offset going from the startIndex? Don&#39;t we usually try to avoid that kind of runtime branching?)<br></p><p>&gt;  That would admittedly leave single-pass Sequences without an API for<br>&gt;  dropping the first N elements. I am inclined to think that interface<br>&gt;  should be moved to Iterator.<br></p><p>Why would it be a good thing to use two different syntaxes for the same operation?<br></p><p>&gt;  The introduction of such notation raises the question of whether we<br>&gt;  need unary range operators, and could instead go with<br>&gt; <br>&gt;     x[i..&lt;$] and x[$..&lt;i]<br>&gt; <br>&gt;  which is after all only one character longer than<br>&gt; <br>&gt;     x[i..&lt;] and x[..&lt;i]<br>&gt; <br>&gt;  and stays out of the territory of the prefix/suffix “pack/unpack”<br>&gt;  operators that are likely to be used for generic variadics.<br>…<br>&gt; I believe the `$+n..&lt;i` idea is still implementable with these basic<br>&gt; types, just with an enum instead of optionals.  I&#39;ll take a shot at it<br>&gt; tonight if I can get a few minutes.<br></p><p>Xcode 8 beta 3-compatible hack based on my assumptions about how this supposed to work, suitable for at least testing the ergonomics: https://gist.github.com/brentdax/3c5c64d3b7ca3ff6b68f1c86163c39c4<br></p><p>At a technical level, I think the biggest problem is the `$` symbol. If it&#39;s a constant or variable, then it can&#39;t be generic, and we need to fix a specific SignedInteger type for the offset. That means we need to convert to whatever IndexDistance ends up being. That could be fixed if either `$` became a magic syntax or we get generic constants, but either of those will be a significant effort. Or it can be a function, but then it&#39;s less convenient.<br></p><p>Stepping back from implementation, though, I think the `$` syntax is just too opaque. It gets better when it&#39;s spaced out:<br></p><p>	array[$ + 2 ..&lt; $ - 1]<br></p><p>But it&#39;s still not something whose meaning you will even make a wild guess at without looking it up. Even once you learn it, the $ symbol will almost always be squeezed between two other punctuation characters, making visual parsing more difficult. The effect is not unlike stereotypes of Perl.<br></p><p>(Note: I&#39;m an old Perl hand, so others might better read that sentence as &quot;The effect is not unlike Perl.&quot;)<br></p><p>I mean, look at this example you gave earlier:<br></p><p>&gt;   It also implies we can replace<br>&gt; <br>&gt;     x.removingPrefix(n)<br>&gt;     x.removingSuffix(n)<br>&gt; <br>&gt;   with<br>&gt; <br>&gt;     x[$+n..&lt;]<br>&gt;     x[..&lt;$-n]<br>&gt; <br>&gt;  for Collections.  <br></p><p>The first version is clear as crystal; the second is clear as mud. The first version gives the parameter a position of prominence; the second buries it in the middle of a complex expression.<br></p><p>Now, abandoning the `$` could help here. I&#39;ve worked up an alternate design which uses descriptive names at &lt;https://gist.github.com/brentdax/0946a99528f6e6500d93bbf67684c0b3&gt;. The example I gave above is instead written:<br></p><p>	array[.startIndex + 2 ..&lt; .endIndex - 1]<br></p><p>Or, for the removingPrefix equivalent:<br></p><p>	x[.startIndex + n ..&lt; .endIndex]<br></p><p>But this is longer than a removingPrefix call and *still* buries the intent. And adding prefix/suffix operators back in doesn&#39;t really help; it merely allows you to omit the straightforward bits, without doing anything to help make the non-straightforward bits more clear. (And in fact, it makes those worse by forcing you to either compress the whitespace in them or parenthesize.)<br></p><p>And even if we get past the syntax issues, there&#39;s an attractive nuisance problem. This feature, whatever it is, will undoubtedly circulate as &quot;the way to make String indexes work&quot;. Is that something we want to bring to the language?<br></p><p>In short, I think the idea of relative ranges is pretty neat. It&#39;s brief, it&#39;s parsimonious, it&#39;s flexible, it&#39;s clever. But it makes code less clear and it hides performance problems. I think either of those two factors by itself ought to make us rethink a Swift proposal.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 26, 2016 at 08:00:00am</p></header><div class="content"><p>on Tue Jul 26 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br></p><p>&gt;&gt; On Jul 25, 2016, at 6:35 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; First, though, I have to apologize for those wide tables, since I&#39;m<br>&gt;&gt; listed as a co-author (because of a small design contribution).  The<br>&gt;&gt; only way I&#39;ve been able to read them is by looking at the markdown<br>&gt;&gt; source, so that&#39;s how I&#39;m going to quote it here.<br>&gt;<br>&gt; Sorry about that. I felt that the systematic way the names were<br>&gt; arranged couldn&#39;t be conveyed in any other way, but the resulting<br>&gt; formatting is regrettably difficult to read.<br>&gt;<br>&gt;&gt; Unfortunately there&#39;s a semantic difference that I hadn&#39;t noticed<br>&gt;&gt; before: the mutating “remove” operations have a precondition that there<br>&gt;&gt; be at least as many elements as are being removed.  “Drop,” like “pop,”<br>&gt;&gt; is forgiving of such overruns.  I think this is solvable; my suggestion<br>&gt;&gt; is below<br>&gt;<br>&gt; Wow, there&#39;s a lot going on in this next section.<br></p><p>Yeah, my turn to say sorry.<br></p><p>&gt; To preface this discussion, I&#39;ll merely point out that, in writing<br>&gt; this proposal, I tried to narrowly focus on renaming. My inability to<br>&gt; rename `prefix(upTo/through:)` and `suffix(from:)` in a way that made<br>&gt; sense led me to a more aggressive redesign, but for the other calls I<br>&gt; considered larger redesigns out of scope. I say this not as an<br>&gt; argument against redesigning the `remove` calls, but merely to explain<br>&gt; why I didn&#39;t fiddle with their semantics already.<br></p><p>Makes sense.<br></p><p>&gt;<br>&gt;<br>&gt; To address things one at a time:<br>&gt;<br>&gt;&gt; My suggestion would be to make the remove()<br>&gt;&gt; operations more forgiving:<br>&gt;&gt; <br>&gt;&gt;   rename popFirst() to removeFirst()<br>&gt;&gt;   rename popLast() to removeLast()<br>&gt;<br>&gt; I actually quite agree that `removeFirst/Last()` and `popFirst/Last()`<br>&gt; are redundant. I think I briefly touched on that in &quot;Future<br>&gt; Directions&quot;.<br></p><p>Missed that.  Your proposal is a bit long, so it&#39;s hard to take<br>everything in.  Here&#39;s what you say:<br></p><p>   removeFirst/Last() and popFirst/Last() are very nearly redundant;<br>   their only difference is that the remove methods have a non-Optional<br>   return type and require the collection not be empty, while the pop<br>   methods have an Optional return type and return nil if it&#39;s empty.<br></p><p>   These operations could be merged, with the remove operations taking<br>   on the preconditions of the current pop operations; <br></p><p>The current pop operations *have* no preconditions.  By “taking on the<br>preconditions of the current pop operations” do you mean “dropping their<br>preconditions?”<br></p><p>   additionally, removePrefix(_:) and removeSuffix(_:) could drop their<br>   equivalent preconditions requiring that the elements being removed<br>   exist.<br></p><p>IIUC you are suggesting making the remove operations uniformly<br>“forgiving,” yes?  I think I&#39;m in favor.<br></p><p>&gt; Going out of order for a moment:<br>&gt;<br>&gt;&gt; We could of course just make<br>&gt;&gt; removePrefix(n) and removeSuffix(n) forgiving,<br>&gt;<br>&gt; If we&#39;re going to go beyond renaming, this is the approach I favor,<br>&gt; because it is the most straightforward and readable. When you see a<br>&gt; piece of code that says `removePrefix(n)`, it doesn&#39;t take much effort<br>&gt; to figure out that it&#39;s removing a series of elements from the<br>&gt; beginning of the sequence.<br></p><p>Of course not, that&#39;s entirely captured by “removePrefix.”  It&#39;s the<br>clarity of the meaning of “n” that concerns me.<br></p><p>&gt; Specifically, if we go this route, I would:<br>&gt;<br>&gt; * Remove the `popFirst/Last` methods.<br>&gt; * Remove the preconditions on removeFirst/Last/Prefix/Suffix requiring<br>&gt; the collection to not be smaller than the number of elements to be<br>&gt; removed.<br>&gt; * Change the signatures to something like:<br>&gt;<br>&gt; 	@discardableResult<br>&gt; 	func removeFirst() -&gt; Iterator.Element?<br>&gt; 	@discardableResult<br>&gt; 	func removeLast() -&gt; Iterator.Element?<br></p><p>This part is equivalent to renaming popFirst/ popLast to<br>removeFirst/removeLast, right?<br></p><p>&gt; 	<br>&gt; 	@discardableResult func removePrefix(_ n: Int) -&gt;<br>&gt; 	[Iterator.Element] // or SubSequence <br>&gt;       @discardableResult func<br>&gt; 	removeSuffix(_ n: Int) -&gt; [Iterator.Element] // or SubSequence<br>&gt;<br>&gt; I&#39;ve added return types to `removePrefix/Suffix` so that they follow<br>&gt; our general rule about not throwing away information that isn&#39;t<br>&gt; necessarily easy to compute, but that part of the change isn&#39;t<br>&gt; strictly necessary.<br></p><p>Yeah, I don&#39;t think we can do those without loss of efficiency; the<br>return value would prevent removals from being done in-place in CoW<br>structures.<br></p><p>&gt;&gt; but I have long believed<br>&gt;&gt; that the “prefix/suffix” methods should go one of two ways:<br>&gt;&gt; <br>&gt;&gt; a. they get a label that clarifies the meaning of the argument, e.g.<br>&gt;&gt; <br>&gt;&gt;   x.removePrefix(ofMaxLength: n)<br>&gt;&gt;   x.removeSuffix(ofMaxLength: n)<br>&gt;<br>&gt; I struggled for a while to find a good label for the count parameters,<br>&gt; but couldn&#39;t find a good convention.<br>&gt;<br>&gt; The fundamental problem is that English counting grammar doesn&#39;t line<br>&gt; up with Swift syntax. In English, you would like to say &quot;prefix of 3<br>&gt; elements&quot;, but you can&#39;t put a label after a parameter in Swift. Thus,<br>&gt; there may not be an idiomatic way to label these parameters. (This is<br>&gt; a problem throughout the standard library, actually; I ran into the<br>&gt; same issues when I was looking at the UnsafeRawPointer proposal.)<br></p><p>I don&#39;t see how “a prefix of maximum length 3” fails to be idiomatic.<br></p><p>&gt; Labels like `ofMaxLength` are verbose, <br></p><p>Yes.<br></p><p>&gt; and the use of &quot;length&quot; in particular isn&#39;t great when the standard<br>&gt; library otherwise uses &quot;count&quot;. <br></p><p>The name `count` causes all kinds of problems, so I view conflicts with<br>it as inevitable.<br></p><p>&gt; If you put a gun to my head and demanded I add a label, I would make<br>&gt; it `x.removePrefix(ofUpTo: n)` <br></p><p>That one is easily misinterpreted as removing the longest prefix that<br>doesn&#39;t include the value `n`.<br></p><p>&gt; or just `x.removePrefix(of: n)`. <br></p><p>That one is easily misinterpreted as removing the first element if it is<br>equal to `n`.<br></p><p>&gt; But I&#39;m not convinced any of these bring enough to the table.<br></p><p>I agree that they don&#39;t clarify enough (or anything in the case of “of”).<br></p><p>&gt; When you see an unlabeled Int parameter to a call with a name like<br>&gt; `removePrefix`, there&#39;s really only a couple of things it could mean,<br>&gt; and the count is an unsurprising one.<br>&gt;<br>&gt; On the other hand, the internal parameter name should probably not be<br>&gt; `n`; it should be something like `count` or even `countToRemove`.<br></p><p>The parameter name should first serve the documentation comment.  IMO<br>`count` is worse than `n` in that regard and `countToRemove` makes the<br>comment read awkwardly.  But this is really tangential at best.<br></p><p>&gt; (Probably obvious, but worth mentioning explicitly: if we add a label,<br>&gt; we should apply it consistently to all `prefix` and `suffix` calls<br>&gt; which take a count.)<br></p><p>Obvious, yes.<br></p><p>&gt;<br>&gt;<br>&gt; Okay, back to the right order:<br>&gt;<br>&gt;&gt;   kill removeFirst(n)<br>&gt;&gt;   kill removeLast(n)<br>&gt;&gt; <br>&gt;&gt; The “forgiving” forms of x.removeFirst(n) and x.removeLast(n) can be<br>&gt;&gt; expressed as:<br>&gt;&gt; <br>&gt;&gt;   let i = x.index(x.startIndex, offsetBy: n, limitedBy: x.endIndex)<br>&gt;&gt;   x.removeSubrange(..&lt;i)<br>&gt;&gt; <br>&gt;&gt;   let i = x.index(x.endIndexIndex, offsetBy: -n, limitedBy: x.startIndex)<br>&gt;&gt;   x.removeSubrange(i..&lt;)<br>&gt;&gt; <br>&gt;&gt; I realize that&#39;s quite verbose.<br>&gt;<br>&gt; No kidding. It requires:<br>&gt;<br>&gt; * Two statements, four references to the collection, and 88 characters<br>&gt; (for an example with one-letter variable names)<br>&gt; * The use of a complex index-manipulation function<br>&gt; * The simultaneous use of the startIndex, endIndex, and a sign on the<br>&gt; count, all of which must be coordinated<br>&gt;<br>&gt; I think that, if `removePrefix/Suffix(_:)` were not in the standard<br>&gt; library, people would be forced to invent them.<br></p><p>They might, but probably not in that form.  I&#39;m not convinced people<br>need them to be forgiving.  They just have to be forgiving if we name<br>them the same as the renamed popXXX methods.  But that doesn&#39;t change<br>your point substantially.<br></p><p>&gt;<br>&gt;<br>&gt;&gt; b. they are given a recognizable domain-specific notation such as:<br>&gt;&gt; <br>&gt;&gt;   x.removeSubrange($+n..&lt;)<br>&gt;&gt;   x.removeSubrange(..&lt;$-n)<br>&gt;<br>&gt; Does $ represent the start, the end, or either one depending on which<br>&gt; side of the range we&#39;re on? Because if it&#39;s the third option, I think<br>&gt; these two operations are actually inverted: the first is removing<br>&gt; everything *except* the `prefix(n)`, and the second is removing<br>&gt; everything except the `suffix(n)`.<br></p><p>Wow, that was impressive!  With one stroke, you have just convinced me<br>that we can&#39;t do this.  The fact that I got it wrong, along with other<br>excellent feedback in this thread, kills my interest in using $ in this<br>way.<br></p><p>&gt; (Or maybe it&#39;s based on the sign, with a negative offset going from<br>&gt; the endIndex, and a positive offset going from the startIndex? Don&#39;t<br>&gt; we usually try to avoid that kind of runtime branching?)<br>&gt;<br>&gt;&gt;  That would admittedly leave single-pass Sequences without an API for<br>&gt;&gt;  dropping the first N elements. I am inclined to think that interface<br>&gt;&gt;  should be moved to Iterator.<br>&gt;<br>&gt; Why would it be a good thing to use two different syntaxes for the<br>&gt; same operation?<br></p><p>It wouldn&#39;t.  I was just trying to make the world fit my preconceived<br>idea of the right solution ;-)<br></p><p>&gt;&gt;  The introduction of such notation raises the question of whether we<br>&gt;&gt;  need unary range operators, and could instead go with<br>&gt;&gt; <br>&gt;&gt;     x[i..&lt;$] and x[$..&lt;i]<br>&gt;&gt; <br>&gt;&gt;  which is after all only one character longer than<br>&gt;&gt; <br>&gt;&gt;     x[i..&lt;] and x[..&lt;i]<br>&gt;&gt; <br>&gt;&gt;  and stays out of the territory of the prefix/suffix “pack/unpack”<br>&gt;&gt;  operators that are likely to be used for generic variadics.<br>&gt; …<br>&gt;&gt; I believe the `$+n..&lt;i` idea is still implementable with these basic<br>&gt;&gt; types, just with an enum instead of optionals.  I&#39;ll take a shot at it<br>&gt;&gt; tonight if I can get a few minutes.<br>&gt;<br>&gt; Xcode 8 beta 3-compatible hack based on my assumptions about how this<br>&gt; supposed to work, suitable for at least testing the ergonomics:<br>&gt; https://gist.github.com/brentdax/3c5c64d3b7ca3ff6b68f1c86163c39c4<br>&gt;<br>&gt; At a technical level, I think the biggest problem is the `$`<br>&gt; symbol. If it&#39;s a constant or variable, then it can&#39;t be generic, and<br>&gt; we need to fix a specific SignedInteger type for the offset. That<br>&gt; means we need to convert to whatever IndexDistance ends up being. That<br>&gt; could be fixed if either `$` became a magic syntax or we get generic<br>&gt; constants, but either of those will be a significant effort. Or it can<br>&gt; be a function, but then it&#39;s less convenient.<br>&gt;<br>&gt; Stepping back from implementation, though, I think the `$` syntax is<br>&gt; just too opaque. It gets better when it&#39;s spaced out:<br>&gt;<br>&gt; 	array[$ + 2 ..&lt; $ - 1]<br>&gt;<br>&gt; But it&#39;s still not something whose meaning you will even make a wild<br>&gt; guess at without looking it up. Even once you learn it, the $ symbol<br>&gt; will almost always be squeezed between two other punctuation<br>&gt; characters, making visual parsing more difficult. The effect is not<br>&gt; unlike stereotypes of Perl.<br>&gt;<br>&gt; (Note: I&#39;m an old Perl hand, so others might better read that sentence<br>&gt; as &quot;The effect is not unlike Perl.&quot;)<br></p><p>OK, now you&#39;re just driving the dagger in deeper.  My poor idea is dead already!<br>&gt;<br>&gt; I mean, look at this example you gave earlier:<br>&gt;<br>&gt;&gt;   It also implies we can replace<br>&gt;&gt; <br>&gt;&gt;     x.removingPrefix(n)<br>&gt;&gt;     x.removingSuffix(n)<br>&gt;&gt; <br>&gt;&gt;   with<br>&gt;&gt; <br>&gt;&gt;     x[$+n..&lt;]<br>&gt;&gt;     x[..&lt;$-n]<br>&gt;&gt; <br>&gt;&gt;  for Collections.  <br>&gt;<br>&gt; The first version is clear as crystal; the second is clear as mud. The<br>&gt; first version gives the parameter a position of prominence; the second<br>&gt; buries it in the middle of a complex expression.<br>&gt;<br>&gt; Now, abandoning the `$` could help here. I&#39;ve worked up an alternate<br>&gt; design which uses descriptive names at<br>&gt; &lt;https://gist.github.com/brentdax/0946a99528f6e6500d93bbf67684c0b3&gt;. The<br>&gt; example I gave above is instead written:<br>&gt;<br>&gt; 	array[.startIndex + 2 ..&lt; .endIndex - 1]<br>&gt;<br>&gt; Or, for the removingPrefix equivalent:<br>&gt;<br>&gt; 	x[.startIndex + n ..&lt; .endIndex]<br>&gt;<br>&gt; But this is longer than a removingPrefix call and *still* buries the<br>&gt; intent. And adding prefix/suffix operators back in doesn&#39;t really<br>&gt; help; it merely allows you to omit the straightforward bits, without<br>&gt; doing anything to help make the non-straightforward bits more<br>&gt; clear. (And in fact, it makes those worse by forcing you to either<br>&gt; compress the whitespace in them or parenthesize.)<br>&gt;<br>&gt; And even if we get past the syntax issues, there&#39;s an attractive<br>&gt; nuisance problem. This feature, whatever it is, will undoubtedly<br>&gt; circulate as &quot;the way to make String indexes work&quot;. Is that something<br>&gt; we want to bring to the language?<br>&gt;<br>&gt; In short, I think the idea of relative ranges is pretty neat. It&#39;s<br>&gt; brief, it&#39;s parsimonious, it&#39;s flexible, it&#39;s clever. But it makes<br>&gt; code less clear and it hides performance problems. I think either of<br>&gt; those two factors by itself ought to make us rethink a Swift proposal.<br></p><p>Sold.<br></p><p>Thanks for indulging my unworkable fantasy,<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>July 27, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On 26 Jul 2016, at 16:15, Dave Abrahams wrote:<br>&gt; <br>&gt;&gt;&gt; b. they are given a recognizable domain-specific notation such as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  x.removeSubrange($+n..&lt;)<br>&gt;&gt;&gt;  x.removeSubrange(..&lt;$-n)<br>&gt;&gt; <br>&gt;&gt; Does $ represent the start, the end, or either one depending on which<br>&gt;&gt; side of the range we&#39;re on? Because if it&#39;s the third option, I think<br>&gt;&gt; these two operations are actually inverted: the first is removing<br>&gt;&gt; everything *except* the `prefix(n)`, and the second is removing<br>&gt;&gt; everything except the `suffix(n)`.<br>&gt; <br>&gt; Wow, that was impressive!  With one stroke, you have just convinced me<br>&gt; that we can&#39;t do this.  The fact that I got it wrong, along with other<br>&gt; excellent feedback in this thread, kills my interest in using $ in this<br>&gt; way.<br></p><p>This would also conflict with one of the following:<br></p><p>1. Allowing `$` for the Dollar library.<br></p><p>	&lt;https://github.com/apple/swift-evolution/pull/354&gt;<br></p><p>2. Reserving `$` for the debugger.<br></p><p>	&lt;https://github.com/apple/swift/pull/3004&gt;<br></p><p>(The latter &quot;test and merge&quot; is failing for some reason).<br></p><p>-- Ben<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/242e18b243022bcb7573443e06444423?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Boris Wang</string> &lt;kona.ming at gmail.com&gt;<p>July 26, 2016 at 11:00:00pm</p></header><div class="content"><p>We should consider SE-0111.<br>The label of parameter is not part of function signature anymore.<br></p><p>Just a quick peek, what&#39;s your first impression for<br></p><p>some.first(n)<br></p><p>Opt 1: the first element, who&#39;s value == n<br>Opt 2: the elements, who&#39;s index less than n<br></p><p><br>Ben Rimmington via swift-evolution &lt;swift-evolution at swift.org&gt;于2016年7月27日<br>周三07:29写道：<br></p><p>&gt;<br>&gt; &gt; On 26 Jul 2016, at 16:15, Dave Abrahams wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; b. they are given a recognizable domain-specific notation such as:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;  x.removeSubrange($+n..&lt;)<br>&gt; &gt;&gt;&gt;  x.removeSubrange(..&lt;$-n)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Does $ represent the start, the end, or either one depending on which<br>&gt; &gt;&gt; side of the range we&#39;re on? Because if it&#39;s the third option, I think<br>&gt; &gt;&gt; these two operations are actually inverted: the first is removing<br>&gt; &gt;&gt; everything *except* the `prefix(n)`, and the second is removing<br>&gt; &gt;&gt; everything except the `suffix(n)`.<br>&gt; &gt;<br>&gt; &gt; Wow, that was impressive!  With one stroke, you have just convinced me<br>&gt; &gt; that we can&#39;t do this.  The fact that I got it wrong, along with other<br>&gt; &gt; excellent feedback in this thread, kills my interest in using $ in this<br>&gt; &gt; way.<br>&gt;<br>&gt; This would also conflict with one of the following:<br>&gt;<br>&gt; 1. Allowing `$` for the Dollar library.<br>&gt;<br>&gt;         &lt;https://github.com/apple/swift-evolution/pull/354&gt;<br>&gt;<br>&gt; 2. Reserving `$` for the debugger.<br>&gt;<br>&gt;         &lt;https://github.com/apple/swift/pull/3004&gt;<br>&gt;<br>&gt; (The latter &quot;test and merge&quot; is failing for some reason).<br>&gt;<br>&gt; -- Ben<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160726/aed72bc2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>July 26, 2016 at 08:00:00pm</p></header><div class="content"><p>On Tue, Jul 26, 2016 at 7:56 PM, Boris Wang via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; We should consider SE-0111.<br>&gt; The label of parameter is not part of function signature anymore.<br>&gt;<br></p><p>What are you driving at?<br></p><p>Per SE–0111<br>&lt;https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md&gt;,<br>a function’s argument labels are no longer part of the function’s *type*,<br>whereas per SE–0021<br>&lt;https://github.com/apple/swift-evolution/blob/master/proposals/0021-generalized-naming.md&gt;<br>they *are* part of its *name*. The whole discussion in this thread has been<br>about *naming*, so I don’t see the relevance of bringing up SE–0111.<br></p><p><br></p><p>&gt; Just a quick peek, what&#39;s your first impression for<br>&gt;<br>&gt; some.first(n)<br>&gt;<br>&gt; Opt 1: the first element, who&#39;s value == n<br>&gt; Opt 2: the elements, who&#39;s index less than n<br>&gt;<br></p><p>Neither.<br></p><p>It is asking for, quite specifically, the first n elements.<br></p><p>Nevin<br></p><p><br></p><p>&gt;<br>&gt; Ben Rimmington via swift-evolution &lt;swift-evolution at swift.org&gt;于2016年7月27日<br>&gt; 周三07:29写道：<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On 26 Jul 2016, at 16:15, Dave Abrahams wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; b. they are given a recognizable domain-specific notation such as:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;  x.removeSubrange($+n..&lt;)<br>&gt;&gt; &gt;&gt;&gt;  x.removeSubrange(..&lt;$-n)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Does $ represent the start, the end, or either one depending on which<br>&gt;&gt; &gt;&gt; side of the range we&#39;re on? Because if it&#39;s the third option, I think<br>&gt;&gt; &gt;&gt; these two operations are actually inverted: the first is removing<br>&gt;&gt; &gt;&gt; everything *except* the `prefix(n)`, and the second is removing<br>&gt;&gt; &gt;&gt; everything except the `suffix(n)`.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Wow, that was impressive!  With one stroke, you have just convinced me<br>&gt;&gt; &gt; that we can&#39;t do this.  The fact that I got it wrong, along with other<br>&gt;&gt; &gt; excellent feedback in this thread, kills my interest in using $ in this<br>&gt;&gt; &gt; way.<br>&gt;&gt;<br>&gt;&gt; This would also conflict with one of the following:<br>&gt;&gt;<br>&gt;&gt; 1. Allowing `$` for the Dollar library.<br>&gt;&gt;<br>&gt;&gt;         &lt;https://github.com/apple/swift-evolution/pull/354&gt;<br>&gt;&gt;<br>&gt;&gt; 2. Reserving `$` for the debugger.<br>&gt;&gt;<br>&gt;&gt;         &lt;https://github.com/apple/swift/pull/3004&gt;<br>&gt;&gt;<br>&gt;&gt; (The latter &quot;test and merge&quot; is failing for some reason).<br>&gt;&gt;<br>&gt;&gt; -- Ben<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160726/7efe3bf5/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>[SHORT Review] SE-0132: Rationalizing Sequence end-operation names</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>July 26, 2016 at 08:00:00am</p></header><div class="content"><p>Daniel Duan<br>Sent from my iPhone<br></p><p>On Jul 26, 2016, at 5:56 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Jul 25, 2016, at 6:35 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; First, though, I have to apologize for those wide tables, since I&#39;m<br>&gt;&gt; listed as a co-author (because of a small design contribution).  The<br>&gt;&gt; only way I&#39;ve been able to read them is by looking at the markdown<br>&gt;&gt; source, so that&#39;s how I&#39;m going to quote it here.<br>&gt; <br>&gt; Sorry about that. I felt that the systematic way the names were arranged couldn&#39;t be conveyed in any other way, but the resulting formatting is regrettably difficult to read.<br>&gt; <br>&gt;&gt; Unfortunately there&#39;s a semantic difference that I hadn&#39;t noticed<br>&gt;&gt; before: the mutating “remove” operations have a precondition that there<br>&gt;&gt; be at least as many elements as are being removed.  “Drop,” like “pop,”<br>&gt;&gt; is forgiving of such overruns.  I think this is solvable; my suggestion<br>&gt;&gt; is below<br>&gt; <br>&gt; Wow, there&#39;s a lot going on in this next section.<br>&gt; <br>&gt; To preface this discussion, I&#39;ll merely point out that, in writing this proposal, I tried to narrowly focus on renaming. My inability to rename `prefix(upTo/through:)` and `suffix(from:)` in a way that made sense led me to a more aggressive redesign, but for the other calls I considered larger redesigns out of scope. I say this not as an argument against redesigning the `remove` calls, but merely to explain why I didn&#39;t fiddle with their semantics already.<br>&gt; <br>&gt; To address things one at a time:<br>&gt; <br>&gt;&gt; My suggestion would be to make the remove()<br>&gt;&gt; operations more forgiving:<br>&gt;&gt; <br>&gt;&gt;  rename popFirst() to removeFirst()<br>&gt;&gt;  rename popLast() to removeLast()<br>&gt; <br>&gt; I actually quite agree that `removeFirst/Last()` and `popFirst/Last()` are redundant. I think I briefly touched on that in &quot;Future Directions&quot;.<br>&gt; <br>&gt; Going out of order for a moment:<br>&gt; <br>&gt;&gt; We could of course just make<br>&gt;&gt; removePrefix(n) and removeSuffix(n) forgiving,<br>&gt; <br>&gt; If we&#39;re going to go beyond renaming, this is the approach I favor, because it is the most straightforward and readable. When you see a piece of code that says `removePrefix(n)`, it doesn&#39;t take much effort to figure out that it&#39;s removing a series of elements from the beginning of the sequence.<br>&gt; <br>&gt; Specifically, if we go this route, I would:<br>&gt; <br>&gt; * Remove the `popFirst/Last` methods.<br>&gt; * Remove the preconditions on removeFirst/Last/Prefix/Suffix requiring the collection to not be smaller than the number of elements to be removed.<br>&gt; * Change the signatures to something like:<br>&gt; <br>&gt;    @discardableResult<br>&gt;    func removeFirst() -&gt; Iterator.Element?<br>&gt;    @discardableResult<br>&gt;    func removeLast() -&gt; Iterator.Element?<br>&gt;    @discardableResult<br>&gt;    func removePrefix(_ n: Int) -&gt; [Iterator.Element]    // or SubSequence<br>&gt;    @discardableResult<br>&gt;    func removeSuffix(_ n: Int) -&gt; [Iterator.Element]    // or SubSequence<br>&gt; <br>&gt; I&#39;ve added return types to `removePrefix/Suffix` so that they follow our general rule about not throwing away information that isn&#39;t necessarily easy to compute, but that part of the change isn&#39;t strictly necessary.<br>&gt; <br>&gt;&gt; but I have long believed<br>&gt;&gt; that the “prefix/suffix” methods should go one of two ways:<br>&gt;&gt; <br>&gt;&gt; a. they get a label that clarifies the meaning of the argument, e.g.<br>&gt;&gt; <br>&gt;&gt;  x.removePrefix(ofMaxLength: n)<br>&gt;&gt;  x.removeSuffix(ofMaxLength: n)<br>&gt; <br>&gt; I struggled for a while to find a good label for the count parameters, but couldn&#39;t find a good convention.<br>&gt; <br>&gt; The fundamental problem is that English counting grammar doesn&#39;t line up with Swift syntax. In English, you would like to say &quot;prefix of 3 elements&quot;, but you can&#39;t put a label after a parameter in Swift. Thus, there may not be an idiomatic way to label these parameters. (This is a problem throughout the standard library, actually; I ran into the same issues when I was looking at the UnsafeRawPointer proposal.)<br>&gt; <br>&gt; Labels like `ofMaxLength` are verbose, and the use of &quot;length&quot; in particular isn&#39;t great when the standard library otherwise uses &quot;count&quot;. If you put a gun to my head and demanded I add a label, I would make it `x.removePrefix(ofUpTo: n)` or just `x.removePrefix(of: n)`. But I&#39;m not convinced any of these bring enough to the table. When you see an unlabeled Int parameter to a call with a name like `removePrefix`, there&#39;s really only a couple of things it could mean, and the count is an unsurprising one.<br>&gt; <br>&gt; On the other hand, the internal parameter name should probably not be `n`; it should be something like `count` or even `countToRemove`.<br>&gt; <br>&gt; (Probably obvious, but worth mentioning explicitly: if we add a label, we should apply it consistently to all `prefix` and `suffix` calls which take a count.)<br>&gt; <br>&gt; Okay, back to the right order:<br>&gt; <br>&gt;&gt;  kill removeFirst(n)<br>&gt;&gt;  kill removeLast(n)<br>&gt;&gt; <br>&gt;&gt; The “forgiving” forms of x.removeFirst(n) and x.removeLast(n) can be<br>&gt;&gt; expressed as:<br>&gt;&gt; <br>&gt;&gt;  let i = x.index(x.startIndex, offsetBy: n, limitedBy: x.endIndex)<br>&gt;&gt;  x.removeSubrange(..&lt;i)<br>&gt;&gt; <br>&gt;&gt;  let i = x.index(x.endIndexIndex, offsetBy: -n, limitedBy: x.startIndex)<br>&gt;&gt;  x.removeSubrange(i..&lt;)<br>&gt;&gt; <br>&gt;&gt; I realize that&#39;s quite verbose.<br>&gt; <br>&gt; <br>&gt; No kidding. It requires:<br>&gt; <br>&gt; * Two statements, four references to the collection, and 88 characters (for an example with one-letter variable names)<br>&gt; * The use of a complex index-manipulation function<br>&gt; * The simultaneous use of the startIndex, endIndex, and a sign on the count, all of which must be coordinated<br>&gt; <br>&gt; I think that, if `removePrefix/Suffix(_:)` were not in the standard library, people would be forced to invent them.<br>&gt; <br>&gt;&gt; b. they are given a recognizable domain-specific notation such as:<br>&gt;&gt; <br>&gt;&gt;  x.removeSubrange($+n..&lt;)<br>&gt;&gt;  x.removeSubrange(..&lt;$-n)<br>&gt; <br>&gt; Does $ represent the start, the end, or either one depending on which side of the range we&#39;re on? Because if it&#39;s the third option, I think these two operations are actually inverted: the first is removing everything *except* the `prefix(n)`, and the second is removing everything except the `suffix(n)`.<br>&gt; <br>&gt; (Or maybe it&#39;s based on the sign, with a negative offset going from the endIndex, and a positive offset going from the startIndex? Don&#39;t we usually try to avoid that kind of runtime branching?)<br>&gt; <br>&gt;&gt; That would admittedly leave single-pass Sequences without an API for<br>&gt;&gt; dropping the first N elements. I am inclined to think that interface<br>&gt;&gt; should be moved to Iterator.<br>&gt; <br>&gt; Why would it be a good thing to use two different syntaxes for the same operation?<br>&gt; <br>&gt;&gt; The introduction of such notation raises the question of whether we<br>&gt;&gt; need unary range operators, and could instead go with<br>&gt;&gt; <br>&gt;&gt;    x[i..&lt;$] and x[$..&lt;i]<br>&gt;&gt; <br>&gt;&gt; which is after all only one character longer than<br>&gt;&gt; <br>&gt;&gt;    x[i..&lt;] and x[..&lt;i]<br>&gt;&gt; <br>&gt;&gt; and stays out of the territory of the prefix/suffix “pack/unpack”<br>&gt;&gt; operators that are likely to be used for generic variadics.<br>&gt; …<br>&gt;&gt; I believe the `$+n..&lt;i` idea is still implementable with these basic<br>&gt;&gt; types, just with an enum instead of optionals.  I&#39;ll take a shot at it<br>&gt;&gt; tonight if I can get a few minutes.<br>&gt; <br>&gt; Xcode 8 beta 3-compatible hack based on my assumptions about how this supposed to work, suitable for at least testing the ergonomics: https://gist.github.com/brentdax/3c5c64d3b7ca3ff6b68f1c86163c39c4<br>&gt; <br>&gt; At a technical level, I think the biggest problem is the `$` symbol. If it&#39;s a constant or variable, then it can&#39;t be generic, and we need to fix a specific SignedInteger type for the offset. That means we need to convert to whatever IndexDistance ends up being. That could be fixed if either `$` became a magic syntax or we get generic constants, but either of those will be a significant effort. Or it can be a function, but then it&#39;s less convenient.<br>&gt; <br>&gt; Stepping back from implementation, though, I think the `$` syntax is just too opaque. It gets better when it&#39;s spaced out:<br>&gt; <br>&gt;    array[$ + 2 ..&lt; $ - 1]<br>&gt; <br>&gt; But it&#39;s still not something whose meaning you will even make a wild guess at without looking it up. Even once you learn it, the $ symbol will almost always be squeezed between two other punctuation characters, making visual parsing more difficult. The effect is not unlike stereotypes of Perl.<br>&gt; <br>&gt; (Note: I&#39;m an old Perl hand, so others might better read that sentence as &quot;The effect is not unlike Perl.&quot;)<br>&gt; <br>&gt; I mean, look at this example you gave earlier:<br>&gt; <br>&gt;&gt;  It also implies we can replace<br>&gt;&gt; <br>&gt;&gt;    x.removingPrefix(n)<br>&gt;&gt;    x.removingSuffix(n)<br>&gt;&gt; <br>&gt;&gt;  with<br>&gt;&gt; <br>&gt;&gt;    x[$+n..&lt;]<br>&gt;&gt;    x[..&lt;$-n]<br>&gt;&gt; <br>&gt;&gt; for Collections.  <br>&gt; <br>&gt; The first version is clear as crystal; the second is clear as mud. The first version gives the parameter a position of prominence; the second buries it in the middle of a complex expression.<br>&gt; <br>&gt; Now, abandoning the `$` could help here. I&#39;ve worked up an alternate design which uses descriptive names at &lt;https://gist.github.com/brentdax/0946a99528f6e6500d93bbf67684c0b3&gt;. The example I gave above is instead written:<br>&gt; <br>&gt;    array[.startIndex + 2 ..&lt; .endIndex - 1]<br>&gt; <br>&gt; Or, for the removingPrefix equivalent:<br>&gt; <br>&gt;    x[.startIndex + n ..&lt; .endIndex]<br>&gt; <br> I assume start and end index can be used on either end?<br></p><p>Also, since &quot;Index&quot; will already be part of the type name, we can use &quot;start&quot; and &quot;end&quot; here instead.<br></p><p>&gt; But this is longer than a removingPrefix call and *still* buries the intent. And adding prefix/suffix operators back in doesn&#39;t really help; it merely allows you to omit the straightforward bits, without doing anything to help make the non-straightforward bits more clear. (And in fact, it makes those worse by forcing you to either compress the whitespace in them or parenthesize.)<br>&gt; <br>&gt; And even if we get past the syntax issues, there&#39;s an attractive nuisance problem. This feature, whatever it is, will undoubtedly circulate as &quot;the way to make String indexes work&quot;. Is that something we want to bring to the language?<br>&gt; <br>&gt; In short, I think the idea of relative ranges is pretty neat. It&#39;s brief, it&#39;s parsimonious, it&#39;s flexible, it&#39;s clever. But it makes code less clear and it hides performance problems. I think either of those two factors by itself ought to make us rethink a Swift proposal.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
