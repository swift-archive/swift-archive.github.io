<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c68458ef31619f30cfc2b4ebbc17c4f6?s=50"></div><header><strong>Proposal: Sealed protocols</strong> from <string>Felix Gabel</string> &lt;felix.gabel at me.com&gt;<p>December  3, 2015 at 11:00:00pm</p></header><div class="content"><p>Hey everyone,<br></p><p>I hereby propose adding a ?sealed? modifier for protocols to enable library developers to declare protocols that can be only conformed to in the scope of the library itself. This is similar to a ?sealed trait? in Scala with the difference that it does not limit the protocol to be only applicable in the file it is declared in.<br></p><p>Example:<br></p><p>public sealed protocol FooType {<br>    // this protocol can be conformed to only in scope of the library itself<br>    // it can NOT be conformed to by any object declared outside the library<br>}<br></p><p>What do you think?<br></p><p>Thank you for your time,<br>Felix<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Proposal: Sealed protocols</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December  3, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 3, 2015, at 2:59 PM, Felix Gabel &lt;felix.gabel at me.com&gt; wrote:<br>&gt; <br>&gt; Hey everyone,<br>&gt; <br>&gt; I hereby propose adding a ?sealed? modifier for protocols to enable library developers to declare protocols that can be only conformed to in the scope of the library itself. This is similar to a ?sealed trait? in Scala with the difference that it does not limit the protocol to be only applicable in the file it is declared in.<br>&gt; <br>&gt; Example:<br>&gt; <br>&gt; public sealed protocol FooType {<br>&gt;    // this protocol can be conformed to only in scope of the library itself<br>&gt;    // it can NOT be conformed to by any object declared outside the library<br>&gt; }<br>&gt; <br>&gt; What do you think?<br></p><p><br>Can you elaborate on why a Swift developer would want to distinguish between ?public sealed? and ?internal??<br></p><p>	- Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c88cf5486b9cffde0cf2acbd181c19e2?s=50"></div><header><strong>Proposal: Sealed protocols</strong> from <string>Mehdi Amini</string> &lt;mehdi.amini at apple.com&gt;<p>December  3, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 3, 2015, at 3:09 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 3, 2015, at 2:59 PM, Felix Gabel &lt;felix.gabel at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey everyone,<br>&gt;&gt; <br>&gt;&gt; I hereby propose adding a ?sealed? modifier for protocols to enable library developers to declare protocols that can be only conformed to in the scope of the library itself. This is similar to a ?sealed trait? in Scala with the difference that it does not limit the protocol to be only applicable in the file it is declared in.<br>&gt;&gt; <br>&gt;&gt; Example:<br>&gt;&gt; <br>&gt;&gt; public sealed protocol FooType {<br>&gt;&gt;   // this protocol can be conformed to only in scope of the library itself<br>&gt;&gt;   // it can NOT be conformed to by any object declared outside the library<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; What do you think?<br>&gt; <br>&gt; <br>&gt; Can you elaborate on why a Swift developer would want to distinguish between ?public sealed? and ?internal??<br></p><p>I can foresee how a whole module optimization would be able to do better devirtualization in this case, knowing the full possible set of type of instance.<br></p><p>? <br>Mehdi<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Proposal: Sealed protocols</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December  3, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 3, 2015, at 3:13 PM, Mehdi Amini &lt;mehdi.amini at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 3, 2015, at 3:09 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 3, 2015, at 2:59 PM, Felix Gabel &lt;felix.gabel at me.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hey everyone,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I hereby propose adding a ?sealed? modifier for protocols to enable library developers to declare protocols that can be only conformed to in the scope of the library itself. This is similar to a ?sealed trait? in Scala with the difference that it does not limit the protocol to be only applicable in the file it is declared in.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public sealed protocol FooType {<br>&gt;&gt;&gt;  // this protocol can be conformed to only in scope of the library itself<br>&gt;&gt;&gt;  // it can NOT be conformed to by any object declared outside the library<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What do you think?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Can you elaborate on why a Swift developer would want to distinguish between ?public sealed? and ?internal??<br>&gt; <br>&gt; I can foresee how a whole module optimization would be able to do better devirtualization in this case, knowing the full possible set of type of instance.<br></p><p>Are you perhaps thinking of the different between ?public? and ?public sealed?? Both ?public sealed? and ?internal? allow whole module optimization to know the complete set of types that conform to the protocol. In the former case, that?s true because it?s the semantics of ?sealed?; in the latter case, that?s true because the protocol isn?t visible outside of the module.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/9a985d81/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c88cf5486b9cffde0cf2acbd181c19e2?s=50"></div><header><strong>Proposal: Sealed protocols</strong> from <string>Mehdi Amini</string> &lt;mehdi.amini at apple.com&gt;<p>December  3, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 3, 2015, at 3:33 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 3, 2015, at 3:13 PM, Mehdi Amini &lt;mehdi.amini at apple.com &lt;mailto:mehdi.amini at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 3, 2015, at 3:09 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 3, 2015, at 2:59 PM, Felix Gabel &lt;felix.gabel at me.com &lt;mailto:felix.gabel at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hey everyone,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I hereby propose adding a ?sealed? modifier for protocols to enable library developers to declare protocols that can be only conformed to in the scope of the library itself. This is similar to a ?sealed trait? in Scala with the difference that it does not limit the protocol to be only applicable in the file it is declared in.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public sealed protocol FooType {<br>&gt;&gt;&gt;&gt;  // this protocol can be conformed to only in scope of the library itself<br>&gt;&gt;&gt;&gt;  // it can NOT be conformed to by any object declared outside the library<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What do you think?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can you elaborate on why a Swift developer would want to distinguish between ?public sealed? and ?internal??<br>&gt;&gt; <br>&gt;&gt; I can foresee how a whole module optimization would be able to do better devirtualization in this case, knowing the full possible set of type of instance.<br>&gt; <br>&gt; Are you perhaps thinking of the different between ?public? and ?public sealed?? Both ?public sealed? and ?internal? allow whole module optimization to know the complete set of types that conform to the protocol. In the former case, that?s true because it?s the semantics of ?sealed?; in the latter case, that?s true because the protocol isn?t visible outside of the module.<br></p><p>Oh yes you?re right, I meant it for the difference between ?public? and ?public sealed?, but that wasn?t your question?<br></p><p>? <br>Mehdi<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/61b1ab50/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Proposal: Sealed protocols</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  3, 2015 at 03:00:00pm</p></header><div class="content"><p>On Thu, Dec 3, 2015 at 3:09 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; On Dec 3, 2015, at 2:59 PM, Felix Gabel &lt;felix.gabel at me.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hey everyone,<br>&gt;&gt;<br>&gt;&gt; I hereby propose adding a ?sealed? modifier for protocols to enable<br>library developers to declare protocols that can be only conformed to in<br>the scope of the library itself. This is similar to a ?sealed trait? in<br>Scala with the difference that it does not limit the protocol to be only<br>applicable in the file it is declared in.<br>&gt;&gt;<br>&gt;&gt; Example:<br>&gt;&gt;<br>&gt;&gt; public sealed protocol FooType {<br>&gt;&gt;    // this protocol can be conformed to only in scope of the library<br>itself<br>&gt;&gt;    // it can NOT be conformed to by any object declared outside the<br>library<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; What do you think?<br>&gt;<br>&gt;<br>&gt; Can you elaborate on why a Swift developer would want to distinguish<br>between ?public sealed? and ?internal??<br></p><p>There are cases when the library isn&#39;t designed to support new conformances<br>for the protocol, but the protocol is public because other public APIs are<br>expressed in terms of it.<br></p><p>We have a case for it in the standard library, &#39;protocol<br>AnyCollectionType&#39;.  Foundation also has a use case -- property list types.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/ab0c1961/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Sealed protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  3, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; There are cases when the library isn&#39;t designed to support new conformances for the protocol, but the protocol is public because other public APIs are expressed in terms of it.<br>&gt; <br>&gt; We have a case for it in the standard library, &#39;protocol AnyCollectionType&#39;.  Foundation also has a use case -- property list types.<br></p><p>I have had cases for this as well.  Joe Groff&#39;s suggestion of adding more convenient syntax for sum types as an alternative may be an acceptable alternative for the cases I have seen, although I would need to have a better idea of what that might look like.  Joe, have you written a proposal for this?<br></p><p>Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Sealed protocols</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  3, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 3, 2015, at 3:32 PM, Anandabits &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; There are cases when the library isn&#39;t designed to support new conformances for the protocol, but the protocol is public because other public APIs are expressed in terms of it.<br>&gt;&gt; <br>&gt;&gt; We have a case for it in the standard library, &#39;protocol AnyCollectionType&#39;.  Foundation also has a use case -- property list types.<br>&gt; <br>&gt; I have had cases for this as well.  Joe Groff&#39;s suggestion of adding more convenient syntax for sum types as an alternative may be an acceptable alternative for the cases I have seen, although I would need to have a better idea of what that might look like.  Joe, have you written a proposal for this?<br></p><p>Only vague notions, nothing ready to formally propose. Optional has hardcoded support for being a supertype of its `Some` payload; it might be worth surfacing that as a language feature other enums can also take advantage of:<br></p><p>enum Optional&lt;Wrapped&gt; {<br>  // Strawman: &#39;sub case&#39; declares a case whose type becomes a subtype of the enum<br>  sub case Some(Wrapped)<br>  case None<br>}<br>enum Result&lt;Success, Error: ErrorType&gt; {<br>  sub case OK(Success)<br>  case Error(Error)<br>}<br></p><p>There would need to be constraints so that two &#39;sub cases&#39; are never able to have overlapping payload types?otherwise with something like Either&lt;Int, Int&gt;, it&#39;d be ambiguous which side of Either Int promotes to. OTOH, optional subtyping also causes some issues (1 &lt; nil works being one of the more prominent ones), so we may not want to dig the subtyping hole deeper either?like I said, only vague notions.<br></p><p>-Joe<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c68458ef31619f30cfc2b4ebbc17c4f6?s=50"></div><header><strong>Proposal: Sealed protocols</strong> from <string>Felix Gabel</string> &lt;felix.gabel at me.com&gt;<p>December  4, 2015 at 01:00:00am</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 12:25 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Thu, Dec 3, 2015 at 3:09 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On Dec 3, 2015, at 2:59 PM, Felix Gabel &lt;felix.gabel at me.com &lt;mailto:felix.gabel at me.com&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Hey everyone,<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I hereby propose adding a ?sealed? modifier for protocols to enable library developers to declare protocols that can be only conformed to in the scope of the library itself. This is similar to a ?sealed trait? in Scala with the difference that it does not limit the protocol to be only applicable in the file it is declared in.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Example:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; public sealed protocol FooType {<br>&gt; &gt;&gt;    // this protocol can be conformed to only in scope of the library itself<br>&gt; &gt;&gt;    // it can NOT be conformed to by any object declared outside the library<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; What do you think?<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Can you elaborate on why a Swift developer would want to distinguish between ?public sealed? and ?internal??<br>&gt; <br>&gt; There are cases when the library isn&#39;t designed to support new conformances for the protocol, but the protocol is public because other public APIs are expressed in terms of it.<br>&gt; <br>&gt; We have a case for it in the standard library, &#39;protocol AnyCollectionType&#39;.  Foundation also has a use case -- property list types.<br>&gt; <br>&gt; Dmitri<br></p><p>- protocols starting with an underscore (_ArrayBufferType, _IntegerType, etc) would benefit from the ?sealed? modifier, because the contract right now only implicitly says: ?public but please don?t use?.<br>- another use case is grouping a set of types regardless their origin and limit the ability to extend the provided number of types by external forces<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/eff0486f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d30e546d655d1c7ece0464791a9a90d5?s=50"></div><header><strong>Proposal: Sealed protocols</strong> from <string>Adrian Kashivskyy</string> &lt;adrian.kashivskyy at me.com&gt;<p>December  4, 2015 at 01:00:00am</p></header><div class="content"><p>&gt; protocols starting with an underscore (_ArrayBufferType, _IntegerType, etc) would benefit from the ?sealed? modifier, because the contract right now only implicitly says: ?public but please don?t use?.<br></p><p>I think it&#39;s wiser to refactor those protocols to be public and fully usable than to insert another access modifier to a language. Contracts that say &quot;public but please don?t use&quot; are generally a sign of design that is poor or limited by language/compiler.<br></p><p>Pozdrawiam ? Regards,<br>Adrian Kashivskyy<br></p><p>&gt; Wiadomo?? napisana przez Felix Gabel &lt;felix.gabel at me.com&gt; w dniu 04.12.2015, o godz. 01:45:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 4, 2015, at 12:25 AM, Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Thu, Dec 3, 2015 at 3:09 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Dec 3, 2015, at 2:59 PM, Felix Gabel &lt;felix.gabel at me.com &lt;mailto:felix.gabel at me.com&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Hey everyone,<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I hereby propose adding a ?sealed? modifier for protocols to enable library developers to declare protocols that can be only conformed to in the scope of the library itself. This is similar to a ?sealed trait? in Scala with the difference that it does not limit the protocol to be only applicable in the file it is declared in.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Example:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; public sealed protocol FooType {<br>&gt;&gt; &gt;&gt;    // this protocol can be conformed to only in scope of the library itself<br>&gt;&gt; &gt;&gt;    // it can NOT be conformed to by any object declared outside the library<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; What do you think?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Can you elaborate on why a Swift developer would want to distinguish between ?public sealed? and ?internal??<br>&gt;&gt; <br>&gt;&gt; There are cases when the library isn&#39;t designed to support new conformances for the protocol, but the protocol is public because other public APIs are expressed in terms of it.<br>&gt;&gt; <br>&gt;&gt; We have a case for it in the standard library, &#39;protocol AnyCollectionType&#39;.  Foundation also has a use case -- property list types.<br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt; <br>&gt; - protocols starting with an underscore (_ArrayBufferType, _IntegerType, etc) would benefit from the ?sealed? modifier, because the contract right now only implicitly says: ?public but please don?t use?.<br>&gt; - another use case is grouping a set of types regardless their origin and limit the ability to extend the provided number of types by external forces<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/791855cc/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Sealed protocols</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  3, 2015 at 03:00:00pm</p></header><div class="content"><p>An alternative that would have the same effect is to allow protocols to<br>require conformance to other protocols with a lesser visibility. Because<br>no external type could conform to the private/internal protocol<br>requirement, they can&#39;t declare conformance to the public protocol<br>either. The only way they could conform is if the library adds<br>conformance to the private protocol to some public class, and then<br>external code can conform to the public protocol in subclasses, which<br>seems like a potentially-desirable thing (just yesterday someone asked<br>on IRC if there was a way to declare a protocol that could only be<br>conformed-to by UIViewController subclasses).<br></p><p>This would look something like<br></p><p>private protocol Restricted {}<br></p><p>public protocol SealedProto: Restricted {<br>    // ...<br>}<br></p><p>The best part about this proposal is it doesn&#39;t require adding any new<br>syntax or rules to the language, it only requires relaxing the rule that<br>says a protocol cannot require conformance to another protocol of lesser<br>visibility.<br></p><p>-Kevin Ballard<br></p><p>On Thu, Dec 3, 2015, at 02:59 PM, Felix Gabel wrote:<br>&gt; Hey everyone,<br>&gt; <br>&gt; I hereby propose adding a ?sealed? modifier for protocols to enable<br>&gt; library developers to declare protocols that can be only conformed to in<br>&gt; the scope of the library itself. This is similar to a ?sealed trait? in<br>&gt; Scala with the difference that it does not limit the protocol to be only<br>&gt; applicable in the file it is declared in.<br>&gt; <br>&gt; Example:<br>&gt; <br>&gt; public sealed protocol FooType {<br>&gt;     // this protocol can be conformed to only in scope of the library<br>&gt;     itself<br>&gt;     // it can NOT be conformed to by any object declared outside the<br>&gt;     library<br>&gt; }<br>&gt; <br>&gt; What do you think?<br>&gt; <br>&gt; Thank you for your time,<br>&gt; Felix<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Sealed protocols</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  3, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 3, 2015, at 2:59 PM, Felix Gabel &lt;felix.gabel at me.com&gt; wrote:<br>&gt; <br>&gt; Hey everyone,<br>&gt; <br>&gt; I hereby propose adding a ?sealed? modifier for protocols to enable library developers to declare protocols that can be only conformed to in the scope of the library itself. This is similar to a ?sealed trait? in Scala with the difference that it does not limit the protocol to be only applicable in the file it is declared in.<br>&gt; <br>&gt; Example:<br>&gt; <br>&gt; public sealed protocol FooType {<br>&gt;    // this protocol can be conformed to only in scope of the library itself<br>&gt;    // it can NOT be conformed to by any object declared outside the library<br>&gt; }<br>&gt; <br>&gt; What do you think?<br></p><p>My first reaction is that enums already provide a way to model closed sum types. Enums do have some syntactic disadvantages compared to protocol types, since there&#39;s no automatic subtyping with enums like there are with protocols, but it might be worth considering ways we can improve that rather than adding redundant language features.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c68458ef31619f30cfc2b4ebbc17c4f6?s=50"></div><header><strong>Proposal: Sealed protocols</strong> from <string>Felix Gabel</string> &lt;felix.gabel at me.com&gt;<p>December  4, 2015 at 01:00:00am</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 12:13 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 3, 2015, at 2:59 PM, Felix Gabel &lt;felix.gabel at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey everyone,<br>&gt;&gt; <br>&gt;&gt; I hereby propose adding a ?sealed? modifier for protocols to enable library developers to declare protocols that can be only conformed to in the scope of the library itself. This is similar to a ?sealed trait? in Scala with the difference that it does not limit the protocol to be only applicable in the file it is declared in.<br>&gt;&gt; <br>&gt;&gt; Example:<br>&gt;&gt; <br>&gt;&gt; public sealed protocol FooType {<br>&gt;&gt;   // this protocol can be conformed to only in scope of the library itself<br>&gt;&gt;   // it can NOT be conformed to by any object declared outside the library<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; What do you think?<br>&gt; <br>&gt; My first reaction is that enums already provide a way to model closed sum types. Enums do have some syntactic disadvantages compared to protocol types, since there&#39;s no automatic subtyping with enums like there are with protocols, but it might be worth considering ways we can improve that rather than adding redundant language features.<br>&gt; <br>&gt; -Joe<br></p><p>The problem using an enum in this case is that the overall complexity will increase with every case that is being introduced. Using a sealed protocol a library developer can define a set of conforming types, that is applicable for usage.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/30a77aa0/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
