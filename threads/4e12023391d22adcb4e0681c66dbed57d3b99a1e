<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June 22, 2016 at 05:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;SE-0104: Protocol-oriented integers&quot; begins now and runs through June 27. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 22, 2016 at 08:00:00pm</p></header><div class="content"><p>On Wed, Jun 22, 2016 at 7:52 PM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;SE-0104: Protocol-oriented integers&quot; begins now and runs<br>&gt; through June 27. The proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br>&gt;<br></p><p>This is excellent, and a huge improvement. Two questions and one ask:<br></p><p>Q1: With the adoption of this proposal, will FloatingPoint conform to<br>Arithmetic?<br>Q2: I do not understand the comment explaining signBitIndex. I thought I<br>understood what it does from the name, but the comment says it&#39;s not the<br>right name. So what is signBitIndex?<br>Ask: You&#39;ve got bitWidth and nthWord. Any way you could expose<br>__builtin_popcount()? Pretty please?<br></p><p><br>&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;<br></p><p>Yes, the current tangle of protocols is not exactly fun to work with for<br>generics.<br></p><p><br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br></p><p>Yes.<br></p><p><br>&gt;         * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;<br></p><p>Not applicable, I think.<br></p><p><br>&gt;         * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br></p><p>Read the proposal, worked with the existing protocols, thought carefully<br>about numbers in the context of the FloatingPoint discussion.<br></p><p><br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/717c983c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c53218a6524f4d644b6a75a4441ea631?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Max Moiseev</string> &lt;moiseev at apple.com&gt;<p>June 23, 2016 at 11:00:00am</p></header><div class="content"><p>Hi Xiaodi,<br></p><p>&gt; Q2: I do not understand the comment explaining signBitIndex. I thought I understood what it does from the name, but the comment says it&#39;s not the right name. So what is signBitIndex?<br></p><p>The name is good but the way it is implemented in the prototype currently is NOT what the name suggests. This is the point of the comment. I plan to revisit the prototype and either make it behave the way it’s called, or find a better name for what it currently does.<br></p><p>&gt; Ask: You&#39;ve got bitWidth and nthWord. Any way you could expose __builtin_popcount()? Pretty please?<br>I don’t mind adding it to the concrete types, similar to `countLeadingZeros` (see https://github.com/apple/swift/blob/master/test/Prototypes/Integers.swift.gyb#L855). Do you think it should be a protocol requirement instead?<br></p><p><br>Max<br></p><p><br>&gt; On Jun 22, 2016, at 6:13 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 22, 2016 at 7:52 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0104: Protocol-oriented integers&quot; begins now and runs through June 27. The proposal is available here:<br>&gt; <br>&gt;         https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md&gt;<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt;         * What is your evaluation of the proposal?<br>&gt; <br>&gt; This is excellent, and a huge improvement. Two questions and one ask:<br>&gt; <br>&gt; Q1: With the adoption of this proposal, will FloatingPoint conform to Arithmetic?<br>&gt; Q2: I do not understand the comment explaining signBitIndex. I thought I understood what it does from the name, but the comment says it&#39;s not the right name. So what is signBitIndex?<br>&gt; Ask: You&#39;ve got bitWidth and nthWord. Any way you could expose __builtin_popcount()? Pretty please?<br>&gt;  <br>&gt;         * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes, the current tangle of protocols is not exactly fun to work with for generics.<br>&gt;  <br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Yes.<br>&gt;  <br>&gt;         * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; Not applicable, I think.<br>&gt;  <br>&gt;         * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; Read the proposal, worked with the existing protocols, thought carefully about numbers in the context of the FloatingPoint discussion.<br>&gt; <br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/133b484e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 23, 2016 at 03:00:00pm</p></header><div class="content"><p>On Thu, Jun 23, 2016 at 1:56 PM, Max Moiseev &lt;moiseev at apple.com&gt; wrote:<br></p><p>&gt; Hi Xiaodi,<br>&gt;<br>&gt; Q2: I do not understand the comment explaining signBitIndex. I thought I<br>&gt; understood what it does from the name, but the comment says it&#39;s not the<br>&gt; right name. So what is signBitIndex?<br>&gt;<br>&gt; The name is good but the way it is implemented in the prototype currently<br>&gt; is NOT what the name suggests. This is the point of the comment. I plan to<br>&gt; revisit the prototype and either make it behave the way it’s called, or<br>&gt; find a better name for what it currently does.<br>&gt;<br>&gt; Ask: You&#39;ve got bitWidth and nthWord. Any way you could expose<br>&gt; __builtin_popcount()? Pretty please?<br>&gt;<br>&gt; I don’t mind adding it to the concrete types, similar to<br>&gt; `countLeadingZeros` (see<br>&gt; https://github.com/apple/swift/blob/master/test/Prototypes/Integers.swift.gyb#L855).<br>&gt; Do you think it should be a protocol requirement instead?<br>&gt;<br></p><p>You&#39;re right, probably best belongs on concrete types.<br></p><p><br>&gt;<br>&gt;<br>&gt; Max<br>&gt;<br>&gt;<br>&gt; On Jun 22, 2016, at 6:13 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Wed, Jun 22, 2016 at 7:52 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hello Swift community,<br>&gt;&gt;<br>&gt;&gt; The review of &quot;SE-0104: Protocol-oriented integers&quot; begins now and runs<br>&gt;&gt; through June 27. The proposal is available here:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md<br>&gt;&gt;<br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;<br>&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt; review manager.<br>&gt;&gt;<br>&gt;&gt; What goes into a review?<br>&gt;&gt;<br>&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt; in your review:<br>&gt;&gt;<br>&gt;&gt;         * What is your evaluation of the proposal?<br>&gt;&gt;<br>&gt;<br>&gt; This is excellent, and a huge improvement. Two questions and one ask:<br>&gt;<br>&gt; Q1: With the adoption of this proposal, will FloatingPoint conform to<br>&gt; Arithmetic?<br>&gt; Q2: I do not understand the comment explaining signBitIndex. I thought I<br>&gt; understood what it does from the name, but the comment says it&#39;s not the<br>&gt; right name. So what is signBitIndex?<br>&gt; Ask: You&#39;ve got bitWidth and nthWord. Any way you could expose<br>&gt; __builtin_popcount()? Pretty please?<br>&gt;<br>&gt;<br>&gt;&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt;&gt; change to Swift?<br>&gt;&gt;<br>&gt;<br>&gt; Yes, the current tangle of protocols is not exactly fun to work with for<br>&gt; generics.<br>&gt;<br>&gt;<br>&gt;&gt;         * Does this proposal fit well with the feel and direction of<br>&gt;&gt; Swift?<br>&gt;&gt;<br>&gt;<br>&gt; Yes.<br>&gt;<br>&gt;<br>&gt;&gt;         * If you have used other languages or libraries with a similar<br>&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt;&gt;<br>&gt;<br>&gt; Not applicable, I think.<br>&gt;<br>&gt;<br>&gt;&gt;         * How much effort did you put into your review? A glance, a<br>&gt;&gt; quick reading, or an in-depth study?<br>&gt;&gt;<br>&gt;<br>&gt; Read the proposal, worked with the existing protocols, thought carefully<br>&gt; about numbers in the context of the FloatingPoint discussion.<br>&gt;<br>&gt;<br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;<br>&gt;&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;<br>&gt;&gt; Thank you,<br>&gt;&gt;<br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/b92f4515/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 29, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt;         https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md<br></p><p>Minor omission I noticed: `Integer` doesn&#39;t formally model the `init?(_: String, radix: Int)` initializer. If it did, we could provide an `init?(_: String)` initializer that called through to it. We might even be able to take the existing string-to-integer logic, which I believe is duplicated for each type through GYB, and share it in an extension so no Integer needs to write its own conversion. Is that something that should be added?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>June 23, 2016 at 03:00:00am</p></header><div class="content"><p>+1<br></p><p>Looks very good. A couple of points:<br></p><p>- I’m not convinced about ‘absoluteValue’, with an associated type. I think it should return the same value as ‘abs()’ or have a different name if it’s really needed at all; the example of a print function is a bit weak IMO.<br>- I’m not sure about an ‘nthWord()’ getter without a corresponding setter.<br>- I would like ‘floor’ and ‘ceil’ to be part of the standard library (or some equivalent). It annoys me that I have to import Darwin/Glibc to properly convert between standard library types. Would this go with the initialisers from FloatingPoint on Integer, or somewhere on FloatingPoint?<br></p><p>Definitely a step up from what we have, and a good foundation to build on.<br></p><p>Karl<br></p><p>&gt; On 23 Jun 2016, at 02:52, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0104: Protocol-oriented integers&quot; begins now and runs through June 27. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>June 22, 2016 at 09:00:00pm</p></header><div class="content"><p>Karl - Absolute value of `Int.min` is currently not representable by an<br>Int.<br></p><p>On Wed, Jun 22, 2016 at 9:32 PM, Karl via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1<br>&gt;<br>&gt; Looks very good. A couple of points:<br>&gt;<br>&gt; - I’m not convinced about ‘absoluteValue’, with an associated type. I<br>&gt; think it should return the same value as ‘abs()’ or have a different name<br>&gt; if it’s really needed at all; the example of a print function is a bit weak<br>&gt; IMO.<br>&gt; - I’m not sure about an ‘nthWord()’ getter without a corresponding setter.<br>&gt; - I would like ‘floor’ and ‘ceil’ to be part of the standard library (or<br>&gt; some equivalent). It annoys me that I have to import Darwin/Glibc to<br>&gt; properly convert between standard library types. Would this go with the<br>&gt; initialisers from FloatingPoint on Integer, or somewhere on FloatingPoint?<br>&gt;<br>&gt; Definitely a step up from what we have, and a good foundation to build on.<br>&gt;<br>&gt; Karl<br>&gt;<br>&gt; &gt; On 23 Jun 2016, at 02:52, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello Swift community,<br>&gt; &gt;<br>&gt; &gt; The review of &quot;SE-0104: Protocol-oriented integers&quot; begins now and runs<br>&gt; through June 27. The proposal is available here:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md<br>&gt; &gt;<br>&gt; &gt; Reviews are an important part of the Swift evolution process. All<br>&gt; reviews should be sent to the swift-evolution mailing list at<br>&gt; &gt;<br>&gt; &gt;       https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt; &gt;<br>&gt; &gt; What goes into a review?<br>&gt; &gt;<br>&gt; &gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt; &gt;<br>&gt; &gt;       * What is your evaluation of the proposal?<br>&gt; &gt;       * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt; &gt;       * Does this proposal fit well with the feel and direction of Swift?<br>&gt; &gt;       * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt; &gt;       * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt; &gt;<br>&gt; &gt; More information about the Swift evolution process is available at<br>&gt; &gt;<br>&gt; &gt;       https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; &gt;<br>&gt; &gt; Thank you,<br>&gt; &gt;<br>&gt; &gt; -Chris Lattner<br>&gt; &gt; Review Manager<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/14570998/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>June 22, 2016 at 10:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Jun 22, 2016, at 9:32 PM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I would like ‘floor’ and ‘ceil’ to be part of the standard library (or some equivalent). It annoys me that I have to import Darwin/Glibc to properly convert between standard library types. Would this go with the initialisers from FloatingPoint on Integer, or somewhere on FloatingPoint?<br></p><p>These should simply be added to FloatingPoint.  I&#39;ll write a tiny proposal for that.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 22, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>This looks really great!  Thank you team for all of your hard work on improving the numeric protocols in Swift 3.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.  The current protocols leave a lot of room for improvement, which we see in this proposal.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes very much so.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I have not.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I read the proposal when a draft was available and again tonight.  I have also encountered some of the challenges described with the existing protocols.<br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>June 22, 2016 at 11:00:00pm</p></header><div class="content"><p>In addition to the technical review, I would like to point out that the definition of Arithmetic appears to be missing some underscores in add/adding/subtract/subtracting<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>I’m so glad this work is being done!<br></p><p>For Integer, does the presence of signBit indicate an expectation that signed Integers will have a two&#39;s complement representation?<br></p><p>For FixedWidthInteger#dividedWithOverflow/remainderWithOverflow, under what situations would you have an overflow? I could only come up with something like Int.min.dividedWithOverflow(-1).<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes, oh yes.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>It looks like a significant improvement. <br></p><p>&gt; <br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I combed the proposal for questions, although most were answered by the time I hit the end.<br></p><p>-DW<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>June 22, 2016 at 11:00:00pm</p></header><div class="content"><p>Do we lose the ability to create a signed integer from an unsigned bit pattern?<br></p><p>Is there a way to get an optional initializer that returns `nil` if the operand can&#39;t be represented?<br></p><p>What is the cost of heterogeneous comparison?<br></p><p>Félix<br></p><p>&gt; Le 22 juin 2016 à 22:42:00, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; In addition to the technical review, I would like to point out that the definition of Arithmetic appears to be missing some underscores in add/adding/subtract/subtracting<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md<br>&gt;&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; I’m so glad this work is being done!<br>&gt; <br>&gt; For Integer, does the presence of signBit indicate an expectation that signed Integers will have a two&#39;s complement representation?<br>&gt; <br>&gt; For FixedWidthInteger#dividedWithOverflow/remainderWithOverflow, under what situations would you have an overflow? I could only come up with something like Int.min.dividedWithOverflow(-1).<br>&gt; <br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes, oh yes.<br>&gt; <br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; It looks like a significant improvement. <br>&gt; <br>&gt;&gt; <br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I combed the proposal for questions, although most were answered by the time I hit the end.<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b85275a7eb50a13a925d4ce05bb5daf7?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Remy Demarest</string> &lt;psycho.hedgehog at me.com&gt;<p>June 23, 2016 at 09:00:00am</p></header><div class="content"><p>I would also like to know why bit shifting and bit-wise and, or and xor operations are limited to FixedWidthInteger. I would think that a variable-length integer would be able to handle these operations in a predictable way consistent with the protocol. Wouldn&#39;t it?<br></p><p>&gt; Le 22 juin 2016 à 23:23, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Do we lose the ability to create a signed integer from an unsigned bit pattern?<br>&gt; <br>&gt; Is there a way to get an optional initializer that returns `nil` if the operand can&#39;t be represented?<br>&gt; <br>&gt; What is the cost of heterogeneous comparison?<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 22 juin 2016 à 22:42:00, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; In addition to the technical review, I would like to point out that the definition of Arithmetic appears to be missing some underscores in add/adding/subtract/subtracting<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; I’m so glad this work is being done!<br>&gt;&gt; <br>&gt;&gt; For Integer, does the presence of signBit indicate an expectation that signed Integers will have a two&#39;s complement representation?<br>&gt;&gt; <br>&gt;&gt; For FixedWidthInteger#dividedWithOverflow/remainderWithOverflow, under what situations would you have an overflow? I could only come up with something like Int.min.dividedWithOverflow(-1).<br>&gt;&gt; <br>&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; <br>&gt;&gt; Yes, oh yes.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; It looks like a significant improvement. <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; I combed the proposal for questions, although most were answered by the time I hit the end.<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>June 23, 2016 at 05:00:00pm</p></header><div class="content"><p>Big step forward, no longer have to do this :<br>https://gist.github.com/jcampbell05/f6b5611bd7f61840edb10500fa69fd09<br></p><p>*___________________________________*<br></p><p>*James⎥Head of Trolls*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On 23 June 2016 at 17:08, Remy Demarest via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I would also like to know why bit shifting and bit-wise and, or and xor<br>&gt; operations are limited to FixedWidthInteger. I would think that a<br>&gt; variable-length integer would be able to handle these operations in a<br>&gt; predictable way consistent with the protocol. Wouldn&#39;t it?<br>&gt;<br>&gt; &gt; Le 22 juin 2016 à 23:23, Félix Cloutier via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt; &gt;<br>&gt; &gt; Do we lose the ability to create a signed integer from an unsigned bit<br>&gt; pattern?<br>&gt; &gt;<br>&gt; &gt; Is there a way to get an optional initializer that returns `nil` if the<br>&gt; operand can&#39;t be represented?<br>&gt; &gt;<br>&gt; &gt; What is the cost of heterogeneous comparison?<br>&gt; &gt;<br>&gt; &gt; Félix<br>&gt; &gt;<br>&gt; &gt;&gt; Le 22 juin 2016 à 22:42:00, David Waite via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; In addition to the technical review, I would like to point out that the<br>&gt; definition of Arithmetic appears to be missing some underscores in<br>&gt; add/adding/subtract/subtracting<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;     * What is your evaluation of the proposal?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I’m so glad this work is being done!<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; For Integer, does the presence of signBit indicate an expectation that<br>&gt; signed Integers will have a two&#39;s complement representation?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; For FixedWidthInteger#dividedWithOverflow/remainderWithOverflow, under<br>&gt; what situations would you have an overflow? I could only come up with<br>&gt; something like Int.min.dividedWithOverflow(-1).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;     * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Yes, oh yes.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;     * Does this proposal fit well with the feel and direction of Swift?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; It looks like a significant improvement.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;     * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I combed the proposal for questions, although most were answered by the<br>&gt; time I hit the end.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -DW<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/1cc64aa3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c53218a6524f4d644b6a75a4441ea631?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Max Moiseev</string> &lt;moiseev at apple.com&gt;<p>June 23, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi Remy,<br></p><p>&gt; I would also like to know why bit shifting and bit-wise and, or and xor operations are limited to FixedWidthInteger. I would think that a variable-length integer would be able to handle these operations in a predictable way consistent with the protocol. Wouldn&#39;t it?<br></p><p>The problem is that with fixed-width, the values will eventually &quot;fall off the cliff” when shifted left, but with the arbitrary-precision integers we can simply grow the underlying storage so that “the cliff” is never reached.<br></p><p>Which means that in generic context, when all you have is some T that conforms to Integer, you won’t be able to tell what will happen exactly.<br></p><p>Pretty much the same argument applies to the bitwise operations: since 2 bignums might have different widths of the underlying storage, the semantics of those operations is not exactly the same as for the fixed width types. Does it make sense?<br></p><p><br>Max<br></p><p>&gt; On Jun 23, 2016, at 9:08 AM, Remy Demarest via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I would also like to know why bit shifting and bit-wise and, or and xor operations are limited to FixedWidthInteger. I would think that a variable-length integer would be able to handle these operations in a predictable way consistent with the protocol. Wouldn&#39;t it?<br>&gt; <br>&gt;&gt; Le 22 juin 2016 à 23:23, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Do we lose the ability to create a signed integer from an unsigned bit pattern?<br>&gt;&gt; <br>&gt;&gt; Is there a way to get an optional initializer that returns `nil` if the operand can&#39;t be represented?<br>&gt;&gt; <br>&gt;&gt; What is the cost of heterogeneous comparison?<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 22 juin 2016 à 22:42:00, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In addition to the technical review, I would like to point out that the definition of Arithmetic appears to be missing some underscores in add/adding/subtract/subtracting<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m so glad this work is being done!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For Integer, does the presence of signBit indicate an expectation that signed Integers will have a two&#39;s complement representation?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For FixedWidthInteger#dividedWithOverflow/remainderWithOverflow, under what situations would you have an overflow? I could only come up with something like Int.min.dividedWithOverflow(-1).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, oh yes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It looks like a significant improvement. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I combed the proposal for questions, although most were answered by the time I hit the end.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -DW<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>June 23, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 2:23 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What is the cost of heterogeneous comparison?<br></p><p>Smaller-than-wordsize comparisons will fall out for free in most cases.  For word size and larger types, there’s one extra test in some cases, but the (very small) added cost is vastly preferable to people rolling their own workarounds and getting it wrong.<br></p><p>– Steve<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>June 23, 2016 at 12:00:00pm</p></header><div class="content"><p>On Jun 23, 2016, at 2:23 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Do we lose the ability to create a signed integer from an unsigned bit pattern?<br></p><p>The existing `init(bitPattern x: UIntN)` are still present on the concrete types in the prototype.  There’s a new init at the Protocol level that handles the fully generic case:<br></p><p>/// Creates in instance of `Self` from `source` by sign-extending it<br>/// indefinitely and then truncating to fit `Self`.<br>init&lt;T : Integer&gt;(extendingOrTruncating source: T)<br></p><p>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/72c127c1/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>June 23, 2016 at 12:00:00pm</p></header><div class="content"><p>On Jun 23, 2016, at 2:23 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Is there a way to get an optional initializer that returns `nil` if the operand can&#39;t be represented?<br></p><p>That’s in the Arithmetic Protocol in the proposal:<br></p><p>/// Initializes to the value of `source` if it is representable exactly,<br>/// returns `nil` otherwise.<br>init?&lt;T : Integer&gt;(exactly source: T)<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/5bf8ff4c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c53218a6524f4d644b6a75a4441ea631?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Max Moiseev</string> &lt;moiseev at apple.com&gt;<p>June 23, 2016 at 11:00:00am</p></header><div class="content"><p>Hi Félix,<br></p><p>&gt; Do we lose the ability to create a signed integer from an unsigned bit pattern?<br></p><p>As I mentioned in one of the earlier replies, the proposal does not contain the full API diff.<br>`init(bitPattern:)` is very useful and will remain.<br></p><p>However, I don’t think it should be added to any of the protocols. Mostly because in order to do so we would need to introduce another associated type — for the signed/unsigned counterpart with the same width.<br>Can you think of an example where this feature would be useful in the generic code?<br></p><p>Max<br></p><p>&gt; On Jun 22, 2016, at 11:23 PM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Do we lose the ability to create a signed integer from an unsigned bit pattern?<br>&gt; <br>&gt; Is there a way to get an optional initializer that returns `nil` if the operand can&#39;t be represented?<br>&gt; <br>&gt; What is the cost of heterogeneous comparison?<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 22 juin 2016 à 22:42:00, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; In addition to the technical review, I would like to point out that the definition of Arithmetic appears to be missing some underscores in add/adding/subtract/subtracting<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; I’m so glad this work is being done!<br>&gt;&gt; <br>&gt;&gt; For Integer, does the presence of signBit indicate an expectation that signed Integers will have a two&#39;s complement representation?<br>&gt;&gt; <br>&gt;&gt; For FixedWidthInteger#dividedWithOverflow/remainderWithOverflow, under what situations would you have an overflow? I could only come up with something like Int.min.dividedWithOverflow(-1).<br>&gt;&gt; <br>&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; <br>&gt;&gt; Yes, oh yes.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; It looks like a significant improvement. <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; I combed the proposal for questions, although most were answered by the time I hit the end.<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c53218a6524f4d644b6a75a4441ea631?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Max Moiseev</string> &lt;moiseev at apple.com&gt;<p>June 23, 2016 at 11:00:00am</p></header><div class="content"><p>Hi David,<br></p><p>&gt; In addition to the technical review, I would like to point out that the definition of Arithmetic appears to be missing some underscores in add/adding/subtract/subtracting<br></p><p>Thank you! I’ll fix it.<br></p><p>&gt; For Integer, does the presence of signBit indicate an expectation that signed Integers will have a two&#39;s complement representation?<br>Yes. That is correct.<br></p><p>&gt; For FixedWidthInteger#dividedWithOverflow/remainderWithOverflow, under what situations would you have an overflow? I could only come up with something like Int.min.dividedWithOverflow(-1).<br>If you look at the prototype here: https://github.com/apple/swift/blob/master/test/Prototypes/Integers.swift.gyb#L789 there is exactly the check that you’ve mentioned, but for all signed integers. Besides, it is very convenient to have all the arithmetic operations be implemented the same way, even if there were no real overflows for division.<br></p><p>Max<br></p><p><br>&gt; On Jun 22, 2016, at 10:42 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In addition to the technical review, I would like to point out that the definition of Arithmetic appears to be missing some underscores in add/adding/subtract/subtracting<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md<br>&gt;&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; I’m so glad this work is being done!<br>&gt; <br>&gt; For Integer, does the presence of signBit indicate an expectation that signed Integers will have a two&#39;s complement representation?<br>&gt; <br>&gt; For FixedWidthInteger#dividedWithOverflow/remainderWithOverflow, under what situations would you have an overflow? I could only come up with something like Int.min.dividedWithOverflow(-1).<br>&gt; <br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes, oh yes.<br>&gt; <br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; It looks like a significant improvement. <br>&gt; <br>&gt;&gt; <br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I combed the proposal for questions, although most were answered by the time I hit the end.<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 23, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1 The protocols are well thought out and make total sense to me. I only have a miner gripe with the naming of:<br></p><p>func nthWord(n: Int) -&gt; UInt<br></p><p>Which reads very weird. Why not:<br></p><p>func word(at: Int) -&gt; UInt<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes, generic algorithms using integers were difficult to write. This is definitely needed for Swift 3.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>It follows the logic behind the floating-point protocols.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>No.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A good read.<br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/f2f1f12e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0104: Protocol-oriented integers</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 23, 2016 at 01:00:00pm</p></header><div class="content"><p>Hey, standard library folks. Glad we&#39;re doing this one. :-)<br></p><p>- I remain unconvinced that defining an Arithmetic that includes both exact and floating-point numbers is a good idea. All of the arguments from Swift 1 and 2 about why we didn&#39;t include this still seem relevant. To phrase it in generic programming terms, what algorithm would be generic over Arithmetic?<br></p><p><br>- What is Integer.init&lt;T: FloatingPoint&gt;(_:) supposed to do if the floating-point value is larger than the maximum representable integer? Smaller than the minimum? (As a special case, negative, when the integer type is unsigned?) Infinity? NaN?<br></p><p>- Integer.init&lt;T: Integer&gt;(_:) currently says &quot;if it is representable&quot;. It should say something like &quot;trapping if it is not representable&quot;.<br></p><p>- I find it odd that Integer.init(clamping:) privileges the bounds of fixed-width integers. I was going to suggest it should take a range to clamp to that defaults to the min and max, but that&#39;s not implementable for a BigInt.<br></p><p>- nthWord should count &quot;from least-significant to most-significant&quot; rather than &quot;from the right&quot;.<br></p><p>- As mentioned before, it sounds like Integer requires a two&#39;s complement representation (if only so the result of nthWord can be interpreted correctly). That should probably be in the doc comment for the protocol.<br></p><p>- Why is bitWidth in bits but nthWord in words? (I know there&#39;s a good answer to this, but using them together seems like it will be common.)<br></p><p>- It&#39;s also probably worth calling out even more explicitly that bitWidth is a representation property, not a value property. That is, a BigInt with the value &quot;1&quot; could have a bitWidth of 1, 8, or 128.<br></p><p>- What does signBitIndex return if self is positive? I ask because it&#39;s just not in the doc comment, but thinking about the answer made it obvious that the correct return value for 0 is 0.<br></p><p>- For signed integers, does remainder(dividingBy:) have specified behavior for the sign of the result? See https://en.wikipedia.org/wiki/Modulo_operation.<br></p><p>- I do think having Swift.abs(_:) and Integer.absoluteValue is confusing, but I don&#39;t know what to do about it.<br></p><p><br>- Why are bitwise operations limited to fixed-width integers? I see &quot;The only difference is that because shifting left truncates the high bits of fixed-width integers, it is hard to define what a left shift would mean to an arbitrary-precision integer&quot; further down, but I would just assume it wouldn&#39;t truncate (i.e. it would be a pure multiplication by two).<br></p><p>- Is there a requirement about left-shifting into the sign bit, for &#39;&lt;&lt;&#39; and for &#39;&amp;&lt;&lt;&#39;?<br></p><p>- What is the ArithmeticOverflow type?<br></p><p>- When does the remainder operation overflow? (I just can&#39;t remember.)<br></p><p>- I feel a little weird having &quot;someValue.and(mask)&quot;. Maybe bitwiseAnd or bitwiseAND to be more explicit?<br></p><p>- maskingShiftLeft/Right seem underspecified in their doc comments. Why can&#39;t the protocol requirement just assume the shift amount has already been masked, instead of performing the masking themselves? Is it because we won&#39;t be able to optimize that away?<br></p><p>I think that&#39;s about it. Great work, all!<br>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/30ffbf62/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0104: Protocol-oriented integers</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 23, 2016 at 02:00:00pm</p></header><div class="content"><p>Oh, one more comment: I suggest naming the primary protocol something other than &quot;Integer&quot;, which IMHO is a little close to &quot;Int&quot; for a beginner. &quot;Integral&quot; is a bit too ambiguous, but maybe &quot;IntegerArithmetic&quot; or &quot;ArithmeticInteger&quot;? Or to go with the representation thing, &quot;BinaryInteger&quot;? (Some of the requirements are at odds with a decimal-based implementation.)<br></p><p>Jordan<br></p><p><br>&gt; On Jun 23, 2016, at 13:50, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; Hey, standard library folks. Glad we&#39;re doing this one. :-)<br>&gt; <br>&gt; - I remain unconvinced that defining an Arithmetic that includes both exact and floating-point numbers is a good idea. All of the arguments from Swift 1 and 2 about why we didn&#39;t include this still seem relevant. To phrase it in generic programming terms, what algorithm would be generic over Arithmetic?<br>&gt; <br>&gt; <br>&gt; - What is Integer.init&lt;T: FloatingPoint&gt;(_:) supposed to do if the floating-point value is larger than the maximum representable integer? Smaller than the minimum? (As a special case, negative, when the integer type is unsigned?) Infinity? NaN?<br>&gt; <br>&gt; - Integer.init&lt;T: Integer&gt;(_:) currently says &quot;if it is representable&quot;. It should say something like &quot;trapping if it is not representable&quot;.<br>&gt; <br>&gt; - I find it odd that Integer.init(clamping:) privileges the bounds of fixed-width integers. I was going to suggest it should take a range to clamp to that defaults to the min and max, but that&#39;s not implementable for a BigInt.<br>&gt; <br>&gt; - nthWord should count &quot;from least-significant to most-significant&quot; rather than &quot;from the right&quot;.<br>&gt; <br>&gt; - As mentioned before, it sounds like Integer requires a two&#39;s complement representation (if only so the result of nthWord can be interpreted correctly). That should probably be in the doc comment for the protocol.<br>&gt; <br>&gt; - Why is bitWidth in bits but nthWord in words? (I know there&#39;s a good answer to this, but using them together seems like it will be common.)<br>&gt; <br>&gt; - It&#39;s also probably worth calling out even more explicitly that bitWidth is a representation property, not a value property. That is, a BigInt with the value &quot;1&quot; could have a bitWidth of 1, 8, or 128.<br>&gt; <br>&gt; - What does signBitIndex return if self is positive? I ask because it&#39;s just not in the doc comment, but thinking about the answer made it obvious that the correct return value for 0 is 0.<br>&gt; <br>&gt; - For signed integers, does remainder(dividingBy:) have specified behavior for the sign of the result? See https://en.wikipedia.org/wiki/Modulo_operation &lt;https://en.wikipedia.org/wiki/Modulo_operation&gt;.<br>&gt; <br>&gt; - I do think having Swift.abs(_:) and Integer.absoluteValue is confusing, but I don&#39;t know what to do about it.<br>&gt; <br>&gt; <br>&gt; - Why are bitwise operations limited to fixed-width integers? I see &quot;The only difference is that because shifting left truncates the high bits of fixed-width integers, it is hard to define what a left shift would mean to an arbitrary-precision integer&quot; further down, but I would just assume it wouldn&#39;t truncate (i.e. it would be a pure multiplication by two).<br>&gt; <br>&gt; - Is there a requirement about left-shifting into the sign bit, for &#39;&lt;&lt;&#39; and for &#39;&amp;&lt;&lt;&#39;?<br>&gt; <br>&gt; - What is the ArithmeticOverflow type?<br>&gt; <br>&gt; - When does the remainder operation overflow? (I just can&#39;t remember.)<br>&gt; <br>&gt; - I feel a little weird having &quot;someValue.and(mask)&quot;. Maybe bitwiseAnd or bitwiseAND to be more explicit?<br>&gt; <br>&gt; - maskingShiftLeft/Right seem underspecified in their doc comments. Why can&#39;t the protocol requirement just assume the shift amount has already been masked, instead of performing the masking themselves? Is it because we won&#39;t be able to optimize that away?<br>&gt; <br>&gt; I think that&#39;s about it. Great work, all!<br>&gt; Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/aa24a822/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0104: Protocol-oriented integers</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>June 24, 2016 at 08:00:00am</p></header><div class="content"><p>&gt;<br>&gt; - I remain unconvinced that defining an Arithmetic that includes both<br>&gt; exact and floating-point numbers is a good idea. All of the arguments from<br>&gt; Swift 1 and 2 about why we didn&#39;t include this still seem relevant. To<br>&gt; phrase it in generic programming terms, what algorithm would be generic<br>&gt; over Arithmetic?<br>&gt;<br></p><p>E.g. generic point/size/rect types.<br></p><p>&gt; For Integer, does the presence of signBit indicate an expectation that<br>&gt; signed Integers will have a two&#39;s complement representation?<br>&gt; Yes. That is correct.<br></p><p><br>So would this require a BigInt implementation to be in two&#39;s complement<br>also? Most BigInt implementations use a separate sign I think, not sure if<br>that&#39;s for performance reasons or merely convenience though.<br></p><p><br>On Fri, Jun 24, 2016 at 7:40 AM, Jordan Rose via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Oh, one more comment: I suggest naming the primary protocol something<br>&gt; other than &quot;Integer&quot;, which IMHO is a little close to &quot;Int&quot; for a beginner.<br>&gt; &quot;Integral&quot; is a bit too ambiguous, but maybe &quot;IntegerArithmetic&quot; or<br>&gt; &quot;ArithmeticInteger&quot;? Or to go with the representation thing,<br>&gt; &quot;BinaryInteger&quot;? (Some of the requirements are at odds with a decimal-based<br>&gt; implementation.)<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On Jun 23, 2016, at 13:50, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;<br>&gt; Hey, standard library folks. Glad we&#39;re doing this one. :-)<br>&gt;<br>&gt; - I remain unconvinced that defining an Arithmetic that includes both<br>&gt; exact and floating-point numbers is a good idea. All of the arguments from<br>&gt; Swift 1 and 2 about why we didn&#39;t include this still seem relevant. To<br>&gt; phrase it in generic programming terms, what algorithm would be generic<br>&gt; over Arithmetic?<br>&gt;<br>&gt;<br>&gt; - What is Integer.init&lt;T: FloatingPoint&gt;(_:) supposed to do if the<br>&gt; floating-point value is larger than the maximum representable integer?<br>&gt; Smaller than the minimum? (As a special case, negative, when the integer<br>&gt; type is unsigned?) Infinity? NaN?<br>&gt;<br>&gt; - Integer.init&lt;T: Integer&gt;(_:) currently says &quot;if it is representable&quot;. It<br>&gt; should say something like &quot;trapping if it is not representable&quot;.<br>&gt;<br>&gt; - I find it odd that Integer.init(clamping:) privileges the bounds of<br>&gt; fixed-width integers. I was going to suggest it should take a range to<br>&gt; clamp to that *defaults* to the min and max, but that&#39;s not implementable<br>&gt; for a BigInt.<br>&gt;<br>&gt; - nthWord should count &quot;from least-significant to most-significant&quot; rather<br>&gt; than &quot;from the right&quot;.<br>&gt;<br>&gt; - As mentioned before, it sounds like Integer requires a two&#39;s complement<br>&gt; representation (if only so the result of nthWord can be interpreted<br>&gt; correctly). That should probably be in the doc comment for the protocol.<br>&gt;<br>&gt; - Why is bitWidth in bits but nthWord in words? (I know there&#39;s a good<br>&gt; answer to this, but using them together seems like it will be common.)<br>&gt;<br>&gt; - It&#39;s also probably worth calling out *even more explicitly* that<br>&gt; bitWidth is a *representation* property, not a *value* property. That is,<br>&gt; a BigInt with the value &quot;1&quot; could have a bitWidth of 1, 8, or 128.<br>&gt;<br>&gt; - What does signBitIndex return if self is positive? I ask because it&#39;s<br>&gt; just not in the doc comment, but thinking about the answer made it obvious<br>&gt; that the correct return value for 0 is 0.<br>&gt;<br>&gt; - For signed integers, does remainder(dividingBy:) have specified behavior<br>&gt; for the sign of the result? See<br>&gt; https://en.wikipedia.org/wiki/Modulo_operation.<br>&gt;<br>&gt; - I do think having Swift.abs(_:) and Integer.absoluteValue is confusing,<br>&gt; but I don&#39;t know what to do about it.<br>&gt;<br>&gt;<br>&gt; - Why are bitwise operations limited to fixed-width integers? I see &quot;The<br>&gt; only difference is that because shifting left truncates the high bits of<br>&gt; fixed-width integers, it is hard to define what a left shift would mean to<br>&gt; an arbitrary-precision integer&quot; further down, but I would just assume it<br>&gt; wouldn&#39;t truncate (i.e. it would be a pure multiplication by two).<br>&gt;<br>&gt; - Is there a requirement about left-shifting into the sign bit, for &#39;&lt;&lt;&#39;<br>&gt; and for &#39;&amp;&lt;&lt;&#39;?<br>&gt;<br>&gt; - What is the ArithmeticOverflow type?<br>&gt;<br>&gt; - When does the remainder operation overflow? (I just can&#39;t remember.)<br>&gt;<br>&gt; - I feel a little weird having &quot;someValue.and(mask)&quot;. Maybe bitwiseAnd or<br>&gt; bitwiseAND to be more explicit?<br>&gt;<br>&gt; - maskingShiftLeft/Right seem underspecified in their doc comments. Why<br>&gt; can&#39;t the protocol requirement just assume the shift amount has already<br>&gt; been masked, instead of performing the masking themselves? Is it because we<br>&gt; won&#39;t be able to optimize that away?<br>&gt;<br>&gt; I think that&#39;s about it. Great work, all!<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/941941c7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0104: Protocol-oriented integers</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 23, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 15:19, Patrick Pijnappel &lt;patrickpijnappel at gmail.com&gt; wrote:<br>&gt; <br>&gt; - I remain unconvinced that defining an Arithmetic that includes both exact and floating-point numbers is a good idea. All of the arguments from Swift 1 and 2 about why we didn&#39;t include this still seem relevant. To phrase it in generic programming terms, what algorithm would be generic over Arithmetic?<br>&gt; <br>&gt; E.g. generic point/size/rect types.<br></p><p>Um. I get that there are useful algorithms generic over floating-point vectors, and also useful algorithms generic over integer vectors. I’m still not sure what algorithms are generic over floating-point values (of any arity) and integers (of any arity).<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/7b58547b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c53218a6524f4d644b6a75a4441ea631?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0104: Protocol-oriented integers</strong> from <string>Max Moiseev</string> &lt;moiseev at apple.com&gt;<p>June 23, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; &gt; For Integer, does the presence of signBit indicate an expectation that signed Integers will have a two&#39;s complement representation?<br>&gt; Yes. That is correct.<br>&gt; <br>&gt; So would this require a BigInt implementation to be in two&#39;s complement also? Most BigInt implementations use a separate sign I think, not sure if that&#39;s for performance reasons or merely convenience though.<br></p><p><br>This is a very valid concern. I think I have discovered a truly marvelous solution a way of addressing it:<br></p><p>`signBitIndex` is only used (I’m talking about the prototype now) to determine the absolute required minimum of bits needed to represent the current value of number when converting it to a different type.<br></p><p>So, instead of mentioning the sign bit, let’s call it what it is ‘minimumRequiredWidth’ or something along this line. This move will also allow the default implementation of `minimumRequiredWidth` to simply return `bitWidth` for unsigned numbers and and `bitWidth - 1` for positive signed, etc.<br></p><p>This way bignum implementations don’t have to have any specific underlying representation. They can either inherit the default implementation or implement their own version of `minimumRequiredWidth` in case the `bitWidth` has some extra unused space that is not absolutely required.<br></p><p>I still need to validate this idea, these are just the thoughts. Any comments are more than welcome.<br></p><p>Max<br></p><p><br>&gt; On Jun 23, 2016, at 3:19 PM, Patrick Pijnappel &lt;patrickpijnappel at gmail.com&gt; wrote:<br>&gt; <br>&gt; - I remain unconvinced that defining an Arithmetic that includes both exact and floating-point numbers is a good idea. All of the arguments from Swift 1 and 2 about why we didn&#39;t include this still seem relevant. To phrase it in generic programming terms, what algorithm would be generic over Arithmetic?<br>&gt; <br>&gt; E.g. generic point/size/rect types.<br>&gt; <br>&gt; &gt; For Integer, does the presence of signBit indicate an expectation that signed Integers will have a two&#39;s complement representation?<br>&gt; Yes. That is correct.<br>&gt; <br>&gt; So would this require a BigInt implementation to be in two&#39;s complement also? Most BigInt implementations use a separate sign I think, not sure if that&#39;s for performance reasons or merely convenience though.<br>&gt; <br>&gt; <br>&gt; On Fri, Jun 24, 2016 at 7:40 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Oh, one more comment: I suggest naming the primary protocol something other than &quot;Integer&quot;, which IMHO is a little close to &quot;Int&quot; for a beginner. &quot;Integral&quot; is a bit too ambiguous, but maybe &quot;IntegerArithmetic&quot; or &quot;ArithmeticInteger&quot;? Or to go with the representation thing, &quot;BinaryInteger&quot;? (Some of the requirements are at odds with a decimal-based implementation.)<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 13:50, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey, standard library folks. Glad we&#39;re doing this one. :-)<br>&gt;&gt; <br>&gt;&gt; - I remain unconvinced that defining an Arithmetic that includes both exact and floating-point numbers is a good idea. All of the arguments from Swift 1 and 2 about why we didn&#39;t include this still seem relevant. To phrase it in generic programming terms, what algorithm would be generic over Arithmetic?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; - What is Integer.init&lt;T: FloatingPoint&gt;(_:) supposed to do if the floating-point value is larger than the maximum representable integer? Smaller than the minimum? (As a special case, negative, when the integer type is unsigned?) Infinity? NaN?<br>&gt;&gt; <br>&gt;&gt; - Integer.init&lt;T: Integer&gt;(_:) currently says &quot;if it is representable&quot;. It should say something like &quot;trapping if it is not representable&quot;.<br>&gt;&gt; <br>&gt;&gt; - I find it odd that Integer.init(clamping:) privileges the bounds of fixed-width integers. I was going to suggest it should take a range to clamp to that defaults to the min and max, but that&#39;s not implementable for a BigInt.<br>&gt;&gt; <br>&gt;&gt; - nthWord should count &quot;from least-significant to most-significant&quot; rather than &quot;from the right&quot;.<br>&gt;&gt; <br>&gt;&gt; - As mentioned before, it sounds like Integer requires a two&#39;s complement representation (if only so the result of nthWord can be interpreted correctly). That should probably be in the doc comment for the protocol.<br>&gt;&gt; <br>&gt;&gt; - Why is bitWidth in bits but nthWord in words? (I know there&#39;s a good answer to this, but using them together seems like it will be common.)<br>&gt;&gt; <br>&gt;&gt; - It&#39;s also probably worth calling out even more explicitly that bitWidth is a representation property, not a value property. That is, a BigInt with the value &quot;1&quot; could have a bitWidth of 1, 8, or 128.<br>&gt;&gt; <br>&gt;&gt; - What does signBitIndex return if self is positive? I ask because it&#39;s just not in the doc comment, but thinking about the answer made it obvious that the correct return value for 0 is 0.<br>&gt;&gt; <br>&gt;&gt; - For signed integers, does remainder(dividingBy:) have specified behavior for the sign of the result? See https://en.wikipedia.org/wiki/Modulo_operation &lt;https://en.wikipedia.org/wiki/Modulo_operation&gt;.<br>&gt;&gt; <br>&gt;&gt; - I do think having Swift.abs(_:) and Integer.absoluteValue is confusing, but I don&#39;t know what to do about it.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; - Why are bitwise operations limited to fixed-width integers? I see &quot;The only difference is that because shifting left truncates the high bits of fixed-width integers, it is hard to define what a left shift would mean to an arbitrary-precision integer&quot; further down, but I would just assume it wouldn&#39;t truncate (i.e. it would be a pure multiplication by two).<br>&gt;&gt; <br>&gt;&gt; - Is there a requirement about left-shifting into the sign bit, for &#39;&lt;&lt;&#39; and for &#39;&amp;&lt;&lt;&#39;?<br>&gt;&gt; <br>&gt;&gt; - What is the ArithmeticOverflow type?<br>&gt;&gt; <br>&gt;&gt; - When does the remainder operation overflow? (I just can&#39;t remember.)<br>&gt;&gt; <br>&gt;&gt; - I feel a little weird having &quot;someValue.and(mask)&quot;. Maybe bitwiseAnd or bitwiseAND to be more explicit?<br>&gt;&gt; <br>&gt;&gt; - maskingShiftLeft/Right seem underspecified in their doc comments. Why can&#39;t the protocol requirement just assume the shift amount has already been masked, instead of performing the masking themselves? Is it because we won&#39;t be able to optimize that away?<br>&gt;&gt; <br>&gt;&gt; I think that&#39;s about it. Great work, all!<br>&gt;&gt; Jordan<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/feb1a680/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0104: Protocol-oriented integers</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>June 23, 2016 at 08:00:00pm</p></header><div class="content"><p>Thanks for answering my questions earlier. I like a lot of the changes.<br></p><p>Speaking of heterogeneous comparisons again, though, how are comparisons of negative signed integers with unsigned integers handled?<br></p><p>Félix<br></p><p>&gt; Le 23 juin 2016 à 17:36:14, Max Moiseev via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; &gt; For Integer, does the presence of signBit indicate an expectation that signed Integers will have a two&#39;s complement representation?<br>&gt;&gt; Yes. That is correct.<br>&gt;&gt; <br>&gt;&gt; So would this require a BigInt implementation to be in two&#39;s complement also? Most BigInt implementations use a separate sign I think, not sure if that&#39;s for performance reasons or merely convenience though.<br>&gt; <br>&gt; <br>&gt; This is a very valid concern. I think I have discovered a truly marvelous solution a way of addressing it:<br>&gt; <br>&gt; `signBitIndex` is only used (I’m talking about the prototype now) to determine the absolute required minimum of bits needed to represent the current value of number when converting it to a different type.<br>&gt; <br>&gt; So, instead of mentioning the sign bit, let’s call it what it is ‘minimumRequiredWidth’ or something along this line. This move will also allow the default implementation of `minimumRequiredWidth` to simply return `bitWidth` for unsigned numbers and and `bitWidth - 1` for positive signed, etc.<br>&gt; <br>&gt; This way bignum implementations don’t have to have any specific underlying representation. They can either inherit the default implementation or implement their own version of `minimumRequiredWidth` in case the `bitWidth` has some extra unused space that is not absolutely required.<br>&gt; <br>&gt; I still need to validate this idea, these are just the thoughts. Any comments are more than welcome.<br>&gt; <br>&gt; Max<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 3:19 PM, Patrick Pijnappel &lt;patrickpijnappel at gmail.com &lt;mailto:patrickpijnappel at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; - I remain unconvinced that defining an Arithmetic that includes both exact and floating-point numbers is a good idea. All of the arguments from Swift 1 and 2 about why we didn&#39;t include this still seem relevant. To phrase it in generic programming terms, what algorithm would be generic over Arithmetic?<br>&gt;&gt; <br>&gt;&gt; E.g. generic point/size/rect types.<br>&gt;&gt; <br>&gt;&gt; &gt; For Integer, does the presence of signBit indicate an expectation that signed Integers will have a two&#39;s complement representation?<br>&gt;&gt; Yes. That is correct.<br>&gt;&gt; <br>&gt;&gt; So would this require a BigInt implementation to be in two&#39;s complement also? Most BigInt implementations use a separate sign I think, not sure if that&#39;s for performance reasons or merely convenience though.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Fri, Jun 24, 2016 at 7:40 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Oh, one more comment: I suggest naming the primary protocol something other than &quot;Integer&quot;, which IMHO is a little close to &quot;Int&quot; for a beginner. &quot;Integral&quot; is a bit too ambiguous, but maybe &quot;IntegerArithmetic&quot; or &quot;ArithmeticInteger&quot;? Or to go with the representation thing, &quot;BinaryInteger&quot;? (Some of the requirements are at odds with a decimal-based implementation.)<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 23, 2016, at 13:50, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hey, standard library folks. Glad we&#39;re doing this one. :-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - I remain unconvinced that defining an Arithmetic that includes both exact and floating-point numbers is a good idea. All of the arguments from Swift 1 and 2 about why we didn&#39;t include this still seem relevant. To phrase it in generic programming terms, what algorithm would be generic over Arithmetic?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - What is Integer.init&lt;T: FloatingPoint&gt;(_:) supposed to do if the floating-point value is larger than the maximum representable integer? Smaller than the minimum? (As a special case, negative, when the integer type is unsigned?) Infinity? NaN?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Integer.init&lt;T: Integer&gt;(_:) currently says &quot;if it is representable&quot;. It should say something like &quot;trapping if it is not representable&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - I find it odd that Integer.init(clamping:) privileges the bounds of fixed-width integers. I was going to suggest it should take a range to clamp to that defaults to the min and max, but that&#39;s not implementable for a BigInt.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - nthWord should count &quot;from least-significant to most-significant&quot; rather than &quot;from the right&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - As mentioned before, it sounds like Integer requires a two&#39;s complement representation (if only so the result of nthWord can be interpreted correctly). That should probably be in the doc comment for the protocol.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Why is bitWidth in bits but nthWord in words? (I know there&#39;s a good answer to this, but using them together seems like it will be common.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - It&#39;s also probably worth calling out even more explicitly that bitWidth is a representation property, not a value property. That is, a BigInt with the value &quot;1&quot; could have a bitWidth of 1, 8, or 128.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - What does signBitIndex return if self is positive? I ask because it&#39;s just not in the doc comment, but thinking about the answer made it obvious that the correct return value for 0 is 0.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - For signed integers, does remainder(dividingBy:) have specified behavior for the sign of the result? See https://en.wikipedia.org/wiki/Modulo_operation &lt;https://en.wikipedia.org/wiki/Modulo_operation&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - I do think having Swift.abs(_:) and Integer.absoluteValue is confusing, but I don&#39;t know what to do about it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Why are bitwise operations limited to fixed-width integers? I see &quot;The only difference is that because shifting left truncates the high bits of fixed-width integers, it is hard to define what a left shift would mean to an arbitrary-precision integer&quot; further down, but I would just assume it wouldn&#39;t truncate (i.e. it would be a pure multiplication by two).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Is there a requirement about left-shifting into the sign bit, for &#39;&lt;&lt;&#39; and for &#39;&amp;&lt;&lt;&#39;?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - What is the ArithmeticOverflow type?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - When does the remainder operation overflow? (I just can&#39;t remember.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - I feel a little weird having &quot;someValue.and(mask)&quot;. Maybe bitwiseAnd or bitwiseAND to be more explicit?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - maskingShiftLeft/Right seem underspecified in their doc comments. Why can&#39;t the protocol requirement just assume the shift amount has already been masked, instead of performing the masking themselves? Is it because we won&#39;t be able to optimize that away?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think that&#39;s about it. Great work, all!<br>&gt;&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/81005bb2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0104: Protocol-oriented integers</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 23, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 22:47, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks for answering my questions earlier. I like a lot of the changes.<br>&gt; <br>&gt; Speaking of heterogeneous comparisons again, though, how are comparisons of negative signed integers with unsigned integers handled?<br>&gt; <br>&gt; Félix<br></p><p>I can&#39;t speak for anyone else, but I&#39;d check the sign bit, return the correct answer if it&#39;s negative, and if not do an unsafeBitCast to the same-width unsigned type and use that to return the results of the homogeneous comparison.<br></p><p>There&#39;s probably a quicker way using some arcane bit-fiddling wizardry, but I don&#39;t know it off the top of my head.<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/8845a910/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c53218a6524f4d644b6a75a4441ea631?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0104: Protocol-oriented integers</strong> from <string>Max Moiseev</string> &lt;moiseev at apple.com&gt;<p>June 24, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 8:47 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; Thanks for answering my questions earlier. I like a lot of the changes.<br>&gt; <br>&gt; Speaking of heterogeneous comparisons again, though, how are comparisons of negative signed integers with unsigned integers handled?<br>It is in the prototype: https://github.com/apple/swift/blob/master/test/Prototypes/Integers.swift.gyb#L334<br></p><p>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 23 juin 2016 à 17:36:14, Max Moiseev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; &gt; For Integer, does the presence of signBit indicate an expectation that signed Integers will have a two&#39;s complement representation?<br>&gt;&gt;&gt; Yes. That is correct.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So would this require a BigInt implementation to be in two&#39;s complement also? Most BigInt implementations use a separate sign I think, not sure if that&#39;s for performance reasons or merely convenience though.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This is a very valid concern. I think I have discovered a truly marvelous solution a way of addressing it:<br>&gt;&gt; <br>&gt;&gt; `signBitIndex` is only used (I’m talking about the prototype now) to determine the absolute required minimum of bits needed to represent the current value of number when converting it to a different type.<br>&gt;&gt; <br>&gt;&gt; So, instead of mentioning the sign bit, let’s call it what it is ‘minimumRequiredWidth’ or something along this line. This move will also allow the default implementation of `minimumRequiredWidth` to simply return `bitWidth` for unsigned numbers and and `bitWidth - 1` for positive signed, etc.<br>&gt;&gt; <br>&gt;&gt; This way bignum implementations don’t have to have any specific underlying representation. They can either inherit the default implementation or implement their own version of `minimumRequiredWidth` in case the `bitWidth` has some extra unused space that is not absolutely required.<br>&gt;&gt; <br>&gt;&gt; I still need to validate this idea, these are just the thoughts. Any comments are more than welcome.<br>&gt;&gt; <br>&gt;&gt; Max<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 23, 2016, at 3:19 PM, Patrick Pijnappel &lt;patrickpijnappel at gmail.com &lt;mailto:patrickpijnappel at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - I remain unconvinced that defining an Arithmetic that includes both exact and floating-point numbers is a good idea. All of the arguments from Swift 1 and 2 about why we didn&#39;t include this still seem relevant. To phrase it in generic programming terms, what algorithm would be generic over Arithmetic?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; E.g. generic point/size/rect types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; For Integer, does the presence of signBit indicate an expectation that signed Integers will have a two&#39;s complement representation?<br>&gt;&gt;&gt; Yes. That is correct.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So would this require a BigInt implementation to be in two&#39;s complement also? Most BigInt implementations use a separate sign I think, not sure if that&#39;s for performance reasons or merely convenience though.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Fri, Jun 24, 2016 at 7:40 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Oh, one more comment: I suggest naming the primary protocol something other than &quot;Integer&quot;, which IMHO is a little close to &quot;Int&quot; for a beginner. &quot;Integral&quot; is a bit too ambiguous, but maybe &quot;IntegerArithmetic&quot; or &quot;ArithmeticInteger&quot;? Or to go with the representation thing, &quot;BinaryInteger&quot;? (Some of the requirements are at odds with a decimal-based implementation.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 23, 2016, at 13:50, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hey, standard library folks. Glad we&#39;re doing this one. :-)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - I remain unconvinced that defining an Arithmetic that includes both exact and floating-point numbers is a good idea. All of the arguments from Swift 1 and 2 about why we didn&#39;t include this still seem relevant. To phrase it in generic programming terms, what algorithm would be generic over Arithmetic?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - What is Integer.init&lt;T: FloatingPoint&gt;(_:) supposed to do if the floating-point value is larger than the maximum representable integer? Smaller than the minimum? (As a special case, negative, when the integer type is unsigned?) Infinity? NaN?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Integer.init&lt;T: Integer&gt;(_:) currently says &quot;if it is representable&quot;. It should say something like &quot;trapping if it is not representable&quot;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - I find it odd that Integer.init(clamping:) privileges the bounds of fixed-width integers. I was going to suggest it should take a range to clamp to that defaults to the min and max, but that&#39;s not implementable for a BigInt.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - nthWord should count &quot;from least-significant to most-significant&quot; rather than &quot;from the right&quot;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - As mentioned before, it sounds like Integer requires a two&#39;s complement representation (if only so the result of nthWord can be interpreted correctly). That should probably be in the doc comment for the protocol.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Why is bitWidth in bits but nthWord in words? (I know there&#39;s a good answer to this, but using them together seems like it will be common.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - It&#39;s also probably worth calling out even more explicitly that bitWidth is a representation property, not a value property. That is, a BigInt with the value &quot;1&quot; could have a bitWidth of 1, 8, or 128.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - What does signBitIndex return if self is positive? I ask because it&#39;s just not in the doc comment, but thinking about the answer made it obvious that the correct return value for 0 is 0.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - For signed integers, does remainder(dividingBy:) have specified behavior for the sign of the result? See https://en.wikipedia.org/wiki/Modulo_operation &lt;https://en.wikipedia.org/wiki/Modulo_operation&gt;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - I do think having Swift.abs(_:) and Integer.absoluteValue is confusing, but I don&#39;t know what to do about it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Why are bitwise operations limited to fixed-width integers? I see &quot;The only difference is that because shifting left truncates the high bits of fixed-width integers, it is hard to define what a left shift would mean to an arbitrary-precision integer&quot; further down, but I would just assume it wouldn&#39;t truncate (i.e. it would be a pure multiplication by two).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Is there a requirement about left-shifting into the sign bit, for &#39;&lt;&lt;&#39; and for &#39;&amp;&lt;&lt;&#39;?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - What is the ArithmeticOverflow type?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - When does the remainder operation overflow? (I just can&#39;t remember.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - I feel a little weird having &quot;someValue.and(mask)&quot;. Maybe bitwiseAnd or bitwiseAND to be more explicit?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - maskingShiftLeft/Right seem underspecified in their doc comments. Why can&#39;t the protocol requirement just assume the shift amount has already been masked, instead of performing the masking themselves? Is it because we won&#39;t be able to optimize that away?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think that&#39;s about it. Great work, all!<br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/131d888c/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0104: Protocol-oriented integers</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>June 24, 2016 at 11:00:00pm</p></header><div class="content"><p>Okay, well, I&#39;m +1 on this. I like that we got rid of conversions from/to U/IntMax in favor of more general initializers and the bitshift enhancements. I think that most generic algorithms on integers will get simpler.<br></p><p>I&#39;m not overly concerned/competent with floating-point numbers, but I&#39;m sure that the people here will nitpick every last wrinkle that there could be.<br></p><p>Félix<br></p><p>&gt; Le 24 juin 2016 à 14:34:37, Max Moiseev &lt;moiseev at apple.com&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 8:47 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks for answering my questions earlier. I like a lot of the changes.<br>&gt;&gt; <br>&gt;&gt; Speaking of heterogeneous comparisons again, though, how are comparisons of negative signed integers with unsigned integers handled?<br>&gt; It is in the prototype: https://github.com/apple/swift/blob/master/test/Prototypes/Integers.swift.gyb#L334 &lt;https://github.com/apple/swift/blob/master/test/Prototypes/Integers.swift.gyb#L334&gt;<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 23 juin 2016 à 17:36:14, Max Moiseev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; For Integer, does the presence of signBit indicate an expectation that signed Integers will have a two&#39;s complement representation?<br>&gt;&gt;&gt;&gt; Yes. That is correct.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So would this require a BigInt implementation to be in two&#39;s complement also? Most BigInt implementations use a separate sign I think, not sure if that&#39;s for performance reasons or merely convenience though.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a very valid concern. I think I have discovered a truly marvelous solution a way of addressing it:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `signBitIndex` is only used (I’m talking about the prototype now) to determine the absolute required minimum of bits needed to represent the current value of number when converting it to a different type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, instead of mentioning the sign bit, let’s call it what it is ‘minimumRequiredWidth’ or something along this line. This move will also allow the default implementation of `minimumRequiredWidth` to simply return `bitWidth` for unsigned numbers and and `bitWidth - 1` for positive signed, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This way bignum implementations don’t have to have any specific underlying representation. They can either inherit the default implementation or implement their own version of `minimumRequiredWidth` in case the `bitWidth` has some extra unused space that is not absolutely required.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I still need to validate this idea, these are just the thoughts. Any comments are more than welcome.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Max<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 23, 2016, at 3:19 PM, Patrick Pijnappel &lt;patrickpijnappel at gmail.com &lt;mailto:patrickpijnappel at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - I remain unconvinced that defining an Arithmetic that includes both exact and floating-point numbers is a good idea. All of the arguments from Swift 1 and 2 about why we didn&#39;t include this still seem relevant. To phrase it in generic programming terms, what algorithm would be generic over Arithmetic?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; E.g. generic point/size/rect types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; For Integer, does the presence of signBit indicate an expectation that signed Integers will have a two&#39;s complement representation?<br>&gt;&gt;&gt;&gt; Yes. That is correct.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So would this require a BigInt implementation to be in two&#39;s complement also? Most BigInt implementations use a separate sign I think, not sure if that&#39;s for performance reasons or merely convenience though.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Fri, Jun 24, 2016 at 7:40 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Oh, one more comment: I suggest naming the primary protocol something other than &quot;Integer&quot;, which IMHO is a little close to &quot;Int&quot; for a beginner. &quot;Integral&quot; is a bit too ambiguous, but maybe &quot;IntegerArithmetic&quot; or &quot;ArithmeticInteger&quot;? Or to go with the representation thing, &quot;BinaryInteger&quot;? (Some of the requirements are at odds with a decimal-based implementation.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 23, 2016, at 13:50, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hey, standard library folks. Glad we&#39;re doing this one. :-)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - I remain unconvinced that defining an Arithmetic that includes both exact and floating-point numbers is a good idea. All of the arguments from Swift 1 and 2 about why we didn&#39;t include this still seem relevant. To phrase it in generic programming terms, what algorithm would be generic over Arithmetic?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - What is Integer.init&lt;T: FloatingPoint&gt;(_:) supposed to do if the floating-point value is larger than the maximum representable integer? Smaller than the minimum? (As a special case, negative, when the integer type is unsigned?) Infinity? NaN?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Integer.init&lt;T: Integer&gt;(_:) currently says &quot;if it is representable&quot;. It should say something like &quot;trapping if it is not representable&quot;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - I find it odd that Integer.init(clamping:) privileges the bounds of fixed-width integers. I was going to suggest it should take a range to clamp to that defaults to the min and max, but that&#39;s not implementable for a BigInt.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - nthWord should count &quot;from least-significant to most-significant&quot; rather than &quot;from the right&quot;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - As mentioned before, it sounds like Integer requires a two&#39;s complement representation (if only so the result of nthWord can be interpreted correctly). That should probably be in the doc comment for the protocol.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Why is bitWidth in bits but nthWord in words? (I know there&#39;s a good answer to this, but using them together seems like it will be common.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - It&#39;s also probably worth calling out even more explicitly that bitWidth is a representation property, not a value property. That is, a BigInt with the value &quot;1&quot; could have a bitWidth of 1, 8, or 128.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - What does signBitIndex return if self is positive? I ask because it&#39;s just not in the doc comment, but thinking about the answer made it obvious that the correct return value for 0 is 0.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - For signed integers, does remainder(dividingBy:) have specified behavior for the sign of the result? See https://en.wikipedia.org/wiki/Modulo_operation &lt;https://en.wikipedia.org/wiki/Modulo_operation&gt;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - I do think having Swift.abs(_:) and Integer.absoluteValue is confusing, but I don&#39;t know what to do about it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Why are bitwise operations limited to fixed-width integers? I see &quot;The only difference is that because shifting left truncates the high bits of fixed-width integers, it is hard to define what a left shift would mean to an arbitrary-precision integer&quot; further down, but I would just assume it wouldn&#39;t truncate (i.e. it would be a pure multiplication by two).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Is there a requirement about left-shifting into the sign bit, for &#39;&lt;&lt;&#39; and for &#39;&amp;&lt;&lt;&#39;?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - What is the ArithmeticOverflow type?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - When does the remainder operation overflow? (I just can&#39;t remember.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - I feel a little weird having &quot;someValue.and(mask)&quot;. Maybe bitwiseAnd or bitwiseAND to be more explicit?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - maskingShiftLeft/Right seem underspecified in their doc comments. Why can&#39;t the protocol requirement just assume the shift amount has already been masked, instead of performing the masking themselves? Is it because we won&#39;t be able to optimize that away?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think that&#39;s about it. Great work, all!<br>&gt;&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/de0e6963/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c53218a6524f4d644b6a75a4441ea631?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0104: Protocol-oriented integers</strong> from <string>Max Moiseev</string> &lt;moiseev at apple.com&gt;<p>June 23, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi Jordan,<br></p><p>&gt; On Jun 23, 2016, at 1:50 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; Hey, standard library folks. Glad we&#39;re doing this one. :-)<br>&gt; <br>&gt; - I remain unconvinced that defining an Arithmetic that includes both exact and floating-point numbers is a good idea. All of the arguments from Swift 1 and 2 about why we didn&#39;t include this still seem relevant. To phrase it in generic programming terms, what algorithm would be generic over Arithmetic?<br>Steve, I don’t remember exactly why we chose to do it this time. Can you answer?<br></p><p>&gt; <br>&gt; - What is Integer.init&lt;T: FloatingPoint&gt;(_:) supposed to do if the floating-point value is larger than the maximum representable integer? Smaller than the minimum? (As a special case, negative, when the integer type is unsigned?) Infinity? NaN?<br>The same thing it does now — trap.<br></p><p>&gt; <br>&gt; - Integer.init&lt;T: Integer&gt;(_:) currently says &quot;if it is representable&quot;. It should say something like &quot;trapping if it is not representable”.<br>There is a comment saying that this is the precondition that must be checked by the caller. The initializer will trap but this is the implementation detail, isn’t it?<br>&gt; <br>&gt; - I find it odd that Integer.init(clamping:) privileges the bounds of fixed-width integers. I was going to suggest it should take a range to clamp to that defaults to the min and max, but that&#39;s not implementable for a BigInt.<br>It is always possible to pass bounds as an optional value and default to min…max in .none case.<br>So you are suggesting something like `init&lt;T : Integer&gt;(clamping: T, within bounds: Optional&lt;ClosedRange&lt;Self&gt;&gt; = nil)` then?<br>I don’t disagree. Looks useful, but I cannot imagine a good real world use for it, except for:<br></p><p>extension Integer {<br>  public func findClosest(to: Self, within bounds: ClosedRange&lt;Self&gt;) {<br>    return Self(clamping: to, within: bounds)<br>  }<br>}<br></p><p>&gt; <br>&gt; - nthWord should count &quot;from least-significant to most-significant&quot; rather than &quot;from the right”.<br>Will this definition work fine with different endiannesses? It needs some thinking, but I see your point.<br>&gt; <br>&gt; - As mentioned before, it sounds like Integer requires a two&#39;s complement representation (if only so the result of nthWord can be interpreted correctly). That should probably be in the doc comment for the protocol.<br>I’ll add it. Thanks.<br>&gt; <br>&gt; - Why is bitWidth in bits but nthWord in words? (I know there&#39;s a good answer to this, but using them together seems like it will be common.)<br>There is a derived property that will return the width in words based on bitWidth and word size.<br>&gt; <br>&gt; - It&#39;s also probably worth calling out even more explicitly that bitWidth is a representation property, not a value property. That is, a BigInt with the value &quot;1&quot; could have a bitWidth of 1, 8, or 128.<br>Noted. Thanks.<br></p><p>&gt; <br>&gt; - What does signBitIndex return if self is positive? I ask because it&#39;s just not in the doc comment, but thinking about the answer made it obvious that the correct return value for 0 is 0.<br>The doc comment right now describes the actual behavior from the prototype implementation. I plan to document this particular property better after cleaning up the prototype.<br></p><p>&gt; <br>&gt; - For signed integers, does remainder(dividingBy:) have specified behavior for the sign of the result? See https://en.wikipedia.org/wiki/Modulo_operation &lt;https://en.wikipedia.org/wiki/Modulo_operation&gt;.<br>The behavior should remain the same as it is now (the sign is preserved). I guess this just should be explicitly mentioned somewhere. Will do.<br>&gt; <br>&gt; - I do think having Swift.abs(_:) and Integer.absoluteValue is confusing, but I don&#39;t know what to do about it.<br>&gt; <br>&gt; <br>&gt; - Why are bitwise operations limited to fixed-width integers? I see &quot;The only difference is that because shifting left truncates the high bits of fixed-width integers, it is hard to define what a left shift would mean to an arbitrary-precision integer&quot; further down, but I would just assume it wouldn&#39;t truncate (i.e. it would be a pure multiplication by two).<br>Exactly. It won’t truncate and we considered it to be a sufficient difference in behavior to not allow it to be used in the context over all integers.<br>&gt; <br>&gt; - Is there a requirement about left-shifting into the sign bit, for &#39;&lt;&lt;&#39; and for &#39;&amp;&lt;&lt;‘?<br>The current behavior is to not do anything special about the sign bit. So that (64 as Int8) &lt;&lt; 1 would result in a -128.<br></p><p>I should probably add a general note somewhere in the proposal that “unless specifically mentioned, the behavior will remain consistent with the existing implementation”.<br></p><p>&gt; <br>&gt; - What is the ArithmeticOverflow type?<br>It is an enum with 2 cases, just like Optional&lt;()&gt;, but with more specific case name. If not for the explicitness, a simple Bool value could have been used.<br>&gt; <br>&gt; - When does the remainder operation overflow? (I just can&#39;t remember.)<br>Discussed in a separate email. The only case where it should trap is ‘division by zero’, so this part is subjected to changes.<br>&gt; <br>&gt; - I feel a little weird having &quot;someValue.and(mask)&quot;. Maybe bitwiseAnd or bitwiseAND to be more explicit?<br>Doesn’t return type hint at the ‘bitwise&#39; and not logical nature of these operations? Besides, I would expect operators to be used instead of actual protocol functions.<br>&gt; <br>&gt; - maskingShiftLeft/Right seem underspecified in their doc comments. Why can&#39;t the protocol requirement just assume the shift amount has already been masked, instead of performing the masking themselves? Is it because we won&#39;t be able to optimize that away?<br>There is a section about shifts: https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md#a-note-on-bit-shifts<br>Let me know if you think it is insufficient.<br>&gt; <br>&gt; I think that&#39;s about it. Great work, all!<br></p><p>&gt; Jordan<br></p><p>Thank you for a thoughtful review!<br>Max<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/4789fe9e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0104: Protocol-oriented integers</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 23, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 15:35, Max Moiseev &lt;moiseev at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi Jordan,<br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 1:50 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey, standard library folks. Glad we&#39;re doing this one. :-)<br>&gt;&gt; <br>&gt;&gt; - I remain unconvinced that defining an Arithmetic that includes both exact and floating-point numbers is a good idea. All of the arguments from Swift 1 and 2 about why we didn&#39;t include this still seem relevant. To phrase it in generic programming terms, what algorithm would be generic over Arithmetic?<br>&gt; Steve, I don’t remember exactly why we chose to do it this time. Can you answer?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; - What is Integer.init&lt;T: FloatingPoint&gt;(_:) supposed to do if the floating-point value is larger than the maximum representable integer? Smaller than the minimum? (As a special case, negative, when the integer type is unsigned?) Infinity? NaN?<br>&gt; The same thing it does now — trap.<br></p><p>I think this is worth calling out as a precondition: the value must be within the bounds of the integer type. (The implementation may not trap for some values slightly outside the integer type, like 0.1 being converted to UInt, but it&#39;s still not defined.)<br></p><p><br>&gt;&gt; <br>&gt;&gt; - Integer.init&lt;T: Integer&gt;(_:) currently says &quot;if it is representable&quot;. It should say something like &quot;trapping if it is not representable”.<br>&gt; There is a comment saying that this is the precondition that must be checked by the caller. The initializer will trap but this is the implementation detail, isn’t it?<br></p><p>Ah, of course. My bad.<br></p><p><br>&gt;&gt; <br>&gt;&gt; - I find it odd that Integer.init(clamping:) privileges the bounds of fixed-width integers. I was going to suggest it should take a range to clamp to that defaults to the min and max, but that&#39;s not implementable for a BigInt.<br>&gt; It is always possible to pass bounds as an optional value and default to min…max in .none case.<br>&gt; So you are suggesting something like `init&lt;T : Integer&gt;(clamping: T, within bounds: Optional&lt;ClosedRange&lt;Self&gt;&gt; = nil)` then?<br>&gt; I don’t disagree. Looks useful, but I cannot imagine a good real world use for it, except for:<br>&gt; <br>&gt; extension Integer {<br>&gt;   public func findClosest(to: Self, within bounds: ClosedRange&lt;Self&gt;) {<br>&gt;     return Self(clamping: to, within: bounds)<br>&gt;   }<br>&gt; }<br></p><p>I don&#39;t find it any different from the existing requirement. If I&#39;m going from a potentially large (absolute) value to a smaller one, it&#39;s possible I only care about representation, but it&#39;s also possible I have a smaller type here because of context.<br></p><p>englishPluralIndex = items.count.clamped(to: 0...2)<br></p><p>Maybe I&#39;d go the other way, and say that this isn&#39;t a useful requirement. Are there algorithms that need this that are generic over Integer? (rather than FixedWidthInteger)<br></p><p><br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; - nthWord should count &quot;from least-significant to most-significant&quot; rather than &quot;from the right”.<br>&gt; Will this definition work fine with different endiannesses? It needs some thinking, but I see your point.<br></p><p>Yes, &quot;significant&quot; always refers to place values, not to the representation in memory/registers.<br></p><p>&gt;&gt; - Why is bitWidth in bits but nthWord in words? (I know there&#39;s a good answer to this, but using them together seems like it will be common.)<br>&gt; There is a derived property that will return the width in words based on bitWidth and word size.<br></p><p>Got it. May be deserving of a SeeAlso.<br></p><p>&gt;&gt; <br>&gt;&gt; - Why are bitwise operations limited to fixed-width integers? I see &quot;The only difference is that because shifting left truncates the high bits of fixed-width integers, it is hard to define what a left shift would mean to an arbitrary-precision integer&quot; further down, but I would just assume it wouldn&#39;t truncate (i.e. it would be a pure multiplication by two).<br>&gt; Exactly. It won’t truncate and we considered it to be a sufficient difference in behavior to not allow it to be used in the context over all integers.<br></p><p>Hm. I guess that makes sense. My interpretation: the behavior on fixed-width integers is well-understood, the behavior on arbitrary-precision integers is easy to understand, but the behavior in an algorithm generic over both might be problematic. Thanks for the explanation.<br></p><p><br>&gt;&gt; <br>&gt;&gt; - Is there a requirement about left-shifting into the sign bit, for &#39;&lt;&lt;&#39; and for &#39;&amp;&lt;&lt;‘?<br>&gt; The current behavior is to not do anything special about the sign bit. So that (64 as Int8) &lt;&lt; 1 would result in a -128.<br>&gt; <br>&gt; I should probably add a general note somewhere in the proposal that “unless specifically mentioned, the behavior will remain consistent with the existing implementation”.<br></p><p>Sure. In this case I was asking about the requirement, though. If I use something like llvm::APSInt, which has an arbitrary-but-fixed-at-creation number of words, does shifting into the sign bit of a signed integer always result in a negative number? It never traps or is assumed not to happen?<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; - What is the ArithmeticOverflow type?<br>&gt; It is an enum with 2 cases, just like Optional&lt;()&gt;, but with more specific case name. If not for the explicitness, a simple Bool value could have been used.<br></p><p>Please do include this in the proposal. :-)<br></p><p><br>&gt;&gt; <br>&gt;&gt; - When does the remainder operation overflow? (I just can&#39;t remember.)<br>&gt; Discussed in a separate email. The only case where it should trap is ‘division by zero’, so this part is subjected to changes.<br>&gt;&gt; <br>&gt;&gt; - I feel a little weird having &quot;someValue.and(mask)&quot;. Maybe bitwiseAnd or bitwiseAND to be more explicit?<br>&gt; Doesn’t return type hint at the ‘bitwise&#39; and not logical nature of these operations? Besides, I would expect operators to be used instead of actual protocol functions.<br></p><p>I guess so. It just reads oddly to me.<br></p><p><br>&gt;&gt; <br>&gt;&gt; - maskingShiftLeft/Right seem underspecified in their doc comments. Why can&#39;t the protocol requirement just assume the shift amount has already been masked, instead of performing the masking themselves? Is it because we won&#39;t be able to optimize that away?<br>&gt; There is a section about shifts: https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md#a-note-on-bit-shifts &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md#a-note-on-bit-shifts&gt;<br>&gt; Let me know if you think it is insufficient.<br></p><p>I did see this section, but that&#39;s about the operator-based interface, not the requirements on a model type. I&#39;d like to hear a little more about what the expected input range of maskingShiftLeft is and why.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/c09e187f/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0735d3bf1d76c0385258ac7a2a22d6fe?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Károly Lőrentey</string> &lt;karoly at lorentey.hu&gt;<p>June 24, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; * What is your evaluation of the proposal?<br>+1 in general<br>&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br>Yes.<br>&gt; * Does this proposal fit well with the feel and direction of Swift?<br>Yes, with some nitpicks detailed below.<br>&gt; * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>-<br>&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>An afternoon of detailed study.<br></p><p><br>As the author of a Swift package for arbitrary integers (https://github.com/lorentey/BigInt), I’m delighted by this proposal.<br></p><p>I’m especially stoked about `FixedWidthInteger.doubleWidthMultiply`, which will likely lead to a measurable speedup. Why is there no `doubleWidthQuotientAndRemainder` or `doubleWidthDivide`, though?<br></p><p>What is the intended behavior for `nthWord` for negative numbers? Can we prevent having to answer this question by e.g. moving this method down to UnsignedInteger? Big integer libs often use a signed magnitude representation; having to e.g. convert it to two’s complement on the fly to satisfy the API would be weird. (Also, the name `nthWord` seems unswifty to me.)<br></p><p>Like others on this list, I also find signBitIndex confusing. The name does not make much sense for unsigned integers, or signed integers that do not use an embedded sign bit. Is it supposed to return the width (in bits) of the binary representation of the integer’s absolute value? (Why -1 for zero, then? What’s the signBitIndex for 1?) <br></p><p>I can’t find any mention of the unary bitwise not (~) operation. It should be in FixedWidthInteger, right?<br></p><p>Binary bitwise operations (or/and/xor) are in FixedWidthInteger, but I believe they can be implemented on big integers in a way that is perfectly consistent with fixed width integers. Admittedly, I don’t know of any generic algorithms that want these.<br></p><p>To support big integers better, I think IntegerLiteralConvertible should also be updated at some point to work in terms of machine words. (Having to implement StringLiteralConvertible to provide source-level support for huge numbers works, but it isn’t great.)<br></p><p>I can see myself typing foo.absoluteValue instead of abs(foo) all the time; if its use is to be discouraged, perhaps a less prominent name would be better.<br></p><p>There is a typo in the Operators section: “Arithmetic” should read “Integer” in these two lines:<br></p><p>	public func % &lt;T: Arithmetic&gt;(lhs: T, rhs: T) -&gt; T<br>	public func %= &lt;T: Arithmetic&gt;(lhs: inout T, rhs: T)<br></p><p>Remark: The gyb is nice when used in moderation, but I find parts of the prototype overuse templating to a point that’s bordering on obfuscation. E.g., I found this code especially hard to read:<br></p><p>	https://github.com/apple/swift/blob/master/test/Prototypes/Integers.swift.gyb#L1016-L1033 &lt;https://github.com/apple/swift/blob/master/test/Prototypes/Integers.swift.gyb#L1016-L1033&gt;<br></p><p>-- <br>Karoly<br>@lorentey<br></p><p><br>&gt; On 2016-06-23, at 02:52, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0104: Protocol-oriented integers&quot; begins now and runs through June 27. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/0ff8dbba/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>June 24, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 24 Jun 2016, at 18:17, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I’m especially stoked about `FixedWidthInteger.doubleWidthMultiply`, which will likely lead to a measurable speedup. Why is there no `doubleWidthQuotientAndRemainder` or `doubleWidthDivide`, though?<br></p><p>Double-width isn&#39;t needed for these as it&#39;s impossible for an integer to become larger when dividing (the smallest value you can divide by and get a result is 2, which will halve the value), and the remainder can&#39;t be larger than the original value.<br></p><p><br>Anyway, I&#39;m hugely in favour of this proposal, it&#39;s desperately needed!<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0735d3bf1d76c0385258ac7a2a22d6fe?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Károly Lőrentey</string> &lt;karoly at lorentey.hu&gt;<p>June 24, 2016 at 09:00:00pm</p></header><div class="content"><p>The operation I want is the inverse of doubleWidthMultiply, where you have a (high, low) word pair and you want to divide it by a single word, getting a quotient and remainder. This is an important building block for implementing arbitrary precision division. Intel’s DIV can do this in a single instruction, while doing it in code requires a lot of work:<br></p><p>https://github.com/lorentey/BigInt/blob/swift3/Sources/BigDigit.swift#L119-L176<br></p><p>&gt; On 2016-06-24, at 20:52, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 24 Jun 2016, at 18:17, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I’m especially stoked about `FixedWidthInteger.doubleWidthMultiply`, which will likely lead to a measurable speedup. Why is there no `doubleWidthQuotientAndRemainder` or `doubleWidthDivide`, though?<br>&gt; <br>&gt; Double-width isn&#39;t needed for these as it&#39;s impossible for an integer to become larger when dividing (the smallest value you can divide by and get a result is 2, which will halve the value), and the remainder can&#39;t be larger than the original value.<br>&gt; <br>&gt; <br>&gt; Anyway, I&#39;m hugely in favour of this proposal, it&#39;s desperately needed!<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 24, 2016 at 05:00:00pm</p></header><div class="content"><p>As someone who’ll likely make use of this protocol, I’m in favor of a “halfWidthDivide” (or whatever it’s called). As someone who’ll likely end up writing at least one type which will conform to `Integer`, I’m not looking forward to implementing 503 little functions &amp; computed properties (although I’ll admit it’ll be worth it to get a nice integer protocol). Is there any chance the protocol be able to provide default implementations for any of the “metadata” kind of stuff?<br></p><p>Also, speaking of default implementations, “wouldn’t it be nice if...” we only had to define everything explicitly for `IntN`, `UIntN` and `DoubleWidth&lt;T&gt;`, and the compiler was smart enough to figure out that, say, `DoubleWidth&lt;Int8&gt;` was semantically identical to `Int16` and would automatically promote it to the native type whenever possible… That way we wouldn’t need the .gyb files to write the code for all the integer types, *and* we wouldn’t have to pay the speed penalty for having, say, &quot;func *(Int, Int)-&gt;Int&quot; be the same code path as &quot;func *(DoubleWidth&lt;DoubleWidth&lt;DoubleWidth&lt;Int8&gt;&gt;&gt;, DoubleWidth&lt;DoubleWidth&lt;DoubleWidth&lt;Int8&gt;&gt;&gt;) -&gt; DoubleWidth&lt;DoubleWidth&lt;DoubleWidth&lt;Int8&gt;&gt;&gt;”, *and* we’d get arbitrary-width ints for free (well, “arbitrary” in terms of powers of 2).<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jun 24, 2016, at 2:01 PM, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The operation I want is the inverse of doubleWidthMultiply, where you have a (high, low) word pair and you want to divide it by a single word, getting a quotient and remainder. This is an important building block for implementing arbitrary precision division. Intel’s DIV can do this in a single instruction, while doing it in code requires a lot of work:<br>&gt; <br>&gt; https://github.com/lorentey/BigInt/blob/swift3/Sources/BigDigit.swift#L119-L176<br>&gt; <br>&gt;&gt; On 2016-06-24, at 20:52, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 24 Jun 2016, at 18:17, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I’m especially stoked about `FixedWidthInteger.doubleWidthMultiply`, which will likely lead to a measurable speedup. Why is there no `doubleWidthQuotientAndRemainder` or `doubleWidthDivide`, though?<br>&gt;&gt; <br>&gt;&gt; Double-width isn&#39;t needed for these as it&#39;s impossible for an integer to become larger when dividing (the smallest value you can divide by and get a result is 2, which will halve the value), and the remainder can&#39;t be larger than the original value.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Anyway, I&#39;m hugely in favour of this proposal, it&#39;s desperately needed!<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>June 24, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 24, 2016, at 2:52 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 24 Jun 2016, at 18:17, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I’m especially stoked about `FixedWidthInteger.doubleWidthMultiply`, which will likely lead to a measurable speedup. Why is there no `doubleWidthQuotientAndRemainder` or `doubleWidthDivide`, though?<br>&gt; <br>&gt; Double-width isn&#39;t needed for these as it&#39;s impossible for an integer to become larger when dividing (the smallest value you can divide by and get a result is 2, which will halve the value), and the remainder can&#39;t be larger than the original value.<br></p><p>A double-width divide takes a double-width *numerator*, and is a useful building block for some approaches to bignum divides.<br></p><p>– Steve<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/33536e304f2318595dbd6104fdb0bd4a?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Alejandro Martinez</string> &lt;alexito4 at gmail.com&gt;<p>June 24, 2016 at 11:00:00pm</p></header><div class="content"><p>+1<br>I&#39;ve read the proposal and I&#39;ve been following the conversation for some days now.<br>I don&#39;t have anything else to add to the concerns that have already been discussed, but I would like to reiterate on the fact that having the ,absoluteValue, property but without substituting &#39;abs&#39; will induce a lot of programers to use it anyway and make mistakes.<br>That&#39;s my only concern with it, the rest looks awesome. It is really amazing to see the power of protocols.<br>Thanks for the proposal 👍🏻<br></p><p><br>Sent from my iPad<br></p><p>&gt; On 23 Jun 2016, at 01:52, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0104: Protocol-oriented integers&quot; begins now and runs through June 27. The proposal is available here:<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt;    * What is your evaluation of the proposal?<br>&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;    * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/fb37406a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 24, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; I don&#39;t have anything else to add to the concerns that have already been discussed, but I would like to reiterate on the fact that having the ,absoluteValue, property but without substituting &#39;abs&#39; will induce a lot of programers to use it anyway and make mistakes.<br></p><p>`FloatingPoint` seems to have a similar concept to `absoluteValue` that&#39;s called &quot;magnitude&quot;, although there&#39;s no actual `magnitude` property. Would that be a better name for this concept?<br></p><p>And if so, should it be on `Arithmetic`? I don&#39;t think the `FloatingPoint` spec actually specifies how absolute values should be handled (for that matter, I don&#39;t think this one does either), and currently it seems to come out of an `AbsoluteValuable` protocol that I haven&#39;t seen mentioned in either the Integer or FloatingPoint proposals.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>June 24, 2016 at 08:00:00pm</p></header><div class="content"><p>+1 but with a few reservations.<br></p><p># Arithmetic<br></p><p>What *are* the expected semantics of the operators? It seems like you can’t assume much about a generic `Arithmetic` type, e.g. in a generic context I can’t reliably assume even things like these:<br></p><p>- `(x / y) * y == x` (or even “is close to&quot; x) <br>- `(x + x + … + x) / n ==  x` (for `x` added together `n` times)<br>- `((x + y) + z) == (x + (y + z))` (etc.)<br>- `(x + y) - y == x`(? I think...)<br></p><p>…and so on; am I missing something? <br></p><p>If `Arithmetic` is as lacking in semantics as it seems, then it feels like one of those “bag of syntax” protocols that keep getting mentioned as against the stdlib philosophy.<br></p><p># More Bit Operations<br></p><p>These don’t have to go into a v1, but I’d like to request seriously considering baking good support for things like popcount  first set bit, etc., directly into the appropriate protocol (`FixedWidthInteger`?).<br></p><p>I won’t pretend there are specific generic algorithms simply waiting on their presence or anything…it just seems like a logical extension of the rationalized bit-shifting behavior in the proposal (and at least IMHO things like popcount really ought to have been fundamental operations on par with the shifts and bitwise operations, but that’s an aside).<br></p><p># Endianness &amp; Byte-Reversal<br></p><p>Endianness seems entirely unaddressed. I assume it’s intentional and, if so, I agree it’s *mostly* best omitted...but I’m curious if there’s already a plan for addressing that at this level or not? Even if just including a function like `func byteReversed() -&gt; Self` (etc.) on a suitable protocol (e.g. `FixedWidthInteger`, or perhaps a new refinement thereof?). <br></p><p>I think that’s it for now. Overall I like it!<br></p><p>&gt; On Jun 22, 2016, at 7:52 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0104: Protocol-oriented integers&quot; begins now and runs through June 27. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
