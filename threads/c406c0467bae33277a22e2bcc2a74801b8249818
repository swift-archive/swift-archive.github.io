<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c6761b86fcf674411c42ea5d32bbf6e5?s=50"></div><header><strong>False match reported by NSRegularExpression.firstMatchInString()</strong> from <string>Pushkar N Kulkarni</string> &lt;pushkar.nk at in.ibm.com&gt;<p>March  3, 2016 at 08:00:00pm</p></header><div class="content"><p>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20160303/c4069818/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>False match reported by NSRegularExpression.firstMatchInString()</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>March  4, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi Pushkar,<br></p><p>Yes, let’s get this into a PR and we can finish reviewing it there. Thanks!<br></p><p>- Tony<br></p><p>&gt; On Mar 3, 2016, at 12:23 PM, Pushkar N Kulkarni via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Philippe, other interested people:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Here is the detailed description of an apparent bug in NSRegularExpression along with a possible solution.  Request you to comment on the solution, in the context of correctness and performance. <br>&gt; <br>&gt;  <br>&gt; This is long - please bear with me!  Alternatively, we could discuss this over a pull request if you concur.<br>&gt; <br>&gt; <br>&gt; <br>&gt; ---&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; The following test case has been borrowed from some of those tests in TestNSRegularExpression that aren’t exercised (test_complexRegularExpression) as of today:<br>&gt; <br>&gt; <br>&gt; <br>&gt; import Foundation<br>&gt; <br>&gt; <br>&gt; <br>&gt; let searchStr = &quot;This this is the theway.&quot;<br>&gt; <br>&gt; let testRegex = try NSRegularExpression(pattern: &quot;\\b(th[a-z]+) \\1\\b&quot;, options: [])<br>&gt; <br>&gt; let fm = testRegex.firstMatchInString(searchStr, options: .WithTransparentBounds, range: NSMakeRange(0,20))<br>&gt; <br>&gt; let str = NSString.init(string: searchStr)<br>&gt; <br>&gt; if let match = fm {<br>&gt; <br>&gt;     print(&quot;Test failed&quot;)<br>&gt; <br>&gt;     print(str.substringWithRange(match.range))<br>&gt; <br>&gt; } else {<br>&gt; <br>&gt;     print(&quot;Test passed&quot;)<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; The test fails on Linux - a false match is reported. The substring “the the” matches pattern “\b(th[a-z]+) \1\b” which is wrong because the second “the” does not occur on a word boundary. Note that we are using the option: WithTransparentBounds. This means the matcher can look beyond the search range,  for word boundaries.  <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; The question is why the word boundary metacharacter at the end of the patter isn’t being honoured. I studied the functions _CFRegularExpressionEnumerateMatchesInString() and prepareRegularExpression() from CFRegularExpression.c and these are my findings that provide an explanation for a possible reason:<br>&gt; <br>&gt; <br>&gt; <br>&gt; 1. We first try to get the search text - a UniChar* - using CFStringGetCharactersPtr(). I guess this is done to try improve performance. We copy the entire search text and set regionStart and regionLimit to the search range.<br>&gt; <br>&gt; <br>&gt; <br>&gt; 2. Alternatively, if CFStringGetCharactersPtr() fails, we try to fill the UniChar buffer using CFStringGetCharacters(). Here we try to reduce the size of the search text so that it matches the search range. We use an “enclosingRange” for this. For “transparentBounds” we use the entire text. For nonAnchoringBounds we just take the searchRange plus one character to the left (to match ^) plus one to the right (to match $) :                                                                                                  enclosingRange = range;    <br>&gt; <br>&gt; if (transparentBounds) {<br>&gt; <br>&gt;     enclosingRange = CFRangeMake(0, length);<br>&gt; <br>&gt; } else if (nonAnchoringBounds) {<br>&gt; <br>&gt;     if (enclosingRange.location &gt; 0) {<br>&gt; <br>&gt;         enclosingRange.location--;<br>&gt; <br>&gt;         enclosingRange.length++;<br>&gt; <br>&gt;     }<br>&gt; <br>&gt;     if (enclosingRange.location + enclosingRange.length &lt; length) enclosingRange.length++;<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; We then set regionStart and regionLimit to the search range.<br>&gt; <br>&gt; <br>&gt; <br>&gt; 3. Further we set the search text using the ICU function uregex_setText() like this:                                                                                                                            <br>&gt; <br>&gt;   uregex_setText(regex, (const UChar *)stringBuffer, (int32_t)regionLimit, &amp;errorCode);<br>&gt; <br>&gt;    <br>&gt; Note that we use “regionLimit” for the “textLength”, which seems questionable. This truncates the search text down to a substring matching the specified search range. So, in the above case where the search text is : &quot;This this is the theway.&quot; , using a search range of {0,20} the search text that we actually pass  to ICU is “This this is the the” which matches “\b(th[a-z]+) \1\b”. Though this may not be a problem in most searches, the WithTransparentBounds option fails to take effect. <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; ————————<br>&gt; <br>&gt; The straightforward solution is to simply set the length of the search text to the actual length in prepareRegularExpression() of the search string  as follows: <br>&gt; <br>&gt;  <br>&gt;     int32_t textLength = length; //proposed fix<br>&gt; <br>&gt; <br>&gt; <br>&gt;     …<br>&gt; <br>&gt; <br>&gt; <br>&gt;     if (range.location + range.length &lt;= INT_MAX) stringBuffer = (UniChar *)CFStringGetCharactersPtr(string);<br>&gt; <br>&gt;     if (stringBuffer) {<br>&gt; <br>&gt;         regionStart = (int64_t)range.location;<br>&gt; <br>&gt;         regionLimit = (int64_t)(range.location + range.length);<br>&gt; <br>&gt;         *offset = 0;<br>&gt; <br>&gt;     } else {<br>&gt; <br>&gt;         enclosingRange = range;<br>&gt; <br>&gt;         if (transparentBounds) {<br>&gt; <br>&gt;             enclosingRange = CFRangeMake(0, length);<br>&gt; <br>&gt;         } else if (nonAnchoringBounds) {<br>&gt; <br>&gt;             if (enclosingRange.location &gt; 0) {<br>&gt; <br>&gt;                 enclosingRange.location--;<br>&gt; <br>&gt;                 enclosingRange.length++;<br>&gt; <br>&gt;             }<br>&gt; <br>&gt;             if (enclosingRange.location + enclosingRange.length &lt; length) enclosingRange.length++;<br>&gt; <br>&gt;         }<br>&gt; <br>&gt; <br>&gt; <br>&gt;         …<br>&gt; <br>&gt; <br>&gt; <br>&gt;         regionStart = (int64_t)(range.location - enclosingRange.location);<br>&gt; <br>&gt;         regionLimit = (int64_t)((range.location + range.length) - enclosingRange.location);<br>&gt; <br>&gt;         *offset = enclosingRange.location;<br>&gt; <br>&gt;         if (enclosingRange.length &lt;= STACK_BUFFER_SIZE) {<br>&gt; <br>&gt;             stringBuffer = stackBuffer;<br>&gt; <br>&gt;             if (enclosingRange.length &gt; 0) {<br>&gt; <br>&gt;                 CFStringGetCharacters(string, enclosingRange, stringBuffer);<br>&gt; <br>&gt;             }<br>&gt; <br>&gt;         } else {<br>&gt; <br>&gt;             stringBuffer = (UniChar *)malloc(sizeof(UniChar) * enclosingRange.length);<br>&gt; <br>&gt;             if (stringBuffer) {<br>&gt; <br>&gt;                 CFStringGetCharacters(string, enclosingRange, stringBuffer);<br>&gt; <br>&gt;                 *bufferToFree = stringBuffer;<br>&gt; <br>&gt;             }<br>&gt; <br>&gt;         }<br>&gt; <br>&gt;         textLength = enclosingRange.length;   //proposed fix<br>&gt; <br>&gt;     }<br>&gt; <br>&gt; <br>&gt; <br>&gt;     if (stringBuffer) {<br>&gt; <br>&gt;         regex = checkOutRegularExpression(internal, checkout, checkedOutRegex);<br>&gt; <br>&gt;         uregex_setText(regex, (const UChar *)stringBuffer, textLength, &amp;errorCode);   //proposed fix<br>&gt; <br>&gt;     }<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; Thanks!<br>&gt; <br>&gt; <br>&gt; Pushkar N Kulkarni,<br>&gt; IBM Runtimes<br>&gt;  <br>&gt; &quot;Any sufficiently advanced technology is indistinguishable from magic.&quot; - Arthur Clarke<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20160304/9ebe59c0/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
