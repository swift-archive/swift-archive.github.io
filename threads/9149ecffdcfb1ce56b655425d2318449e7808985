<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b9904260218b6d7942782c2b2355f2aa?s=50"></div><header><strong>[proposal]Decouple definition of Int8 from target char type</strong> from <string>William Dillon</string> &lt;william at housedillon.com&gt;<p>February 25, 2016 at 07:00:00pm</p></header><div class="content"><p>Hi All,<br></p><p>(For best viewing, use a fixed-width font with this email)<br></p><p>While porting Swift to ARM/Linux (and while observing other ports, such as SwiftAndroid) several of my collaborators and I have noticed inconsistencies in the handling of char.  I’ve taken the liberty of producing a table to summarize these differences that will hopefully illuminate the problem.<br></p><p>char           ARM         mips         ppc        ppc64       i386      x86_64<br>Linux/ELF  unsigned[1]  unsigned[2]  unsigned[3] unsigned[4] signed[5] signed[6]<br>Mach-O       signed[7]     N/A        signed[7]   signed[7]  signed[7] signed[7]<br>Windows    —=-=-=-=-=-=-=-=-=-=-=-=-=-=- signed —=-=-=-=-=-=-=-=-=-=-=-=-=-=-[8]<br></p><p>Swift currently maps the Int8 type to be equal to the char type of the target platform.  On targets where char is unsigned by default, Int8 becomes an unsigned 8-bit integer, which is a clear violation of the Principle of Least Astonishment.  Furthermore, it is impossible to specify a signed 8-bit integer type on platforms with unsigned chars.<br></p><p>This proposal aims to address the problem by defining the CChar type to equal whatever type the target defines as char.  Further, Int8 and UInt8 will always be their advertised signedness.  The current status quo requires extensive special-casing (or casting) for compilation to succeed, and if it does, the tests require specialization to the underlying type of the target device.<br></p><p>We have come across this issue several times during code review of our patches, and I’ve included a sampling of these to provide some context to the discussion:<br></p><p>https://github.com/apple/swift/pull/1103<br>https://github.com/apple/swift-corelibs-foundation/pull/265<br></p><p>In these discussions we obviously struggle to adequately solve the issues at hand without introducing the changes proposed here.  Furthermore, other than completely disabling the test, there is no other satisfactory way to make the last remaining failure on Linux/ARM (c_layout.sil) pass.<br></p><p>The implementation of this proposal requires changes to the way Swift imports these types.  The impact of these changes will be fully evaluated, and an sample implementation will likely be complete, prior to the submission of this proposal for scheduling and consideration.  We do anticipate some changes to user code, the standard library, and Foundation may be required.<br></p><p>These changes should happen during a major release.  Considering them for Swift 3 will enable us to move forward efficiently while constraining any source incompatibilities to transitions where users expect them.  A stated goal of Swift 3 is to improve portability, and these changes are, to us, necessary to consider such a goal a success.   Code that works properly on each of these platforms now is already resilient to changes in the implementation of char, and should continue to work.  Further, the implementation of this proposal will identify cases where such a problem exists, but for which the symptoms have not yet been identified.<br></p><p>The proposed new mapping of types is as follows:<br></p><p>    C type    |   Swift type<br>-=-=-=-=-=-=-=-=-=-=-=-=-=-=-<br>         char |   CChar<br>unsigned char |   UInt8<br>  signed char |    Int8<br></p><p>I appreciate any comments, concerns, or questions.<br>Thanks,<br>- Will<br></p><p>[1]: http://www.eecs.umich.edu/courses/eecs373/readings/ARM-AAPCS-EABI-v2.08.pdf<br>[2]: http://math-atlas.sourceforge.net/devel/assembly/mipsabi32.pdf<br>[3]: https://uclibc.org/docs/psABI-ppc.pdf<br>[4]: http://refspecs.linuxfoundation.org/ELF/ppc64/PPC-elf64abi.html<br>[5]: http://www.sco.com/developers/devspecs/abi386-4.pdf<br>[6]: http://www.x86-64.org/documentation/abi.pdf<br>[7]: *proof by construction* (is it signed by convention?)<br>$ cat test.c<br>char _char(char a) { return a; }<br>signed char _schar(signed char a) { return a; }<br>unsigned char _uchar(unsigned char a) { return a; }<br></p><p>$ clang -S -emit-llvm -target &lt;arch&gt;-unknown-{windows,darwin}<br></p><p>and look for “signext” OR “zeroext&quot; in @_char definition<br></p><p>[8]: Windows char is signed by convention.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[proposal]Decouple definition of Int8 from target char type</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>February 25, 2016 at 08:00:00pm</p></header><div class="content"><p>On Thu, Feb 25, 2016 at 7:47 PM, William Dillon via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hi All,<br>&gt;<br>&gt; (For best viewing, use a fixed-width font with this email)<br>&gt;<br>&gt; While porting Swift to ARM/Linux (and while observing other ports, such as SwiftAndroid) several of my collaborators and I have noticed inconsistencies in the handling of char.  I’ve taken the liberty of producing a table to summarize these differences that will hopefully illuminate the problem.<br>&gt;<br>&gt; char           ARM         mips         ppc        ppc64       i386      x86_64<br>&gt; Linux/ELF  unsigned[1]  unsigned[2]  unsigned[3] unsigned[4] signed[5] signed[6]<br>&gt; Mach-O       signed[7]     N/A        signed[7]   signed[7]  signed[7] signed[7]<br>&gt; Windows    —=-=-=-=-=-=-=-=-=-=-=-=-=-=- signed —=-=-=-=-=-=-=-=-=-=-=-=-=-=-[8]<br>&gt;<br>&gt; Swift currently maps the Int8 type to be equal to the char type of the target platform.  On targets where char is unsigned by default, Int8 becomes an unsigned 8-bit integer, which is a clear violation of the Principle of Least Astonishment.  Furthermore, it is impossible to specify a signed 8-bit integer type on platforms with unsigned chars.<br></p><p>I&#39;m probably misunderstanding you, but are you sure that&#39;s what is<br>happening?  I can&#39;t imagine how the standard library would just<br>silently make Int8 unsigned on Linux arm.<br></p><p>What I would expect to happen is that on Linux arm the Clang importer<br>would map &#39;char&#39; to UInt8, instead of mapping it to Int8 like it does<br>on x86_64.<br></p><p>&gt;     C type    |   Swift type<br>&gt; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-<br>&gt;          char |   CChar<br>&gt; unsigned char |   UInt8<br>&gt;   signed char |    Int8<br></p><p>This brings in the notion of the CChar type, and requires us to define<br>(hopefully!) some rules for type-based aliasing, since you want to be<br>able to freely cast UnsafePointer&lt;CChar&gt; to UnsafePointer&lt;UInt8&gt; or<br>UnsafePointer&lt;Int8&gt;.<br></p><p>What about a proposal where we would always map &#39;char&#39; to Int8,<br>regardless of the C&#39;s idea of signedness?<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
