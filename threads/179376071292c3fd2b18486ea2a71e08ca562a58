<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft Proposal] Require `final` on protocol extension members</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January  4, 2016 at 04:00:00am</p></header><div class="content"><p>Now that everyone&#39;s presumably back from vacation, I figured I&#39;d repost this proposal.<br></p><p>(If nobody has any comments, how can I get the ball rolling on starting a review?)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p><p><br></p><p>I&#39;ve been working on this on-and-off for a few weeks, and I&#39;ve finished drafting a formal proposal. Comments welcome.<br></p><p>&lt;https://github.com/brentdax/swift-evolution/blob/final-protocol-methods/proposals/0000-require-final-on-protocol-extension-methods.md&gt;<br></p><p><br></p><p># Require `final` on protocol extension members<br></p><p>## Introduction<br></p><p>Protocol extension members which aren&#39;t listed in the protocol itself have an unusual behavior: a conforming type can implement an identically named member, but instances with the protocol&#39;s type are always statically dispatched to the protocol&#39;s implementation. This can lead to the same instance displaying different behavior when it&#39;s cast to a  protocol it conforms to. In effect, the conforming type&#39;s member shadows the protocol&#39;s, rather than overriding it. This behavior is very surprising to some users.<br></p><p>The lack of a warning on this is [currently considered a bug](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001861.html), but I think we should go further and cause it to be an error. However, we should also provide an escape hatch which permits conflicts in cases where they&#39;re necessary.<br></p><p>## Motivation<br></p><p>Suppose you write a protocol and extension like this:<br></p><p>	protocol Turnable {<br>	    func turning() -&gt; Self<br>	    mutating func turn()<br>	}<br>	extension Turnable {<br>	    mutating func turn() {<br>	        self = turning()<br>	    }<br>	<br>	    func turningRepeatedly(additionalTurns: Int) -&gt; Self {<br>	        var turnedSelf = self<br>	        for _ in 1...additionalTurns {<br>	            turnedSelf.turn()<br>	        }<br>	        return turnedSelf<br>	    }<br>	}<br></p><p>Now you want to write a conforming type, `SpimsterWicket`. There are three different rules about whether your type has to, or can, implement its own versions of these methods.<br></p><p>1. `turning()` is a “protocol method”: it is listed in the protocol but is not included in the extension. You *must* implement `turning()` to conform to `Turnable`.<br>2. `turn()` is a “defaulted protocol method”: it is listed in the protocol but there is also an implementation of it in the extension. You *may* implement `turn()`; if you don’t, the protocol extension’s implementation will be used.<br>3. `turningRepeatedly(_: Int)` is a “protocol extension method”: it is *not* listed in the protocol, but only in the protocol extension. This is the case we are trying to address.<br></p><p>Currently, in case 3, Swift permits you to implement your own `turningRepeatedly(_: Int)`. However, your implementation may not be called in every circumstance that you expect. If you call `turningRepeatedly` on a variable of type `SpimsterWicket`, you’ll get `SpimsterWicket`’s implementation of the method; however, if you call `turningRepeatedly` on a variable of type `Turnable`, you’ll get `Turnable`’s implementation of the method.<br></p><p>	var wicket: SpimsterWicket = SpimsterWicket()<br>	var turnable: Turnable = wicket<br>	<br>	wicket.turn()					// Calls SpimsterWicket.turn()<br>	turnable.turn()					// Also calls SpimsterWicket.turn()<br>	<br>	wicket.turningRepeatedly(5)		// Calls SpimsterWicket.turningRepeatedly(_:)<br>	turnable.turningRepeatedly(5)	// Calls Turnable.turningRepeatedly(_:)<br></p><p>In most parts of Swift, casting an instance or assigning it to a variable of a different type doesn’t change which implementation will be called when you put it on the left-hand side of a dot. (I’m leaving aside Objective-C bridging, like `Int` to `NSNumber`, which is really a different operation being performed with the same syntax.) If you put a `UIControl` into a variable of type `UIView`, and then call `touchesBegan()` on that variable, Swift will still call `UIControl.touchesBegan()`. The same is true of defaulted protocol methods—if you call `turn()` on `turnable`, you’ll get `SpimsterWicket.turn()`.<br></p><p>But this is not true of protocol extension methods. There, the static type of the variable—the type known at compile time, the type that the variable is labeled with—is used. Thus, calling `turningRepeatedly(_:)` on `wicket` gets you `SpimsterWicket`’s implementation, but calling it on `turnable`—even though it&#39;s merely the same instance casted to a different type—gets you `Turnable`’s implementation.<br></p><p>This creates what I call an “incoherent” dispatch, and it occurs nowhere else in Swift. In most places in Swift, method dispatch is either based on the runtime type (reference types, normal protocol members), or the design of the language ensures there’s no difference between dispatching on the compile-time type and the runtime type (value types, `final` members). But in protocol extension members, dispatch is based on the compile-time type even though the runtime type might produce different behavior.<br></p><p>## Proposed solution<br></p><p>I propose that we:<br></p><p>1. Cause Swift to emit an error when it detects this sort of conflict.<br>2. Add a mandatory `final` keyword to statically-dispatched protocol extension members, to give a textual indication that these errors will occur.<br>3. For those circumstances in which this conflict is a necessary evil, provide an attribute which can be applied to indicate that conflicts are allowed when caused by a particular conformance.<br></p><p>Specifics follow, though not in the order given above. In the examples below, `T` and `U` are conforming types, `P` and `Q` are protocols, and `f` is a member which, in some cases, may be a final protocol extension member.<br></p><p>### Mark protocol extension members with the `final` keyword<br></p><p>If we are going to emit an error for these conflicts, it would be helpful to mark which members are prone to them.<br></p><p>I therefore propose that all protocol extension members (that is, the ones that aren&#39;t providing a default implementation for a protocol requirement) be marked with the `final` keyword. Failing to mark such a member with `final` would cause an error.<br></p><p>Currently, the `final` keyword is only used on classes. When applied to a class&#39;s member, it indicates that subclasses cannot override that member. I see this new use of the `final` keyword as analogously indicating that conforming types cannot customize the member. In fact, you can capture both meanings of `final` in a single statement:<br></p><p>&gt; `final` declares that subtypes of this type must use this specific implementation of the member, and cannot substitute their own specialized implementation. Attempting to do so causes an error.<br></p><p>### Make conflicting with a `final` protocol extension method an error<br></p><p>We can now define an incoherent type as one in which a `final` protocol extension member is shadowed by a member of a conforming type, as seen from any source file. (Note that methods and subscripts are only shadowed by a member with a matching signature.)<br></p><p>Because incoherence is caused by the interaction of two separate declarations, there are many different circumstances in which incoherence may be caused. Here are the ones I&#39;ve been able to think of:<br></p><p>1. Type `T` is conformed to protocol `P` in a file where member `f` is visible on both `T` and `P`.<br>2. Type `T` is conformed to protocols `P` and `Q`, which both have a final member `f`. (Note that diamond conformance patterns, where `P` and `Q` both get the same final member `f` from protocol `R`, should be permitted.)<br>3. Type `T` is extended to add a member `f` in a file where `T`&#39;s conformance to `P` is imported from another module, and `P` has a final member `f`.<br>4. Protocol `P` is extended to add final member `f` in a file where `T`&#39;s conformance to `P`, and the declaration of `T.f`, are both imported from other modules.<br>5. A source file imports module A, which extends protocol `P` to include final member `f`, and module B, which conforms type `T` with member `f` to conform to `P`.<br></p><p>It should be noted that these conflicts are tied to *visibility*. There is no conflict if the two definitions of `f` are not both visible in  the same place. For instance:<br></p><p>- If file A.swift extends `T` with a private member `f`, and file B.swift extends `P` with a private final member `f`, there is no conflict.<br>- If module A extends `T` with an internal member `f`, and module B extends `P` with an internal final member `f`, there is no conflict.<br>- If module A extends `T` with a *public* member `f`, and module B extends `P` with a public final member `f`, there is only a conflict if A and B are imported in the same file. Even if A and B are imported in different files in the same module, there is no conflict.<br></p><p>### Permit conflicts with an explicit acknowledgement through an `@incoherent` attribute<br></p><p>In some circumstances, it may be desirable to permit a conflict, even though it causes surprising behavior. For instance, you may want to conform an existing type to a protocol where the names conflict through sheer happenstance, and you know the protocol extension method will only ever be needed in code that treats that uses the protocol&#39;s type. In those cases, you can disable the conflict error and restore the current incoherent dispatch behavior using an `@incoherent` attribute.<br></p><p>The `@incoherent` attribute is always tied to a particular type and protocol. It says, in essence, &quot;I know type T conflicts with protocol P, and I want to ignore all of those conflicts and accept incoherent dispatch.&quot; Depending on where it&#39;s attached, you may have to specify more or less information in the attribute&#39;s parameters. For instance:<br></p><p>	// Mark the conformance.<br>	extension T: @incoherent P {...}<br>	<br>	// Mark the extension.<br>	@incoherent(T) extension P {...}<br>	@incoherent(P) extension T {...}<br>	<br>	// Mark the import statement<br>	@incoherent(T: P) import B<br></p><p>## Detailed design<br></p><p>### Errors for improper use of the `final` keyword<br></p><p>Failing to put a `final` keyword on a protocol extension member which requires it should emit an error message along these lines:<br></p><p>&gt; f must be final because it is not a requirement of P.<br></p><p>This error should include a fix-it which adds the `final` keyword.<br></p><p>Putting a `final` keyword on a defaulted protocol member is nonsensical—it essentially gives the member the semantics of a protocol extension member. We should emit an error message along these lines:<br></p><p>&gt; f cannot be final because it is a requirement of P.<br></p><p>This error should include a fix-it which removes the `final` keyword.<br></p><p>### Errors for conflicting members<br></p><p>As mentioned above, there are many ways to cause a conflict, and each of them needs a slightly different wording. Here&#39;s what I propose:<br></p><p>1. **Type `T` is conformed to protocol `P` in a file where member `f` is visible on both `T` and `P`.** The declaration of the conformance (that is, the declaration with the `: P` clause) should be marked with an error like:<br></p><p>&gt; T cannot conform to P because T.f conflicts with final member P.f.<br>	<br>2. **Type `T` is conformed to protocols `P` and `Q`, which both have a final member `f`.** The declaration of one of the conformances should be marked with an error like:<br></p><p>&gt; T cannot conform to both P and Q because final member P.f conflicts with final member Q.f.<br></p><p>3. **Type `T` is extended to add a member `f` in a file where `T`&#39;s conformance to `P` is imported from another module, and `P` has a final member `f`.** The declaration of the concrete type extension should be marked with an error like:<br></p><p>&gt; T cannot be extended to add member f because it conflicts with final member P.f.<br></p><p>4. **Protocol `P` is extended to add final member `f` in a file where `T`&#39;s conformance to `P`, and the declaration of `T.f`, are both imported from other modules.** The declaration of the protocol extension should be marked with an error like:<br></p><p>&gt; P cannot be extended to add final member f because it conflicts with member T.f of a conforming type.<br>	<br>5. **A source file imports module A, which extends protocol `P` to include final member `f`, and module B, which conforms type `T` with member `f` to conform to `P`.** The later of the two imports should be marked with an error like:<br></p><p>&gt; B cannot be imported because final member P.f conflicts with A&#39;s T.f.<br></p><p>The preferred means of resolving a conflict include:<br></p><p>- Renaming one of the conflicting members.<br>- Deleting one of the conflicting members.<br>- Deleting an `import` statement which causes the conflict.<br>- Adding the conflicting member to the protocol, and removing the `final` keyword, so that it becomes a defaulted protocol member.<br></p><p>If it is feasible to provide a fix-it suggesting one of these solutions, that should be done.<br></p><p>Fix-its should *not* suggest adding an `@incoherent` attribute. It is sometimes necessary to permit incoherence, but it&#39;s never desirable, because incoherence is confusing. A fix-it would encourage users to enable incoherence without actually understanding what it means, which will cause confusion.<br></p><p>### Marking multiple `@incoherent` types<br></p><p>In places where one parameter to the `@incoherent` attribute is permitted, you can instead provide a comma-separated list to permit several different incoherences caused by the same declaration:<br></p><p>	@incoherent(T, U) extension P {...}<br>	@incoherent(P, Q) extension T {...}<br>	<br>	@incoherent(T: P, U: Q) import B<br></p><p>## Impact on existing code<br></p><p>The requirement that `final` be applied to many protocol extension methods will cause many—perhaps most—protocol extensions to stop compiling without changes. However, the changes needed—adding a keyword to the declarations of relevant members—are fairly mechanical and are fix-it guided. The migrator should add them automatically.<br></p><p>The conflict errors will cause a smaller number of conformance declarations, protocol extensions, or `import` statements to fail to compile. I believe that many of these cases will be bugs, and users will want to rename members to avoid them. When users do not want to rename, they can preserve the existing semantics with an `@incoherent` attribute.<br></p><p>Because this is primarily a safety feature, does not change runtime semantics, and, in most codebases, all changes will be purely mechanical, I believe this feature should be added to the next minor version of Swift, rather than waiting for 3.0.<br></p><p>## Alternatives considered<br></p><p>### Dynamically dispatch calls to protocol extension members<br></p><p>This would fix the underlying problem—the confusing behavior—by making protocol extension members not behave confusingly.<br></p><p>This would likely take a redesign of protocol witnesses to include extension methods not listed in the original protocol. It&#39;s probably not impossible—class extensions behave this way—but it&#39;s a much bigger change than what I propose, which keeps the current runtime semantics and only adds compile-time errors and keywords.<br></p><p>Dynamically dispatching to protocol extension members would also change the performance characteristics of these calls. Even if this change were made, we might want to allow users to apply `final` to extension methods which they want to be dispatched statically.<br></p><p>### Don&#39;t provide an `@incoherent` attribute<br></p><p>This would improve safety by making this confusing construct completely impossible to write. However, it would also make it completely impossible to conform certain types to certain protocols or import certain combinations of modules into the same file. This seems especially unwise because previous versions of Swift have actually permitted this shadowing; code that previously compiled without even a warning could be difficult to port.<br></p><p>### Mark default members instead of statically dispatched members<br></p><p>This would invert the keywording in a protocol extension: instead of marking the statically-dispatched members with `final`, you would mark the overridable members with `default`.<br></p><p>I prefer `final` because it marks the more unusual case. Users are not surprised that they can override default methods; they are surprised that they *can&#39;t* reliably override protocol extension methods. Also, as mentioned in the previous section, I could see `final` being retained even if protocol extension methods gained dynamic dispatch.<br></p><p>However, my preference is not terribly strong, and using `default` on the overridable methods is not a bad option.<br></p><p>### Require a `final` keyword, but don&#39;t prevent conflicts with an error<br></p><p>The problem with this approach is that the conflict is the surprising part. It doesn&#39;t matter all that much whether protocol extension members are dispatched statically or dynamically *except* if there&#39;s a conflict; *then* you&#39;re getting into potential bug territory. The `@incoherent` keyword is what makes this mistake impossible to make accidentally; without it, this is merely a proposal to force people to annotate their protocol extensions more clearly.<br></p><p>### Don&#39;t require a `final` keyword, but prevent conflicts with an error<br></p><p>Without the `final` keyword (or the `default` alternative mentioned above) on the extension members themselves, it&#39;s impossible to tell at a glance which members are overridable and which ones aren&#39;t. This makes predicting incoherent conformance errors an exercise in trial-and-error, or at least in visual-diffing two separate parts of the code to figure out what&#39;s going on. Without the `final` keyword, in other words, avoiding conflicts when you write your code instead of discovering them when you compile it is much more difficult.<br></p><p>### Mark specific conflicting members<br></p><p>Rather than marking an entire conformance as permitted to allow conflicts, we could force users to mark specific conflicting members. For instance, in the `Turnable`/`SpimsterWicket` example used above, `turningRepeatedly(_:)` itself would have to be marked in some way.<br></p><p>The main issue I see is that, in many cases, a conformance is added in a different file or even module than the conflicting declaration, so there&#39;s no convenient place to put the attribute. This is basically the same reason there&#39;s no equivalent of `override` for implementations of protocol methods.<br></p><p>This would also require more declarations, but I don&#39;t necessarily think that would be a bad thing.<br></p><p><br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Draft Proposal] Require `final` on protocol extension members</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January  5, 2016 at 07:00:00am</p></header><div class="content"><p>+1, adds nice clarity<br></p><p>&gt; On 4 Jan 2016, at 11:28 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Now that everyone&#39;s presumably back from vacation, I figured I&#39;d repost this proposal.<br>&gt; <br>&gt; (If nobody has any comments, how can I get the ball rolling on starting a review?)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; <br>&gt; <br>&gt; I&#39;ve been working on this on-and-off for a few weeks, and I&#39;ve finished drafting a formal proposal. Comments welcome.<br>&gt; <br>&gt; &lt;https://github.com/brentdax/swift-evolution/blob/final-protocol-methods/proposals/0000-require-final-on-protocol-extension-methods.md&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; # Require `final` on protocol extension members<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; Protocol extension members which aren&#39;t listed in the protocol itself have an unusual behavior: a conforming type can implement an identically named member, but instances with the protocol&#39;s type are always statically dispatched to the protocol&#39;s implementation. This can lead to the same instance displaying different behavior when it&#39;s cast to a  protocol it conforms to. In effect, the conforming type&#39;s member shadows the protocol&#39;s, rather than overriding it. This behavior is very surprising to some users.<br>&gt; <br>&gt; The lack of a warning on this is [currently considered a bug](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001861.html), but I think we should go further and cause it to be an error. However, we should also provide an escape hatch which permits conflicts in cases where they&#39;re necessary.<br>&gt; <br>&gt; ## Motivation<br>&gt; <br>&gt; Suppose you write a protocol and extension like this:<br>&gt; <br>&gt; 	protocol Turnable {<br>&gt; 	    func turning() -&gt; Self<br>&gt; 	    mutating func turn()<br>&gt; 	}<br>&gt; 	extension Turnable {<br>&gt; 	    mutating func turn() {<br>&gt; 	        self = turning()<br>&gt; 	    }<br>&gt; 	<br>&gt; 	    func turningRepeatedly(additionalTurns: Int) -&gt; Self {<br>&gt; 	        var turnedSelf = self<br>&gt; 	        for _ in 1...additionalTurns {<br>&gt; 	            turnedSelf.turn()<br>&gt; 	        }<br>&gt; 	        return turnedSelf<br>&gt; 	    }<br>&gt; 	}<br>&gt; <br>&gt; Now you want to write a conforming type, `SpimsterWicket`. There are three different rules about whether your type has to, or can, implement its own versions of these methods.<br>&gt; <br>&gt; 1. `turning()` is a “protocol method”: it is listed in the protocol but is not included in the extension. You *must* implement `turning()` to conform to `Turnable`.<br>&gt; 2. `turn()` is a “defaulted protocol method”: it is listed in the protocol but there is also an implementation of it in the extension. You *may* implement `turn()`; if you don’t, the protocol extension’s implementation will be used.<br>&gt; 3. `turningRepeatedly(_: Int)` is a “protocol extension method”: it is *not* listed in the protocol, but only in the protocol extension. This is the case we are trying to address.<br>&gt; <br>&gt; Currently, in case 3, Swift permits you to implement your own `turningRepeatedly(_: Int)`. However, your implementation may not be called in every circumstance that you expect. If you call `turningRepeatedly` on a variable of type `SpimsterWicket`, you’ll get `SpimsterWicket`’s implementation of the method; however, if you call `turningRepeatedly` on a variable of type `Turnable`, you’ll get `Turnable`’s implementation of the method.<br>&gt; <br>&gt; 	var wicket: SpimsterWicket = SpimsterWicket()<br>&gt; 	var turnable: Turnable = wicket<br>&gt; 	<br>&gt; 	wicket.turn()					// Calls SpimsterWicket.turn()<br>&gt; 	turnable.turn()					// Also calls SpimsterWicket.turn()<br>&gt; 	<br>&gt; 	wicket.turningRepeatedly(5)		// Calls SpimsterWicket.turningRepeatedly(_:)<br>&gt; 	turnable.turningRepeatedly(5)	// Calls Turnable.turningRepeatedly(_:)<br>&gt; <br>&gt; In most parts of Swift, casting an instance or assigning it to a variable of a different type doesn’t change which implementation will be called when you put it on the left-hand side of a dot. (I’m leaving aside Objective-C bridging, like `Int` to `NSNumber`, which is really a different operation being performed with the same syntax.) If you put a `UIControl` into a variable of type `UIView`, and then call `touchesBegan()` on that variable, Swift will still call `UIControl.touchesBegan()`. The same is true of defaulted protocol methods—if you call `turn()` on `turnable`, you’ll get `SpimsterWicket.turn()`.<br>&gt; <br>&gt; But this is not true of protocol extension methods. There, the static type of the variable—the type known at compile time, the type that the variable is labeled with—is used. Thus, calling `turningRepeatedly(_:)` on `wicket` gets you `SpimsterWicket`’s implementation, but calling it on `turnable`—even though it&#39;s merely the same instance casted to a different type—gets you `Turnable`’s implementation.<br>&gt; <br>&gt; This creates what I call an “incoherent” dispatch, and it occurs nowhere else in Swift. In most places in Swift, method dispatch is either based on the runtime type (reference types, normal protocol members), or the design of the language ensures there’s no difference between dispatching on the compile-time type and the runtime type (value types, `final` members). But in protocol extension members, dispatch is based on the compile-time type even though the runtime type might produce different behavior.<br>&gt; <br>&gt; ## Proposed solution<br>&gt; <br>&gt; I propose that we:<br>&gt; <br>&gt; 1. Cause Swift to emit an error when it detects this sort of conflict.<br>&gt; 2. Add a mandatory `final` keyword to statically-dispatched protocol extension members, to give a textual indication that these errors will occur.<br>&gt; 3. For those circumstances in which this conflict is a necessary evil, provide an attribute which can be applied to indicate that conflicts are allowed when caused by a particular conformance.<br>&gt; <br>&gt; Specifics follow, though not in the order given above. In the examples below, `T` and `U` are conforming types, `P` and `Q` are protocols, and `f` is a member which, in some cases, may be a final protocol extension member.<br>&gt; <br>&gt; ### Mark protocol extension members with the `final` keyword<br>&gt; <br>&gt; If we are going to emit an error for these conflicts, it would be helpful to mark which members are prone to them.<br>&gt; <br>&gt; I therefore propose that all protocol extension members (that is, the ones that aren&#39;t providing a default implementation for a protocol requirement) be marked with the `final` keyword. Failing to mark such a member with `final` would cause an error.<br>&gt; <br>&gt; Currently, the `final` keyword is only used on classes. When applied to a class&#39;s member, it indicates that subclasses cannot override that member. I see this new use of the `final` keyword as analogously indicating that conforming types cannot customize the member. In fact, you can capture both meanings of `final` in a single statement:<br>&gt; <br>&gt;&gt; `final` declares that subtypes of this type must use this specific implementation of the member, and cannot substitute their own specialized implementation. Attempting to do so causes an error.<br>&gt; <br>&gt; ### Make conflicting with a `final` protocol extension method an error<br>&gt; <br>&gt; We can now define an incoherent type as one in which a `final` protocol extension member is shadowed by a member of a conforming type, as seen from any source file. (Note that methods and subscripts are only shadowed by a member with a matching signature.)<br>&gt; <br>&gt; Because incoherence is caused by the interaction of two separate declarations, there are many different circumstances in which incoherence may be caused. Here are the ones I&#39;ve been able to think of:<br>&gt; <br>&gt; 1. Type `T` is conformed to protocol `P` in a file where member `f` is visible on both `T` and `P`.<br>&gt; 2. Type `T` is conformed to protocols `P` and `Q`, which both have a final member `f`. (Note that diamond conformance patterns, where `P` and `Q` both get the same final member `f` from protocol `R`, should be permitted.)<br>&gt; 3. Type `T` is extended to add a member `f` in a file where `T`&#39;s conformance to `P` is imported from another module, and `P` has a final member `f`.<br>&gt; 4. Protocol `P` is extended to add final member `f` in a file where `T`&#39;s conformance to `P`, and the declaration of `T.f`, are both imported from other modules.<br>&gt; 5. A source file imports module A, which extends protocol `P` to include final member `f`, and module B, which conforms type `T` with member `f` to conform to `P`.<br>&gt; <br>&gt; It should be noted that these conflicts are tied to *visibility*. There is no conflict if the two definitions of `f` are not both visible in  the same place. For instance:<br>&gt; <br>&gt; - If file A.swift extends `T` with a private member `f`, and file B.swift extends `P` with a private final member `f`, there is no conflict.<br>&gt; - If module A extends `T` with an internal member `f`, and module B extends `P` with an internal final member `f`, there is no conflict.<br>&gt; - If module A extends `T` with a *public* member `f`, and module B extends `P` with a public final member `f`, there is only a conflict if A and B are imported in the same file. Even if A and B are imported in different files in the same module, there is no conflict.<br>&gt; <br>&gt; ### Permit conflicts with an explicit acknowledgement through an `@incoherent` attribute<br>&gt; <br>&gt; In some circumstances, it may be desirable to permit a conflict, even though it causes surprising behavior. For instance, you may want to conform an existing type to a protocol where the names conflict through sheer happenstance, and you know the protocol extension method will only ever be needed in code that treats that uses the protocol&#39;s type. In those cases, you can disable the conflict error and restore the current incoherent dispatch behavior using an `@incoherent` attribute.<br>&gt; <br>&gt; The `@incoherent` attribute is always tied to a particular type and protocol. It says, in essence, &quot;I know type T conflicts with protocol P, and I want to ignore all of those conflicts and accept incoherent dispatch.&quot; Depending on where it&#39;s attached, you may have to specify more or less information in the attribute&#39;s parameters. For instance:<br>&gt; <br>&gt; 	// Mark the conformance.<br>&gt; 	extension T: @incoherent P {...}<br>&gt; 	<br>&gt; 	// Mark the extension.<br>&gt; 	@incoherent(T) extension P {...}<br>&gt; 	@incoherent(P) extension T {...}<br>&gt; 	<br>&gt; 	// Mark the import statement<br>&gt; 	@incoherent(T: P) import B<br>&gt; <br>&gt; ## Detailed design<br>&gt; <br>&gt; ### Errors for improper use of the `final` keyword<br>&gt; <br>&gt; Failing to put a `final` keyword on a protocol extension member which requires it should emit an error message along these lines:<br>&gt; <br>&gt;&gt; f must be final because it is not a requirement of P.<br>&gt; <br>&gt; This error should include a fix-it which adds the `final` keyword.<br>&gt; <br>&gt; Putting a `final` keyword on a defaulted protocol member is nonsensical—it essentially gives the member the semantics of a protocol extension member. We should emit an error message along these lines:<br>&gt; <br>&gt;&gt; f cannot be final because it is a requirement of P.<br>&gt; <br>&gt; This error should include a fix-it which removes the `final` keyword.<br>&gt; <br>&gt; ### Errors for conflicting members<br>&gt; <br>&gt; As mentioned above, there are many ways to cause a conflict, and each of them needs a slightly different wording. Here&#39;s what I propose:<br>&gt; <br>&gt; 1. **Type `T` is conformed to protocol `P` in a file where member `f` is visible on both `T` and `P`.** The declaration of the conformance (that is, the declaration with the `: P` clause) should be marked with an error like:<br>&gt; <br>&gt;&gt; T cannot conform to P because T.f conflicts with final member P.f.<br>&gt; 	<br>&gt; 2. **Type `T` is conformed to protocols `P` and `Q`, which both have a final member `f`.** The declaration of one of the conformances should be marked with an error like:<br>&gt; <br>&gt;&gt; T cannot conform to both P and Q because final member P.f conflicts with final member Q.f.<br>&gt; <br>&gt; 3. **Type `T` is extended to add a member `f` in a file where `T`&#39;s conformance to `P` is imported from another module, and `P` has a final member `f`.** The declaration of the concrete type extension should be marked with an error like:<br>&gt; <br>&gt;&gt; T cannot be extended to add member f because it conflicts with final member P.f.<br>&gt; <br>&gt; 4. **Protocol `P` is extended to add final member `f` in a file where `T`&#39;s conformance to `P`, and the declaration of `T.f`, are both imported from other modules.** The declaration of the protocol extension should be marked with an error like:<br>&gt; <br>&gt;&gt; P cannot be extended to add final member f because it conflicts with member T.f of a conforming type.<br>&gt; 	<br>&gt; 5. **A source file imports module A, which extends protocol `P` to include final member `f`, and module B, which conforms type `T` with member `f` to conform to `P`.** The later of the two imports should be marked with an error like:<br>&gt; <br>&gt;&gt; B cannot be imported because final member P.f conflicts with A&#39;s T.f.<br>&gt; <br>&gt; The preferred means of resolving a conflict include:<br>&gt; <br>&gt; - Renaming one of the conflicting members.<br>&gt; - Deleting one of the conflicting members.<br>&gt; - Deleting an `import` statement which causes the conflict.<br>&gt; - Adding the conflicting member to the protocol, and removing the `final` keyword, so that it becomes a defaulted protocol member.<br>&gt; <br>&gt; If it is feasible to provide a fix-it suggesting one of these solutions, that should be done.<br>&gt; <br>&gt; Fix-its should *not* suggest adding an `@incoherent` attribute. It is sometimes necessary to permit incoherence, but it&#39;s never desirable, because incoherence is confusing. A fix-it would encourage users to enable incoherence without actually understanding what it means, which will cause confusion.<br>&gt; <br>&gt; ### Marking multiple `@incoherent` types<br>&gt; <br>&gt; In places where one parameter to the `@incoherent` attribute is permitted, you can instead provide a comma-separated list to permit several different incoherences caused by the same declaration:<br>&gt; <br>&gt; 	@incoherent(T, U) extension P {...}<br>&gt; 	@incoherent(P, Q) extension T {...}<br>&gt; 	<br>&gt; 	@incoherent(T: P, U: Q) import B<br>&gt; <br>&gt; ## Impact on existing code<br>&gt; <br>&gt; The requirement that `final` be applied to many protocol extension methods will cause many—perhaps most—protocol extensions to stop compiling without changes. However, the changes needed—adding a keyword to the declarations of relevant members—are fairly mechanical and are fix-it guided. The migrator should add them automatically.<br>&gt; <br>&gt; The conflict errors will cause a smaller number of conformance declarations, protocol extensions, or `import` statements to fail to compile. I believe that many of these cases will be bugs, and users will want to rename members to avoid them. When users do not want to rename, they can preserve the existing semantics with an `@incoherent` attribute.<br>&gt; <br>&gt; Because this is primarily a safety feature, does not change runtime semantics, and, in most codebases, all changes will be purely mechanical, I believe this feature should be added to the next minor version of Swift, rather than waiting for 3.0.<br>&gt; <br>&gt; ## Alternatives considered<br>&gt; <br>&gt; ### Dynamically dispatch calls to protocol extension members<br>&gt; <br>&gt; This would fix the underlying problem—the confusing behavior—by making protocol extension members not behave confusingly.<br>&gt; <br>&gt; This would likely take a redesign of protocol witnesses to include extension methods not listed in the original protocol. It&#39;s probably not impossible—class extensions behave this way—but it&#39;s a much bigger change than what I propose, which keeps the current runtime semantics and only adds compile-time errors and keywords.<br>&gt; <br>&gt; Dynamically dispatching to protocol extension members would also change the performance characteristics of these calls. Even if this change were made, we might want to allow users to apply `final` to extension methods which they want to be dispatched statically.<br>&gt; <br>&gt; ### Don&#39;t provide an `@incoherent` attribute<br>&gt; <br>&gt; This would improve safety by making this confusing construct completely impossible to write. However, it would also make it completely impossible to conform certain types to certain protocols or import certain combinations of modules into the same file. This seems especially unwise because previous versions of Swift have actually permitted this shadowing; code that previously compiled without even a warning could be difficult to port.<br>&gt; <br>&gt; ### Mark default members instead of statically dispatched members<br>&gt; <br>&gt; This would invert the keywording in a protocol extension: instead of marking the statically-dispatched members with `final`, you would mark the overridable members with `default`.<br>&gt; <br>&gt; I prefer `final` because it marks the more unusual case. Users are not surprised that they can override default methods; they are surprised that they *can&#39;t* reliably override protocol extension methods. Also, as mentioned in the previous section, I could see `final` being retained even if protocol extension methods gained dynamic dispatch.<br>&gt; <br>&gt; However, my preference is not terribly strong, and using `default` on the overridable methods is not a bad option.<br>&gt; <br>&gt; ### Require a `final` keyword, but don&#39;t prevent conflicts with an error<br>&gt; <br>&gt; The problem with this approach is that the conflict is the surprising part. It doesn&#39;t matter all that much whether protocol extension members are dispatched statically or dynamically *except* if there&#39;s a conflict; *then* you&#39;re getting into potential bug territory. The `@incoherent` keyword is what makes this mistake impossible to make accidentally; without it, this is merely a proposal to force people to annotate their protocol extensions more clearly.<br>&gt; <br>&gt; ### Don&#39;t require a `final` keyword, but prevent conflicts with an error<br>&gt; <br>&gt; Without the `final` keyword (or the `default` alternative mentioned above) on the extension members themselves, it&#39;s impossible to tell at a glance which members are overridable and which ones aren&#39;t. This makes predicting incoherent conformance errors an exercise in trial-and-error, or at least in visual-diffing two separate parts of the code to figure out what&#39;s going on. Without the `final` keyword, in other words, avoiding conflicts when you write your code instead of discovering them when you compile it is much more difficult.<br>&gt; <br>&gt; ### Mark specific conflicting members<br>&gt; <br>&gt; Rather than marking an entire conformance as permitted to allow conflicts, we could force users to mark specific conflicting members. For instance, in the `Turnable`/`SpimsterWicket` example used above, `turningRepeatedly(_:)` itself would have to be marked in some way.<br>&gt; <br>&gt; The main issue I see is that, in many cases, a conformance is added in a different file or even module than the conflicting declaration, so there&#39;s no convenient place to put the attribute. This is basically the same reason there&#39;s no equivalent of `override` for implementations of protocol methods.<br>&gt; <br>&gt; This would also require more declarations, but I don&#39;t necessarily think that would be a bad thing.<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[Draft Proposal] Require `final` on protocol extension members</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>January  5, 2016 at 08:00:00am</p></header><div class="content"><p>It definitely is odd behaviour that needs to be sorted out. The question is, how? I think part of this is the confusing position that you put the code into.<br></p><p>If I approached this new to Swift, I would expect the declaration in the type to be a replacement for a default in the protocol extension. I would not expect protocol to be able to override my type in any way.<br></p><p>Perhaps this shows more that I am a object oriented programmer more than protocol oriented, but if I&#39;m declaring it specifically on a type, I would expect the type to be the definitive word on this.<br></p><p>The question then becomes simple: should a type gave the right to replace the value in the protocol? Should protocol extensions therefore only be defaults?<br></p><p>I would argue for treating the protocol as a default. If you had an identical member in the type, use the type rather than the protocol extension. This allows the most flexibility. That said, I am aware that means that some optimisations are not possible. I simply think this makes the most sense from a programming perspective.<br></p><p>- Rod<br></p><p>&gt; On 4 Jan 2016, at 11:28 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Now that everyone&#39;s presumably back from vacation, I figured I&#39;d repost this proposal.<br>&gt; <br>&gt; (If nobody has any comments, how can I get the ball rolling on starting a review?)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; <br>&gt; <br>&gt; I&#39;ve been working on this on-and-off for a few weeks, and I&#39;ve finished drafting a formal proposal. Comments welcome.<br>&gt; <br>&gt; &lt;https://github.com/brentdax/swift-evolution/blob/final-protocol-methods/proposals/0000-require-final-on-protocol-extension-methods.md&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; # Require `final` on protocol extension members<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; Protocol extension members which aren&#39;t listed in the protocol itself have an unusual behavior: a conforming type can implement an identically named member, but instances with the protocol&#39;s type are always statically dispatched to the protocol&#39;s implementation. This can lead to the same instance displaying different behavior when it&#39;s cast to a  protocol it conforms to. In effect, the conforming type&#39;s member shadows the protocol&#39;s, rather than overriding it. This behavior is very surprising to some users.<br>&gt; <br>&gt; The lack of a warning on this is [currently considered a bug](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001861.html), but I think we should go further and cause it to be an error. However, we should also provide an escape hatch which permits conflicts in cases where they&#39;re necessary.<br>&gt; <br>&gt; ## Motivation<br>&gt; <br>&gt; Suppose you write a protocol and extension like this:<br>&gt; <br>&gt;    protocol Turnable {<br>&gt;        func turning() -&gt; Self<br>&gt;        mutating func turn()<br>&gt;    }<br>&gt;    extension Turnable {<br>&gt;        mutating func turn() {<br>&gt;            self = turning()<br>&gt;        }<br>&gt;    <br>&gt;        func turningRepeatedly(additionalTurns: Int) -&gt; Self {<br>&gt;            var turnedSelf = self<br>&gt;            for _ in 1...additionalTurns {<br>&gt;                turnedSelf.turn()<br>&gt;            }<br>&gt;            return turnedSelf<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; Now you want to write a conforming type, `SpimsterWicket`. There are three different rules about whether your type has to, or can, implement its own versions of these methods.<br>&gt; <br>&gt; 1. `turning()` is a “protocol method”: it is listed in the protocol but is not included in the extension. You *must* implement `turning()` to conform to `Turnable`.<br>&gt; 2. `turn()` is a “defaulted protocol method”: it is listed in the protocol but there is also an implementation of it in the extension. You *may* implement `turn()`; if you don’t, the protocol extension’s implementation will be used.<br>&gt; 3. `turningRepeatedly(_: Int)` is a “protocol extension method”: it is *not* listed in the protocol, but only in the protocol extension. This is the case we are trying to address.<br>&gt; <br>&gt; Currently, in case 3, Swift permits you to implement your own `turningRepeatedly(_: Int)`. However, your implementation may not be called in every circumstance that you expect. If you call `turningRepeatedly` on a variable of type `SpimsterWicket`, you’ll get `SpimsterWicket`’s implementation of the method; however, if you call `turningRepeatedly` on a variable of type `Turnable`, you’ll get `Turnable`’s implementation of the method.<br>&gt; <br>&gt;    var wicket: SpimsterWicket = SpimsterWicket()<br>&gt;    var turnable: Turnable = wicket<br>&gt;    <br>&gt;    wicket.turn()                    // Calls SpimsterWicket.turn()<br>&gt;    turnable.turn()                    // Also calls SpimsterWicket.turn()<br>&gt;    <br>&gt;    wicket.turningRepeatedly(5)        // Calls SpimsterWicket.turningRepeatedly(_:)<br>&gt;    turnable.turningRepeatedly(5)    // Calls Turnable.turningRepeatedly(_:)<br>&gt; <br>&gt; In most parts of Swift, casting an instance or assigning it to a variable of a different type doesn’t change which implementation will be called when you put it on the left-hand side of a dot. (I’m leaving aside Objective-C bridging, like `Int` to `NSNumber`, which is really a different operation being performed with the same syntax.) If you put a `UIControl` into a variable of type `UIView`, and then call `touchesBegan()` on that variable, Swift will still call `UIControl.touchesBegan()`. The same is true of defaulted protocol methods—if you call `turn()` on `turnable`, you’ll get `SpimsterWicket.turn()`.<br>&gt; <br>&gt; But this is not true of protocol extension methods. There, the static type of the variable—the type known at compile time, the type that the variable is labeled with—is used. Thus, calling `turningRepeatedly(_:)` on `wicket` gets you `SpimsterWicket`’s implementation, but calling it on `turnable`—even though it&#39;s merely the same instance casted to a different type—gets you `Turnable`’s implementation.<br>&gt; <br>&gt; This creates what I call an “incoherent” dispatch, and it occurs nowhere else in Swift. In most places in Swift, method dispatch is either based on the runtime type (reference types, normal protocol members), or the design of the language ensures there’s no difference between dispatching on the compile-time type and the runtime type (value types, `final` members). But in protocol extension members, dispatch is based on the compile-time type even though the runtime type might produce different behavior.<br>&gt; <br>&gt; ## Proposed solution<br>&gt; <br>&gt; I propose that we:<br>&gt; <br>&gt; 1. Cause Swift to emit an error when it detects this sort of conflict.<br>&gt; 2. Add a mandatory `final` keyword to statically-dispatched protocol extension members, to give a textual indication that these errors will occur.<br>&gt; 3. For those circumstances in which this conflict is a necessary evil, provide an attribute which can be applied to indicate that conflicts are allowed when caused by a particular conformance.<br>&gt; <br>&gt; Specifics follow, though not in the order given above. In the examples below, `T` and `U` are conforming types, `P` and `Q` are protocols, and `f` is a member which, in some cases, may be a final protocol extension member.<br>&gt; <br>&gt; ### Mark protocol extension members with the `final` keyword<br>&gt; <br>&gt; If we are going to emit an error for these conflicts, it would be helpful to mark which members are prone to them.<br>&gt; <br>&gt; I therefore propose that all protocol extension members (that is, the ones that aren&#39;t providing a default implementation for a protocol requirement) be marked with the `final` keyword. Failing to mark such a member with `final` would cause an error.<br>&gt; <br>&gt; Currently, the `final` keyword is only used on classes. When applied to a class&#39;s member, it indicates that subclasses cannot override that member. I see this new use of the `final` keyword as analogously indicating that conforming types cannot customize the member. In fact, you can capture both meanings of `final` in a single statement:<br>&gt; <br>&gt;&gt; `final` declares that subtypes of this type must use this specific implementation of the member, and cannot substitute their own specialized implementation. Attempting to do so causes an error.<br>&gt; <br>&gt; ### Make conflicting with a `final` protocol extension method an error<br>&gt; <br>&gt; We can now define an incoherent type as one in which a `final` protocol extension member is shadowed by a member of a conforming type, as seen from any source file. (Note that methods and subscripts are only shadowed by a member with a matching signature.)<br>&gt; <br>&gt; Because incoherence is caused by the interaction of two separate declarations, there are many different circumstances in which incoherence may be caused. Here are the ones I&#39;ve been able to think of:<br>&gt; <br>&gt; 1. Type `T` is conformed to protocol `P` in a file where member `f` is visible on both `T` and `P`.<br>&gt; 2. Type `T` is conformed to protocols `P` and `Q`, which both have a final member `f`. (Note that diamond conformance patterns, where `P` and `Q` both get the same final member `f` from protocol `R`, should be permitted.)<br>&gt; 3. Type `T` is extended to add a member `f` in a file where `T`&#39;s conformance to `P` is imported from another module, and `P` has a final member `f`.<br>&gt; 4. Protocol `P` is extended to add final member `f` in a file where `T`&#39;s conformance to `P`, and the declaration of `T.f`, are both imported from other modules.<br>&gt; 5. A source file imports module A, which extends protocol `P` to include final member `f`, and module B, which conforms type `T` with member `f` to conform to `P`.<br>&gt; <br>&gt; It should be noted that these conflicts are tied to *visibility*. There is no conflict if the two definitions of `f` are not both visible in  the same place. For instance:<br>&gt; <br>&gt; - If file A.swift extends `T` with a private member `f`, and file B.swift extends `P` with a private final member `f`, there is no conflict.<br>&gt; - If module A extends `T` with an internal member `f`, and module B extends `P` with an internal final member `f`, there is no conflict.<br>&gt; - If module A extends `T` with a *public* member `f`, and module B extends `P` with a public final member `f`, there is only a conflict if A and B are imported in the same file. Even if A and B are imported in different files in the same module, there is no conflict.<br>&gt; <br>&gt; ### Permit conflicts with an explicit acknowledgement through an `@incoherent` attribute<br>&gt; <br>&gt; In some circumstances, it may be desirable to permit a conflict, even though it causes surprising behavior. For instance, you may want to conform an existing type to a protocol where the names conflict through sheer happenstance, and you know the protocol extension method will only ever be needed in code that treats that uses the protocol&#39;s type. In those cases, you can disable the conflict error and restore the current incoherent dispatch behavior using an `@incoherent` attribute.<br>&gt; <br>&gt; The `@incoherent` attribute is always tied to a particular type and protocol. It says, in essence, &quot;I know type T conflicts with protocol P, and I want to ignore all of those conflicts and accept incoherent dispatch.&quot; Depending on where it&#39;s attached, you may have to specify more or less information in the attribute&#39;s parameters. For instance:<br>&gt; <br>&gt;    // Mark the conformance.<br>&gt;    extension T: @incoherent P {...}<br>&gt;    <br>&gt;    // Mark the extension.<br>&gt;    @incoherent(T) extension P {...}<br>&gt;    @incoherent(P) extension T {...}<br>&gt;    <br>&gt;    // Mark the import statement<br>&gt;    @incoherent(T: P) import B<br>&gt; <br>&gt; ## Detailed design<br>&gt; <br>&gt; ### Errors for improper use of the `final` keyword<br>&gt; <br>&gt; Failing to put a `final` keyword on a protocol extension member which requires it should emit an error message along these lines:<br>&gt; <br>&gt;&gt; f must be final because it is not a requirement of P.<br>&gt; <br>&gt; This error should include a fix-it which adds the `final` keyword.<br>&gt; <br>&gt; Putting a `final` keyword on a defaulted protocol member is nonsensical—it essentially gives the member the semantics of a protocol extension member. We should emit an error message along these lines:<br>&gt; <br>&gt;&gt; f cannot be final because it is a requirement of P.<br>&gt; <br>&gt; This error should include a fix-it which removes the `final` keyword.<br>&gt; <br>&gt; ### Errors for conflicting members<br>&gt; <br>&gt; As mentioned above, there are many ways to cause a conflict, and each of them needs a slightly different wording. Here&#39;s what I propose:<br>&gt; <br>&gt; 1. **Type `T` is conformed to protocol `P` in a file where member `f` is visible on both `T` and `P`.** The declaration of the conformance (that is, the declaration with the `: P` clause) should be marked with an error like:<br>&gt; <br>&gt;&gt; T cannot conform to P because T.f conflicts with final member P.f.<br>&gt;    <br>&gt; 2. **Type `T` is conformed to protocols `P` and `Q`, which both have a final member `f`.** The declaration of one of the conformances should be marked with an error like:<br>&gt; <br>&gt;&gt; T cannot conform to both P and Q because final member P.f conflicts with final member Q.f.<br>&gt; <br>&gt; 3. **Type `T` is extended to add a member `f` in a file where `T`&#39;s conformance to `P` is imported from another module, and `P` has a final member `f`.** The declaration of the concrete type extension should be marked with an error like:<br>&gt; <br>&gt;&gt; T cannot be extended to add member f because it conflicts with final member P.f.<br>&gt; <br>&gt; 4. **Protocol `P` is extended to add final member `f` in a file where `T`&#39;s conformance to `P`, and the declaration of `T.f`, are both imported from other modules.** The declaration of the protocol extension should be marked with an error like:<br>&gt; <br>&gt;&gt; P cannot be extended to add final member f because it conflicts with member T.f of a conforming type.<br>&gt;    <br>&gt; 5. **A source file imports module A, which extends protocol `P` to include final member `f`, and module B, which conforms type `T` with member `f` to conform to `P`.** The later of the two imports should be marked with an error like:<br>&gt; <br>&gt;&gt; B cannot be imported because final member P.f conflicts with A&#39;s T.f.<br>&gt; <br>&gt; The preferred means of resolving a conflict include:<br>&gt; <br>&gt; - Renaming one of the conflicting members.<br>&gt; - Deleting one of the conflicting members.<br>&gt; - Deleting an `import` statement which causes the conflict.<br>&gt; - Adding the conflicting member to the protocol, and removing the `final` keyword, so that it becomes a defaulted protocol member.<br>&gt; <br>&gt; If it is feasible to provide a fix-it suggesting one of these solutions, that should be done.<br>&gt; <br>&gt; Fix-its should *not* suggest adding an `@incoherent` attribute. It is sometimes necessary to permit incoherence, but it&#39;s never desirable, because incoherence is confusing. A fix-it would encourage users to enable incoherence without actually understanding what it means, which will cause confusion.<br>&gt; <br>&gt; ### Marking multiple `@incoherent` types<br>&gt; <br>&gt; In places where one parameter to the `@incoherent` attribute is permitted, you can instead provide a comma-separated list to permit several different incoherences caused by the same declaration:<br>&gt; <br>&gt;    @incoherent(T, U) extension P {...}<br>&gt;    @incoherent(P, Q) extension T {...}<br>&gt;    <br>&gt;    @incoherent(T: P, U: Q) import B<br>&gt; <br>&gt; ## Impact on existing code<br>&gt; <br>&gt; The requirement that `final` be applied to many protocol extension methods will cause many—perhaps most—protocol extensions to stop compiling without changes. However, the changes needed—adding a keyword to the declarations of relevant members—are fairly mechanical and are fix-it guided. The migrator should add them automatically.<br>&gt; <br>&gt; The conflict errors will cause a smaller number of conformance declarations, protocol extensions, or `import` statements to fail to compile. I believe that many of these cases will be bugs, and users will want to rename members to avoid them. When users do not want to rename, they can preserve the existing semantics with an `@incoherent` attribute.<br>&gt; <br>&gt; Because this is primarily a safety feature, does not change runtime semantics, and, in most codebases, all changes will be purely mechanical, I believe this feature should be added to the next minor version of Swift, rather than waiting for 3.0.<br>&gt; <br>&gt; ## Alternatives considered<br>&gt; <br>&gt; ### Dynamically dispatch calls to protocol extension members<br>&gt; <br>&gt; This would fix the underlying problem—the confusing behavior—by making protocol extension members not behave confusingly.<br>&gt; <br>&gt; This would likely take a redesign of protocol witnesses to include extension methods not listed in the original protocol. It&#39;s probably not impossible—class extensions behave this way—but it&#39;s a much bigger change than what I propose, which keeps the current runtime semantics and only adds compile-time errors and keywords.<br>&gt; <br>&gt; Dynamically dispatching to protocol extension members would also change the performance characteristics of these calls. Even if this change were made, we might want to allow users to apply `final` to extension methods which they want to be dispatched statically.<br>&gt; <br>&gt; ### Don&#39;t provide an `@incoherent` attribute<br>&gt; <br>&gt; This would improve safety by making this confusing construct completely impossible to write. However, it would also make it completely impossible to conform certain types to certain protocols or import certain combinations of modules into the same file. This seems especially unwise because previous versions of Swift have actually permitted this shadowing; code that previously compiled without even a warning could be difficult to port.<br>&gt; <br>&gt; ### Mark default members instead of statically dispatched members<br>&gt; <br>&gt; This would invert the keywording in a protocol extension: instead of marking the statically-dispatched members with `final`, you would mark the overridable members with `default`.<br>&gt; <br>&gt; I prefer `final` because it marks the more unusual case. Users are not surprised that they can override default methods; they are surprised that they *can&#39;t* reliably override protocol extension methods. Also, as mentioned in the previous section, I could see `final` being retained even if protocol extension methods gained dynamic dispatch.<br>&gt; <br>&gt; However, my preference is not terribly strong, and using `default` on the overridable methods is not a bad option.<br>&gt; <br>&gt; ### Require a `final` keyword, but don&#39;t prevent conflicts with an error<br>&gt; <br>&gt; The problem with this approach is that the conflict is the surprising part. It doesn&#39;t matter all that much whether protocol extension members are dispatched statically or dynamically *except* if there&#39;s a conflict; *then* you&#39;re getting into potential bug territory. The `@incoherent` keyword is what makes this mistake impossible to make accidentally; without it, this is merely a proposal to force people to annotate their protocol extensions more clearly.<br>&gt; <br>&gt; ### Don&#39;t require a `final` keyword, but prevent conflicts with an error<br>&gt; <br>&gt; Without the `final` keyword (or the `default` alternative mentioned above) on the extension members themselves, it&#39;s impossible to tell at a glance which members are overridable and which ones aren&#39;t. This makes predicting incoherent conformance errors an exercise in trial-and-error, or at least in visual-diffing two separate parts of the code to figure out what&#39;s going on. Without the `final` keyword, in other words, avoiding conflicts when you write your code instead of discovering them when you compile it is much more difficult.<br>&gt; <br>&gt; ### Mark specific conflicting members<br>&gt; <br>&gt; Rather than marking an entire conformance as permitted to allow conflicts, we could force users to mark specific conflicting members. For instance, in the `Turnable`/`SpimsterWicket` example used above, `turningRepeatedly(_:)` itself would have to be marked in some way.<br>&gt; <br>&gt; The main issue I see is that, in many cases, a conformance is added in a different file or even module than the conflicting declaration, so there&#39;s no convenient place to put the attribute. This is basically the same reason there&#39;s no equivalent of `override` for implementations of protocol methods.<br>&gt; <br>&gt; This would also require more declarations, but I don&#39;t necessarily think that would be a bad thing.<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft Proposal] Require `final` on protocol extension members</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January  4, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; The question then becomes simple: should a type gave the right to replace the value in the protocol? Should protocol extensions therefore only be defaults?<br>&gt; <br>&gt; I would argue for treating the protocol as a default. If you had an identical member in the type, use the type rather than the protocol extension. This allows the most flexibility. That said, I am aware that means that some optimisations are not possible. I simply think this makes the most sense from a programming perspective.<br></p><p>I discuss this in the Alternatives section:<br></p><p>&gt; ### Dynamically dispatch calls to protocol extension members<br>&gt; <br>&gt; This would fix the underlying problem—the confusing behavior—by making protocol extension members not behave confusingly.<br>&gt; <br>&gt; This would likely take a redesign of protocol witnesses to include extension methods not listed in the original protocol. It&#39;s probably not impossible—class extensions behave this way—but it&#39;s a much bigger change than what I propose, which keeps the current runtime semantics and only adds compile-time errors and keywords.<br>&gt; <br>&gt; Dynamically dispatching to protocol extension members would also change the performance characteristics of these calls. Even if this change were made, we might want to allow users to apply `final` to extension methods which they want to be dispatched statically.<br></p><p>Basically, I&#39;m not proposing that simply because it&#39;s a larger change and would take redesigning that would have to wait until at least Swift 3, and is well beyond my own ability to specify or even evaluate the feasibility of. Plus, as I said in that last paragraph, `final` protocol extension members may be useful even if we do treat extension members as equivalent to defaulted protocol members.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[Draft Proposal] Require `final` on protocol extension members</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>January  5, 2016 at 11:00:00am</p></header><div class="content"><p>Sorry Brent, I obviously didn’t read down to the alternatives section. Stupid me.<br></p><p>I think that it is a larger change, but if we’re going to change this, shouldn’t we do it right?<br></p><p>From my perspective, a protocol says what “should” happen, whereas a type is where it eventually “does” happen. I find it a little backwards to make protocol extensions mandatorily final. It blocks out the power of defaulting.  I definitely agree with you that final in protocol extensions is a great idea, though.<br></p><p><br>&gt; On 5 Jan 2016, at 10:13 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; The question then becomes simple: should a type gave the right to replace the value in the protocol? Should protocol extensions therefore only be defaults?<br>&gt;&gt; <br>&gt;&gt; I would argue for treating the protocol as a default. If you had an identical member in the type, use the type rather than the protocol extension. This allows the most flexibility. That said, I am aware that means that some optimisations are not possible. I simply think this makes the most sense from a programming perspective.<br>&gt; <br>&gt; I discuss this in the Alternatives section:<br>&gt; <br>&gt;&gt; ### Dynamically dispatch calls to protocol extension members<br>&gt;&gt; <br>&gt;&gt; This would fix the underlying problem—the confusing behavior—by making protocol extension members not behave confusingly.<br>&gt;&gt; <br>&gt;&gt; This would likely take a redesign of protocol witnesses to include extension methods not listed in the original protocol. It&#39;s probably not impossible—class extensions behave this way—but it&#39;s a much bigger change than what I propose, which keeps the current runtime semantics and only adds compile-time errors and keywords.<br>&gt;&gt; <br>&gt;&gt; Dynamically dispatching to protocol extension members would also change the performance characteristics of these calls. Even if this change were made, we might want to allow users to apply `final` to extension methods which they want to be dispatched statically.<br>&gt; <br>&gt; Basically, I&#39;m not proposing that simply because it&#39;s a larger change and would take redesigning that would have to wait until at least Swift 3, and is well beyond my own ability to specify or even evaluate the feasibility of. Plus, as I said in that last paragraph, `final` protocol extension members may be useful even if we do treat extension members as equivalent to defaulted protocol members.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Draft Proposal] Require `final` on protocol extension members</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>January  5, 2016 at 12:00:00am</p></header><div class="content"><p>I agree with you, if we tackle this and we should then we should aim to the right solution if it is reachable. <br>I know I am in the minority and it is partially off topic here, but I do feel that default method implementations are something that might be put to good use, but it is best to try to make sure no unintentional side effects are produced too easily. In a way you give out a possibly dangerous tool, you have protocols and you pass around objects referenced not by the actual type but by the protocol it is represented by to make sure that the receiver cannot make any assumption on the actual implementation beyond the abstract API contract and default methods do expose that. <br></p><p>Sent from my iPhone<br></p><p>&gt; On 5 Jan 2016, at 00:11, Rod Brown via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Sorry Brent, I obviously didn’t read down to the alternatives section. Stupid me.<br>&gt; <br>&gt; I think that it is a larger change, but if we’re going to change this, shouldn’t we do it right?<br>&gt; <br>&gt; From my perspective, a protocol says what “should” happen, whereas a type is where it eventually “does” happen. I find it a little backwards to make protocol extensions mandatorily final. It blocks out the power of defaulting.  I definitely agree with you that final in protocol extensions is a great idea, though.<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On 5 Jan 2016, at 10:13 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The question then becomes simple: should a type gave the right to replace the value in the protocol? Should protocol extensions therefore only be defaults?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would argue for treating the protocol as a default. If you had an identical member in the type, use the type rather than the protocol extension. This allows the most flexibility. That said, I am aware that means that some optimisations are not possible. I simply think this makes the most sense from a programming perspective.<br>&gt;&gt; <br>&gt;&gt; I discuss this in the Alternatives section:<br>&gt;&gt; <br>&gt;&gt;&gt; ### Dynamically dispatch calls to protocol extension members<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would fix the underlying problem—the confusing behavior—by making protocol extension members not behave confusingly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would likely take a redesign of protocol witnesses to include extension methods not listed in the original protocol. It&#39;s probably not impossible—class extensions behave this way—but it&#39;s a much bigger change than what I propose, which keeps the current runtime semantics and only adds compile-time errors and keywords.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dynamically dispatching to protocol extension members would also change the performance characteristics of these calls. Even if this change were made, we might want to allow users to apply `final` to extension methods which they want to be dispatched statically.<br>&gt;&gt; <br>&gt;&gt; Basically, I&#39;m not proposing that simply because it&#39;s a larger change and would take redesigning that would have to wait until at least Swift 3, and is well beyond my own ability to specify or even evaluate the feasibility of. Plus, as I said in that last paragraph, `final` protocol extension members may be useful even if we do treat extension members as equivalent to defaulted protocol members.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft Proposal] Require `final` on protocol extension members</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January  5, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; I think that it is a larger change, but if we’re going to change this, shouldn’t we do it right?<br></p><p>Okay, so let&#39;s sketch out a &quot;doing it right&quot; solution here. No implementation details, just high-level ideas.<br></p><p>If you want members added in extensions to be overridable, that basically means you want them to add requirements to the protocol and then provide a default implementation of those requirements. In other words, you&#39;re reducing the distinction between the protocol and its extensions. This is a goal of several other planned changes as well, such as letting you provide default implementations directly in a protocol definition.<br></p><p>I think it&#39;s fair to say that the ultimate goal here is to erase the distinction between the protocol definition and its extensions as much as possible. Now, it&#39;s probably not possible to make them completely equivalent, because you can&#39;t allow an extension to break an existing conformance. So, for instance, you probably can&#39;t put a requirement in an extension unless you provide a default implementation. But this is not very different from, for instance, not being able to declare stored properties in concrete type extensions.<br></p><p>So, if our ultimate goal is to, as much as possible, erase the distinction between protocol declarations and protocol extensions, without changing existing behavior, what are the changes needed? At a minimum, they are:<br></p><p>1. Add `final` protocol members, and migrate current protocol extension members to `final` members.<br>2. Add an error when a `final` protocol member conflicts with a conforming type&#39;s member.<br>3. Permit default implementations in the main protocol definition.<br>4. Permit protocol extensions to add conformances to other protocols (with all the `where` clause bells and whistles).<br>5. Allow protocol extensions to add requirements with default implementations.<br></p><p>I put them in this order because I think this is the order they should be implemented in. 1 should come first because if it comes after 5, the exact same source code can compile in two adjacent versions of Swift with different semantics. I think we need to avoid this so that people can get used to the new semantics. 2 needs to come early as well, both to justify the use of `final` as the keyword, and to provide additional safety as the definitions of protocols become more diffuse and fragmented. 3 and 4 I put before 5 simply because I think they&#39;re most likely easier to implement.<br></p><p>So in short, I think that even if you want to change protocol extensions to add defaulted requirements, this proposal is a necessary first step. The Swift development process encourages incremental development, with each step in implementing a change refining the language in a useful way. I think this is the step we should take right now. If it&#39;s the only change we ever make in this direction, it will still be an improvement in the language; if we take further steps, they will benefit from having this change already implemented.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Draft Proposal] Require `final` on protocol extension members</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January  7, 2016 at 12:00:00pm</p></header><div class="content"><p>The requirement for final for functions not from the protocol works well<br>with a proposal in another thread for the requirement for override for<br>functions that are from the protocol. Between the two proposals they allow<br>the compiler to generate better error messages since the programmers<br>intention is clear to the compiler (and to other humans).<br></p><p>On Wednesday, 6 January 2016, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; I think that it is a larger change, but if we’re going to change this,<br>&gt; shouldn’t we do it right?<br>&gt;<br>&gt; Okay, so let&#39;s sketch out a &quot;doing it right&quot; solution here. No<br>&gt; implementation details, just high-level ideas.<br>&gt;<br>&gt; If you want members added in extensions to be overridable, that basically<br>&gt; means you want them to add requirements to the protocol and then provide a<br>&gt; default implementation of those requirements. In other words, you&#39;re<br>&gt; reducing the distinction between the protocol and its extensions. This is a<br>&gt; goal of several other planned changes as well, such as letting you provide<br>&gt; default implementations directly in a protocol definition.<br>&gt;<br>&gt; I think it&#39;s fair to say that the ultimate goal here is to erase the<br>&gt; distinction between the protocol definition and its extensions as much as<br>&gt; possible. Now, it&#39;s probably not possible to make them completely<br>&gt; equivalent, because you can&#39;t allow an extension to break an existing<br>&gt; conformance. So, for instance, you probably can&#39;t put a requirement in an<br>&gt; extension unless you provide a default implementation. But this is not very<br>&gt; different from, for instance, not being able to declare stored properties<br>&gt; in concrete type extensions.<br>&gt;<br>&gt; So, if our ultimate goal is to, as much as possible, erase the distinction<br>&gt; between protocol declarations and protocol extensions, without changing<br>&gt; existing behavior, what are the changes needed? At a minimum, they are:<br>&gt;<br>&gt; 1. Add `final` protocol members, and migrate current protocol extension<br>&gt; members to `final` members.<br>&gt; 2. Add an error when a `final` protocol member conflicts with a conforming<br>&gt; type&#39;s member.<br>&gt; 3. Permit default implementations in the main protocol definition.<br>&gt; 4. Permit protocol extensions to add conformances to other protocols (with<br>&gt; all the `where` clause bells and whistles).<br>&gt; 5. Allow protocol extensions to add requirements with default<br>&gt; implementations.<br>&gt;<br>&gt; I put them in this order because I think this is the order they should be<br>&gt; implemented in. 1 should come first because if it comes after 5, the exact<br>&gt; same source code can compile in two adjacent versions of Swift with<br>&gt; different semantics. I think we need to avoid this so that people can get<br>&gt; used to the new semantics. 2 needs to come early as well, both to justify<br>&gt; the use of `final` as the keyword, and to provide additional safety as the<br>&gt; definitions of protocols become more diffuse and fragmented. 3 and 4 I put<br>&gt; before 5 simply because I think they&#39;re most likely easier to implement.<br>&gt;<br>&gt; So in short, I think that even if you want to change protocol extensions<br>&gt; to add defaulted requirements, this proposal is a necessary first step. The<br>&gt; Swift development process encourages incremental development, with each<br>&gt; step in implementing a change refining the language in a useful way. I<br>&gt; think this is the step we should take right now. If it&#39;s the only change we<br>&gt; ever make in this direction, it will still be an improvement in the<br>&gt; language; if we take further steps, they will benefit from having this<br>&gt; change already implemented.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/40084071/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Draft Proposal] Require `final` on protocol extension members</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>January  7, 2016 at 02:00:00am</p></header><div class="content"><p>I would rather see this go the &#39;other&#39; way and allow us to mark methods as<br>final in the protocol declaration. There has been consistent talk of<br>letting the default implementation for protocol methods live inside of the<br>protocol and these two things together would be much better than this<br>proposal, in my opinion.  I agree that, as it is, marking protocol<br>extension methods as final would be helpful but I don&#39;t think that this is<br>the general way to go.<br></p><p>On Wed, Jan 6, 2016 at 8:20 PM, Howard Lovatt via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The requirement for final for functions not from the protocol works well<br>&gt; with a proposal in another thread for the requirement for override for<br>&gt; functions that are from the protocol. Between the two proposals they allow<br>&gt; the compiler to generate better error messages since the programmers<br>&gt; intention is clear to the compiler (and to other humans).<br>&gt;<br>&gt;<br>&gt; On Wednesday, 6 January 2016, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; I think that it is a larger change, but if we’re going to change this,<br>&gt;&gt; shouldn’t we do it right?<br>&gt;&gt;<br>&gt;&gt; Okay, so let&#39;s sketch out a &quot;doing it right&quot; solution here. No<br>&gt;&gt; implementation details, just high-level ideas.<br>&gt;&gt;<br>&gt;&gt; If you want members added in extensions to be overridable, that basically<br>&gt;&gt; means you want them to add requirements to the protocol and then provide a<br>&gt;&gt; default implementation of those requirements. In other words, you&#39;re<br>&gt;&gt; reducing the distinction between the protocol and its extensions. This is a<br>&gt;&gt; goal of several other planned changes as well, such as letting you provide<br>&gt;&gt; default implementations directly in a protocol definition.<br>&gt;&gt;<br>&gt;&gt; I think it&#39;s fair to say that the ultimate goal here is to erase the<br>&gt;&gt; distinction between the protocol definition and its extensions as much as<br>&gt;&gt; possible. Now, it&#39;s probably not possible to make them completely<br>&gt;&gt; equivalent, because you can&#39;t allow an extension to break an existing<br>&gt;&gt; conformance. So, for instance, you probably can&#39;t put a requirement in an<br>&gt;&gt; extension unless you provide a default implementation. But this is not very<br>&gt;&gt; different from, for instance, not being able to declare stored properties<br>&gt;&gt; in concrete type extensions.<br>&gt;&gt;<br>&gt;&gt; So, if our ultimate goal is to, as much as possible, erase the<br>&gt;&gt; distinction between protocol declarations and protocol extensions, without<br>&gt;&gt; changing existing behavior, what are the changes needed? At a minimum, they<br>&gt;&gt; are:<br>&gt;&gt;<br>&gt;&gt; 1. Add `final` protocol members, and migrate current protocol extension<br>&gt;&gt; members to `final` members.<br>&gt;&gt; 2. Add an error when a `final` protocol member conflicts with a<br>&gt;&gt; conforming type&#39;s member.<br>&gt;&gt; 3. Permit default implementations in the main protocol definition.<br>&gt;&gt; 4. Permit protocol extensions to add conformances to other protocols<br>&gt;&gt; (with all the `where` clause bells and whistles).<br>&gt;&gt; 5. Allow protocol extensions to add requirements with default<br>&gt;&gt; implementations.<br>&gt;&gt;<br>&gt;&gt; I put them in this order because I think this is the order they should be<br>&gt;&gt; implemented in. 1 should come first because if it comes after 5, the exact<br>&gt;&gt; same source code can compile in two adjacent versions of Swift with<br>&gt;&gt; different semantics. I think we need to avoid this so that people can get<br>&gt;&gt; used to the new semantics. 2 needs to come early as well, both to justify<br>&gt;&gt; the use of `final` as the keyword, and to provide additional safety as the<br>&gt;&gt; definitions of protocols become more diffuse and fragmented. 3 and 4 I put<br>&gt;&gt; before 5 simply because I think they&#39;re most likely easier to implement.<br>&gt;&gt;<br>&gt;&gt; So in short, I think that even if you want to change protocol extensions<br>&gt;&gt; to add defaulted requirements, this proposal is a necessary first step. The<br>&gt;&gt; Swift development process encourages incremental development, with each<br>&gt;&gt; step in implementing a change refining the language in a useful way. I<br>&gt;&gt; think this is the step we should take right now. If it&#39;s the only change we<br>&gt;&gt; ever make in this direction, it will still be an improvement in the<br>&gt;&gt; language; if we take further steps, they will benefit from having this<br>&gt;&gt; change already implemented.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt;   -- Howard.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/fe110b0f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
