<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>The bind thread</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February  1, 2016 at 12:00:00pm</p></header><div class="content"><p>Joe says &quot;If you all are serious about this, I think you should start a new thread about it.&quot; <br>I think it&#39;s worth a serious discussion just so it can be evaluated and either adopted or discarded<br>and dropped forever. Here goes.<br></p><p>INTRO<br></p><p>The if let x = x {...} and guard let x = x else {...} constructs do something with let (and var) that&#39;s <br>fundamentally different from let (and var) elsewhere in the language.  The same keywords are used to conditionally unwrap<br>and bind an item, not just shadow that item&#39;s current value.<br></p><p>Introducing a new bind keyword to indicate unwrapping and binding would disambiguate these uses.<br></p><p>DETAIL DESIGN:<br></p><p>Jacob Bandes-Storch offers two common use-cases. I prefer his &quot;if bind foo&quot; to my original &quot;if bind foo = foo&quot;:<br></p><p>  if bind foo {<br>      // foo is non-optional in here<br>  }<br></p><p>  somethingAsync { [weak self] in<br>      guard bind self else { return }<br>      // ...<br>  }<br></p><p>JBS&#39;s approach offers my original &quot;bind&quot; keyword to unwrap and shadow bind, but also provides a way to <br>strongly bind a weak reference to self, which (presumably) would allow self semantics in the remaining<br>lifetime of that scope.<br></p><p>ALTERNATIVE PROPOSALS:<br></p><p>Tino Heth proposes a second use-case one with different semantics. This case, it seems to make an<br>alias rather than using binding for shadowing:<br></p><p>bind x = a.property.with.a.long.path<br>print x  // 42<br>print(a.property.with.a.long.path == 42) =&gt; true<br></p><p>presumably this means:<br></p><p>x += 1<br>print(a.property.with.a.long.path)  // 43<br></p><p>DISCUSSION<br></p><p>I&#39;m throwing these both out there. I have nothing to really say about Tino&#39;s but I do think my and Jacob&#39;s <br>proposal has the advantages of:<br></p><p>* Simplifying an mildly complex and potentially misleading statement <br>* Creating a deliberate and controlled rather than accidental shadowing style<br></p><p>Have at it.<br></p><p>-- Erica<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/599417bc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>The bind thread</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>February  1, 2016 at 11:00:00am</p></header><div class="content"><p>I think it&#39;s also worth mentioning Ceylon&#39;s flow-sensitive typing<br>&lt;http://ceylon-lang.org/documentation/1.2/introduction/#typesafe_null_and_flow_sensitive_typing&gt;<br>features, pointed out by Thorsten Seitz:<br></p><p>This is called flow typing in Ceylon and they are using &quot;exists&quot; for that<br>&gt; case but testing for conformance with &quot;is&quot; works just the same way there.<br>&gt; The latter is of importance because the common use of union types in Ceylon.<br>&gt; if exists foo {<br>&gt;         // foo is non-optional here<br>&gt; }<br>&gt; if foo is String {<br>&gt;         // foo is of type String here<br>&gt; }<br></p><p><br>Seems like a neat option to me.<br></p><p>On Mon, Feb 1, 2016 at 11:18 AM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Joe says &quot;If you all are serious about this, I think you should start a<br>&gt; new thread about it.&quot;<br>&gt; I think it&#39;s worth a serious discussion just so it can be evaluated and<br>&gt; either adopted or discarded<br>&gt; and dropped forever. Here goes.<br>&gt;<br>&gt; INTRO<br>&gt;<br>&gt; The if let x = x {...} and guard let x = x else {...} constructs do<br>&gt; something with let (and var) that&#39;s<br>&gt; fundamentally different from let (and var) elsewhere in the language.<br>&gt; The same keywords are used to conditionally unwrap<br>&gt; and bind an item, not just shadow that item&#39;s current value.<br>&gt;<br>&gt; Introducing a new bind keyword to indicate unwrapping and binding would<br>&gt; disambiguate these uses.<br>&gt;<br>&gt; DETAIL DESIGN:<br>&gt;<br>&gt; Jacob Bandes-Storch offers two common use-cases. I prefer his &quot;if bind<br>&gt; foo&quot; to my original &quot;if bind foo = foo&quot;:<br>&gt;<br>&gt;   if bind foo {<br>&gt;       // foo is non-optional in here<br>&gt;   }<br>&gt;<br>&gt;   somethingAsync { [weak self] in<br>&gt;       guard bind self else { return }<br>&gt;       // ...<br>&gt;   }<br>&gt;<br>&gt; JBS&#39;s approach offers my original &quot;bind&quot; keyword to unwrap and shadow<br>&gt; bind, but also provides a way to<br>&gt; strongly bind a weak reference to self, which (presumably) would allow<br>&gt; self semantics in the remaining<br>&gt; lifetime of that scope.<br>&gt;<br>&gt; ALTERNATIVE PROPOSALS:<br>&gt;<br>&gt; Tino Heth proposes a second use-case one with different semantics. This<br>&gt; case, it seems to make an<br>&gt; alias rather than using binding for shadowing:<br>&gt;<br>&gt; bind x = a.property.with.a.long.path<br>&gt; print x  // 42<br>&gt; print(a.property.with.a.long.path == 42) =&gt; true<br>&gt;<br>&gt; presumably this means:<br>&gt;<br>&gt; x += 1<br>&gt; print(a.property.with.a.long.path)  // 43<br>&gt;<br>&gt; DISCUSSION<br>&gt;<br>&gt; I&#39;m throwing these both out there. I have nothing to really say about<br>&gt; Tino&#39;s but I do think my and Jacob&#39;s<br>&gt; proposal has the advantages of:<br>&gt;<br>&gt; * Simplifying an mildly complex and potentially misleading statement<br>&gt; * Creating a deliberate and controlled rather than accidental shadowing<br>&gt; style<br>&gt;<br>&gt; Have at it.<br>&gt;<br>&gt; -- Erica<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/ef0829de/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>The bind thread</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>February  1, 2016 at 02:00:00pm</p></header><div class="content"><p>This is interesting. What name is created by<br></p><p>  if bind foo.somethingReturningAnOptional {<br>      // ???<br>  }<br></p><p>On Mon, Feb 1, 2016 at 2:18 PM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Joe says &quot;If you all are serious about this, I think you should start a<br>&gt; new thread about it.&quot;<br>&gt; I think it&#39;s worth a serious discussion just so it can be evaluated and<br>&gt; either adopted or discarded<br>&gt; and dropped forever. Here goes.<br>&gt;<br>&gt; INTRO<br>&gt;<br>&gt; The if let x = x {...} and guard let x = x else {...} constructs do<br>&gt; something with let (and var) that&#39;s<br>&gt; fundamentally different from let (and var) elsewhere in the language.<br>&gt; The same keywords are used to conditionally unwrap<br>&gt; and bind an item, not just shadow that item&#39;s current value.<br>&gt;<br>&gt; Introducing a new bind keyword to indicate unwrapping and binding would<br>&gt; disambiguate these uses.<br>&gt;<br>&gt; DETAIL DESIGN:<br>&gt;<br>&gt; Jacob Bandes-Storch offers two common use-cases. I prefer his &quot;if bind<br>&gt; foo&quot; to my original &quot;if bind foo = foo&quot;:<br>&gt;<br>&gt;   if bind foo {<br>&gt;       // foo is non-optional in here<br>&gt;   }<br>&gt;<br>&gt;   somethingAsync { [weak self] in<br>&gt;       guard bind self else { return }<br>&gt;       // ...<br>&gt;   }<br>&gt;<br>&gt; JBS&#39;s approach offers my original &quot;bind&quot; keyword to unwrap and shadow<br>&gt; bind, but also provides a way to<br>&gt; strongly bind a weak reference to self, which (presumably) would allow<br>&gt; self semantics in the remaining<br>&gt; lifetime of that scope.<br>&gt;<br>&gt; ALTERNATIVE PROPOSALS:<br>&gt;<br>&gt; Tino Heth proposes a second use-case one with different semantics. This<br>&gt; case, it seems to make an<br>&gt; alias rather than using binding for shadowing:<br>&gt;<br>&gt; bind x = a.property.with.a.long.path<br>&gt; print x  // 42<br>&gt; print(a.property.with.a.long.path == 42) =&gt; true<br>&gt;<br>&gt; presumably this means:<br>&gt;<br>&gt; x += 1<br>&gt; print(a.property.with.a.long.path)  // 43<br>&gt;<br>&gt; DISCUSSION<br>&gt;<br>&gt; I&#39;m throwing these both out there. I have nothing to really say about<br>&gt; Tino&#39;s but I do think my and Jacob&#39;s<br>&gt; proposal has the advantages of:<br>&gt;<br>&gt; * Simplifying an mildly complex and potentially misleading statement<br>&gt; * Creating a deliberate and controlled rather than accidental shadowing<br>&gt; style<br>&gt;<br>&gt; Have at it.<br>&gt;<br>&gt; -- Erica<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/3949a658/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>The bind thread</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>February  1, 2016 at 11:00:00am</p></header><div class="content"><p>I think it’d be _<br></p><p>You could use it to test if the return value is non-nil, but you’d have to revert to “if let x = …” to actually use the results.<br></p><p>I think.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Feb 1, 2016, at 11:22, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is interesting. What name is created by <br>&gt; <br>&gt;   if bind foo.somethingReturningAnOptional {<br>&gt;       // ???<br>&gt;   }<br>&gt; <br>&gt; On Mon, Feb 1, 2016 at 2:18 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Joe says &quot;If you all are serious about this, I think you should start a new thread about it.&quot; <br>&gt; I think it&#39;s worth a serious discussion just so it can be evaluated and either adopted or discarded<br>&gt; and dropped forever. Here goes.<br>&gt; <br>&gt; INTRO<br>&gt; <br>&gt; The if let x = x {...} and guard let x = x else {...} constructs do something with let (and var) that&#39;s <br>&gt; fundamentally different from let (and var) elsewhere in the language.  The same keywords are used to conditionally unwrap<br>&gt; and bind an item, not just shadow that item&#39;s current value.<br>&gt; <br>&gt; Introducing a new bind keyword to indicate unwrapping and binding would disambiguate these uses.<br>&gt; <br>&gt; DETAIL DESIGN:<br>&gt; <br>&gt; Jacob Bandes-Storch offers two common use-cases. I prefer his &quot;if bind foo&quot; to my original &quot;if bind foo = foo&quot;:<br>&gt; <br>&gt;   if bind foo {<br>&gt;       // foo is non-optional in here<br>&gt;   }<br>&gt; <br>&gt;   somethingAsync { [weak self] in<br>&gt;       guard bind self else { return }<br>&gt;       // ...<br>&gt;   }<br>&gt; <br>&gt; JBS&#39;s approach offers my original &quot;bind&quot; keyword to unwrap and shadow bind, but also provides a way to <br>&gt; strongly bind a weak reference to self, which (presumably) would allow self semantics in the remaining<br>&gt; lifetime of that scope.<br>&gt; <br>&gt; ALTERNATIVE PROPOSALS:<br>&gt; <br>&gt; Tino Heth proposes a second use-case one with different semantics. This case, it seems to make an<br>&gt; alias rather than using binding for shadowing:<br>&gt; <br>&gt; bind x = a.property.with.a.long.path<br>&gt; print x  // 42<br>&gt; print(a.property.with.a.long.path == 42) =&gt; true<br>&gt; <br>&gt; presumably this means:<br>&gt; <br>&gt; x += 1<br>&gt; print(a.property.with.a.long.path)  // 43<br>&gt; <br>&gt; DISCUSSION<br>&gt; <br>&gt; I&#39;m throwing these both out there. I have nothing to really say about Tino&#39;s but I do think my and Jacob&#39;s <br>&gt; proposal has the advantages of:<br>&gt; <br>&gt; * Simplifying an mildly complex and potentially misleading statement <br>&gt; * Creating a deliberate and controlled rather than accidental shadowing style<br>&gt; <br>&gt; Have at it.<br>&gt; <br>&gt; -- Erica<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/2eedc441/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>The bind thread</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>February  2, 2016 at 06:00:00am</p></header><div class="content"><p>I like this proposal. I also think that either bind or exists could be the<br>keyword. I would suggest that both forms of syntax should be allowed, e.g.:<br></p><p>    if bind x { /* x is non-nil, unwrapped, and hides original x inside if<br>statement */ }<br>    if bind x = object.property { /* x is non-nil and unwrapped */ }<br></p><p>On Tuesday, 2 February 2016, Dave via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I *think* it’d be _<br>&gt;<br>&gt; You could use it to test if the return value is non-nil, but you’d have to<br>&gt; revert to “if let x = …” to actually use the results.<br>&gt;<br>&gt; I think.<br>&gt;<br>&gt; - Dave Sweeris<br>&gt;<br>&gt; On Feb 1, 2016, at 11:22, T.J. Usiyan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; This is interesting. What name is created by<br>&gt;<br>&gt;   if bind foo.somethingReturningAnOptional {<br>&gt;       // ???<br>&gt;   }<br>&gt;<br>&gt; On Mon, Feb 1, 2016 at 2:18 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; Joe says &quot;If you all are serious about this, I think you should start a<br>&gt;&gt; new thread about it.&quot;<br>&gt;&gt; I think it&#39;s worth a serious discussion just so it can be evaluated and<br>&gt;&gt; either adopted or discarded<br>&gt;&gt; and dropped forever. Here goes.<br>&gt;&gt;<br>&gt;&gt; INTRO<br>&gt;&gt;<br>&gt;&gt; The if let x = x {...} and guard let x = x else {...} constructs do<br>&gt;&gt; something with let (and var) that&#39;s<br>&gt;&gt; fundamentally different from let (and var) elsewhere in the language.<br>&gt;&gt; The same keywords are used to conditionally unwrap<br>&gt;&gt; and bind an item, not just shadow that item&#39;s current value.<br>&gt;&gt;<br>&gt;&gt; Introducing a new bind keyword to indicate unwrapping and binding would<br>&gt;&gt; disambiguate these uses.<br>&gt;&gt;<br>&gt;&gt; DETAIL DESIGN:<br>&gt;&gt;<br>&gt;&gt; Jacob Bandes-Storch offers two common use-cases. I prefer his &quot;if bind<br>&gt;&gt; foo&quot; to my original &quot;if bind foo = foo&quot;:<br>&gt;&gt;<br>&gt;&gt;   if bind foo {<br>&gt;&gt;       // foo is non-optional in here<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   somethingAsync { [weak self] in<br>&gt;&gt;       guard bind self else { return }<br>&gt;&gt;       // ...<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt; JBS&#39;s approach offers my original &quot;bind&quot; keyword to unwrap and shadow<br>&gt;&gt; bind, but also provides a way to<br>&gt;&gt; strongly bind a weak reference to self, which (presumably) would allow<br>&gt;&gt; self semantics in the remaining<br>&gt;&gt; lifetime of that scope.<br>&gt;&gt;<br>&gt;&gt; ALTERNATIVE PROPOSALS:<br>&gt;&gt;<br>&gt;&gt; Tino Heth proposes a second use-case one with different semantics. This<br>&gt;&gt; case, it seems to make an<br>&gt;&gt; alias rather than using binding for shadowing:<br>&gt;&gt;<br>&gt;&gt; bind x = a.property.with.a.long.path<br>&gt;&gt; print x  // 42<br>&gt;&gt; print(a.property.with.a.long.path == 42) =&gt; true<br>&gt;&gt;<br>&gt;&gt; presumably this means:<br>&gt;&gt;<br>&gt;&gt; x += 1<br>&gt;&gt; print(a.property.with.a.long.path)  // 43<br>&gt;&gt;<br>&gt;&gt; DISCUSSION<br>&gt;&gt;<br>&gt;&gt; I&#39;m throwing these both out there. I have nothing to really say about<br>&gt;&gt; Tino&#39;s but I do think my and Jacob&#39;s<br>&gt;&gt; proposal has the advantages of:<br>&gt;&gt;<br>&gt;&gt; * Simplifying an mildly complex and potentially misleading statement<br>&gt;&gt; * Creating a deliberate and controlled rather than accidental shadowing<br>&gt;&gt; style<br>&gt;&gt;<br>&gt;&gt; Have at it.<br>&gt;&gt;<br>&gt;&gt; -- Erica<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p><p>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/79aabfa8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>The bind thread</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>February  1, 2016 at 11:00:00am</p></header><div class="content"><p>The bind or exists keywords seem sort of silly to me. There is already syntax for binding optionals:<br></p><p>if x? {<br>	foo(x) // x type narrowed after binding.<br>}<br></p><p>Tyler<br></p><p><br>&gt; On Feb 1, 2016, at 11:35 AM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I like this proposal. I also think that either bind or exists could be the keyword. I would suggest that both forms of syntax should be allowed, e.g.:<br>&gt; <br>&gt;     if bind x { /* x is non-nil, unwrapped, and hides original x inside if statement */ }<br>&gt;     if bind x = object.property { /* x is non-nil and unwrapped */ }<br>&gt; <br>&gt; On Tuesday, 2 February 2016, Dave via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I think it’d be _<br>&gt; <br>&gt; You could use it to test if the return value is non-nil, but you’d have to revert to “if let x = …” to actually use the results.<br>&gt; <br>&gt; I think.<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; On Feb 1, 2016, at 11:22, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is interesting. What name is created by <br>&gt;&gt; <br>&gt;&gt;   if bind foo.somethingReturningAnOptional {<br>&gt;&gt;       // ???<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; On Mon, Feb 1, 2016 at 2:18 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt; Joe says &quot;If you all are serious about this, I think you should start a new thread about it.&quot; <br>&gt;&gt; I think it&#39;s worth a serious discussion just so it can be evaluated and either adopted or discarded<br>&gt;&gt; and dropped forever. Here goes.<br>&gt;&gt; <br>&gt;&gt; INTRO<br>&gt;&gt; <br>&gt;&gt; The if let x = x {...} and guard let x = x else {...} constructs do something with let (and var) that&#39;s <br>&gt;&gt; fundamentally different from let (and var) elsewhere in the language.  The same keywords are used to conditionally unwrap<br>&gt;&gt; and bind an item, not just shadow that item&#39;s current value.<br>&gt;&gt; <br>&gt;&gt; Introducing a new bind keyword to indicate unwrapping and binding would disambiguate these uses.<br>&gt;&gt; <br>&gt;&gt; DETAIL DESIGN:<br>&gt;&gt; <br>&gt;&gt; Jacob Bandes-Storch offers two common use-cases. I prefer his &quot;if bind foo&quot; to my original &quot;if bind foo = foo&quot;:<br>&gt;&gt; <br>&gt;&gt;   if bind foo {<br>&gt;&gt;       // foo is non-optional in here<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   somethingAsync { [weak self] in<br>&gt;&gt;       guard bind self else { return }<br>&gt;&gt;       // ...<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; JBS&#39;s approach offers my original &quot;bind&quot; keyword to unwrap and shadow bind, but also provides a way to <br>&gt;&gt; strongly bind a weak reference to self, which (presumably) would allow self semantics in the remaining<br>&gt;&gt; lifetime of that scope.<br>&gt;&gt; <br>&gt;&gt; ALTERNATIVE PROPOSALS:<br>&gt;&gt; <br>&gt;&gt; Tino Heth proposes a second use-case one with different semantics. This case, it seems to make an<br>&gt;&gt; alias rather than using binding for shadowing:<br>&gt;&gt; <br>&gt;&gt; bind x = a.property.with.a.long.path<br>&gt;&gt; print x  // 42<br>&gt;&gt; print(a.property.with.a.long.path == 42) =&gt; true<br>&gt;&gt; <br>&gt;&gt; presumably this means:<br>&gt;&gt; <br>&gt;&gt; x += 1<br>&gt;&gt; print(a.property.with.a.long.path)  // 43<br>&gt;&gt; <br>&gt;&gt; DISCUSSION<br>&gt;&gt; <br>&gt;&gt; I&#39;m throwing these both out there. I have nothing to really say about Tino&#39;s but I do think my and Jacob&#39;s <br>&gt;&gt; proposal has the advantages of:<br>&gt;&gt; <br>&gt;&gt; * Simplifying an mildly complex and potentially misleading statement <br>&gt;&gt; * Creating a deliberate and controlled rather than accidental shadowing style<br>&gt;&gt; <br>&gt;&gt; Have at it.<br>&gt;&gt; <br>&gt;&gt; -- Erica<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt;   -- Howard.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/bdc4d392/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>The bind thread</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>February  1, 2016 at 03:00:00pm</p></header><div class="content"><p>I don&#39;t think that the keyword is silly but this is a good point. I forgot<br>that this application of the `?` postfix exists.<br></p><p>On Mon, Feb 1, 2016 at 2:56 PM, Tyler Cloutier via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The bind or exists keywords seem sort of silly to me. There is already<br>&gt; syntax for binding optionals:<br>&gt;<br>&gt; if x? {<br>&gt; foo(x) // x type narrowed after binding.<br>&gt; }<br>&gt;<br>&gt; Tyler<br>&gt;<br>&gt;<br>&gt; On Feb 1, 2016, at 11:35 AM, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I like this proposal. I also think that either bind or exists could be the<br>&gt; keyword. I would suggest that both forms of syntax should be allowed, e.g.:<br>&gt;<br>&gt;     if bind x { /* x is non-nil, unwrapped, and hides original x inside if<br>&gt; statement */ }<br>&gt;     if bind x = object.property { /* x is non-nil and unwrapped */ }<br>&gt;<br>&gt; On Tuesday, 2 February 2016, Dave via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I *think* it’d be _<br>&gt;&gt;<br>&gt;&gt; You could use it to test if the return value is non-nil, but you’d have<br>&gt;&gt; to revert to “if let x = …” to actually use the results.<br>&gt;&gt;<br>&gt;&gt; I think.<br>&gt;&gt;<br>&gt;&gt; - Dave Sweeris<br>&gt;&gt;<br>&gt;&gt; On Feb 1, 2016, at 11:22, T.J. Usiyan via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; This is interesting. What name is created by<br>&gt;&gt;<br>&gt;&gt;   if bind foo.somethingReturningAnOptional {<br>&gt;&gt;       // ???<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt; On Mon, Feb 1, 2016 at 2:18 PM, Erica Sadun via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Joe says &quot;If you all are serious about this, I think you should start a<br>&gt;&gt;&gt; new thread about it.&quot;<br>&gt;&gt;&gt; I think it&#39;s worth a serious discussion just so it can be evaluated and<br>&gt;&gt;&gt; either adopted or discarded<br>&gt;&gt;&gt; and dropped forever. Here goes.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; INTRO<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The if let x = x {...} and guard let x = x else {...} constructs do<br>&gt;&gt;&gt; something with let (and var) that&#39;s<br>&gt;&gt;&gt; fundamentally different from let (and var) elsewhere in the language.<br>&gt;&gt;&gt; The same keywords are used to conditionally unwrap<br>&gt;&gt;&gt; and bind an item, not just shadow that item&#39;s current value.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Introducing a new bind keyword to indicate unwrapping and binding would<br>&gt;&gt;&gt; disambiguate these uses.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; DETAIL DESIGN:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jacob Bandes-Storch offers two common use-cases. I prefer his &quot;if bind<br>&gt;&gt;&gt; foo&quot; to my original &quot;if bind foo = foo&quot;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   if bind foo {<br>&gt;&gt;&gt;       // foo is non-optional in here<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   somethingAsync { [weak self] in<br>&gt;&gt;&gt;       guard bind self else { return }<br>&gt;&gt;&gt;       // ...<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; JBS&#39;s approach offers my original &quot;bind&quot; keyword to unwrap and shadow<br>&gt;&gt;&gt; bind, but also provides a way to<br>&gt;&gt;&gt; strongly bind a weak reference to self, which (presumably) would allow<br>&gt;&gt;&gt; self semantics in the remaining<br>&gt;&gt;&gt; lifetime of that scope.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ALTERNATIVE PROPOSALS:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Tino Heth proposes a second use-case one with different semantics. This<br>&gt;&gt;&gt; case, it seems to make an<br>&gt;&gt;&gt; alias rather than using binding for shadowing:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; bind x = a.property.with.a.long.path<br>&gt;&gt;&gt; print x  // 42<br>&gt;&gt;&gt; print(a.property.with.a.long.path == 42) =&gt; true<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; presumably this means:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; x += 1<br>&gt;&gt;&gt; print(a.property.with.a.long.path)  // 43<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; DISCUSSION<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m throwing these both out there. I have nothing to really say about<br>&gt;&gt;&gt; Tino&#39;s but I do think my and Jacob&#39;s<br>&gt;&gt;&gt; proposal has the advantages of:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * Simplifying an mildly complex and potentially misleading statement<br>&gt;&gt;&gt; * Creating a deliberate and controlled rather than accidental shadowing<br>&gt;&gt;&gt; style<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Have at it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -- Erica<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; --<br>&gt;   -- Howard.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/c5d0349a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>The bind thread</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>February  2, 2016 at 09:00:00am</p></header><div class="content"><p>I&#39;m -1 as stated, I don&#39;t think the proposed change adds any clarity, if<br>anything it adds more things to learn.<br></p><p>I think you can achieve some of your goals with a linter. You need to<br>consider how this works with pattern matching. It would remove the ability<br>to mutate the value type in a switch without a reassignment.<br></p><p>I&#39;m closer to liking it if it removes nothing from the language and adds<br>something like this:<br></p><p>var x: Int?<br>let y: Int?<br>if bind x, y where x == y {<br>    x = 4 // changes the x outside this scope<br>    y = 5 // compile time error<br>    x = nil // compile time error<br>}<br></p><p>I think that makes bind make more sense, and less surprising. However it<br>doesn&#39;t clarify anything about it no longer being optional.<br></p><p>It would be nice if the following worked, although I it has its own issues<br>with surprises:<br></p><p>let x: Int? = 123<br>if x != nil {<br>   ... // x is non-optional here<br>}<br>assert(x != nil)<br>// x is non-optional here<br></p><p>var y: Int? = 456<br>while y != nil {<br>    // y is non-optional here<br>}<br>// y is optional here<br></p><p>On Tuesday, 2 February 2016, T.J. Usiyan via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I don&#39;t think that the keyword is silly but this is a good point. I forgot<br>&gt; that this application of the `?` postfix exists.<br>&gt;<br>&gt; On Mon, Feb 1, 2016 at 2:56 PM, Tyler Cloutier via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; The bind or exists keywords seem sort of silly to me. There is already<br>&gt;&gt; syntax for binding optionals:<br>&gt;&gt;<br>&gt;&gt; if x? {<br>&gt;&gt; foo(x) // x type narrowed after binding.<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Tyler<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Feb 1, 2016, at 11:35 AM, Howard Lovatt via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I like this proposal. I also think that either bind or exists could be<br>&gt;&gt; the keyword. I would suggest that both forms of syntax should be allowed,<br>&gt;&gt; e.g.:<br>&gt;&gt;<br>&gt;&gt;     if bind x { /* x is non-nil, unwrapped, and hides original x inside<br>&gt;&gt; if statement */ }<br>&gt;&gt;     if bind x = object.property { /* x is non-nil and unwrapped */ }<br>&gt;&gt;<br>&gt;&gt; On Tuesday, 2 February 2016, Dave via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I *think* it’d be _<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; You could use it to test if the return value is non-nil, but you’d have<br>&gt;&gt;&gt; to revert to “if let x = …” to actually use the results.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Feb 1, 2016, at 11:22, T.J. Usiyan via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is interesting. What name is created by<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   if bind foo.somethingReturningAnOptional {<br>&gt;&gt;&gt;       // ???<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mon, Feb 1, 2016 at 2:18 PM, Erica Sadun via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Joe says &quot;If you all are serious about this, I think you should start<br>&gt;&gt;&gt;&gt; a new thread about it.&quot;<br>&gt;&gt;&gt;&gt; I think it&#39;s worth a serious discussion just so it can be evaluated and<br>&gt;&gt;&gt;&gt; either adopted or discarded<br>&gt;&gt;&gt;&gt; and dropped forever. Here goes.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; INTRO<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The if let x = x {...} and guard let x = x else {...} constructs do<br>&gt;&gt;&gt;&gt; something with let (and var) that&#39;s<br>&gt;&gt;&gt;&gt; fundamentally different from let (and var) elsewhere in the language.<br>&gt;&gt;&gt;&gt; The same keywords are used to conditionally unwrap<br>&gt;&gt;&gt;&gt; and bind an item, not just shadow that item&#39;s current value.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Introducing a new bind keyword to indicate unwrapping and binding<br>&gt;&gt;&gt;&gt; would disambiguate these uses.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; DETAIL DESIGN:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Jacob Bandes-Storch offers two common use-cases. I prefer his &quot;if bind<br>&gt;&gt;&gt;&gt; foo&quot; to my original &quot;if bind foo = foo&quot;:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   if bind foo {<br>&gt;&gt;&gt;&gt;       // foo is non-optional in here<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   somethingAsync { [weak self] in<br>&gt;&gt;&gt;&gt;       guard bind self else { return }<br>&gt;&gt;&gt;&gt;       // ...<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; JBS&#39;s approach offers my original &quot;bind&quot; keyword to unwrap and shadow<br>&gt;&gt;&gt;&gt; bind, but also provides a way to<br>&gt;&gt;&gt;&gt; strongly bind a weak reference to self, which (presumably) would allow<br>&gt;&gt;&gt;&gt; self semantics in the remaining<br>&gt;&gt;&gt;&gt; lifetime of that scope.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ALTERNATIVE PROPOSALS:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Tino Heth proposes a second use-case one with different semantics. This<br>&gt;&gt;&gt;&gt; case, it seems to make an<br>&gt;&gt;&gt;&gt; alias rather than using binding for shadowing:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; bind x = a.property.with.a.long.path<br>&gt;&gt;&gt;&gt; print x  // 42<br>&gt;&gt;&gt;&gt; print(a.property.with.a.long.path == 42) =&gt; true<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; presumably this means:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; x += 1<br>&gt;&gt;&gt;&gt; print(a.property.with.a.long.path)  // 43<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; DISCUSSION<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I&#39;m throwing these both out there. I have nothing to really say about<br>&gt;&gt;&gt;&gt; Tino&#39;s but I do think my and Jacob&#39;s<br>&gt;&gt;&gt;&gt; proposal has the advantages of:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * Simplifying an mildly complex and potentially misleading statement<br>&gt;&gt;&gt;&gt; * Creating a deliberate and controlled rather than accidental shadowing<br>&gt;&gt;&gt;&gt; style<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Have at it.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -- Erica<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt;   -- Howard.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/77174fb9/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>The bind thread</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>February  2, 2016 at 10:00:00am</p></header><div class="content"><p>There is a language, Nice (related to Java), that does:<br></p><p>    if x != nil {<br>        // x is unwrapped<br>    }<br></p><p>As Andrew has already suggested as a possibility. However I am not sure<br>that it is a great idea because why should this particular if statement<br>have &#39;magic&#39;?<br></p><p>How about:<br></p><p>     ifsome x { // Equivalent to current `if let x = x`, note `ifsome` is<br>one word<br>        // x is unwrapped<br>    }<br></p><p>This doesn&#39;t use `bind` which has some baggage, it doesn&#39;t use `var` or<br>`let` which have other meanings, `ifsome` is an unusual word and hence<br>unlikely to be useful as a name, and it is clear it is not a normal `if`<br>statement.<br></p><p>Don&#39;t change `case` clauses, they are not confusing, they do introduce a<br>new variable and hence `let` and `var` are appropriate.<br></p><p>On Tuesday, 2 February 2016, Andrew Bennett via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;m -1 as stated, I don&#39;t think the proposed change adds any clarity, if<br>&gt; anything it adds more things to learn.<br>&gt;<br>&gt; I think you can achieve some of your goals with a linter. You need to<br>&gt; consider how this works with pattern matching. It would remove the ability<br>&gt; to mutate the value type in a switch without a reassignment.<br>&gt;<br>&gt; I&#39;m closer to liking it if it removes nothing from the language and adds<br>&gt; something like this:<br>&gt;<br>&gt; var x: Int?<br>&gt; let y: Int?<br>&gt; if bind x, y where x == y {<br>&gt;     x = 4 // changes the x outside this scope<br>&gt;     y = 5 // compile time error<br>&gt;     x = nil // compile time error<br>&gt; }<br>&gt;<br>&gt; I think that makes bind make more sense, and less surprising. However it<br>&gt; doesn&#39;t clarify anything about it no longer being optional.<br>&gt;<br>&gt; It would be nice if the following worked, although I it has its own issues<br>&gt; with surprises:<br>&gt;<br>&gt; let x: Int? = 123<br>&gt; if x != nil {<br>&gt;    ... // x is non-optional here<br>&gt; }<br>&gt; assert(x != nil)<br>&gt; // x is non-optional here<br>&gt;<br>&gt; var y: Int? = 456<br>&gt; while y != nil {<br>&gt;     // y is non-optional here<br>&gt; }<br>&gt; // y is optional here<br>&gt;<br>&gt; On Tuesday, 2 February 2016, T.J. Usiyan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; I don&#39;t think that the keyword is silly but this is a good point. I<br>&gt;&gt; forgot that this application of the `?` postfix exists.<br>&gt;&gt;<br>&gt;&gt; On Mon, Feb 1, 2016 at 2:56 PM, Tyler Cloutier via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; The bind or exists keywords seem sort of silly to me. There is already<br>&gt;&gt;&gt; syntax for binding optionals:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if x? {<br>&gt;&gt;&gt; foo(x) // x type narrowed after binding.<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Feb 1, 2016, at 11:35 AM, Howard Lovatt via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I like this proposal. I also think that either bind or exists could be<br>&gt;&gt;&gt; the keyword. I would suggest that both forms of syntax should be allowed,<br>&gt;&gt;&gt; e.g.:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     if bind x { /* x is non-nil, unwrapped, and hides original x inside<br>&gt;&gt;&gt; if statement */ }<br>&gt;&gt;&gt;     if bind x = object.property { /* x is non-nil and unwrapped */ }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tuesday, 2 February 2016, Dave via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I *think* it’d be _<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; You could use it to test if the return value is non-nil, but you’d have<br>&gt;&gt;&gt;&gt; to revert to “if let x = …” to actually use the results.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I think.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Feb 1, 2016, at 11:22, T.J. Usiyan via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is interesting. What name is created by<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   if bind foo.somethingReturningAnOptional {<br>&gt;&gt;&gt;&gt;       // ???<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Mon, Feb 1, 2016 at 2:18 PM, Erica Sadun via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Joe says &quot;If you all are serious about this, I think you should start<br>&gt;&gt;&gt;&gt;&gt; a new thread about it.&quot;<br>&gt;&gt;&gt;&gt;&gt; I think it&#39;s worth a serious discussion just so it can be evaluated<br>&gt;&gt;&gt;&gt;&gt; and either adopted or discarded<br>&gt;&gt;&gt;&gt;&gt; and dropped forever. Here goes.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; INTRO<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; The if let x = x {...} and guard let x = x else {...} constructs do<br>&gt;&gt;&gt;&gt;&gt; something with let (and var) that&#39;s<br>&gt;&gt;&gt;&gt;&gt; fundamentally different from let (and var) elsewhere in the<br>&gt;&gt;&gt;&gt;&gt; language.  The same keywords are used to conditionally unwrap<br>&gt;&gt;&gt;&gt;&gt; and bind an item, not just shadow that item&#39;s current value.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Introducing a new bind keyword to indicate unwrapping and binding<br>&gt;&gt;&gt;&gt;&gt; would disambiguate these uses.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; DETAIL DESIGN:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Jacob Bandes-Storch offers two common use-cases. I prefer his &quot;if bind<br>&gt;&gt;&gt;&gt;&gt; foo&quot; to my original &quot;if bind foo = foo&quot;:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;   if bind foo {<br>&gt;&gt;&gt;&gt;&gt;       // foo is non-optional in here<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;   somethingAsync { [weak self] in<br>&gt;&gt;&gt;&gt;&gt;       guard bind self else { return }<br>&gt;&gt;&gt;&gt;&gt;       // ...<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; JBS&#39;s approach offers my original &quot;bind&quot; keyword to unwrap and shadow<br>&gt;&gt;&gt;&gt;&gt; bind, but also provides a way to<br>&gt;&gt;&gt;&gt;&gt; strongly bind a weak reference to self, which (presumably) would allow<br>&gt;&gt;&gt;&gt;&gt; self semantics in the remaining<br>&gt;&gt;&gt;&gt;&gt; lifetime of that scope.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; ALTERNATIVE PROPOSALS:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Tino Heth proposes a second use-case one with different semantics.<br>&gt;&gt;&gt;&gt;&gt; This case, it seems to make an<br>&gt;&gt;&gt;&gt;&gt; alias rather than using binding for shadowing:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; bind x = a.property.with.a.long.path<br>&gt;&gt;&gt;&gt;&gt; print x  // 42<br>&gt;&gt;&gt;&gt;&gt; print(a.property.with.a.long.path == 42) =&gt; true<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; presumably this means:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; x += 1<br>&gt;&gt;&gt;&gt;&gt; print(a.property.with.a.long.path)  // 43<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; DISCUSSION<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I&#39;m throwing these both out there. I have nothing to really say about<br>&gt;&gt;&gt;&gt;&gt; Tino&#39;s but I do think my and Jacob&#39;s<br>&gt;&gt;&gt;&gt;&gt; proposal has the advantages of:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; * Simplifying an mildly complex and potentially misleading statement<br>&gt;&gt;&gt;&gt;&gt; * Creating a deliberate and controlled rather than accidental<br>&gt;&gt;&gt;&gt;&gt; shadowing style<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Have at it.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; -- Erica<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt;   -- Howard.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br></p><p>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/04cc83f2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>The bind thread</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>February  1, 2016 at 05:00:00pm</p></header><div class="content"><p>The thing I like about “if let x = y” over all these alternatives — either shorthand like “ifsome” or Ceylon/Kotlin-like expression analysis— is that it generalizes to y being an arbitrary expression.<br></p><p>No special case needed for this:<br></p><p>    if let x = foo.bar?.baz<br></p><p>…or this:<br></p><p>    if let x = y as? SomeType<br></p><p>They just fall out naturally.<br></p><p>P<br></p><p>&gt; On Feb 1, 2016, at 5:04 PM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There is a language, Nice (related to Java), that does:<br>&gt; <br>&gt;     if x != nil {<br>&gt;         // x is unwrapped<br>&gt;     }<br>&gt; <br>&gt; As Andrew has already suggested as a possibility. However I am not sure that it is a great idea because why should this particular if statement have &#39;magic&#39;?<br>&gt; <br>&gt; How about:<br>&gt; <br>&gt;      ifsome x { // Equivalent to current `if let x = x`, note `ifsome` is one word<br>&gt;         // x is unwrapped<br>&gt;     }<br>&gt; <br>&gt; This doesn&#39;t use `bind` which has some baggage, it doesn&#39;t use `var` or `let` which have other meanings, `ifsome` is an unusual word and hence unlikely to be useful as a name, and it is clear it is not a normal `if` statement.<br>&gt; <br>&gt; Don&#39;t change `case` clauses, they are not confusing, they do introduce a new variable and hence `let` and `var` are appropriate. <br>&gt; <br>&gt; On Tuesday, 2 February 2016, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I&#39;m -1 as stated, I don&#39;t think the proposed change adds any clarity, if anything it adds more things to learn.<br>&gt; <br>&gt; I think you can achieve some of your goals with a linter. You need to consider how this works with pattern matching. It would remove the ability to mutate the value type in a switch without a reassignment.<br>&gt; <br>&gt; I&#39;m closer to liking it if it removes nothing from the language and adds something like this:<br>&gt; <br>&gt; var x: Int?<br>&gt; let y: Int?<br>&gt; if bind x, y where x == y {<br>&gt;     x = 4 // changes the x outside this scope<br>&gt;     y = 5 // compile time error<br>&gt;     x = nil // compile time error<br>&gt; }<br>&gt; <br>&gt; I think that makes bind make more sense, and less surprising. However it doesn&#39;t clarify anything about it no longer being optional.<br>&gt; <br>&gt; It would be nice if the following worked, although I it has its own issues with surprises:<br>&gt; <br>&gt; let x: Int? = 123<br>&gt; if x != nil {<br>&gt;    ... // x is non-optional here<br>&gt; }<br>&gt; assert(x != nil)<br>&gt; // x is non-optional here<br>&gt; <br>&gt; var y: Int? = 456<br>&gt; while y != nil {<br>&gt;     // y is non-optional here<br>&gt; }<br>&gt; // y is optional here<br>&gt; <br>&gt; On Tuesday, 2 February 2016, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; wrote:<br>&gt; I don&#39;t think that the keyword is silly but this is a good point. I forgot that this application of the `?` postfix exists.<br>&gt; <br>&gt; On Mon, Feb 1, 2016 at 2:56 PM, Tyler Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; wrote:<br>&gt; The bind or exists keywords seem sort of silly to me. There is already syntax for binding optionals:<br>&gt; <br>&gt; if x? {<br>&gt; 	foo(x) // x type narrowed after binding.<br>&gt; }<br>&gt; <br>&gt; Tyler<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 1, 2016, at 11:35 AM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I like this proposal. I also think that either bind or exists could be the keyword. I would suggest that both forms of syntax should be allowed, e.g.:<br>&gt;&gt; <br>&gt;&gt;     if bind x { /* x is non-nil, unwrapped, and hides original x inside if statement */ }<br>&gt;&gt;     if bind x = object.property { /* x is non-nil and unwrapped */ }<br>&gt;&gt; <br>&gt;&gt; On Tuesday, 2 February 2016, Dave via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; wrote:<br>&gt;&gt; I think it’d be _<br>&gt;&gt; <br>&gt;&gt; You could use it to test if the return value is non-nil, but you’d have to revert to “if let x = …” to actually use the results.<br>&gt;&gt; <br>&gt;&gt; I think.<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 1, 2016, at 11:22, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is interesting. What name is created by <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   if bind foo.somethingReturningAnOptional {<br>&gt;&gt;&gt;       // ???<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, Feb 1, 2016 at 2:18 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt;wrote:<br>&gt;&gt;&gt; Joe says &quot;If you all are serious about this, I think you should start a new thread about it.&quot; <br>&gt;&gt;&gt; I think it&#39;s worth a serious discussion just so it can be evaluated and either adopted or discarded<br>&gt;&gt;&gt; and dropped forever. Here goes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; INTRO<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The if let x = x {...} and guard let x = x else {...} constructs do something with let (and var) that&#39;s <br>&gt;&gt;&gt; fundamentally different from let (and var) elsewhere in the language.  The same keywords are used to conditionally unwrap<br>&gt;&gt;&gt; and bind an item, not just shadow that item&#39;s current value.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introducing a new bind keyword to indicate unwrapping and binding would disambiguate these uses.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; DETAIL DESIGN:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jacob Bandes-Storch offers two common use-cases. I prefer his &quot;if bind foo&quot; to my original &quot;if bind foo = foo&quot;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   if bind foo {<br>&gt;&gt;&gt;       // foo is non-optional in here<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   somethingAsync { [weak self] in<br>&gt;&gt;&gt;       guard bind self else { return }<br>&gt;&gt;&gt;       // ...<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; JBS&#39;s approach offers my original &quot;bind&quot; keyword to unwrap and shadow bind, but also provides a way to <br>&gt;&gt;&gt; strongly bind a weak reference to self, which (presumably) would allow self semantics in the remaining<br>&gt;&gt;&gt; lifetime of that scope.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ALTERNATIVE PROPOSALS:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Tino Heth proposes a second use-case one with different semantics. This case, it seems to make an<br>&gt;&gt;&gt; alias rather than using binding for shadowing:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; bind x = a.property.with.a.long.path<br>&gt;&gt;&gt; print x  // 42<br>&gt;&gt;&gt; print(a.property.with.a.long.path == 42) =&gt; true<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; presumably this means:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; x += 1<br>&gt;&gt;&gt; print(a.property.with.a.long.path)  // 43<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; DISCUSSION<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m throwing these both out there. I have nothing to really say about Tino&#39;s but I do think my and Jacob&#39;s <br>&gt;&gt;&gt; proposal has the advantages of:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Simplifying an mildly complex and potentially misleading statement <br>&gt;&gt;&gt; * Creating a deliberate and controlled rather than accidental shadowing style<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Have at it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- Erica<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt;   -- Howard.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt;   -- Howard.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/727b91c9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>The bind thread</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>February  1, 2016 at 05:00:00pm</p></header><div class="content"><p>I didn&#39;t actually try<br>```<br>if x? {<br>foo(x) // x type narrowed after binding.<br>}<br>```<br></p><p>in a swift file and I should have.<br></p><p><br>To misquote a movie<br>*That code, you keep using that code. I do not think it does what you think<br>it does.*<br></p><p>I *do* recall discussion of this syntax and it might have been in an<br>earlier version, but it does not work now. What I receive is  `error:<br>optional type &#39;_?&#39; cannot be used as a boolean; test for &#39;!= nil&#39; instead`.<br>I agree with this because that question mark was not, in my opinion, sigil<br>enough for the action.<br></p><p><br></p><p>On Mon, Feb 1, 2016 at 2:56 PM, Tyler Cloutier via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The bind or exists keywords seem sort of silly to me. There is already<br>&gt; syntax for binding optionals:<br>&gt;<br>&gt; if x? {<br>&gt; foo(x) // x type narrowed after binding.<br>&gt; }<br>&gt;<br>&gt; Tyler<br>&gt;<br>&gt;<br>&gt; On Feb 1, 2016, at 11:35 AM, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I like this proposal. I also think that either bind or exists could be the<br>&gt; keyword. I would suggest that both forms of syntax should be allowed, e.g.:<br>&gt;<br>&gt;     if bind x { /* x is non-nil, unwrapped, and hides original x inside if<br>&gt; statement */ }<br>&gt;     if bind x = object.property { /* x is non-nil and unwrapped */ }<br>&gt;<br>&gt; On Tuesday, 2 February 2016, Dave via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I *think* it’d be _<br>&gt;&gt;<br>&gt;&gt; You could use it to test if the return value is non-nil, but you’d have<br>&gt;&gt; to revert to “if let x = …” to actually use the results.<br>&gt;&gt;<br>&gt;&gt; I think.<br>&gt;&gt;<br>&gt;&gt; - Dave Sweeris<br>&gt;&gt;<br>&gt;&gt; On Feb 1, 2016, at 11:22, T.J. Usiyan via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; This is interesting. What name is created by<br>&gt;&gt;<br>&gt;&gt;   if bind foo.somethingReturningAnOptional {<br>&gt;&gt;       // ???<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt; On Mon, Feb 1, 2016 at 2:18 PM, Erica Sadun via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Joe says &quot;If you all are serious about this, I think you should start a<br>&gt;&gt;&gt; new thread about it.&quot;<br>&gt;&gt;&gt; I think it&#39;s worth a serious discussion just so it can be evaluated and<br>&gt;&gt;&gt; either adopted or discarded<br>&gt;&gt;&gt; and dropped forever. Here goes.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; INTRO<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The if let x = x {...} and guard let x = x else {...} constructs do<br>&gt;&gt;&gt; something with let (and var) that&#39;s<br>&gt;&gt;&gt; fundamentally different from let (and var) elsewhere in the language.<br>&gt;&gt;&gt; The same keywords are used to conditionally unwrap<br>&gt;&gt;&gt; and bind an item, not just shadow that item&#39;s current value.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Introducing a new bind keyword to indicate unwrapping and binding would<br>&gt;&gt;&gt; disambiguate these uses.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; DETAIL DESIGN:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jacob Bandes-Storch offers two common use-cases. I prefer his &quot;if bind<br>&gt;&gt;&gt; foo&quot; to my original &quot;if bind foo = foo&quot;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   if bind foo {<br>&gt;&gt;&gt;       // foo is non-optional in here<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   somethingAsync { [weak self] in<br>&gt;&gt;&gt;       guard bind self else { return }<br>&gt;&gt;&gt;       // ...<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; JBS&#39;s approach offers my original &quot;bind&quot; keyword to unwrap and shadow<br>&gt;&gt;&gt; bind, but also provides a way to<br>&gt;&gt;&gt; strongly bind a weak reference to self, which (presumably) would allow<br>&gt;&gt;&gt; self semantics in the remaining<br>&gt;&gt;&gt; lifetime of that scope.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ALTERNATIVE PROPOSALS:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Tino Heth proposes a second use-case one with different semantics. This<br>&gt;&gt;&gt; case, it seems to make an<br>&gt;&gt;&gt; alias rather than using binding for shadowing:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; bind x = a.property.with.a.long.path<br>&gt;&gt;&gt; print x  // 42<br>&gt;&gt;&gt; print(a.property.with.a.long.path == 42) =&gt; true<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; presumably this means:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; x += 1<br>&gt;&gt;&gt; print(a.property.with.a.long.path)  // 43<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; DISCUSSION<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m throwing these both out there. I have nothing to really say about<br>&gt;&gt;&gt; Tino&#39;s but I do think my and Jacob&#39;s<br>&gt;&gt;&gt; proposal has the advantages of:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * Simplifying an mildly complex and potentially misleading statement<br>&gt;&gt;&gt; * Creating a deliberate and controlled rather than accidental shadowing<br>&gt;&gt;&gt; style<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Have at it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -- Erica<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; --<br>&gt;   -- Howard.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/e519f367/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>The bind thread</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February  1, 2016 at 12:00:00pm</p></header><div class="content"><p>It would have to be something along the lines of $0 wouldn&#39;t it? If there was no clear single symbol to shadow?<br></p><p>That&#39;s a very good point, and thank you for bringing it up.<br></p><p>-- Erica<br></p><p>&gt; On Feb 1, 2016, at 12:22 PM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; <br>&gt; This is interesting. What name is created by <br>&gt; <br>&gt;   if bind foo.somethingReturningAnOptional {<br>&gt;       // ???<br>&gt;   }<br>&gt; <br>&gt; On Mon, Feb 1, 2016 at 2:18 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Joe says &quot;If you all are serious about this, I think you should start a new thread about it.&quot; <br>&gt; I think it&#39;s worth a serious discussion just so it can be evaluated and either adopted or discarded<br>&gt; and dropped forever. Here goes.<br>&gt; <br>&gt; INTRO<br>&gt; <br>&gt; The if let x = x {...} and guard let x = x else {...} constructs do something with let (and var) that&#39;s <br>&gt; fundamentally different from let (and var) elsewhere in the language.  The same keywords are used to conditionally unwrap<br>&gt; and bind an item, not just shadow that item&#39;s current value.<br>&gt; <br>&gt; Introducing a new bind keyword to indicate unwrapping and binding would disambiguate these uses.<br>&gt; <br>&gt; DETAIL DESIGN:<br>&gt; <br>&gt; Jacob Bandes-Storch offers two common use-cases. I prefer his &quot;if bind foo&quot; to my original &quot;if bind foo = foo&quot;:<br>&gt; <br>&gt;   if bind foo {<br>&gt;       // foo is non-optional in here<br>&gt;   }<br>&gt; <br>&gt;   somethingAsync { [weak self] in<br>&gt;       guard bind self else { return }<br>&gt;       // ...<br>&gt;   }<br>&gt; <br>&gt; JBS&#39;s approach offers my original &quot;bind&quot; keyword to unwrap and shadow bind, but also provides a way to <br>&gt; strongly bind a weak reference to self, which (presumably) would allow self semantics in the remaining<br>&gt; lifetime of that scope.<br>&gt; <br>&gt; ALTERNATIVE PROPOSALS:<br>&gt; <br>&gt; Tino Heth proposes a second use-case one with different semantics. This case, it seems to make an<br>&gt; alias rather than using binding for shadowing:<br>&gt; <br>&gt; bind x = a.property.with.a.long.path<br>&gt; print x  // 42<br>&gt; print(a.property.with.a.long.path == 42) =&gt; true<br>&gt; <br>&gt; presumably this means:<br>&gt; <br>&gt; x += 1<br>&gt; print(a.property.with.a.long.path)  // 43<br>&gt; <br>&gt; DISCUSSION<br>&gt; <br>&gt; I&#39;m throwing these both out there. I have nothing to really say about Tino&#39;s but I do think my and Jacob&#39;s <br>&gt; proposal has the advantages of:<br>&gt; <br>&gt; * Simplifying an mildly complex and potentially misleading statement <br>&gt; * Creating a deliberate and controlled rather than accidental shadowing style<br>&gt; <br>&gt; Have at it.<br>&gt; <br>&gt; -- Erica<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/656880af/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>The bind thread</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>February  1, 2016 at 03:00:00pm</p></header><div class="content"><p>Ok, would that mean that we could use closure syntax to …associate the<br>value with a name?<br></p><p>  if bind foo.somethingReturningAnOptional { foo in<br>      // ???<br>  }<br></p><p>I think that the question brings me back to my initial thought when reading<br>this that it is dangerously &quot;close but not quite the same as&quot; the &#39;other&#39;<br>meaning of `bind`. I don&#39;t thank that the closeness should shut down<br>discussion of this but I would like to float the name `unwrap` instead.<br>This makes a near-implementation that is currently possible make more sense.<br></p><p>func unwrap&lt;Wrapped&gt;(wrapped: Wrapped?, handler: Wrapped -&gt; Void) -&gt; Bool<br></p><p><br>The `Bool` represents whether or not the unwrap was successful and the<br>`else` flows from that thought without issue. (`bind` works in this regard<br>as well but becomes, in my opinion, it becomes even more confusing to have<br>a bind with the suggested signature.)<br></p><p>TJ<br></p><p><br>On Mon, Feb 1, 2016 at 2:27 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt; It would have to be something along the lines of $0 wouldn&#39;t it? If there<br>&gt; was no clear single symbol to shadow?<br>&gt;<br>&gt; That&#39;s a very good point, and thank you for bringing it up.<br>&gt;<br>&gt; -- Erica<br>&gt;<br>&gt; On Feb 1, 2016, at 12:22 PM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;<br>&gt; This is interesting. What name is created by<br>&gt;<br>&gt;   if bind foo.somethingReturningAnOptional {<br>&gt;       // ???<br>&gt;   }<br>&gt;<br>&gt; On Mon, Feb 1, 2016 at 2:18 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Joe says &quot;If you all are serious about this, I think you should start a<br>&gt;&gt; new thread about it.&quot;<br>&gt;&gt; I think it&#39;s worth a serious discussion just so it can be evaluated and<br>&gt;&gt; either adopted or discarded<br>&gt;&gt; and dropped forever. Here goes.<br>&gt;&gt;<br>&gt;&gt; INTRO<br>&gt;&gt;<br>&gt;&gt; The if let x = x {...} and guard let x = x else {...} constructs do<br>&gt;&gt; something with let (and var) that&#39;s<br>&gt;&gt; fundamentally different from let (and var) elsewhere in the language.<br>&gt;&gt; The same keywords are used to conditionally unwrap<br>&gt;&gt; and bind an item, not just shadow that item&#39;s current value.<br>&gt;&gt;<br>&gt;&gt; Introducing a new bind keyword to indicate unwrapping and binding would<br>&gt;&gt; disambiguate these uses.<br>&gt;&gt;<br>&gt;&gt; DETAIL DESIGN:<br>&gt;&gt;<br>&gt;&gt; Jacob Bandes-Storch offers two common use-cases. I prefer his &quot;if bind<br>&gt;&gt; foo&quot; to my original &quot;if bind foo = foo&quot;:<br>&gt;&gt;<br>&gt;&gt;   if bind foo {<br>&gt;&gt;       // foo is non-optional in here<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   somethingAsync { [weak self] in<br>&gt;&gt;       guard bind self else { return }<br>&gt;&gt;       // ...<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt; JBS&#39;s approach offers my original &quot;bind&quot; keyword to unwrap and shadow<br>&gt;&gt; bind, but also provides a way to<br>&gt;&gt; strongly bind a weak reference to self, which (presumably) would allow<br>&gt;&gt; self semantics in the remaining<br>&gt;&gt; lifetime of that scope.<br>&gt;&gt;<br>&gt;&gt; ALTERNATIVE PROPOSALS:<br>&gt;&gt;<br>&gt;&gt; Tino Heth proposes a second use-case one with different semantics. This<br>&gt;&gt; case, it seems to make an<br>&gt;&gt; alias rather than using binding for shadowing:<br>&gt;&gt;<br>&gt;&gt; bind x = a.property.with.a.long.path<br>&gt;&gt; print x  // 42<br>&gt;&gt; print(a.property.with.a.long.path == 42) =&gt; true<br>&gt;&gt;<br>&gt;&gt; presumably this means:<br>&gt;&gt;<br>&gt;&gt; x += 1<br>&gt;&gt; print(a.property.with.a.long.path)  // 43<br>&gt;&gt;<br>&gt;&gt; DISCUSSION<br>&gt;&gt;<br>&gt;&gt; I&#39;m throwing these both out there. I have nothing to really say about<br>&gt;&gt; Tino&#39;s but I do think my and Jacob&#39;s<br>&gt;&gt; proposal has the advantages of:<br>&gt;&gt;<br>&gt;&gt; * Simplifying an mildly complex and potentially misleading statement<br>&gt;&gt; * Creating a deliberate and controlled rather than accidental shadowing<br>&gt;&gt; style<br>&gt;&gt;<br>&gt;&gt; Have at it.<br>&gt;&gt;<br>&gt;&gt; -- Erica<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/e42e0e42/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>The bind thread</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>February  1, 2016 at 03:00:00pm</p></header><div class="content"><p>My apologies for the double post but 2.2 (no need for backticks around<br>&#39;else&#39; as a parameter name) allows a slightly different approach right now<br>(I am not exactly suggesting that this solves the problem completely, just<br>seeing what it looks like.)<br></p><p>        func unwrap&lt;Wrapped&gt;(wrapped: Wrapped?, _ unwrapHandler: Wrapped -&gt;<br>Void, else failureHandler: Void -&gt; Void) {<br>   switch wrapped {<br>   case let .Some(value):<br>       unwrapHandler(value)<br>   case .None:<br>       failureHandler()<br>   }<br>}<br></p><p>// allows<br></p><p>let theBox:Int? = 4<br></p><p>unwrap(theBox, { print(&quot;the value is \($0)&quot;) }<br>   , else: {<br>   print (&quot;Nothing in the box!&quot;)<br>})<br></p><p><br>On Mon, Feb 1, 2016 at 3:14 PM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br></p><p>&gt; Ok, would that mean that we could use closure syntax to …associate the<br>&gt; value with a name?<br>&gt;<br>&gt;   if bind foo.somethingReturningAnOptional { foo in<br>&gt;       // ???<br>&gt;   }<br>&gt;<br>&gt; I think that the question brings me back to my initial thought when<br>&gt; reading this that it is dangerously &quot;close but not quite the same as&quot; the<br>&gt; &#39;other&#39; meaning of `bind`. I don&#39;t thank that the closeness should shut<br>&gt; down discussion of this but I would like to float the name `unwrap`<br>&gt; instead. This makes a near-implementation that is currently possible make<br>&gt; more sense.<br>&gt;<br>&gt; func unwrap&lt;Wrapped&gt;(wrapped: Wrapped?, handler: Wrapped -&gt; Void) -&gt; Bool<br>&gt;<br>&gt;<br>&gt; The `Bool` represents whether or not the unwrap was successful and the<br>&gt; `else` flows from that thought without issue. (`bind` works in this regard<br>&gt; as well but becomes, in my opinion, it becomes even more confusing to have<br>&gt; a bind with the suggested signature.)<br>&gt;<br>&gt; TJ<br>&gt;<br>&gt;<br>&gt; On Mon, Feb 1, 2016 at 2:27 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;<br>&gt;&gt; It would have to be something along the lines of $0 wouldn&#39;t it? If there<br>&gt;&gt; was no clear single symbol to shadow?<br>&gt;&gt;<br>&gt;&gt; That&#39;s a very good point, and thank you for bringing it up.<br>&gt;&gt;<br>&gt;&gt; -- Erica<br>&gt;&gt;<br>&gt;&gt; On Feb 1, 2016, at 12:22 PM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; This is interesting. What name is created by<br>&gt;&gt;<br>&gt;&gt;   if bind foo.somethingReturningAnOptional {<br>&gt;&gt;       // ???<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt; On Mon, Feb 1, 2016 at 2:18 PM, Erica Sadun via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Joe says &quot;If you all are serious about this, I think you should start a<br>&gt;&gt;&gt; new thread about it.&quot;<br>&gt;&gt;&gt; I think it&#39;s worth a serious discussion just so it can be evaluated and<br>&gt;&gt;&gt; either adopted or discarded<br>&gt;&gt;&gt; and dropped forever. Here goes.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; INTRO<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The if let x = x {...} and guard let x = x else {...} constructs do<br>&gt;&gt;&gt; something with let (and var) that&#39;s<br>&gt;&gt;&gt; fundamentally different from let (and var) elsewhere in the language.<br>&gt;&gt;&gt; The same keywords are used to conditionally unwrap<br>&gt;&gt;&gt; and bind an item, not just shadow that item&#39;s current value.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Introducing a new bind keyword to indicate unwrapping and binding would<br>&gt;&gt;&gt; disambiguate these uses.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; DETAIL DESIGN:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jacob Bandes-Storch offers two common use-cases. I prefer his &quot;if bind<br>&gt;&gt;&gt; foo&quot; to my original &quot;if bind foo = foo&quot;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   if bind foo {<br>&gt;&gt;&gt;       // foo is non-optional in here<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   somethingAsync { [weak self] in<br>&gt;&gt;&gt;       guard bind self else { return }<br>&gt;&gt;&gt;       // ...<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; JBS&#39;s approach offers my original &quot;bind&quot; keyword to unwrap and shadow<br>&gt;&gt;&gt; bind, but also provides a way to<br>&gt;&gt;&gt; strongly bind a weak reference to self, which (presumably) would allow<br>&gt;&gt;&gt; self semantics in the remaining<br>&gt;&gt;&gt; lifetime of that scope.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ALTERNATIVE PROPOSALS:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Tino Heth proposes a second use-case one with different semantics. This<br>&gt;&gt;&gt; case, it seems to make an<br>&gt;&gt;&gt; alias rather than using binding for shadowing:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; bind x = a.property.with.a.long.path<br>&gt;&gt;&gt; print x  // 42<br>&gt;&gt;&gt; print(a.property.with.a.long.path == 42) =&gt; true<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; presumably this means:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; x += 1<br>&gt;&gt;&gt; print(a.property.with.a.long.path)  // 43<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; DISCUSSION<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m throwing these both out there. I have nothing to really say about<br>&gt;&gt;&gt; Tino&#39;s but I do think my and Jacob&#39;s<br>&gt;&gt;&gt; proposal has the advantages of:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * Simplifying an mildly complex and potentially misleading statement<br>&gt;&gt;&gt; * Creating a deliberate and controlled rather than accidental shadowing<br>&gt;&gt;&gt; style<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Have at it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -- Erica<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/db870f6f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>The bind thread</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>February  1, 2016 at 11:00:00am</p></header><div class="content"><p>I disagree. The “if let” and “if var” are part of the pattern matching syntax that is fairly unified throughout the language, especially with the reversal for removing “if var” from Swift. Also, does “bind” also replace the “let” and “var” usage in case statements? And how do you handle this case?<br></p><p>let items: [Int]? = [1, 5, 4]<br></p><p>if var items = items {<br>    items.sortInPlace()<br>}<br></p><p><br></p><p>-David<br></p><p><br>&gt; On Feb 1, 2016, at 11:18 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Joe says &quot;If you all are serious about this, I think you should start a new thread about it.&quot; <br>&gt; I think it&#39;s worth a serious discussion just so it can be evaluated and either adopted or discarded<br>&gt; and dropped forever. Here goes.<br>&gt; <br>&gt; INTRO<br>&gt; <br>&gt; The if let x = x {...} and guard let x = x else {...} constructs do something with let (and var) that&#39;s <br>&gt; fundamentally different from let (and var) elsewhere in the language.  The same keywords are used to conditionally unwrap<br>&gt; and bind an item, not just shadow that item&#39;s current value.<br>&gt; <br>&gt; Introducing a new bind keyword to indicate unwrapping and binding would disambiguate these uses.<br>&gt; <br>&gt; DETAIL DESIGN:<br>&gt; <br>&gt; Jacob Bandes-Storch offers two common use-cases. I prefer his &quot;if bind foo&quot; to my original &quot;if bind foo = foo&quot;:<br>&gt; <br>&gt;   if bind foo {<br>&gt;       // foo is non-optional in here<br>&gt;   }<br>&gt; <br>&gt;   somethingAsync { [weak self] in<br>&gt;       guard bind self else { return }<br>&gt;       // ...<br>&gt;   }<br>&gt; <br>&gt; JBS&#39;s approach offers my original &quot;bind&quot; keyword to unwrap and shadow bind, but also provides a way to <br>&gt; strongly bind a weak reference to self, which (presumably) would allow self semantics in the remaining<br>&gt; lifetime of that scope.<br>&gt; <br>&gt; ALTERNATIVE PROPOSALS:<br>&gt; <br>&gt; Tino Heth proposes a second use-case one with different semantics. This case, it seems to make an<br>&gt; alias rather than using binding for shadowing:<br>&gt; <br>&gt; bind x = a.property.with.a.long.path<br>&gt; print x  // 42<br>&gt; print(a.property.with.a.long.path == 42) =&gt; true<br>&gt; <br>&gt; presumably this means:<br>&gt; <br>&gt; x += 1<br>&gt; print(a.property.with.a.long.path)  // 43<br>&gt; <br>&gt; DISCUSSION<br>&gt; <br>&gt; I&#39;m throwing these both out there. I have nothing to really say about Tino&#39;s but I do think my and Jacob&#39;s <br>&gt; proposal has the advantages of:<br>&gt; <br>&gt; * Simplifying an mildly complex and potentially misleading statement <br>&gt; * Creating a deliberate and controlled rather than accidental shadowing style<br>&gt; <br>&gt; Have at it.<br>&gt; <br>&gt; -- Erica<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/9facd466/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>The bind thread</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>February  1, 2016 at 12:00:00pm</p></header><div class="content"><p>We&#39;ve had multiple threads in the past suggesting many different<br>variants on<br></p><p>if let foo {    // foo is non-optional in here }<br></p><p>The only difference with this one is it uses the keyword &quot;bind&quot; instead<br>of any of the various similar alternatives in the other threads.<br></p><p>And my answer is the same to all of this: This is a bad idea. Your<br>construct here does not actually include any notion of assignment or<br>initialization. The construct `if bind foo { ... }` looks like nonsense<br>to anyone who doesn&#39;t already explicitly know that it&#39;s shorthand for<br>`if let foo = foo { ... }`.<br></p><p>If your goal here is to just avoid having to write the `= foo`, then I<br>disagree with the whole motive. If your goal here is to just use a<br>keyword `bind` instead of `let` (e.g. if you want to use `if bind foo =<br>foo { ... }`), I still disagree, because this new keyword serves no<br>purpose. `if let foo = bar { ... }` is not &quot;fundamentally different&quot;<br>than `let foo = bar`, it&#39;s still binding a new identifier to a value,<br>the only difference is it binds it to an optional value. And it&#39;s<br>really just a specialization of `if case let foo? = bar { ... }`. I&#39;ve<br>asked in the past about whether it&#39;s worth keeping the special case<br>around now that we have `if case let` (or more specifically, if we<br>should just turn `if let` into the generalized version, so you&#39;d say<br>`if let foo? = bar {... }`) and the answer from the core team was that<br>they already tried it internally and found that the usage of optionals<br>was so prevalent that the special-case optional-specific form of `if<br>let` was worth keeping.<br></p><p>-Kevin Ballard<br></p><p>On Mon, Feb 1, 2016, at 11:18 AM, Erica Sadun via swift-evolution wrote:<br>&gt; Joe says &quot;If you all are serious about this, I think you should start<br>&gt; a new thread about it.&quot; I think it&#39;s worth a serious discussion just<br>&gt; so it can be evaluated and either adopted or discarded and dropped<br>&gt; forever. Here goes.<br>&gt;<br>&gt; INTRO<br>&gt;<br>&gt; The if let x = x {...} and guard let x = x else {...} constructs do<br>&gt; something with let (and var) that&#39;s fundamentally different from let<br>&gt; (and var) elsewhere in the language.  The same keywords are used to<br>&gt; conditionally unwrap and bind an item, not just shadow that item&#39;s<br>&gt; current value.<br>&gt;<br>&gt; Introducing a new bind keyword to indicate unwrapping and binding<br>&gt; would disambiguate these uses.<br>&gt;<br>&gt; DETAIL DESIGN:<br>&gt;<br>&gt; Jacob Bandes-Storch offers two common use-cases. I prefer his &quot;if bind<br>&gt; foo&quot; to my original &quot;if bind foo = foo&quot;:<br>&gt;<br>&gt; if bind foo {      // foo is non-optional in here  }<br>&gt;<br>&gt; somethingAsync { [weak self] in      guard bind self else { return }<br>&gt; // ...  }<br>&gt;<br>&gt; JBS&#39;s approach offers my original &quot;bind&quot; keyword to unwrap and shadow<br>&gt; bind, but also provides a way to strongly bind a weak reference to<br>&gt; self, which (presumably) would allow self semantics in the remaining<br>&gt; lifetime of that scope.<br>&gt;<br>&gt; ALTERNATIVE PROPOSALS:<br>&gt;<br>&gt; Tino Heth proposes a second use-case one with different semantics.<br>&gt; This case, it seems to make an alias rather than using binding for<br>&gt; shadowing:<br>&gt;<br>&gt; bind x = a.property.with.a.long.path print x  // 42<br>&gt; print(a.property.with.a.long.path == 42) =&gt; true<br>&gt;<br>&gt; presumably this means:<br>&gt;<br>&gt; x += 1 print(a.property.with.a.long.path)  // 43<br>&gt;<br>&gt; DISCUSSION<br>&gt;<br>&gt; I&#39;m throwing these both out there. I have nothing to really say about<br>&gt; Tino&#39;s but I do think my and Jacob&#39;s proposal has the advantages of:<br>&gt;<br>&gt; * Simplifying an mildly complex and potentially misleading statement<br>&gt; * Creating a deliberate and controlled rather than accidental<br>&gt;   shadowing style<br>&gt;<br>&gt; Have at it.<br>&gt;<br>&gt; -- Erica<br>&gt;<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/0643430e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>The bind thread</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>February  1, 2016 at 03:00:00pm</p></header><div class="content"><p>Pulling &amp; updating my comments from the old thread:<br></p><p>&gt; On Feb 1, 2016, at 1:18 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The if let x = x {...} and guard let x = x else {...} constructs do something with let (and var) that&#39;s fundamentally different from let (and var) elsewhere in the language.<br></p><p>I don’t agree. Wherever they appear, let and var declare a new variable. And they always shadow variables from an outer scope in exactly the same way:<br></p><p>    let x = &quot;hi&quot;<br>    if 3 &lt; 7 {<br>        let x = [&quot;different&quot;, &quot;scope&quot;, &quot;different&quot;, &quot;x&quot;]<br>        print(x)<br>    }<br></p><p>This consistency of meaning for let/var gives the correct implication: “if let” is just a normal variable declaration, even though it appears in the middle of an if condition.<br></p><p>&gt; The same keywords are used to conditionally unwrap<br>&gt; and bind an item, not just shadow that item&#39;s current value.<br></p><p>In my head, it’s “if”, not “let”, that conveys the conditionality. Really, “if” + “let” is exactly the right combination of concepts; the words just come in a grammatically confusing order.<br></p><p>To me, “bind” misleadingly implies that this is something other than a normal variable declaration: maybe an alias, or a reactive binding, or something like that.<br></p><p>Cheers,<br></p><p>Paul<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/0987fa12/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>The bind thread</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February  1, 2016 at 03:00:00pm</p></header><div class="content"><p>Yes, but they don&#39;t unwrap. Which is the extra something special.<br></p><p>if let x = x {...} <br></p><p>is kind of really <br></p><p>x.map({f(x)}) // Bless you Kevin!<br></p><p>if you follow what I&#39;m saying. It&#39;s not just binding.<br></p><p>-- E<br></p><p>&gt; On Feb 1, 2016, at 2:52 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt; <br>&gt; Pulling &amp; updating my comments from the old thread:<br>&gt; <br>&gt;&gt; On Feb 1, 2016, at 1:18 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The if let x = x {...} and guard let x = x else {...} constructs do something with let (and var) that&#39;s fundamentally different from let (and var) elsewhere in the language.<br>&gt; <br>&gt; I don’t agree. Wherever they appear, let and var declare a new variable. And they always shadow variables from an outer scope in exactly the same way:<br>&gt; <br>&gt;     let x = &quot;hi&quot;<br>&gt;     if 3 &lt; 7 {<br>&gt;         let x = [&quot;different&quot;, &quot;scope&quot;, &quot;different&quot;, &quot;x&quot;]<br>&gt;         print(x)<br>&gt;     }<br>&gt; <br>&gt; This consistency of meaning for let/var gives the correct implication: “if let” is just a normal variable declaration, even though it appears in the middle of an if condition.<br>&gt; <br>&gt;&gt; The same keywords are used to conditionally unwrap<br>&gt;&gt; and bind an item, not just shadow that item&#39;s current value.<br>&gt; <br>&gt; In my head, it’s “if”, not “let”, that conveys the conditionality. Really, “if” + “let” is exactly the right combination of concepts; the words just come in a grammatically confusing order.<br>&gt; <br>&gt; To me, “bind” misleadingly implies that this is something other than a normal variable declaration: maybe an alias, or a reactive binding, or something like that.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/7537750f/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>The bind thread</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February  1, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt;   if bind foo {<br>&gt;       // foo is non-optional in here<br>&gt;   }<br></p><p>If something in a flow control statement should read like an assertion, we don&#39;t want &quot;bind&quot; here.<br></p><p>	if has foo {<br>		// foo is non-optional<br>	}<br></p><p>However, I do note that pattern matching in an if statement already lets you do the same thing as `if let` more explicitly:<br></p><p>	if case let foo? = bar {<br>		<br>	}<br></p><p>I wonder if we should instead enhance this feature&#39;s usability. For instance, as a surgical change, we could drop the `case` keyword when `let` is present in the condition (since `let` isn&#39;t allowed in a boolean expression anyway):<br></p><p>	if let foo? = bar {<br>		<br>	}<br></p><p>This is one character longer than the current `if let`, but it falls naturally out of other language features and allows for other similar constructs, like `if let .Success(value) = bar`.<br></p><p>However, the `if case` syntax kind of sucks in other ways, too, and I think it deserves another look. In particular, the `=` isn&#39;t great for pattern matching that doesn&#39;t bind variables; people have complained about that part of `if case` before. Maybe we can improve that while still making the unwrapping good by introducing a keyword or operator that replaces the `=` while implying the `case` so it doesn&#39;t have to be stated explicitly. Here&#39;s a strawman of what this would look like, using `matches`:<br></p><p>	if let foo? matches bar<br>	if let .Success(value) matches bar<br>	if .Card(let rank, .Heart) matches bar<br>	if .OK matches bar<br></p><p>Can we do this with `for case` too? Maybe...<br></p><p>	for let foo? matches in bars<br>	for let .Success(value) matches in bars<br>	for .Card(let rank, .Heart) matches in bars<br>	for .OK matches in bars<br></p><p>I think this approach might work; the only question is what `matches` should be. I don&#39;t like using a keyword for it; I think it disappears too easily, particularly in the optional case. We do sort of have a pattern matching operator, `~=`, but it&#39;s very obscure, the overloading is not really right, and I can never remember which order the characters go in (possibly because Perl uses `=~` as its matching operator). Colon kind of reads well, but it disappears too easily, and it&#39;s already associated with typing:<br></p><p>	if let foo?: bar<br>	if let .Success(value): bar<br>	if .Card(let rank, .Heart): bar<br>	if .OK: bar<br></p><p>I don&#39;t know what the answer is here, but I think this might be a good line to pursue.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>The bind thread</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>February  2, 2016 at 11:00:00am</p></header><div class="content"><p>I mostly agree with everything you said. I also think &quot;if case&quot; syntax is<br>bad at the moment.<br></p><p>However I think any changes probably have to be an addition rather than a<br>replacement.<br></p><p>I&#39;ve tried to reconcile these changes with pattern matching and cannot work<br>out how it fits. There&#39;s too many inconsistencies and incompatibilities. At<br>best you can make a new pattern matching syntax that&#39;s incompatible with<br>switch statements.<br></p><p>On Tuesday, 2 February 2016, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt;   if bind foo {<br>&gt; &gt;       // foo is non-optional in here<br>&gt; &gt;   }<br>&gt;<br>&gt; If something in a flow control statement should read like an assertion, we<br>&gt; don&#39;t want &quot;bind&quot; here.<br>&gt;<br>&gt;         if has foo {<br>&gt;                 // foo is non-optional<br>&gt;         }<br>&gt;<br>&gt; However, I do note that pattern matching in an if statement already lets<br>&gt; you do the same thing as `if let` more explicitly:<br>&gt;<br>&gt;         if case let foo? = bar {<br>&gt;<br>&gt;         }<br>&gt;<br>&gt; I wonder if we should instead enhance this feature&#39;s usability. For<br>&gt; instance, as a surgical change, we could drop the `case` keyword when `let`<br>&gt; is present in the condition (since `let` isn&#39;t allowed in a boolean<br>&gt; expression anyway):<br>&gt;<br>&gt;         if let foo? = bar {<br>&gt;<br>&gt;         }<br>&gt;<br>&gt; This is one character longer than the current `if let`, but it falls<br>&gt; naturally out of other language features and allows for other similar<br>&gt; constructs, like `if let .Success(value) = bar`.<br>&gt;<br>&gt; However, the `if case` syntax kind of sucks in other ways, too, and I<br>&gt; think it deserves another look. In particular, the `=` isn&#39;t great for<br>&gt; pattern matching that doesn&#39;t bind variables; people have complained about<br>&gt; that part of `if case` before. Maybe we can improve that while still making<br>&gt; the unwrapping good by introducing a keyword or operator that replaces the<br>&gt; `=` while implying the `case` so it doesn&#39;t have to be stated explicitly.<br>&gt; Here&#39;s a strawman of what this would look like, using `matches`:<br>&gt;<br>&gt;         if let foo? matches bar<br>&gt;         if let .Success(value) matches bar<br>&gt;         if .Card(let rank, .Heart) matches bar<br>&gt;         if .OK matches bar<br>&gt;<br>&gt; Can we do this with `for case` too? Maybe...<br>&gt;<br>&gt;         for let foo? matches in bars<br>&gt;         for let .Success(value) matches in bars<br>&gt;         for .Card(let rank, .Heart) matches in bars<br>&gt;         for .OK matches in bars<br>&gt;<br>&gt; I think this approach might work; the only question is what `matches`<br>&gt; should be. I don&#39;t like using a keyword for it; I think it disappears too<br>&gt; easily, particularly in the optional case. We do sort of have a pattern<br>&gt; matching operator, `~=`, but it&#39;s very obscure, the overloading is not<br>&gt; really right, and I can never remember which order the characters go in<br>&gt; (possibly because Perl uses `=~` as its matching operator). Colon kind of<br>&gt; reads well, but it disappears too easily, and it&#39;s already associated with<br>&gt; typing:<br>&gt;<br>&gt;         if let foo?: bar<br>&gt;         if let .Success(value): bar<br>&gt;         if .Card(let rank, .Heart): bar<br>&gt;         if .OK: bar<br>&gt;<br>&gt; I don&#39;t know what the answer is here, but I think this might be a good<br>&gt; line to pursue.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/e5c7c1cc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>The bind thread</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>February  2, 2016 at 02:00:00am</p></header><div class="content"><p>I do not see any necessity in a bind keyword and I don’t believe that it adds any clarity to the language. Furthermore, the current syntax allows one to change the variable name or add additional conditions in  transparent manner. I also like that the current syntax make it very obvious that a variable is declared within a local scope. Flow-typing already exists in Swift (via as?) and while it might be a bit more verbose, its also more flexible. <br></p><p>However, I do agree that the specific semantic of let and var in the if context is a bit unexpected. So maybe one should look into making the optional unwrapping semantics more explicit. E.g. what about changing the semantics of ! so that it can be safely used in a conditional context? E.g.<br></p><p>if let x = x! {<br></p><p>}<br></p><p>if let x = x as! SomeType {<br></p><p>}<br></p><p>This would make it very clear that the value is being unwrapped without adding a lot of clutter or additional effort. <br></p><p>Alternative options for making binding more explicit<br></p><p>if let x ?= x <br>if let x ? x<br>if let? x = x<br></p><p>etc. But I do like the ! refinement above. <br></p><p>— Taras<br></p><p>&gt; On 02 Feb 2016, at 01:49, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I mostly agree with everything you said. I also think &quot;if case&quot; syntax is bad at the moment.<br>&gt; <br>&gt; However I think any changes probably have to be an addition rather than a replacement.<br>&gt; <br>&gt; I&#39;ve tried to reconcile these changes with pattern matching and cannot work out how it fits. There&#39;s too many inconsistencies and incompatibilities. At best you can make a new pattern matching syntax that&#39;s incompatible with switch statements.<br>&gt; <br>&gt; On Tuesday, 2 February 2016, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;   if bind foo {<br>&gt; &gt;       // foo is non-optional in here<br>&gt; &gt;   }<br>&gt; <br>&gt; If something in a flow control statement should read like an assertion, we don&#39;t want &quot;bind&quot; here.<br>&gt; <br>&gt;         if has foo {<br>&gt;                 // foo is non-optional<br>&gt;         }<br>&gt; <br>&gt; However, I do note that pattern matching in an if statement already lets you do the same thing as `if let` more explicitly:<br>&gt; <br>&gt;         if case let foo? = bar {<br>&gt; <br>&gt;         }<br>&gt; <br>&gt; I wonder if we should instead enhance this feature&#39;s usability. For instance, as a surgical change, we could drop the `case` keyword when `let` is present in the condition (since `let` isn&#39;t allowed in a boolean expression anyway):<br>&gt; <br>&gt;         if let foo? = bar {<br>&gt; <br>&gt;         }<br>&gt; <br>&gt; This is one character longer than the current `if let`, but it falls naturally out of other language features and allows for other similar constructs, like `if let .Success(value) = bar`.<br>&gt; <br>&gt; However, the `if case` syntax kind of sucks in other ways, too, and I think it deserves another look. In particular, the `=` isn&#39;t great for pattern matching that doesn&#39;t bind variables; people have complained about that part of `if case` before. Maybe we can improve that while still making the unwrapping good by introducing a keyword or operator that replaces the `=` while implying the `case` so it doesn&#39;t have to be stated explicitly. Here&#39;s a strawman of what this would look like, using `matches`:<br>&gt; <br>&gt;         if let foo? matches bar<br>&gt;         if let .Success(value) matches bar<br>&gt;         if .Card(let rank, .Heart) matches bar<br>&gt;         if .OK matches bar<br>&gt; <br>&gt; Can we do this with `for case` too? Maybe...<br>&gt; <br>&gt;         for let foo? matches in bars<br>&gt;         for let .Success(value) matches in bars<br>&gt;         for .Card(let rank, .Heart) matches in bars<br>&gt;         for .OK matches in bars<br>&gt; <br>&gt; I think this approach might work; the only question is what `matches` should be. I don&#39;t like using a keyword for it; I think it disappears too easily, particularly in the optional case. We do sort of have a pattern matching operator, `~=`, but it&#39;s very obscure, the overloading is not really right, and I can never remember which order the characters go in (possibly because Perl uses `=~` as its matching operator). Colon kind of reads well, but it disappears too easily, and it&#39;s already associated with typing:<br>&gt; <br>&gt;         if let foo?: bar<br>&gt;         if let .Success(value): bar<br>&gt;         if .Card(let rank, .Heart): bar<br>&gt;         if .OK: bar<br>&gt; <br>&gt; I don&#39;t know what the answer is here, but I think this might be a good line to pursue.<br>&gt; <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/fd181aa3/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>The bind thread</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>February  1, 2016 at 07:00:00pm</p></header><div class="content"><p>Meta-comments:<br></p><p>&quot;if let y = x { … } “ actually corresponds closest to<br></p><p>if x != nil {<br>   let y = x!<br>   …<br>}<br></p><p>e.g. has the following behaviors:<br>1. a comparison to nil<br>2. a copy of the reference or value w/o optionality<br>3. execution of a block<br></p><p>but also:<br>4. implication that this is safe within the block (my eyes would be drawn to that &quot;let y = x!” every time)<br>5. ability to shadow outer optional variable with non-optional inner variable (e.g. if let x = x { … } )<br></p><p>You could do all of this of course via .flatMap, but there is an obvious desire for something closer to the traditional/familiar syntax of a conditional. <br></p><p>Having a special case of variable assignment within a conditional that casts off optionality feels odd, and I can understand why people have proposed changes. However, the proposals so far seem to have gotten hung up around point #2, having issues with either:<br></p><p>a) making it less clear that a copy is being made,<br>b) making it less clear that a copy is shadowing the original value, and/or<br>c) changing the capabilities of the actual statement, such that a copy is *not* being made, and the original value is effectively inout. This means that you are not actually replacing all uses of the syntax at all, but instead defining a new kind of operation.<br></p><p>Issues with a) and b) are syntactic. We can possibly come up with a more clear way to explain the current behavior, although its very hard to make it more clear that a copy is being made than a ‘let’ declaration and assignment. <br></p><p>Issues with c) are mostly just around clarity of purpose - you are defining something new, and &quot;if let x = x” will likely still exist because uses for that operation are still likely valid.<br></p><p>-DW<br></p><p>&gt; On Feb 1, 2016, at 12:18 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Joe says &quot;If you all are serious about this, I think you should start a new thread about it.&quot; <br>&gt; I think it&#39;s worth a serious discussion just so it can be evaluated and either adopted or discarded<br>&gt; and dropped forever. Here goes.<br>&gt; <br>&gt; INTRO<br>&gt; <br>&gt; The if let x = x {...} and guard let x = x else {...} constructs do something with let (and var) that&#39;s <br>&gt; fundamentally different from let (and var) elsewhere in the language.  The same keywords are used to conditionally unwrap<br>&gt; and bind an item, not just shadow that item&#39;s current value.<br>&gt; <br>&gt; Introducing a new bind keyword to indicate unwrapping and binding would disambiguate these uses.<br>&gt; <br>&gt; DETAIL DESIGN:<br>&gt; <br>&gt; Jacob Bandes-Storch offers two common use-cases. I prefer his &quot;if bind foo&quot; to my original &quot;if bind foo = foo&quot;:<br>&gt; <br>&gt;   if bind foo {<br>&gt;       // foo is non-optional in here<br>&gt;   }<br>&gt; <br>&gt;   somethingAsync { [weak self] in<br>&gt;       guard bind self else { return }<br>&gt;       // ...<br>&gt;   }<br>&gt; <br>&gt; JBS&#39;s approach offers my original &quot;bind&quot; keyword to unwrap and shadow bind, but also provides a way to <br>&gt; strongly bind a weak reference to self, which (presumably) would allow self semantics in the remaining<br>&gt; lifetime of that scope.<br>&gt; <br>&gt; ALTERNATIVE PROPOSALS:<br>&gt; <br>&gt; Tino Heth proposes a second use-case one with different semantics. This case, it seems to make an<br>&gt; alias rather than using binding for shadowing:<br>&gt; <br>&gt; bind x = a.property.with.a.long.path<br>&gt; print x  // 42<br>&gt; print(a.property.with.a.long.path == 42) =&gt; true<br>&gt; <br>&gt; presumably this means:<br>&gt; <br>&gt; x += 1<br>&gt; print(a.property.with.a.long.path)  // 43<br>&gt; <br>&gt; DISCUSSION<br>&gt; <br>&gt; I&#39;m throwing these both out there. I have nothing to really say about Tino&#39;s but I do think my and Jacob&#39;s <br>&gt; proposal has the advantages of:<br>&gt; <br>&gt; * Simplifying an mildly complex and potentially misleading statement <br>&gt; * Creating a deliberate and controlled rather than accidental shadowing style<br>&gt; <br>&gt; Have at it.<br>&gt; <br>&gt; -- Erica<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/81fcca60/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>The bind thread</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>February  2, 2016 at 07:00:00am</p></header><div class="content"><p>I respectfully disagree with the need for bind operator, see below:<br></p><p>On Mon, Feb 1, 2016 at 8:18 PM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Joe says &quot;If you all are serious about this, I think you should start a<br>&gt; new thread about it.&quot;<br>&gt; I think it&#39;s worth a serious discussion just so it can be evaluated and<br>&gt; either adopted or discarded<br>&gt; and dropped forever. Here goes.<br>&gt;<br>&gt; INTRO<br>&gt;<br>&gt; The if let x = x {...} and guard let x = x else {...} constructs do<br>&gt; something with let (and var) that&#39;s<br>&gt; fundamentally different from let (and var) elsewhere in the language.<br>&gt; The same keywords are used to conditionally unwrap<br>&gt; and bind an item, not just shadow that item&#39;s current value.<br>&gt;<br></p><p>let A = B does exactly the same in all instances: evaluate the expression B<br>in current scope and bind the result to a local name A, and if let x =<br>x meaning<br>is no different. If a person doesn&#39;t know the precise meaning of if let,<br>with the similarity to normal let one is likely to guess at least the &quot;name<br>binding&quot; part. This is a big advantage of if let syntax.<br></p><p><br>&gt; Introducing a new bind keyword to indicate unwrapping and binding would<br>&gt; disambiguate these uses.<br>&gt;<br>&gt; DETAIL DESIGN:<br>&gt;<br>&gt; Jacob Bandes-Storch offers two common use-cases. I prefer his &quot;if bind<br>&gt; foo&quot; to my original &quot;if bind foo = foo&quot;:<br>&gt;<br>&gt;   if bind foo {<br>&gt;       // foo is non-optional in here<br>&gt;   }<br>&gt;<br>&gt;<br>Let&#39;s consider the case where foo was originally a property. Unfortunately,<br>the syntax above is then very likely to confuse people into thinking that<br>self.foo is non-optional inside the inner scope, which is far from<br>guaranteed:<br></p><p>if bind foo {<br>    // we have created a local variable foo here<br>    // foo is non-optional<br>    // no guarantees about self.foo can be made, however<br>    // as it&#39;s value may have changed<br>}<br></p><p>The same applies if foo is a local variable captured by an escaped closure<br>which may be executing concurrently with the inner block.<br></p><p>So it seems like the bind statement is most helpful only when foo is a<br>local name and either declared with let or not captured by any escaped<br>closure. In that case the original foo can be used directly without<br>shadowing.<br></p><p>One sees how such a statement can be useful, but I&#39;m not sure if the word<br>bind is the best one for it. After all, both let and var perform name<br>binding. Also, there were suggestions to make<br></p><p>// foo is local and not escaping<br>if foo != nil {<br>    // foo is non-optional<br>}<br></p><p>simply work without any additional syntax. Perhaps one can look into that.<br></p><p>  somethingAsync { [weak self] in<br>&gt;       guard bind self else { return }<br>&gt;       // ...<br>&gt;   }<br>&gt;<br>&gt; JBS&#39;s approach offers my original &quot;bind&quot; keyword to unwrap and shadow<br>&gt; bind, but also provides a way to<br>&gt; strongly bind a weak reference to self, which (presumably) would allow<br>&gt; self semantics in the remaining<br>&gt; lifetime of that scope.<br>&gt;<br>&gt; ALTERNATIVE PROPOSALS:<br>&gt;<br>&gt; Tino Heth proposes a second use-case one with different semantics. This<br>&gt; case, it seems to make an<br>&gt; alias rather than using binding for shadowing:<br>&gt;<br>&gt; bind x = a.property.with.a.long.path<br>&gt; print x  // 42<br>&gt; print(a.property.with.a.long.path == 42) =&gt; true<br>&gt;<br>&gt; presumably this means:<br>&gt;<br>&gt; x += 1<br>&gt; print(a.property.with.a.long.path)  // 43<br>&gt;<br>&gt; DISCUSSION<br>&gt;<br>&gt; I&#39;m throwing these both out there. I have nothing to really say about<br>&gt; Tino&#39;s but I do think my and Jacob&#39;s<br>&gt; proposal has the advantages of:<br>&gt;<br>&gt; * Simplifying an mildly complex and potentially misleading statement<br>&gt; * Creating a deliberate and controlled rather than accidental shadowing<br>&gt; style<br>&gt;<br>&gt; Have at it.<br>&gt;<br>&gt;<br>The &#39;big picture argument&#39;  is that shadowing is likely to introduce more<br>errors, so we should be discouraging it, not encouraging. In real life I<br>find creating a local variable with a different name more natural anyway,<br>e.g:<br></p><p>// issuesViewController is a property<br>// we want to present it, if it can be constructed<br></p><p>if let to_present = issuesViewController {<br>    presentViewController(to_present, animated: true)<br>}<br></p><p>Ilya.<br></p><p>-- Erica<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/c2a0e38d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>The bind thread</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February  2, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 02.02.2016 um 07:44 schrieb ilya via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I respectfully disagree with the need for bind operator, see below:<br>&gt; <br>&gt; On Mon, Feb 1, 2016 at 8:18 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Joe says &quot;If you all are serious about this, I think you should start a new thread about it.&quot; <br>&gt; I think it&#39;s worth a serious discussion just so it can be evaluated and either adopted or discarded<br>&gt; and dropped forever. Here goes.<br>&gt; <br>&gt; INTRO<br>&gt; <br>&gt; The if let x = x {...} and guard let x = x else {...} constructs do something with let (and var) that&#39;s <br>&gt; fundamentally different from let (and var) elsewhere in the language.  The same keywords are used to conditionally unwrap<br>&gt; and bind an item, not just shadow that item&#39;s current value.<br>&gt; <br>&gt; let A = B does exactly the same in all instances: evaluate the expression B in current scope and bind the result to a local name A, and if let x = x meaning is no different. If a person doesn&#39;t know the precise meaning of if let, with the similarity to normal let one is likely to guess at least the &quot;name binding&quot; part. This is a big advantage of if let syntax.<br></p><p>The meaning of `if let x = y` differs from `let x = y` in the type inferred for x (non-optional vs. optional). <br></p><p><br>&gt; <br>&gt; Introducing a new bind keyword to indicate unwrapping and binding would disambiguate these uses.<br>&gt; <br>&gt; DETAIL DESIGN:<br>&gt; <br>&gt; Jacob Bandes-Storch offers two common use-cases. I prefer his &quot;if bind foo&quot; to my original &quot;if bind foo = foo&quot;:<br>&gt; <br>&gt;   if bind foo {<br>&gt;       // foo is non-optional in here<br>&gt;   }<br>&gt; <br>&gt; <br>&gt; Let&#39;s consider the case where foo was originally a property. Unfortunately, the syntax above is then very likely to confuse people into thinking that self.foo is non-optional inside the inner scope, which is far from guaranteed:<br></p><p>Actually that semantics (I would prefer `exists` to `bind` to make this more explicit in the syntax) is the whole point of flow typing.<br></p><p><br>&gt; if bind foo {<br>&gt;     // we have created a local variable foo here<br>&gt;     // foo is non-optional<br>&gt;     // no guarantees about self.foo can be made, however<br>&gt;     // as it&#39;s value may have changed<br>&gt; }<br>&gt; <br>&gt; The same applies if foo is a local variable captured by an escaped closure which may be executing concurrently with the inner block.<br></p><p>In Ceylon flow typing is only allowed for constants (i.e. let bindings), probably for that reason, so foo would have to be constant and the problem you mention would not exist.<br></p><p>In Ceylon if `foo` is a variable you have to rebind to a constant which looks like follows (Swiftified, and I’m using `exists` rather than `bind` because I don’t like the latter for the aforementioned reason):<br></p><p>// foo is a var<br>if exists x = foo {<br>    // x is a let binding to foo<br>}<br></p><p>So this is exactly the same as Swift’s current `if let x = foo` except that it makes the unwrapping (or mapping as Erica pointed out) clear and can be used without a (possibly shadowing) assignment for constant values (`if exists x { … }` vs. `if let x = x { … }`).<br></p><p>As I already posted in the original thread `if var` would have to be expressed more clumsily as `if exists x { var copy = x … }` like originally proposed in SE-0003 (that part was recently thankfully revoked). With `exists` there would be no additional shadowing (`if let x = x { let copy = x … } `) so it might be not so bad.<br></p><p><br>There is a potential advantage of the current `if let` syntax, though: it would allow to be generalized to work for monadic types, i.e. it might just be desugared into `map`. <br>This could be extended to `for` loops where `for x in foo, y in bar { … }` would be desugared into `flatMap` for all `in` expressions but the last which would be desugared into `map`. In both cases a `where` clause would be desugared into `filter`. For a type to be applicable in `if let` statements it would have to conform to a protocol providing `map`, for support of `where` clauses it would have to conform to another protocol providing `filter` and for being used in `for` statements with nesting it would have to conform to yet another protocol providing `flatMap`. <br></p><p>In that case I’d definitely prefer to stay with the current syntax, because `let` makes more sense in a generalization than `exists` which only applies to optionals.<br></p><p>I think that’s the direction I’d prefer most.<br></p><p>-Thorsten<br></p><p><br></p><p>&gt; <br>&gt; So it seems like the bind statement is most helpful only when foo is a local name and either declared with let or not captured by any escaped closure. In that case the original foo can be used directly without shadowing. <br>&gt; <br>&gt; One sees how such a statement can be useful, but I&#39;m not sure if the word bind is the best one for it. After all, both let and var perform name binding. Also, there were suggestions to make <br>&gt; <br>&gt; // foo is local and not escaping<br>&gt; if foo != nil {<br>&gt;     // foo is non-optional<br>&gt; }<br>&gt; <br>&gt; simply work without any additional syntax. Perhaps one can look into that.<br>&gt; <br>&gt;   somethingAsync { [weak self] in<br>&gt;       guard bind self else { return }<br>&gt;       // ...<br>&gt;   }<br>&gt; <br>&gt; JBS&#39;s approach offers my original &quot;bind&quot; keyword to unwrap and shadow bind, but also provides a way to <br>&gt; strongly bind a weak reference to self, which (presumably) would allow self semantics in the remaining<br>&gt; lifetime of that scope.<br>&gt; <br>&gt; ALTERNATIVE PROPOSALS:<br>&gt; <br>&gt; Tino Heth proposes a second use-case one with different semantics. This case, it seems to make an<br>&gt; alias rather than using binding for shadowing:<br>&gt; <br>&gt; bind x = a.property.with.a.long.path<br>&gt; print x  // 42<br>&gt; print(a.property.with.a.long.path == 42) =&gt; true<br>&gt; <br>&gt; presumably this means:<br>&gt; <br>&gt; x += 1<br>&gt; print(a.property.with.a.long.path)  // 43<br>&gt; <br>&gt; DISCUSSION<br>&gt; <br>&gt; I&#39;m throwing these both out there. I have nothing to really say about Tino&#39;s but I do think my and Jacob&#39;s <br>&gt; proposal has the advantages of:<br>&gt; <br>&gt; * Simplifying an mildly complex and potentially misleading statement <br>&gt; * Creating a deliberate and controlled rather than accidental shadowing style<br>&gt; <br>&gt; Have at it.<br>&gt; <br>&gt; <br>&gt; The &#39;big picture argument&#39;  is that shadowing is likely to introduce more errors, so we should be discouraging it, not encouraging. In real life I find creating a local variable with a different name more natural anyway, e.g:<br>&gt; <br>&gt; // issuesViewController is a property<br>&gt; // we want to present it, if it can be constructed<br>&gt; <br>&gt; if let to_present = issuesViewController {<br>&gt;     presentViewController(to_present, animated: true)<br>&gt; }<br>&gt; <br>&gt; Ilya.<br>&gt; <br>&gt; -- Erica<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/1087a8dd/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
