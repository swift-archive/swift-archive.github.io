<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Implement == and &lt; for tuples where possible, up to some high arity</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  7, 2015 at 11:00:00am</p></header><div class="content"><p>I&#39;d really like to see tuples support comparison operators when<br>possible. Eventually they should even conform to the<br>Equatable/Comparable protocols, but that requires tuples being able to<br>conform to protocols at all to begin with.<br></p><p>In the absence of some sort of variadic type parameters, we&#39;d only be<br>able to support the comparison operators on tuples up to some predefined<br>arity. There&#39;s precedent in Rust and Haskell for this. Rust defines<br>these operations up to arity 12, Haskell defines them up to arity 15.<br></p><p>Behavior of == should be obvious. Behavior of the ordered comparison<br>operators would work like comparison of strings, where the first element<br>is compared, and if equal, the second element is compared, etc.<br></p><p>This would be implemented using some .gyb code that generates<br>declarations that look something like<br></p><p>func == &lt;A: Equatable, B: Equatable, C: Equatable&gt;(lhs: (A, B, C), rhs:<br>(A, B, C)) -&gt; Bool {    return lhs.0 == rhs.0 &amp;&amp; lhs.1 == rhs.1 &amp;&amp; lhs.2<br>== rhs.2 }<br></p><p>func &lt; &lt;A: Comparable, B: Comparable, C: Comparable&gt;(lhs: (A, B, C),<br>rhs: (A, B, C)) -&gt; Bool {    if lhs.0 != rhs.0 { return lhs.0 &lt; rhs.0 }<br>if lhs.1 != rhs.1 { return lhs.1 &lt; rhs.1 }    return lhs.2 &lt; rhs.2 }<br></p><p>func &gt; &lt;A: Comparable, B: Comparable, C: Comparable&gt;(lhs: (A, B, C),<br>rhs: (A, B, C)) -&gt; Bool {    if lhs.0 != rhs.0 { return lhs.0 &gt; rhs.0 }<br>if lhs.1 != rhs.1 { return lhs.1 &gt; rhs.1 }    return lhs.2 &gt; rhs.2 }<br></p><p>If tuples ever gain the ability to conform to protocols (which I think<br>they should), and when types gain the ability to conditionally conform<br>to protocols, these declarations would be adjusted to declare the tuples<br>as conforming to Equatable and Comparable. This would be a backwards-<br>compatible change.<br></p><p>Similarly if Swift ever gains some form of variadic type parameters,<br>thus allowing for declaring behavior of arbitrary-sized tuples, then<br>this can be adjusted to use that feature and it should still be backwards-<br>compatible.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/caceb457/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Proposal: Implement == and &lt; for tuples where possible, up to some high arity</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  7, 2015 at 12:00:00pm</p></header><div class="content"><p>On Mon, Dec 7, 2015 at 11:48 AM, Kevin Ballard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;d really like to see tuples support comparison operators when possible.<br>&gt; Eventually they should even conform to the Equatable/Comparable protocols,<br>&gt; but that requires tuples being able to conform to protocols at all to begin<br>&gt; with.<br>&gt;<br>&gt; In the absence of some sort of variadic type parameters, we&#39;d only be able<br>&gt; to support the comparison operators on tuples up to some predefined arity.<br>&gt; There&#39;s precedent in Rust and Haskell for this. Rust defines these<br>&gt; operations up to arity 12, Haskell defines them up to arity 15.<br>&gt;<br>&gt; Behavior of == should be obvious. Behavior of the ordered comparison<br>&gt; operators would work like comparison of strings, where the first element is<br>&gt; compared, and if equal, the second element is compared, etc.<br>&gt;<br>&gt; This would be implemented using some .gyb code that generates declarations<br>&gt; that look something like<br>&gt;<br>&gt; func == &lt;A: Equatable, B: Equatable, C: Equatable&gt;(lhs: (A, B, C), rhs:<br>&gt; (A, B, C)) -&gt; Bool {<br>&gt;     return lhs.0 == rhs.0 &amp;&amp; lhs.1 == rhs.1 &amp;&amp; lhs.2 == rhs.2<br>&gt; }<br>&gt;<br>&gt; func &lt; &lt;A: Comparable, B: Comparable, C: Comparable&gt;(lhs: (A, B, C), rhs:<br>&gt; (A, B, C)) -&gt; Bool {<br>&gt;     if lhs.0 != rhs.0 { return lhs.0 &lt; rhs.0 }<br>&gt;     if lhs.1 != rhs.1 { return lhs.1 &lt; rhs.1 }<br>&gt;     return lhs.2 &lt; rhs.2<br>&gt; }<br>&gt;<br>&gt; func &gt; &lt;A: Comparable, B: Comparable, C: Comparable&gt;(lhs: (A, B, C), rhs:<br>&gt; (A, B, C)) -&gt; Bool {<br>&gt;     if lhs.0 != rhs.0 { return lhs.0 &gt; rhs.0 }<br>&gt;     if lhs.1 != rhs.1 { return lhs.1 &gt; rhs.1 }<br>&gt;     return lhs.2 &gt; rhs.2<br>&gt; }<br>&gt;<br></p><p>Looks like a good idea to me!  Also the &lt;= and &gt;= operators, right?<br></p><p>What concerns we with massive code generation is the code size of the core<br>swift library.  It would be definitely important to see how much code this<br>adds, depending on the number of tuple elements.<br></p><p>I personally don&#39;t see a point in going as high as 12 tuple elements.<br>About 4 or 5 makes sense to me.  Given that Swift does not have variadic<br>generics right now, these long tuples have to be defined by someone<br>manually.  If one is defining a tuple that is that long, I&#39;d argue that<br>they should be using a custom struct instead.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/21c92d7f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Implement == and &lt; for tuples where possible, up to some high arity</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  7, 2015 at 12:00:00pm</p></header><div class="content"><p>On Mon, Dec 7, 2015, at 12:01 PM, Dmitri Gribenko wrote:<br>&gt; On Mon, Dec 7, 2015 at 11:48 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; __<br>&gt;&gt; I&#39;d really like to see tuples support comparison operators when<br>&gt;&gt; possible. Eventually they should even conform to the<br>&gt;&gt; Equatable/Comparable protocols, but that requires tuples being able<br>&gt;&gt; to conform to protocols at all to begin with.<br>&gt;&gt;<br>&gt;&gt; In the absence of some sort of variadic type parameters, we&#39;d only be<br>&gt;&gt; able to support the comparison operators on tuples up to some<br>&gt;&gt; predefined arity. There&#39;s precedent in Rust and Haskell for this.<br>&gt;&gt; Rust defines these operations up to arity 12, Haskell defines them up<br>&gt;&gt; to arity 15.<br>&gt;&gt;<br>&gt;&gt; Behavior of == should be obvious. Behavior of the ordered<br>&gt;&gt; comparison operators would work like comparison of strings, where<br>&gt;&gt; the first element is compared, and if equal, the second element is<br>&gt;&gt; compared, etc.<br>&gt;&gt;<br>&gt;&gt; This would be implemented using some .gyb code that generates<br>&gt;&gt; declarations that look something like<br>&gt;&gt;<br>&gt;&gt; func == &lt;A: Equatable, B: Equatable, C: Equatable&gt;(lhs: (A, B, C),<br>&gt;&gt; rhs: (A, B, C)) -&gt; Bool {    return lhs.0 == rhs.0 &amp;&amp; lhs.1 == rhs.1<br>&gt;&gt; &amp;&amp; lhs.2 == rhs.2 }<br>&gt;&gt;<br>&gt;&gt; func &lt; &lt;A: Comparable, B: Comparable, C: Comparable&gt;(lhs: (A, B, C),<br>&gt;&gt; rhs: (A, B, C)) -&gt; Bool {    if lhs.0 != rhs.0 { return lhs.0 &lt; rhs.0<br>&gt;&gt; }    if lhs.1 != rhs.1 { return lhs.1 &lt; rhs.1 }    return lhs.2 &lt;<br>&gt;&gt; rhs.2 }<br>&gt;&gt;<br>&gt;&gt; func &gt; &lt;A: Comparable, B: Comparable, C: Comparable&gt;(lhs: (A, B, C),<br>&gt;&gt; rhs: (A, B, C)) -&gt; Bool {    if lhs.0 != rhs.0 { return lhs.0 &gt; rhs.0<br>&gt;&gt; }    if lhs.1 != rhs.1 { return lhs.1 &gt; rhs.1 }    return lhs.2 &gt;<br>&gt;&gt; rhs.2 }<br>&gt;<br>&gt; Looks like a good idea to me!  Also the &lt;= and &gt;= operators, right?<br></p><p>Yeah, and != too. I just skipped them for brevity.<br></p><p>&gt; What concerns we with massive code generation is the code size of the<br>&gt; core swift library.  It would be definitely important to see how much<br>&gt; code this adds, depending on the number of tuple elements.<br></p><p>Good question. What&#39;s the best way to measure this? File size of build/$target/swift-macosx-<br>x86_64/lib/swift/macosx/libswiftCore.dylib (does that even include<br>generic functions)? Or the x86_64/libswiftCore.dylib from the same<br>folder (what&#39;s the difference)? Or x86_64/Swift.swiftmodule?<br>Something else?<br></p><p>&gt; I personally don&#39;t see a point in going as high as 12 tuple elements.<br>&gt; About 4 or 5 makes sense to me.  Given that Swift does not have<br>&gt; variadic generics right now, these long tuples have to be defined by<br>&gt; someone manually.  If one is defining a tuple that is that long, I&#39;d<br>&gt; argue that they should be using a custom struct instead.<br></p><p>Depends on how much code size it is. I&#39;d rather err on the side of<br>defining it for a higher arity tuple than we expect people to actually<br>use in practice. Just because it&#39;s probably a good idea to not point<br>more than a handful of elements in a tuple doesn&#39;t mean people will<br>actually stick to that, and it&#39;s surprising behavior to have ==<br>suddenly break because you added one more (Equatable) value to the<br>tuple. As an example, my coworker recently wrote some code that uses a<br>tuple of 7 elements (as a typedef). It probably should have been a<br>struct, but I think it was originally defined with just 3 or 4 elements<br>and sprouted the others as he worked on it. Granted, this particular<br>tuple wouldn&#39;t actually support ==, but I&#39;m sure others have written<br>similarly long tuples.<br></p><p>I&#39;ll probably prototype this some time today, and I can produce some<br>measurements of code size at different arities (if I can figure out the<br>best way to measure that).<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/7854782c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Proposal: Implement == and &lt; for tuples where possible, up to some high arity</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  7, 2015 at 12:00:00pm</p></header><div class="content"><p>On Mon, Dec 7, 2015 at 12:22 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; On Mon, Dec 7, 2015, at 12:01 PM, Dmitri Gribenko wrote:<br>&gt;<br>&gt; On Mon, Dec 7, 2015 at 11:48 AM, Kevin Ballard via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Good question. What&#39;s the best way to measure this? File size of<br>&gt; build/$target/swift-macosx-x86_64/lib/swift/macosx/libswiftCore.dylib (does<br>&gt; that even include generic functions)? Or the x86_64/libswiftCore.dylib from<br>&gt; the same folder (what&#39;s the difference)? Or x86_64/Swift.swiftmodule?<br>&gt; Something else?<br></p><p>Use utils/cmpcodesize.<br></p><p>The swift-macosx-x86_64/lib/swift/&lt;target&gt;/libswiftCore.dylib dylibs<br>are fat ones, the dylib nested inside the architecture directory is a<br>regular one.  Please also measure for iOS (to build those, run<br>build-script with -i).<br></p><p>&gt; I personally don&#39;t see a point in going as high as 12 tuple elements.  About<br>&gt; 4 or 5 makes sense to me.  Given that Swift does not have variadic generics<br>&gt; right now, these long tuples have to be defined by someone manually.  If one<br>&gt; is defining a tuple that is that long, I&#39;d argue that they should be using a<br>&gt; custom struct instead.<br>&gt;<br>&gt;<br>&gt; Depends on how much code size it is. I&#39;d rather err on the side of defining<br>&gt; it for a higher arity tuple than we expect people to actually use in<br>&gt; practice. Just because it&#39;s probably a good idea to not point more than a<br>&gt; handful of elements in a tuple doesn&#39;t mean people will actually stick to<br>&gt; that, and it&#39;s surprising behavior to have == suddenly break because you<br>&gt; added one more (Equatable) value to the tuple. As an example, my coworker<br>&gt; recently wrote some code that uses a tuple of 7 elements (as a typedef). It<br>&gt; probably should have been a struct, but I think it was originally defined<br>&gt; with just 3 or 4 elements and sprouted the others as he worked on it.<br>&gt; Granted, this particular tuple wouldn&#39;t actually support ==, but I&#39;m sure<br>&gt; others have written similarly long tuples.<br>&gt;<br>&gt; I&#39;ll probably prototype this some time today, and I can produce some<br>&gt; measurements of code size at different arities (if I can figure out the best<br>&gt; way to measure that).<br></p><p>I can see that.  Definitely depends on the code size, though!<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Implement == and &lt; for tuples where possible, up to some high arity</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  7, 2015 at 10:00:00pm</p></header><div class="content"><p>Code size turns out to be much higher than expected.<br></p><p>When implementing ==, !=, &lt;, &lt;=, &gt;, and &gt;= for tuples of arities 2–6, I<br>end up with a 1.4% increase in libswiftCore.dylib code size:<br></p><p>                                   Section       Old       New  Percent<br>libswiftCore.dylib                  __text:  3198165   3242853   -1.4%<br>libswiftCore.dylib                  __text:  2939740   2980844   -1.4%<br></p><p>(or about 43.6KiB)<br></p><p>After increasing it to go up to arity 12, it reaches a 5.3–5.5%<br>increase:<br></p><p>                                   Section       Old       New  Percent<br>libswiftCore.dylib                  __text:  3198165   3373349   -5.5%<br>libswiftCore.dylib                  __text:  2939740   3096140   -5.3%<br></p><p>(171KiB for macosx, 152.7KiB for iphoneos)<br></p><p>I&#39;m surprised at how large this is. 43.6KiB for arities 2–6 alone seems<br>bad enough, but up to 171KiB for arities 2–12? Where did all that code<br>size come from!<br></p><p>Note: this is compiling as Ninja-ReleaseAssert.<br></p><p>Based on this, I&#39;m inclined to submit the change with arities 2–6, but<br>if anyone has any idea why this results in so much code size I&#39;d love to<br>hear it.<br></p><p>-Kevin Ballard<br></p><p>On Mon, Dec 7, 2015, at 12:32 PM, Dmitri Gribenko wrote:<br>&gt; On Mon, Dec 7, 2015 at 12:22 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; &gt; On Mon, Dec 7, 2015, at 12:01 PM, Dmitri Gribenko wrote:<br>&gt; &gt;<br>&gt; &gt; On Mon, Dec 7, 2015 at 11:48 AM, Kevin Ballard via swift-evolution<br>&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; Good question. What&#39;s the best way to measure this? File size of<br>&gt; &gt; build/$target/swift-macosx-x86_64/lib/swift/macosx/libswiftCore.dylib (does<br>&gt; &gt; that even include generic functions)? Or the x86_64/libswiftCore.dylib from<br>&gt; &gt; the same folder (what&#39;s the difference)? Or x86_64/Swift.swiftmodule?<br>&gt; &gt; Something else?<br>&gt; <br>&gt; Use utils/cmpcodesize.<br>&gt; <br>&gt; The swift-macosx-x86_64/lib/swift/&lt;target&gt;/libswiftCore.dylib dylibs<br>&gt; are fat ones, the dylib nested inside the architecture directory is a<br>&gt; regular one.  Please also measure for iOS (to build those, run<br>&gt; build-script with -i).<br>&gt; <br>&gt; &gt; I personally don&#39;t see a point in going as high as 12 tuple elements.  About<br>&gt; &gt; 4 or 5 makes sense to me.  Given that Swift does not have variadic generics<br>&gt; &gt; right now, these long tuples have to be defined by someone manually.  If one<br>&gt; &gt; is defining a tuple that is that long, I&#39;d argue that they should be using a<br>&gt; &gt; custom struct instead.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Depends on how much code size it is. I&#39;d rather err on the side of defining<br>&gt; &gt; it for a higher arity tuple than we expect people to actually use in<br>&gt; &gt; practice. Just because it&#39;s probably a good idea to not point more than a<br>&gt; &gt; handful of elements in a tuple doesn&#39;t mean people will actually stick to<br>&gt; &gt; that, and it&#39;s surprising behavior to have == suddenly break because you<br>&gt; &gt; added one more (Equatable) value to the tuple. As an example, my coworker<br>&gt; &gt; recently wrote some code that uses a tuple of 7 elements (as a typedef). It<br>&gt; &gt; probably should have been a struct, but I think it was originally defined<br>&gt; &gt; with just 3 or 4 elements and sprouted the others as he worked on it.<br>&gt; &gt; Granted, this particular tuple wouldn&#39;t actually support ==, but I&#39;m sure<br>&gt; &gt; others have written similarly long tuples.<br>&gt; &gt;<br>&gt; &gt; I&#39;ll probably prototype this some time today, and I can produce some<br>&gt; &gt; measurements of code size at different arities (if I can figure out the best<br>&gt; &gt; way to measure that).<br>&gt; <br>&gt; I can see that.  Definitely depends on the code size, though!<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Implement == and &lt; for tuples where possible, up to some high arity</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  7, 2015 at 10:00:00pm</p></header><div class="content"><p>I&#39;ve pushed my code (no tests) as<br>https://github.com/kballard/swift/commit/3b61da42986689d0f26323f88a49bf7d1175c717<br>if anyone wants to see it.<br></p><p>-Kevin Ballard<br></p><p>On Mon, Dec 7, 2015, at 10:04 PM, Kevin Ballard wrote:<br>&gt; Code size turns out to be much higher than expected.<br>&gt; <br>&gt; When implementing ==, !=, &lt;, &lt;=, &gt;, and &gt;= for tuples of arities 2–6, I<br>&gt; end up with a 1.4% increase in libswiftCore.dylib code size:<br>&gt; <br>&gt;                                    Section       Old       New  Percent<br>&gt; libswiftCore.dylib                  __text:  3198165   3242853   -1.4%<br>&gt; libswiftCore.dylib                  __text:  2939740   2980844   -1.4%<br>&gt; <br>&gt; (or about 43.6KiB)<br>&gt; <br>&gt; After increasing it to go up to arity 12, it reaches a 5.3–5.5%<br>&gt; increase:<br>&gt; <br>&gt;                                    Section       Old       New  Percent<br>&gt; libswiftCore.dylib                  __text:  3198165   3373349   -5.5%<br>&gt; libswiftCore.dylib                  __text:  2939740   3096140   -5.3%<br>&gt; <br>&gt; (171KiB for macosx, 152.7KiB for iphoneos)<br>&gt; <br>&gt; I&#39;m surprised at how large this is. 43.6KiB for arities 2–6 alone seems<br>&gt; bad enough, but up to 171KiB for arities 2–12? Where did all that code<br>&gt; size come from!<br>&gt; <br>&gt; Note: this is compiling as Ninja-ReleaseAssert.<br>&gt; <br>&gt; Based on this, I&#39;m inclined to submit the change with arities 2–6, but<br>&gt; if anyone has any idea why this results in so much code size I&#39;d love to<br>&gt; hear it.<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; On Mon, Dec 7, 2015, at 12:32 PM, Dmitri Gribenko wrote:<br>&gt; &gt; On Mon, Dec 7, 2015 at 12:22 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; &gt; &gt; On Mon, Dec 7, 2015, at 12:01 PM, Dmitri Gribenko wrote:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; On Mon, Dec 7, 2015 at 11:48 AM, Kevin Ballard via swift-evolution<br>&gt; &gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; &gt; Good question. What&#39;s the best way to measure this? File size of<br>&gt; &gt; &gt; build/$target/swift-macosx-x86_64/lib/swift/macosx/libswiftCore.dylib (does<br>&gt; &gt; &gt; that even include generic functions)? Or the x86_64/libswiftCore.dylib from<br>&gt; &gt; &gt; the same folder (what&#39;s the difference)? Or x86_64/Swift.swiftmodule?<br>&gt; &gt; &gt; Something else?<br>&gt; &gt; <br>&gt; &gt; Use utils/cmpcodesize.<br>&gt; &gt; <br>&gt; &gt; The swift-macosx-x86_64/lib/swift/&lt;target&gt;/libswiftCore.dylib dylibs<br>&gt; &gt; are fat ones, the dylib nested inside the architecture directory is a<br>&gt; &gt; regular one.  Please also measure for iOS (to build those, run<br>&gt; &gt; build-script with -i).<br>&gt; &gt; <br>&gt; &gt; &gt; I personally don&#39;t see a point in going as high as 12 tuple elements.  About<br>&gt; &gt; &gt; 4 or 5 makes sense to me.  Given that Swift does not have variadic generics<br>&gt; &gt; &gt; right now, these long tuples have to be defined by someone manually.  If one<br>&gt; &gt; &gt; is defining a tuple that is that long, I&#39;d argue that they should be using a<br>&gt; &gt; &gt; custom struct instead.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Depends on how much code size it is. I&#39;d rather err on the side of defining<br>&gt; &gt; &gt; it for a higher arity tuple than we expect people to actually use in<br>&gt; &gt; &gt; practice. Just because it&#39;s probably a good idea to not point more than a<br>&gt; &gt; &gt; handful of elements in a tuple doesn&#39;t mean people will actually stick to<br>&gt; &gt; &gt; that, and it&#39;s surprising behavior to have == suddenly break because you<br>&gt; &gt; &gt; added one more (Equatable) value to the tuple. As an example, my coworker<br>&gt; &gt; &gt; recently wrote some code that uses a tuple of 7 elements (as a typedef). It<br>&gt; &gt; &gt; probably should have been a struct, but I think it was originally defined<br>&gt; &gt; &gt; with just 3 or 4 elements and sprouted the others as he worked on it.<br>&gt; &gt; &gt; Granted, this particular tuple wouldn&#39;t actually support ==, but I&#39;m sure<br>&gt; &gt; &gt; others have written similarly long tuples.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; I&#39;ll probably prototype this some time today, and I can produce some<br>&gt; &gt; &gt; measurements of code size at different arities (if I can figure out the best<br>&gt; &gt; &gt; way to measure that).<br>&gt; &gt; <br>&gt; &gt; I can see that.  Definitely depends on the code size, though!<br>&gt; &gt; <br>&gt; &gt; Dmitri<br>&gt; &gt; <br>&gt; &gt; -- <br>&gt; &gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; &gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Proposal: Implement == and &lt; for tuples where possible, up to some high arity</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>December  8, 2015 at 08:00:00am</p></header><div class="content"><p>FWIW — and without trying to address why the absolute size is what it is — at least in my experience, &quot;generic families” like “== for tuples of length 2 , … n“ seem to require size that reliably grows as O(n^2). <br></p><p>On the one hand, this growth pattern doesn&#39;t actually seem *surprising* (think about it); but, on the other hand, I’d also be curious to know if the ABI changes for Swift 3 will have any significant impact on the *absolute* size of such constructs (or if other features will provide other solutions).<br></p><p>&gt; On Dec 8, 2015, at 12:04 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Code size turns out to be much higher than expected.<br>&gt; <br>&gt; When implementing ==, !=, &lt;, &lt;=, &gt;, and &gt;= for tuples of arities 2–6, I<br>&gt; end up with a 1.4% increase in libswiftCore.dylib code size:<br>&gt; <br>&gt;                                   Section       Old       New  Percent<br>&gt; libswiftCore.dylib                  __text:  3198165   3242853   -1.4%<br>&gt; libswiftCore.dylib                  __text:  2939740   2980844   -1.4%<br>&gt; <br>&gt; (or about 43.6KiB)<br>&gt; <br>&gt; After increasing it to go up to arity 12, it reaches a 5.3–5.5%<br>&gt; increase:<br>&gt; <br>&gt;                                   Section       Old       New  Percent<br>&gt; libswiftCore.dylib                  __text:  3198165   3373349   -5.5%<br>&gt; libswiftCore.dylib                  __text:  2939740   3096140   -5.3%<br>&gt; <br>&gt; (171KiB for macosx, 152.7KiB for iphoneos)<br>&gt; <br>&gt; I&#39;m surprised at how large this is. 43.6KiB for arities 2–6 alone seems<br>&gt; bad enough, but up to 171KiB for arities 2–12? Where did all that code<br>&gt; size come from!<br>&gt; <br>&gt; Note: this is compiling as Ninja-ReleaseAssert.<br>&gt; <br>&gt; Based on this, I&#39;m inclined to submit the change with arities 2–6, but<br>&gt; if anyone has any idea why this results in so much code size I&#39;d love to<br>&gt; hear it.<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; On Mon, Dec 7, 2015, at 12:32 PM, Dmitri Gribenko wrote:<br>&gt;&gt; On Mon, Dec 7, 2015 at 12:22 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt; On Mon, Dec 7, 2015, at 12:01 PM, Dmitri Gribenko wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, Dec 7, 2015 at 11:48 AM, Kevin Ballard via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Good question. What&#39;s the best way to measure this? File size of<br>&gt;&gt;&gt; build/$target/swift-macosx-x86_64/lib/swift/macosx/libswiftCore.dylib (does<br>&gt;&gt;&gt; that even include generic functions)? Or the x86_64/libswiftCore.dylib from<br>&gt;&gt;&gt; the same folder (what&#39;s the difference)? Or x86_64/Swift.swiftmodule?<br>&gt;&gt;&gt; Something else?<br>&gt;&gt; <br>&gt;&gt; Use utils/cmpcodesize.<br>&gt;&gt; <br>&gt;&gt; The swift-macosx-x86_64/lib/swift/&lt;target&gt;/libswiftCore.dylib dylibs<br>&gt;&gt; are fat ones, the dylib nested inside the architecture directory is a<br>&gt;&gt; regular one.  Please also measure for iOS (to build those, run<br>&gt;&gt; build-script with -i).<br>&gt;&gt; <br>&gt;&gt;&gt; I personally don&#39;t see a point in going as high as 12 tuple elements.  About<br>&gt;&gt;&gt; 4 or 5 makes sense to me.  Given that Swift does not have variadic generics<br>&gt;&gt;&gt; right now, these long tuples have to be defined by someone manually.  If one<br>&gt;&gt;&gt; is defining a tuple that is that long, I&#39;d argue that they should be using a<br>&gt;&gt;&gt; custom struct instead.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Depends on how much code size it is. I&#39;d rather err on the side of defining<br>&gt;&gt;&gt; it for a higher arity tuple than we expect people to actually use in<br>&gt;&gt;&gt; practice. Just because it&#39;s probably a good idea to not point more than a<br>&gt;&gt;&gt; handful of elements in a tuple doesn&#39;t mean people will actually stick to<br>&gt;&gt;&gt; that, and it&#39;s surprising behavior to have == suddenly break because you<br>&gt;&gt;&gt; added one more (Equatable) value to the tuple. As an example, my coworker<br>&gt;&gt;&gt; recently wrote some code that uses a tuple of 7 elements (as a typedef). It<br>&gt;&gt;&gt; probably should have been a struct, but I think it was originally defined<br>&gt;&gt;&gt; with just 3 or 4 elements and sprouted the others as he worked on it.<br>&gt;&gt;&gt; Granted, this particular tuple wouldn&#39;t actually support ==, but I&#39;m sure<br>&gt;&gt;&gt; others have written similarly long tuples.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ll probably prototype this some time today, and I can produce some<br>&gt;&gt;&gt; measurements of code size at different arities (if I can figure out the best<br>&gt;&gt;&gt; way to measure that).<br>&gt;&gt; <br>&gt;&gt; I can see that.  Definitely depends on the code size, though!<br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Implement == and &lt; for tuples where possible, up to some high arity</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  7, 2015 at 03:00:00pm</p></header><div class="content"><p>On Dec 7, 2015, at 12:01 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; func &gt; &lt;A: Comparable, B: Comparable, C: Comparable&gt;(lhs: (A, B, C), rhs: (A, B, C)) -&gt; Bool {<br>&gt;     if lhs.0 != rhs.0 { return lhs.0 &gt; rhs.0 }<br>&gt;     if lhs.1 != rhs.1 { return lhs.1 &gt; rhs.1 }<br>&gt;     return lhs.2 &gt; rhs.2<br>&gt; }<br>&gt; <br>&gt; Looks like a good idea to me!  Also the &lt;= and &gt;= operators, right?<br></p><p>+1 from me too.<br></p><p>&gt; I personally don&#39;t see a point in going as high as 12 tuple elements.  About 4 or 5 makes sense to me.  Given that Swift does not have variadic generics right now, these long tuples have to be defined by someone manually.  If one is defining a tuple that is that long, I&#39;d argue that they should be using a custom struct instead.<br></p><p>I tend to agree with Dmitri here.  Independent of the code size concern, what is the expected use-case for &gt; 4 element tuples?<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/b292bab5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Proposal: Implement == and &lt; for tuples where possible, up to some high arity</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  7, 2015 at 03:00:00pm</p></header><div class="content"><p>On Mon, Dec 7, 2015 at 3:01 PM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Dec 7, 2015, at 12:01 PM, Dmitri Gribenko via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I personally don&#39;t see a point in going as high as 12 tuple elements.<br>&gt; About 4 or 5 makes sense to me.  Given that Swift does not have variadic<br>&gt; generics right now, these long tuples have to be defined by someone<br>&gt; manually.  If one is defining a tuple that is that long, I&#39;d argue that<br>&gt; they should be using a custom struct instead.<br>&gt;<br>&gt;<br>&gt; I tend to agree with Dmitri here.  Independent of the code size concern,<br>&gt; what is the expected use-case for &gt; 4 element tuples?<br>&gt;<br>&gt; -Chris<br>&gt;<br></p><p><br>On the contrary, I think &gt;4-element-tuples are useful exactly *for* the<br>case of custom structs. You wouldn&#39;t want the tuples themselves to be part<br>of your API, but if you have a custom struct with 4+ Comparable fields, you<br>can implement its &lt; operator as simply &quot;return (a1,b1,c1,d1,e1) &lt;<br>(a2,b2,c2,d2,e2)&quot;.<br></p><p>Jacob<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/8360415e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Implement == and &lt; for tuples where possible, up to some high arity</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  7, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 3:04 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Mon, Dec 7, 2015 at 3:01 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; On Dec 7, 2015, at 12:01 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I personally don&#39;t see a point in going as high as 12 tuple elements.  About 4 or 5 makes sense to me.  Given that Swift does not have variadic generics right now, these long tuples have to be defined by someone manually.  If one is defining a tuple that is that long, I&#39;d argue that they should be using a custom struct instead.<br>&gt; <br>&gt; I tend to agree with Dmitri here.  Independent of the code size concern, what is the expected use-case for &gt; 4 element tuples?<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; On the contrary, I think &gt;4-element-tuples are useful exactly *for* the case of custom structs. You wouldn&#39;t want the tuples themselves to be part of your API, but if you have a custom struct with 4+ Comparable fields, you can implement its &lt; operator as simply &quot;return (a1,b1,c1,d1,e1) &lt; (a2,b2,c2,d2,e2)”.<br></p><p>Sure, or:<br>   return (a1,b1,(c1,d1,e1)) &lt; (a2,b2,(c2,d2,e2))<br></p><p>:-)<br></p><p>-Chris<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/601a52f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Proposal: Implement == and &lt; for tuples where possible, up to some high arity</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  7, 2015 at 04:00:00pm</p></header><div class="content"><p>On Mon, Dec 7, 2015 at 4:06 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;<br>&gt; On Dec 7, 2015, at 3:04 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Mon, Dec 7, 2015 at 3:01 PM, Chris Lattner via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Dec 7, 2015, at 12:01 PM, Dmitri Gribenko via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I personally don&#39;t see a point in going as high as 12 tuple elements.<br>&gt;&gt; About 4 or 5 makes sense to me.  Given that Swift does not have variadic<br>&gt;&gt; generics right now, these long tuples have to be defined by someone<br>&gt;&gt; manually.  If one is defining a tuple that is that long, I&#39;d argue that they<br>&gt;&gt; should be using a custom struct instead.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I tend to agree with Dmitri here.  Independent of the code size concern,<br>&gt;&gt; what is the expected use-case for &gt; 4 element tuples?<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;<br>&gt;<br>&gt;<br>&gt; On the contrary, I think &gt;4-element-tuples are useful exactly *for* the case<br>&gt; of custom structs. You wouldn&#39;t want the tuples themselves to be part of<br>&gt; your API, but if you have a custom struct with 4+ Comparable fields, you can<br>&gt; implement its &lt; operator as simply &quot;return (a1,b1,c1,d1,e1) &lt;<br>&gt; (a2,b2,c2,d2,e2)”.<br>&gt;<br>&gt;<br>&gt; Sure, or:<br>&gt;    return (a1,b1,(c1,d1,e1)) &lt; (a2,b2,(c2,d2,e2))<br></p><p>That won&#39;t work, since tuples don&#39;t conform to Comparable.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Implement == and &lt; for tuples where possible, up to some high arity</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  7, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 4:08 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On the contrary, I think &gt;4-element-tuples are useful exactly *for* the case<br>&gt;&gt; of custom structs. You wouldn&#39;t want the tuples themselves to be part of<br>&gt;&gt; your API, but if you have a custom struct with 4+ Comparable fields, you can<br>&gt;&gt; implement its &lt; operator as simply &quot;return (a1,b1,c1,d1,e1) &lt;<br>&gt;&gt; (a2,b2,c2,d2,e2)”.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sure, or:<br>&gt;&gt;   return (a1,b1,(c1,d1,e1)) &lt; (a2,b2,(c2,d2,e2))<br>&gt; <br>&gt; That won&#39;t work, since tuples don&#39;t conform to Comparable.<br></p><p>Ah right, someone should really fix that :-) :-)<br></p><p>-Chris<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: Implement == and &lt; for tuples where possible, up to some high arity</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  7, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; you can implement its &lt; operator as simply &quot;return (a1,b1,c1,d1,e1) &lt; (a2,b2,c2,d2,e2)”.<br></p><p>	return zip([a1,b1,c1,d1,e1], [a2,b2,c2,d2,e2]).lazy.filter(==).first.flatMap(&lt;) ?? false<br></p><p>Okay, so that wasn’t quite as easy as I thought when I started writing the email.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Implement == and &lt; for tuples where possible, up to some high arity</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  7, 2015 at 04:00:00pm</p></header><div class="content"><p>On Mon, Dec 7, 2015, at 04:11 PM, Brent Royal-Gordon via swift-evolution<br>wrote:<br>&gt; &gt; you can implement its &lt; operator as simply &quot;return (a1,b1,c1,d1,e1) &lt; (a2,b2,c2,d2,e2)”.<br>&gt; <br>&gt; 	return zip([a1,b1,c1,d1,e1], [a2,b2,c2,d2,e2]).lazy.filter(==).first.flatMap(&lt;) ?? false<br>&gt; <br>&gt; Okay, so that wasn’t quite as easy as I thought when I started writing<br>&gt; the email.<br></p><p>That also allocates two intermediate arrays (the inputs to zip()).<br></p><p>-Kevin<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Proposal: Implement == and &lt; for tuples where possible, up to some high arity</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  7, 2015 at 04:00:00pm</p></header><div class="content"><p>On Mon, Dec 7, 2015 at 4:12 PM, Kevin Ballard via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; On Mon, Dec 7, 2015, at 04:11 PM, Brent Royal-Gordon via swift-evolution<br>&gt; wrote:<br>&gt;&gt; &gt; you can implement its &lt; operator as simply &quot;return (a1,b1,c1,d1,e1) &lt; (a2,b2,c2,d2,e2)”.<br>&gt;&gt;<br>&gt;&gt;       return zip([a1,b1,c1,d1,e1], [a2,b2,c2,d2,e2]).lazy.filter(==).first.flatMap(&lt;) ?? false<br>&gt;&gt;<br>&gt;&gt; Okay, so that wasn’t quite as easy as I thought when I started writing<br>&gt;&gt; the email.<br>&gt;<br>&gt; That also allocates two intermediate arrays (the inputs to zip()).<br></p><p>And relies on all variables having the same type.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: Implement == and &lt; for tuples where possible, up to some high arity</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  7, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt;&gt;&gt;      return zip([a1,b1,c1,d1,e1], [a2,b2,c2,d2,e2]).lazy.filter(==).first.flatMap(&lt;) ?? false<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Okay, so that wasn’t quite as easy as I thought when I started writing<br>&gt;&gt;&gt; the email.<br>&gt;&gt; <br>&gt;&gt; That also allocates two intermediate arrays (the inputs to zip()).<br>&gt; <br>&gt; And relies on all variables having the same type.<br></p><p>Both true. What actually happened was, when I looked at the tuple version, I thought “okay, that’s basically just zipping the two together and then running &lt; on each pair&quot;. In trying to write the email making that point, I discovered that this “easy” alternative is actually ridiculously complicated once you translate it from a vague notion to running code, and thought that was funny.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Proposal: Implement == and &lt; for tuples where possible, up to some high arity</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  7, 2015 at 04:00:00pm</p></header><div class="content"><p>On Mon, Dec 7, 2015 at 4:17 PM, Brent Royal-Gordon<br>&lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt;      return zip([a1,b1,c1,d1,e1], [a2,b2,c2,d2,e2]).lazy.filter(==).first.flatMap(&lt;) ?? false<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Okay, so that wasn’t quite as easy as I thought when I started writing<br>&gt;&gt;&gt;&gt; the email.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That also allocates two intermediate arrays (the inputs to zip()).<br>&gt;&gt;<br>&gt;&gt; And relies on all variables having the same type.<br>&gt;<br>&gt; Both true. What actually happened was, when I looked at the tuple version, I thought “okay, that’s basically just zipping the two together and then running &lt; on each pair&quot;. In trying to write the email making that point, I discovered that this “easy” alternative is actually ridiculously complicated once you translate it from a vague notion to running code, and thought that was funny.<br></p><p>We have lexicographicalCompare(), so it is not that complicated after all.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Proposal: Implement == and &lt; for tuples where possible, up to some high arity</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December  8, 2015 at 11:00:00am</p></header><div class="content"><p>I&#39;d love to see a type like tuple&lt;(A,B,C),D&gt;, that is equivalent to<br>(A,B,C,D).<br>Also you could have functions on the tuple:<br></p><p>for (A,B,C,D,E,F):<br></p><p>func prefix&lt;A,B,C,...&gt;() -&gt; (A,B,C)<br>func suffix&lt;...,D,E,F&gt;() -&gt; (D,E,F)<br></p><p>Then you may be able to do something like this:<br>func ==&lt;A:tuple&lt;&gt;, B: tuple&lt;&gt;, where A: Equatable, B:Equatable&gt;(lhs:<br>tuple&lt;A,B&gt;, rhs: tuple&lt;A,B&gt;) {<br>    return ls.prefix() as A == rhs.prefix() as A &amp;&amp; lhs.suffix() as B ==<br>rhs.suffix() as B<br>}<br>extension tuple&lt;Equatable,Equatable&gt;: Equatable {}<br></p><p>The downside I can see for that is that it will match the same tuple n<br>different ways. You can overcome this by only allowing tuple&lt;A,B&gt; to append<br>a single element, but it&#39;s less useful. Alternatively it will always match<br>the function with the most elements in the left-most argument, and cannot<br>match against the empty tuple.<br></p><p><br>On Tue, Dec 8, 2015 at 11:18 AM, Dmitri Gribenko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Mon, Dec 7, 2015 at 4:17 PM, Brent Royal-Gordon<br>&gt; &lt;brent at architechies.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;      return zip([a1,b1,c1,d1,e1],<br>&gt; [a2,b2,c2,d2,e2]).lazy.filter(==).first.flatMap(&lt;) ?? false<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Okay, so that wasn’t quite as easy as I thought when I started writing<br>&gt; &gt;&gt;&gt;&gt; the email.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; That also allocates two intermediate arrays (the inputs to zip()).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; And relies on all variables having the same type.<br>&gt; &gt;<br>&gt; &gt; Both true. What actually happened was, when I looked at the tuple<br>&gt; version, I thought “okay, that’s basically just zipping the two together<br>&gt; and then running &lt; on each pair&quot;. In trying to write the email making that<br>&gt; point, I discovered that this “easy” alternative is actually ridiculously<br>&gt; complicated once you translate it from a vague notion to running code, and<br>&gt; thought that was funny.<br>&gt;<br>&gt; We have lexicographicalCompare(), so it is not that complicated after all.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/1ae2037e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Proposal: Implement == and &lt; for tuples where possible, up to some high arity</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>December  8, 2015 at 10:00:00am</p></header><div class="content"><p>FWIW, the possibility of tuple-punning (tuple -&gt; function arguments) provides a lot of practical uses for larger tuples, but these aren’t actually uses that would really benefit from having `==`, etc., defined.<br></p><p>What *would* be useful for those uses is some standard way to flatten “nested&quot; tuples -&gt; “flat&quot; tuples — `((a,b),(c,d),(e,f,g)) -&gt; (a,b,c,d,e,f,g)` and so on — if it doesn’t already exist (does it?).<br></p><p>&gt; On Dec 7, 2015, at 5:01 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Dec 7, 2015, at 12:01 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; func &gt; &lt;A: Comparable, B: Comparable, C: Comparable&gt;(lhs: (A, B, C), rhs: (A, B, C)) -&gt; Bool {<br>&gt;&gt;     if lhs.0 != rhs.0 { return lhs.0 &gt; rhs.0 }<br>&gt;&gt;     if lhs.1 != rhs.1 { return lhs.1 &gt; rhs.1 }<br>&gt;&gt;     return lhs.2 &gt; rhs.2<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Looks like a good idea to me!  Also the &lt;= and &gt;= operators, right?<br>&gt; <br>&gt; +1 from me too.<br>&gt; <br>&gt;&gt; I personally don&#39;t see a point in going as high as 12 tuple elements.  About 4 or 5 makes sense to me.  Given that Swift does not have variadic generics right now, these long tuples have to be defined by someone manually.  If one is defining a tuple that is that long, I&#39;d argue that they should be using a custom struct instead.<br>&gt; <br>&gt; I tend to agree with Dmitri here.  Independent of the code size concern, what is the expected use-case for &gt; 4 element tuples?<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/73fbdc09/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Proposal: Implement == and &lt; for tuples where possible, up to some high arity</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December  8, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 5:01 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I tend to agree with Dmitri here.  Independent of the code size concern, what is the expected use-case for &gt; 4 element tuples?<br></p><p>When importing structs from C, all char arrays are converted into Int8 tuples. So, it’s pretty easy to end up with a tuple with quite a lot of elements.<br></p><p>For example:<br></p><p>struct Foo {<br>    char bar[256];<br>};<br></p><p>becomes:<br></p><p>public struct Foo {<br>    public var bar: (Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8)<br>    public init()<br>    public init(bar: (Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8))<br>}<br></p><p>These tuples are currently rather difficult to work with.<br></p><p>Charles<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Implement == and &lt; for tuples where possible, up to some high arity</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  8, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 8, 2015, at 12:10 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 5:01 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I tend to agree with Dmitri here.  Independent of the code size concern, what is the expected use-case for &gt; 4 element tuples?<br>&gt; <br>&gt; When importing structs from C, all char arrays are converted into Int8 tuples. So, it’s pretty easy to end up with a tuple with quite a lot of elements.<br>&gt; <br>&gt; For example:<br>&gt; <br>&gt; struct Foo {<br>&gt;    char bar[256];<br>&gt; };<br>&gt; <br>&gt; becomes:<br>&gt; <br>&gt; public struct Foo {<br>&gt;    public var bar: (Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8)<br>&gt;    public init()<br>&gt;    public init(bar: (Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8))<br>&gt; }<br>&gt; <br>&gt; These tuples are currently rather difficult to work with.<br></p><p>Indeed.  However, this doesn’t mean that this is a good thing and that making 256-element tuples comparable is a requirement.  This means that we should (someday) investigate in-place fixed-size array types, so that we can import the C constructs better.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Implement == and &lt; for tuples where possible, up to some high arity</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  9, 2015 at 11:00:00pm</p></header><div class="content"><p>I&#39;ve submitted this proposal as https://github.com/apple/swift-evolution/pull/45<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Proposal: Implement == and &lt; for tuples where possible, up to some high arity</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>December 10, 2015 at 12:00:00pm</p></header><div class="content"><p>If these are to be added to the standard library it seems prudent to put them in under their own names — e.g. `#&lt;`, and then `#==` for consistency — reserving `&lt;` for any user-defined logic. <br></p><p>The reason I suggest this is that at least at present, the existing method-dispatch logic seems likely to lead to unintended consequences if e.g. `&lt;` is defined so broadly; if you can paste the below into a playground you can see the kind of non-intuitive behavior that can crop up here:<br></p><p>// proposed function, arity-2<br>func == &lt;A:Equatable,B:Equatable&gt; (lhs: (A,B), rhs: (A,B)) -&gt; Bool {<br>  return lhs.0 == rhs.0 &amp;&amp; lhs.1 == rhs.1<br>}<br></p><p>// proposed function, arity-2<br>func &lt; &lt;A:Comparable,B:Comparable&gt; (lhs: (A,B), rhs: (A,B)) -&gt; Bool {<br>  if lhs.0 != rhs.0 { return lhs.0 &lt; rhs.0 }<br>  return lhs.1 &lt; rhs.1<br>}<br></p><p>// concrete `&lt;` implementation:<br>func &lt; (lhs: (String,String), rhs: (String,String)) -&gt; Bool {<br>  switch customComparison(lhs.0, rhs.0) {<br>  case .OrderedAscending: return true<br>  case .OrderedDescending: return false<br>  case .OrderedSame:<br>    return customComparison(lhs.1, rhs.1) == .OrderedAscending<br>  }<br>}<br></p><p>// helper for `&lt;` <br>private func customComparison(lhs: String, _ rhs: String) -&gt; NSComparisonResult {<br>  return (lhs as NSString).compare(rhs, options: [.CaseInsensitiveSearch, .NumericSearch])<br>}<br></p><p>// trouble begins here:<br>extension SequenceType {<br>  <br>  func extractOrderedPairs&lt;K:Comparable,Q:Comparable&gt;(extractor: (Self.Generator.Element) -&gt; (K,Q)) -&gt; [(K,Q)] {<br>    return self.map(extractor).sort() {<br>      (l:(K,Q),r:(K,Q)) -&gt; Bool<br>      in<br>      return l &lt; r<br>    }<br>  }<br>  <br>  func extractOrderedPairs&lt;K,Q&gt;(<br>    isOrderedBefore: ((K,Q),(K,Q)) -&gt; Bool,<br>    _ extractor: (Self.Generator.Element) -&gt; (K,Q)) -&gt; [(K,Q)] {<br>      return self.map(extractor).sort(isOrderedBefore)<br>  }<br>  <br>}<br></p><p>// helper for below:<br>extension String {<br>  <br>  var fileNamePieces: (String,String) {<br>    get {<br>      let lastComponent = (self as NSString).lastPathComponent<br>      return (<br>        (lastComponent as NSString).stringByDeletingPathExtension,<br>        (lastComponent as NSString).pathExtension<br>      )<br>    }<br>  }<br>  <br>}<br></p><p>let someFileNames = [&quot;Image.png&quot;, &quot;Image.jpeg&quot;, &quot;Image.bmp&quot;, &quot;Essay1.txt&quot;, &quot;Essay11.txt&quot;, &quot;Essay2.txt&quot;]<br></p><p>let pairsV1 = someFileNames.extractOrderedPairs() { $0.fileNamePieces }<br>let pairsV2 = someFileNames.extractOrderedPairs(&lt;) { $0.fileNamePieces }<br>// ^ note the `&lt;` that gets passed-in<br></p><p>var pairV1Mismatches = 0<br>for index in 0..&lt;(pairsV1.count-1) {<br>  if !(pairsV1[index] &lt; pairsV1[index + 1]) {<br>    print(&quot;found mismatch: \(pairsV1[index]) !&lt; \(pairsV1[index + 1])!&quot;)<br>    pairV1Mismatches += 1<br>  }<br>}<br>pairV1Mismatches // 1<br></p><p>var pairV2Mismatches = 0<br>for index in 0..&lt;(pairsV2.count-1) {<br>  if !(pairsV2[index] &lt; pairsV2[index + 1]) {<br>    print(&quot;found mismatch: \(pairsV2[index]) !&lt; \(pairsV2[index + 1])!&quot;)<br>    pairV2Mismatches += 1<br>  }<br>}<br>pairV2Mismatches // 0<br></p><p>// END SNIPPET<br></p><p>Yes this is very contrived — and hopefully not something someone would write intentionally! — and yes if you understand the various scopes and dispatch rules involved you can work out why this happens, but I don’t think it’s intuitive (and thus it’s easy to stumble upon accidentally). I also think that with additional layers of generics / protocol extensions / customized implementations / etc. involved there’ll be a few more flavors of non-intuitive outcomes one can possibly stumble into.<br></p><p>Whence the suggestion that if these are to go into the standard library, put them in under distinct names, rather than as e.g. `==` and `&lt;`. (FWIW `==` is by itself less problematic, but the comparisons likely customization targets, hence my concerns).<br></p><p>&gt; On Dec 10, 2015, at 1:14 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve submitted this proposal as https://github.com/apple/swift-evolution/pull/45<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
