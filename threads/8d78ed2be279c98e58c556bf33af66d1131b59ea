<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7f82643a80c536e1ddf188d21826fc08?s=50"></div><header><strong>Cross-compiling with Toolchain files</strong> from <string>Tom Birch</string> &lt;froody at gmail.com&gt;<p>February 16, 2016 at 09:00:00pm</p></header><div class="content"><p>I&#39;m working on cross-compiling swift using OS X to build a linux-arm<br>runtime/stdlib, and I&#39;ve had some success. My change is here:<br></p><p>https://github.com/froody/swift/commit/bc7ca07c1c7a94a8d07acd635c486388640ee2d2<br></p><p>Steps to repro are in cmake/modules/Toolchain-linux-arm.cmake<br></p><p>It&#39;s still a work in progress, but I wanted to get some feedback on whether<br>or not I&#39;m going in the right direction. Toolchain files are the<br>recommended way for cross-compiling with CMake, but it seems like it<br>doesn&#39;t mesh well with the current system of building multiple mach-o<br>targets from a single CMake invocation (e.g. OS X, iOS, tvOS and watchOS<br>built on OS X). I&#39;ve also had to fight the build-system a lot (using many<br>--skip-build-foo flags, and two invocations of ./utils/build-script) in<br>order to avoid building ninja targets that don&#39;t exist, and I&#39;m wondering<br>if there&#39;s a better way to do this, i.e. to build llvm/clang/swiftc for OS<br>X in llvm-macosx-x86_64/swift-macosx-x86_64 build directories, and use that<br>to build (swiftc?)/stdlib/tests for linux-arm in a swift-linux-armv7 build<br>directory. Maybe this is a good reason to do<br>https://bugs.swift.org/browse/SR-237 first/in parallel?<br></p><p>I also required a change to LLVM:<br></p><p>*https://github.com/froody/swift-llvm/commit/ed54c92943444999f11918f013cca1dba7892da1<br>&lt;https://github.com/froody/swift-llvm/commit/ed54c92943444999f11918f013cca1dba7892da1&gt;*<br></p><p>to fix this error:<br></p><p>CMake Error: The inter-target dependency graph contains the following<br>strongly connected component (cycle):<br>  &quot;NativeLLVMConfig&quot; of type UTILITY<br>    depends on &quot;llvm-config&quot; (strong)<br>  &quot;llvm-config&quot; of type EXECUTABLE<br>    depends on &quot;NativeLLVMConfig&quot; (strong)<br></p><p>Maybe Chris Bieneman has an idea about this? I seemed to successfully<br>cross-compile with the &quot;False AND&quot; hack, not sure what&#39;s going on.<br></p><p>Anyway, I&#39;d appreciate any feedback on the direction/next steps.<br></p><p>cheers,<br>Tom<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160216/8d7859ea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Cross-compiling with Toolchain files</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 16, 2016 at 07:00:00pm</p></header><div class="content"><p>The main reason we didn&#39;t even try to go for the CMake toolchain support is because of the old build/host/target problem. For those who don&#39;t know, in old GCC terminology, the build machine is where you build the compiler, the host machine is where you run the compiler, and the target machine is where you run the code that comes out of the compiler.<br></p><p>Right now our CMake project tries to build some binaries for the host machine (the compiler) and some binaries for the target machine (the runtime, standard library, and overlays). On non-Darwin platforms, these are always the same today; for us the host machine is OS X and we build several target standard libraries. CMake really doesn&#39;t like this, which is why a CMake-generated Xcode project still can&#39;t build for iOS, even though Xcode supports products with different platforms perfectly well.<br></p><p>So from CMake&#39;s perspective, we&#39;re always building for the host machine, and we pass some funny flags when building the runtime and stdlib. We get away with this because the OS X linker can also link binaries intended for iOS et al.<br></p><p>If you&#39;re planning on building a cross-compiler (build = OS X, host = OS X, target = Linux), I think you&#39;d really have the best success by using the same mechanism we use to build multiple stdlibs on Darwin. You&#39;d have to figure out how to trick it into using your linker for just those libraries, but Clang actually does have support for cross-compilation &lt;http://clang.llvm.org/docs/CrossCompilation.html#toolchain-options&gt; (and CMake should be using Clang to link, I think?) so you should have a chance.<br></p><p>Jordan<br></p><p><br>&gt; On Feb 16, 2016, at 13:48 , Tom Birch via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m working on cross-compiling swift using OS X to build a linux-arm runtime/stdlib, and I&#39;ve had some success. My change is here:<br>&gt; <br>&gt; https://github.com/froody/swift/commit/bc7ca07c1c7a94a8d07acd635c486388640ee2d2 &lt;https://github.com/froody/swift/commit/bc7ca07c1c7a94a8d07acd635c486388640ee2d2&gt;<br>&gt; <br>&gt; Steps to repro are in cmake/modules/Toolchain-linux-arm.cmake<br>&gt; <br>&gt; It&#39;s still a work in progress, but I wanted to get some feedback on whether or not I&#39;m going in the right direction. Toolchain files are the recommended way for cross-compiling with CMake, but it seems like it doesn&#39;t mesh well with the current system of building multiple mach-o targets from a single CMake invocation (e.g. OS X, iOS, tvOS and watchOS built on OS X). I&#39;ve also had to fight the build-system a lot (using many --skip-build-foo flags, and two invocations of ./utils/build-script) in order to avoid building ninja targets that don&#39;t exist, and I&#39;m wondering if there&#39;s a better way to do this, i.e. to build llvm/clang/swiftc for OS X in llvm-macosx-x86_64/swift-macosx-x86_64 build directories, and use that to build (swiftc?)/stdlib/tests for linux-arm in a swift-linux-armv7 build directory. Maybe this is a good reason to do https://bugs.swift.org/browse/SR-237 &lt;https://bugs.swift.org/browse/SR-237&gt; first/in parallel?<br>&gt; <br>&gt; I also required a change to LLVM:<br>&gt; <br>&gt; https://github.com/froody/swift-llvm/commit/ed54c92943444999f11918f013cca1dba7892da1 &lt;https://github.com/froody/swift-llvm/commit/ed54c92943444999f11918f013cca1dba7892da1&gt;<br>&gt; <br>&gt; to fix this error:<br>&gt;  <br>&gt; CMake Error: The inter-target dependency graph contains the following strongly connected component (cycle):<br>&gt;   &quot;NativeLLVMConfig&quot; of type UTILITY<br>&gt;     depends on &quot;llvm-config&quot; (strong)<br>&gt;   &quot;llvm-config&quot; of type EXECUTABLE<br>&gt;     depends on &quot;NativeLLVMConfig&quot; (strong)<br>&gt; <br>&gt; Maybe Chris Bieneman has an idea about this? I seemed to successfully cross-compile with the &quot;False AND&quot; hack, not sure what&#39;s going on.<br>&gt; <br>&gt; Anyway, I&#39;d appreciate any feedback on the direction/next steps.<br>&gt; <br>&gt; cheers,<br>&gt; Tom<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160216/a5d2c2f1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7f82643a80c536e1ddf188d21826fc08?s=50"></div><header><strong>Cross-compiling with Toolchain files</strong> from <string>Tom Birch</string> &lt;froody at gmail.com&gt;<p>February 18, 2016 at 05:00:00pm</p></header><div class="content"><p>I agree that CMake really doesn&#39;t like building multiple target variants<br>within a single invocation, which is why I suggested Toolchain files in the<br>first place.  I don&#39;t follow your argument that wrapping ld, ar, ranlib,<br>etc. is preferable to using Toolchain files. The problem is that I&#39;d not<br>only need to wrap these commands, but also change all the CMake configure<br>logic, i.e. all the find_package calls, the CMAKE_SYSTEM_NAME tests, and<br>the check_* calls (luckily there&#39;s only one check_symbol_exists call), and<br>I&#39;m not sure what advantages this has over doing it &quot;the CMake way&quot;. Is the<br>parallelism and the ability to use ninja to rebuild everything without<br>re-invoking CMake really worth all this extra effort? See<br>http://thread.gmane.org/gmane.comp.lang.swift.devel/911 for more details.<br></p><p>Just to be clear, are you suggesting building everything (OSX swiftc, OSX<br>stdlib, Linux stdlib) within a single CMake invocation? Dmitri explained<br>the reasoning behind doing this for Darwin-based targets (i.e. parallelism,<br>fast iteration without re-invoking CMake) , but as mentioned above, I don&#39;t<br>think this works well when mixing different toolchains (elf, mach-o) or<br>headers/libraries (e.g. Linux vs FreeBSD), as you end up having to<br>re-implement a lot of the CMake configure logic either in shell scripts or<br>CMake itself. If multiple CMake invocations are ok, why the aversion to<br>toolchain files?<br></p><p>cheers,<br>Tom<br></p><p>On Tue, Feb 16, 2016 at 10:57 PM Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; The main reason we didn&#39;t even try to go for the CMake toolchain support<br>&gt; is because of the old build/host/target problem. For those who don&#39;t know,<br>&gt; in old GCC terminology, the *build* machine is where you build the<br>&gt; compiler, the *host* machine is where you run the compiler, and the<br>&gt; *target* machine is where you run the code that comes out of the compiler.<br>&gt;<br>&gt; Right now our CMake project tries to build some binaries for the host<br>&gt; machine (the compiler) and some binaries for the target machine (the<br>&gt; runtime, standard library, and overlays). On non-Darwin platforms, these<br>&gt; are always the same today; for us the host machine is OS X and we build<br>&gt; several target standard libraries. CMake *really* doesn&#39;t like this,<br>&gt; which is why a CMake-generated Xcode project still can&#39;t build for iOS,<br>&gt; even though Xcode supports products with different platforms perfectly well.<br>&gt;<br>&gt; So from CMake&#39;s perspective, we&#39;re always building for the host machine,<br>&gt; and we pass some funny flags when building the runtime and stdlib. We get<br>&gt; away with this because the OS X linker can also link binaries intended for<br>&gt; iOS et al.<br>&gt;<br>&gt; If you&#39;re planning on building a cross-compiler (build = OS X, host = OS<br>&gt; X, target = Linux), I think you&#39;d really have the best success by using the<br>&gt; same mechanism we use to build multiple stdlibs on Darwin. You&#39;d have to<br>&gt; figure out how to trick it into using your linker for just those libraries,<br>&gt; but Clang actually does have support for cross-compilation<br>&gt; &lt;http://clang.llvm.org/docs/CrossCompilation.html#toolchain-options&gt; (and<br>&gt; CMake should be using Clang to link, I think?) so you should have a chance.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On Feb 16, 2016, at 13:48 , Tom Birch via swift-dev &lt;swift-dev at swift.org&gt;<br>&gt; wrote:<br>&gt;<br>&gt; I&#39;m working on cross-compiling swift using OS X to build a linux-arm<br>&gt; runtime/stdlib, and I&#39;ve had some success. My change is here:<br>&gt;<br>&gt;<br>&gt; https://github.com/froody/swift/commit/bc7ca07c1c7a94a8d07acd635c486388640ee2d2<br>&gt;<br>&gt; Steps to repro are in cmake/modules/Toolchain-linux-arm.cmake<br>&gt;<br>&gt; It&#39;s still a work in progress, but I wanted to get some feedback on<br>&gt; whether or not I&#39;m going in the right direction. Toolchain files are the<br>&gt; recommended way for cross-compiling with CMake, but it seems like it<br>&gt; doesn&#39;t mesh well with the current system of building multiple mach-o<br>&gt; targets from a single CMake invocation (e.g. OS X, iOS, tvOS and watchOS<br>&gt; built on OS X). I&#39;ve also had to fight the build-system a lot (using many<br>&gt; --skip-build-foo flags, and two invocations of ./utils/build-script) in<br>&gt; order to avoid building ninja targets that don&#39;t exist, and I&#39;m wondering<br>&gt; if there&#39;s a better way to do this, i.e. to build llvm/clang/swiftc for OS<br>&gt; X in llvm-macosx-x86_64/swift-macosx-x86_64 build directories, and use that<br>&gt; to build (swiftc?)/stdlib/tests for linux-arm in a swift-linux-armv7 build<br>&gt; directory. Maybe this is a good reason to do<br>&gt; https://bugs.swift.org/browse/SR-237 first/in parallel?<br>&gt;<br>&gt; I also required a change to LLVM:<br>&gt;<br>&gt; *https://github.com/froody/swift-llvm/commit/ed54c92943444999f11918f013cca1dba7892da1<br>&gt; &lt;https://github.com/froody/swift-llvm/commit/ed54c92943444999f11918f013cca1dba7892da1&gt;*<br>&gt;<br>&gt; to fix this error:<br>&gt;<br>&gt; CMake Error: The inter-target dependency graph contains the following<br>&gt; strongly connected component (cycle):<br>&gt;   &quot;NativeLLVMConfig&quot; of type UTILITY<br>&gt;     depends on &quot;llvm-config&quot; (strong)<br>&gt;   &quot;llvm-config&quot; of type EXECUTABLE<br>&gt;     depends on &quot;NativeLLVMConfig&quot; (strong)<br>&gt;<br>&gt; Maybe Chris Bieneman has an idea about this? I seemed to successfully<br>&gt; cross-compile with the &quot;False AND&quot; hack, not sure what&#39;s going on.<br>&gt;<br>&gt; Anyway, I&#39;d appreciate any feedback on the direction/next steps.<br>&gt;<br>&gt; cheers,<br>&gt; Tom<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160218/9f77d2e7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Cross-compiling with Toolchain files</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 18, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; If multiple CMake invocations are ok, why the aversion to toolchain files?<br></p><p>My main concern is that there end up being two equally-supported ways to build Swift. With LLVM/Clang we had constant small pain trying to keep the autotools and CMake builds in sync. I&#39;d rather not end up in that position for Swift.<br></p><p>(That doesn&#39;t mean it might not be the best option. It just means there are serious downsides, and they&#39;d have to be outweighed by the upsides.)<br></p><p>Jordan<br></p><p><br>&gt; On Feb 18, 2016, at 9:33 , Tom Birch &lt;froody at gmail.com &lt;mailto:froody at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt; I agree that CMake really doesn&#39;t like building multiple target variants within a single invocation, which is why I suggested Toolchain files in the first place.  I don&#39;t follow your argument that wrapping ld, ar, ranlib, etc. is preferable to using Toolchain files. The problem is that I&#39;d not only need to wrap these commands, but also change all the CMake configure logic, i.e. all the find_package calls, the CMAKE_SYSTEM_NAME tests, and the check_* calls (luckily there&#39;s only one check_symbol_exists call), and I&#39;m not sure what advantages this has over doing it &quot;the CMake way&quot;. Is the parallelism and the ability to use ninja to rebuild everything without re-invoking CMake really worth all this extra effort? See http://thread.gmane.org/gmane.comp.lang.swift.devel/911 &lt;http://thread.gmane.org/gmane.comp.lang.swift.devel/911&gt; for more details.<br>&gt; <br>&gt; Just to be clear, are you suggesting building everything (OSX swiftc, OSX stdlib, Linux stdlib) within a single CMake invocation? Dmitri explained the reasoning behind doing this for Darwin-based targets (i.e. parallelism, fast iteration without re-invoking CMake) , but as mentioned above, I don&#39;t think this works well when mixing different toolchains (elf, mach-o) or headers/libraries (e.g. Linux vs FreeBSD), as you end up having to re-implement a lot of the CMake configure logic either in shell scripts or CMake itself. If multiple CMake invocations are ok, why the aversion to toolchain files?<br>&gt; <br>&gt; cheers,<br>&gt; Tom<br>&gt; <br>&gt; On Tue, Feb 16, 2016 at 10:57 PM Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt; The main reason we didn&#39;t even try to go for the CMake toolchain support is because of the old build/host/target problem. For those who don&#39;t know, in old GCC terminology, the build machine is where you build the compiler, the host machine is where you run the compiler, and the target machine is where you run the code that comes out of the compiler.<br>&gt; <br>&gt; Right now our CMake project tries to build some binaries for the host machine (the compiler) and some binaries for the target machine (the runtime, standard library, and overlays). On non-Darwin platforms, these are always the same today; for us the host machine is OS X and we build several target standard libraries. CMake really doesn&#39;t like this, which is why a CMake-generated Xcode project still can&#39;t build for iOS, even though Xcode supports products with different platforms perfectly well.<br>&gt; <br>&gt; So from CMake&#39;s perspective, we&#39;re always building for the host machine, and we pass some funny flags when building the runtime and stdlib. We get away with this because the OS X linker can also link binaries intended for iOS et al.<br>&gt; <br>&gt; If you&#39;re planning on building a cross-compiler (build = OS X, host = OS X, target = Linux), I think you&#39;d really have the best success by using the same mechanism we use to build multiple stdlibs on Darwin. You&#39;d have to figure out how to trick it into using your linker for just those libraries, but Clang actually does have support for cross-compilation &lt;http://clang.llvm.org/docs/CrossCompilation.html#toolchain-options&gt; (and CMake should be using Clang to link, I think?) so you should have a chance.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Feb 16, 2016, at 13:48 , Tom Birch via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt; <br>&gt;&gt; I&#39;m working on cross-compiling swift using OS X to build a linux-arm runtime/stdlib, and I&#39;ve had some success. My change is here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/froody/swift/commit/bc7ca07c1c7a94a8d07acd635c486388640ee2d2 &lt;https://github.com/froody/swift/commit/bc7ca07c1c7a94a8d07acd635c486388640ee2d2&gt;<br>&gt;&gt; <br>&gt;&gt; Steps to repro are in cmake/modules/Toolchain-linux-arm.cmake<br>&gt;&gt; <br>&gt;&gt; It&#39;s still a work in progress, but I wanted to get some feedback on whether or not I&#39;m going in the right direction. Toolchain files are the recommended way for cross-compiling with CMake, but it seems like it doesn&#39;t mesh well with the current system of building multiple mach-o targets from a single CMake invocation (e.g. OS X, iOS, tvOS and watchOS built on OS X). I&#39;ve also had to fight the build-system a lot (using many --skip-build-foo flags, and two invocations of ./utils/build-script) in order to avoid building ninja targets that don&#39;t exist, and I&#39;m wondering if there&#39;s a better way to do this, i.e. to build llvm/clang/swiftc for OS X in llvm-macosx-x86_64/swift-macosx-x86_64 build directories, and use that to build (swiftc?)/stdlib/tests for linux-arm in a swift-linux-armv7 build directory. Maybe this is a good reason to do https://bugs.swift.org/browse/SR-237 &lt;https://bugs.swift.org/browse/SR-237&gt; first/in parallel?<br>&gt;&gt; <br>&gt;&gt; I also required a change to LLVM:<br>&gt;&gt; <br>&gt;&gt; https://github.com/froody/swift-llvm/commit/ed54c92943444999f11918f013cca1dba7892da1 &lt;https://github.com/froody/swift-llvm/commit/ed54c92943444999f11918f013cca1dba7892da1&gt;<br>&gt;&gt; <br>&gt;&gt; to fix this error:<br>&gt;&gt;  <br>&gt;&gt; CMake Error: The inter-target dependency graph contains the following strongly connected component (cycle):<br>&gt;&gt;   &quot;NativeLLVMConfig&quot; of type UTILITY<br>&gt;&gt;     depends on &quot;llvm-config&quot; (strong)<br>&gt;&gt;   &quot;llvm-config&quot; of type EXECUTABLE<br>&gt;&gt;     depends on &quot;NativeLLVMConfig&quot; (strong)<br>&gt;&gt; <br>&gt;&gt; Maybe Chris Bieneman has an idea about this? I seemed to successfully cross-compile with the &quot;False AND&quot; hack, not sure what&#39;s going on.<br>&gt;&gt; <br>&gt;&gt; Anyway, I&#39;d appreciate any feedback on the direction/next steps.<br>&gt;&gt; <br>&gt;&gt; cheers,<br>&gt;&gt; Tom<br>&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160218/95f7bb3f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/088f1858984b00b826ef337a672ebc04?s=50"></div><header><strong>Cross-compiling with Toolchain files</strong> from <string>Chris Bieneman</string> &lt;cbieneman at apple.com&gt;<p>March 15, 2016 at 09:00:00am</p></header><div class="content"><p>Apologies for being *very* late to this thread and reviving it.<br></p><p>I&#39;m not super familiar with the swift build system or its planned evolution, but I can speak to what we&#39;re trying to do in LLVM.<br></p><p>In LLVM &amp; Clang we&#39;re taking steps to move away from building for multiple targets in the same CMake invocation. Today the only place we do this is in compiler_rt, and I&#39;ll hopefully have that fixed by the end of the summer (assuming I can keep distraction to a minimum).<br></p><p>Our plan is to support an engineering workflow that has a single CMake invocation, but we&#39;re going to utilize recursive CMake calls (likely via CMake&#39;s ExternalPreject module) to build runtime libraries for one target at a time. This will likely be exposed to the user by allowing them to specify a list of platform-architecture tuples (or GCC/Clang triples), which we&#39;ll feed into each of our runtime libraries. I expect to support both Darwin-style cross-compilation (Xcode SDKs), and Linux-style cross-compilation (user-specified sysroots), and I&#39;ll either be using CMake Toolchain files, or a similar mechanism to do it.<br></p><p>We&#39;ve also done extensive work to support Toolchain files for building LLVM and Clang, but we don&#39;t currently support Toolchain files for the runtimes in a simple enough way to support building cross-targeted runtimes.<br></p><p>The LLVM community has committed to CMake as our only supported configuration system, and we are committed to making it better at every opportunity. Over the next year (and into the future) we will be working to improve the CMake build systems in all the LLVM runtime libraries (compiler_rt, libcxx, libcxxabi, libunwind,...), with the ultimate goal of being able to support a great cross-compiling experience via CMake for developers and package maintainers alike.<br></p><p>WRT the swift stuff you&#39;re trying to do. I might be able to help work out some kinks. The LLVM patch you needed to make leads me to think your toolchain file may not be correct. We use CMake Toolchain files with the LLVM &amp; Clang CMake build systems to cross-compile LLVM libraries and the Clang compiler extensively. The iOS.cmake Toolchain file in LLVM&#39;s repo is what we use internally at Apple for most LLVM-based projects that ship on embedded Darwin platforms.<br></p><p>I know this isn&#39;t exactly what you&#39;re trying to do, but there is a very simple CMake invocation to build LLVM for iOS which works on any Mac with Xcode and an iOS SDK. The CMake invocation is in our documentation here:<br></p><p>http://llvm.org/docs/GettingStarted.html#cross-compiling-llvm<br></p><p>Hope this helps,<br>-Chris<br></p><p>&gt; On Feb 18, 2016, at 8:24 PM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; If multiple CMake invocations are ok, why the aversion to toolchain files?<br>&gt; <br>&gt; My main concern is that there end up being two equally-supported ways to build Swift. With LLVM/Clang we had constant small pain trying to keep the autotools and CMake builds in sync. I&#39;d rather not end up in that position for Swift.<br>&gt; <br>&gt; (That doesn&#39;t mean it might not be the best option. It just means there are serious downsides, and they&#39;d have to be outweighed by the upsides.)<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 18, 2016, at 9:33 , Tom Birch &lt;froody at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I agree that CMake really doesn&#39;t like building multiple target variants within a single invocation, which is why I suggested Toolchain files in the first place.  I don&#39;t follow your argument that wrapping ld, ar, ranlib, etc. is preferable to using Toolchain files. The problem is that I&#39;d not only need to wrap these commands, but also change all the CMake configure logic, i.e. all the find_package calls, the CMAKE_SYSTEM_NAME tests, and the check_* calls (luckily there&#39;s only one check_symbol_exists call), and I&#39;m not sure what advantages this has over doing it &quot;the CMake way&quot;. Is the parallelism and the ability to use ninja to rebuild everything without re-invoking CMake really worth all this extra effort? See http://thread.gmane.org/gmane.comp.lang.swift.devel/911 for more details.<br>&gt;&gt; <br>&gt;&gt; Just to be clear, are you suggesting building everything (OSX swiftc, OSX stdlib, Linux stdlib) within a single CMake invocation? Dmitri explained the reasoning behind doing this for Darwin-based targets (i.e. parallelism, fast iteration without re-invoking CMake) , but as mentioned above, I don&#39;t think this works well when mixing different toolchains (elf, mach-o) or headers/libraries (e.g. Linux vs FreeBSD), as you end up having to re-implement a lot of the CMake configure logic either in shell scripts or CMake itself. If multiple CMake invocations are ok, why the aversion to toolchain files?<br>&gt;&gt; <br>&gt;&gt; cheers,<br>&gt;&gt; Tom<br>&gt;&gt; <br>&gt;&gt;&gt; On Tue, Feb 16, 2016 at 10:57 PM Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;&gt; The main reason we didn&#39;t even try to go for the CMake toolchain support is because of the old build/host/target problem. For those who don&#39;t know, in old GCC terminology, the build machine is where you build the compiler, the host machine is where you run the compiler, and the target machine is where you run the code that comes out of the compiler.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right now our CMake project tries to build some binaries for the host machine (the compiler) and some binaries for the target machine (the runtime, standard library, and overlays). On non-Darwin platforms, these are always the same today; for us the host machine is OS X and we build several target standard libraries. CMake really doesn&#39;t like this, which is why a CMake-generated Xcode project still can&#39;t build for iOS, even though Xcode supports products with different platforms perfectly well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So from CMake&#39;s perspective, we&#39;re always building for the host machine, and we pass some funny flags when building the runtime and stdlib. We get away with this because the OS X linker can also link binaries intended for iOS et al.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you&#39;re planning on building a cross-compiler (build = OS X, host = OS X, target = Linux), I think you&#39;d really have the best success by using the same mechanism we use to build multiple stdlibs on Darwin. You&#39;d have to figure out how to trick it into using your linker for just those libraries, but Clang actually does have support for cross-compilation (and CMake should be using Clang to link, I think?) so you should have a chance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 16, 2016, at 13:48 , Tom Birch via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m working on cross-compiling swift using OS X to build a linux-arm runtime/stdlib, and I&#39;ve had some success. My change is here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/froody/swift/commit/bc7ca07c1c7a94a8d07acd635c486388640ee2d2<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Steps to repro are in cmake/modules/Toolchain-linux-arm.cmake<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s still a work in progress, but I wanted to get some feedback on whether or not I&#39;m going in the right direction. Toolchain files are the recommended way for cross-compiling with CMake, but it seems like it doesn&#39;t mesh well with the current system of building multiple mach-o targets from a single CMake invocation (e.g. OS X, iOS, tvOS and watchOS built on OS X). I&#39;ve also had to fight the build-system a lot (using many --skip-build-foo flags, and two invocations of ./utils/build-script) in order to avoid building ninja targets that don&#39;t exist, and I&#39;m wondering if there&#39;s a better way to do this, i.e. to build llvm/clang/swiftc for OS X in llvm-macosx-x86_64/swift-macosx-x86_64 build directories, and use that to build (swiftc?)/stdlib/tests for linux-arm in a swift-linux-armv7 build directory. Maybe this is a good reason to do https://bugs.swift.org/browse/SR-237 first/in parallel?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I also required a change to LLVM:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/froody/swift-llvm/commit/ed54c92943444999f11918f013cca1dba7892da1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; to fix this error:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; CMake Error: The inter-target dependency graph contains the following strongly connected component (cycle):<br>&gt;&gt;&gt;&gt;   &quot;NativeLLVMConfig&quot; of type UTILITY<br>&gt;&gt;&gt;&gt;     depends on &quot;llvm-config&quot; (strong)<br>&gt;&gt;&gt;&gt;   &quot;llvm-config&quot; of type EXECUTABLE<br>&gt;&gt;&gt;&gt;     depends on &quot;NativeLLVMConfig&quot; (strong)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Maybe Chris Bieneman has an idea about this? I seemed to successfully cross-compile with the &quot;False AND&quot; hack, not sure what&#39;s going on.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Anyway, I&#39;d appreciate any feedback on the direction/next steps.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; cheers,<br>&gt;&gt;&gt;&gt; Tom<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160315/93a1bd3e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
