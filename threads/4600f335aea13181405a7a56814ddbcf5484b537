<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>June 23, 2016 at 09:00:00pm</p></header><div class="content"><p>Max Moiseev via swift-evolution &lt;swift-evolution at ...&gt; writes:<br></p><p>&gt; &gt; For FixedWidthInteger#dividedWithOverflow/remainderWithOverflow, under<br>what situations would<br>&gt; you have an overflow? I could only come up with something like<br>Int.min.dividedWithOverflow(-1).<br>&gt; If you look at the prototype here:<br>&gt;<br>https://github.com/apple/swift/blob/master/test/Prototypes<br>/Integers.swift.gyb#L789<br>&gt; there is<br>&gt; exactly the check that you’ve mentioned, but for all signed integers.<br>Besides, it is very convenient to<br>&gt; have all the arithmetic operations be implemented the same way, even if<br>there were no real overflows for division.<br></p><p>I agree with this for the four basic operations, but not for the remainder<br>operation.<br></p><p>By definition, the remainder is always strictly smaller (in absolute value)<br>than the divisor, so even if the division itself overflows, the remainder<br>must be representable, so technically it never overflow.<br></p><p>In the only actual case where the division overflow, that is Int.min / -1,<br>the remainder is simply 0.<br></p><p>For these reasons, I think it would make sense to explicitly request that<br>the remainder operation never traps, and remove the overflow variants.<br></p><p>Nicola<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c53218a6524f4d644b6a75a4441ea631?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Max Moiseev</string> &lt;moiseev at apple.com&gt;<p>June 23, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi Nicola,<br></p><p>&gt; For these reasons, I think it would make sense to explicitly request that<br>&gt; the remainder operation never traps, and remove the overflow variants.<br>It will still trap when you divide by 0. But in that case falling back to the same generic overflow logic is not the best idea.<br>I agree that remainder is special, let me see what I can do about it.<br></p><p>Thanks,<br>Max<br></p><p><br>&gt; On Jun 23, 2016, at 2:38 PM, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Max Moiseev via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt; <br>&gt;&gt;&gt; For FixedWidthInteger#dividedWithOverflow/remainderWithOverflow, under<br>&gt; what situations would<br>&gt;&gt; you have an overflow? I could only come up with something like<br>&gt; Int.min.dividedWithOverflow(-1).<br>&gt;&gt; If you look at the prototype here:<br>&gt;&gt; <br>&gt; https://github.com/apple/swift/blob/master/test/Prototypes<br>&gt; /Integers.swift.gyb#L789<br>&gt;&gt; there is<br>&gt;&gt; exactly the check that you’ve mentioned, but for all signed integers.<br>&gt; Besides, it is very convenient to<br>&gt;&gt; have all the arithmetic operations be implemented the same way, even if<br>&gt; there were no real overflows for division.<br>&gt; <br>&gt; I agree with this for the four basic operations, but not for the remainder<br>&gt; operation.<br>&gt; <br>&gt; By definition, the remainder is always strictly smaller (in absolute value)<br>&gt; than the divisor, so even if the division itself overflows, the remainder<br>&gt; must be representable, so technically it never overflow.<br>&gt; <br>&gt; In the only actual case where the division overflow, that is Int.min / -1,<br>&gt; the remainder is simply 0.<br>&gt; <br>&gt; For these reasons, I think it would make sense to explicitly request that<br>&gt; the remainder operation never traps, and remove the overflow variants.<br>&gt; <br>&gt; Nicola<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>June 24, 2016 at 08:00:00am</p></header><div class="content"><p>On Fri, Jun 24, 2016 at 12:12 AM, Max Moiseev &lt;moiseev at apple.com&gt; wrote:<br></p><p>&gt; Hi Nicola,<br>&gt;<br>&gt; &gt; For these reasons, I think it would make sense to explicitly request that<br>&gt; &gt; the remainder operation never traps, and remove the overflow variants.<br>&gt; It will still trap when you divide by 0. But in that case falling back to<br>&gt; the same generic overflow logic is not the best idea.<br>&gt; I agree that remainder is special, let me see what I can do about it.<br>&gt;<br>&gt;<br>LOL, yes of course, I forgot about the obvious trapping case.<br></p><p>However, division by 0 isn&#39;t an overflow: it&#39;s an undefined operation. I<br>find it somewhat surprising that dividedWithOverflow/remainderWithOverflow<br>allow attempting this operation.<br></p><p>To me, the intuitive semantics of the WithOverflow methods are &quot;perform the<br>operation, and if the result doesn&#39;t fit in the given type, return a<br>truncated result and an overflow flag&quot;. This is not what happens when<br>dividing by 0, because the result simply doesn&#39;t exist.<br></p><p>I think I would prefer if rhs != 0 was documented as an explicit<br>precondition of the division and remainder operations, and<br>dividedWithOverflow/remainderWithOverflow trapped because of precondition<br>failure.<br></p><p>If it is desirable that the WithOverflow methods never trap, then I think<br>it would be better to add a `divisionByZero` case to the ArithmeticOverflow<br>enum and return that instead of the generic `overflow`.<br></p><p>Thanks,<br>Nicola<br></p><p><br></p><p>&gt; Thanks,<br>&gt; Max<br>&gt;<br>&gt;<br>&gt; &gt; On Jun 23, 2016, at 2:38 PM, Nicola Salmoria via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Max Moiseev via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; For FixedWidthInteger#dividedWithOverflow/remainderWithOverflow, under<br>&gt; &gt; what situations would<br>&gt; &gt;&gt; you have an overflow? I could only come up with something like<br>&gt; &gt; Int.min.dividedWithOverflow(-1).<br>&gt; &gt;&gt; If you look at the prototype here:<br>&gt; &gt;&gt;<br>&gt; &gt; https://github.com/apple/swift/blob/master/test/Prototypes<br>&gt; &gt; /Integers.swift.gyb#L789<br>&gt; &gt;&gt; there is<br>&gt; &gt;&gt; exactly the check that you’ve mentioned, but for all signed integers.<br>&gt; &gt; Besides, it is very convenient to<br>&gt; &gt;&gt; have all the arithmetic operations be implemented the same way, even if<br>&gt; &gt; there were no real overflows for division.<br>&gt; &gt;<br>&gt; &gt; I agree with this for the four basic operations, but not for the<br>&gt; remainder<br>&gt; &gt; operation.<br>&gt; &gt;<br>&gt; &gt; By definition, the remainder is always strictly smaller (in absolute<br>&gt; value)<br>&gt; &gt; than the divisor, so even if the division itself overflows, the remainder<br>&gt; &gt; must be representable, so technically it never overflow.<br>&gt; &gt;<br>&gt; &gt; In the only actual case where the division overflow, that is Int.min /<br>&gt; -1,<br>&gt; &gt; the remainder is simply 0.<br>&gt; &gt;<br>&gt; &gt; For these reasons, I think it would make sense to explicitly request that<br>&gt; &gt; the remainder operation never traps, and remove the overflow variants.<br>&gt; &gt;<br>&gt; &gt; Nicola<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p>On Fri, Jun 24, 2016 at 12:12 AM, Max Moiseev &lt;moiseev at apple.com&gt; wrote:<br></p><p>&gt; Hi Nicola,<br>&gt;<br>&gt; &gt; For these reasons, I think it would make sense to explicitly request that<br>&gt; &gt; the remainder operation never traps, and remove the overflow variants.<br>&gt; It will still trap when you divide by 0. But in that case falling back to<br>&gt; the same generic overflow logic is not the best idea.<br>&gt; I agree that remainder is special, let me see what I can do about it.<br>&gt;<br>&gt; Thanks,<br>&gt; Max<br>&gt;<br>&gt;<br>&gt; &gt; On Jun 23, 2016, at 2:38 PM, Nicola Salmoria via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Max Moiseev via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; For FixedWidthInteger#dividedWithOverflow/remainderWithOverflow, under<br>&gt; &gt; what situations would<br>&gt; &gt;&gt; you have an overflow? I could only come up with something like<br>&gt; &gt; Int.min.dividedWithOverflow(-1).<br>&gt; &gt;&gt; If you look at the prototype here:<br>&gt; &gt;&gt;<br>&gt; &gt; https://github.com/apple/swift/blob/master/test/Prototypes<br>&gt; &gt; /Integers.swift.gyb#L789<br>&gt; &gt;&gt; there is<br>&gt; &gt;&gt; exactly the check that you’ve mentioned, but for all signed integers.<br>&gt; &gt; Besides, it is very convenient to<br>&gt; &gt;&gt; have all the arithmetic operations be implemented the same way, even if<br>&gt; &gt; there were no real overflows for division.<br>&gt; &gt;<br>&gt; &gt; I agree with this for the four basic operations, but not for the<br>&gt; remainder<br>&gt; &gt; operation.<br>&gt; &gt;<br>&gt; &gt; By definition, the remainder is always strictly smaller (in absolute<br>&gt; value)<br>&gt; &gt; than the divisor, so even if the division itself overflows, the remainder<br>&gt; &gt; must be representable, so technically it never overflow.<br>&gt; &gt;<br>&gt; &gt; In the only actual case where the division overflow, that is Int.min /<br>&gt; -1,<br>&gt; &gt; the remainder is simply 0.<br>&gt; &gt;<br>&gt; &gt; For these reasons, I think it would make sense to explicitly request that<br>&gt; &gt; the remainder operation never traps, and remove the overflow variants.<br>&gt; &gt;<br>&gt; &gt; Nicola<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/345fbc51/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 24, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 23:06, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Fri, Jun 24, 2016 at 12:12 AM, Max Moiseev &lt;moiseev at apple.com &lt;mailto:moiseev at apple.com&gt;&gt; wrote:<br>&gt; Hi Nicola,<br>&gt; <br>&gt; &gt; For these reasons, I think it would make sense to explicitly request that<br>&gt; &gt; the remainder operation never traps, and remove the overflow variants.<br>&gt; It will still trap when you divide by 0. But in that case falling back to the same generic overflow logic is not the best idea.<br>&gt; I agree that remainder is special, let me see what I can do about it.<br>&gt; <br>&gt; <br>&gt; LOL, yes of course, I forgot about the obvious trapping case.<br>&gt; <br>&gt; However, division by 0 isn&#39;t an overflow: it&#39;s an undefined operation. I find it somewhat surprising that dividedWithOverflow/remainderWithOverflow allow attempting this operation.<br>&gt; <br>&gt; To me, the intuitive semantics of the WithOverflow methods are &quot;perform the operation, and if the result doesn&#39;t fit in the given type, return a truncated result and an overflow flag&quot;. This is not what happens when dividing by 0, because the result simply doesn&#39;t exist.<br>&gt; <br>&gt; I think I would prefer if rhs != 0 was documented as an explicit precondition of the division and remainder operations, and dividedWithOverflow/remainderWithOverflow trapped because of precondition failure.<br>&gt; <br>&gt; If it is desirable that the WithOverflow methods never trap, then I think it would be better to add a `divisionByZero` case to the ArithmeticOverflow enum and return that instead of the generic `overflow`.<br></p><p>IIUC, the WithOverflow flag is only for the INT_MIN / -1 case. (And IIUC, that doesn&#39;t affect remainder.)<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/46ead481/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c53218a6524f4d644b6a75a4441ea631?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Max Moiseev</string> &lt;moiseev at apple.com&gt;<p>June 24, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; However, division by 0 isn&#39;t an overflow: it&#39;s an undefined operation. I find it somewhat surprising that dividedWithOverflow/remainderWithOverflow allow attempting this operation.<br>I tried to say that in my previous email. I agree that division by zero is NOT the overflow and should probably be handled differently if only for a better error message.<br></p><p>&gt; <br>&gt; To me, the intuitive semantics of the WithOverflow methods are &quot;perform the operation, and if the result doesn&#39;t fit in the given type, return a truncated result and an overflow flag&quot;. This is not what happens when dividing by 0, because the result simply doesn&#39;t exist.<br>&gt; <br>&gt; I think I would prefer if rhs != 0 was documented as an explicit precondition of the division and remainder operations, and dividedWithOverflow/remainderWithOverflow trapped because of precondition failure.<br>That’s exactly how it is implemented in the prototype now.<br></p><p>&gt; If it is desirable that the WithOverflow methods never trap, then I think it would be better to add a `divisionByZero` case to the ArithmeticOverflow enum and return that instead of the generic `overflow`.<br>Nice idea, but I don’t think it is really required that WithOverflow methods should never fail. The main idea behind these methods is to allow for 2 versions of arithmetic operations: one that traps on overflow and an unsafe one, that simply discards the overflow flag returning the partial result. Both of these however should, in my opinion, trap in a truly exceptional case of division by 0.<br></p><p>Thanks for your comments, Nicola!<br></p><p>Max<br></p><p>&gt; On Jun 23, 2016, at 11:06 PM, Nicola Salmoria &lt;nicola.salmoria at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Fri, Jun 24, 2016 at 12:12 AM, Max Moiseev &lt;moiseev at apple.com &lt;mailto:moiseev at apple.com&gt;&gt; wrote:<br>&gt; Hi Nicola,<br>&gt; <br>&gt; &gt; For these reasons, I think it would make sense to explicitly request that<br>&gt; &gt; the remainder operation never traps, and remove the overflow variants.<br>&gt; It will still trap when you divide by 0. But in that case falling back to the same generic overflow logic is not the best idea.<br>&gt; I agree that remainder is special, let me see what I can do about it.<br>&gt; <br>&gt; <br>&gt; LOL, yes of course, I forgot about the obvious trapping case.<br>&gt; <br>&gt; However, division by 0 isn&#39;t an overflow: it&#39;s an undefined operation. I find it somewhat surprising that dividedWithOverflow/remainderWithOverflow allow attempting this operation.<br>&gt; <br>&gt; To me, the intuitive semantics of the WithOverflow methods are &quot;perform the operation, and if the result doesn&#39;t fit in the given type, return a truncated result and an overflow flag&quot;. This is not what happens when dividing by 0, because the result simply doesn&#39;t exist.<br>&gt; <br>&gt; I think I would prefer if rhs != 0 was documented as an explicit precondition of the division and remainder operations, and dividedWithOverflow/remainderWithOverflow trapped because of precondition failure.<br>&gt; <br>&gt; If it is desirable that the WithOverflow methods never trap, then I think it would be better to add a `divisionByZero` case to the ArithmeticOverflow enum and return that instead of the generic `overflow`.<br>&gt; <br>&gt; Thanks,<br>&gt; Nicola<br>&gt; <br>&gt;  <br>&gt; Thanks,<br>&gt; Max<br>&gt; <br>&gt; <br>&gt; &gt; On Jun 23, 2016, at 2:38 PM, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Max Moiseev via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; For FixedWidthInteger#dividedWithOverflow/remainderWithOverflow, under<br>&gt; &gt; what situations would<br>&gt; &gt;&gt; you have an overflow? I could only come up with something like<br>&gt; &gt; Int.min.dividedWithOverflow(-1).<br>&gt; &gt;&gt; If you look at the prototype here:<br>&gt; &gt;&gt;<br>&gt; &gt; https://github.com/apple/swift/blob/master/test/Prototypes &lt;https://github.com/apple/swift/blob/master/test/Prototypes&gt;<br>&gt; &gt; /Integers.swift.gyb#L789<br>&gt; &gt;&gt; there is<br>&gt; &gt;&gt; exactly the check that you’ve mentioned, but for all signed integers.<br>&gt; &gt; Besides, it is very convenient to<br>&gt; &gt;&gt; have all the arithmetic operations be implemented the same way, even if<br>&gt; &gt; there were no real overflows for division.<br>&gt; &gt;<br>&gt; &gt; I agree with this for the four basic operations, but not for the remainder<br>&gt; &gt; operation.<br>&gt; &gt;<br>&gt; &gt; By definition, the remainder is always strictly smaller (in absolute value)<br>&gt; &gt; than the divisor, so even if the division itself overflows, the remainder<br>&gt; &gt; must be representable, so technically it never overflow.<br>&gt; &gt;<br>&gt; &gt; In the only actual case where the division overflow, that is Int.min / -1,<br>&gt; &gt; the remainder is simply 0.<br>&gt; &gt;<br>&gt; &gt; For these reasons, I think it would make sense to explicitly request that<br>&gt; &gt; the remainder operation never traps, and remove the overflow variants.<br>&gt; &gt;<br>&gt; &gt; Nicola<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Fri, Jun 24, 2016 at 12:12 AM, Max Moiseev &lt;moiseev at apple.com &lt;mailto:moiseev at apple.com&gt;&gt; wrote:<br>&gt; Hi Nicola,<br>&gt; <br>&gt; &gt; For these reasons, I think it would make sense to explicitly request that<br>&gt; &gt; the remainder operation never traps, and remove the overflow variants.<br>&gt; It will still trap when you divide by 0. But in that case falling back to the same generic overflow logic is not the best idea.<br>&gt; I agree that remainder is special, let me see what I can do about it.<br>&gt; <br>&gt; Thanks,<br>&gt; Max<br>&gt; <br>&gt; <br>&gt; &gt; On Jun 23, 2016, at 2:38 PM, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Max Moiseev via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; For FixedWidthInteger#dividedWithOverflow/remainderWithOverflow, under<br>&gt; &gt; what situations would<br>&gt; &gt;&gt; you have an overflow? I could only come up with something like<br>&gt; &gt; Int.min.dividedWithOverflow(-1).<br>&gt; &gt;&gt; If you look at the prototype here:<br>&gt; &gt;&gt;<br>&gt; &gt; https://github.com/apple/swift/blob/master/test/Prototypes &lt;https://github.com/apple/swift/blob/master/test/Prototypes&gt;<br>&gt; &gt; /Integers.swift.gyb#L789<br>&gt; &gt;&gt; there is<br>&gt; &gt;&gt; exactly the check that you’ve mentioned, but for all signed integers.<br>&gt; &gt; Besides, it is very convenient to<br>&gt; &gt;&gt; have all the arithmetic operations be implemented the same way, even if<br>&gt; &gt; there were no real overflows for division.<br>&gt; &gt;<br>&gt; &gt; I agree with this for the four basic operations, but not for the remainder<br>&gt; &gt; operation.<br>&gt; &gt;<br>&gt; &gt; By definition, the remainder is always strictly smaller (in absolute value)<br>&gt; &gt; than the divisor, so even if the division itself overflows, the remainder<br>&gt; &gt; must be representable, so technically it never overflow.<br>&gt; &gt;<br>&gt; &gt; In the only actual case where the division overflow, that is Int.min / -1,<br>&gt; &gt; the remainder is simply 0.<br>&gt; &gt;<br>&gt; &gt; For these reasons, I think it would make sense to explicitly request that<br>&gt; &gt; the remainder operation never traps, and remove the overflow variants.<br>&gt; &gt;<br>&gt; &gt; Nicola<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/62e10a01/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>June 25, 2016 at 12:00:00am</p></header><div class="content"><p>On Fri, Jun 24, 2016 at 11:45 PM, Max Moiseev &lt;moiseev at apple.com&gt; wrote:<br></p><p>&gt; However, division by 0 isn&#39;t an overflow: it&#39;s an undefined operation. I<br>&gt; find it somewhat surprising that dividedWithOverflow/remainderWithOverflow<br>&gt; allow attempting this operation.<br>&gt;<br>&gt; I tried to say that in my previous email. I agree that division by zero is<br>&gt; NOT the overflow and should probably be handled differently if only for a<br>&gt; better error message.<br>&gt;<br>&gt;<br>&gt; To me, the intuitive semantics of the WithOverflow methods are &quot;perform<br>&gt; the operation, and if the result doesn&#39;t fit in the given type, return a<br>&gt; truncated result and an overflow flag&quot;. This is not what happens when<br>&gt; dividing by 0, because the result simply doesn&#39;t exist.<br>&gt;<br>&gt; I think I would prefer if rhs != 0 was documented as an explicit<br>&gt; precondition of the division and remainder operations, and<br>&gt; dividedWithOverflow/remainderWithOverflow trapped because of precondition<br>&gt; failure.<br>&gt;<br>&gt; That’s exactly how it is implemented in the prototype now.<br>&gt;<br></p><p>Now I&#39;m confused. Isn&#39;t this line of the gyb returning .overflow when the<br>divisor is 0?<br>https://github.com/apple/swift/blob/master/test/Prototypes/Integers.swift.gyb#L793<br></p><p>Also, the current version of Swift doesn&#39;t trap either:<br>let z = 0<br>print(Int.divideWithOverflow(1, z))    // (0, true)<br>print(Int.remainderWithOverflow(1, z))    // (0, true)<br></p><p>interestingly, you need to put 0 in a variable otherwise the compiler<br>rejects the lines.<br></p><p><br>&gt;<br>&gt; If it is desirable that the WithOverflow methods never trap, then I think<br>&gt; it would be better to add a `divisionByZero` case to the ArithmeticOverflow<br>&gt; enum and return that instead of the generic `overflow`.<br>&gt;<br>&gt; Nice idea, but I don’t think it is really required that WithOverflow<br>&gt; methods should never fail. The main idea behind these methods is to allow<br>&gt; for 2 versions of arithmetic operations: one that traps on overflow and an<br>&gt; unsafe one, that simply discards the overflow flag returning the partial<br>&gt; result. Both of these however should, in my opinion, trap in a truly<br>&gt; exceptional case of division by 0.<br>&gt;<br></p><p>That would be my preference too. Thanks!<br></p><p>Nicola<br></p><p><br>&gt;<br>&gt; Thanks for your comments, Nicola!<br>&gt;<br>&gt; Max<br>&gt;<br>&gt; On Jun 23, 2016, at 11:06 PM, Nicola Salmoria &lt;nicola.salmoria at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Fri, Jun 24, 2016 at 12:12 AM, Max Moiseev &lt;moiseev at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; Hi Nicola,<br>&gt;&gt;<br>&gt;&gt; &gt; For these reasons, I think it would make sense to explicitly request<br>&gt;&gt; that<br>&gt;&gt; &gt; the remainder operation never traps, and remove the overflow variants.<br>&gt;&gt; It will still trap when you divide by 0. But in that case falling back to<br>&gt;&gt; the same generic overflow logic is not the best idea.<br>&gt;&gt; I agree that remainder is special, let me see what I can do about it.<br>&gt;&gt;<br>&gt;&gt;<br>&gt; LOL, yes of course, I forgot about the obvious trapping case.<br>&gt;<br>&gt; However, division by 0 isn&#39;t an overflow: it&#39;s an undefined operation. I<br>&gt; find it somewhat surprising that dividedWithOverflow/remainderWithOverflow<br>&gt; allow attempting this operation.<br>&gt;<br>&gt; To me, the intuitive semantics of the WithOverflow methods are &quot;perform<br>&gt; the operation, and if the result doesn&#39;t fit in the given type, return a<br>&gt; truncated result and an overflow flag&quot;. This is not what happens when<br>&gt; dividing by 0, because the result simply doesn&#39;t exist.<br>&gt;<br>&gt; I think I would prefer if rhs != 0 was documented as an explicit<br>&gt; precondition of the division and remainder operations, and<br>&gt; dividedWithOverflow/remainderWithOverflow trapped because of precondition<br>&gt; failure.<br>&gt;<br>&gt; If it is desirable that the WithOverflow methods never trap, then I think<br>&gt; it would be better to add a `divisionByZero` case to the ArithmeticOverflow<br>&gt; enum and return that instead of the generic `overflow`.<br>&gt;<br>&gt; Thanks,<br>&gt; Nicola<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt; Max<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Jun 23, 2016, at 2:38 PM, Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Max Moiseev via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; For FixedWidthInteger#dividedWithOverflow/remainderWithOverflow, under<br>&gt;&gt; &gt; what situations would<br>&gt;&gt; &gt;&gt; you have an overflow? I could only come up with something like<br>&gt;&gt; &gt; Int.min.dividedWithOverflow(-1).<br>&gt;&gt; &gt;&gt; If you look at the prototype here:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt; https://github.com/apple/swift/blob/master/test/Prototypes<br>&gt;&gt; &gt; /Integers.swift.gyb#L789<br>&gt;&gt; &gt;&gt; there is<br>&gt;&gt; &gt;&gt; exactly the check that you’ve mentioned, but for all signed integers.<br>&gt;&gt; &gt; Besides, it is very convenient to<br>&gt;&gt; &gt;&gt; have all the arithmetic operations be implemented the same way, even if<br>&gt;&gt; &gt; there were no real overflows for division.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I agree with this for the four basic operations, but not for the<br>&gt;&gt; remainder<br>&gt;&gt; &gt; operation.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; By definition, the remainder is always strictly smaller (in absolute<br>&gt;&gt; value)<br>&gt;&gt; &gt; than the divisor, so even if the division itself overflows, the<br>&gt;&gt; remainder<br>&gt;&gt; &gt; must be representable, so technically it never overflow.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In the only actual case where the division overflow, that is Int.min /<br>&gt;&gt; -1,<br>&gt;&gt; &gt; the remainder is simply 0.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; For these reasons, I think it would make sense to explicitly request<br>&gt;&gt; that<br>&gt;&gt; &gt; the remainder operation never traps, and remove the overflow variants.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Nicola<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; On Fri, Jun 24, 2016 at 12:12 AM, Max Moiseev &lt;moiseev at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; Hi Nicola,<br>&gt;&gt;<br>&gt;&gt; &gt; For these reasons, I think it would make sense to explicitly request<br>&gt;&gt; that<br>&gt;&gt; &gt; the remainder operation never traps, and remove the overflow variants.<br>&gt;&gt; It will still trap when you divide by 0. But in that case falling back to<br>&gt;&gt; the same generic overflow logic is not the best idea.<br>&gt;&gt; I agree that remainder is special, let me see what I can do about it.<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt; Max<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Jun 23, 2016, at 2:38 PM, Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Max Moiseev via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; For FixedWidthInteger#dividedWithOverflow/remainderWithOverflow, under<br>&gt;&gt; &gt; what situations would<br>&gt;&gt; &gt;&gt; you have an overflow? I could only come up with something like<br>&gt;&gt; &gt; Int.min.dividedWithOverflow(-1).<br>&gt;&gt; &gt;&gt; If you look at the prototype here:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt; https://github.com/apple/swift/blob/master/test/Prototypes<br>&gt;&gt; &gt; /Integers.swift.gyb#L789<br>&gt;&gt; &gt;&gt; there is<br>&gt;&gt; &gt;&gt; exactly the check that you’ve mentioned, but for all signed integers.<br>&gt;&gt; &gt; Besides, it is very convenient to<br>&gt;&gt; &gt;&gt; have all the arithmetic operations be implemented the same way, even if<br>&gt;&gt; &gt; there were no real overflows for division.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I agree with this for the four basic operations, but not for the<br>&gt;&gt; remainder<br>&gt;&gt; &gt; operation.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; By definition, the remainder is always strictly smaller (in absolute<br>&gt;&gt; value)<br>&gt;&gt; &gt; than the divisor, so even if the division itself overflows, the<br>&gt;&gt; remainder<br>&gt;&gt; &gt; must be representable, so technically it never overflow.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In the only actual case where the division overflow, that is Int.min /<br>&gt;&gt; -1,<br>&gt;&gt; &gt; the remainder is simply 0.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; For these reasons, I think it would make sense to explicitly request<br>&gt;&gt; that<br>&gt;&gt; &gt; the remainder operation never traps, and remove the overflow variants.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Nicola<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160625/8956f101/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 24, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 24, 2016, at 15:03, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Fri, Jun 24, 2016 at 11:45 PM, Max Moiseev &lt;moiseev at apple.com &lt;mailto:moiseev at apple.com&gt;&gt; wrote:<br>&gt;&gt; However, division by 0 isn&#39;t an overflow: it&#39;s an undefined operation. I find it somewhat surprising that dividedWithOverflow/remainderWithOverflow allow attempting this operation.<br>&gt; I tried to say that in my previous email. I agree that division by zero is NOT the overflow and should probably be handled differently if only for a better error message.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; To me, the intuitive semantics of the WithOverflow methods are &quot;perform the operation, and if the result doesn&#39;t fit in the given type, return a truncated result and an overflow flag&quot;. This is not what happens when dividing by 0, because the result simply doesn&#39;t exist.<br>&gt;&gt; <br>&gt;&gt; I think I would prefer if rhs != 0 was documented as an explicit precondition of the division and remainder operations, and dividedWithOverflow/remainderWithOverflow trapped because of precondition failure.<br>&gt; That’s exactly how it is implemented in the prototype now.<br>&gt; <br>&gt; Now I&#39;m confused. Isn&#39;t this line of the gyb returning .overflow when the divisor is 0?<br>&gt; https://github.com/apple/swift/blob/master/test/Prototypes/Integers.swift.gyb#L793 &lt;https://github.com/apple/swift/blob/master/test/Prototypes/Integers.swift.gyb#L793&gt;<br>&gt; <br>&gt; Also, the current version of Swift doesn&#39;t trap either:<br>&gt; let z = 0<br>&gt; print(Int.divideWithOverflow(1, z))    // (0, true)<br>&gt; print(Int.remainderWithOverflow(1, z))    // (0, true)<br>&gt; <br>&gt; interestingly, you need to put 0 in a variable otherwise the compiler rejects the lines.<br></p><p>Huh. My bad for not checking. Yeah, I don&#39;t think dividing by zero and dividing INT_MIN by -1 are the same kind of overflow.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/92e8e295/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c53218a6524f4d644b6a75a4441ea631?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Max Moiseev</string> &lt;moiseev at apple.com&gt;<p>June 24, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Now I&#39;m confused. Isn&#39;t this line of the gyb returning .overflow when the divisor is 0?<br>&gt; https://github.com/apple/swift/blob/master/test/Prototypes/Integers.swift.gyb#L793 &lt;https://github.com/apple/swift/blob/master/test/Prototypes/Integers.swift.gyb#L793&gt;<br></p><p>Sorry. What I meant was “this is how it’s documented”. Not dividing by zero is a precondition.<br></p><p>&gt; Also, the current version of Swift doesn&#39;t trap either:<br>&gt; let z = 0<br>&gt; print(Int.divideWithOverflow(1, z))    // (0, true)<br>&gt; print(Int.remainderWithOverflow(1, z))    // (0, true)<br>https://github.com/apple/swift/blob/master/stdlib/public/core/FixedPoint.swift.gyb#L399<br></p><p>Well, then we’ll be fixing it :-)<br></p><p>&gt; interestingly, you need to put 0 in a variable otherwise the compiler rejects the lines.<br>FWIW: Works in the Swift 3 compiler.<br></p><p><br>&gt; On Jun 24, 2016, at 3:03 PM, Nicola Salmoria &lt;nicola.salmoria at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Fri, Jun 24, 2016 at 11:45 PM, Max Moiseev &lt;moiseev at apple.com &lt;mailto:moiseev at apple.com&gt;&gt; wrote:<br>&gt;&gt; However, division by 0 isn&#39;t an overflow: it&#39;s an undefined operation. I find it somewhat surprising that dividedWithOverflow/remainderWithOverflow allow attempting this operation.<br>&gt; I tried to say that in my previous email. I agree that division by zero is NOT the overflow and should probably be handled differently if only for a better error message.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; To me, the intuitive semantics of the WithOverflow methods are &quot;perform the operation, and if the result doesn&#39;t fit in the given type, return a truncated result and an overflow flag&quot;. This is not what happens when dividing by 0, because the result simply doesn&#39;t exist.<br>&gt;&gt; <br>&gt;&gt; I think I would prefer if rhs != 0 was documented as an explicit precondition of the division and remainder operations, and dividedWithOverflow/remainderWithOverflow trapped because of precondition failure.<br>&gt; That’s exactly how it is implemented in the prototype now.<br>&gt; <br>&gt; Now I&#39;m confused. Isn&#39;t this line of the gyb returning .overflow when the divisor is 0?<br>&gt; https://github.com/apple/swift/blob/master/test/Prototypes/Integers.swift.gyb#L793 &lt;https://github.com/apple/swift/blob/master/test/Prototypes/Integers.swift.gyb#L793&gt;<br>&gt; <br>&gt; Also, the current version of Swift doesn&#39;t trap either:<br>&gt; let z = 0<br>&gt; print(Int.divideWithOverflow(1, z))    // (0, true)<br>&gt; print(Int.remainderWithOverflow(1, z))    // (0, true)<br>&gt; <br>&gt; interestingly, you need to put 0 in a variable otherwise the compiler rejects the lines.<br>&gt;  <br>&gt; <br>&gt;&gt; If it is desirable that the WithOverflow methods never trap, then I think it would be better to add a `divisionByZero` case to the ArithmeticOverflow enum and return that instead of the generic `overflow`.<br>&gt; Nice idea, but I don’t think it is really required that WithOverflow methods should never fail. The main idea behind these methods is to allow for 2 versions of arithmetic operations: one that traps on overflow and an unsafe one, that simply discards the overflow flag returning the partial result. Both of these however should, in my opinion, trap in a truly exceptional case of division by 0.<br>&gt; <br>&gt; That would be my preference too. Thanks!<br>&gt; <br>&gt; Nicola<br>&gt;  <br>&gt; <br>&gt; Thanks for your comments, Nicola!<br>&gt; <br>&gt; Max<br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 11:06 PM, Nicola Salmoria &lt;nicola.salmoria at gmail.com &lt;mailto:nicola.salmoria at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Fri, Jun 24, 2016 at 12:12 AM, Max Moiseev &lt;moiseev at apple.com &lt;mailto:moiseev at apple.com&gt;&gt; wrote:<br>&gt;&gt; Hi Nicola,<br>&gt;&gt; <br>&gt;&gt; &gt; For these reasons, I think it would make sense to explicitly request that<br>&gt;&gt; &gt; the remainder operation never traps, and remove the overflow variants.<br>&gt;&gt; It will still trap when you divide by 0. But in that case falling back to the same generic overflow logic is not the best idea.<br>&gt;&gt; I agree that remainder is special, let me see what I can do about it.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; LOL, yes of course, I forgot about the obvious trapping case.<br>&gt;&gt; <br>&gt;&gt; However, division by 0 isn&#39;t an overflow: it&#39;s an undefined operation. I find it somewhat surprising that dividedWithOverflow/remainderWithOverflow allow attempting this operation.<br>&gt;&gt; <br>&gt;&gt; To me, the intuitive semantics of the WithOverflow methods are &quot;perform the operation, and if the result doesn&#39;t fit in the given type, return a truncated result and an overflow flag&quot;. This is not what happens when dividing by 0, because the result simply doesn&#39;t exist.<br>&gt;&gt; <br>&gt;&gt; I think I would prefer if rhs != 0 was documented as an explicit precondition of the division and remainder operations, and dividedWithOverflow/remainderWithOverflow trapped because of precondition failure.<br>&gt;&gt; <br>&gt;&gt; If it is desirable that the WithOverflow methods never trap, then I think it would be better to add a `divisionByZero` case to the ArithmeticOverflow enum and return that instead of the generic `overflow`.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Nicola<br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; Thanks,<br>&gt;&gt; Max<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; On Jun 23, 2016, at 2:38 PM, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Max Moiseev via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; For FixedWidthInteger#dividedWithOverflow/remainderWithOverflow, under<br>&gt;&gt; &gt; what situations would<br>&gt;&gt; &gt;&gt; you have an overflow? I could only come up with something like<br>&gt;&gt; &gt; Int.min.dividedWithOverflow(-1).<br>&gt;&gt; &gt;&gt; If you look at the prototype here:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt; https://github.com/apple/swift/blob/master/test/Prototypes &lt;https://github.com/apple/swift/blob/master/test/Prototypes&gt;<br>&gt;&gt; &gt; /Integers.swift.gyb#L789<br>&gt;&gt; &gt;&gt; there is<br>&gt;&gt; &gt;&gt; exactly the check that you’ve mentioned, but for all signed integers.<br>&gt;&gt; &gt; Besides, it is very convenient to<br>&gt;&gt; &gt;&gt; have all the arithmetic operations be implemented the same way, even if<br>&gt;&gt; &gt; there were no real overflows for division.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I agree with this for the four basic operations, but not for the remainder<br>&gt;&gt; &gt; operation.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; By definition, the remainder is always strictly smaller (in absolute value)<br>&gt;&gt; &gt; than the divisor, so even if the division itself overflows, the remainder<br>&gt;&gt; &gt; must be representable, so technically it never overflow.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In the only actual case where the division overflow, that is Int.min / -1,<br>&gt;&gt; &gt; the remainder is simply 0.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; For these reasons, I think it would make sense to explicitly request that<br>&gt;&gt; &gt; the remainder operation never traps, and remove the overflow variants.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Nicola<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Fri, Jun 24, 2016 at 12:12 AM, Max Moiseev &lt;moiseev at apple.com &lt;mailto:moiseev at apple.com&gt;&gt; wrote:<br>&gt;&gt; Hi Nicola,<br>&gt;&gt; <br>&gt;&gt; &gt; For these reasons, I think it would make sense to explicitly request that<br>&gt;&gt; &gt; the remainder operation never traps, and remove the overflow variants.<br>&gt;&gt; It will still trap when you divide by 0. But in that case falling back to the same generic overflow logic is not the best idea.<br>&gt;&gt; I agree that remainder is special, let me see what I can do about it.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Max<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; On Jun 23, 2016, at 2:38 PM, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Max Moiseev via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; For FixedWidthInteger#dividedWithOverflow/remainderWithOverflow, under<br>&gt;&gt; &gt; what situations would<br>&gt;&gt; &gt;&gt; you have an overflow? I could only come up with something like<br>&gt;&gt; &gt; Int.min.dividedWithOverflow(-1).<br>&gt;&gt; &gt;&gt; If you look at the prototype here:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt; https://github.com/apple/swift/blob/master/test/Prototypes &lt;https://github.com/apple/swift/blob/master/test/Prototypes&gt;<br>&gt;&gt; &gt; /Integers.swift.gyb#L789<br>&gt;&gt; &gt;&gt; there is<br>&gt;&gt; &gt;&gt; exactly the check that you’ve mentioned, but for all signed integers.<br>&gt;&gt; &gt; Besides, it is very convenient to<br>&gt;&gt; &gt;&gt; have all the arithmetic operations be implemented the same way, even if<br>&gt;&gt; &gt; there were no real overflows for division.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I agree with this for the four basic operations, but not for the remainder<br>&gt;&gt; &gt; operation.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; By definition, the remainder is always strictly smaller (in absolute value)<br>&gt;&gt; &gt; than the divisor, so even if the division itself overflows, the remainder<br>&gt;&gt; &gt; must be representable, so technically it never overflow.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In the only actual case where the division overflow, that is Int.min / -1,<br>&gt;&gt; &gt; the remainder is simply 0.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; For these reasons, I think it would make sense to explicitly request that<br>&gt;&gt; &gt; the remainder operation never traps, and remove the overflow variants.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Nicola<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/c8416e64/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Review] SE-0104: Protocol-oriented integers</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 23, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 14:38, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Max Moiseev via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt; <br>&gt;&gt;&gt; For FixedWidthInteger#dividedWithOverflow/remainderWithOverflow, under<br>&gt; what situations would<br>&gt;&gt; you have an overflow? I could only come up with something like<br>&gt; Int.min.dividedWithOverflow(-1).<br>&gt;&gt; If you look at the prototype here:<br>&gt;&gt; <br>&gt; https://github.com/apple/swift/blob/master/test/Prototypes<br>&gt; /Integers.swift.gyb#L789<br>&gt;&gt; there is<br>&gt;&gt; exactly the check that you’ve mentioned, but for all signed integers.<br>&gt; Besides, it is very convenient to<br>&gt;&gt; have all the arithmetic operations be implemented the same way, even if<br>&gt; there were no real overflows for division.<br>&gt; <br>&gt; I agree with this for the four basic operations, but not for the remainder<br>&gt; operation.<br>&gt; <br>&gt; By definition, the remainder is always strictly smaller (in absolute value)<br>&gt; than the divisor, so even if the division itself overflows, the remainder<br>&gt; must be representable, so technically it never overflow.<br>&gt; <br>&gt; In the only actual case where the division overflow, that is Int.min / -1,<br>&gt; the remainder is simply 0.<br>&gt; <br>&gt; For these reasons, I think it would make sense to explicitly request that<br>&gt; the remainder operation never traps, and remove the overflow variants.<br></p><p>…except when taking a remainder dividing by 0, right?<br></p><p>Jordan<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
