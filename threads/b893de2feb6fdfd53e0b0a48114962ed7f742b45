<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal draft] Introducing `indexed()` collections</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>September 28, 2016 at 11:00:00am</p></header><div class="content"><p>Gist here: https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2<br></p><p>Introducing indexed() collections<br></p><p>Proposal: TBD<br>Author: Erica Sadun &lt;https://github.com/erica&gt;, Nate Cook &lt;https://github.com/natecook1000&gt;, Jacob Bandes-Storch &lt;https://github.com/jtbandes&gt;, Kevin Ballard &lt;https://github.com/kballard&gt;<br>Status: TBD<br>Review manager: TBD<br> &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#introduction&gt;Introduction<br></p><p>This proposal introduces indexed() to the standard library, a method on collections that returns an (index, element) tuple sequence.<br></p><p>Swift-evolution thread: TBD &lt;https://gist.github.com/erica/tbd&gt;<br> &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#motivation&gt;Motivation<br></p><p>The standard library&#39;s enumerated() method returns a sequence of pairs enumerating a sequence. The pair&#39;s first member is a monotonically incrementing integer starting at zero, and the second member is the corresponding element of the sequence. When working with arrays, the integer is coincidentally the same type and value as an Array index but the enumerated value is not generated with index-specific semantics. This may lead to confusion when developers attempt to subscript a non-array collection with enumerated integers. It can introduce serious bugs when developers use enumerated()-based integer subscripting with non-zero-based array slices.<br></p><p>Indices have a specific, fixed meaning in Swift, which are used to create valid collection subscripts. This proposal introduces indexed() to produce a more semantically relevant sequence by pairing a collection&#39;s indices with its members. While it is trivial to create a solution in Swift, the most common developer approach shown here calculates indexes twice: <br></p><p>extension Collection {<br>    /// Returns a sequence of pairs (*idx*, *x*), where *idx* represents a<br>    /// consecutive collection index, and *x* represents an element of<br>    /// the sequence.<br>    func indexed() -&gt; Zip2Sequence&lt;Self.Indices, Self&gt; {<br>        return zip(indices, self)<br>    }<br>}<br>Incrementing an index in some collections can be unnecessarily costly. In a lazy filtered collection, an index increment is potentially O(N). We feel this is better addressed introducing a new function into the Standard Library to provide a more efficient design that avoids the attractive nuisance of the &quot;obvious&quot; solution.<br></p><p> &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#detailed-design&gt;Detailed Design<br></p><p>Our vision of indexed() bypasses duplicated index generation with their potentially high computation costs. We&#39;d create an iterator that calculates each index once and then applies that index to subscript the collection. Implementation would take place through IndexedSequence, similar to EnumeratedSequence.<br></p><p> &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#impact-on-existing-code&gt;Impact on Existing Code<br></p><p>This proposal is purely additive and has no impact on existing code.<br></p><p> &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#alternatives-considered&gt;Alternatives Considered<br></p><p>Not yet<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/b8932b45/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[Proposal draft] Introducing `indexed()` collections</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>September 28, 2016 at 02:00:00pm</p></header><div class="content"><p>+1, I have been mildly surprised that this was not already present.<br></p><p>My workaround heretofore has been:<br></p><p>for idx in abc.indices {<br>  let val = abc[i]<br>  // do something with idx and val<br>}<br></p><p>Nevin<br></p><p><br>On Wed, Sep 28, 2016 at 1:55 PM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Gist here: https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2<br>&gt;<br>&gt; Introducing indexed() collections<br>&gt;<br>&gt;    - Proposal: TBD<br>&gt;    - Author: Erica Sadun &lt;https://github.com/erica&gt;, Nate Cook<br>&gt;    &lt;https://github.com/natecook1000&gt;, Jacob Bandes-Storch<br>&gt;    &lt;https://github.com/jtbandes&gt;, Kevin Ballard<br>&gt;    &lt;https://github.com/kballard&gt;<br>&gt;    - Status: TBD<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal introduces indexed() to the standard library, a method on<br>&gt; collections that returns an (index, element) tuple sequence.<br>&gt;<br>&gt; Swift-evolution thread: TBD &lt;https://gist.github.com/erica/tbd&gt;<br>&gt; &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; The standard library&#39;s enumerated() method returns a sequence of pairs<br>&gt; enumerating a sequence. The pair&#39;s first member is a monotonically<br>&gt; incrementing integer starting at zero, and the second member is the<br>&gt; corresponding element of the sequence. When working with arrays, the<br>&gt; integer is coincidentally the same type and value as an Array index but<br>&gt; the enumerated value is not generated with index-specific semantics. This<br>&gt; may lead to confusion when developers attempt to subscript a non-array<br>&gt; collection with enumerated integers. It can introduce serious bugs when<br>&gt; developers use enumerated()-based integer subscripting with<br>&gt; non-zero-based array slices.<br>&gt;<br>&gt; Indices have a specific, fixed meaning in Swift, which are used to create<br>&gt; valid collection subscripts. This proposal introduces indexed() to<br>&gt; produce a more semantically relevant sequence by pairing a collection&#39;s<br>&gt; indices with its members. While it is trivial to create a solution in<br>&gt; Swift, the most common developer approach shown here calculates indexes<br>&gt; twice:<br>&gt;<br>&gt; extension Collection {<br>&gt;     /// Returns a sequence of pairs (*idx*, *x*), where *idx* represents a<br>&gt;     /// consecutive collection index, and *x* represents an element of<br>&gt;     /// the sequence.<br>&gt;     func indexed() -&gt; Zip2Sequence&lt;Self.Indices, Self&gt; {<br>&gt;         return zip(indices, self)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Incrementing an index in some collections can be unnecessarily costly. In<br>&gt; a lazy filtered collection, an index increment is potentially O(N). We feel<br>&gt; this is better addressed introducing a new function into the Standard<br>&gt; Library to provide a more efficient design that avoids the attractive<br>&gt; nuisance of the &quot;obvious&quot; solution.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#detailed-design&gt;Detailed<br>&gt; Design<br>&gt;<br>&gt; Our vision of indexed() bypasses duplicated index generation with their<br>&gt; potentially high computation costs. We&#39;d create an iterator that calculates<br>&gt; each index once and then applies that index to subscript the collection.<br>&gt; Implementation would take place through IndexedSequence, similar to<br>&gt; EnumeratedSequence.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; This proposal is purely additive and has no impact on existing code.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt; Not yet<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/e8ebe0f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Proposal draft] Introducing `indexed()` collections</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>September 28, 2016 at 02:00:00pm</p></header><div class="content"><p>+1.  One of those things where you wonder why this wasn&#39;t the default behavior.<br></p><p>~Robert Widmann<br></p><p>2016/09/28 14:23、Nevin Brackett-Rozinsky via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; +1, I have been mildly surprised that this was not already present.<br>&gt; <br>&gt; My workaround heretofore has been:<br>&gt; <br>&gt; for idx in abc.indices {<br>&gt;   let val = abc[i]<br>&gt;   // do something with idx and val<br>&gt; }<br>&gt; <br>&gt; Nevin<br>&gt; <br>&gt; <br>&gt;&gt; On Wed, Sep 28, 2016 at 1:55 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Gist here: https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2<br>&gt;&gt; <br>&gt;&gt; Introducing indexed() collections<br>&gt;&gt; Proposal: TBD<br>&gt;&gt; Author: Erica Sadun, Nate Cook, Jacob Bandes-Storch, Kevin Ballard<br>&gt;&gt; Status: TBD<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal introduces indexed() to the standard library, a method on collections that returns an (index, element) tuple sequence.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: TBD<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; The standard library&#39;s enumerated() method returns a sequence of pairs enumerating a sequence. The pair&#39;s first member is a monotonically incrementing integer starting at zero, and the second member is the corresponding element of the sequence. When working with arrays, the integer is coincidentally the same type and value as an Array index but the enumerated value is not generated with index-specific semantics. This may lead to confusion when developers attempt to subscript a non-array collection with enumerated integers. It can introduce serious bugs when developers use enumerated()-based integer subscripting with non-zero-based array slices.<br>&gt;&gt; <br>&gt;&gt; Indices have a specific, fixed meaning in Swift, which are used to create valid collection subscripts. This proposal introduces indexed() to produce a more semantically relevant sequence by pairing a collection&#39;s indices with its members. While it is trivial to create a solution in Swift, the most common developer approach shown here calculates indexes twice: <br>&gt;&gt; <br>&gt;&gt; extension Collection {<br>&gt;&gt;     /// Returns a sequence of pairs (*idx*, *x*), where *idx* represents a<br>&gt;&gt;     /// consecutive collection index, and *x* represents an element of<br>&gt;&gt;     /// the sequence.<br>&gt;&gt;     func indexed() -&gt; Zip2Sequence&lt;Self.Indices, Self&gt; {<br>&gt;&gt;         return zip(indices, self)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; Incrementing an index in some collections can be unnecessarily costly. In a lazy filtered collection, an index increment is potentially O(N). We feel this is better addressed introducing a new function into the Standard Library to provide a more efficient design that avoids the attractive nuisance of the &quot;obvious&quot; solution.<br>&gt;&gt; <br>&gt;&gt; Detailed Design<br>&gt;&gt; <br>&gt;&gt; Our vision of indexed() bypasses duplicated index generation with their potentially high computation costs. We&#39;d create an iterator that calculates each index once and then applies that index to subscript the collection. Implementation would take place through IndexedSequence, similar to EnumeratedSequence.<br>&gt;&gt; <br>&gt;&gt; Impact on Existing Code<br>&gt;&gt; <br>&gt;&gt; This proposal is purely additive and has no impact on existing code.<br>&gt;&gt; <br>&gt;&gt; Alternatives Considered<br>&gt;&gt; <br>&gt;&gt; Not yet<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/9047d793/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Proposal draft] Introducing `indexed()` collections</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>September 28, 2016 at 01:00:00pm</p></header><div class="content"><p>This might just be me being silly, but is there any way to be able to do something like this instead:<br></p><p>for (index, value) in sequence {<br>}<br></p><p>Maybe by adding another variant of makeIterator() that only differs by the return type or something like that?<br></p><p>I sort of dislike that enumerated() and indexed() would co-exist and potentially lead to really subtle bugs when getting them confused. Obviously removing enumerated() would be a breaking change, though, and maybe it has valuable uses that I’m not really thinking about (although it seems to me that the index/value pair is what you want like, 99% of the time and plenty of people - myself included - have been using the index of enumerated() as an array index even though that’s technically maybe not quite ‘correct&#39;).<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Sep 28, 2016, at 12:55 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Gist here: https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2<br>&gt; <br>&gt; Introducing indexed() collections<br>&gt; <br>&gt; 	• Proposal: TBD<br>&gt; 	• Author: Erica Sadun, Nate Cook, Jacob Bandes-Storch, Kevin Ballard<br>&gt; 	• Status: TBD<br>&gt; 	• Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; This proposal introduces indexed() to the standard library, a method on collections that returns an (index, element) tuple sequence.<br>&gt; <br>&gt; Swift-evolution thread: TBD<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; The standard library&#39;s enumerated() method returns a sequence of pairs enumerating a sequence. The pair&#39;s first member is a monotonically incrementing integer starting at zero, and the second member is the corresponding element of the sequence. When working with arrays, the integer is coincidentally the same type and value as an Array index but the enumerated value is not generated with index-specific semantics. This may lead to confusion when developers attempt to subscript a non-array collection with enumerated integers. It can introduce serious bugs when developers use enumerated()-based integer subscripting with non-zero-based array slices.<br>&gt; <br>&gt; Indices have a specific, fixed meaning in Swift, which are used to create valid collection subscripts. This proposal introduces indexed() to produce a more semantically relevant sequence by pairing a collection&#39;s indices with its members. While it is trivial to create a solution in Swift, the most common developer approach shown here calculates indexes twice: <br>&gt; <br>&gt; extension Collection {<br>&gt;     /// Returns a sequence of pairs (*idx*, *x*), where *idx* represents a<br>&gt;     /// consecutive collection index, and *x* represents an element of<br>&gt;     /// the sequence.<br>&gt;     func indexed() -&gt; Zip2Sequence&lt;Self.Indices, Self&gt; {<br>&gt;         return zip(indices, self)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Incrementing an index in some collections can be unnecessarily costly. In a lazy filtered collection, an index increment is potentially O(N). We feel this is better addressed introducing a new function into the Standard Library to provide a more efficient design that avoids the attractive nuisance of the &quot;obvious&quot; solution.<br>&gt; <br>&gt; Detailed Design<br>&gt; <br>&gt; Our vision of indexed() bypasses duplicated index generation with their potentially high computation costs. We&#39;d create an iterator that calculates each index once and then applies that index to subscript the collection. Implementation would take place through IndexedSequence, similar to EnumeratedSequence.<br>&gt; <br>&gt; Impact on Existing Code<br>&gt; <br>&gt; This proposal is purely additive and has no impact on existing code.<br>&gt; <br>&gt; Alternatives Considered<br>&gt; <br>&gt; Not yet<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>[Proposal draft] Introducing `indexed()` collections</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>September 28, 2016 at 07:00:00pm</p></header><div class="content"><p>One (potentially dumb) question...<br></p><p>If the actual indices are needed inside the loop, presumably this means<br>they will be used in the loop, perhaps to mutate it, and if the collection<br>is mutated won&#39;t that either invalidate (or change the relative<br>correspondence of) the others indices, because the collection accessed in<br>the loop will be the mutated one whereas the indices refer to the copy that<br>was taken at the start when the &#39;for&#39; statement was evaluated?<br></p><p><br></p><p>On Wed, 28 Sep 2016 at 19:34 Sean Heber via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This might just be me being silly, but is there any way to be able to do<br>&gt; something like this instead:<br>&gt;<br>&gt; for (index, value) in sequence {<br>&gt; }<br>&gt;<br>&gt; Maybe by adding another variant of makeIterator() that only differs by the<br>&gt; return type or something like that?<br>&gt;<br>&gt; I sort of dislike that enumerated() and indexed() would co-exist and<br>&gt; potentially lead to really subtle bugs when getting them confused.<br>&gt; Obviously removing enumerated() would be a breaking change, though, and<br>&gt; maybe it has valuable uses that I’m not really thinking about (although it<br>&gt; seems to me that the index/value pair is what you want like, 99% of the<br>&gt; time and plenty of people - myself included - have been using the index of<br>&gt; enumerated() as an array index even though that’s technically maybe not<br>&gt; quite ‘correct&#39;).<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt;<br>&gt; &gt; On Sep 28, 2016, at 12:55 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Gist here:<br>&gt; https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2<br>&gt; &gt;<br>&gt; &gt; Introducing indexed() collections<br>&gt; &gt;<br>&gt; &gt;       • Proposal: TBD<br>&gt; &gt;       • Author: Erica Sadun, Nate Cook, Jacob Bandes-Storch, Kevin<br>&gt; Ballard<br>&gt; &gt;       • Status: TBD<br>&gt; &gt;       • Review manager: TBD<br>&gt; &gt; Introduction<br>&gt; &gt;<br>&gt; &gt; This proposal introduces indexed() to the standard library, a method on<br>&gt; collections that returns an (index, element) tuple sequence.<br>&gt; &gt;<br>&gt; &gt; Swift-evolution thread: TBD<br>&gt; &gt;<br>&gt; &gt; Motivation<br>&gt; &gt;<br>&gt; &gt; The standard library&#39;s enumerated() method returns a sequence of pairs<br>&gt; enumerating a sequence. The pair&#39;s first member is a monotonically<br>&gt; incrementing integer starting at zero, and the second member is the<br>&gt; corresponding element of the sequence. When working with arrays, the<br>&gt; integer is coincidentally the same type and value as an Array index but the<br>&gt; enumerated value is not generated with index-specific semantics. This may<br>&gt; lead to confusion when developers attempt to subscript a non-array<br>&gt; collection with enumerated integers. It can introduce serious bugs when<br>&gt; developers use enumerated()-based integer subscripting with non-zero-based<br>&gt; array slices.<br>&gt; &gt;<br>&gt; &gt; Indices have a specific, fixed meaning in Swift, which are used to<br>&gt; create valid collection subscripts. This proposal introduces indexed() to<br>&gt; produce a more semantically relevant sequence by pairing a collection&#39;s<br>&gt; indices with its members. While it is trivial to create a solution in<br>&gt; Swift, the most common developer approach shown here calculates indexes<br>&gt; twice:<br>&gt; &gt;<br>&gt; &gt; extension Collection {<br>&gt; &gt;     /// Returns a sequence of pairs (*idx*, *x*), where *idx* represents<br>&gt; a<br>&gt; &gt;     /// consecutive collection index, and *x* represents an element of<br>&gt; &gt;     /// the sequence.<br>&gt; &gt;     func indexed() -&gt; Zip2Sequence&lt;Self.Indices, Self&gt; {<br>&gt; &gt;         return zip(indices, self)<br>&gt; &gt;     }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Incrementing an index in some collections can be unnecessarily costly.<br>&gt; In a lazy filtered collection, an index increment is potentially O(N). We<br>&gt; feel this is better addressed introducing a new function into the Standard<br>&gt; Library to provide a more efficient design that avoids the attractive<br>&gt; nuisance of the &quot;obvious&quot; solution.<br>&gt; &gt;<br>&gt; &gt; Detailed Design<br>&gt; &gt;<br>&gt; &gt; Our vision of indexed() bypasses duplicated index generation with their<br>&gt; potentially high computation costs. We&#39;d create an iterator that calculates<br>&gt; each index once and then applies that index to subscript the collection.<br>&gt; Implementation would take place through IndexedSequence, similar to<br>&gt; EnumeratedSequence.<br>&gt; &gt;<br>&gt; &gt; Impact on Existing Code<br>&gt; &gt;<br>&gt; &gt; This proposal is purely additive and has no impact on existing code.<br>&gt; &gt;<br>&gt; &gt; Alternatives Considered<br>&gt; &gt;<br>&gt; &gt; Not yet<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/ae567ab1/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[Proposal draft] Introducing `indexed()` collections</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>September 28, 2016 at 06:00:00pm</p></header><div class="content"><p>I like Sean’s idea.<br></p><p>Nevin<br></p><p>On Wed, Sep 28, 2016 at 2:34 PM, Sean Heber via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This might just be me being silly, but is there any way to be able to do<br>&gt; something like this instead:<br>&gt;<br>&gt; for (index, value) in sequence {<br>&gt; }<br>&gt;<br>&gt; Maybe by adding another variant of makeIterator() that only differs by the<br>&gt; return type or something like that?<br>&gt;<br>&gt; I sort of dislike that enumerated() and indexed() would co-exist and<br>&gt; potentially lead to really subtle bugs when getting them confused.<br>&gt; Obviously removing enumerated() would be a breaking change, though, and<br>&gt; maybe it has valuable uses that I’m not really thinking about (although it<br>&gt; seems to me that the index/value pair is what you want like, 99% of the<br>&gt; time and plenty of people - myself included - have been using the index of<br>&gt; enumerated() as an array index even though that’s technically maybe not<br>&gt; quite ‘correct&#39;).<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt;<br>&gt; &gt; On Sep 28, 2016, at 12:55 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Gist here: https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3<br>&gt; f2<br>&gt; &gt;<br>&gt; &gt; Introducing indexed() collections<br>&gt; &gt;<br>&gt; &gt;       • Proposal: TBD<br>&gt; &gt;       • Author: Erica Sadun, Nate Cook, Jacob Bandes-Storch, Kevin<br>&gt; Ballard<br>&gt; &gt;       • Status: TBD<br>&gt; &gt;       • Review manager: TBD<br>&gt; &gt; Introduction<br>&gt; &gt;<br>&gt; &gt; This proposal introduces indexed() to the standard library, a method on<br>&gt; collections that returns an (index, element) tuple sequence.<br>&gt; &gt;<br>&gt; &gt; Swift-evolution thread: TBD<br>&gt; &gt;<br>&gt; &gt; Motivation<br>&gt; &gt;<br>&gt; &gt; The standard library&#39;s enumerated() method returns a sequence of pairs<br>&gt; enumerating a sequence. The pair&#39;s first member is a monotonically<br>&gt; incrementing integer starting at zero, and the second member is the<br>&gt; corresponding element of the sequence. When working with arrays, the<br>&gt; integer is coincidentally the same type and value as an Array index but the<br>&gt; enumerated value is not generated with index-specific semantics. This may<br>&gt; lead to confusion when developers attempt to subscript a non-array<br>&gt; collection with enumerated integers. It can introduce serious bugs when<br>&gt; developers use enumerated()-based integer subscripting with non-zero-based<br>&gt; array slices.<br>&gt; &gt;<br>&gt; &gt; Indices have a specific, fixed meaning in Swift, which are used to<br>&gt; create valid collection subscripts. This proposal introduces indexed() to<br>&gt; produce a more semantically relevant sequence by pairing a collection&#39;s<br>&gt; indices with its members. While it is trivial to create a solution in<br>&gt; Swift, the most common developer approach shown here calculates indexes<br>&gt; twice:<br>&gt; &gt;<br>&gt; &gt; extension Collection {<br>&gt; &gt;     /// Returns a sequence of pairs (*idx*, *x*), where *idx* represents<br>&gt; a<br>&gt; &gt;     /// consecutive collection index, and *x* represents an element of<br>&gt; &gt;     /// the sequence.<br>&gt; &gt;     func indexed() -&gt; Zip2Sequence&lt;Self.Indices, Self&gt; {<br>&gt; &gt;         return zip(indices, self)<br>&gt; &gt;     }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Incrementing an index in some collections can be unnecessarily costly.<br>&gt; In a lazy filtered collection, an index increment is potentially O(N). We<br>&gt; feel this is better addressed introducing a new function into the Standard<br>&gt; Library to provide a more efficient design that avoids the attractive<br>&gt; nuisance of the &quot;obvious&quot; solution.<br>&gt; &gt;<br>&gt; &gt; Detailed Design<br>&gt; &gt;<br>&gt; &gt; Our vision of indexed() bypasses duplicated index generation with their<br>&gt; potentially high computation costs. We&#39;d create an iterator that calculates<br>&gt; each index once and then applies that index to subscript the collection.<br>&gt; Implementation would take place through IndexedSequence, similar to<br>&gt; EnumeratedSequence.<br>&gt; &gt;<br>&gt; &gt; Impact on Existing Code<br>&gt; &gt;<br>&gt; &gt; This proposal is purely additive and has no impact on existing code.<br>&gt; &gt;<br>&gt; &gt; Alternatives Considered<br>&gt; &gt;<br>&gt; &gt; Not yet<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/128625a8/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Proposal draft] Introducing `indexed()` collections</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>September 28, 2016 at 04:00:00pm</p></header><div class="content"><p>+1 to have something *like* this, but a few questions.<br></p><p>Is there a specific reason `IndexedSequence` isn’t `IndexedCollection`, conforming to `Collection` (and once conditional conformances are available picking up `BidirectionalCollection` and `RandomAccessCollection` when possible?).<br></p><p>Secondly, can you provide more detail on the proposed implementation? <br></p><p>Are you just walking the index forward and subscripting the base in the iterator, or something fancier?<br></p><p>&gt; On Sep 28, 2016, at 12:55 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Gist here: https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2 &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2&gt;<br>&gt; <br>&gt; Introducing indexed() collections<br>&gt; <br>&gt; Proposal: TBD<br>&gt; Author: Erica Sadun &lt;https://github.com/erica&gt;, Nate Cook &lt;https://github.com/natecook1000&gt;, Jacob Bandes-Storch &lt;https://github.com/jtbandes&gt;, Kevin Ballard &lt;https://github.com/kballard&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal introduces indexed() to the standard library, a method on collections that returns an (index, element) tuple sequence.<br>&gt; <br>&gt; Swift-evolution thread: TBD &lt;https://gist.github.com/erica/tbd&gt;<br>&gt;  &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#motivation&gt;Motivation<br>&gt; <br>&gt; The standard library&#39;s enumerated() method returns a sequence of pairs enumerating a sequence. The pair&#39;s first member is a monotonically incrementing integer starting at zero, and the second member is the corresponding element of the sequence. When working with arrays, the integer is coincidentally the same type and value as an Array index but the enumerated value is not generated with index-specific semantics. This may lead to confusion when developers attempt to subscript a non-array collection with enumerated integers. It can introduce serious bugs when developers use enumerated()-based integer subscripting with non-zero-based array slices.<br>&gt; <br>&gt; Indices have a specific, fixed meaning in Swift, which are used to create valid collection subscripts. This proposal introduces indexed() to produce a more semantically relevant sequence by pairing a collection&#39;s indices with its members. While it is trivial to create a solution in Swift, the most common developer approach shown here calculates indexes twice: <br>&gt; <br>&gt; extension Collection {<br>&gt;     /// Returns a sequence of pairs (*idx*, *x*), where *idx* represents a<br>&gt;     /// consecutive collection index, and *x* represents an element of<br>&gt;     /// the sequence.<br>&gt;     func indexed() -&gt; Zip2Sequence&lt;Self.Indices, Self&gt; {<br>&gt;         return zip(indices, self)<br>&gt;     }<br>&gt; }<br>&gt; Incrementing an index in some collections can be unnecessarily costly. In a lazy filtered collection, an index increment is potentially O(N). We feel this is better addressed introducing a new function into the Standard Library to provide a more efficient design that avoids the attractive nuisance of the &quot;obvious&quot; solution.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#detailed-design&gt;Detailed Design<br>&gt; <br>&gt; Our vision of indexed() bypasses duplicated index generation with their potentially high computation costs. We&#39;d create an iterator that calculates each index once and then applies that index to subscript the collection. Implementation would take place through IndexedSequence, similar to EnumeratedSequence.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; This proposal is purely additive and has no impact on existing code.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; Not yet<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/f8b0fbb0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal draft] Introducing `indexed()` collections</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>September 28, 2016 at 02:00:00pm</p></header><div class="content"><p>On Wed, Sep 28, 2016, at 02:27 PM, plx via swift-evolution wrote:<br>&gt; +1 to have something *like* this, but a few questions.<br>&gt;<br>&gt; Is there a specific reason `IndexedSequence` isn’t<br>&gt; `IndexedCollection`, conforming to `Collection` (and once conditional<br>&gt; conformances are available picking up `BidirectionalCollection` and<br>&gt; `RandomAccessCollection` when possible?).<br></p><p>This is already being discussed in this thread, but the simple answer is<br>that adds complexity and it&#39;s not obvious that it&#39;s worth the additional<br>complexity.<br></p><p>&gt; Secondly, can you provide more detail on the proposed implementation?<br>&gt;<br>&gt; Are you just walking the index forward and subscripting the base in<br>&gt; the iterator, or something fancier?<br></p><p>Yeah, that&#39;s what it would be. Something like<br></p><p>sequence(state: base.indices, next: {<br>    guard let idx = $0.next() else { return nil }<br>    return (idx, base[idx])<br>})<br></p><p>except done as a concrete type.<br></p><p>-Kevin<br></p><p>&gt;&gt; On Sep 28, 2016, at 12:55 PM, Erica Sadun via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Gist here:<br>&gt;&gt; https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2<br>&gt;&gt;<br>&gt;&gt; Introducing indexed() collections<br></p><p><br>&gt;&gt;  * Proposal: TBD<br>&gt;&gt;  * Author: Erica Sadun[1], Nate Cook[2], Jacob Bandes-Storch[3],<br>&gt;&gt;    Kevin Ballard[4]<br>&gt;&gt;  * Status: TBD<br>&gt;&gt;  * Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; This proposal introduces indexed() to the standard library, a method<br>&gt;&gt; on collections that returns an (index, element) tuple sequence.<br>&gt;&gt; Swift-evolution thread: TBD[5]<br>&gt;&gt; Motivation<br>&gt;&gt; The standard library&#39;s enumerated() method returns a sequence of<br>&gt;&gt; pairs enumerating a sequence. The pair&#39;s first member is a<br>&gt;&gt; monotonically incrementing integer starting at zero, and the second<br>&gt;&gt; member is the corresponding element of the sequence. When working<br>&gt;&gt; with arrays, the integer is coincidentally the same type and value as<br>&gt;&gt; an Array index but the enumerated value is not generated with index-<br>&gt;&gt; specific semantics. This may lead to confusion when developers<br>&gt;&gt; attempt to subscript a non-array collection with enumerated integers.<br>&gt;&gt; It can introduce serious bugs when developers use enumerated()-based<br>&gt;&gt; integer subscripting with non-zero-based array slices.<br>&gt;&gt; Indices have a specific, fixed meaning in Swift, which are used to<br>&gt;&gt; create valid collection subscripts. This proposal introduces<br>&gt;&gt; indexed() to produce a more semantically relevant sequence by pairing<br>&gt;&gt; a collection&#39;s indices with its members. While it is trivial to<br>&gt;&gt; create a solution in Swift, the most common developer approach shown<br>&gt;&gt; here calculates indexes twice:<br></p><p><br>&gt;&gt; extension Collection { /// Returns a sequence of pairs (*idx*, *x*),<br>&gt;&gt; where *idx* represents a /// consecutive collection index, and *x*<br>&gt;&gt; represents an element of /// the sequence. func indexed() -&gt;<br>&gt;&gt; Zip2Sequence&lt;Self.Indices, Self&gt; { return zip(indices, self) } }<br>&gt;&gt;<br>&gt;&gt; Incrementing an index in some collections can be unnecessarily<br>&gt;&gt; costly. In a lazy filtered collection, an index increment is<br>&gt;&gt; potentially O(N). We feel this is better addressed introducing a new<br>&gt;&gt; function into the Standard Library to provide a more efficient design<br>&gt;&gt; that avoids the attractive nuisance of the &quot;obvious&quot; solution.<br>&gt;&gt; Detailed Design<br>&gt;&gt; Our vision of indexed() bypasses duplicated index generation with<br>&gt;&gt; their potentially high computation costs. We&#39;d create an iterator<br>&gt;&gt; that calculates each index once and then applies that index to<br>&gt;&gt; subscript the collection. Implementation would take place through<br>&gt;&gt; IndexedSequence, similar to EnumeratedSequence.<br>&gt;&gt; Impact on Existing Code<br>&gt;&gt; This proposal is purely additive and has no impact on existing code.<br>&gt;&gt; Alternatives Considered<br>&gt;&gt; Not yet<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>Links:<br></p><p>  1. https://github.com/erica<br>  2. https://github.com/natecook1000<br>  3. https://github.com/jtbandes<br>  4. https://github.com/kballard<br>  5. https://gist.github.com/erica/tbd<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/6493d5a9/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Proposal draft] Introducing `indexed()` collections</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>September 28, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Sep 28, 2016, at 4:47 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Sep 28, 2016, at 02:27 PM, plx via swift-evolution wrote:<br>&gt;&gt; +1 to have something *like* this, but a few questions.<br>&gt;&gt; <br>&gt;&gt; Is there a specific reason `IndexedSequence` isn’t `IndexedCollection`, conforming to `Collection` (and once conditional conformances are available picking up `BidirectionalCollection` and `RandomAccessCollection` when possible?).<br>&gt; <br>&gt; This is already being discussed in this thread, but the simple answer is that adds complexity and it&#39;s not obvious that it&#39;s worth the additional complexity.<br></p><p>As it can be done as trivial, &quot;pass-through&quot; boilerplate:<br></p><p>  struct IndexedCollection&lt;C:Collection&gt; :Collection {<br>    typealias Index = C.Index<br>    typealias Indices = C.Indices<br></p><p>    let base: C<br>  <br>    subscript(i: Index) -&gt; (Index,C.Iterator.Element) { return (i,base[i]) }<br>  <br>}<br></p><p>…(and so on and so forth) it’s about as trivial to implement as any `Collection` is going to be…which is why I was a bit surprised it wasn’t part of the proposal.<br></p><p>If you’re worried about performance vis-a-vis lazy collections you could also store the `base.indices` and use it instead of `base` but even that should leave the implementation almost entirely boilerplate-ish.<br></p><p>Sure it’s a bit annoying to write it all out but I’m not seeing a lot of complexity really; I might be missing something?<br></p><p>&gt; <br>&gt;&gt; Secondly, can you provide more detail on the proposed implementation? <br>&gt;&gt; <br>&gt;&gt; Are you just walking the index forward and subscripting the base in the iterator, or something fancier?<br>&gt; <br>&gt; Yeah, that&#39;s what it would be. Something like<br>&gt; <br>&gt; sequence(state: base.indices, next: {<br>&gt;     guard let idx = $0.next() else { return nil }<br>&gt;     return (idx, base[idx])<br>&gt; })<br>&gt; <br>&gt; except done as a concrete type.<br></p><p>I assume the above is closer to this?<br></p><p>&gt; sequence(state: base.indices.makeIterator(), next: {<br>&gt;     guard let idx = $0.next() else { return nil }<br>&gt;     return (idx, base[idx])<br>&gt; })<br></p><p>The way the proposal was worried I was concerned the “only calculate each index once” bit would be a bit expensive when not really necessary, but deferring to the implementation of `indices` seems perfectly reasonable to me.<br></p><p>&gt; <br>&gt; -Kevin<br>&gt; <br>&gt;&gt;&gt; On Sep 28, 2016, at 12:55 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Gist here: https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2 &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introducing indexed() collections<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: TBD<br>&gt;&gt;&gt; Author: Erica Sadun &lt;https://github.com/erica&gt;, Nate Cook &lt;https://github.com/natecook1000&gt;, Jacob Bandes-Storch &lt;https://github.com/jtbandes&gt;, Kevin Ballard &lt;https://github.com/kballard&gt;<br>&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;  &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#introduction&gt;Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal introduces indexed() to the standard library, a method on collections that returns an (index, element) tuple sequence.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: TBD &lt;https://gist.github.com/erica/tbd&gt;<br>&gt;&gt;&gt;  &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#motivation&gt;Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The standard library&#39;s enumerated() method returns a sequence of pairs enumerating a sequence. The pair&#39;s first member is a monotonically incrementing integer starting at zero, and the second member is the corresponding element of the sequence. When working with arrays, the integer is coincidentally the same type and value as an Array index but the enumerated value is not generated with index-specific semantics. This may lead to confusion when developers attempt to subscript a non-array collection with enumerated integers. It can introduce serious bugs when developers use enumerated()-based integer subscripting with non-zero-based array slices.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Indices have a specific, fixed meaning in Swift, which are used to create valid collection subscripts. This proposal introduces indexed() to produce a more semantically relevant sequence by pairing a collection&#39;s indices with its members. While it is trivial to create a solution in Swift, the most common developer approach shown here calculates indexes twice: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Collection {<br>&gt;&gt;&gt;     /// Returns a sequence of pairs (*idx*, *x*), where *idx* represents a<br>&gt;&gt;&gt;     /// consecutive collection index, and *x* represents an element of<br>&gt;&gt;&gt;     /// the sequence.<br>&gt;&gt;&gt;     func indexed() -&gt; Zip2Sequence&lt;Self.Indices, Self&gt; {<br>&gt;&gt;&gt;         return zip(indices, self)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Incrementing an index in some collections can be unnecessarily costly. In a lazy filtered collection, an index increment is potentially O(N). We feel this is better addressed introducing a new function into the Standard Library to provide a more efficient design that avoids the attractive nuisance of the &quot;obvious&quot; solution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#detailed-design&gt;Detailed Design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Our vision of indexed() bypasses duplicated index generation with their potentially high computation costs. We&#39;d create an iterator that calculates each index once and then applies that index to subscript the collection. Implementation would take place through IndexedSequence, similar to EnumeratedSequence.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#impact-on-existing-code&gt;Impact on Existing Code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal is purely additive and has no impact on existing code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#alternatives-considered&gt;Alternatives Considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not yet<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/086d9c6f/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/268d9a6a10ecdf70a24fdf96d03cec1c?s=50"></div><header><strong>[Proposal draft] Introducing `indexed()` collections</strong> from <string>Colin Barrett</string> &lt;colin at springsandstruts.com&gt;<p>September 28, 2016 at 08:00:00pm</p></header><div class="content"><p>Definitely well motivated. It seems like having both .enumerated() and .indexed() methods would still leave open the possibility of novices using .enumerated and making the same mistake as before. I realize that because of where .enumerated() sits it has to work the way it does, but is there perhaps a better design (with constrained extensions?) for a single method that can give an Int for a Sequence and an appropriate Index for a Collection?<br></p><p>-Colin<br></p><p>&gt; On Sep 28, 2016, at 1:55 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Gist here: https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2 &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2&gt;<br>&gt; <br>&gt; Introducing indexed() collections<br>&gt; <br>&gt; Proposal: TBD<br>&gt; Author: Erica Sadun &lt;https://github.com/erica&gt;, Nate Cook &lt;https://github.com/natecook1000&gt;, Jacob Bandes-Storch &lt;https://github.com/jtbandes&gt;, Kevin Ballard &lt;https://github.com/kballard&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal introduces indexed() to the standard library, a method on collections that returns an (index, element) tuple sequence.<br>&gt; <br>&gt; Swift-evolution thread: TBD &lt;https://gist.github.com/erica/tbd&gt;<br>&gt;  &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#motivation&gt;Motivation<br>&gt; <br>&gt; The standard library&#39;s enumerated() method returns a sequence of pairs enumerating a sequence. The pair&#39;s first member is a monotonically incrementing integer starting at zero, and the second member is the corresponding element of the sequence. When working with arrays, the integer is coincidentally the same type and value as an Array index but the enumerated value is not generated with index-specific semantics. This may lead to confusion when developers attempt to subscript a non-array collection with enumerated integers. It can introduce serious bugs when developers use enumerated()-based integer subscripting with non-zero-based array slices.<br>&gt; <br>&gt; Indices have a specific, fixed meaning in Swift, which are used to create valid collection subscripts. This proposal introduces indexed() to produce a more semantically relevant sequence by pairing a collection&#39;s indices with its members. While it is trivial to create a solution in Swift, the most common developer approach shown here calculates indexes twice: <br>&gt; <br>&gt; extension Collection {<br>&gt;     /// Returns a sequence of pairs (*idx*, *x*), where *idx* represents a<br>&gt;     /// consecutive collection index, and *x* represents an element of<br>&gt;     /// the sequence.<br>&gt;     func indexed() -&gt; Zip2Sequence&lt;Self.Indices, Self&gt; {<br>&gt;         return zip(indices, self)<br>&gt;     }<br>&gt; }<br>&gt; Incrementing an index in some collections can be unnecessarily costly. In a lazy filtered collection, an index increment is potentially O(N). We feel this is better addressed introducing a new function into the Standard Library to provide a more efficient design that avoids the attractive nuisance of the &quot;obvious&quot; solution.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#detailed-design&gt;Detailed Design<br>&gt; <br>&gt; Our vision of indexed() bypasses duplicated index generation with their potentially high computation costs. We&#39;d create an iterator that calculates each index once and then applies that index to subscript the collection. Implementation would take place through IndexedSequence, similar to EnumeratedSequence.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; This proposal is purely additive and has no impact on existing code.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; Not yet<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/04f43ea3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal draft] Introducing `indexed()` collections</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>September 28, 2016 at 05:00:00pm</p></header><div class="content"><p>There&#39;s more uses for enumerated() than just producing Array indices.<br></p><p>-Kevin<br></p><p>On Wed, Sep 28, 2016, at 05:49 PM, Colin Barrett via swift-evolution wrote:<br>&gt; Definitely well motivated. It seems like having both .enumerated() and<br>&gt; .indexed() methods would still leave open the possibility of novices<br>&gt; using .enumerated and making the same mistake as before. I realize<br>&gt; that because of where .enumerated() sits it has to work the way it<br>&gt; does, but is there perhaps a better design (with constrained<br>&gt; extensions?) for a single method that can give an Int for a Sequence<br>&gt; and an appropriate Index for a Collection?<br>&gt;<br>&gt; -Colin<br>&gt;<br>&gt;&gt; On Sep 28, 2016, at 1:55 PM, Erica Sadun via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Gist here:<br>&gt;&gt; https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2<br>&gt;&gt;<br>&gt;&gt; Introducing indexed() collections<br></p><p><br>&gt;&gt;  * Proposal: TBD<br>&gt;&gt;  * Author: Erica Sadun[1], Nate Cook[2], Jacob Bandes-Storch[3],<br>&gt;&gt;    Kevin Ballard[4]<br>&gt;&gt;  * Status: TBD<br>&gt;&gt;  * Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; This proposal introduces indexed() to the standard library, a method<br>&gt;&gt; on collections that returns an (index, element) tuple sequence.<br>&gt;&gt; Swift-evolution thread: TBD[5]<br>&gt;&gt; Motivation<br>&gt;&gt; The standard library&#39;s enumerated() method returns a sequence of<br>&gt;&gt; pairs enumerating a sequence. The pair&#39;s first member is a<br>&gt;&gt; monotonically incrementing integer starting at zero, and the second<br>&gt;&gt; member is the corresponding element of the sequence. When working<br>&gt;&gt; with arrays, the integer is coincidentally the same type and value as<br>&gt;&gt; an Array index but the enumerated value is not generated with index-<br>&gt;&gt; specific semantics. This may lead to confusion when developers<br>&gt;&gt; attempt to subscript a non-array collection with enumerated integers.<br>&gt;&gt; It can introduce serious bugs when developers use enumerated()-based<br>&gt;&gt; integer subscripting with non-zero-based array slices.<br>&gt;&gt; Indices have a specific, fixed meaning in Swift, which are used to<br>&gt;&gt; create valid collection subscripts. This proposal introduces<br>&gt;&gt; indexed() to produce a more semantically relevant sequence by pairing<br>&gt;&gt; a collection&#39;s indices with its members. While it is trivial to<br>&gt;&gt; create a solution in Swift, the most common developer approach shown<br>&gt;&gt; here calculates indexes twice:<br></p><p><br>&gt;&gt; extension Collection { /// Returns a sequence of pairs (*idx*, *x*),<br>&gt;&gt; where *idx* represents a /// consecutive collection index, and *x*<br>&gt;&gt; represents an element of /// the sequence. func indexed() -&gt;<br>&gt;&gt; Zip2Sequence&lt;Self.Indices, Self&gt; { return zip(indices, self) } }<br>&gt;&gt;<br>&gt;&gt; Incrementing an index in some collections can be unnecessarily<br>&gt;&gt; costly. In a lazy filtered collection, an index increment is<br>&gt;&gt; potentially O(N). We feel this is better addressed introducing a new<br>&gt;&gt; function into the Standard Library to provide a more efficient design<br>&gt;&gt; that avoids the attractive nuisance of the &quot;obvious&quot; solution.<br>&gt;&gt; Detailed Design<br>&gt;&gt; Our vision of indexed() bypasses duplicated index generation with<br>&gt;&gt; their potentially high computation costs. We&#39;d create an iterator<br>&gt;&gt; that calculates each index once and then applies that index to<br>&gt;&gt; subscript the collection. Implementation would take place through<br>&gt;&gt; IndexedSequence, similar to EnumeratedSequence.<br>&gt;&gt; Impact on Existing Code<br>&gt;&gt; This proposal is purely additive and has no impact on existing code.<br>&gt;&gt; Alternatives Considered<br>&gt;&gt; Not yet<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>Links:<br></p><p>  1. https://github.com/erica<br>  2. https://github.com/natecook1000<br>  3. https://github.com/jtbandes<br>  4. https://github.com/kballard<br>  5. https://gist.github.com/erica/tbd<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/6c1d0398/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/268d9a6a10ecdf70a24fdf96d03cec1c?s=50"></div><header><strong>[Proposal draft] Introducing `indexed()` collections</strong> from <string>Colin Barrett</string> &lt;colin at springsandstruts.com&gt;<p>September 28, 2016 at 10:00:00pm</p></header><div class="content"><p>I’m aware, which is why I didn’t say it should be removed. (And if I hadn’t been aware, this wouldn’t have helped me discover them. :-)<br></p><p>&gt; On Sep 28, 2016, at 8:58 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; There&#39;s more uses for enumerated() than just producing Array indices.<br>&gt; <br>&gt; -Kevin<br>&gt; <br>&gt; On Wed, Sep 28, 2016, at 05:49 PM, Colin Barrett via swift-evolution wrote:<br>&gt;&gt; Definitely well motivated. It seems like having both .enumerated() and .indexed() methods would still leave open the possibility of novices using .enumerated and making the same mistake as before. I realize that because of where .enumerated() sits it has to work the way it does, but is there perhaps a better design (with constrained extensions?) for a single method that can give an Int for a Sequence and an appropriate Index for a Collection?<br>&gt;&gt; <br>&gt;&gt; -Colin<br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 28, 2016, at 1:55 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Gist here: https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2 &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introducing indexed() collections<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: TBD<br>&gt;&gt;&gt; Author: Erica Sadun &lt;https://github.com/erica&gt;, Nate Cook &lt;https://github.com/natecook1000&gt;, Jacob Bandes-Storch &lt;https://github.com/jtbandes&gt;, Kevin Ballard &lt;https://github.com/kballard&gt;<br>&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;  &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#introduction&gt;Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal introduces indexed() to the standard library, a method on collections that returns an (index, element) tuple sequence.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: TBD &lt;https://gist.github.com/erica/tbd&gt;<br>&gt;&gt;&gt;  &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#motivation&gt;Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The standard library&#39;s enumerated() method returns a sequence of pairs enumerating a sequence. The pair&#39;s first member is a monotonically incrementing integer starting at zero, and the second member is the corresponding element of the sequence. When working with arrays, the integer is coincidentally the same type and value as an Array index but the enumerated value is not generated with index-specific semantics. This may lead to confusion when developers attempt to subscript a non-array collection with enumerated integers. It can introduce serious bugs when developers use enumerated()-based integer subscripting with non-zero-based array slices.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Indices have a specific, fixed meaning in Swift, which are used to create valid collection subscripts. This proposal introduces indexed() to produce a more semantically relevant sequence by pairing a collection&#39;s indices with its members. While it is trivial to create a solution in Swift, the most common developer approach shown here calculates indexes twice: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Collection {<br>&gt;&gt;&gt;     /// Returns a sequence of pairs (*idx*, *x*), where *idx* represents a<br>&gt;&gt;&gt;     /// consecutive collection index, and *x* represents an element of<br>&gt;&gt;&gt;     /// the sequence.<br>&gt;&gt;&gt;     func indexed() -&gt; Zip2Sequence&lt;Self.Indices, Self&gt; {<br>&gt;&gt;&gt;         return zip(indices, self)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Incrementing an index in some collections can be unnecessarily costly. In a lazy filtered collection, an index increment is potentially O(N). We feel this is better addressed introducing a new function into the Standard Library to provide a more efficient design that avoids the attractive nuisance of the &quot;obvious&quot; solution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#detailed-design&gt;Detailed Design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Our vision of indexed() bypasses duplicated index generation with their potentially high computation costs. We&#39;d create an iterator that calculates each index once and then applies that index to subscript the collection. Implementation would take place through IndexedSequence, similar to EnumeratedSequence.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#impact-on-existing-code&gt;Impact on Existing Code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal is purely additive and has no impact on existing code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#alternatives-considered&gt;Alternatives Considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not yet<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/646d2973/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal draft] Introducing `indexed()` collections</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>September 29, 2016 at 11:00:00am</p></header><div class="content"><p>Well you kind of did say it should be removed. If we came up with a new<br>design that produced an Int for sequences and an Index for collections,<br>then you can&#39;t get an Int for collections (without wrapping the<br>collection in AnySequence), which is basically the same thing as just<br>removing enumerated() for collections.<br></p><p>-Kevin<br></p><p>On Wed, Sep 28, 2016, at 07:08 PM, Colin Barrett wrote:<br>&gt; I’m aware, which is why I didn’t say it should be removed. (And if I<br>&gt; hadn’t been aware, this wouldn’t have helped me discover them. :-)<br>&gt;<br>&gt;&gt; On Sep 28, 2016, at 8:58 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; There&#39;s more uses for enumerated() than just producing Array indices.<br>&gt;&gt;<br>&gt;&gt; -Kevin<br>&gt;&gt;<br>&gt;&gt; On Wed, Sep 28, 2016, at 05:49 PM, Colin Barrett via swift-<br>&gt;&gt; evolution wrote:<br>&gt;&gt;&gt; Definitely well motivated. It seems like having both .enumerated()<br>&gt;&gt;&gt; and .indexed() methods would still leave open the possibility of<br>&gt;&gt;&gt; novices using .enumerated and making the same mistake as before. I<br>&gt;&gt;&gt; realize that because of where .enumerated() sits it has to work the<br>&gt;&gt;&gt; way it does, but is there perhaps a better design (with constrained<br>&gt;&gt;&gt; extensions?) for a single method that can give an Int for a Sequence<br>&gt;&gt;&gt; and an appropriate Index for a Collection?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Colin<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Sep 28, 2016, at 1:55 PM, Erica Sadun via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Gist here:<br>&gt;&gt;&gt;&gt; https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Introducing indexed() collections<br></p><p><br>&gt;&gt;&gt;&gt;  * Proposal: TBD<br>&gt;&gt;&gt;&gt;  * Author: Erica Sadun[1], Nate Cook[2], Jacob Bandes-Storch[3],<br>&gt;&gt;&gt;&gt;    Kevin Ballard[4]<br>&gt;&gt;&gt;&gt;  * Status: TBD<br>&gt;&gt;&gt;&gt;  * Review manager: TBD<br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt; This proposal introduces indexed() to the standard library, a<br>&gt;&gt;&gt;&gt; method on collections that returns an (index, element) tuple<br>&gt;&gt;&gt;&gt; sequence.<br>&gt;&gt;&gt;&gt; Swift-evolution thread: TBD[5]<br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt; The standard library&#39;s enumerated() method returns a sequence of<br>&gt;&gt;&gt;&gt; pairs enumerating a sequence. The pair&#39;s first member is a<br>&gt;&gt;&gt;&gt; monotonically incrementing integer starting at zero, and the second<br>&gt;&gt;&gt;&gt; member is the corresponding element of the sequence. When working<br>&gt;&gt;&gt;&gt; with arrays, the integer is coincidentally the same type and value<br>&gt;&gt;&gt;&gt; as an Array index but the enumerated value is not generated with<br>&gt;&gt;&gt;&gt; index-specific semantics. This may lead to confusion when<br>&gt;&gt;&gt;&gt; developers attempt to subscript a non-array collection with<br>&gt;&gt;&gt;&gt; enumerated integers. It can introduce serious bugs when developers<br>&gt;&gt;&gt;&gt; use enumerated()-based integer subscripting with non-zero-based<br>&gt;&gt;&gt;&gt; array slices.<br>&gt;&gt;&gt;&gt; Indices have a specific, fixed meaning in Swift, which are used to<br>&gt;&gt;&gt;&gt; create valid collection subscripts. This proposal introduces<br>&gt;&gt;&gt;&gt; indexed() to produce a more semantically relevant sequence by<br>&gt;&gt;&gt;&gt; pairing a collection&#39;s indices with its members. While it is<br>&gt;&gt;&gt;&gt; trivial to create a solution in Swift, the most common developer<br>&gt;&gt;&gt;&gt; approach shown here calculates indexes twice:<br></p><p><br>&gt;&gt;&gt;&gt; extension Collection { /// Returns a sequence of pairs (*idx*,<br>&gt;&gt;&gt;&gt; *x*), where *idx* represents a /// consecutive collection index,<br>&gt;&gt;&gt;&gt; and *x* represents an element of /// the sequence. func indexed()<br>&gt;&gt;&gt;&gt; -&gt; Zip2Sequence&lt;Self.Indices, Self&gt; { return zip(indices, self) } }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Incrementing an index in some collections can be unnecessarily<br>&gt;&gt;&gt;&gt; costly. In a lazy filtered collection, an index increment is<br>&gt;&gt;&gt;&gt; potentially O(N). We feel this is better addressed introducing a<br>&gt;&gt;&gt;&gt; new function into the Standard Library to provide a more efficient<br>&gt;&gt;&gt;&gt; design that avoids the attractive nuisance of the &quot;obvious&quot;<br>&gt;&gt;&gt;&gt; solution.<br>&gt;&gt;&gt;&gt; Detailed Design<br>&gt;&gt;&gt;&gt; Our vision of indexed() bypasses duplicated index generation with<br>&gt;&gt;&gt;&gt; their potentially high computation costs. We&#39;d create an iterator<br>&gt;&gt;&gt;&gt; that calculates each index once and then applies that index to<br>&gt;&gt;&gt;&gt; subscript the collection. Implementation would take place through<br>&gt;&gt;&gt;&gt; IndexedSequence, similar to EnumeratedSequence.<br>&gt;&gt;&gt;&gt; Impact on Existing Code<br>&gt;&gt;&gt;&gt; This proposal is purely additive and has no impact on existing<br>&gt;&gt;&gt;&gt; code.<br>&gt;&gt;&gt;&gt; Alternatives Considered<br>&gt;&gt;&gt;&gt; Not yet<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _________________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p><p><br>Links:<br></p><p>  1. https://github.com/erica<br>  2. https://github.com/natecook1000<br>  3. https://github.com/jtbandes<br>  4. https://github.com/kballard<br>  5. https://gist.github.com/erica/tbd<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160929/14e3f438/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal draft] Introducing `indexed()` collections</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>September 29, 2016 at 09:00:00am</p></header><div class="content"><p>+1 to this idea.<br></p><p>On the issue of discoverability, I wonder if .enumeratedByIndex() could be an alternative name for the new method? It&#39;s a bit verbose, but would cause it to come up as an option alongside .enumarated(), while being clear of the difference.<br></p><p>&gt; On 28 Sep 2016, at 18:55, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Gist here: https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2 &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2&gt;<br>&gt; <br>&gt; Introducing indexed() collections<br>&gt; <br>&gt; Proposal: TBD<br>&gt; Author: Erica Sadun &lt;https://github.com/erica&gt;, Nate Cook &lt;https://github.com/natecook1000&gt;, Jacob Bandes-Storch &lt;https://github.com/jtbandes&gt;, Kevin Ballard &lt;https://github.com/kballard&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal introduces indexed() to the standard library, a method on collections that returns an (index, element) tuple sequence.<br>&gt; <br>&gt; Swift-evolution thread: TBD &lt;https://gist.github.com/erica/tbd&gt;<br>&gt;  &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#motivation&gt;Motivation<br>&gt; <br>&gt; The standard library&#39;s enumerated() method returns a sequence of pairs enumerating a sequence. The pair&#39;s first member is a monotonically incrementing integer starting at zero, and the second member is the corresponding element of the sequence. When working with arrays, the integer is coincidentally the same type and value as an Array index but the enumerated value is not generated with index-specific semantics. This may lead to confusion when developers attempt to subscript a non-array collection with enumerated integers. It can introduce serious bugs when developers use enumerated()-based integer subscripting with non-zero-based array slices.<br>&gt; <br>&gt; Indices have a specific, fixed meaning in Swift, which are used to create valid collection subscripts. This proposal introduces indexed() to produce a more semantically relevant sequence by pairing a collection&#39;s indices with its members. While it is trivial to create a solution in Swift, the most common developer approach shown here calculates indexes twice: <br>&gt; <br>&gt; extension Collection {<br>&gt;     /// Returns a sequence of pairs (*idx*, *x*), where *idx* represents a<br>&gt;     /// consecutive collection index, and *x* represents an element of<br>&gt;     /// the sequence.<br>&gt;     func indexed() -&gt; Zip2Sequence&lt;Self.Indices, Self&gt; {<br>&gt;         return zip(indices, self)<br>&gt;     }<br>&gt; }<br>&gt; Incrementing an index in some collections can be unnecessarily costly. In a lazy filtered collection, an index increment is potentially O(N). We feel this is better addressed introducing a new function into the Standard Library to provide a more efficient design that avoids the attractive nuisance of the &quot;obvious&quot; solution.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#detailed-design&gt;Detailed Design<br>&gt; <br>&gt; Our vision of indexed() bypasses duplicated index generation with their potentially high computation costs. We&#39;d create an iterator that calculates each index once and then applies that index to subscript the collection. Implementation would take place through IndexedSequence, similar to EnumeratedSequence.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; This proposal is purely additive and has no impact on existing code.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; Not yet<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160929/a5b7ecc0/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
