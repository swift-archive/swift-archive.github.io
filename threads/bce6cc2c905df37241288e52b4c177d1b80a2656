<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Draft Proposal: Declare variables in &#39;case&#39; labels with multiple patterns</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 23, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>I&#39;d like to discuss declaring variables in case labels with multiple<br>patterns. I&#39;ve written a draft proposal, but I&#39;d like to discuss it first<br>before formally proposing anything.<br></p><p>https://github.com/therealbnut/swift-evolution/blob/a137202e41588b71d3c0511cff85f82ec5f65629/proposals/0023-declare-variables-in-case-labels-with-multiple-patterns.md<br></p><p>In short:<br></p><p>switch value {<br>case let .Case1(x, 2), .Case2(2, x):<br>    print(x)<br>}<br></p><p><br>The original proposal is here, it may need to adapt after discussion, so<br>I&#39;ll try to keep the proposal at that link up-to-date.<br></p><p>Thanks,<br>Andrew<br></p><p>Declare variables in &#39;case&#39; labels with multiple patterns<br></p><p>   - Proposal: SE-0022<br>   &lt;https://github.com/therealbnut/swift-evolution/blob/master/proposals/0023-declare-variables-in-case-labels-with-multiple-patterns.md&gt;<br>   - Author(s): Andrew Bennett &lt;https://github.com/therealbnut&gt;<br>   - Status: *In Discussion*<br>   - Review manager: *Not In Review*<br></p><p>Introduction<br></p><p>In Swift 2, it is possible to match multiple patterns in cases. However<br>cases cannot contain multiple patterns if the case declares variables.<br></p><p>The following code currently produces an error:<br></p><p>enum MyEnum {<br>    case Case1(Int,Float)<br>    case Case2(Float,Int)<br>}<br>switch value {<br>case let .Case1(x, 2), .Case2(2, x):<br>    print(x)<br>case .Case1, .Case2:<br>    break<br>}<br></p><p>The error is:<br></p><p>`case` labels with multiple patterns cannot declare variables.<br></p><p>This proposal aims to remove this error when each pattern declares the same<br>variables with the same types.<br></p><p>Motivation<br></p><p>This change reduces repeditive code, and therefore reduces mistakes. It&#39;s<br>consistent with multi-pattern matching when variables aren&#39;t defined.<br>Proposed solution<br></p><p>Allow case labels with multiple patterns to declare patterns by matching<br>variable names in each pattern.<br></p><p>Using the following enum:<br></p><p>enum MyEnum {<br>    case Case1(Int,Float)<br>    case Case2(Float,Int)<br>}<br></p><p>These cases should be possible:<br></p><p>case let .Case1(x, _), .Case2(_, x):<br>case let .Case1(y, x), .Case2(x, y):<br>case let .Case1(x), .Case2(x):<br>case .Case1(let x, _), .Case2(_, let x):<br></p><p>Detailed design<br></p><p>Allow case labels with multiple patterns if the case labels match the<br>following constraints:<br></p><p>   - All patterns declare exactly the same variables.<br>   - The same variable has the same type in each pattern.<br></p><p>Therefore each pattern is able to produce the same variables for the case<br>label.<br>Impact on existing code<br></p><p>This should have no impact on existing code, although it should offer many<br>opportunities for existing code to be simplified.<br>Alternatives considered<br>Using a closure or inline function<br></p><p>Code repitition can be reduced with one pattern per &#39;case&#39; and handling the<br>result with an inline function.<br></p><p>func handleCases(value: MyEnum, apply: Int -&gt; Int) -&gt; Int {<br>    func handleX(x: Int) -&gt; Int {<br>        return apply(x) + 1<br>    }<br>    let out: Int<br>    switch value {<br>    case .Case1(let x, 2):<br>        out = handleX(x)<br>    case .Case2(2, let x):<br>        out = handleX(x)<br>    case .Case1, .Case2:<br>        out = -1<br>    }<br>    return out<br>}<br></p><p>This syntax is much more verbose, makes control flow more confusing, and<br>has the limitations of the what the inline function may capture.<br></p><p>In the above example apply cannot be @noescape because handleX captures it.<br></p><p>Also in the above example if out is captured and assigned by handleX then<br>it must be var, not let. This can produce shorter syntax, but is not as<br>safe; out may accidentally be assigned more than once, additionally out also<br>needs to initialized (which may not be possible or desirable).<br>Extending the fallthrough syntax<br></p><p>A similar reduction in code repetition can be achieved if fallthrough<br>allowed variables to be mapped onto the next case, for example:<br></p><p>switch test {<br>    case .Case1(let x, 2):<br>        fallthrough .Case2(_, x)<br>    case .Case2(3, .let x):<br>        print(&quot;x: \(x)&quot;)<br>}<br></p><p>This is not as intuitive, is a hack, and fallthrough should probably be<br>discouraged. It is much more flexible, a programmer could adjust the value<br>of x before fallthrough. Flexibility increases the chances of programmer<br>error, perhaps not as much as code-repitition though.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/bce62656/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Draft Proposal: Declare variables in &#39;case&#39; labels with multiple patterns</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 22, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 7:39 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; I&#39;d like to discuss declaring variables in case labels with multiple patterns. I&#39;ve written a draft proposal, but I&#39;d like to discuss it first before formally proposing anything.<br>&gt; <br>&gt; https://github.com/therealbnut/swift-evolution/blob/a137202e41588b71d3c0511cff85f82ec5f65629/proposals/0023-declare-variables-in-case-labels-with-multiple-patterns.md &lt;https://github.com/therealbnut/swift-evolution/blob/a137202e41588b71d3c0511cff85f82ec5f65629/proposals/0023-declare-variables-in-case-labels-with-multiple-patterns.md&gt;<br>+1.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/01ba7d5e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Draft Proposal: Declare variables in &#39;case&#39; labels with multiple patterns</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 23, 2016 at 06:00:00pm</p></header><div class="content"><p>Thanks Chris :)<br></p><p>I accidentally linked a specific commit, here&#39;s a proper link:<br></p><p>https://github.com/therealbnut/swift-evolution/blob/therealbnut-case-match/proposals/0023-declare-variables-in-case-labels-with-multiple-patterns.md<br></p><p>I also fixed a few typos.<br></p><p><br>On Sat, Jan 23, 2016 at 5:53 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 22, 2016, at 7:39 PM, Andrew Bennett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi,<br>&gt;<br>&gt; I&#39;d like to discuss declaring variables in case labels with multiple<br>&gt; patterns. I&#39;ve written a draft proposal, but I&#39;d like to discuss it first<br>&gt; before formally proposing anything.<br>&gt;<br>&gt;<br>&gt; https://github.com/therealbnut/swift-evolution/blob/a137202e41588b71d3c0511cff85f82ec5f65629/proposals/0023-declare-variables-in-case-labels-with-multiple-patterns.md<br>&gt;<br>&gt;<br>&gt; +1.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/5820f6c4/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Draft Proposal: Declare variables in &#39;case&#39; labels with multiple patterns</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 23, 2016 at 10:00:00am</p></header><div class="content"><p>This would be great. Other pattern matching languages with ML heritage can do this, the only reason Swift couldn&#39;t was time.<br></p><p>-Joe<br></p><p>&gt; On Jan 22, 2016, at 7:39 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; I&#39;d like to discuss declaring variables in case labels with multiple patterns. I&#39;ve written a draft proposal, but I&#39;d like to discuss it first before formally proposing anything.<br>&gt; <br>&gt; https://github.com/therealbnut/swift-evolution/blob/a137202e41588b71d3c0511cff85f82ec5f65629/proposals/0023-declare-variables-in-case-labels-with-multiple-patterns.md &lt;https://github.com/therealbnut/swift-evolution/blob/a137202e41588b71d3c0511cff85f82ec5f65629/proposals/0023-declare-variables-in-case-labels-with-multiple-patterns.md&gt;<br>&gt; <br>&gt; In short:<br>&gt; <br>&gt; switch value {<br>&gt; case let .Case1(x, 2), .Case2(2, x):<br>&gt;     print(x)<br>&gt; }<br>&gt; <br>&gt; The original proposal is here, it may need to adapt after discussion, so I&#39;ll try to keep the proposal at that link up-to-date.<br>&gt; <br>&gt; Thanks,<br>&gt; Andrew<br>&gt; <br>&gt; Declare variables in &#39;case&#39; labels with multiple patterns<br>&gt; <br>&gt; Proposal: SE-0022 &lt;https://github.com/therealbnut/swift-evolution/blob/master/proposals/0023-declare-variables-in-case-labels-with-multiple-patterns.md&gt;<br>&gt; Author(s): Andrew Bennett &lt;https://github.com/therealbnut&gt;<br>&gt; Status: In Discussion<br>&gt; Review manager: Not In Review<br>&gt; Introduction<br>&gt; <br>&gt; In Swift 2, it is possible to match multiple patterns in cases. However cases cannot contain multiple patterns if the case declares variables.<br>&gt; <br>&gt; The following code currently produces an error:<br>&gt; <br>&gt; enum MyEnum {<br>&gt;     case Case1(Int,Float)<br>&gt;     case Case2(Float,Int)<br>&gt; }<br>&gt; switch value {<br>&gt; case let .Case1(x, 2), .Case2(2, x):<br>&gt;     print(x)<br>&gt; case .Case1, .Case2:<br>&gt;     break<br>&gt; }<br>&gt; The error is:<br>&gt; <br>&gt; `case` labels with multiple patterns cannot declare variables. <br>&gt; This proposal aims to remove this error when each pattern declares the same variables with the same types.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; This change reduces repeditive code, and therefore reduces mistakes. It&#39;s consistent with multi-pattern matching when variables aren&#39;t defined.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; Allow case labels with multiple patterns to declare patterns by matching variable names in each pattern.<br>&gt; <br>&gt; Using the following enum:<br>&gt; <br>&gt; enum MyEnum {<br>&gt;     case Case1(Int,Float)<br>&gt;     case Case2(Float,Int)<br>&gt; }<br>&gt; These cases should be possible:<br>&gt; <br>&gt; case let .Case1(x, _), .Case2(_, x):<br>&gt; case let .Case1(y, x), .Case2(x, y):<br>&gt; case let .Case1(x), .Case2(x):<br>&gt; case .Case1(let x, _), .Case2(_, let x):<br>&gt; Detailed design<br>&gt; <br>&gt; Allow case labels with multiple patterns if the case labels match the following constraints:<br>&gt; <br>&gt; All patterns declare exactly the same variables.<br>&gt; The same variable has the same type in each pattern.<br>&gt; Therefore each pattern is able to produce the same variables for the case label.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; This should have no impact on existing code, although it should offer many opportunities for existing code to be simplified.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Using a closure or inline function<br>&gt; <br>&gt; Code repitition can be reduced with one pattern per &#39;case&#39; and handling the result with an inline function.<br>&gt; <br>&gt; func handleCases(value: MyEnum, apply: Int -&gt; Int) -&gt; Int {<br>&gt;     func handleX(x: Int) -&gt; Int {<br>&gt;         return apply(x) + 1<br>&gt;     }<br>&gt;     let out: Int<br>&gt;     switch value {<br>&gt;     case .Case1(let x, 2):<br>&gt;         out = handleX(x)<br>&gt;     case .Case2(2, let x):<br>&gt;         out = handleX(x)<br>&gt;     case .Case1, .Case2:<br>&gt;         out = -1<br>&gt;     }<br>&gt;     return out<br>&gt; }<br>&gt; This syntax is much more verbose, makes control flow more confusing, and has the limitations of the what the inline function may capture.<br>&gt; <br>&gt; In the above example apply cannot be @noescape because handleX captures it.<br>&gt; <br>&gt; Also in the above example if out is captured and assigned by handleX then it must be var, not let. This can produce shorter syntax, but is not as safe; out may accidentally be assigned more than once, additionally out also needs to initialized (which may not be possible or desirable).<br>&gt; <br>&gt; Extending the fallthrough syntax<br>&gt; <br>&gt; A similar reduction in code repetition can be achieved if fallthrough allowed variables to be mapped onto the next case, for example:<br>&gt; <br>&gt; switch test {<br>&gt;     case .Case1(let x, 2): <br>&gt;         fallthrough .Case2(_, x)<br>&gt;     case .Case2(3, .let x):<br>&gt;         print(&quot;x: \(x)&quot;)<br>&gt; }<br>&gt; This is not as intuitive, is a hack, and fallthrough should probably be discouraged. It is much more flexible, a programmer could adjust the value of x before fallthrough. Flexibility increases the chances of programmer error, perhaps not as much as code-repitition though.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/b0fecb59/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/423beb7cfb5894f7b53623d6e515b01d?s=50"></div><header><strong>Draft Proposal: Declare variables in &#39;case&#39; labels with multiple patterns</strong> from <string>Jed Lewison</string> &lt;jed.lewison at icloud.com&gt;<p>January 23, 2016 at 05:00:00pm</p></header><div class="content"><p>Also +1. I&#39;ve run into this a couple of times in the past week and the proposal would allow shorter and easier to read code.<br></p><p>Sent from my iPhone<br></p><p>&gt; On Jan 23, 2016, at 10:09 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This would be great. Other pattern matching languages with ML heritage can do this, the only reason Swift couldn&#39;t was time.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Jan 22, 2016, at 7:39 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to discuss declaring variables in case labels with multiple patterns. I&#39;ve written a draft proposal, but I&#39;d like to discuss it first before formally proposing anything.<br>&gt;&gt; <br>&gt;&gt; https://github.com/therealbnut/swift-evolution/blob/a137202e41588b71d3c0511cff85f82ec5f65629/proposals/0023-declare-variables-in-case-labels-with-multiple-patterns.md<br>&gt;&gt; <br>&gt;&gt; In short:<br>&gt;&gt; <br>&gt;&gt; switch value {<br>&gt;&gt; case let .Case1(x, 2), .Case2(2, x):<br>&gt;&gt;     print(x)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The original proposal is here, it may need to adapt after discussion, so I&#39;ll try to keep the proposal at that link up-to-date.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Andrew<br>&gt;&gt; <br>&gt;&gt; Declare variables in &#39;case&#39; labels with multiple patterns<br>&gt;&gt; Proposal: SE-0022<br>&gt;&gt; Author(s): Andrew Bennett<br>&gt;&gt; Status: In Discussion<br>&gt;&gt; Review manager: Not In Review<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; In Swift 2, it is possible to match multiple patterns in cases. However cases cannot contain multiple patterns if the case declares variables.<br>&gt;&gt; <br>&gt;&gt; The following code currently produces an error:<br>&gt;&gt; <br>&gt;&gt; enum MyEnum {<br>&gt;&gt;     case Case1(Int,Float)<br>&gt;&gt;     case Case2(Float,Int)<br>&gt;&gt; }<br>&gt;&gt; switch value {<br>&gt;&gt; case let .Case1(x, 2), .Case2(2, x):<br>&gt;&gt;     print(x)<br>&gt;&gt; case .Case1, .Case2:<br>&gt;&gt;     break<br>&gt;&gt; }<br>&gt;&gt; The error is:<br>&gt;&gt; <br>&gt;&gt; `case` labels with multiple patterns cannot declare variables. <br>&gt;&gt; This proposal aims to remove this error when each pattern declares the same variables with the same types.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; This change reduces repeditive code, and therefore reduces mistakes. It&#39;s consistent with multi-pattern matching when variables aren&#39;t defined.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; Allow case labels with multiple patterns to declare patterns by matching variable names in each pattern.<br>&gt;&gt; <br>&gt;&gt; Using the following enum:<br>&gt;&gt; <br>&gt;&gt; enum MyEnum {<br>&gt;&gt;     case Case1(Int,Float)<br>&gt;&gt;     case Case2(Float,Int)<br>&gt;&gt; }<br>&gt;&gt; These cases should be possible:<br>&gt;&gt; <br>&gt;&gt; case let .Case1(x, _), .Case2(_, x):<br>&gt;&gt; case let .Case1(y, x), .Case2(x, y):<br>&gt;&gt; case let .Case1(x), .Case2(x):<br>&gt;&gt; case .Case1(let x, _), .Case2(_, let x):<br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; Allow case labels with multiple patterns if the case labels match the following constraints:<br>&gt;&gt; <br>&gt;&gt; All patterns declare exactly the same variables.<br>&gt;&gt; The same variable has the same type in each pattern.<br>&gt;&gt; Therefore each pattern is able to produce the same variables for the case label.<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This should have no impact on existing code, although it should offer many opportunities for existing code to be simplified.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Using a closure or inline function<br>&gt;&gt; <br>&gt;&gt; Code repitition can be reduced with one pattern per &#39;case&#39; and handling the result with an inline function.<br>&gt;&gt; <br>&gt;&gt; func handleCases(value: MyEnum, apply: Int -&gt; Int) -&gt; Int {<br>&gt;&gt;     func handleX(x: Int) -&gt; Int {<br>&gt;&gt;         return apply(x) + 1<br>&gt;&gt;     }<br>&gt;&gt;     let out: Int<br>&gt;&gt;     switch value {<br>&gt;&gt;     case .Case1(let x, 2):<br>&gt;&gt;         out = handleX(x)<br>&gt;&gt;     case .Case2(2, let x):<br>&gt;&gt;         out = handleX(x)<br>&gt;&gt;     case .Case1, .Case2:<br>&gt;&gt;         out = -1<br>&gt;&gt;     }<br>&gt;&gt;     return out<br>&gt;&gt; }<br>&gt;&gt; This syntax is much more verbose, makes control flow more confusing, and has the limitations of the what the inline function may capture.<br>&gt;&gt; <br>&gt;&gt; In the above example apply cannot be @noescape because handleX captures it.<br>&gt;&gt; <br>&gt;&gt; Also in the above example if out is captured and assigned by handleX then it must be var, not let. This can produce shorter syntax, but is not as safe; out may accidentally be assigned more than once, additionally out also needs to initialized (which may not be possible or desirable).<br>&gt;&gt; <br>&gt;&gt; Extending the fallthrough syntax<br>&gt;&gt; <br>&gt;&gt; A similar reduction in code repetition can be achieved if fallthrough allowed variables to be mapped onto the next case, for example:<br>&gt;&gt; <br>&gt;&gt; switch test {<br>&gt;&gt;     case .Case1(let x, 2): <br>&gt;&gt;         fallthrough .Case2(_, x)<br>&gt;&gt;     case .Case2(3, .let x):<br>&gt;&gt;         print(&quot;x: \(x)&quot;)<br>&gt;&gt; }<br>&gt;&gt; This is not as intuitive, is a hack, and fallthrough should probably be discouraged. It is much more flexible, a programmer could adjust the value of x before fallthrough. Flexibility increases the chances of programmer error, perhaps not as much as code-repitition though.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/90d16e6d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Draft Proposal: Declare variables in &#39;case&#39; labels with multiple patterns</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 23, 2016 at 06:00:00pm</p></header><div class="content"><p>+1 too<br></p><p>-- E<br></p><p>&gt; On Jan 23, 2016, at 6:08 PM, Jed Lewison via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Also +1. I&#39;ve run into this a couple of times in the past week and the proposal would allow shorter and easier to read code.<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Jan 23, 2016, at 10:09 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; This would be great. Other pattern matching languages with ML heritage can do this, the only reason Swift couldn&#39;t was time.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 22, 2016, at 7:39 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like to discuss declaring variables in case labels with multiple patterns. I&#39;ve written a draft proposal, but I&#39;d like to discuss it first before formally proposing anything.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/therealbnut/swift-evolution/blob/a137202e41588b71d3c0511cff85f82ec5f65629/proposals/0023-declare-variables-in-case-labels-with-multiple-patterns.md &lt;https://github.com/therealbnut/swift-evolution/blob/a137202e41588b71d3c0511cff85f82ec5f65629/proposals/0023-declare-variables-in-case-labels-with-multiple-patterns.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In short:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch value {<br>&gt;&gt;&gt; case let .Case1(x, 2), .Case2(2, x):<br>&gt;&gt;&gt;     print(x)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The original proposal is here, it may need to adapt after discussion, so I&#39;ll try to keep the proposal at that link up-to-date.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Andrew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Declare variables in &#39;case&#39; labels with multiple patterns<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-0022 &lt;https://github.com/therealbnut/swift-evolution/blob/master/proposals/0023-declare-variables-in-case-labels-with-multiple-patterns.md&gt;<br>&gt;&gt;&gt; Author(s): Andrew Bennett &lt;https://github.com/therealbnut&gt;<br>&gt;&gt;&gt; Status: In Discussion<br>&gt;&gt;&gt; Review manager: Not In Review<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Swift 2, it is possible to match multiple patterns in cases. However cases cannot contain multiple patterns if the case declares variables.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The following code currently produces an error:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum MyEnum {<br>&gt;&gt;&gt;     case Case1(Int,Float)<br>&gt;&gt;&gt;     case Case2(Float,Int)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; switch value {<br>&gt;&gt;&gt; case let .Case1(x, 2), .Case2(2, x):<br>&gt;&gt;&gt;     print(x)<br>&gt;&gt;&gt; case .Case1, .Case2:<br>&gt;&gt;&gt;     break<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; The error is:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `case` labels with multiple patterns cannot declare variables. <br>&gt;&gt;&gt; This proposal aims to remove this error when each pattern declares the same variables with the same types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This change reduces repeditive code, and therefore reduces mistakes. It&#39;s consistent with multi-pattern matching when variables aren&#39;t defined.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Allow case labels with multiple patterns to declare patterns by matching variable names in each pattern.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Using the following enum:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum MyEnum {<br>&gt;&gt;&gt;     case Case1(Int,Float)<br>&gt;&gt;&gt;     case Case2(Float,Int)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; These cases should be possible:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case let .Case1(x, _), .Case2(_, x):<br>&gt;&gt;&gt; case let .Case1(y, x), .Case2(x, y):<br>&gt;&gt;&gt; case let .Case1(x), .Case2(x):<br>&gt;&gt;&gt; case .Case1(let x, _), .Case2(_, let x):<br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Allow case labels with multiple patterns if the case labels match the following constraints:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; All patterns declare exactly the same variables.<br>&gt;&gt;&gt; The same variable has the same type in each pattern.<br>&gt;&gt;&gt; Therefore each pattern is able to produce the same variables for the case label.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This should have no impact on existing code, although it should offer many opportunities for existing code to be simplified.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Using a closure or inline function<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Code repitition can be reduced with one pattern per &#39;case&#39; and handling the result with an inline function.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func handleCases(value: MyEnum, apply: Int -&gt; Int) -&gt; Int {<br>&gt;&gt;&gt;     func handleX(x: Int) -&gt; Int {<br>&gt;&gt;&gt;         return apply(x) + 1<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     let out: Int<br>&gt;&gt;&gt;     switch value {<br>&gt;&gt;&gt;     case .Case1(let x, 2):<br>&gt;&gt;&gt;         out = handleX(x)<br>&gt;&gt;&gt;     case .Case2(2, let x):<br>&gt;&gt;&gt;         out = handleX(x)<br>&gt;&gt;&gt;     case .Case1, .Case2:<br>&gt;&gt;&gt;         out = -1<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     return out<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; This syntax is much more verbose, makes control flow more confusing, and has the limitations of the what the inline function may capture.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the above example apply cannot be @noescape because handleX captures it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also in the above example if out is captured and assigned by handleX then it must be var, not let. This can produce shorter syntax, but is not as safe; out may accidentally be assigned more than once, additionally out also needs to initialized (which may not be possible or desirable).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Extending the fallthrough syntax<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A similar reduction in code repetition can be achieved if fallthrough allowed variables to be mapped onto the next case, for example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch test {<br>&gt;&gt;&gt;     case .Case1(let x, 2): <br>&gt;&gt;&gt;         fallthrough .Case2(_, x)<br>&gt;&gt;&gt;     case .Case2(3, .let x):<br>&gt;&gt;&gt;         print(&quot;x: \(x)&quot;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; This is not as intuitive, is a hack, and fallthrough should probably be discouraged. It is much more flexible, a programmer could adjust the value of x before fallthrough. Flexibility increases the chances of programmer error, perhaps not as much as code-repitition though.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/5c08dd0f/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Draft Proposal: Declare variables in &#39;case&#39; labels with multiple patterns</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 25, 2016 at 02:00:00pm</p></header><div class="content"><p>+1 in general, but as a nitpick I think this should be<br></p><p>case let .Case1(x, 2), let .Case2(2, x):<br></p><p>because the patterns really are distinct. (In other words, it seems weird to me that &quot;case let .Case1(x), .Case2(x)&quot; is different from &quot;case .Case2(x), let .Case1(x)&quot;.)<br></p><p>Jordan<br></p><p>&gt; On Jan 22, 2016, at 19:39, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; I&#39;d like to discuss declaring variables in case labels with multiple patterns. I&#39;ve written a draft proposal, but I&#39;d like to discuss it first before formally proposing anything.<br>&gt; <br>&gt; https://github.com/therealbnut/swift-evolution/blob/a137202e41588b71d3c0511cff85f82ec5f65629/proposals/0023-declare-variables-in-case-labels-with-multiple-patterns.md &lt;https://github.com/therealbnut/swift-evolution/blob/a137202e41588b71d3c0511cff85f82ec5f65629/proposals/0023-declare-variables-in-case-labels-with-multiple-patterns.md&gt;<br>&gt; <br>&gt; In short:<br>&gt; <br>&gt; switch value {<br>&gt; case let .Case1(x, 2), .Case2(2, x):<br>&gt;     print(x)<br>&gt; }<br>&gt; <br>&gt; The original proposal is here, it may need to adapt after discussion, so I&#39;ll try to keep the proposal at that link up-to-date.<br>&gt; <br>&gt; Thanks,<br>&gt; Andrew<br>&gt; <br>&gt; Declare variables in &#39;case&#39; labels with multiple patterns<br>&gt; <br>&gt; Proposal: SE-0022 &lt;https://github.com/therealbnut/swift-evolution/blob/master/proposals/0023-declare-variables-in-case-labels-with-multiple-patterns.md&gt;<br>&gt; Author(s): Andrew Bennett &lt;https://github.com/therealbnut&gt;<br>&gt; Status: In Discussion<br>&gt; Review manager: Not In Review<br>&gt; Introduction<br>&gt; <br>&gt; In Swift 2, it is possible to match multiple patterns in cases. However cases cannot contain multiple patterns if the case declares variables.<br>&gt; <br>&gt; The following code currently produces an error:<br>&gt; <br>&gt; enum MyEnum {<br>&gt;     case Case1(Int,Float)<br>&gt;     case Case2(Float,Int)<br>&gt; }<br>&gt; switch value {<br>&gt; case let .Case1(x, 2), .Case2(2, x):<br>&gt;     print(x)<br>&gt; case .Case1, .Case2:<br>&gt;     break<br>&gt; }<br>&gt; The error is:<br>&gt; <br>&gt; `case` labels with multiple patterns cannot declare variables. <br>&gt; This proposal aims to remove this error when each pattern declares the same variables with the same types.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; This change reduces repeditive code, and therefore reduces mistakes. It&#39;s consistent with multi-pattern matching when variables aren&#39;t defined.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; Allow case labels with multiple patterns to declare patterns by matching variable names in each pattern.<br>&gt; <br>&gt; Using the following enum:<br>&gt; <br>&gt; enum MyEnum {<br>&gt;     case Case1(Int,Float)<br>&gt;     case Case2(Float,Int)<br>&gt; }<br>&gt; These cases should be possible:<br>&gt; <br>&gt; case let .Case1(x, _), .Case2(_, x):<br>&gt; case let .Case1(y, x), .Case2(x, y):<br>&gt; case let .Case1(x), .Case2(x):<br>&gt; case .Case1(let x, _), .Case2(_, let x):<br>&gt; Detailed design<br>&gt; <br>&gt; Allow case labels with multiple patterns if the case labels match the following constraints:<br>&gt; <br>&gt; All patterns declare exactly the same variables.<br>&gt; The same variable has the same type in each pattern.<br>&gt; Therefore each pattern is able to produce the same variables for the case label.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; This should have no impact on existing code, although it should offer many opportunities for existing code to be simplified.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Using a closure or inline function<br>&gt; <br>&gt; Code repitition can be reduced with one pattern per &#39;case&#39; and handling the result with an inline function.<br>&gt; <br>&gt; func handleCases(value: MyEnum, apply: Int -&gt; Int) -&gt; Int {<br>&gt;     func handleX(x: Int) -&gt; Int {<br>&gt;         return apply(x) + 1<br>&gt;     }<br>&gt;     let out: Int<br>&gt;     switch value {<br>&gt;     case .Case1(let x, 2):<br>&gt;         out = handleX(x)<br>&gt;     case .Case2(2, let x):<br>&gt;         out = handleX(x)<br>&gt;     case .Case1, .Case2:<br>&gt;         out = -1<br>&gt;     }<br>&gt;     return out<br>&gt; }<br>&gt; This syntax is much more verbose, makes control flow more confusing, and has the limitations of the what the inline function may capture.<br>&gt; <br>&gt; In the above example apply cannot be @noescape because handleX captures it.<br>&gt; <br>&gt; Also in the above example if out is captured and assigned by handleX then it must be var, not let. This can produce shorter syntax, but is not as safe; out may accidentally be assigned more than once, additionally out also needs to initialized (which may not be possible or desirable).<br>&gt; <br>&gt; Extending the fallthrough syntax<br>&gt; <br>&gt; A similar reduction in code repetition can be achieved if fallthrough allowed variables to be mapped onto the next case, for example:<br>&gt; <br>&gt; switch test {<br>&gt;     case .Case1(let x, 2): <br>&gt;         fallthrough .Case2(_, x)<br>&gt;     case .Case2(3, .let x):<br>&gt;         print(&quot;x: \(x)&quot;)<br>&gt; }<br>&gt; This is not as intuitive, is a hack, and fallthrough should probably be discouraged. It is much more flexible, a programmer could adjust the value of x before fallthrough. Flexibility increases the chances of programmer error, perhaps not as much as code-repitition though.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/4197b1d2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Draft Proposal: Declare variables in &#39;case&#39; labels with multiple patterns</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 26, 2016 at 12:00:00pm</p></header><div class="content"><p>Thanks Jordan,<br></p><p>I wrote a few responses, mostly misinterpreting what you meant, in the end<br>I agree with you.<br></p><p>It&#39;s more consistent to have a let in front of each case label, so it&#39;s of<br>the form:<br>    case &lt;PATTERN&gt;, &lt;PATTERN&gt;, &lt;PATTERN&gt;, ...:<br></p><p>Each pattern is self contained, individually defining whether it&#39;s:<br> * let .Case1(1,x), or<br> * .Case1(1, let x)<br></p><p>Yesterday I updated the proposal to state these changes to the existing<br>Swift grammar:<br></p><p>+ enum-case-pattern-list → enum-case-pattern |+<br>  enum-case-pattern , enum-case-pattern-list+ pattern  →<br>enum-case-pattern-list- pattern  → enum-case-pattern<br></p><p><br>https://github.com/therealbnut/swift-evolution/blob/therealbnut-case-match/proposals/0023-declare-variables-in-case-labels-with-multiple-patterns.md<br></p><p>It seems that I accidentally already did what you proposed, because the<br>grammar was structured like you suggested.<br></p><p>I&#39;ll fix the examples in the proposal. It&#39;s certainly shorter to only add<br>`let` once, but it probably complicates the grammar and pairs the let with<br>the case rather than the pattern (which is inconsistent).<br></p><p>The relevant bits of the current grammar:<br></p><p>    enum-case-pattern          *→* type-identifier­ [opt]­ .<br>­enum-case-name­ tuple-pattern­ [opt]<br>    tuple-pattern              *→* (­tuple-pattern-element-list­ [opt]­)­<br>    tuple-pattern-element-list *→* tuple-pattern-element­ |<br>                                 tuple-pattern-element­ ,<br>­tuple-pattern-element-list<br>    tuple-pattern-element      *→* pattern<br>    pattern                    *→* value-binding-pattern<br>    value-binding-pattern      *→* *var­* pattern­ |<br>*                                 let* ­pattern­<br></p><p><br></p><p>On Tue, Jan 26, 2016 at 9:15 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; +1 in general, but as a nitpick I think this should be<br>&gt;<br>&gt; case let .Case1(x, 2), let .Case2(2, x):<br>&gt;<br>&gt;<br>&gt; because the patterns really are distinct. (In other words, it seems weird<br>&gt; to me that &quot;case let .Case1(x), .Case2(x)&quot; is different from &quot;case<br>&gt; .Case2(x), let .Case1(x)&quot;.)<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt; On Jan 22, 2016, at 19:39, Andrew Bennett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi,<br>&gt;<br>&gt; I&#39;d like to discuss declaring variables in case labels with multiple<br>&gt; patterns. I&#39;ve written a draft proposal, but I&#39;d like to discuss it first<br>&gt; before formally proposing anything.<br>&gt;<br>&gt;<br>&gt; https://github.com/therealbnut/swift-evolution/blob/a137202e41588b71d3c0511cff85f82ec5f65629/proposals/0023-declare-variables-in-case-labels-with-multiple-patterns.md<br>&gt;<br>&gt; In short:<br>&gt;<br>&gt; switch value {<br>&gt; case let .Case1(x, 2), .Case2(2, x):<br>&gt;     print(x)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; The original proposal is here, it may need to adapt after discussion, so<br>&gt; I&#39;ll try to keep the proposal at that link up-to-date.<br>&gt;<br>&gt; Thanks,<br>&gt; Andrew<br>&gt;<br>&gt; Declare variables in &#39;case&#39; labels with multiple patterns<br>&gt;<br>&gt;    - Proposal: SE-0022<br>&gt;    &lt;https://github.com/therealbnut/swift-evolution/blob/master/proposals/0023-declare-variables-in-case-labels-with-multiple-patterns.md&gt;<br>&gt;    - Author(s): Andrew Bennett &lt;https://github.com/therealbnut&gt;<br>&gt;    - Status: *In Discussion*<br>&gt;    - Review manager: *Not In Review*<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; In Swift 2, it is possible to match multiple patterns in cases. However<br>&gt; cases cannot contain multiple patterns if the case declares variables.<br>&gt;<br>&gt; The following code currently produces an error:<br>&gt;<br>&gt; enum MyEnum {<br>&gt;     case Case1(Int,Float)<br>&gt;     case Case2(Float,Int)<br>&gt; }<br>&gt; switch value {<br>&gt; case let .Case1(x, 2), .Case2(2, x):<br>&gt;     print(x)<br>&gt; case .Case1, .Case2:<br>&gt;     break<br>&gt; }<br>&gt;<br>&gt; The error is:<br>&gt;<br>&gt; `case` labels with multiple patterns cannot declare variables.<br>&gt;<br>&gt; This proposal aims to remove this error when each pattern declares the<br>&gt; same variables with the same types.<br>&gt;<br>&gt; Motivation<br>&gt;<br>&gt; This change reduces repeditive code, and therefore reduces mistakes. It&#39;s<br>&gt; consistent with multi-pattern matching when variables aren&#39;t defined.<br>&gt; Proposed solution<br>&gt;<br>&gt; Allow case labels with multiple patterns to declare patterns by matching<br>&gt; variable names in each pattern.<br>&gt;<br>&gt; Using the following enum:<br>&gt;<br>&gt; enum MyEnum {<br>&gt;     case Case1(Int,Float)<br>&gt;     case Case2(Float,Int)<br>&gt; }<br>&gt;<br>&gt; These cases should be possible:<br>&gt;<br>&gt; case let .Case1(x, _), .Case2(_, x):<br>&gt; case let .Case1(y, x), .Case2(x, y):<br>&gt; case let .Case1(x), .Case2(x):<br>&gt; case .Case1(let x, _), .Case2(_, let x):<br>&gt;<br>&gt; Detailed design<br>&gt;<br>&gt; Allow case labels with multiple patterns if the case labels match the<br>&gt; following constraints:<br>&gt;<br>&gt;    - All patterns declare exactly the same variables.<br>&gt;    - The same variable has the same type in each pattern.<br>&gt;<br>&gt; Therefore each pattern is able to produce the same variables for the case<br>&gt; label.<br>&gt; Impact on existing code<br>&gt;<br>&gt; This should have no impact on existing code, although it should offer many<br>&gt; opportunities for existing code to be simplified.<br>&gt; Alternatives considered<br>&gt; Using a closure or inline function<br>&gt;<br>&gt; Code repitition can be reduced with one pattern per &#39;case&#39; and handling<br>&gt; the result with an inline function.<br>&gt;<br>&gt; func handleCases(value: MyEnum, apply: Int -&gt; Int) -&gt; Int {<br>&gt;     func handleX(x: Int) -&gt; Int {<br>&gt;         return apply(x) + 1<br>&gt;     }<br>&gt;     let out: Int<br>&gt;     switch value {<br>&gt;     case .Case1(let x, 2):<br>&gt;         out = handleX(x)<br>&gt;     case .Case2(2, let x):<br>&gt;         out = handleX(x)<br>&gt;     case .Case1, .Case2:<br>&gt;         out = -1<br>&gt;     }<br>&gt;     return out<br>&gt; }<br>&gt;<br>&gt; This syntax is much more verbose, makes control flow more confusing, and<br>&gt; has the limitations of the what the inline function may capture.<br>&gt;<br>&gt; In the above example apply cannot be @noescape because handleX captures<br>&gt; it.<br>&gt;<br>&gt; Also in the above example if out is captured and assigned by handleX then<br>&gt; it must be var, not let. This can produce shorter syntax, but is not as<br>&gt; safe; out may accidentally be assigned more than once, additionally out also<br>&gt; needs to initialized (which may not be possible or desirable).<br>&gt; Extending the fallthrough syntax<br>&gt;<br>&gt; A similar reduction in code repetition can be achieved if fallthrough<br>&gt; allowed variables to be mapped onto the next case, for example:<br>&gt;<br>&gt; switch test {<br>&gt;     case .Case1(let x, 2):<br>&gt;         fallthrough .Case2(_, x)<br>&gt;     case .Case2(3, .let x):<br>&gt;         print(&quot;x: \(x)&quot;)<br>&gt; }<br>&gt;<br>&gt; This is not as intuitive, is a hack, and fallthrough should probably be<br>&gt; discouraged. It is much more flexible, a programmer could adjust the value<br>&gt; of x before fallthrough. Flexibility increases the chances of programmer<br>&gt; error, perhaps not as much as code-repitition though.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/5d7a94c3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
