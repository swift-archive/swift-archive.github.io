<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b9904260218b6d7942782c2b2355f2aa?s=50"></div><header><strong>PointerIntPair alignment</strong> from <string>William Dillon</string> &lt;william at housedillon.com&gt;<p>January 28, 2016 at 07:00:00pm</p></header><div class="content"><p>Hi everyone,<br></p><p>I’ve been working on rebasing my Arm patch with the latest apple/master.  There is an assertion thrown by the swift compiler that the pointer in PointerIntPair is insufficiently aligned (using ProtocolConformance *).  I’ve found where the allocator used for these objects, the specified alignment, and the definition of the NumLowBitsAvailable for ProtocolConformance is.  The problem is that on these systems (I’m not sure whether it’s an ARM problem or a 32-bit problem) the alignment specified in the allocator is insufficient for the stated NumLowBitsAvailable.<br></p><p>For convince, the allocator is in ProtocolConformance.h:<br></p><p>  // Only allow allocation of protocol conformances using the allocator in<br>  // ASTContext or by doing a placement new.<br>  void *operator new(size_t bytes, ASTContext &amp;context,<br>                     AllocationArena arena,<br>                     unsigned alignment = alignof(ProtocolConformance)); // (4-byte aligned)<br>  void *operator new(size_t bytes, void *mem) {<br>    assert(mem);<br>    return mem;<br>  }<br></p><p><br>and the definition of NumLowBitsAvailable is in TypeAlignments.h:<br></p><p>constexpr size_t DeclAlignInBits = 3;<br>...<br>LLVM_DECLARE_TYPE_ALIGNMENT(swift::ProtocolConformance, swift::DeclAlignInBits)<br></p><p>So, my question is this:  There are tons of ways to solve the problem, but I think all but one are a hack.  What method of solving the problem best matches the coding conventions and the overall architecture (which I readily admit that I don’t fully understand)?<br></p><p>Thanks! <br>- Will<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>PointerIntPair alignment</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 28, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 28, 2016, at 7:10 PM, William Dillon via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi everyone,<br>&gt; <br>&gt; I’ve been working on rebasing my Arm patch with the latest apple/master.  There is an assertion thrown by the swift compiler that the pointer in PointerIntPair is insufficiently aligned (using ProtocolConformance *).  I’ve found where the allocator used for these objects, the specified alignment, and the definition of the NumLowBitsAvailable for ProtocolConformance is.  The problem is that on these systems (I’m not sure whether it’s an ARM problem or a 32-bit problem) the alignment specified in the allocator is insufficient for the stated NumLowBitsAvailable.<br>&gt; <br>&gt; For convince, the allocator is in ProtocolConformance.h:<br>&gt; <br>&gt;  // Only allow allocation of protocol conformances using the allocator in<br>&gt;  // ASTContext or by doing a placement new.<br>&gt;  void *operator new(size_t bytes, ASTContext &amp;context,<br>&gt;                     AllocationArena arena,<br>&gt;                     unsigned alignment = alignof(ProtocolConformance)); // (4-byte aligned)<br>&gt;  void *operator new(size_t bytes, void *mem) {<br>&gt;    assert(mem);<br>&gt;    return mem;<br>&gt;  }<br>&gt; <br>&gt; <br>&gt; and the definition of NumLowBitsAvailable is in TypeAlignments.h:<br>&gt; <br>&gt; constexpr size_t DeclAlignInBits = 3;<br>&gt; ...<br>&gt; LLVM_DECLARE_TYPE_ALIGNMENT(swift::ProtocolConformance, swift::DeclAlignInBits)<br>&gt; <br>&gt; So, my question is this:  There are tons of ways to solve the problem, but I think all but one are a hack.  What method of solving the problem best matches the coding conventions and the overall architecture (which I readily admit that I don’t fully understand)?<br></p><p>Hi William,<br></p><p>Does it help to add an alignment to the ProtocolConformance type, change:<br></p><p>class ProtocolConformance {<br></p><p>to:<br></p><p>class alignas(1 &lt;&lt; DeclAlignInBits) ProtocolConformance {<br></p><p><br>?<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b9904260218b6d7942782c2b2355f2aa?s=50"></div><header><strong>PointerIntPair alignment</strong> from <string>William Dillon</string> &lt;william at housedillon.com&gt;<p>January 28, 2016 at 08:00:00pm</p></header><div class="content"><p>Perfect.  That sounds like a great solution, I’l try it out.  Thanks, Chris!<br></p><p>&gt; On Jan 28, 2016, at 8:42 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 28, 2016, at 7:10 PM, William Dillon via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi everyone,<br>&gt;&gt; <br>&gt;&gt; I’ve been working on rebasing my Arm patch with the latest apple/master.  There is an assertion thrown by the swift compiler that the pointer in PointerIntPair is insufficiently aligned (using ProtocolConformance *).  I’ve found where the allocator used for these objects, the specified alignment, and the definition of the NumLowBitsAvailable for ProtocolConformance is.  The problem is that on these systems (I’m not sure whether it’s an ARM problem or a 32-bit problem) the alignment specified in the allocator is insufficient for the stated NumLowBitsAvailable.<br>&gt;&gt; <br>&gt;&gt; For convince, the allocator is in ProtocolConformance.h:<br>&gt;&gt; <br>&gt;&gt; // Only allow allocation of protocol conformances using the allocator in<br>&gt;&gt; // ASTContext or by doing a placement new.<br>&gt;&gt; void *operator new(size_t bytes, ASTContext &amp;context,<br>&gt;&gt;                    AllocationArena arena,<br>&gt;&gt;                    unsigned alignment = alignof(ProtocolConformance)); // (4-byte aligned)<br>&gt;&gt; void *operator new(size_t bytes, void *mem) {<br>&gt;&gt;   assert(mem);<br>&gt;&gt;   return mem;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; and the definition of NumLowBitsAvailable is in TypeAlignments.h:<br>&gt;&gt; <br>&gt;&gt; constexpr size_t DeclAlignInBits = 3;<br>&gt;&gt; ...<br>&gt;&gt; LLVM_DECLARE_TYPE_ALIGNMENT(swift::ProtocolConformance, swift::DeclAlignInBits)<br>&gt;&gt; <br>&gt;&gt; So, my question is this:  There are tons of ways to solve the problem, but I think all but one are a hack.  What method of solving the problem best matches the coding conventions and the overall architecture (which I readily admit that I don’t fully understand)?<br>&gt; <br>&gt; Hi William,<br>&gt; <br>&gt; Does it help to add an alignment to the ProtocolConformance type, change:<br>&gt; <br>&gt; class ProtocolConformance {<br>&gt; <br>&gt; to:<br>&gt; <br>&gt; class alignas(1 &lt;&lt; DeclAlignInBits) ProtocolConformance {<br>&gt; <br>&gt; <br>&gt; ?<br>&gt; <br>&gt; -Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160128/38c06cd3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
