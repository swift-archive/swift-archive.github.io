<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Meta] Let&#39;s talk TouchBar + Unicode</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>October 28, 2016 at 05:00:00pm</p></header><div class="content"><p>Given that Swift supports unicode, and it looks like this TouchBar will make typing relevant characters/symbols much more accessible/discoverable, I think we should move forward with the assumption that we will be able to type (somehow) whatever symbol we feel best represents something, and we should start looking for opportunities to use this where it makes sense.<br></p><p><br>The big issue is how to provide similar support for pre-touchbar devices (and non-Apple devices), and there are lots of options (of which I will list just a few below):<br></p><p>‚Ä¢ Have emojis and symbols in the autocomplete list when appropriate by typing human readable names (i.e. ‚ÄòDog Face‚Äô instead of U+1F436, or ‚Äòunion‚Äô for ‚à™).  Optionally, we could have an easy symbol (e.g. $ or ^) which hints to the autocomplete that we might want a symbol (similar to how typing @ in Facebook brings up an autocomplete list of friends).  Thus typing ‚Äò^u‚Äô would bring up &#39;‚à™&#39; near the top of the list (and you could continue typing ‚Äò^union‚Äô if needed to disambiguate)<br></p><p>‚Ä¢ Allow autocomplete when using the short code (e.g. :dog: for üê∂)<br></p><p>‚Ä¢ Have a bar along the bottom of the screen (kind of like the one which shows up when a keyboard is docked with an iPad) which maps to the function keys, and has similar options to what the TouchBar would have.<br></p><p>‚Ä¢ For those using just a text editor, utilities like TextExpander (or the built in text expanding capabilities of OS X &amp; other platforms).  Pretty much every platform has a built in way to type unicode/emoji.  It may not be the easiest, but hey, that is true of many platforms in general.  There typically exist utilities to make it easier.<br></p><p>.<br></p><p>My main point, is that we should proceed as if everything we want to do in terms of input is possible, and trust that the Xcode team (and other IDE developers) will do what is required to make it work (or will speak up in particular cases to tell us we are headed in the wrong direction)‚Ä¶ as opposed to assuming that things are impossible and not pushing the limits at all.<br></p><p>Note: I am not saying we should use these things frivolously‚Ä¶ just that we shouldn‚Äôt be afraid to use them when they make a lot of sense (We have previously rejected several proposals because they are hard to type on one kind of keyboard or another).<br></p><p>Thanks,<br>Jon<br></p><p>PS.  I am also ok having some overlap (e.g. both the union operator and ‚ÄòformUnion‚Äô, where one maps to the other) while technology is disseminating.  They can always go through a depreciation cycle later if we decide to consolidate.  I just don‚Äôt think we should wait, because then we will never start...<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Meta] Let&#39;s talk TouchBar + Unicode</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 29, 2016 at 12:00:00am</p></header><div class="content"><p>-1. I&#39;m all for full and complete Unicode support in Swift so that each<br>person can use their native language to the fullest. But there is value in<br>saying that the working language for Swift evolution is U.S. English, the<br>working language for the Swift standard library API is U.S. English, and<br>the working character set for the core language facilities is ASCII. We&#39;ve<br>discussed and rejected union operators in the stdlib; it was a heated<br>discussion, but we simply can&#39;t revisit API naming every six months. The<br>same argument about the touch bar can be said for iPad soft keyboards.<br></p><p>On Fri, Oct 28, 2016 at 7:35 PM Jonathan Hull via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Given that Swift supports unicode, and it looks like this TouchBar will<br>&gt; make typing relevant characters/symbols much more accessible/discoverable,<br>&gt; I think we should move forward with the assumption that we will be able to<br>&gt; type (somehow) whatever symbol we feel best represents something, and we<br>&gt; should start looking for opportunities to use this where it makes sense.<br>&gt;<br>&gt;<br>&gt; The big issue is how to provide similar support for pre-touchbar devices<br>&gt; (and non-Apple devices), and there are lots of options (of which I will<br>&gt; list just a few below):<br>&gt;<br>&gt; ‚Ä¢ Have emojis and symbols in the autocomplete list when appropriate by<br>&gt; typing human readable names (i.e. ‚ÄòDog Face‚Äô instead of U+1F436, or ‚Äòunion‚Äô<br>&gt; for ‚à™).  Optionally, we could have an easy symbol (e.g. $ or ^) which hints<br>&gt; to the autocomplete that we might want a symbol (similar to how typing @ in<br>&gt; Facebook brings up an autocomplete list of friends).  Thus typing ‚Äò^u‚Äô<br>&gt; would bring up &#39;‚à™&#39; near the top of the list (and you could continue typing<br>&gt; ‚Äò^union‚Äô if needed to disambiguate)<br>&gt;<br>&gt; ‚Ä¢ Allow autocomplete when using the short code (e.g. :dog: for üê∂)<br>&gt;<br>&gt; ‚Ä¢ Have a bar along the bottom of the screen (kind of like the one which<br>&gt; shows up when a keyboard is docked with an iPad) which maps to the function<br>&gt; keys, and has similar options to what the TouchBar would have.<br>&gt;<br>&gt; ‚Ä¢ For those using just a text editor, utilities like TextExpander (or the<br>&gt; built in text expanding capabilities of OS X &amp; other platforms).  Pretty<br>&gt; much every platform has a built in way to type unicode/emoji.  It may not<br>&gt; be the easiest, but hey, that is true of many platforms in general.  There<br>&gt; typically exist utilities to make it easier.<br>&gt;<br>&gt; .<br>&gt;<br>&gt; My main point, is that we should proceed as if everything we want to do in<br>&gt; terms of input is possible, and trust that the Xcode team (and other IDE<br>&gt; developers) will do what is required to make it work (or will speak up in<br>&gt; particular cases to tell us we are headed in the wrong direction)‚Ä¶ as<br>&gt; opposed to assuming that things are impossible and not pushing the limits<br>&gt; at all.<br>&gt;<br>&gt; Note: I am not saying we should use these things frivolously‚Ä¶ just that we<br>&gt; shouldn‚Äôt be afraid to use them when they make a lot of sense (We have<br>&gt; previously rejected several proposals because they are hard to type on one<br>&gt; kind of keyboard or another).<br>&gt;<br>&gt; Thanks,<br>&gt; Jon<br>&gt;<br>&gt; PS.  I am also ok having some overlap (e.g. both the union operator and<br>&gt; ‚ÄòformUnion‚Äô, where one maps to the other) while technology is<br>&gt; disseminating.  They can always go through a depreciation cycle later if we<br>&gt; decide to consolidate.  I just don‚Äôt think we should wait, because then we<br>&gt; will never start...<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161029/a702ba19/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Meta] Let&#39;s talk TouchBar + Unicode</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>October 28, 2016 at 06:00:00pm</p></header><div class="content"><p>You are against even making it simpler to type/use the characters for those who want to use them?  Hardcore.<br></p><p><br>&gt; On Oct 28, 2016, at 5:45 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; -1. I&#39;m all for full and complete Unicode support in Swift so that each person can use their native language to the fullest. But there is value in saying that the working language for Swift evolution is U.S. English, the working language for the Swift standard library API is U.S. English, and the working character set for the core language facilities is ASCII. We&#39;ve discussed and rejected union operators in the stdlib; it was a heated discussion, but we simply can&#39;t revisit API naming every six months. The same argument about the touch bar can be said for iPad soft keyboards.<br>&gt; <br>&gt; On Fri, Oct 28, 2016 at 7:35 PM Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Given that Swift supports unicode, and it looks like this TouchBar will make typing relevant characters/symbols much more accessible/discoverable, I think we should move forward with the assumption that we will be able to type (somehow) whatever symbol we feel best represents something, and we should start looking for opportunities to use this where it makes sense.<br>&gt; <br>&gt; <br>&gt; The big issue is how to provide similar support for pre-touchbar devices (and non-Apple devices), and there are lots of options (of which I will list just a few below):<br>&gt; <br>&gt; ‚Ä¢ Have emojis and symbols in the autocomplete list when appropriate by typing human readable names (i.e. ‚ÄòDog Face‚Äô instead of U+1F436, or ‚Äòunion‚Äô for ‚à™).  Optionally, we could have an easy symbol (e.g. $ or ^) which hints to the autocomplete that we might want a symbol (similar to how typing @ in Facebook brings up an autocomplete list of friends).  Thus typing ‚Äò^u‚Äô would bring up &#39;‚à™&#39; near the top of the list (and you could continue typing ‚Äò^union‚Äô if needed to disambiguate)<br>&gt; <br>&gt; ‚Ä¢ Allow autocomplete when using the short code (e.g. :dog: for üê∂)<br>&gt; <br>&gt; ‚Ä¢ Have a bar along the bottom of the screen (kind of like the one which shows up when a keyboard is docked with an iPad) which maps to the function keys, and has similar options to what the TouchBar would have.<br>&gt; <br>&gt; ‚Ä¢ For those using just a text editor, utilities like TextExpander (or the built in text expanding capabilities of OS X &amp; other platforms).  Pretty much every platform has a built in way to type unicode/emoji.  It may not be the easiest, but hey, that is true of many platforms in general.  There typically exist utilities to make it easier.<br>&gt; <br>&gt; .<br>&gt; <br>&gt; My main point, is that we should proceed as if everything we want to do in terms of input is possible, and trust that the Xcode team (and other IDE developers) will do what is required to make it work (or will speak up in particular cases to tell us we are headed in the wrong direction)‚Ä¶ as opposed to assuming that things are impossible and not pushing the limits at all.<br>&gt; <br>&gt; Note: I am not saying we should use these things frivolously‚Ä¶ just that we shouldn‚Äôt be afraid to use them when they make a lot of sense (We have previously rejected several proposals because they are hard to type on one kind of keyboard or another).<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt; PS.  I am also ok having some overlap (e.g. both the union operator and ‚ÄòformUnion‚Äô, where one maps to the other) while technology is disseminating.  They can always go through a depreciation cycle later if we decide to consolidate.  I just don‚Äôt think we should wait, because then we will never start...<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161028/40f599de/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Meta] Let&#39;s talk TouchBar + Unicode</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>October 28, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Oct 28, 2016, at 5:45 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; -1. I&#39;m all for full and complete Unicode support in Swift so that each person can use their native language to the fullest. But there is value in saying that the working language for Swift evolution is U.S. English, the working language for the Swift standard library API is U.S. English, and the working character set for the core language facilities is ASCII. We&#39;ve discussed and rejected union operators in the stdlib; it was a heated discussion, but we simply can&#39;t revisit API naming every six months.<br>It was mainly rejected based on being too hard to type.  It turns out that that decision was short-sighted. I am saying we need to stop being short-sighted.  I honestly don‚Äôt see the value in limiting ourselves to ASCII anymore.  Let‚Äôs be expressive in the best way we can.  If a symbol is more expressive in one case, let‚Äôs use it.  If a word is more expressive in another, let‚Äôs use that.  But applying (now artificial/unnecessary) constraints because it is what our forefathers did is not helpful.<br></p><p>I am reminded of the time, when I was writing my thesis (on Undo) in User Experience, they were trying to force us to put our charts, tables, and figures in a very unreadable format.  Why?  Because it made it easier for printing presses in the 1850‚Äôs, and the rules had been codified based on that.  It didn‚Äôt matter that we were now printing on laser printers. Everyone was forced to do something suboptimal because it was what those in charge had been forced to do in their day as well.  Arbitrarily forcing part of the system to be restricted to ASCII despite the fact that it now supports unicode is similarly silly (and similarly harmful).<br></p><p><br>&gt; The same argument about the touch bar can be said for iPad soft keyboards.<br>Yes, yes it can. Programming on the iPad will be a real thing before you know it.  We need to avoid limiting ourselves to the constraints of the 1970s.<br></p><p>Thanks,<br>Jon<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Meta] Let&#39;s talk TouchBar + Unicode</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 29, 2016 at 02:00:00am</p></header><div class="content"><p>There are two proposals in here that you&#39;re mixing together.<br></p><p>One has to do with improvements to Xcode for working with Unicode. I&#39;d be<br>all for that, as I&#39;ve just said, but afaict this is not in scope for Swift<br>evolution.<br></p><p>The other has to do with expanding Swift standard library and core library<br>APIs beyond the ASCII character set. I&#39;m -1 on that for the reasons I&#39;ve<br>outlined above. Reworded, a very good reason to limit the standard library<br>itself to ASCII APIs is the same reason we limit the library to (a<br>restricted subset of) U.S. English. We do not all share a common first<br>language or recognize the same characters, but these are reasonable common<br>denominators with historical precedent in computer science *and* reasonably<br>wide international recognition.<br></p><p>Given the adage here that code is more frequently read than written, it is<br>unreasonable to require someone to master both &quot;form union&quot; and the union<br>operator when one of these will do. While you and I are comfortable with<br>set algebra notation, not everyone who uses Swift will be, and currently<br>they *do not have to be* in order to be perfectly proficient at Swift. It<br>does not sway me that you can now more easily type a character on a<br>potential future device. It matters to me that someone not familiar with<br>set algebra would have a hard time even looking up what such a non-ASCII<br>character is when he or she first encounters it in, say, a textbook.<br></p><p>Now, to be clear, a third-party Swift library should be free to adopt any<br>language or character set, and we should make the tooling as robust and<br>convenient as possible for that use case, but the choice for Swift standard<br>library APIs--themselves deliberately restricted in scope--should be the<br>minimum required for clearly expressing what these APIs are. A person<br>should not need to buy a special keyboard or device, or know how to work<br>the option/alt key, in order to write the less-than-or-equal-to operator.<br>OTOH, there&#39;s nothing wrong with a third-party project to decide that its<br>API will be Sanskrit-only and require proficiency in the associated script<br>for use.<br></p><p>On Fri, Oct 28, 2016 at 20:54 Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Oct 28, 2016, at 5:45 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; -1. I&#39;m all for full and complete Unicode support in Swift so that each<br>&gt; person can use their native language to the fullest. But there is value in<br>&gt; saying that the working language for Swift evolution is U.S. English, the<br>&gt; working language for the Swift standard library API is U.S. English, and<br>&gt; the working character set for the core language facilities is ASCII. We&#39;ve<br>&gt; discussed and rejected union operators in the stdlib; it was a heated<br>&gt; discussion, but we simply can&#39;t revisit API naming every six months.<br>&gt; It was mainly rejected based on being too hard to type.  It turns out that<br>&gt; that decision was short-sighted. I am saying we need to stop being<br>&gt; short-sighted.  I honestly don‚Äôt see the value in limiting ourselves to<br>&gt; ASCII anymore.  Let‚Äôs be expressive in the best way we can.  If a symbol is<br>&gt; more expressive in one case, let‚Äôs use it.  If a word is more expressive in<br>&gt; another, let‚Äôs use that.  But applying (now artificial/unnecessary)<br>&gt; constraints because it is what our forefathers did is not helpful.<br>&gt;<br>&gt; I am reminded of the time, when I was writing my thesis (on Undo) in User<br>&gt; Experience, they were trying to force us to put our charts, tables, and<br>&gt; figures in a very unreadable format.  Why?  Because it made it easier for<br>&gt; printing presses in the 1850‚Äôs, and the rules had been codified based on<br>&gt; that.  It didn‚Äôt matter that we were now printing on laser printers.<br>&gt; Everyone was forced to do something suboptimal because it was what those in<br>&gt; charge had been forced to do in their day as well.  Arbitrarily forcing<br>&gt; part of the system to be restricted to ASCII despite the fact that it now<br>&gt; supports unicode is similarly silly (and similarly harmful).<br>&gt;<br>&gt;<br>&gt; &gt; The same argument about the touch bar can be said for iPad soft<br>&gt; keyboards.<br>&gt; Yes, yes it can. Programming on the iPad will be a real thing before you<br>&gt; know it.  We need to avoid limiting ourselves to the constraints of the<br>&gt; 1970s.<br>&gt;<br>&gt; Thanks,<br>&gt; Jon<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161029/75115ec9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>[Meta] Let&#39;s talk TouchBar + Unicode</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>October 29, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 29 Oct 2016, at 04:22, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The other has to do with expanding Swift standard library and core library APIs beyond the ASCII character set. I&#39;m -1 on that for the reasons I&#39;ve outlined above. Reworded, a very good reason to limit the standard library itself to ASCII APIs is the same reason we limit the library to (a restricted subset of) U.S. English. We do not all share a common first language or recognize the same characters, but these are reasonable common denominators with historical precedent in computer science *and* reasonably wide international recognition.<br></p><p>+1, Well said.<br></p><p><br>Regards,<br>Rien<br></p><p>Site: http://balancingrock.nl<br>Blog: http://swiftrien.blogspot.com<br>Github: http://github.com/Swiftrien<br>Project: http://swiftfire.nl<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Meta] Let&#39;s talk TouchBar + Unicode</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>October 29, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Oct 28, 2016, at 7:22 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; A person should not need to buy a special keyboard or device, or know how to work the option/alt key, in order to write the less-than-or-equal-to operator.<br></p><p>But my main point is that the symbols painted on the physical keyboard are no longer our only (or even best) method of discovery.  If ‚â§ comes up in the auto-complete when you write &lt; or &lt;=, then it solves the discovery issue. We can even use this to teach the option/alt key method (this is the what the Mac does to teach command keys associated with menu items).<br></p><p>Your point about the search-ability of symbols is an important one, but that can also be solved with appropriate UI for discovery of the associated (searchable) keywords.<br></p><p>Swift is a language being designed for the next 20-30 years, we shouldn‚Äôt be limiting ourselves based on technology that is already being replaced (as you mentioned many of the devices people use everyday already have a soft keyboard‚Ä¶ and Ive said the TouchBar was just the beginning of a new direction).  We need to aim for where the puck is going to be‚Ä¶<br></p><p>Thanks,<br>Jon<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161029/aac062e9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>[Meta] Let&#39;s talk TouchBar + Unicode</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>October 29, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; <br>&gt; Swift is a language being designed for the next 20-30 years, we shouldn‚Äôt be limiting ourselves based on technology that is already being replaced (as you mentioned many of the devices people use everyday already have a soft keyboard‚Ä¶ and Ive said the TouchBar was just the beginning of a new direction).  We need to aim for where the puck is going to be‚Ä¶<br>&gt; <br></p><p>Hmm, I have engineering problems today. There will be engineering problems in 20 and 30 years as well, but I rather have a tool that is geared towards today‚Äôs problems. It would be even better if that tool is flexible enough so that it can adapt to the requirements as they change.<br></p><p>The difference between a puck and the future of engineering is that you can make a very good prediction about where a puck is going to be based on direction and speed. It is completely impossible to predict where the future of programming is going to be in 20 years time.<br></p><p>Let Swift be a flexible tool, don‚Äôt write anything in stone, and don‚Äôt try to predict the future.<br>If requirements change, let Swift change. But don‚Äôt try to be 20 years ahead of what we need today.<br></p><p>Regards,<br>Rien<br></p><p>Site: http://balancingrock.nl<br>Blog: http://swiftrien.blogspot.com<br>Github: http://github.com/Swiftrien<br>Project: http://swiftfire.nl<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Meta] Let&#39;s talk TouchBar + Unicode</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>October 29, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; On Oct 29, 2016, at 12:40 AM, Rien &lt;Rien at Balancingrock.nl&gt; wrote:<br>&gt; <br>&gt; Hmm, I have engineering problems today. There will be engineering problems in 20 and 30 years as well, but I rather have a tool that is geared towards today‚Äôs problems. It would be even better if that tool is flexible enough so that it can adapt to the requirements as they change.<br></p><p>I have already given several examples of how this can be done using today‚Äôs hardware (the TouchBar only makes things better).  I have even shown how it can work with plain old text editors. Sure, in the case of using a vanilla editor, you lose some discoverability and ease, but that is a tradeoff that you make for using a vanilla editor (everything is still possible).  Programs like BBEdit are infinitely extensible, and would quickly have plugins.<br></p><p>I agree that we want flexibility to adapt to requirements as they change.<br></p><p><br>&gt; The difference between a puck and the future of engineering is that you can make a very good prediction about where a puck is going to be based on direction and speed. It is completely impossible to predict where the future of programming is going to be in 20 years time.<br></p><p>Sure you can.  I have an extremely good track record of predictions (and a horrible track record of being able to convince people before things actually happen‚Ä¶ I call it my Cassandra Complex). You can‚Äôt predict everything of course, but there are patterns, trends and cycles that are fairly obvious if you look for them.  Look at how the kids today communicate‚Ä¶ they will be tomorrow‚Äôs programmers.  I may not know exactly where we will end up, but I can tell which way the wind is blowing.  You can either embrace the wind or fight it and be lost at sea.<br></p><p>More importantly though, we have a chance to help MAKE the future we want to see.  That is why we are all here. While I value forward transfer, growth always requires some change.<br></p><p><br>Once again, I am not saying we should willy nilly replace things with crazy symbols.  I am saying we should feel free to use whatever is clearest and most expressive for a given situation.  If that is a word, we should use a word.  If it is a symbol, then we should use a symbol.  If that symbol is ASCII, then so be it.  If it is unicode, we can do that now.  Giving ourselves an artificial constraint of only being able to use the characters which are painted on US keyboards will, by definition, lead to a less clear/expressive experience.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161029/aaf3b1b2/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Meta] Let&#39;s talk TouchBar + Unicode</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 29, 2016 at 10:00:00am</p></header><div class="content"><p>On Sat, Oct 29, 2016 at 2:02 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Oct 28, 2016, at 7:22 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; A person should not need to buy a special keyboard or device, or know how<br>&gt; to work the option/alt key, in order to write the less-than-or-equal-to<br>&gt; operator.<br>&gt;<br>&gt;<br>&gt; But my main point is that the symbols painted on the physical keyboard are<br>&gt; no longer our only (or even best) method of discovery.  If ‚â§ comes up in<br>&gt; the auto-complete when you write &lt; or &lt;=, then it solves the discovery<br>&gt; issue. We can even use this to teach the option/alt key method (this is the<br>&gt; what the Mac does to teach command keys associated with menu items).<br>&gt;<br></p><p>I agree with the first part of that, but IMO the second part misses the<br>point.<br></p><p>Sure, we should absolutely have better ways of discovering characters we do<br>not often use. I believe we should have this both at the OS level and, in<br>the case of writing code in languages that are Unicode-aware, at the IDE<br>level and baked into the language itself. I have no beef with that.<br></p><p>However, *my* main point is that the Swift&#39;s standard library APIs (and the<br>keywords and syntax at the core of the language) should use a character set<br>that *requires no discovery whatsoever* for the vast majority of users. It<br>is difficult enough to master a programming language, more difficult still<br>to master one&#39;s first programming language (and--per the core team--Swift<br>aims to be a great first programming language to learn); it is _bonkers_ to<br>pile onto that the need to &quot;discover&quot; (however smoothly that goes) how to<br>physically input the characters required to invoke some method.<br></p><p>Again, for your own libraries and APIs, go wild. Make a library that allows<br>people to write equations using the correct mathematical symbols. That&#39;d be<br>awesome. *Of course* it makes sense then for people to need to learn these<br>symbols, and of course we could improve the OS and IDE and Swift itself to<br>make the experience of using that library better. But that shouldn&#39;t be the<br>_standard_ library.<br></p><p>Your point about the search-ability of symbols is an important one, but<br>&gt; that can also be solved with appropriate UI for discovery of the associated<br>&gt; (searchable) keywords.<br>&gt;<br>&gt; Swift is a language being designed for the next 20-30 years, we shouldn‚Äôt<br>&gt; be limiting ourselves based on technology that is already being replaced<br>&gt; (as you mentioned many of the devices people use everyday already have a<br>&gt; soft keyboard‚Ä¶ and Ive said the TouchBar was just the beginning of a new<br>&gt; direction).  We need to aim for where the puck is going to be‚Ä¶<br>&gt;<br>&gt; Thanks,<br>&gt; Jon<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161029/ae7a2430/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Meta] Let&#39;s talk TouchBar + Unicode</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>October 29, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Oct 29, 2016, at 8:11 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; However, *my* main point is that the Swift&#39;s standard library APIs (and the keywords and syntax at the core of the language) should use a character set that *requires no discovery whatsoever* for the vast majority of users. It is difficult enough to master a programming language, more difficult still to master one&#39;s first programming language (and--per the core team--Swift aims to be a great first programming language to learn); it is _bonkers_ to pile onto that the need to &quot;discover&quot; (however smoothly that goes) how to physically input the characters required to invoke some method.<br></p><p>I am always amazed at this caricature of users as somehow simultaneously complete idiots (unable to figure out the option key) and experts in archaic computer architecture (‚Ä¶and they use vim).  It is extremely disrespectful to the actual user.  A good rule of thumb is to think of the user as extremely intelligent, but too busy and important to deal with your interface.<br></p><p>From today‚Äôs Daring Fireball:<br>&gt; Apple has always been very good at this ‚Äî designing software and hardware where complexity is encapsulated rather than hidden. The genius of the original Mac wasn‚Äôt that it was suitable for dummies but that it was the first system that wasn‚Äôt confusing. Smart people flocked to the Mac.<br></p><p><br>There is, by definition, always discovery.  I think what you are really arguing is that there is forward transfer from things like word processing, and there is‚Ä¶ it is important.  But there are also still tradeoffs forced by your limitations that harm discovery in other ways (not to mention that I often use ‚â† and ‚â§ in word processing).<br></p><p><br>Let‚Äôs take, as an example, discovery of ‚ÄúformUnion‚Äù.  How will a user, who doesn‚Äôt know about this, discover it‚Äôs existence and how it works?<br></p><p>‚Ä¢ For the lucky people who already know about unions, but not swift‚Äôs crazy ‚ÄúformUnion‚Äù, they are in luck.  If they just start typing ‚Äòuni‚Ä¶‚Äô, then ‚ÄòformUnion‚Äô will show in the autocomplete.  Hmm‚Ä¶ sounds like the exact method I was talking about with symbols.<br></p><p>‚Ä¢ Maybe they will command-click into the definition file, and then see formUnion definition there.  But couldn‚Äôt they also see the union symbol defined there?<br></p><p>‚Ä¢ Maybe they search for the documentation and find ‚ÄúformUnion‚Äù explained on the page. Again, the same is true of the operator.<br></p><p>There is the issue of how to learn from an already typed symbol how to type it, but I can think of several easy ways to do that in the UI (even something as simple as a tooltip). I trust the Xcode team to be able to come up with something appropriate and user test it as necessary.  (What about vim users?  I trust they can figure it out)<br></p><p><br>We do need to be aware of and support beginning users, but optimizing Swift (or any expert system) for beginners just leads to a disempowering experience for everyone.  Instead, we need to optimize for the users they will become, and provide ‚Äúon-ramps‚Äù for the beginners.  This is UX 101.  Alan Cooper is probably the one who talks about this problem most, but any well trained designer will tell you the same.<br></p><p>You were characterizing having both ‚ÄòformUnion‚Äô and the union symbol operator (or both &lt;= and ‚â§) as a burden on the user‚Äôs feeble mind, but it isn‚Äôt.  It is an on-ramp.  It teaches them how to use the system!  Are people confused by having ‚ÄòSave‚Äô in the menu bar and also ‚åòS?  Or does the save menu command teach them how to use the keyboard to save time?<br></p><p>I should point out that all of your arguments also argue against things like color and image literals (which are features I absolutely love). I am really glad that those didn‚Äôt have to go through this process, because we never would have done it.  I guess that is what is worrying me‚Ä¶<br></p><p><br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161029/ada2cadb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Meta] Let&#39;s talk TouchBar + Unicode</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 29, 2016 at 04:00:00pm</p></header><div class="content"><p>On Sat, Oct 29, 2016 at 4:14 PM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Oct 29, 2016, at 8:11 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; However, *my* main point is that the Swift&#39;s standard library APIs (and<br>&gt; the keywords and syntax at the core of the language) should use a character<br>&gt; set that *requires no discovery whatsoever* for the vast majority of users.<br>&gt; It is difficult enough to master a programming language, more difficult<br>&gt; still to master one&#39;s first programming language (and--per the core<br>&gt; team--Swift aims to be a great first programming language to learn); it is<br>&gt; _bonkers_ to pile onto that the need to &quot;discover&quot; (however smoothly that<br>&gt; goes) how to physically input the characters required to invoke some method.<br>&gt;<br>&gt;<br>&gt; I am always amazed at this caricature of users as somehow simultaneously<br>&gt; complete idiots (unable to figure out the option key) and experts in<br>&gt; archaic computer architecture (‚Ä¶and they use vim).  It is extremely<br>&gt; disrespectful to the actual user.  A good rule of thumb is to think of the<br>&gt; user as extremely intelligent, but too busy and important to deal with your<br>&gt; interface.<br>&gt;<br></p><p>This is a completely unfair characterization of my argument. I&#39;m not sure<br>how you conclude from the text that I&#39;ve written above that I believe Swift<br>users to be &quot;complete idiots.&quot; On the contrary, I am saying that the user<br>is indeed too busy with important matters to want to deal with figuring out<br>how to type some weird symbol they&#39;ve never seen before.<br></p><p>And while I do find myself using vim sometimes, I hardly consider it a<br>paragon of discoverability, and I&#39;ve never mentioned vim in any<br>conversation. Not sure why you&#39;re throwing that into the discussion here.<br></p><p><br>&gt; From today‚Äôs Daring Fireball:<br>&gt;<br>&gt; Apple has always been very good at this ‚Äî designing software and hardware<br>&gt; where complexity is encapsulated rather than hidden. The genius of the<br>&gt; original Mac wasn‚Äôt that it was suitable for dummies but that it was the<br>&gt; first system that wasn‚Äôt confusing. Smart people flocked to the Mac.<br>&gt;<br>&gt;<br>&gt;<br>&gt; There is, by definition, always discovery.  I think what you are really<br>&gt; arguing is that there is forward transfer from things like word processing,<br>&gt; and there is‚Ä¶ it is important.  But there are also still tradeoffs forced<br>&gt; by your limitations that harm discovery in other ways (not to mention that<br>&gt; I often use ‚â† and ‚â§ in word processing).<br>&gt;<br></p><p>Why does not having the less-than-or-equal-to sign &quot;harm discovery&quot;? FWIW,<br>it has been observed numerous times on this very list that operators are<br>_less_, not more, discoverable than other functions.<br></p><p>Let‚Äôs take, as an example, discovery of ‚ÄúformUnion‚Äù.  How will a user, who<br>&gt; doesn‚Äôt know about this, discover it‚Äôs existence and how it works?<br>&gt;<br>&gt; ‚Ä¢ For the lucky people who already know about unions, but not swift‚Äôs<br>&gt; crazy ‚ÄúformUnion‚Äù, they are in luck.  If they just start typing ‚Äòuni‚Ä¶‚Äô,<br>&gt; then ‚ÄòformUnion‚Äô will show in the autocomplete.  Hmm‚Ä¶ sounds like the exact<br>&gt; method I was talking about with symbols.<br>&gt;<br>&gt; ‚Ä¢ Maybe they will command-click into the definition file, and then see<br>&gt; formUnion definition there.  But couldn‚Äôt they also see the union symbol<br>&gt; defined there?<br>&gt;<br>&gt; ‚Ä¢ Maybe they search for the documentation and find ‚ÄúformUnion‚Äù explained<br>&gt; on the page. Again, the same is true of the operator.<br>&gt;<br></p><p>OK, and if you&#39;ve never seen that symbol before, just how do you say &quot;‚à™&quot;?<br>As in, literally, how would someone who just discovered such a hypothetical<br>operator in Swift&#39;s documentation for SetAlgebra turn to another programmer<br>and pronounce it? Here&#39;s the description in the documentation: &quot;Adds the<br>elements of the given set to the set.&quot; Not very helpful for figuring that<br>out, is it?<br></p><p>There is the issue of how to learn from an already typed symbol how to type<br>&gt; it, but I can think of several easy ways to do that in the UI (even<br>&gt; something as simple as a tooltip). I trust the Xcode team to be able to<br>&gt; come up with something appropriate and user test it as necessary.  (What<br>&gt; about vim users?  I trust they can figure it out)<br>&gt;<br>&gt;<br>&gt; We do need to be aware of and support beginning users, but optimizing<br>&gt; Swift (or any expert system) for beginners just leads to a disempowering<br>&gt; experience for everyone.<br>&gt;<br></p><p>Disagree strongly. Easy things should be easy, even when they&#39;re part of<br>complex systems. Not everyone learning Swift has to grasp copy-on-write on<br>day 1, but no one should have to struggle with how to type something.<br></p><p>Just because a computer is a powerful device doesn&#39;t mean that we should<br>tolerate the power button being unintuitive. (See, for example, widespread<br>mockery of some versions of Windows because shutting down requires several<br>menu clicks.) Just because Swift is a powerful language does not mean that<br>we should give ourselves license to make the basic task of typing the<br>letters required to invoke a function any harder than is absolutely<br>necessary.<br></p><p>Instead, we need to optimize for the users they will become, and provide<br>&gt; ‚Äúon-ramps‚Äù for the beginners.  This is UX 101.  Alan Cooper is probably the<br>&gt; one who talks about this problem most, but any well trained designer will<br>&gt; tell you the same.<br>&gt;<br>&gt; You were characterizing having both ‚ÄòformUnion‚Äô and the union symbol<br>&gt; operator (or both &lt;= and ‚â§) as a burden on the user‚Äôs feeble mind, but it<br>&gt; isn‚Äôt.  It is an on-ramp.  It teaches them how to use the system!  Are<br>&gt; people confused by having ‚ÄòSave‚Äô in the menu bar and also ‚åòS?  Or does the<br>&gt; save menu command teach them how to use the keyboard to save time?<br>&gt;<br></p><p>This argument is unpersuasive. The situation with &quot;formUnion&quot; is the<br>diametrical opposite of your example of the &quot;Save&quot; shortcut. There, the<br>more discoverable method (the menu) is slower than the less discoverable<br>one (the shortcut), so one points to the other. (Notably, on the Mac,<br>pressing the shortcut will also highlight the corresponding menu, so it<br>works both ways.) How is having the less-than-or-equal-to symbol &quot;saving<br>time&quot;? Is it really faster for you to type it out than to type &quot;&lt;=&quot;? That&#39;s<br>certainly not the case for me! Half the time I find myself responding to<br>you, I&#39;m using the iPad, where I have not yet worked out how to type that<br>symbol at all. Hence, &quot;less-than-or-equal-to&quot; it is.<br></p><p>I&#39;m glad you have some thoughts as to how to teach someone to do something<br>(typing the less-than-or-equal-to sign) that&#39;s more difficult than<br>something else (typing &quot;&lt;=&quot;). I totally agree that where something is<br>necessarily difficult, then we should be thinking to these methods of<br>teaching users. But you know what&#39;s better than a good way of teaching<br>something? Not having to teach it at all!<br></p><p>I should point out that all of your arguments also argue against things<br>&gt; like color and image literals (which are features I absolutely love). I am<br>&gt; really glad that those didn‚Äôt have to go through this process, because we<br>&gt; never would have done it.  I guess that is what is worrying me‚Ä¶<br>&gt;<br></p><p>Huh? How is this related in any way to color or image literals? Those are<br>extremely beginner-friendly and pedagogically useful facilities. Again, you<br>are misunderstanding my argument. Colors and images are often used in Swift<br>programming, and referring to them by a series of hexadecimal numbers or a<br>file path (respectively) is unintuitive. It is therefore useful to have a<br>beginner-friendly, WYSIWYG way of specifying a color or image. By contrast,<br>typing the less-than-or-equal-to symbol is not necessary in Swift. It is<br>totally backwards to design an elaborate way to make it easier to do so for<br>the purpose of justifying an API change that will make them necessary.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161029/77f67f38/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Meta] Let&#39;s talk TouchBar + Unicode</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>October 29, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Oct 29, 2016, at 2:56 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Sat, Oct 29, 2016 at 4:14 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Oct 29, 2016, at 8:11 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; However, *my* main point is that the Swift&#39;s standard library APIs (and the keywords and syntax at the core of the language) should use a character set that *requires no discovery whatsoever* for the vast majority of users. It is difficult enough to master a programming language, more difficult still to master one&#39;s first programming language (and--per the core team--Swift aims to be a great first programming language to learn); it is _bonkers_ to pile onto that the need to &quot;discover&quot; (however smoothly that goes) how to physically input the characters required to invoke some method.<br>&gt; <br>&gt; I am always amazed at this caricature of users as somehow simultaneously complete idiots (unable to figure out the option key) and experts in archaic computer architecture (‚Ä¶and they use vim).  It is extremely disrespectful to the actual user.  A good rule of thumb is to think of the user as extremely intelligent, but too busy and important to deal with your interface.<br>&gt; <br>&gt; This is a completely unfair characterization of my argument. I&#39;m not sure how you conclude from the text that I&#39;ve written above that I believe Swift users to be &quot;complete idiots.&quot; On the contrary, I am saying that the user is indeed too busy with important matters to want to deal with figuring out how to type some weird symbol they&#39;ve never seen before.<br></p><p>Because your arguments are assuming that the user can‚Äôt figure things out, when they totally can. It is an extremely common (almost subconscious) caricature of ‚ÄúThe User‚Äù.  As a young designer, I was yelled at once by Don Norman for doing the same thing.  I was complaining about the design of a room key (The arrow on the key needed more salience to afford how to use it).  He replied, ‚ÄúSure, it could be better. Things can always be better‚Ä¶ but were you able to get into your room?‚Äù.  Yes, I had.  He then asked several other people nearby if they were able to get into their rooms.  Everyone had.  ‚ÄúHow many people in the entire hotel do you think were not able to get into their room because of this?  Tell me again why the hotel should spend thousands of dollars to reprint their keys to solve this thing which may be an annoyance, but hasn‚Äôt caused an actual problem?‚Äù.  He then told me that people were much more capable than I was imagining them to be, and that I should give them the credit they deserve because failing to do so is ultimately harmful not just to the user of my designs, but to the design profession in general.  It took me several years to really truly understand what he meant‚Ä¶ but he was (as usual) right.<br></p><p>I was being slightly hyperbolic, but you are arguing that figuring out how to use autocomplete (or even use the option key to type a symbol) is too difficult for beginners.  You have also argued that having both ‚ÄòformsUnion‚Äô and the union symbol would be too much of a burden on someone learning the language.  You are assuming they will fail, no matter how well the UI is designed.  I am saying, there might be a brief moment where they are learning, but once they get it‚Ä¶ they will get it‚Ä¶ and they will be able to express themselves much more as a result.<br></p><p>Also, I don‚Äôt think I have ever talked about requiring anyone to figure out the symbols.  Rather I have talked about building on-ramps to teach them to be able to use the symbols freely where they want to.<br></p><p><br>&gt; And while I do find myself using vim sometimes, I hardly consider it a paragon of discoverability, and I&#39;ve never mentioned vim in any conversation. Not sure why you&#39;re throwing that into the discussion here.<br>Apologies, it was someone else who wrote me about vim.<br></p><p><br>&gt; From today‚Äôs Daring Fireball:<br>&gt;&gt; Apple has always been very good at this ‚Äî designing software and hardware where complexity is encapsulated rather than hidden. The genius of the original Mac wasn‚Äôt that it was suitable for dummies but that it was the first system that wasn‚Äôt confusing. Smart people flocked to the Mac.<br>&gt; <br>&gt; <br>&gt; There is, by definition, always discovery.  I think what you are really arguing is that there is forward transfer from things like word processing, and there is‚Ä¶ it is important.  But there are also still tradeoffs forced by your limitations that harm discovery in other ways (not to mention that I often use ‚â† and ‚â§ in word processing).<br>&gt; <br>&gt; Why does not having the less-than-or-equal-to sign &quot;harm discovery&quot;? FWIW, it has been observed numerous times on this very list that operators are _less_, not more, discoverable than other functions.<br></p><p>I actually just finished teaching a Swift class for people who had never programmed before.  They had trouble with &lt;= (‚ÄúWhy does the arrow mean less than or equal? Why can‚Äôt I use ‚â§?&quot;) and != (‚ÄúBut the ! has to do with optionals‚Äù‚Ä¶ I think they thought it was unwrap and assign like *= is multiply and assign).  They were able to solve these issues, of course, as they are intelligent people‚Ä¶ but let‚Äôs not pretend that ASCII is magically free of confusion.  Having fewer available symbols means we are forced to chain the symbols we do have together in suboptimal ways (I believe there is talk of adding &lt;=&gt; to the standard library).<br></p><p><br>&gt; Let‚Äôs take, as an example, discovery of ‚ÄúformUnion‚Äù.  How will a user, who doesn‚Äôt know about this, discover it‚Äôs existence and how it works?<br>&gt; <br>&gt; ‚Ä¢ For the lucky people who already know about unions, but not swift‚Äôs crazy ‚ÄúformUnion‚Äù, they are in luck.  If they just start typing ‚Äòuni‚Ä¶‚Äô, then ‚ÄòformUnion‚Äô will show in the autocomplete.  Hmm‚Ä¶ sounds like the exact method I was talking about with symbols.<br>&gt; <br>&gt; ‚Ä¢ Maybe they will command-click into the definition file, and then see formUnion definition there.  But couldn‚Äôt they also see the union symbol defined there?<br>&gt; <br>&gt; ‚Ä¢ Maybe they search for the documentation and find ‚ÄúformUnion‚Äù explained on the page. Again, the same is true of the operator.<br>&gt; <br>&gt; OK, and if you&#39;ve never seen that symbol before, just how do you say &quot;‚à™&quot;? As in, literally, how would someone who just discovered such a hypothetical operator in Swift&#39;s documentation for SetAlgebra turn to another programmer and pronounce it? Here&#39;s the description in the documentation: &quot;Adds the elements of the given set to the set.&quot; Not very helpful for figuring that out, is it?<br></p><p>In Xcode, they could mouse over it and see the word ‚Äúunion‚Äù.  In the documentation, it could say ‚ÄúUnion Operator. Adds the elements of the given set to the set.‚Äù  It could even have a hint on how to type it (e.g. &#39;^union‚Äô), and that part could be auto-generated.<br></p><p><br>&gt; We do need to be aware of and support beginning users, but optimizing Swift (or any expert system) for beginners just leads to a disempowering experience for everyone.<br>&gt; <br>&gt; Disagree strongly. Easy things should be easy, even when they&#39;re part of complex systems. Not everyone learning Swift has to grasp copy-on-write on day 1, but no one should have to struggle with how to type something.<br></p><p>I do agree that easy things should be easy. I am saying we can make this easy if we want to.  Easy enough that it can be used in any Swift code, even the core libraries when appropriate. <br></p><p>Again, if a symbol isn‚Äôt clear, we shouldn‚Äôt use it (and we can argue over what is clear or not in other threads). We should use whatever is clearest and most expressive. If that is ASCII, that is great, and if it is unicode, also great.<br></p><p>Why should we force ourselves to use something, which is by definition, less clear/expressive?<br></p><p><br>&gt; Just because a computer is a powerful device doesn&#39;t mean that we should tolerate the power button being unintuitive. (See, for example, widespread mockery of some versions of Windows because shutting down requires several menu clicks.) Just because Swift is a powerful language does not mean that we should give ourselves license to make the basic task of typing the letters required to invoke a function any harder than is absolutely necessary.<br></p><p>I am not saying that we should make things purposefully unintuitive.  But for expert systems, we want to optimize for efficiency of use, error recovery/prevention, and expression over walk-up-and-use.  Believe it or not, this is the mindset the original mac was designed with (people still find that easy to use), and it is the mindset we should be designing with here.<br></p><p>As an aside, shutting down SHOULD require effort (Just as easy things should be easy‚Ä¶ dangerous things should be a little bit difficult). You have to press and hold the mac power button for quite a while so that you don‚Äôt slip and hit it accidentally.  It could be made ‚Äúeasier‚Äù, but that would put people‚Äôs data at risk.  My understanding of why people ridicule Windows‚Äô shutdown is that it was under the ‚Äústart‚Äù menu.<br></p><p>&gt; Instead, we need to optimize for the users they will become, and provide ‚Äúon-ramps‚Äù for the beginners.  This is UX 101.  Alan Cooper is probably the one who talks about this problem most, but any well trained designer will tell you the same.<br>&gt; <br>&gt; You were characterizing having both ‚ÄòformUnion‚Äô and the union symbol operator (or both &lt;= and ‚â§) as a burden on the user‚Äôs feeble mind, but it isn‚Äôt.  It is an on-ramp.  It teaches them how to use the system!  Are people confused by having ‚ÄòSave‚Äô in the menu bar and also ‚åòS?  Or does the save menu command teach them how to use the keyboard to save time?<br>&gt; <br>&gt; This argument is unpersuasive. The situation with &quot;formUnion&quot; is the diametrical opposite of your example of the &quot;Save&quot; shortcut. There, the more discoverable method (the menu) is slower than the less discoverable one (the shortcut), so one points to the other. (Notably, on the Mac, pressing the shortcut will also highlight the corresponding menu, so it works both ways.) How is having the less-than-or-equal-to symbol &quot;saving time&quot;? Is it really faster for you to type it out than to type &quot;&lt;=&quot;? That&#39;s certainly not the case for me! Half the time I find myself responding to you, I&#39;m using the iPad, where I have not yet worked out how to type that symbol at all. Hence, &quot;less-than-or-equal-to&quot; it is.<br></p><p>In the case of the menu item, it is used to teach an accelerator which saves time.  I am saying, we can use the same technique to teach symbols which are more concise, are more easily located in code, and are more representative.  If the symbol is less representative than the word in a particular case, then we should use the word.  We should use whatever is best.<br></p><p>Funny story: For new users (to a shortcut), especially those who are currently using the mouse, keyboard shortcuts actually take longer than using the menu, despite the fact that it FEELS much quicker to them. The brain basically stops making memories for a second during the context switch.  You can sit in coffee shops and watch it happen.  I always found it an amusing effect. (This changes with practice for common commands due to muscle memory)<br></p><p><br>&gt; I&#39;m glad you have some thoughts as to how to teach someone to do something (typing the less-than-or-equal-to sign) that&#39;s more difficult than something else (typing &quot;&lt;=&quot;). I totally agree that where something is necessarily difficult, then we should be thinking to these methods of teaching users. But you know what&#39;s better than a good way of teaching something? Not having to teach it at all!<br></p><p>Sure, but you are always going to have to teach someone who doesn‚Äôt have transferable experience (see above with students seeing &lt;= as an arrow and being confused).  We find the mouse intuitive now, but the original Mac came with software which taught you how to use it (and they needed to).  Should we have stayed with DOS, because people knew how to use the keyboard (and we don‚Äôt want to teach them a new thing)? <br></p><p><br>&gt; I should point out that all of your arguments also argue against things like color and image literals (which are features I absolutely love). I am really glad that those didn‚Äôt have to go through this process, because we never would have done it.  I guess that is what is worrying me‚Ä¶<br>&gt; <br>&gt; Huh? How is this related in any way to color or image literals? Those are extremely beginner-friendly and pedagogically useful facilities. Again, you are misunderstanding my argument. Colors and images are often used in Swift programming, and referring to them by a series of hexadecimal numbers or a file path (respectively) is unintuitive. It is therefore useful to have a beginner-friendly, WYSIWYG way of specifying a color or image. By contrast, typing the less-than-or-equal-to symbol is not necessary in Swift. It is totally backwards to design an elaborate way to make it easier to do so for the purpose of justifying an API change that will make them necessary.<br></p><p>Well, image literals currently work exactly the same way I am saying unicode should.  I agree that they are very beginner-friendly and pedagogically useful.  Why do you think we can‚Äôt make symbols beginner-friendly and pedagogically useful?  Is having both image(named:) and image literals confusing to beginners?  No it is not.<br></p><p>This is not to justify making an API change.  I am saying that we need to do whatever is clearest and most expressive.  We can argue over whether ‚â§ or &lt;= is clearer or more expressive (that is a separate issue), but I am shocked that so many are arguing that we should limit clarity to adhere to an ASCII only rule.<br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161029/89cc3eb1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Meta] Let&#39;s talk TouchBar + Unicode</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 29, 2016 at 09:00:00pm</p></header><div class="content"><p>On Sat, Oct 29, 2016 at 8:42 PM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Oct 29, 2016, at 2:56 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Sat, Oct 29, 2016 at 4:14 PM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Oct 29, 2016, at 8:11 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; However, *my* main point is that the Swift&#39;s standard library APIs (and<br>&gt;&gt; the keywords and syntax at the core of the language) should use a character<br>&gt;&gt; set that *requires no discovery whatsoever* for the vast majority of users.<br>&gt;&gt; It is difficult enough to master a programming language, more difficult<br>&gt;&gt; still to master one&#39;s first programming language (and--per the core<br>&gt;&gt; team--Swift aims to be a great first programming language to learn); it is<br>&gt;&gt; _bonkers_ to pile onto that the need to &quot;discover&quot; (however smoothly that<br>&gt;&gt; goes) how to physically input the characters required to invoke some method.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I am always amazed at this caricature of users as somehow simultaneously<br>&gt;&gt; complete idiots (unable to figure out the option key) and experts in<br>&gt;&gt; archaic computer architecture (‚Ä¶and they use vim).  It is extremely<br>&gt;&gt; disrespectful to the actual user.  A good rule of thumb is to think of the<br>&gt;&gt; user as extremely intelligent, but too busy and important to deal with your<br>&gt;&gt; interface.<br>&gt;&gt;<br>&gt;<br>&gt; This is a completely unfair characterization of my argument. I&#39;m not sure<br>&gt; how you conclude from the text that I&#39;ve written above that I believe Swift<br>&gt; users to be &quot;complete idiots.&quot; On the contrary, I am saying that the user<br>&gt; is indeed too busy with important matters to want to deal with figuring out<br>&gt; how to type some weird symbol they&#39;ve never seen before.<br>&gt;<br>&gt;<br>&gt; Because your arguments are assuming that the user can‚Äôt figure things out,<br>&gt; when they totally can. It is an extremely common (almost subconscious)<br>&gt; caricature of ‚ÄúThe User‚Äù.  As a young designer, I was yelled at once by Don<br>&gt; Norman for doing the same thing.  I was complaining about the design of a<br>&gt; room key (The arrow on the key needed more salience to afford how to use<br>&gt; it).  He replied, ‚ÄúSure, it could be better. Things can always be better‚Ä¶<br>&gt; but were you able to get into your room?‚Äù.  Yes, I had.  He then asked<br>&gt; several other people nearby if they were able to get into their rooms.<br>&gt; Everyone had.  ‚ÄúHow many people in the entire hotel do you think were not<br>&gt; able to get into their room because of this?  Tell me again why the hotel<br>&gt; should spend thousands of dollars to reprint their keys to solve this thing<br>&gt; which may be an annoyance, but hasn‚Äôt caused an actual problem?‚Äù.  He then<br>&gt; told me that people were much more capable than I was imagining them to be,<br>&gt; and that I should give them the credit they deserve because failing to do<br>&gt; so is ultimately harmful not just to the user of my designs, but to the<br>&gt; design profession in general.  It took me several years to really truly<br>&gt; understand what he meant‚Ä¶ but he was (as usual) right.<br>&gt;<br></p><p>Perhaps he was right about your room key. But we&#39;re not designing room keys<br>here. (Also, have you *never* been annoyed by room keys and wondered to<br>yourself who the !@#$ designed that piece of crap? But I digress.)<br></p><p>Figure out how to use your room key and the task is done. You&#39;re in your<br>room. Figure out how to type and you&#39;re at step 0 of a long list of steps<br>towards writing anything remotely useful in Swift. Make every step slightly<br>annoying and you&#39;ve got an infuriating language.<br></p><p><br>&gt; I was being slightly hyperbolic, but you are arguing that figuring out how<br>&gt; to use autocomplete (or even use the option key to type a symbol) is too<br>&gt; difficult for beginners.<br>&gt;<br></p><p>I&#39;m not arguing that it&#39;s &quot;too difficult&quot; a challenge to surmount--I&#39;m<br>arguing that if we stick to ASCII the challenge would not exist in the<br>first place, and that we should not challenge the user to any degree<br>whatsoever with regards to typing. There are other, more salient challenges<br>already.<br></p><p><br>&gt; You have also argued that having both ‚ÄòformsUnion‚Äô and the union symbol<br>&gt; would be too much of a burden on someone learning the language.  You are<br>&gt; assuming they will fail, no matter how well the UI is designed.  I am<br>&gt; saying, there might be a brief moment where they are learning, but once<br>&gt; they get it‚Ä¶ they will get it‚Ä¶ and they will be able to express themselves<br>&gt; much more as a result.<br>&gt;<br>&gt; Also, I don‚Äôt think I have ever talked about requiring anyone to figure<br>&gt; out the symbols.  Rather I have talked about building on-ramps to teach<br>&gt; them to be able to use the symbols freely where they want to.<br>&gt;<br></p><p>I understand. There&#39;s a mini-argument here that I didn&#39;t write out. It&#39;s<br>been said that Swift is an &quot;opinionated&quot; language, not a<br>to-each-their-own/design-by-committee kind of language. Thus, afaict, the<br>modus operandi is that what&#39;s decided to be the best way is adopted as the<br>*only* way.<br></p><p>Other than for compatibility reasons, perhaps, there are few if any aliases<br>in the standard library. If we decide that the less-than-or-equal-to symbol<br>is the best way to invoke that particular operation, then `&lt;=` would be<br>deprecated and then in the next version removed. If that&#39;s too much to<br>stomach, then it&#39;s a hint that perhaps the less-than-or-equal-to symbol<br>isn&#39;t good enough to replace `&lt;=`. I don&#39;t see room for an in-between<br>solution where the same function is named two or three ways.<br></p><p>&gt; And while I do find myself using vim sometimes, I hardly consider it a<br>&gt; paragon of discoverability, and I&#39;ve never mentioned vim in any<br>&gt; conversation. Not sure why you&#39;re throwing that into the discussion here.<br>&gt;<br>&gt; Apologies, it was someone else who wrote me about vim.<br>&gt;<br>&gt;<br>&gt; From today‚Äôs Daring Fireball:<br>&gt;&gt;<br>&gt;&gt; Apple has always been very good at this ‚Äî designing software and hardware<br>&gt;&gt; where complexity is encapsulated rather than hidden. The genius of the<br>&gt;&gt; original Mac wasn‚Äôt that it was suitable for dummies but that it was the<br>&gt;&gt; first system that wasn‚Äôt confusing. Smart people flocked to the Mac.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; There is, by definition, always discovery.  I think what you are really<br>&gt;&gt; arguing is that there is forward transfer from things like word processing,<br>&gt;&gt; and there is‚Ä¶ it is important.  But there are also still tradeoffs forced<br>&gt;&gt; by your limitations that harm discovery in other ways (not to mention that<br>&gt;&gt; I often use ‚â† and ‚â§ in word processing).<br>&gt;&gt;<br>&gt;<br>&gt; Why does not having the less-than-or-equal-to sign &quot;harm discovery&quot;? FWIW,<br>&gt; it has been observed numerous times on this very list that operators are<br>&gt; _less_, not more, discoverable than other functions.<br>&gt;<br>&gt;<br>&gt; I actually just finished teaching a Swift class for people who had never<br>&gt; programmed before.  They had trouble with &lt;= (‚ÄúWhy does the arrow mean less<br>&gt; than or equal? Why can‚Äôt I use ‚â§?&quot;) and != (‚ÄúBut the ! has to do with<br>&gt; optionals‚Äù‚Ä¶ I think they thought it was unwrap and assign like *= is<br>&gt; multiply and assign).  They were able to solve these issues, of course, as<br>&gt; they are intelligent people‚Ä¶ but let‚Äôs not pretend that ASCII is magically<br>&gt; free of confusion.<br>&gt;<br></p><p>If only you&#39;d read as many documents as I have where the<br>less-than-or-equal-to sign is written by underlining &lt;, you would see that<br>your proposed solution to these issues is not nearly as obvious as you make<br>it out to be. (I&#39;m a biologist by training; the number of manuscripts in<br>that field where one sees it written as &quot;*&lt;*&quot; [note to non-rich-text<br>readers: that&#39;s &quot;&lt;&quot; with an underline] is very near 100%.)<br></p><p><br>&gt; Having fewer available symbols means we are forced to chain the symbols we<br>&gt; do have together in suboptimal ways (I believe there is talk of adding &lt;=&gt;<br>&gt; to the standard library).<br>&gt;<br>&gt;<br>&gt; Let‚Äôs take, as an example, discovery of ‚ÄúformUnion‚Äù.  How will a user, who<br>&gt;&gt; doesn‚Äôt know about this, discover it‚Äôs existence and how it works?<br>&gt;&gt;<br>&gt;&gt; ‚Ä¢ For the lucky people who already know about unions, but not swift‚Äôs<br>&gt;&gt; crazy ‚ÄúformUnion‚Äù, they are in luck.  If they just start typing ‚Äòuni‚Ä¶‚Äô,<br>&gt;&gt; then ‚ÄòformUnion‚Äô will show in the autocomplete.  Hmm‚Ä¶ sounds like the exact<br>&gt;&gt; method I was talking about with symbols.<br>&gt;&gt;<br>&gt;&gt; ‚Ä¢ Maybe they will command-click into the definition file, and then see<br>&gt;&gt; formUnion definition there.  But couldn‚Äôt they also see the union symbol<br>&gt;&gt; defined there?<br>&gt;&gt;<br>&gt;&gt; ‚Ä¢ Maybe they search for the documentation and find ‚ÄúformUnion‚Äù explained<br>&gt;&gt; on the page. Again, the same is true of the operator.<br>&gt;&gt;<br>&gt;<br>&gt; OK, and if you&#39;ve never seen that symbol before, just how do you say &quot;‚à™&quot;?<br>&gt; As in, literally, how would someone who just discovered such a hypothetical<br>&gt; operator in Swift&#39;s documentation for SetAlgebra turn to another programmer<br>&gt; and pronounce it? Here&#39;s the description in the documentation: &quot;Adds the<br>&gt; elements of the given set to the set.&quot; Not very helpful for figuring that<br>&gt; out, is it?<br>&gt;<br>&gt;<br>&gt; In Xcode, they could mouse over it and see the word ‚Äúunion‚Äù.  In the<br>&gt; documentation, it could say ‚ÄúUnion Operator. Adds the elements of the given<br>&gt; set to the set.‚Äù  It could even have a hint on how to type it (e.g.<br>&gt; &#39;^union‚Äô), and that part could be auto-generated.<br>&gt;<br></p><p>But if it needs to be documented as &quot;union operator&quot; and needs a tooltip to<br>say &quot;union&quot; and you need to type &quot;^union&quot;, why wouldn&#39;t you just name it<br>&quot;union&quot; _as it already is_?<br></p><p>We do need to be aware of and support beginning users, but optimizing Swift<br>&gt;&gt; (or any expert system) for beginners just leads to a disempowering<br>&gt;&gt; experience for everyone.<br>&gt;&gt;<br>&gt;<br>&gt; Disagree strongly. Easy things should be easy, even when they&#39;re part of<br>&gt; complex systems. Not everyone learning Swift has to grasp copy-on-write on<br>&gt; day 1, but no one should have to struggle with how to type something.<br>&gt;<br>&gt;<br>&gt; I do agree that easy things should be easy. I am saying we can make this<br>&gt; easy if we want to.  Easy enough that it can be used in any Swift code,<br>&gt; even the core libraries when appropriate.<br>&gt;<br>&gt; Again, if a symbol isn‚Äôt clear, we shouldn‚Äôt use it (and we can argue over<br>&gt; what is clear or not in other threads). We should use whatever is clearest<br>&gt; and most expressive. If that is ASCII, that is great, and if it is unicode,<br>&gt; also great.<br>&gt;<br></p><p>I&#39;m arguing that any ASCII character is at baseline, simply by virtue of<br>having the increased recognition that ASCII characters do, clearer than any<br>non-ASCII character to a general audience. There would have to be a huge<br>win in expressiveness for any particular non-ASCII character to overcome<br>that handicap. And I&#39;m arguing that the most plausible scenario in the<br>standard library where we might see a huge win--the union operator--does<br>not, for me, pass that bar.<br></p><p>Again, this has nothing to do with how you write your own third-party<br>libraries.<br></p><p>Why should we force ourselves to use something, which is by definition,<br>&gt; less clear/expressive?<br>&gt;<br></p><p>See above. I can&#39;t accept your premise that the clearest and most<br>expressive choice for any standard library API would be a non-ASCII symbol.<br></p><p>Just because a computer is a powerful device doesn&#39;t mean that we should<br>&gt; tolerate the power button being unintuitive. (See, for example, widespread<br>&gt; mockery of some versions of Windows because shutting down requires several<br>&gt; menu clicks.) Just because Swift is a powerful language does not mean that<br>&gt; we should give ourselves license to make the basic task of typing the<br>&gt; letters required to invoke a function any harder than is absolutely<br>&gt; necessary.<br>&gt;<br>&gt;<br>&gt; I am not saying that we should make things purposefully unintuitive.  But<br>&gt; for expert systems, we want to optimize for efficiency of use, error<br>&gt; recovery/prevention, and expression over walk-up-and-use.  Believe it or<br>&gt; not, this is the mindset the original mac was designed with (people still<br>&gt; find that easy to use), and it is the mindset we should be designing with<br>&gt; here.<br>&gt;<br>&gt; As an aside, shutting down SHOULD require effort (Just as easy things<br>&gt; should be easy‚Ä¶ dangerous things should be a little bit difficult). You<br>&gt; have to press and hold the mac power button for quite a while so that you<br>&gt; don‚Äôt slip and hit it accidentally.  It could be made ‚Äúeasier‚Äù, but that<br>&gt; would put people‚Äôs data at risk.  My understanding of why people ridicule<br>&gt; Windows‚Äô shutdown is that it was under the ‚Äústart‚Äù menu.<br>&gt;<br></p><p>That&#39;s a much earlier criticism of the Windows shut down menu options...<br></p><p><br>&gt; Instead, we need to optimize for the users they will become, and provide<br>&gt;&gt; ‚Äúon-ramps‚Äù for the beginners.  This is UX 101.  Alan Cooper is probably the<br>&gt;&gt; one who talks about this problem most, but any well trained designer will<br>&gt;&gt; tell you the same.<br>&gt;&gt;<br>&gt;&gt; You were characterizing having both ‚ÄòformUnion‚Äô and the union symbol<br>&gt;&gt; operator (or both &lt;= and ‚â§) as a burden on the user‚Äôs feeble mind, but it<br>&gt;&gt; isn‚Äôt.  It is an on-ramp.  It teaches them how to use the system!  Are<br>&gt;&gt; people confused by having ‚ÄòSave‚Äô in the menu bar and also ‚åòS?  Or does the<br>&gt;&gt; save menu command teach them how to use the keyboard to save time?<br>&gt;&gt;<br>&gt;<br>&gt; This argument is unpersuasive. The situation with &quot;formUnion&quot; is the<br>&gt; diametrical opposite of your example of the &quot;Save&quot; shortcut. There, the<br>&gt; more discoverable method (the menu) is slower than the less discoverable<br>&gt; one (the shortcut), so one points to the other. (Notably, on the Mac,<br>&gt; pressing the shortcut will also highlight the corresponding menu, so it<br>&gt; works both ways.) How is having the less-than-or-equal-to symbol &quot;saving<br>&gt; time&quot;? Is it really faster for you to type it out than to type &quot;&lt;=&quot;? That&#39;s<br>&gt; certainly not the case for me! Half the time I find myself responding to<br>&gt; you, I&#39;m using the iPad, where I have not yet worked out how to type that<br>&gt; symbol at all. Hence, &quot;less-than-or-equal-to&quot; it is.<br>&gt;<br>&gt;<br>&gt; In the case of the menu item, it is used to teach an accelerator which<br>&gt; saves time.  I am saying, we can use the same technique to teach symbols<br>&gt; which are more concise, are more easily located in code, and are more<br>&gt; representative.  If the symbol is less representative than the word in a<br>&gt; particular case, then we should use the word.  We should use whatever is<br>&gt; best.<br>&gt;<br></p><p>Yes, and I&#39;m saying, in the standard library, what&#39;s best isn&#39;t the symbol.<br></p><p><br>&gt; Funny story: For new users (to a shortcut), especially those who are<br>&gt; currently using the mouse, keyboard shortcuts actually take longer than<br>&gt; using the menu, despite the fact that it FEELS much quicker to them. The<br>&gt; brain basically stops making memories for a second during the context<br>&gt; switch.  You can sit in coffee shops and watch it happen.  I always found<br>&gt; it an amusing effect. (This changes with practice for common commands due<br>&gt; to muscle memory)<br>&gt;<br>&gt;<br>&gt; I&#39;m glad you have some thoughts as to how to teach someone to do something<br>&gt; (typing the less-than-or-equal-to sign) that&#39;s more difficult than<br>&gt; something else (typing &quot;&lt;=&quot;). I totally agree that where something is<br>&gt; necessarily difficult, then we should be thinking to these methods of<br>&gt; teaching users. But you know what&#39;s better than a good way of teaching<br>&gt; something? Not having to teach it at all!<br>&gt;<br>&gt;<br>&gt; Sure, but you are always going to have to teach someone who doesn‚Äôt have<br>&gt; transferable experience (see above with students seeing &lt;= as an arrow and<br>&gt; being confused).  We find the mouse intuitive now, but the original Mac<br>&gt; came with software which taught you how to use it (and they needed to).<br>&gt; Should we have stayed with DOS, because people knew how to use the keyboard<br>&gt; (and we don‚Äôt want to teach them a new thing)?<br>&gt;<br>&gt;<br>&gt; I should point out that all of your arguments also argue against things<br>&gt;&gt; like color and image literals (which are features I absolutely love). I am<br>&gt;&gt; really glad that those didn‚Äôt have to go through this process, because we<br>&gt;&gt; never would have done it.  I guess that is what is worrying me‚Ä¶<br>&gt;&gt;<br>&gt;<br>&gt; Huh? How is this related in any way to color or image literals? Those are<br>&gt; extremely beginner-friendly and pedagogically useful facilities. Again, you<br>&gt; are misunderstanding my argument. Colors and images are often used in Swift<br>&gt; programming, and referring to them by a series of hexadecimal numbers or a<br>&gt; file path (respectively) is unintuitive. It is therefore useful to have a<br>&gt; beginner-friendly, WYSIWYG way of specifying a color or image. By contrast,<br>&gt; typing the less-than-or-equal-to symbol is not necessary in Swift. It is<br>&gt; totally backwards to design an elaborate way to make it easier to do so for<br>&gt; the purpose of justifying an API change that will make them necessary.<br>&gt;<br>&gt;<br>&gt; Well, image literals currently work exactly the same way I am saying<br>&gt; unicode should.  I agree that they are very beginner-friendly and<br>&gt; pedagogically useful.  Why do you think we can‚Äôt make symbols<br>&gt; beginner-friendly and pedagogically useful?  Is having both image(named:)<br>&gt; and image literals confusing to beginners?  No it is not.<br>&gt;<br>&gt; This is not to justify making an API change.  I am saying that we need to<br>&gt; do whatever is clearest and most expressive.  We can argue over whether ‚â§<br>&gt; or &lt;= is clearer or more expressive (that is a separate issue), but I am<br>&gt; shocked that so many are arguing that we should limit clarity to adhere to<br>&gt; an ASCII only rule.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161029/f967ef3c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Meta] Let&#39;s talk TouchBar + Unicode</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>October 31, 2016 at 03:00:00pm</p></header><div class="content"><p>Premature standardization is just as bad as premature optimization...<br></p><p>&gt; Because your arguments are assuming that the user can‚Äôt figure things out, when they totally can. It is an extremely common (almost subconscious) caricature of ‚ÄúThe User‚Äù.  As a young designer, I was yelled at once by Don Norman for doing the same thing.  I was complaining about the design of a room key (The arrow on the key needed more salience to afford how to use it).  He replied, ‚ÄúSure, it could be better. Things can always be better‚Ä¶ but were you able to get into your room?‚Äù.  Yes, I had.  He then asked several other people nearby if they were able to get into their rooms.  Everyone had.  ‚ÄúHow many people in the entire hotel do you think were not able to get into their room because of this?  Tell me again why the hotel should spend thousands of dollars to reprint their keys to solve this thing which may be an annoyance, but hasn‚Äôt caused an actual problem?‚Äù.  He then told me that people were much more capable than I was imagining them to be, and that I should give them the credit they deserve because failing to do so is ultimately harmful not just to the user of my designs, but to the design profession in general.  It took me several years to really truly understand what he meant‚Ä¶ but he was (as usual) right.<br>&gt; <br>&gt; Perhaps he was right about your room key. But we&#39;re not designing room keys here. (Also, have you *never* been annoyed by room keys and wondered to yourself who the !@#$ designed that piece of crap? But I digress.)<br></p><p>Sorry if I was unclear.  The point is not that you shouldn‚Äôt deal with annoyances (you should improve the keys on the next already scheduled re-print).  The point was that I was imagining the problem to be much worse (and much more urgent) than it actually was, because I wasn‚Äôt realistic about the user‚Äôs capabilities.  It may be counter-intuitive, but it leads to worse designs overall and lack of trust in the designer (and designers in general) by the client.  It also blinded me to much bigger improvements that could be made to truly improve the guest‚Äôs stay.<br></p><p><br>&gt; Figure out how to use your room key and the task is done. You&#39;re in your room. Figure out how to type and you&#39;re at step 0 of a long list of steps towards writing anything remotely useful in Swift. Make every step slightly annoying and you&#39;ve got an infuriating language.<br></p><p>Why do you imagine that it has to be annoying or difficult?  You already told me that you find image literals ‚Äúbeginner-friendly‚Äù, and this could have a similar UX. It is not taking away any capability you have now, just adding the ability to use symbols much more easily when you want to.<br></p><p><br>&gt;  I was being slightly hyperbolic, but you are arguing that figuring out how to use autocomplete (or even use the option key to type a symbol) is too difficult for beginners.<br>&gt; <br>&gt; I&#39;m not arguing that it&#39;s &quot;too difficult&quot; a challenge to surmount--I&#39;m arguing that if we stick to ASCII the challenge would not exist in the first place, and that we should not challenge the user to any degree whatsoever with regards to typing. There are other, more salient challenges already.<br>&gt;  <br>&gt; You have also argued that having both ‚ÄòformsUnion‚Äô and the union symbol would be too much of a burden on someone learning the language.  You are assuming they will fail, no matter how well the UI is designed.  I am saying, there might be a brief moment where they are learning, but once they get it‚Ä¶ they will get it‚Ä¶ and they will be able to express themselves much more as a result.<br>&gt; <br>&gt; Also, I don‚Äôt think I have ever talked about requiring anyone to figure out the symbols.  Rather I have talked about building on-ramps to teach them to be able to use the symbols freely where they want to.<br>&gt; <br>&gt; I understand. There&#39;s a mini-argument here that I didn&#39;t write out. It&#39;s been said that Swift is an &quot;opinionated&quot; language, not a to-each-their-own/design-by-committee kind of language. Thus, afaict, the modus operandi is that what&#39;s decided to be the best way is adopted as the *only* way.<br>&gt; <br>&gt; Other than for compatibility reasons, perhaps, there are few if any aliases in the standard library. If we decide that the less-than-or-equal-to symbol is the best way to invoke that particular operation, then `&lt;=` would be deprecated and then in the next version removed. If that&#39;s too much to stomach, then it&#39;s a hint that perhaps the less-than-or-equal-to symbol isn&#39;t good enough to replace `&lt;=`. I don&#39;t see room for an in-between solution where the same function is named two or three ways.<br></p><p>If this is true, I would argue for ‚â§ (with &lt;= bringing up ‚â§ in autocomplete). I would also probably argue for a longer depreciation schedule.  We can argue about that in phase 2 though.<br></p><p>I am actually a little annoyed at the removal of appending(contentsOf:), because I used both that and ‚Äò+‚Äô, finding one or the other clearer in different contexts.  I‚Äôll get used to it eventually though.<br></p><p>&gt; I actually just finished teaching a Swift class for people who had never programmed before.  They had trouble with &lt;= (‚ÄúWhy does the arrow mean less than or equal? Why can‚Äôt I use ‚â§?&quot;) and != (‚ÄúBut the ! has to do with optionals‚Äù‚Ä¶ I think they thought it was unwrap and assign like *= is multiply and assign).  They were able to solve these issues, of course, as they are intelligent people‚Ä¶ but let‚Äôs not pretend that ASCII is magically free of confusion.<br>&gt; <br>&gt; If only you&#39;d read as many documents as I have where the less-than-or-equal-to sign is written by underlining &lt;, you would see that your proposed solution to these issues is not nearly as obvious as you make it out to be. (I&#39;m a biologist by training; the number of manuscripts in that field where one sees it written as &quot;&lt;&quot; [note to non-rich-text readers: that&#39;s &quot;&lt;&quot; with an underline] is very near 100%.) <br></p><p>Just because Microsoft Word is horrible and unintuitive, doesn‚Äôt mean that we have to be (also note that they were trying to make the ‚â§ symbol as opposed to writing &lt;= or something similar).  The point is that we can do better than the status quo‚Ä¶ and we should.<br></p><p><br>&gt; Having fewer available symbols means we are forced to chain the symbols we do have together in suboptimal ways (I believe there is talk of adding &lt;=&gt; to the standard library).<br>&gt; <br>&gt; <br>&gt;&gt; Let‚Äôs take, as an example, discovery of ‚ÄúformUnion‚Äù.  How will a user, who doesn‚Äôt know about this, discover it‚Äôs existence and how it works?<br>&gt;&gt; <br>&gt;&gt; ‚Ä¢ For the lucky people who already know about unions, but not swift‚Äôs crazy ‚ÄúformUnion‚Äù, they are in luck.  If they just start typing ‚Äòuni‚Ä¶‚Äô, then ‚ÄòformUnion‚Äô will show in the autocomplete.  Hmm‚Ä¶ sounds like the exact method I was talking about with symbols.<br>&gt;&gt; <br>&gt;&gt; ‚Ä¢ Maybe they will command-click into the definition file, and then see formUnion definition there.  But couldn‚Äôt they also see the union symbol defined there?<br>&gt;&gt; <br>&gt;&gt; ‚Ä¢ Maybe they search for the documentation and find ‚ÄúformUnion‚Äù explained on the page. Again, the same is true of the operator.<br>&gt;&gt; <br>&gt;&gt; OK, and if you&#39;ve never seen that symbol before, just how do you say &quot;‚à™&quot;? As in, literally, how would someone who just discovered such a hypothetical operator in Swift&#39;s documentation for SetAlgebra turn to another programmer and pronounce it? Here&#39;s the description in the documentation: &quot;Adds the elements of the given set to the set.&quot; Not very helpful for figuring that out, is it?<br>&gt; <br>&gt; In Xcode, they could mouse over it and see the word ‚Äúunion‚Äù.  In the documentation, it could say ‚ÄúUnion Operator. Adds the elements of the given set to the set.‚Äù  It could even have a hint on how to type it (e.g. &#39;^union‚Äô), and that part could be auto-generated.<br>&gt; <br>&gt; But if it needs to be documented as &quot;union operator&quot; and needs a tooltip to say &quot;union&quot; and you need to type &quot;^union&quot;, why wouldn&#39;t you just name it &quot;union&quot; _as it already is_?<br></p><p>Because it is much more concise.  It is essentially ‚Äúnamed‚Äù union‚Ä¶ we just have a shorthand way to display it that doesn‚Äôt have to distract as much from everything else.  Would you rather have: &#39;2.formSum(2)&#39; or ‚Äò2 + 2‚Äô ?  It makes a REAL difference when you are combining things into a fairly complex equation.  One line vs. half a page.  <br></p><p>The recent update from named methods to symbols in Decimal made my code so much more readable and clear.  The transformation is remarkable.  I can understand at a glance what I had to read and comprehend before.  Why should we deny ourselves similar clarity for set, vector, or matrix operations?<br></p><p><br>&gt;&gt; We do need to be aware of and support beginning users, but optimizing Swift (or any expert system) for beginners just leads to a disempowering experience for everyone.<br>&gt;&gt; <br>&gt;&gt; Disagree strongly. Easy things should be easy, even when they&#39;re part of complex systems. Not everyone learning Swift has to grasp copy-on-write on day 1, but no one should have to struggle with how to type something.<br>&gt; <br>&gt; I do agree that easy things should be easy. I am saying we can make this easy if we want to.  Easy enough that it can be used in any Swift code, even the core libraries when appropriate. <br>&gt; <br>&gt; Again, if a symbol isn‚Äôt clear, we shouldn‚Äôt use it (and we can argue over what is clear or not in other threads). We should use whatever is clearest and most expressive. If that is ASCII, that is great, and if it is unicode, also great.<br>&gt; <br>&gt; I&#39;m arguing that any ASCII character is at baseline, simply by virtue of having the increased recognition that ASCII characters do, clearer than any non-ASCII character to a general audience. There would have to be a huge win in expressiveness for any particular non-ASCII character to overcome that handicap. And I&#39;m arguing that the most plausible scenario in the standard library where we might see a huge win--the union operator--does not, for me, pass that bar.<br></p><p>Well, if on a case-by-case basis, we end up choosing ASCII characters and words, that is fine. I am just saying that we shouldn‚Äôt have a rule that limits us from choosing the best option in the case we decide it is the unicode version.<br></p><p><br>&gt; In the case of the menu item, it is used to teach an accelerator which saves time.  I am saying, we can use the same technique to teach symbols which are more concise, are more easily located in code, and are more representative.  If the symbol is less representative than the word in a particular case, then we should use the word.  We should use whatever is best.<br>&gt; <br>&gt; Yes, and I&#39;m saying, in the standard library, what&#39;s best isn&#39;t the symbol.<br></p><p>In most cases, the word is probably clearest.  But we decided ‚Äò+‚Äô (which is a symbol) is more clear than ‚ÄòformSum()‚Äô.  As I said above, I found a huge real world improvement from moving to symbols with Decimal.  I am sure that we will find other cases as well where symbols are helpful, especially as we start bringing in both heavy math (like vectors and matrices) and advanced string processing.<br></p><p><br>&gt; Again, this has nothing to do with how you write your own third-party libraries.<br>&gt; <br>&gt; Why should we force ourselves to use something, which is by definition, less clear/expressive?<br>&gt; <br>&gt; See above. I can&#39;t accept your premise that the clearest and most expressive choice for any standard library API would be a non-ASCII symbol.<br></p><p>Right, and that is something we can argue given the context of each issue.  I can‚Äôt accept the premise that you know FOR SURE that there aren‚Äôt cases where something else might be the best choice.<br></p><p><br>If we stop ourselves from even CONSIDERING other options, then I can tell you we won‚Äôt find the best one.  In my experience, productive creativity requires two phases:<br></p><p>1) Ideation - Where you generate lots of ideas (most of which are unworkable).  I tell my students that the road to GREAT ideas runs through bad ideas, so don‚Äôt stop with ideas that are merely ok.<br></p><p>2) Pruning - Where you take all of those ideas and nurture and sculpt the good ones‚Ä¶ picking just the one or two that work best.<br></p><p>I have found this list to be downright hostile at times towards anyone attempting step 1, and I think it is hurting us.  It may work for iterative refinement, but it makes big leaps much harder, so we get stuck in local maxima (and bike shedding).<br></p><p><br>When I was little, I was lucky enough to meet Buzz Aldrin, and he told me: ‚ÄúReach for the stars, and you might just touch the sky‚Äù.  I was confused, and asked him what it meant.  He said, ‚ÄúYou need to aim high, because you will surprise yourself with what you are capable of (even if you don‚Äôt reach your goal) and you will do better than you thought you ever could.  If you aim for your actual goal, you will never actually reach it.‚Äù  That stuck with me my whole life.<br></p><p>All I am saying is that we need to stop imagining that everything is too difficult (for ourselves and for ‚ÄúThe User‚Äù). Let‚Äôs figure out what we would want in an ideal world, and then we can figure out how to make some approximation work in our own...<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161031/babc16ce/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Meta] Let&#39;s talk TouchBar + Unicode</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 31, 2016 at 06:00:00pm</p></header><div class="content"><p>On Mon, Oct 31, 2016 at 5:45 PM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br></p><p>&gt; Premature standardization is just as bad as premature optimization...<br>&gt;<br>&gt; Because your arguments are assuming that the user can‚Äôt figure things out,<br>&gt;&gt; when they totally can. It is an extremely common (almost subconscious)<br>&gt;&gt; caricature of ‚ÄúThe User‚Äù.  As a young designer, I was yelled at once by Don<br>&gt;&gt; Norman for doing the same thing.  I was complaining about the design of a<br>&gt;&gt; room key (The arrow on the key needed more salience to afford how to use<br>&gt;&gt; it).  He replied, ‚ÄúSure, it could be better. Things can always be better‚Ä¶<br>&gt;&gt; but were you able to get into your room?‚Äù.  Yes, I had.  He then asked<br>&gt;&gt; several other people nearby if they were able to get into their rooms.<br>&gt;&gt; Everyone had.  ‚ÄúHow many people in the entire hotel do you think were not<br>&gt;&gt; able to get into their room because of this?  Tell me again why the hotel<br>&gt;&gt; should spend thousands of dollars to reprint their keys to solve this thing<br>&gt;&gt; which may be an annoyance, but hasn‚Äôt caused an actual problem?‚Äù.  He then<br>&gt;&gt; told me that people were much more capable than I was imagining them to be,<br>&gt;&gt; and that I should give them the credit they deserve because failing to do<br>&gt;&gt; so is ultimately harmful not just to the user of my designs, but to the<br>&gt;&gt; design profession in general.  It took me several years to really truly<br>&gt;&gt; understand what he meant‚Ä¶ but he was (as usual) right.<br>&gt;&gt;<br>&gt;<br>&gt; Perhaps he was right about your room key. But we&#39;re not designing room<br>&gt; keys here. (Also, have you *never* been annoyed by room keys and wondered<br>&gt; to yourself who the !@#$ designed that piece of crap? But I digress.)<br>&gt;<br>&gt;<br>&gt; Sorry if I was unclear.  The point is not that you shouldn‚Äôt deal with<br>&gt; annoyances (you should improve the keys on the next already scheduled<br>&gt; re-print).  The point was that I was imagining the problem to be much worse<br>&gt; (and much more urgent) than it actually was, because I wasn‚Äôt realistic<br>&gt; about the user‚Äôs capabilities.  It may be counter-intuitive, but it leads<br>&gt; to worse designs overall and lack of trust in the designer (and designers<br>&gt; in general) by the client.  It also blinded me to much bigger improvements<br>&gt; that could be made to truly improve the guest‚Äôs stay.<br>&gt;<br>&gt;<br>&gt; Figure out how to use your room key and the task is done. You&#39;re in your<br>&gt; room. Figure out how to type and you&#39;re at step 0 of a long list of steps<br>&gt; towards writing anything remotely useful in Swift. Make every step slightly<br>&gt; annoying and you&#39;ve got an infuriating language.<br>&gt;<br>&gt;<br>&gt; Why do you imagine that it has to be annoying or difficult?  You already<br>&gt; told me that you find image literals ‚Äúbeginner-friendly‚Äù, and this could<br>&gt; have a similar UX. It is not taking away any capability you have now, just<br>&gt; adding the ability to use symbols much more easily when you want to.<br>&gt;<br>&gt;<br>&gt;  I was being slightly hyperbolic, but you are arguing that figuring out<br>&gt; how to use autocomplete (or even use the option key to type a symbol) is<br>&gt; too difficult for beginners.<br>&gt;<br>&gt; I&#39;m not arguing that it&#39;s &quot;too difficult&quot; a challenge to surmount--I&#39;m<br>&gt; arguing that if we stick to ASCII the challenge would not exist in the<br>&gt; first place, and that we should not challenge the user to any degree<br>&gt; whatsoever with regards to typing. There are other, more salient challenges<br>&gt; already.<br>&gt;<br>&gt;<br>&gt;&gt; You have also argued that having both ‚ÄòformsUnion‚Äô and the union symbol<br>&gt;&gt; would be too much of a burden on someone learning the language.  You are<br>&gt;&gt; assuming they will fail, no matter how well the UI is designed.  I am<br>&gt;&gt; saying, there might be a brief moment where they are learning, but once<br>&gt;&gt; they get it‚Ä¶ they will get it‚Ä¶ and they will be able to express themselves<br>&gt;&gt; much more as a result.<br>&gt;&gt;<br>&gt;&gt; Also, I don‚Äôt think I have ever talked about requiring anyone to figure<br>&gt;&gt; out the symbols.  Rather I have talked about building on-ramps to teach<br>&gt;&gt; them to be able to use the symbols freely where they want to.<br>&gt;&gt;<br>&gt;<br>&gt; I understand. There&#39;s a mini-argument here that I didn&#39;t write out. It&#39;s<br>&gt; been said that Swift is an &quot;opinionated&quot; language, not a<br>&gt; to-each-their-own/design-by-committee kind of language. Thus, afaict, the<br>&gt; modus operandi is that what&#39;s decided to be the best way is adopted as the<br>&gt; *only* way.<br>&gt;<br>&gt; Other than for compatibility reasons, perhaps, there are few if any<br>&gt; aliases in the standard library. If we decide that the<br>&gt; less-than-or-equal-to symbol is the best way to invoke that particular<br>&gt; operation, then `&lt;=` would be deprecated and then in the next version<br>&gt; removed. If that&#39;s too much to stomach, then it&#39;s a hint that perhaps the<br>&gt; less-than-or-equal-to symbol isn&#39;t good enough to replace `&lt;=`. I don&#39;t see<br>&gt; room for an in-between solution where the same function is named two or<br>&gt; three ways.<br>&gt;<br>&gt;<br>&gt; If this is true, I would argue for ‚â§ (with &lt;= bringing up ‚â§ in<br>&gt; autocomplete). I would also probably argue for a longer depreciation<br>&gt; schedule.  We can argue about that in phase 2 though.<br>&gt;<br>&gt; I am actually a little annoyed at the removal of appending(contentsOf:),<br>&gt; because I used both that and ‚Äò+‚Äô, finding one or the other clearer in<br>&gt; different contexts.  I‚Äôll get used to it eventually though.<br>&gt;<br>&gt; I actually just finished teaching a Swift class for people who had never<br>&gt;&gt; programmed before.  They had trouble with &lt;= (‚ÄúWhy does the arrow mean less<br>&gt;&gt; than or equal? Why can‚Äôt I use ‚â§?&quot;) and != (‚ÄúBut the ! has to do with<br>&gt;&gt; optionals‚Äù‚Ä¶ I think they thought it was unwrap and assign like *= is<br>&gt;&gt; multiply and assign).  They were able to solve these issues, of course, as<br>&gt;&gt; they are intelligent people‚Ä¶ but let‚Äôs not pretend that ASCII is magically<br>&gt;&gt; free of confusion.<br>&gt;&gt;<br>&gt;<br>&gt; If only you&#39;d read as many documents as I have where the<br>&gt; less-than-or-equal-to sign is written by underlining &lt;, you would see that<br>&gt; your proposed solution to these issues is not nearly as obvious as you make<br>&gt; it out to be. (I&#39;m a biologist by training; the number of manuscripts in<br>&gt; that field where one sees it written as &quot;*&lt;*&quot; [note to non-rich-text<br>&gt; readers: that&#39;s &quot;&lt;&quot; with an underline] is very near 100%.)<br>&gt;<br>&gt;<br>&gt; Just because Microsoft Word is horrible and unintuitive, doesn‚Äôt mean that<br>&gt; we have to be (also note that they were trying to make the ‚â§ symbol as<br>&gt; opposed to writing &lt;= or something similar).  The point is that we can do<br>&gt; better than the status quo‚Ä¶ and we should.<br>&gt;<br>&gt;<br>&gt; Having fewer available symbols means we are forced to chain the symbols we<br>&gt;&gt; do have together in suboptimal ways (I believe there is talk of adding &lt;=&gt;<br>&gt;&gt; to the standard library).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Let‚Äôs take, as an example, discovery of ‚ÄúformUnion‚Äù.  How will a user,<br>&gt;&gt;&gt; who doesn‚Äôt know about this, discover it‚Äôs existence and how it works?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ‚Ä¢ For the lucky people who already know about unions, but not swift‚Äôs<br>&gt;&gt;&gt; crazy ‚ÄúformUnion‚Äù, they are in luck.  If they just start typing ‚Äòuni‚Ä¶‚Äô,<br>&gt;&gt;&gt; then ‚ÄòformUnion‚Äô will show in the autocomplete.  Hmm‚Ä¶ sounds like the exact<br>&gt;&gt;&gt; method I was talking about with symbols.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ‚Ä¢ Maybe they will command-click into the definition file, and then see<br>&gt;&gt;&gt; formUnion definition there.  But couldn‚Äôt they also see the union symbol<br>&gt;&gt;&gt; defined there?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ‚Ä¢ Maybe they search for the documentation and find ‚ÄúformUnion‚Äù explained<br>&gt;&gt;&gt; on the page. Again, the same is true of the operator.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; OK, and if you&#39;ve never seen that symbol before, just how do you say &quot;‚à™&quot;?<br>&gt;&gt; As in, literally, how would someone who just discovered such a hypothetical<br>&gt;&gt; operator in Swift&#39;s documentation for SetAlgebra turn to another programmer<br>&gt;&gt; and pronounce it? Here&#39;s the description in the documentation: &quot;Adds the<br>&gt;&gt; elements of the given set to the set.&quot; Not very helpful for figuring that<br>&gt;&gt; out, is it?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; In Xcode, they could mouse over it and see the word ‚Äúunion‚Äù.  In the<br>&gt;&gt; documentation, it could say ‚ÄúUnion Operator. Adds the elements of the given<br>&gt;&gt; set to the set.‚Äù  It could even have a hint on how to type it (e.g.<br>&gt;&gt; &#39;^union‚Äô), and that part could be auto-generated.<br>&gt;&gt;<br>&gt;<br>&gt; But if it needs to be documented as &quot;union operator&quot; and needs a tooltip<br>&gt; to say &quot;union&quot; and you need to type &quot;^union&quot;, why wouldn&#39;t you just name it<br>&gt; &quot;union&quot; _as it already is_?<br>&gt;<br>&gt;<br>&gt; Because it is much more concise.  It is essentially ‚Äúnamed‚Äù union‚Ä¶ we just<br>&gt; have a shorthand way to display it that doesn‚Äôt have to distract as much<br>&gt; from everything else.  Would you rather have: &#39;2.formSum(2)&#39; or ‚Äò2 + 2‚Äô ?<br>&gt; It makes a REAL difference when you are combining things into a fairly<br>&gt; complex equation.  One line vs. half a page.<br>&gt;<br>&gt; The recent update from named methods to symbols in Decimal made my code so<br>&gt; much more readable and clear.  The transformation is remarkable.  I can<br>&gt; understand at a glance what I had to read and comprehend before.  Why<br>&gt; should we deny ourselves similar clarity for set, vector, or matrix<br>&gt; operations?<br>&gt;<br></p><p>Again, I&#39;m not opposed to making the IDE better for Unicode. And I&#39;m not<br>opposed to having appropriate symbols for vector or matrix operations. You<br>keep returning to these points where we don&#39;t disagree.<br></p><p>The point I&#39;m trying to make is: the set algebra operations in the Standard<br>Library are implemented by general-purpose types such as CharacterSet.<br>These are not going to be participating in mathematical operations. No one<br>is denying anybody the use of mathematical symbols for mathematical<br>equations. But they are not appropriate, IMO, for the Standard Library.<br>This applies equally for less-than-or-equal-to signs, which are implemented<br>for all Equatable types, many of which (most?) are *not* geared towards<br>mathematical use cases.<br></p><p>Again, I&#39;d be perfectly content to see mathematical symbols aliasing the<br>appropriate functions in a separate library. That&#39;d be delightful. I&#39;d even<br>use it for math-heavy work.<br></p><p>We do need to be aware of and support beginning users, but optimizing Swift<br>&gt;&gt;&gt; (or any expert system) for beginners just leads to a disempowering<br>&gt;&gt;&gt; experience for everyone.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Disagree strongly. Easy things should be easy, even when they&#39;re part of<br>&gt;&gt; complex systems. Not everyone learning Swift has to grasp copy-on-write on<br>&gt;&gt; day 1, but no one should have to struggle with how to type something.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I do agree that easy things should be easy. I am saying we can make this<br>&gt;&gt; easy if we want to.  Easy enough that it can be used in any Swift code,<br>&gt;&gt; even the core libraries when appropriate.<br>&gt;&gt;<br>&gt;&gt; Again, if a symbol isn‚Äôt clear, we shouldn‚Äôt use it (and we can argue<br>&gt;&gt; over what is clear or not in other threads). We should use whatever is<br>&gt;&gt; clearest and most expressive. If that is ASCII, that is great, and if it is<br>&gt;&gt; unicode, also great.<br>&gt;&gt;<br>&gt;<br>&gt; I&#39;m arguing that any ASCII character is at baseline, simply by virtue of<br>&gt; having the increased recognition that ASCII characters do, clearer than any<br>&gt; non-ASCII character to a general audience. There would have to be a huge<br>&gt; win in expressiveness for any particular non-ASCII character to overcome<br>&gt; that handicap. And I&#39;m arguing that the most plausible scenario in the<br>&gt; standard library where we might see a huge win--the union operator--does<br>&gt; not, for me, pass that bar.<br>&gt;<br>&gt;<br>&gt; Well, if on a case-by-case basis, we end up choosing ASCII characters and<br>&gt; words, that is fine. I am just saying that we shouldn‚Äôt have a rule that<br>&gt; limits us from choosing the best option in the case we decide it is the<br>&gt; unicode version.<br>&gt;<br></p><p>See, I&#39;m -1 on the case-by-case evaluation of the Standard Library API,<br>which I think should stay as it is. Firstly, because we just went through a<br>whole bunch of renaming, and secondly, because I&#39;m arguing that<br>mathematically correct symbols, which are wonderful for a mathematical<br>library, don&#39;t belong in the Standard Library unless they&#39;re ASCII.<br></p><p>In the case of the menu item, it is used to teach an accelerator which<br>&gt;&gt; saves time.  I am saying, we can use the same technique to teach symbols<br>&gt;&gt; which are more concise, are more easily located in code, and are more<br>&gt;&gt; representative.  If the symbol is less representative than the word in a<br>&gt;&gt; particular case, then we should use the word.  We should use whatever is<br>&gt;&gt; best.<br>&gt;&gt;<br>&gt;<br>&gt; Yes, and I&#39;m saying, in the standard library, what&#39;s best isn&#39;t the symbol.<br>&gt;<br>&gt;<br>&gt; In most cases, the word is probably clearest.  But we decided ‚Äò+‚Äô (which<br>&gt; is a symbol) is more clear than ‚ÄòformSum()‚Äô.  As I said above, I found a<br>&gt; huge real world improvement from moving to symbols with Decimal.  I am sure<br>&gt; that we will find other cases as well where symbols are helpful, especially<br>&gt; as we start bringing in both heavy math (like vectors and matrices) and<br>&gt; advanced string processing.<br>&gt;<br></p><p>I believe the core team has made clear that vector and matrix math will<br>*not* be a part of the standard library. I&#39;m not sure where non-ASCII<br>symbols come into advanced string processing. I&#39;m not aware of any and<br>wouldn&#39;t know how to interpret any that I did come across.<br></p><p>Again, this has nothing to do with how you write your own third-party<br>&gt; libraries.<br>&gt;<br>&gt; Why should we force ourselves to use something, which is by definition,<br>&gt;&gt; less clear/expressive?<br>&gt;&gt;<br>&gt;<br>&gt; See above. I can&#39;t accept your premise that the clearest and most<br>&gt; expressive choice for any standard library API would be a non-ASCII symbol.<br>&gt;<br>&gt;<br>&gt; Right, and that is something we can argue given the context of each<br>&gt; issue.  I can‚Äôt accept the premise that you know FOR SURE that there aren‚Äôt<br>&gt; cases where something else might be the best choice.<br>&gt;<br>&gt;<br>&gt; If we stop ourselves from even CONSIDERING other options, then I can tell<br>&gt; you we won‚Äôt find the best one.  In my experience, productive creativity<br>&gt; requires two phases:<br>&gt;<br>&gt; 1) Ideation - Where you generate lots of ideas (most of which are<br>&gt; unworkable).  I tell my students that the road to GREAT ideas runs through<br>&gt; bad ideas, so don‚Äôt stop with ideas that are merely ok.<br>&gt;<br>&gt; 2) Pruning - Where you take all of those ideas and nurture and sculpt the<br>&gt; good ones‚Ä¶ picking just the one or two that work best.<br>&gt;<br>&gt; I have found this list to be downright hostile at times towards anyone<br>&gt; attempting step 1, and I think it is hurting us.  It may work for iterative<br>&gt; refinement, but it makes big leaps much harder, so we get stuck in local<br>&gt; maxima (and bike shedding).<br>&gt;<br>&gt;<br>&gt; When I was little, I was lucky enough to meet Buzz Aldrin, and he told me:<br>&gt; ‚ÄúReach for the stars, and you might just touch the sky‚Äù.  I was confused,<br>&gt; and asked him what it meant.  He said, ‚ÄúYou need to aim high, because you<br>&gt; will surprise yourself with what you are capable of (even if you don‚Äôt<br>&gt; reach your goal) and you will do better than you thought you ever could.<br>&gt; If you aim for your actual goal, you will never actually reach it.‚Äù  That<br>&gt; stuck with me my whole life.<br>&gt;<br>&gt; All I am saying is that we need to stop imagining that everything is too<br>&gt; difficult (for ourselves and for ‚ÄúThe User‚Äù). Let‚Äôs figure out what we<br>&gt; would want in an ideal world, and then we can figure out how to make some<br>&gt; approximation work in our own...<br>&gt;<br></p><p>Again, to reiterate, I&#39;m -1 on any ideation regarding revisions to Standard<br>Library APIs that involve the use of non-ASCII symbols, for the reasons<br>I&#39;ve written above and in previous emails. Sorry.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161031/f7e1b773/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Meta] Let&#39;s talk TouchBar + Unicode</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>October 29, 2016 at 04:00:00pm</p></header><div class="content"><p>Well said. For what it is worth, I agree entirely. Let&#39;s move programming forward a little!<br></p><p>l8r<br>Sean<br></p><p>Sent from my iPad<br></p><p>&gt; On Oct 29, 2016, at 4:14 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 29, 2016, at 8:11 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; However, *my* main point is that the Swift&#39;s standard library APIs (and the keywords and syntax at the core of the language) should use a character set that *requires no discovery whatsoever* for the vast majority of users. It is difficult enough to master a programming language, more difficult still to master one&#39;s first programming language (and--per the core team--Swift aims to be a great first programming language to learn); it is _bonkers_ to pile onto that the need to &quot;discover&quot; (however smoothly that goes) how to physically input the characters required to invoke some method.<br>&gt; <br>&gt; I am always amazed at this caricature of users as somehow simultaneously complete idiots (unable to figure out the option key) and experts in archaic computer architecture (‚Ä¶and they use vim).  It is extremely disrespectful to the actual user.  A good rule of thumb is to think of the user as extremely intelligent, but too busy and important to deal with your interface.<br>&gt; <br>&gt; From today‚Äôs Daring Fireball:<br>&gt;&gt; Apple has always been very good at this ‚Äî designing software and hardware where complexity is encapsulated rather than hidden. The genius of the original Mac wasn‚Äôt that it was suitable for dummies but that it was the first system that wasn‚Äôt confusing. Smart people flocked to the Mac.<br>&gt; <br>&gt; <br>&gt; There is, by definition, always discovery.  I think what you are really arguing is that there is forward transfer from things like word processing, and there is‚Ä¶ it is important.  But there are also still tradeoffs forced by your limitations that harm discovery in other ways (not to mention that I often use ‚â† and ‚â§ in word processing).<br>&gt; <br>&gt; <br>&gt; Let‚Äôs take, as an example, discovery of ‚ÄúformUnion‚Äù.  How will a user, who doesn‚Äôt know about this, discover it‚Äôs existence and how it works?<br>&gt; <br>&gt; ‚Ä¢ For the lucky people who already know about unions, but not swift‚Äôs crazy ‚ÄúformUnion‚Äù, they are in luck.  If they just start typing ‚Äòuni‚Ä¶‚Äô, then ‚ÄòformUnion‚Äô will show in the autocomplete.  Hmm‚Ä¶ sounds like the exact method I was talking about with symbols.<br>&gt; <br>&gt; ‚Ä¢ Maybe they will command-click into the definition file, and then see formUnion definition there.  But couldn‚Äôt they also see the union symbol defined there?<br>&gt; <br>&gt; ‚Ä¢ Maybe they search for the documentation and find ‚ÄúformUnion‚Äù explained on the page. Again, the same is true of the operator.<br>&gt; <br>&gt; There is the issue of how to learn from an already typed symbol how to type it, but I can think of several easy ways to do that in the UI (even something as simple as a tooltip). I trust the Xcode team to be able to come up with something appropriate and user test it as necessary.  (What about vim users?  I trust they can figure it out)<br>&gt; <br>&gt; <br>&gt; We do need to be aware of and support beginning users, but optimizing Swift (or any expert system) for beginners just leads to a disempowering experience for everyone.  Instead, we need to optimize for the users they will become, and provide ‚Äúon-ramps‚Äù for the beginners.  This is UX 101.  Alan Cooper is probably the one who talks about this problem most, but any well trained designer will tell you the same.<br>&gt; <br>&gt; You were characterizing having both ‚ÄòformUnion‚Äô and the union symbol operator (or both &lt;= and ‚â§) as a burden on the user‚Äôs feeble mind, but it isn‚Äôt.  It is an on-ramp.  It teaches them how to use the system!  Are people confused by having ‚ÄòSave‚Äô in the menu bar and also ‚åòS?  Or does the save menu command teach them how to use the keyboard to save time?<br>&gt; <br>&gt; I should point out that all of your arguments also argue against things like color and image literals (which are features I absolutely love). I am really glad that those didn‚Äôt have to go through this process, because we never would have done it.  I guess that is what is worrying me‚Ä¶<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161029/738c0057/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>[Meta] Let&#39;s talk TouchBar + Unicode</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>October 31, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On 29 Oct 2016, at 03:22, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Given the adage here that code is more frequently read than written, it is unreasonable to require someone to master both &quot;form union&quot; and the union operator when one of these will do. While you and I are comfortable with set algebra notation, not everyone who uses Swift will be, and currently they *do not have to be* in order to be perfectly proficient at Swift. It does not sway me that you can now more easily type a character on a potential future device. It matters to me that someone not familiar with set algebra would have a hard time even looking up what such a non-ASCII character is when he or she first encounters it in, say, a textbook.<br></p><p>Somebody not familiar with set algebra is not going to understand what ‚ÄúformUnion‚Äù means either. Either way they are going to have to look it up. Google returns the link in the Apple documentation as the top hit for formUnion, and it returns the Wikipedia page for set unions for ‚à™, so not a terrible disaster for discoverability. However ‚Ä¶<br></p><p>&gt; <br>&gt; Now, to be clear, a third-party Swift library should be free to adopt any language or character set, and we should make the tooling as robust and convenient as possible for that use case, but the choice for Swift standard library APIs--themselves deliberately restricted in scope--should be the minimum required for clearly expressing what these APIs are. A person should not need to buy a special keyboard or device, or know how to work the option/alt key, in order to write the less-than-or-equal-to operator. OTOH, there&#39;s nothing wrong with a third-party project to decide that its API will be Sanskrit-only and require proficiency in the associated script for use.<br></p><p>This I agree with 100%: the functions and operators of the standard library have to be typed in by everybody who programs in Swift. Not everybody has a MacBookPro with a touch bar (in fact, not anybody just yet, except for a lucky few). Not everybody wants to program with an iPad. Some people even like to program in Swift with text editors that aren‚Äôt Xcode. I expect there are programmers (especially on Linux) whose preferred editor is vi or even Emacs. For that reason, the Swift Standard Library has to be fairly lowest common denominator in terms of characters used.<br></p><p>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e2303da56647c283b6d8e58d5831faca?s=50"></div><header><strong>[Meta] Let&#39;s talk TouchBar + Unicode</strong> from <string>Joseph Bell</string> &lt;joe at iachieved.it&gt;<p>October 31, 2016 at 09:00:00pm</p></header><div class="content"><p>-1 I agree with Jeremy and Xiaodi with regards to adding non-ASCII<br>characters to the language core/standard library.  Jeremy summed it up<br>nicely here, emphasis mine:<br></p><p>&quot;This I agree with 100%: the functions and operators of the standard<br>library have to be typed in by everybody who programs in Swift. *Not<br>everybody has a MacBookPro with a touch bar* (in fact, not anybody just<br>yet, except for a lucky few). *Not everybody wants to program with an iPad*.<br>Some people *even like to program in Swift with text editors that aren‚Äôt<br>Xcode. I expect there are programmers (especially on Linux) whose preferred<br>editor is vi or even Emacs.* For that reason, the Swift Standard Library<br>has to be fairly lowest common denominator in terms of characters used.&quot;<br></p><p>I frequently code Swift on Linux with both vi and Emacs, and I&#39;m on<br>touch-typist keyboards (Das Keyboard w/ no glyphs) with years of muscle<br>memory typing quick sequences such as &lt;= or !=.  Adding glyphs that cannot<br>be typed with 1 or 2 sequences (i.e., relying on a touchbar or relying on<br>an editor recognizing the &quot;macOS-style&quot; sequence of holding a key down long<br>enough to get options) or adding :less-than-or-equal-to: would be an<br>unwelcome addition.<br></p><p>-Joe<br></p><p>On Mon, Oct 31, 2016 at 9:07 AM, Jeremy Pereira via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On 29 Oct 2016, at 03:22, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Given the adage here that code is more frequently read than written, it<br>&gt; is unreasonable to require someone to master both &quot;form union&quot; and the<br>&gt; union operator when one of these will do. While you and I are comfortable<br>&gt; with set algebra notation, not everyone who uses Swift will be, and<br>&gt; currently they *do not have to be* in order to be perfectly proficient at<br>&gt; Swift. It does not sway me that you can now more easily type a character on<br>&gt; a potential future device. It matters to me that someone not familiar with<br>&gt; set algebra would have a hard time even looking up what such a non-ASCII<br>&gt; character is when he or she first encounters it in, say, a textbook.<br>&gt;<br>&gt; Somebody not familiar with set algebra is not going to understand what<br>&gt; ‚ÄúformUnion‚Äù means either. Either way they are going to have to look it up.<br>&gt; Google returns the link in the Apple documentation as the top hit for<br>&gt; formUnion, and it returns the Wikipedia page for set unions for ‚à™, so not a<br>&gt; terrible disaster for discoverability. However ‚Ä¶<br>&gt;<br>&gt; &gt;<br>&gt; &gt; Now, to be clear, a third-party Swift library should be free to adopt<br>&gt; any language or character set, and we should make the tooling as robust and<br>&gt; convenient as possible for that use case, but the choice for Swift standard<br>&gt; library APIs--themselves deliberately restricted in scope--should be the<br>&gt; minimum required for clearly expressing what these APIs are. A person<br>&gt; should not need to buy a special keyboard or device, or know how to work<br>&gt; the option/alt key, in order to write the less-than-or-equal-to operator.<br>&gt; OTOH, there&#39;s nothing wrong with a third-party project to decide that its<br>&gt; API will be Sanskrit-only and require proficiency in the associated script<br>&gt; for use.<br>&gt;<br>&gt; This I agree with 100%: the functions and operators of the standard<br>&gt; library have to be typed in by everybody who programs in Swift. Not<br>&gt; everybody has a MacBookPro with a touch bar (in fact, not anybody just yet,<br>&gt; except for a lucky few). Not everybody wants to program with an iPad. Some<br>&gt; people even like to program in Swift with text editors that aren‚Äôt Xcode. I<br>&gt; expect there are programmers (especially on Linux) whose preferred editor<br>&gt; is vi or even Emacs. For that reason, the Swift Standard Library has to be<br>&gt; fairly lowest common denominator in terms of characters used.<br>&gt;<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Joseph Bell<br>http://dev.iachieved.it/iachievedit/<br>@iachievedit<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161031/f2f4d82e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Meta] Let&#39;s talk TouchBar + Unicode</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>October 29, 2016 at 09:00:00am</p></header><div class="content"><p>There are people out there who insist on using spaces for indention, just because of fear that some odd editor might not be able to deal with tabs properly‚Ä¶ so even if this idea doesn&#39;t require a TouchBar, I don&#39;t think we should replace words with somewhat exotic characters:<br>Swift code will be written on computers without a TouchBar (which still has to prove its value), and even without Xcode.<br>So I&#39;d focus the discussion on wether it makes sense to have two different ways to refer to common operations and constants (do you want œÄ ? ;-), or if this would be a source of confusion.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Meta] Let&#39;s talk TouchBar + Unicode</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>October 29, 2016 at 11:00:00am</p></header><div class="content"><p>Eh, I&#39;m all for better emoji support but I think this needs to come in at the OS level.<br></p><p>Part of the problem for emoji is that the macOS special characters menu is so awkward to use; coincidentally I actually posted an enhancement request to the Apple bug reporter only yesterday asking for a more Spotlight-search like special characters selector. i.e- rather than the the awkward, tiny and hard to dismiss window something with immediate searching by relevant tags, either narrowing down for easy selection, or hitting enter for the top result.<br></p><p>In short; I don&#39;t think it&#39;s a Swift or even Xcode specific issue, and definitely shouldn&#39;t be part of auto-complete IMO. The real problem is that the macOS special characters selector is terrible, and has changed very little since OS X first appeared, except to be slightly rebranded for emojis (despite being no easier to use). Most apps that provide their own picker are vastly superior.<br></p><p>&gt; On 29 Oct 2016, at 01:34, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Given that Swift supports unicode, and it looks like this TouchBar will make typing relevant characters/symbols much more accessible/discoverable, I think we should move forward with the assumption that we will be able to type (somehow) whatever symbol we feel best represents something, and we should start looking for opportunities to use this where it makes sense.<br>&gt; <br>&gt; <br>&gt; The big issue is how to provide similar support for pre-touchbar devices (and non-Apple devices), and there are lots of options (of which I will list just a few below):<br>&gt; <br>&gt; ‚Ä¢ Have emojis and symbols in the autocomplete list when appropriate by typing human readable names (i.e. ‚ÄòDog Face‚Äô instead of U+1F436, or ‚Äòunion‚Äô for ‚à™).  Optionally, we could have an easy symbol (e.g. $ or ^) which hints to the autocomplete that we might want a symbol (similar to how typing @ in Facebook brings up an autocomplete list of friends).  Thus typing ‚Äò^u‚Äô would bring up &#39;‚à™&#39; near the top of the list (and you could continue typing ‚Äò^union‚Äô if needed to disambiguate)<br>&gt; <br>&gt; ‚Ä¢ Allow autocomplete when using the short code (e.g. :dog: for üê∂)<br>&gt; <br>&gt; ‚Ä¢ Have a bar along the bottom of the screen (kind of like the one which shows up when a keyboard is docked with an iPad) which maps to the function keys, and has similar options to what the TouchBar would have.<br>&gt; <br>&gt; ‚Ä¢ For those using just a text editor, utilities like TextExpander (or the built in text expanding capabilities of OS X &amp; other platforms).  Pretty much every platform has a built in way to type unicode/emoji.  It may not be the easiest, but hey, that is true of many platforms in general.  There typically exist utilities to make it easier.<br>&gt; <br>&gt; .<br>&gt; <br>&gt; My main point, is that we should proceed as if everything we want to do in terms of input is possible, and trust that the Xcode team (and other IDE developers) will do what is required to make it work (or will speak up in particular cases to tell us we are headed in the wrong direction)‚Ä¶ as opposed to assuming that things are impossible and not pushing the limits at all.<br>&gt; <br>&gt; Note: I am not saying we should use these things frivolously‚Ä¶ just that we shouldn‚Äôt be afraid to use them when they make a lot of sense (We have previously rejected several proposals because they are hard to type on one kind of keyboard or another).<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt; PS.  I am also ok having some overlap (e.g. both the union operator and ‚ÄòformUnion‚Äô, where one maps to the other) while technology is disseminating.  They can always go through a depreciation cycle later if we decide to consolidate.  I just don‚Äôt think we should wait, because then we will never start...<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4c60436f08b7b107f0bb0848c31297fa?s=50"></div><header><strong>[Meta] Let&#39;s talk TouchBar + Unicode</strong> from <string>Alex Blewitt</string> &lt;alblue at apple.com&gt;<p>October 31, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 29 Oct 2016, at 11:10, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Part of the problem for emoji is that the macOS special characters menu is so awkward to use; coincidentally I actually posted an enhancement request to the Apple bug reporter only yesterday asking for a more Spotlight-search like special characters selector. i.e- rather than the the awkward, tiny and hard to dismiss window something with immediate searching by relevant tags, either narrowing down for easy selection, or hitting enter for the top result.<br></p><p>When typing you can use Control + Command + Space to bring up the same kind of emoji keyboard as on iOS; and it searches by name as well, so you can use the spotlight-like-search selector:<br></p><p>[üîçpump      ‚ìß] [‚†ø‚åò]<br>üë† üéÉ ‚õΩÔ∏è ‚õΩ<br></p><p><br>Screenshot in case the unicode characters don&#39;t survive:<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161031/9971a2dc/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: Screen Shot 2016-10-31 at 10.11.51.png<br>Type: image/png<br>Size: 40159 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161031/9971a2dc/attachment.png&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Meta] Let&#39;s talk TouchBar + Unicode</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>October 31, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On 31 Oct 2016, at 10:14, Alex Blewitt &lt;alblue at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 29 Oct 2016, at 11:10, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Part of the problem for emoji is that the macOS special characters menu is so awkward to use; coincidentally I actually posted an enhancement request to the Apple bug reporter only yesterday asking for a more Spotlight-search like special characters selector. i.e- rather than the the awkward, tiny and hard to dismiss window something with immediate searching by relevant tags, either narrowing down for easy selection, or hitting enter for the top result.<br>&gt; <br>&gt; When typing you can use Control + Command + Space to bring up the same kind of emoji keyboard as on iOS; and it searches by name as well, so you can use the spotlight-like-search selector:<br>&gt; <br>&gt; [üîçpump      ‚ìß] [‚†ø‚åò]<br>&gt; üë† üéÉ ‚õΩÔ∏è ‚õΩ<br>&gt; <br>&gt; <br>&gt; Screenshot in case the unicode characters don&#39;t survive:<br>&gt; &lt;Screen Shot 2016-10-31 at 10.11.51.png&gt;<br></p><p>Huh, this must be new on macOS Sierra? I&#39;m still on El Capitan where it definitely does not work that way üòâ<br>If so it may be a reason to upgrade, as adding the winking emoji just there was a pain in the arse.<br></p><p>In that case though I&#39;m not sure what extra support Swift really needs, as key-combo plus type-to-search ought to be more than fast enough, no need to overburden auto-complete etc.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161031/3d0ee6f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>[Meta] Let&#39;s talk TouchBar + Unicode</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>October 31, 2016 at 05:00:00pm</p></header><div class="content"><p>FYI, the emoji bar with ctrl cmd space has worked that way since at the<br>very least El capit√°n, and I think as far back as mavericks.<br></p><p>Le lun. 31 oct. 2016 11:59, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; a √©crit :<br></p><p>&gt; On 31 Oct 2016, at 10:14, Alex Blewitt &lt;alblue at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 29 Oct 2016, at 11:10, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Part of the problem for emoji is that the macOS special characters menu is<br>&gt; so awkward to use; coincidentally I actually posted an enhancement request<br>&gt; to the Apple bug reporter only yesterday asking for a more Spotlight-search<br>&gt; like special characters selector. i.e- rather than the the awkward, tiny<br>&gt; and hard to dismiss window something with immediate searching by relevant<br>&gt; tags, either narrowing down for easy selection, or hitting enter for the<br>&gt; top result.<br>&gt;<br>&gt;<br>&gt; When typing you can use Control + Command + Space to bring up the same<br>&gt; kind of emoji keyboard as on iOS; and it searches by name as well, so you<br>&gt; can use the spotlight-like-search selector:<br>&gt;<br>&gt; [üîçpump      ‚ìß] [‚†ø‚åò]<br>&gt; üë† üéÉ ‚õΩÔ∏è ‚õΩ<br>&gt;<br>&gt;<br>&gt; Screenshot in case the unicode characters don&#39;t survive:<br>&gt;<br>&gt; &lt;Screen Shot 2016-10-31 at 10.11.51.png&gt;<br>&gt;<br>&gt;<br>&gt; Huh, this must be new on macOS Sierra? I&#39;m still on El Capitan where it<br>&gt; definitely does not work that way üòâ<br>&gt; If so it may be a reason to upgrade, as adding the winking emoji just<br>&gt; there was a pain in the arse.<br>&gt;<br>&gt; In that case though I&#39;m not sure what extra support Swift really needs, as<br>&gt; key-combo plus type-to-search ought to be more than fast enough, no need to<br>&gt; overburden auto-complete etc.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161031/269d6b9d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
