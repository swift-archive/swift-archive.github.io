<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Comparing POP to OOP</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March 10, 2016 at 04:00:00pm</p></header><div class="content"><p>on Tue Mar 08 2016, Jon Hoffman &lt;swift-users-AT-swift.org&gt; wrote:<br></p><p>&gt;&gt; On Mar 8, 2016, at 1:40 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon Mar 07 2016, Jon Hoffman &lt;hoffman.jon-AT-gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So for the last two hours or so I put myself on a task to create a<br>&gt;&gt;&gt; mutable linked list using value types and to do it in an elegant way<br>&gt;&gt;&gt; (Hey I love challenges and beating my head against the wall).  <br>&gt;&gt; <br>&gt;&gt; A linked list that conforms to MutableCollection with the right<br>&gt;&gt; efficiency characteristics for linked lists *and* value semantics is a<br>&gt;&gt; tough problem.<br>&gt;&gt; <br>&gt;&gt; I think under the proposed new indexing model you can just build it on<br>&gt;&gt; top of an Array, though ;-)<br>&gt;<br>&gt; But where is the fun in using an Array?  The greater the challenge, the more rewarding it is to overcome it :)  <br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; While I have found one working solution so far it is pretty ugly<br>&gt;&gt;&gt; therefore I have to ask myself, that even though it is preferred that<br>&gt;&gt;&gt; we use value types overall, should it be preferred that we use<br>&gt;&gt;&gt; reference types for mutable data structures like this?  <br>&gt;&gt; <br>&gt;&gt; What do you mean by “like this?”  Array is a mutable data structure; is<br>&gt;&gt; it “like this?”<br>&gt;&gt; <br>&gt;&gt; You&#39;re going to use reference types in the *implementation* of any type<br>&gt;&gt; that has arbitrary growth.  Array uses a reference internally.<br>&gt;<br>&gt; Actually we should be able to make a decent stack out of a value type<br>&gt; without a reference type behind it.  Something like this:<br>&gt;<br>&gt; enum Stack&lt;T&gt; {<br>&gt;     case Empty<br>&gt;     indirect case Node(T, next: Stack&lt;T&gt;)<br>&gt;<br>&gt;     mutating func push(value: T) {<br>&gt;         self = .Node(value, next:self)<br>&gt;     }<br>&gt;<br>&gt;     mutating func pop() -&gt; T? {<br>&gt;         switch self {<br>&gt;         case .Empty: return nil<br>&gt;         case let .Node(value, next: next):<br>&gt;             self = next<br>&gt;             return value<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Can use it like this:<br>&gt;<br>&gt; var stack = Stack&lt;Int&gt;.Empty<br>&gt; stack.push(1)<br>&gt; stack.push(2)<br>&gt; stack.push(3)<br>&gt; stack.pop()<br>&gt; stack.pop()<br></p><p>Leaving aside the reference implied by &quot;indirect,&quot; this type is not<br>mutable by parts.<br></p><p>You can build that same thing trivially with an immutable class; you just<br>lose the method syntax because our class methods aren&#39;t allowed to write<br>back to the original reference, so you end up with<br></p><p>  push(&amp;stack, 1)<br></p><p>etc.<br></p><p>That&#39;s just a syntactic distinction The real /semantic/ distinction<br>between value types and reference types occurs when you are doing<br>mutation of just a part:<br></p><p>&gt;&gt;&gt; Trust me, I have not giving up finding an elegant solution yet just<br>&gt;&gt;&gt; wondering your thoughts on that.<br>&gt;&gt; <br>&gt;&gt; My feeling is that linked lists are almost never the best answer in<br>&gt;&gt; real programs, but if you *really* need their characteristics you<br>&gt;&gt; might want to implement them with reference semantics.<br>&gt;&gt; <br>&gt;<br>&gt; True but linked lists, stacks and queues are good data structures to<br>&gt; play with especially when demonstrating what data structures are and<br>&gt; how they work.<br></p><p>Sure.  But when you&#39;re demonstrating linked data structures, do they<br>need to be value types?  Do you even want the complication implied by<br>the CoW that&#39;s needed?<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c8bc65b07027beac76b917624be47611?s=50"></div><header><strong>Comparing POP to OOP</strong> from <string>Jon Hoffman</string> &lt;hoffman.jon at gmail.com&gt;<p>March 10, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Mar 10, 2016, at 7:05 PM, Dave Abrahams via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Tue Mar 08 2016, Jon Hoffman &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Mar 8, 2016, at 1:40 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Mon Mar 07 2016, Jon Hoffman &lt;hoffman.jon-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So for the last two hours or so I put myself on a task to create a<br>&gt;&gt;&gt;&gt; mutable linked list using value types and to do it in an elegant way<br>&gt;&gt;&gt;&gt; (Hey I love challenges and beating my head against the wall).  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A linked list that conforms to MutableCollection with the right<br>&gt;&gt;&gt; efficiency characteristics for linked lists *and* value semantics is a<br>&gt;&gt;&gt; tough problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think under the proposed new indexing model you can just build it on<br>&gt;&gt;&gt; top of an Array, though ;-)<br>&gt;&gt; <br>&gt;&gt; But where is the fun in using an Array?  The greater the challenge, the more rewarding it is to overcome it :)  <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; While I have found one working solution so far it is pretty ugly<br>&gt;&gt;&gt;&gt; therefore I have to ask myself, that even though it is preferred that<br>&gt;&gt;&gt;&gt; we use value types overall, should it be preferred that we use<br>&gt;&gt;&gt;&gt; reference types for mutable data structures like this?  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What do you mean by “like this?”  Array is a mutable data structure; is<br>&gt;&gt;&gt; it “like this?”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You&#39;re going to use reference types in the *implementation* of any type<br>&gt;&gt;&gt; that has arbitrary growth.  Array uses a reference internally.<br>&gt;&gt; <br>&gt;&gt; Actually we should be able to make a decent stack out of a value type<br>&gt;&gt; without a reference type behind it.  Something like this:<br>&gt;&gt; <br>&gt;&gt; enum Stack&lt;T&gt; {<br>&gt;&gt;    case Empty<br>&gt;&gt;    indirect case Node(T, next: Stack&lt;T&gt;)<br>&gt;&gt; <br>&gt;&gt;    mutating func push(value: T) {<br>&gt;&gt;        self = .Node(value, next:self)<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    mutating func pop() -&gt; T? {<br>&gt;&gt;        switch self {<br>&gt;&gt;        case .Empty: return nil<br>&gt;&gt;        case let .Node(value, next: next):<br>&gt;&gt;            self = next<br>&gt;&gt;            return value<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Can use it like this:<br>&gt;&gt; <br>&gt;&gt; var stack = Stack&lt;Int&gt;.Empty<br>&gt;&gt; stack.push(1)<br>&gt;&gt; stack.push(2)<br>&gt;&gt; stack.push(3)<br>&gt;&gt; stack.pop()<br>&gt;&gt; stack.pop()<br>&gt; <br>&gt; Leaving aside the reference implied by &quot;indirect,&quot; this type is not<br>&gt; mutable by parts.<br></p><p>I was responding to your statement that we needed reference types in the implementation of any type that has arbitrary growth.  I wasn’t implying that the individual parts were mutable :). I do understand that using indirect causes the value to be stored indirectly but that is how we create recursive value types.     <br></p><p>&gt; <br>&gt; You can build that same thing trivially with an immutable class; you just<br>&gt; lose the method syntax because our class methods aren&#39;t allowed to write<br>&gt; back to the original reference, so you end up with<br>&gt; <br>&gt;  push(&amp;stack, 1)<br>&gt; <br>&gt; etc.<br>&gt; <br>&gt; That&#39;s just a syntactic distinction The real /semantic/ distinction<br>&gt; between value types and reference types occurs when you are doing<br>&gt; mutation of just a part:<br>&gt; <br>&gt;&gt;&gt;&gt; Trust me, I have not giving up finding an elegant solution yet just<br>&gt;&gt;&gt;&gt; wondering your thoughts on that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My feeling is that linked lists are almost never the best answer in<br>&gt;&gt;&gt; real programs, but if you *really* need their characteristics you<br>&gt;&gt;&gt; might want to implement them with reference semantics.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; True but linked lists, stacks and queues are good data structures to<br>&gt;&gt; play with especially when demonstrating what data structures are and<br>&gt;&gt; how they work.<br>&gt; <br>&gt; Sure.  But when you&#39;re demonstrating linked data structures, do they<br>&gt; need to be value types?  Do you even want the complication implied by<br>&gt; the CoW that&#39;s needed?<br>&gt; <br></p><p>They absolutely do not need to be value types however sometimes it is fun to challenge yourself to see if you can figure out how to do something.  Who does’t love a good challenge :).  I probably would not use these for anything in production but the exercise and challenge itself can be fun.  I wasn’t even aware that we could make recursive value types until you correctly me earlier in this e-mail chain when I said we couldn’t do it.  The reason I was not aware that we could do recursive value types is because they are not something I would really use but since you mentioned that I could create them, I wanted to see what I could do with them.<br></p><p>Jon<br></p><p>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
