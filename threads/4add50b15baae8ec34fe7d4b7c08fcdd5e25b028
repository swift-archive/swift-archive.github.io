<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>Dropping NS Prefix in Foundation</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>May  7, 2016 at 06:00:00am</p></header><div class="content"><p>-1 on this as well.  How much does dropping NS really help things anyway?  <br></p><p>All it does is force everyone to learn which things still have NS and which don’t.  It also makes things much more difficult to search for… searching for NS_ gives the results you want quickly vs searching for anything in Swift foundation (e.g. Array -- which gives you a mixture of other programming languages and Taylor Swift gossip).<br></p><p>My proposal would be to keep NS for everything and then slowing making versions without the prefix, either by rewriting them to be better in Swift or simply aliasing the NS version.  Once you have critical mass for useful things (around Swift 5~6), you can separate all the NSStuff out into their own NSFoundation which would be used only for backwards compatibility.<br></p><p>To the inevitable question: Wont having NS and Non-NS versions be confusing (especially if some are just aliases)?  My answer is that it is less confusing than this proposal. There is a simple rule: Things without NS are always the new and preferred methods. Things with NS are there for compatibility and will continue to work the way they do in ObjectiveC (even if you have to import “NSFoundation” to get them instead of just “Foundation&quot;)<br></p><p>Side Note: I would also REALLY like to see a swift native improvement on NSAttributedString with native literal support.<br></p><p>&gt; There’s no question that we can improve Coding for Swift. I have actually explored this area quite a bit although I don’t have anything planned for Swift 3 at this time.<br>&gt; <br>&gt; The general point is though, that we can do it by extending Foundation in that direction over time. In fact, keyed archiving is the perfect example of how we were able to do just that in the past in Objective-C. NSArchiver already existed and served a particular purpose, so we extended the concept into NSKeyedArchiver using the facilities available to us at the time.<br>I would be curious to hear about your explorations (either in another thread or offlist)<br></p><p>I have written a couple of experimental versions of an improved Coding system for Swift.  The key idea is to use closures to allow coding of arbitrarily complex nested types (e.g an array of tuples of Dictionaries: [(String, [String:Int])] ).  It works pretty well, but unfortunately currently taxes the compiler to the point where it randomly crashes during compilation.  I am waiting for the new generics stuff to come online before I explore further, since I believe that will dramatically simplify the code.<br></p><p>The other idea which I would like to see replicated is that it codes to an intermediate format which can then be transformed to/from binary data, XML, BSON (JSON + some representation for Binary Data) or some other format...<br></p><p>It also interoperates very well with existing NSCoding classes, which is an important feature.<br></p><p>Thanks,<br>Jon<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160507/4addb028/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>Dropping NS Prefix in Foundation</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>May  7, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 7, 2016, at 6:06 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt; <br>&gt; -1 on this as well.  How much does dropping NS really help things anyway?  <br>&gt; <br>&gt; All it does is force everyone to learn which things still have NS and which don’t.  It also makes things much more difficult to search for… searching for NS_ gives the results you want quickly vs searching for anything in Swift foundation (e.g. Array -- which gives you a mixture of other programming languages and Taylor Swift gossip).<br>&gt; <br>&gt; My proposal would be to keep NS for everything and then slowing making versions without the prefix, either by rewriting them to be better in Swift or simply aliasing the NS version.  Once you have critical mass for useful things (around Swift 5~6), you can separate all the NSStuff out into their own NSFoundation which would be used only for backwards compatibility.<br>&gt; <br>&gt; To the inevitable question: Wont having NS and Non-NS versions be confusing (especially if some are just aliases)?  My answer is that it is less confusing than this proposal. There is a simple rule: Things without NS are always the new and preferred methods. Things with NS are there for compatibility and will continue to work the way they do in ObjectiveC (even if you have to import “NSFoundation” to get them instead of just “Foundation&quot;)<br>&gt; <br></p><p>I think that this approach ends up with confusion as well. Maybe we end up with UserDefaults and NSUserDefaults? One is written in Swift and other is not, but what difference would that make to the caller? Swift itself is not written completely in Swift. Instead, let’s have one UserDefaults that has an API appropriate for Swift. You’ve seen some of that already with changes to the names of its methods (https://github.com/apple/swift/blob/master/apinotes/Foundation.apinotes#L575 as one example, which takes advantage of overloading to simplify the API).<br></p><p>&gt; Side Note: I would also REALLY like to see a swift native improvement on NSAttributedString with native literal support.<br></p><p>NSAttributedString was part of the value types proposal at the beginning but deferred for a few practical reasons. One reason is that I want additional existential support in the language first. AttributedString has the concept of a “longest effective run”, which is calculated by checking for equality between attributes. Attributed string should allow for AnyEquatableAndCopyable members of its attribute dictionary. A second problem is that the entire Cocoa text system (and hundreds of higher level APIs) are based on top of the NSString Index concept, which is hidden behind the unicodeScalar view of Swift.String. I would like a more unified story of how these two can interoperate before we revamp the base type.<br></p><p>Both of these are solvable, but they require time to collaborate between teams to decide what the right platform-wide approach is. We’ll do it, but it will not happen immediately.<br></p><p>&gt; <br>&gt;&gt; There’s no question that we can improve Coding for Swift. I have actually explored this area quite a bit although I don’t have anything planned for Swift 3 at this time.<br>&gt;&gt; <br>&gt;&gt; The general point is though, that we can do it by extending Foundation in that direction over time. In fact, keyed archiving is the perfect example of how we were able to do just that in the past in Objective-C. NSArchiver already existed and served a particular purpose, so we extended the concept into NSKeyedArchiver using the facilities available to us at the time.<br>&gt; I would be curious to hear about your explorations (either in another thread or offlist)<br>&gt; <br>&gt; I have written a couple of experimental versions of an improved Coding system for Swift.  The key idea is to use closures to allow coding of arbitrarily complex nested types (e.g an array of tuples of Dictionaries: [(String, [String:Int])] ).  It works pretty well, but unfortunately currently taxes the compiler to the point where it randomly crashes during compilation.  I am waiting for the new generics stuff to come online before I explore further, since I believe that will dramatically simplify the code.<br>&gt; <br>&gt; The other idea which I would like to see replicated is that it codes to an intermediate format which can then be transformed to/from binary data, XML, BSON (JSON + some representation for Binary Data) or some other format...<br>&gt; <br>&gt; It also interoperates very well with existing NSCoding classes, which is an important feature.<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br></p><p>One thing to think about here is what the role of NSCoding is in the first place. It was designed to support archiving of UI objects to nib files. It has been pressed into service for all kinds of other interesting tasks since; UI state restoration, document formats, and IPC wire protocol, to name a few. It may be worthwhile to decide if these are really all the same use case or not. I’m honestly not sure yet. Some of these are very focused on dynamic behavior (that is, the object graph is not known in advance). For some, custom object types are really important (NSXPC takes full advantage of this, and is basically its reason for existence over the raw libxpc API). For others it is not (a raw document file of one million double values). Some of these have different performance requirements than others (archiving fast is important to IPC but unarchiving fast is important to loading nib files). <br></p><p>- Tony<br></p><p><br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160507/75b49364/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>Dropping NS Prefix in Foundation</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May  8, 2016 at 04:00:00am</p></header><div class="content"><p>I think everyone possibly has different definitions of what ‘Swift-native rethinking’ could involve? My thoughts are, the Swift standard library is a base library of types and algorithms. There’s then a sister library that has serialisation, file reading and writing, and HTTP networking, dates, and more. At the moment that library is Foundation.<br></p><p>I think a good rule for Swift 3 has been, if some feature wasn’t already in, would it be added now if freshly proposed? Is it too far to ask what would a fresh take on Foundation look like?<br></p><p>There are certain things with Foundation that make it feel outdated or possibly less Swift-like:<br>- File references/paths are currently a part of NSURL. While this is 10 times better than the old NSString API, isn’t it still a bit odd, and a bit unfortunate to be bringing forward to Linux? There are a whole set of APIs of NSURL that only apply to files, and other another set that only apply to actual RFC 2396 URLs. Plus you have the NSFileManager APIs and the NSURLSession APIs, one for files and one for web URLs, and they both use the same type.<br>- Why does the library Alamofire have 16,000 stars given that it uses the relatively new API NSURLSession? Would a Swift Foundation aim to get a similar API?<br>- NSTask I think is a reasonable Objective-C API, but nowadays is verbose and throws exceptions: https://www.shinobicontrols.com/blog/scripting-in-swift &lt;https://www.shinobicontrols.com/blog/scripting-in-swift&gt;<br>- NSUserDefaults is designed to write to file storage by a single client as far as I know. i.e. would it be appropriate for a web server?<br>- Foundation is originally designed in a time before closures and before GCD. It’s had some additions to work those features in, but they don’t feel like Foundation has been based upon them.<br>- Having two types, the [NS]OutputStream class, and the OutputStreamable protocol, but they seemingly have nothing to do with each other? Why the designs of one or both change so that NSOutputStream could conform to OutputStreamable?<br>- APIs such as NSOperation that rely on key value coding and observation.<br>- NSOperationQueue, which back in its day added a nice Objective-C API over dispatch queues, but today could probably be achieved by use of protocol extensions and a smaller class that complement GCD?<br>- NSSortDescriptor, designed using key value coding.<br></p><p>Matthew Johnson raised the possibility of a “split between those who favor various libraries”. I take your point that “We are trying to avoid exactly the split you are concerned about.”<br></p><p>I think it is worth listing what Swift-native thinking includes. Here are my ideas based on what I’ve seen from the standard library and the community:<br>- Modular protocol oriented design<br>- Small focused APIs<br>- Elegant use of closures<br>- Explicit rejection of old conventions in order to find the best possible API<br>- Value types of course, which we have coming thanks to the effort here<br>- Ability to design with ‘micro’ value types, where objects would have been cumbersome or inefficient in Objective-C.<br></p><p>I have a feeling that for developers who start by learn Swift conventions and who know have exposure to other libraries and frameworks, that Foundation will feel a bit foreign to them. I feel there will be a split between library choices, as people go for something with more focused APIs that take advantage of Swift more. Is the plan for Foundation to still be a core part of Swift in the next 5+ years?<br></p><p>Foundation is a great API for the tools they had available with Objective-C and thoughtful naming and design. I feel if someone were to design an API given the current tools we have now, it would be very different.<br></p><p>I think modernising Foundation for Swift is a worthy effort, but seemingly making it the defacto sister library to the standard library feels a bit odd.<br></p><p><br>&gt; On 8 May 2016, at 2:53 AM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 7, 2016, at 6:06 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1 on this as well.  How much does dropping NS really help things anyway?  <br>&gt;&gt; <br>&gt;&gt; All it does is force everyone to learn which things still have NS and which don’t.  It also makes things much more difficult to search for… searching for NS_ gives the results you want quickly vs searching for anything in Swift foundation (e.g. Array -- which gives you a mixture of other programming languages and Taylor Swift gossip).<br>&gt;&gt; <br>&gt;&gt; My proposal would be to keep NS for everything and then slowing making versions without the prefix, either by rewriting them to be better in Swift or simply aliasing the NS version.  Once you have critical mass for useful things (around Swift 5~6), you can separate all the NSStuff out into their own NSFoundation which would be used only for backwards compatibility.<br>&gt;&gt; <br>&gt;&gt; To the inevitable question: Wont having NS and Non-NS versions be confusing (especially if some are just aliases)?  My answer is that it is less confusing than this proposal. There is a simple rule: Things without NS are always the new and preferred methods. Things with NS are there for compatibility and will continue to work the way they do in ObjectiveC (even if you have to import “NSFoundation” to get them instead of just “Foundation&quot;)<br>&gt;&gt; <br>&gt; <br>&gt; I think that this approach ends up with confusion as well. Maybe we end up with UserDefaults and NSUserDefaults? One is written in Swift and other is not, but what difference would that make to the caller? Swift itself is not written completely in Swift. Instead, let’s have one UserDefaults that has an API appropriate for Swift. You’ve seen some of that already with changes to the names of its methods (https://github.com/apple/swift/blob/master/apinotes/Foundation.apinotes#L575 &lt;https://github.com/apple/swift/blob/master/apinotes/Foundation.apinotes#L575&gt; as one example, which takes advantage of overloading to simplify the API).<br>&gt; <br>&gt;&gt; Side Note: I would also REALLY like to see a swift native improvement on NSAttributedString with native literal support.<br>&gt; <br>&gt; NSAttributedString was part of the value types proposal at the beginning but deferred for a few practical reasons. One reason is that I want additional existential support in the language first. AttributedString has the concept of a “longest effective run”, which is calculated by checking for equality between attributes. Attributed string should allow for AnyEquatableAndCopyable members of its attribute dictionary. A second problem is that the entire Cocoa text system (and hundreds of higher level APIs) are based on top of the NSString Index concept, which is hidden behind the unicodeScalar view of Swift.String. I would like a more unified story of how these two can interoperate before we revamp the base type.<br>&gt; <br>&gt; Both of these are solvable, but they require time to collaborate between teams to decide what the right platform-wide approach is. We’ll do it, but it will not happen immediately.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; There’s no question that we can improve Coding for Swift. I have actually explored this area quite a bit although I don’t have anything planned for Swift 3 at this time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The general point is though, that we can do it by extending Foundation in that direction over time. In fact, keyed archiving is the perfect example of how we were able to do just that in the past in Objective-C. NSArchiver already existed and served a particular purpose, so we extended the concept into NSKeyedArchiver using the facilities available to us at the time.<br>&gt;&gt; I would be curious to hear about your explorations (either in another thread or offlist)<br>&gt;&gt; <br>&gt;&gt; I have written a couple of experimental versions of an improved Coding system for Swift.  The key idea is to use closures to allow coding of arbitrarily complex nested types (e.g an array of tuples of Dictionaries: [(String, [String:Int])] ).  It works pretty well, but unfortunately currently taxes the compiler to the point where it randomly crashes during compilation.  I am waiting for the new generics stuff to come online before I explore further, since I believe that will dramatically simplify the code.<br>&gt;&gt; <br>&gt;&gt; The other idea which I would like to see replicated is that it codes to an intermediate format which can then be transformed to/from binary data, XML, BSON (JSON + some representation for Binary Data) or some other format...<br>&gt;&gt; <br>&gt;&gt; It also interoperates very well with existing NSCoding classes, which is an important feature.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt; <br>&gt; One thing to think about here is what the role of NSCoding is in the first place. It was designed to support archiving of UI objects to nib files. It has been pressed into service for all kinds of other interesting tasks since; UI state restoration, document formats, and IPC wire protocol, to name a few. It may be worthwhile to decide if these are really all the same use case or not. I’m honestly not sure yet. Some of these are very focused on dynamic behavior (that is, the object graph is not known in advance). For some, custom object types are really important (NSXPC takes full advantage of this, and is basically its reason for existence over the raw libxpc API). For others it is not (a raw document file of one million double values). Some of these have different performance requirements than others (archiving fast is important to IPC but unarchiving fast is important to loading nib files). <br>&gt; <br>&gt; - Tony<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160508/048c64bc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7ba3c93f9350613c243eeb87c602935e?s=50"></div><header><strong>Dropping NS Prefix in Foundation</strong> from <string>David Smith</string> &lt;david_smith at apple.com&gt;<p>May  7, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 7, 2016, at 11:37 AM, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think everyone possibly has different definitions of what ‘Swift-native rethinking’ could involve? My thoughts are, the Swift standard library is a base library of types and algorithms. There’s then a sister library that has serialisation, file reading and writing, and HTTP networking, dates, and more. At the moment that library is Foundation.<br>&gt; <br>&gt; I think a good rule for Swift 3 has been, if some feature wasn’t already in, would it be added now if freshly proposed? Is it too far to ask what would a fresh take on Foundation look like?<br>&gt; <br>&gt; There are certain things with Foundation that make it feel outdated or possibly less Swift-like:<br>&gt; - File references/paths are currently a part of NSURL. While this is 10 times better than the old NSString API, isn’t it still a bit odd, and a bit unfortunate to be bringing forward to Linux? There are a whole set of APIs of NSURL that only apply to files, and other another set that only apply to actual RFC 2396 URLs. Plus you have the NSFileManager APIs and the NSURLSession APIs, one for files and one for web URLs, and they both use the same type.<br>&gt; - Why does the library Alamofire have 16,000 stars given that it uses the relatively new API NSURLSession? Would a Swift Foundation aim to get a similar API?<br>&gt; - NSTask I think is a reasonable Objective-C API, but nowadays is verbose and throws exceptions: https://www.shinobicontrols.com/blog/scripting-in-swift &lt;https://www.shinobicontrols.com/blog/scripting-in-swift&gt;<br>&gt; - NSUserDefaults is designed to write to file storage by a single client as far as I know. i.e. would it be appropriate for a web server?<br></p><p>For what it’s worth, this isn’t true. NSUserDefaults supports concurrent access from arbitrary numbers of clients.<br></p><p>	David<br></p><p>&gt; - Foundation is originally designed in a time before closures and before GCD. It’s had some additions to work those features in, but they don’t feel like Foundation has been based upon them.<br>&gt; - Having two types, the [NS]OutputStream class, and the OutputStreamable protocol, but they seemingly have nothing to do with each other? Why the designs of one or both change so that NSOutputStream could conform to OutputStreamable?<br>&gt; - APIs such as NSOperation that rely on key value coding and observation.<br>&gt; - NSOperationQueue, which back in its day added a nice Objective-C API over dispatch queues, but today could probably be achieved by use of protocol extensions and a smaller class that complement GCD?<br>&gt; - NSSortDescriptor, designed using key value coding.<br>&gt; <br>&gt; Matthew Johnson raised the possibility of a “split between those who favor various libraries”. I take your point that “We are trying to avoid exactly the split you are concerned about.”<br>&gt; <br>&gt; I think it is worth listing what Swift-native thinking includes. Here are my ideas based on what I’ve seen from the standard library and the community:<br>&gt; - Modular protocol oriented design<br>&gt; - Small focused APIs<br>&gt; - Elegant use of closures<br>&gt; - Explicit rejection of old conventions in order to find the best possible API<br>&gt; - Value types of course, which we have coming thanks to the effort here<br>&gt; - Ability to design with ‘micro’ value types, where objects would have been cumbersome or inefficient in Objective-C.<br>&gt; <br>&gt; I have a feeling that for developers who start by learn Swift conventions and who know have exposure to other libraries and frameworks, that Foundation will feel a bit foreign to them. I feel there will be a split between library choices, as people go for something with more focused APIs that take advantage of Swift more. Is the plan for Foundation to still be a core part of Swift in the next 5+ years?<br>&gt; <br>&gt; Foundation is a great API for the tools they had available with Objective-C and thoughtful naming and design. I feel if someone were to design an API given the current tools we have now, it would be very different.<br>&gt; <br>&gt; I think modernising Foundation for Swift is a worthy effort, but seemingly making it the defacto sister library to the standard library feels a bit odd.<br>&gt; <br>&gt; <br>&gt;&gt; On 8 May 2016, at 2:53 AM, Tony Parker via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 7, 2016, at 6:06 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -1 on this as well.  How much does dropping NS really help things anyway?  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; All it does is force everyone to learn which things still have NS and which don’t.  It also makes things much more difficult to search for… searching for NS_ gives the results you want quickly vs searching for anything in Swift foundation (e.g. Array -- which gives you a mixture of other programming languages and Taylor Swift gossip).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My proposal would be to keep NS for everything and then slowing making versions without the prefix, either by rewriting them to be better in Swift or simply aliasing the NS version.  Once you have critical mass for useful things (around Swift 5~6), you can separate all the NSStuff out into their own NSFoundation which would be used only for backwards compatibility.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To the inevitable question: Wont having NS and Non-NS versions be confusing (especially if some are just aliases)?  My answer is that it is less confusing than this proposal. There is a simple rule: Things without NS are always the new and preferred methods. Things with NS are there for compatibility and will continue to work the way they do in ObjectiveC (even if you have to import “NSFoundation” to get them instead of just “Foundation&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I think that this approach ends up with confusion as well. Maybe we end up with UserDefaults and NSUserDefaults? One is written in Swift and other is not, but what difference would that make to the caller? Swift itself is not written completely in Swift. Instead, let’s have one UserDefaults that has an API appropriate for Swift. You’ve seen some of that already with changes to the names of its methods (https://github.com/apple/swift/blob/master/apinotes/Foundation.apinotes#L575 &lt;https://github.com/apple/swift/blob/master/apinotes/Foundation.apinotes#L575&gt; as one example, which takes advantage of overloading to simplify the API).<br>&gt;&gt; <br>&gt;&gt;&gt; Side Note: I would also REALLY like to see a swift native improvement on NSAttributedString with native literal support.<br>&gt;&gt; <br>&gt;&gt; NSAttributedString was part of the value types proposal at the beginning but deferred for a few practical reasons. One reason is that I want additional existential support in the language first. AttributedString has the concept of a “longest effective run”, which is calculated by checking for equality between attributes. Attributed string should allow for AnyEquatableAndCopyable members of its attribute dictionary. A second problem is that the entire Cocoa text system (and hundreds of higher level APIs) are based on top of the NSString Index concept, which is hidden behind the unicodeScalar view of Swift.String. I would like a more unified story of how these two can interoperate before we revamp the base type.<br>&gt;&gt; <br>&gt;&gt; Both of these are solvable, but they require time to collaborate between teams to decide what the right platform-wide approach is. We’ll do it, but it will not happen immediately.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There’s no question that we can improve Coding for Swift. I have actually explored this area quite a bit although I don’t have anything planned for Swift 3 at this time.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The general point is though, that we can do it by extending Foundation in that direction over time. In fact, keyed archiving is the perfect example of how we were able to do just that in the past in Objective-C. NSArchiver already existed and served a particular purpose, so we extended the concept into NSKeyedArchiver using the facilities available to us at the time.<br>&gt;&gt;&gt; I would be curious to hear about your explorations (either in another thread or offlist)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have written a couple of experimental versions of an improved Coding system for Swift.  The key idea is to use closures to allow coding of arbitrarily complex nested types (e.g an array of tuples of Dictionaries: [(String, [String:Int])] ).  It works pretty well, but unfortunately currently taxes the compiler to the point where it randomly crashes during compilation.  I am waiting for the new generics stuff to come online before I explore further, since I believe that will dramatically simplify the code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The other idea which I would like to see replicated is that it codes to an intermediate format which can then be transformed to/from binary data, XML, BSON (JSON + some representation for Binary Data) or some other format...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It also interoperates very well with existing NSCoding classes, which is an important feature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt; One thing to think about here is what the role of NSCoding is in the first place. It was designed to support archiving of UI objects to nib files. It has been pressed into service for all kinds of other interesting tasks since; UI state restoration, document formats, and IPC wire protocol, to name a few. It may be worthwhile to decide if these are really all the same use case or not. I’m honestly not sure yet. Some of these are very focused on dynamic behavior (that is, the object graph is not known in advance). For some, custom object types are really important (NSXPC takes full advantage of this, and is basically its reason for existence over the raw libxpc API). For others it is not (a raw document file of one million double values). Some of these have different performance requirements than others (archiving fast is important to IPC but unarchiving fast is important to loading nib files). <br>&gt;&gt; <br>&gt;&gt; - Tony<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160507/94c57f99/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>Dropping NS Prefix in Foundation</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>May  7, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 7, 2016, at 9:53 AM, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 7, 2016, at 6:06 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1 on this as well.  How much does dropping NS really help things anyway?  <br>&gt;&gt; <br>&gt;&gt; All it does is force everyone to learn which things still have NS and which don’t.  It also makes things much more difficult to search for… searching for NS_ gives the results you want quickly vs searching for anything in Swift foundation (e.g. Array -- which gives you a mixture of other programming languages and Taylor Swift gossip).<br>&gt;&gt; <br>&gt;&gt; My proposal would be to keep NS for everything and then slowing making versions without the prefix, either by rewriting them to be better in Swift or simply aliasing the NS version.  Once you have critical mass for useful things (around Swift 5~6), you can separate all the NSStuff out into their own NSFoundation which would be used only for backwards compatibility.<br>&gt;&gt; <br>&gt;&gt; To the inevitable question: Wont having NS and Non-NS versions be confusing (especially if some are just aliases)?  My answer is that it is less confusing than this proposal. There is a simple rule: Things without NS are always the new and preferred methods. Things with NS are there for compatibility and will continue to work the way they do in ObjectiveC (even if you have to import “NSFoundation” to get them instead of just “Foundation&quot;)<br>&gt;&gt; <br>&gt; <br>&gt; I think that this approach ends up with confusion as well. Maybe we end up with UserDefaults and NSUserDefaults? One is written in Swift and other is not, but what difference would that make to the caller? Swift itself is not written completely in Swift. Instead, let’s have one UserDefaults that has an API appropriate for Swift. You’ve seen some of that already with changes to the names of its methods (https://github.com/apple/swift/blob/master/apinotes/Foundation.apinotes#L575 &lt;https://github.com/apple/swift/blob/master/apinotes/Foundation.apinotes#L575&gt; as one example, which takes advantage of overloading to simplify the API).<br></p><p>I think my main point here is that just because we are making breaking changes in Swift 3, it doesn’t mean we have to do everything as a breaking change.  I feel like we are being hasty in trying to bring everything over so quickly without thought, when it could be done gradually over 3-4 years… making large improvements as we pull things over.  If we do this now, we will be locking ourselves into a base design that will always be between two worlds, and thus not really ideal for either world. Lowest common denominator.  We won’t be able to do things like Swift’s String or Array.<br></p><p>In cases like UserDefaults where it makes sense to pull over the design without much modification, you can have a single design and just alias it to “UserDefaults”<br></p><p>There will be confusion with any system, but this at least has a simple clarifying rule. If there is both a NS and Non-NS version, the non-NS version is the new/shiny/preferred one.<br></p><p><br>What happens if we just bring something like NSURL over and call it URL, but then decide we need a completely different conceptual model (or we want to make it a value type instead of a reference type)?  All of the non-breaking fixes I can think of are way more confusing than having separate NSURL and Url types (which mirror the differences of NSArray and Array).<br></p><p><br>&gt;&gt; Side Note: I would also REALLY like to see a swift native improvement on NSAttributedString with native literal support.<br>&gt; <br>&gt; NSAttributedString was part of the value types proposal at the beginning but deferred for a few practical reasons. One reason is that I want additional existential support in the language first. AttributedString has the concept of a “longest effective run”, which is calculated by checking for equality between attributes. Attributed string should allow for AnyEquatableAndCopyable members of its attribute dictionary. A second problem is that the entire Cocoa text system (and hundreds of higher level APIs) are based on top of the NSString Index concept, which is hidden behind the unicodeScalar view of Swift.String. I would like a more unified story of how these two can interoperate before we revamp the base type.<br>&gt; <br>&gt; Both of these are solvable, but they require time to collaborate between teams to decide what the right platform-wide approach is. We’ll do it, but it will not happen immediately.<br></p><p>Makes sense.<br></p><p>I think what I would like to see is a new model which makes editing &amp; creation much less of a pain, but which can be bridged to NSAttributedString so we don’t have to propagate changes (e.g. the indexing model) throughout the system all at once.<br></p><p>My main opposition to bringing everything over right now is that it makes changes like that much more difficult in the future.<br>&gt;&gt;&gt; There’s no question that we can improve Coding for Swift. I have actually explored this area quite a bit although I don’t have anything planned for Swift 3 at this time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The general point is though, that we can do it by extending Foundation in that direction over time. In fact, keyed archiving is the perfect example of how we were able to do just that in the past in Objective-C. NSArchiver already existed and served a particular purpose, so we extended the concept into NSKeyedArchiver using the facilities available to us at the time.<br>&gt;&gt; I would be curious to hear about your explorations (either in another thread or offlist)<br>&gt;&gt; <br>&gt;&gt; I have written a couple of experimental versions of an improved Coding system for Swift.  The key idea is to use closures to allow coding of arbitrarily complex nested types (e.g an array of tuples of Dictionaries: [(String, [String:Int])] ).  It works pretty well, but unfortunately currently taxes the compiler to the point where it randomly crashes during compilation.  I am waiting for the new generics stuff to come online before I explore further, since I believe that will dramatically simplify the code.<br>&gt;&gt; <br>&gt;&gt; The other idea which I would like to see replicated is that it codes to an intermediate format which can then be transformed to/from binary data, XML, BSON (JSON + some representation for Binary Data) or some other format...<br>&gt;&gt; <br>&gt;&gt; It also interoperates very well with existing NSCoding classes, which is an important feature.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt; <br>&gt; One thing to think about here is what the role of NSCoding is in the first place. It was designed to support archiving of UI objects to nib files. It has been pressed into service for all kinds of other interesting tasks since; UI state restoration, document formats, and IPC wire protocol, to name a few. It may be worthwhile to decide if these are really all the same use case or not. I’m honestly not sure yet. Some of these are very focused on dynamic behavior (that is, the object graph is not known in advance). For some, custom object types are really important (NSXPC takes full advantage of this, and is basically its reason for existence over the raw libxpc API). For others it is not (a raw document file of one million double values). Some of these have different performance requirements than others (archiving fast is important to IPC but unarchiving fast is important to loading nib files). <br></p><p>Makes sense.  I haven’t really worried to much about efficiency in my experiments (I am just trying to get it to work at all), but I can see where that will be important for the official version.<br></p><p>I wonder if protocols help us here?  They might allow us to swap out implementations and have something optimized for the situation (e.g. your file of one million double values).<br></p><p>It definitely warrants significant thought and design.  It sounds like a Swift 4 thing, though I continually hope for Swift 3, as it is the main issue (i.e. How do I save information stored in value types?) stalling real-world projects which I have in the pipeline. If improved generics make their way into Swift 3, it should be enough, as we can make custom frameworks (which don’t crash the compiler) to do the job until the official version is ready...<br></p><p>Thanks,<br>Jon<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160507/ff352bf6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
