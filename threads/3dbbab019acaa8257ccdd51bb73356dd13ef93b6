<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c65faa002b79348ac10e1fb9c1a9ad83?s=50"></div><header><strong>access control proposal</strong> from <string>Colin Cornaby</string> &lt;colin.cornaby at mac.com&gt;<p>December 14, 2015 at 09:00:00pm</p></header><div class="content"><p>I don&#39;t think this analogy follows. Books have division lines of pages or chapters that compartmentalize information. In the same way, development projects traditionally have a separation of concerns that are organized using different source code files. I don&#39;t know if a &quot;gazillion&quot; accurately captures the number of files required to separate concerns. On the other hand, I&#39;m also not sure if Swift should try to enforce good development practices as policy (but I like the practice it&#39;s trying to support here.)<br></p><p>I&#39;m just watching this from the sidelines, but I haven&#39;t seen a compelling example case anywhere in the discussion that would lead to just an unmaintanable number of files. Even for multiple teams all working on the same source... separation of files seems like the cleanest solution.<br></p><p>As others have mentioned, iOS and Mac development (as well as open source Swift) seems to be going in the direction of a single application or project containing multiple modules. Mac has been doing that with great success for a long time. Given that&#39;s the direction things are going, private as it exists now even seems a little heavy for a lot of uses. It&#39;s completely realistic the projects are going to start separating concerns over module boundaries and not just source file boundaries. This proposal just seems to be going the opposite way that Swift and Apple platform development is going.<br></p><p>Files are easy to understand, and they&#39;re lightweight, and I just haven&#39;t been convinced that files with small amount of source are even a bad thing, nor have I seen Swift projects out in the wild that have too many short Swift source files that is a result of language restrictions. Do you have any examples of projects out in the community?<br></p><p>On Dec 14, 2015, at 11:42 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br></p><p>Please take a look at the other posts today. I addressed this concern earlier. In one sentence, just like you wouldn&#39;t want to put every paragraph of a book or every section of an article in an encyclopedia in a separate file, you wouldn&#39;t want to end up with a gazillion files just to ensure that implementation details of an API stay hidden in a way that is enforced by the compiler.<br></p><p>--<br>Ilya Belenkiy<br></p><p>On Mon, Dec 14, 2015 at 2:19 PM Colin Cornaby via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>(I&#39;m reading the upstream discussion but I&#39;ll reply here.)<br></p><p>I don&#39;t know if I really like the pattern this is trying to support. I like that Swift makes it cleaner to include multiple types in a single Swift file. But I feel like this proposal is trying to take things too far the other way. Types that should should only see each other from a non &quot;friends&quot; role should be in separate files.<br></p><p>What&#39;s proposed doesn&#39;t really harm someone who likes the &quot;multiple file&quot; style directly, but I don&#39;t want to see projects where everything gets jammed into one file. I think keeping the scope of private (with no new keywords) to the same file encourages good coding practices.<br></p><p>I&#39;ve really liked the balance Swift strikes in this case. I feel like this discussion is going to come down to opinion, but projects that I&#39;ve worked in that have tried to over compact have always run into issues. I don&#39;t know if it&#39;s the role of the language to push an ideology either way, but personally I like the direction Swift is pushing. Files make for good scope boundaries.<br></p><p>On Dec 05, 2015, at 08:40 PM, Ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>I think the it would help a great deal to have an access level modifier that is really private and visible only inside the class itself. Right now, the only way to hide implementation details for a class is to hide the class code in a separate file, which is very inconvenient for several reasons:<br></p><p>1) the meaning of the code changes depending on which file the class is in. It&#39;s very easy to accidentally expose class internal details and then call class elements that are meant to be used only inside the class. Having a keyword for class internals will allow the compiler to ensure that only the public API for the class is used from the outside world. The user can check types on his own, but it&#39;s better that the compiler does it automatically. Similarly, the user can check that only the proper APIs are called, but it&#39;s better that the compiler does it automatically.<br></p><p>2) accessibility by file structure may cause some really short files. <br></p><p>3) It&#39;s impossible to group related classes in one file but still hide implementation details inside each class<br></p><p>I think that it the best solution is to make private keyword do what it states -- keep the class element private to the class. But if it&#39;s really important to have a separate keyword for backward compatibility, it would be the next best thing.<br></p><p>--<br>Ilya Belenkiy<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/3dbb93b6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>December 15, 2015 at 12:00:00pm</p></header><div class="content"><p>This is a matter of opinion. I think that the proposal is very much in line<br>with Swift&#39;s emphasis on strong types and protocols and adds clarity about<br>where an API can be used.<br></p><p>--<br>Ilya Belenkiy<br></p><p>On Mon, Dec 14, 2015 at 4:11 PM Colin Cornaby &lt;colin.cornaby at mac.com&gt; wrote:<br></p><p>&gt; I don&#39;t think this analogy follows. Books have division lines of pages or<br>&gt; chapters that compartmentalize information. In the same way, development<br>&gt; projects traditionally have a separation of concerns that are organized<br>&gt; using different source code files. I don&#39;t know if a &quot;gazillion&quot; accurately<br>&gt; captures the number of files required to separate concerns. On the other<br>&gt; hand, I&#39;m also not sure if Swift should try to enforce good development<br>&gt; practices as policy (but I like the practice it&#39;s trying to support here.)<br>&gt;<br>&gt; I&#39;m just watching this from the sidelines, but I haven&#39;t seen a compelling<br>&gt; example case anywhere in the discussion that would lead to just an<br>&gt; unmaintanable number of files. Even for multiple teams all working on the<br>&gt; same source... separation of files seems like the cleanest solution.<br>&gt;<br>&gt; As others have mentioned, iOS and Mac development (as well as open source<br>&gt; Swift) seems to be going in the direction of a single application or<br>&gt; project containing multiple modules. Mac has been doing that with great<br>&gt; success for a long time. Given that&#39;s the direction things are going,<br>&gt; private as it exists now even seems a little heavy for a lot of uses. It&#39;s<br>&gt; completely realistic the projects are going to start separating concerns<br>&gt; over module boundaries and not just source file boundaries. This proposal<br>&gt; just seems to be going the opposite way that Swift and Apple platform<br>&gt; development is going.<br>&gt;<br>&gt; Files are easy to understand, and they&#39;re lightweight, and I just haven&#39;t<br>&gt; been convinced that files with small amount of source are even a bad thing,<br>&gt; nor have I seen Swift projects out in the wild that have too many short<br>&gt; Swift source files that is a result of language restrictions. Do you have<br>&gt; any examples of projects out in the community?<br>&gt;<br>&gt; On Dec 14, 2015, at 11:42 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Please take a look at the other posts today. I addressed this concern<br>&gt; earlier. In one sentence, just like you wouldn&#39;t want to put every<br>&gt; paragraph of a book or every section of an article in an encyclopedia in a<br>&gt; separate file, you wouldn&#39;t want to end up with a gazillion files just to<br>&gt; ensure that implementation details of an API stay hidden in a way that is<br>&gt; enforced by the compiler.<br>&gt;<br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt;<br>&gt; On Mon, Dec 14, 2015 at 2:19 PM Colin Cornaby via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; (I&#39;m reading the upstream discussion but I&#39;ll reply here.)<br>&gt;&gt;<br>&gt;&gt; I don&#39;t know if I really like the pattern this is trying to support. I<br>&gt;&gt; like that Swift makes it cleaner to include multiple types in a single<br>&gt;&gt; Swift file. But I feel like this proposal is trying to take things too far<br>&gt;&gt; the other way. Types that should should only see each other from a non<br>&gt;&gt; &quot;friends&quot; role should be in separate files.<br>&gt;&gt;<br>&gt;&gt; What&#39;s proposed doesn&#39;t really harm someone who likes the &quot;multiple file&quot;<br>&gt;&gt; style directly, but I don&#39;t want to see projects where everything gets<br>&gt;&gt; jammed into one file. I think keeping the scope of private (with no new<br>&gt;&gt; keywords) to the same file encourages good coding practices.<br>&gt;&gt;<br>&gt;&gt; I&#39;ve really liked the balance Swift strikes in this case. I feel like<br>&gt;&gt; this discussion is going to come down to opinion, but projects that I&#39;ve<br>&gt;&gt; worked in that have tried to over compact have always run into issues. I<br>&gt;&gt; don&#39;t know if it&#39;s the role of the language to push an ideology either way,<br>&gt;&gt; but personally I like the direction Swift is pushing. Files make for good<br>&gt;&gt; scope boundaries.<br>&gt;&gt;<br>&gt;&gt; On Dec 05, 2015, at 08:40 PM, Ilya via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I think the it would help a great deal to have an access level modifier<br>&gt;&gt; that is really private and visible only inside the class itself. Right now,<br>&gt;&gt; the only way to hide implementation details for a class is to hide the<br>&gt;&gt; class code in a separate file, which is very inconvenient for several<br>&gt;&gt; reasons:<br>&gt;&gt;<br>&gt;&gt; 1) the meaning of the code changes depending on which file the class is<br>&gt;&gt; in. It&#39;s very easy to accidentally expose class internal details and then<br>&gt;&gt; call class elements that are meant to be used only inside the class. Having<br>&gt;&gt; a keyword for class internals will allow the compiler to ensure that only<br>&gt;&gt; the public API for the class is used from the outside world. The user can<br>&gt;&gt; check types on his own, but it&#39;s better that the compiler does it<br>&gt;&gt; automatically. Similarly, the user can check that only the proper APIs are<br>&gt;&gt; called, but it&#39;s better that the compiler does it automatically.<br>&gt;&gt;<br>&gt;&gt; 2) accessibility by file structure may cause some really short files.<br>&gt;&gt;<br>&gt;&gt; 3) It&#39;s impossible to group related classes in one file but still hide<br>&gt;&gt; implementation details inside each class<br>&gt;&gt;<br>&gt;&gt; I think that it the best solution is to make private keyword do what it<br>&gt;&gt; states -- keep the class element private to the class. But if it&#39;s really<br>&gt;&gt; important to have a separate keyword for backward compatibility, it would<br>&gt;&gt; be the next best thing.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Ilya Belenkiy<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/cd8bf9d1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c65faa002b79348ac10e1fb9c1a9ad83?s=50"></div><header><strong>access control proposal</strong> from <string>Colin Cornaby</string> &lt;colin.cornaby at mac.com&gt;<p>December 15, 2015 at 08:00:00am</p></header><div class="content"><p>I guess where I get skeptical is the example case. In this example, a module that should otherwise be simple but is made complicated by having too many source files in Swift is really a module that should be simple, but has been made complicated by too many custom types. If we’re talking about a simple module that has been overcomplicated by too many types (Swift scoping aside), we’re talking about a module that likely has significant architectural problems. That’s why I asked if there were any examples. I was wondering if there were any cases where a project’s design was otherwise sound, but maintainability was compromised by a lack of fine grain scoping in Swift. What’s been talked about so far seems to really be Swift source that is suffering from design issues or overbuilding, and instead of fixing those design issues that’s leading to a large number of source files, we’re talking about paving over those design issues with new language constraints.<br></p><p>I don’t know where the Swift team falls in having Swift as a language that supports questionable development practices. But to me, I’m still just not convinced the work to change this would be justified by any real gain in good development practices.<br></p><p>&gt; On Dec 15, 2015, at 4:10 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br>&gt; <br>&gt; This is a matter of opinion. I think that the proposal is very much in line with Swift&#39;s emphasis on strong types and protocols and adds clarity about where an API can be used.<br>&gt; <br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt; <br>&gt; On Mon, Dec 14, 2015 at 4:11 PM Colin Cornaby &lt;colin.cornaby at mac.com &lt;mailto:colin.cornaby at mac.com&gt;&gt; wrote:<br>&gt; I don&#39;t think this analogy follows. Books have division lines of pages or chapters that compartmentalize information. In the same way, development projects traditionally have a separation of concerns that are organized using different source code files. I don&#39;t know if a &quot;gazillion&quot; accurately captures the number of files required to separate concerns. On the other hand, I&#39;m also not sure if Swift should try to enforce good development practices as policy (but I like the practice it&#39;s trying to support here.)<br>&gt; <br>&gt; I&#39;m just watching this from the sidelines, but I haven&#39;t seen a compelling example case anywhere in the discussion that would lead to just an unmaintanable number of files. Even for multiple teams all working on the same source... separation of files seems like the cleanest solution.<br>&gt; <br>&gt; As others have mentioned, iOS and Mac development (as well as open source Swift) seems to be going in the direction of a single application or project containing multiple modules. Mac has been doing that with great success for a long time. Given that&#39;s the direction things are going, private as it exists now even seems a little heavy for a lot of uses. It&#39;s completely realistic the projects are going to start separating concerns over module boundaries and not just source file boundaries. This proposal just seems to be going the opposite way that Swift and Apple platform development is going.<br>&gt; <br>&gt; Files are easy to understand, and they&#39;re lightweight, and I just haven&#39;t been convinced that files with small amount of source are even a bad thing, nor have I seen Swift projects out in the wild that have too many short Swift source files that is a result of language restrictions. Do you have any examples of projects out in the community?<br>&gt; <br>&gt; On Dec 14, 2015, at 11:42 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com &lt;mailto:ilya.belenkiy at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Please take a look at the other posts today. I addressed this concern earlier. In one sentence, just like you wouldn&#39;t want to put every paragraph of a book or every section of an article in an encyclopedia in a separate file, you wouldn&#39;t want to end up with a gazillion files just to ensure that implementation details of an API stay hidden in a way that is enforced by the compiler.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Ilya Belenkiy<br>&gt;&gt; <br>&gt; <br>&gt;&gt; On Mon, Dec 14, 2015 at 2:19 PM Colin Cornaby via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; (I&#39;m reading the upstream discussion but I&#39;ll reply here.)<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know if I really like the pattern this is trying to support. I like that Swift makes it cleaner to include multiple types in a single Swift file. But I feel like this proposal is trying to take things too far the other way. Types that should should only see each other from a non &quot;friends&quot; role should be in separate files.<br>&gt;&gt; <br>&gt;&gt; What&#39;s proposed doesn&#39;t really harm someone who likes the &quot;multiple file&quot; style directly, but I don&#39;t want to see projects where everything gets jammed into one file. I think keeping the scope of private (with no new keywords) to the same file encourages good coding practices.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve really liked the balance Swift strikes in this case. I feel like this discussion is going to come down to opinion, but projects that I&#39;ve worked in that have tried to over compact have always run into issues. I don&#39;t know if it&#39;s the role of the language to push an ideology either way, but personally I like the direction Swift is pushing. Files make for good scope boundaries.<br>&gt;&gt; <br>&gt;&gt; On Dec 05, 2015, at 08:40 PM, Ilya via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I think the it would help a great deal to have an access level modifier that is really private and visible only inside the class itself. Right now, the only way to hide implementation details for a class is to hide the class code in a separate file, which is very inconvenient for several reasons:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) the meaning of the code changes depending on which file the class is in. It&#39;s very easy to accidentally expose class internal details and then call class elements that are meant to be used only inside the class. Having a keyword for class internals will allow the compiler to ensure that only the public API for the class is used from the outside world. The user can check types on his own, but it&#39;s better that the compiler does it automatically. Similarly, the user can check that only the proper APIs are called, but it&#39;s better that the compiler does it automatically.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2) accessibility by file structure may cause some really short files. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3) It&#39;s impossible to group related classes in one file but still hide implementation details inside each class<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think that it the best solution is to make private keyword do what it states -- keep the class element private to the class. But if it&#39;s really important to have a separate keyword for backward compatibility, it would be the next best thing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Ilya Belenkiy<br>&gt; <br>&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/121d5962/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control proposal</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 15, 2015 at 10:00:00am</p></header><div class="content"><p>So the takeaway from this, which I think is a good point, is that any proposal needs to have some concrete motivating examples that are otherwise well designed and where a reasonable argument can be made that they benefit from this.  This is something all proposals should have.  Not everyone will agree about the degree of benefit and how it relates to the feature, but a concrete example will provide focus for that discussion.<br></p><p>Matthew<br></p><p>&gt; On Dec 15, 2015, at 10:35 AM, Colin Cornaby via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I guess where I get skeptical is the example case. In this example, a module that should otherwise be simple but is made complicated by having too many source files in Swift is really a module that should be simple, but has been made complicated by too many custom types. If we’re talking about a simple module that has been overcomplicated by too many types (Swift scoping aside), we’re talking about a module that likely has significant architectural problems. That’s why I asked if there were any examples. I was wondering if there were any cases where a project’s design was otherwise sound, but maintainability was compromised by a lack of fine grain scoping in Swift. What’s been talked about so far seems to really be Swift source that is suffering from design issues or overbuilding, and instead of fixing those design issues that’s leading to a large number of source files, we’re talking about paving over those design issues with new language constraints.<br>&gt; <br>&gt; I don’t know where the Swift team falls in having Swift as a language that supports questionable development practices. But to me, I’m still just not convinced the work to change this would be justified by any real gain in good development practices.<br>&gt; <br>&gt;&gt; On Dec 15, 2015, at 4:10 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com &lt;mailto:ilya.belenkiy at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is a matter of opinion. I think that the proposal is very much in line with Swift&#39;s emphasis on strong types and protocols and adds clarity about where an API can be used.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Ilya Belenkiy<br>&gt;&gt; <br>&gt;&gt; On Mon, Dec 14, 2015 at 4:11 PM Colin Cornaby &lt;colin.cornaby at mac.com &lt;mailto:colin.cornaby at mac.com&gt;&gt; wrote:<br>&gt;&gt; I don&#39;t think this analogy follows. Books have division lines of pages or chapters that compartmentalize information. In the same way, development projects traditionally have a separation of concerns that are organized using different source code files. I don&#39;t know if a &quot;gazillion&quot; accurately captures the number of files required to separate concerns. On the other hand, I&#39;m also not sure if Swift should try to enforce good development practices as policy (but I like the practice it&#39;s trying to support here.)<br>&gt;&gt; <br>&gt;&gt; I&#39;m just watching this from the sidelines, but I haven&#39;t seen a compelling example case anywhere in the discussion that would lead to just an unmaintanable number of files. Even for multiple teams all working on the same source... separation of files seems like the cleanest solution.<br>&gt;&gt; <br>&gt;&gt; As others have mentioned, iOS and Mac development (as well as open source Swift) seems to be going in the direction of a single application or project containing multiple modules. Mac has been doing that with great success for a long time. Given that&#39;s the direction things are going, private as it exists now even seems a little heavy for a lot of uses. It&#39;s completely realistic the projects are going to start separating concerns over module boundaries and not just source file boundaries. This proposal just seems to be going the opposite way that Swift and Apple platform development is going.<br>&gt;&gt; <br>&gt;&gt; Files are easy to understand, and they&#39;re lightweight, and I just haven&#39;t been convinced that files with small amount of source are even a bad thing, nor have I seen Swift projects out in the wild that have too many short Swift source files that is a result of language restrictions. Do you have any examples of projects out in the community?<br>&gt;&gt; <br>&gt;&gt; On Dec 14, 2015, at 11:42 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com &lt;mailto:ilya.belenkiy at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Please take a look at the other posts today. I addressed this concern earlier. In one sentence, just like you wouldn&#39;t want to put every paragraph of a book or every section of an article in an encyclopedia in a separate file, you wouldn&#39;t want to end up with a gazillion files just to ensure that implementation details of an API stay hidden in a way that is enforced by the compiler.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mon, Dec 14, 2015 at 2:19 PM Colin Cornaby via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; (I&#39;m reading the upstream discussion but I&#39;ll reply here.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t know if I really like the pattern this is trying to support. I like that Swift makes it cleaner to include multiple types in a single Swift file. But I feel like this proposal is trying to take things too far the other way. Types that should should only see each other from a non &quot;friends&quot; role should be in separate files.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What&#39;s proposed doesn&#39;t really harm someone who likes the &quot;multiple file&quot; style directly, but I don&#39;t want to see projects where everything gets jammed into one file. I think keeping the scope of private (with no new keywords) to the same file encourages good coding practices.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve really liked the balance Swift strikes in this case. I feel like this discussion is going to come down to opinion, but projects that I&#39;ve worked in that have tried to over compact have always run into issues. I don&#39;t know if it&#39;s the role of the language to push an ideology either way, but personally I like the direction Swift is pushing. Files make for good scope boundaries.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 05, 2015, at 08:40 PM, Ilya via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think the it would help a great deal to have an access level modifier that is really private and visible only inside the class itself. Right now, the only way to hide implementation details for a class is to hide the class code in a separate file, which is very inconvenient for several reasons:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) the meaning of the code changes depending on which file the class is in. It&#39;s very easy to accidentally expose class internal details and then call class elements that are meant to be used only inside the class. Having a keyword for class internals will allow the compiler to ensure that only the public API for the class is used from the outside world. The user can check types on his own, but it&#39;s better that the compiler does it automatically. Similarly, the user can check that only the proper APIs are called, but it&#39;s better that the compiler does it automatically.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2) accessibility by file structure may cause some really short files. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3) It&#39;s impossible to group related classes in one file but still hide implementation details inside each class<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think that it the best solution is to make private keyword do what it states -- keep the class element private to the class. But if it&#39;s really important to have a separate keyword for backward compatibility, it would be the next best thing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/1c4e051b/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>December 15, 2015 at 05:00:00pm</p></header><div class="content"><p>I think that I already gave simple and reasonable examples. If this was a<br>complicated issue, I would agree that a coded example would be useful. But<br>in this case, it looks like anything small will be called contrived, and<br>anything big will be called poorly designed.<br></p><p>I think that I already presented my case. I hope that the discussion is<br>enough to submit a formal proposal. If not, I&#39;ll stop here.<br></p><p>--<br>Ilya Belenkiy<br></p><p>On Tue, Dec 15, 2015 at 11:41 AM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt; So the takeaway from this, which I think is a good point, is that any<br>&gt; proposal needs to have some concrete motivating examples that are otherwise<br>&gt; well designed and where a reasonable argument can be made that they benefit<br>&gt; from this.  This is something all proposals should have.  Not everyone will<br>&gt; agree about the degree of benefit and how it relates to the feature, but a<br>&gt; concrete example will provide focus for that discussion.<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt;<br>&gt; On Dec 15, 2015, at 10:35 AM, Colin Cornaby via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I guess where I get skeptical is the example case. In this example, a<br>&gt; module that should otherwise be simple but is made complicated by having<br>&gt; too many source files in Swift is really a module that should be simple,<br>&gt; but has been made complicated by too many custom types. If we’re talking<br>&gt; about a simple module that has been overcomplicated by too many types<br>&gt; (Swift scoping aside), we’re talking about a module that likely has<br>&gt; significant architectural problems. That’s why I asked if there were any<br>&gt; examples. I was wondering if there were any cases where a project’s design<br>&gt; was otherwise sound, but maintainability was compromised by a lack of fine<br>&gt; grain scoping in Swift. What’s been talked about so far seems to really be<br>&gt; Swift source that is suffering from design issues or overbuilding, and<br>&gt; instead of fixing those design issues that’s leading to a large number of<br>&gt; source files, we’re talking about paving over those design issues with new<br>&gt; language constraints.<br>&gt;<br>&gt; I don’t know where the Swift team falls in having Swift as a language that<br>&gt; supports questionable development practices. But to me, I’m still just not<br>&gt; convinced the work to change this would be justified by any real gain in<br>&gt; good development practices.<br>&gt;<br>&gt; On Dec 15, 2015, at 4:10 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; This is a matter of opinion. I think that the proposal is very much in<br>&gt; line with Swift&#39;s emphasis on strong types and protocols and adds clarity<br>&gt; about where an API can be used.<br>&gt;<br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt;<br>&gt; On Mon, Dec 14, 2015 at 4:11 PM Colin Cornaby &lt;colin.cornaby at mac.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; I don&#39;t think this analogy follows. Books have division lines of pages or<br>&gt;&gt; chapters that compartmentalize information. In the same way, development<br>&gt;&gt; projects traditionally have a separation of concerns that are organized<br>&gt;&gt; using different source code files. I don&#39;t know if a &quot;gazillion&quot; accurately<br>&gt;&gt; captures the number of files required to separate concerns. On the other<br>&gt;&gt; hand, I&#39;m also not sure if Swift should try to enforce good development<br>&gt;&gt; practices as policy (but I like the practice it&#39;s trying to support here.)<br>&gt;&gt;<br>&gt;&gt; I&#39;m just watching this from the sidelines, but I haven&#39;t seen a<br>&gt;&gt; compelling example case anywhere in the discussion that would lead to just<br>&gt;&gt; an unmaintanable number of files. Even for multiple teams all working on<br>&gt;&gt; the same source... separation of files seems like the cleanest solution.<br>&gt;&gt;<br>&gt;&gt; As others have mentioned, iOS and Mac development (as well as open source<br>&gt;&gt; Swift) seems to be going in the direction of a single application or<br>&gt;&gt; project containing multiple modules. Mac has been doing that with great<br>&gt;&gt; success for a long time. Given that&#39;s the direction things are going,<br>&gt;&gt; private as it exists now even seems a little heavy for a lot of uses. It&#39;s<br>&gt;&gt; completely realistic the projects are going to start separating concerns<br>&gt;&gt; over module boundaries and not just source file boundaries. This proposal<br>&gt;&gt; just seems to be going the opposite way that Swift and Apple platform<br>&gt;&gt; development is going.<br>&gt;&gt;<br>&gt;&gt; Files are easy to understand, and they&#39;re lightweight, and I just haven&#39;t<br>&gt;&gt; been convinced that files with small amount of source are even a bad thing,<br>&gt;&gt; nor have I seen Swift projects out in the wild that have too many short<br>&gt;&gt; Swift source files that is a result of language restrictions. Do you have<br>&gt;&gt; any examples of projects out in the community?<br>&gt;&gt;<br>&gt;&gt; On Dec 14, 2015, at 11:42 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Please take a look at the other posts today. I addressed this concern<br>&gt;&gt; earlier. In one sentence, just like you wouldn&#39;t want to put every<br>&gt;&gt; paragraph of a book or every section of an article in an encyclopedia in a<br>&gt;&gt; separate file, you wouldn&#39;t want to end up with a gazillion files just to<br>&gt;&gt; ensure that implementation details of an API stay hidden in a way that is<br>&gt;&gt; enforced by the compiler.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Ilya Belenkiy<br>&gt;&gt;<br>&gt;&gt; On Mon, Dec 14, 2015 at 2:19 PM Colin Cornaby via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; (I&#39;m reading the upstream discussion but I&#39;ll reply here.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don&#39;t know if I really like the pattern this is trying to support. I<br>&gt;&gt;&gt; like that Swift makes it cleaner to include multiple types in a single<br>&gt;&gt;&gt; Swift file. But I feel like this proposal is trying to take things too far<br>&gt;&gt;&gt; the other way. Types that should should only see each other from a non<br>&gt;&gt;&gt; &quot;friends&quot; role should be in separate files.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What&#39;s proposed doesn&#39;t really harm someone who likes the &quot;multiple<br>&gt;&gt;&gt; file&quot; style directly, but I don&#39;t want to see projects where everything<br>&gt;&gt;&gt; gets jammed into one file. I think keeping the scope of private (with no<br>&gt;&gt;&gt; new keywords) to the same file encourages good coding practices.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;ve really liked the balance Swift strikes in this case. I feel like<br>&gt;&gt;&gt; this discussion is going to come down to opinion, but projects that I&#39;ve<br>&gt;&gt;&gt; worked in that have tried to over compact have always run into issues. I<br>&gt;&gt;&gt; don&#39;t know if it&#39;s the role of the language to push an ideology either way,<br>&gt;&gt;&gt; but personally I like the direction Swift is pushing. Files make for good<br>&gt;&gt;&gt; scope boundaries.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 05, 2015, at 08:40 PM, Ilya via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think the it would help a great deal to have an access level modifier<br>&gt;&gt;&gt; that is really private and visible only inside the class itself. Right now,<br>&gt;&gt;&gt; the only way to hide implementation details for a class is to hide the<br>&gt;&gt;&gt; class code in a separate file, which is very inconvenient for several<br>&gt;&gt;&gt; reasons:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1) the meaning of the code changes depending on which file the class is<br>&gt;&gt;&gt; in. It&#39;s very easy to accidentally expose class internal details and then<br>&gt;&gt;&gt; call class elements that are meant to be used only inside the class. Having<br>&gt;&gt;&gt; a keyword for class internals will allow the compiler to ensure that only<br>&gt;&gt;&gt; the public API for the class is used from the outside world. The user can<br>&gt;&gt;&gt; check types on his own, but it&#39;s better that the compiler does it<br>&gt;&gt;&gt; automatically. Similarly, the user can check that only the proper APIs are<br>&gt;&gt;&gt; called, but it&#39;s better that the compiler does it automatically.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2) accessibility by file structure may cause some really short files.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 3) It&#39;s impossible to group related classes in one file but still hide<br>&gt;&gt;&gt; implementation details inside each class<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think that it the best solution is to make private keyword do what it<br>&gt;&gt;&gt; states -- keep the class element private to the class. But if it&#39;s really<br>&gt;&gt;&gt; important to have a separate keyword for backward compatibility, it would<br>&gt;&gt;&gt; be the next best thing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/a48bd76f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>access control proposal</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 15, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 9:17 AM, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think that I already gave simple and reasonable examples. If this was a complicated issue, I would agree that a coded example would be useful. But in this case, it looks like anything small will be called contrived, and anything big will be called poorly designed.<br>&gt; <br>&gt; I think that I already presented my case. I hope that the discussion is enough to submit a formal proposal. If not, I&#39;ll stop here.<br></p><p>There’s no reason to not submit a proposal for it with examples and references to the criticism in this thread and your counter for it. If nothing else, it would consolidate this thread as there have been multiple variations proposed throughout and solidify exactly what the proposal is all about.<br></p><p>My person vote is to not support further grain access controls. It&#39;s not because your examples were not reasonable, but because I come from a perspective where I don’t think the language complexity warrants it and the use case is very narrowly focused. Others have been in favor of it though.<br></p><p>So go for it.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/5fbd6635/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>December 15, 2015 at 04:00:00pm</p></header><div class="content"><p>There are a lot of unreasonable assumptions here. That&#39;s all I have to say<br>in response.<br></p><p>--<br>Ilya Belenkiy<br></p><p>On Tue, Dec 15, 2015 at 11:35 AM Colin Cornaby &lt;colin.cornaby at mac.com&gt;<br>wrote:<br></p><p>&gt; I guess where I get skeptical is the example case. In this example, a<br>&gt; module that should otherwise be simple but is made complicated by having<br>&gt; too many source files in Swift is really a module that should be simple,<br>&gt; but has been made complicated by too many custom types. If we’re talking<br>&gt; about a simple module that has been overcomplicated by too many types<br>&gt; (Swift scoping aside), we’re talking about a module that likely has<br>&gt; significant architectural problems. That’s why I asked if there were any<br>&gt; examples. I was wondering if there were any cases where a project’s design<br>&gt; was otherwise sound, but maintainability was compromised by a lack of fine<br>&gt; grain scoping in Swift. What’s been talked about so far seems to really be<br>&gt; Swift source that is suffering from design issues or overbuilding, and<br>&gt; instead of fixing those design issues that’s leading to a large number of<br>&gt; source files, we’re talking about paving over those design issues with new<br>&gt; language constraints.<br>&gt;<br>&gt; I don’t know where the Swift team falls in having Swift as a language that<br>&gt; supports questionable development practices. But to me, I’m still just not<br>&gt; convinced the work to change this would be justified by any real gain in<br>&gt; good development practices.<br>&gt;<br>&gt; On Dec 15, 2015, at 4:10 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; This is a matter of opinion. I think that the proposal is very much in<br>&gt; line with Swift&#39;s emphasis on strong types and protocols and adds clarity<br>&gt; about where an API can be used.<br>&gt;<br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt;<br>&gt; On Mon, Dec 14, 2015 at 4:11 PM Colin Cornaby &lt;colin.cornaby at mac.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; I don&#39;t think this analogy follows. Books have division lines of pages or<br>&gt;&gt; chapters that compartmentalize information. In the same way, development<br>&gt;&gt; projects traditionally have a separation of concerns that are organized<br>&gt;&gt; using different source code files. I don&#39;t know if a &quot;gazillion&quot; accurately<br>&gt;&gt; captures the number of files required to separate concerns. On the other<br>&gt;&gt; hand, I&#39;m also not sure if Swift should try to enforce good development<br>&gt;&gt; practices as policy (but I like the practice it&#39;s trying to support here.)<br>&gt;&gt;<br>&gt;&gt; I&#39;m just watching this from the sidelines, but I haven&#39;t seen a<br>&gt;&gt; compelling example case anywhere in the discussion that would lead to just<br>&gt;&gt; an unmaintanable number of files. Even for multiple teams all working on<br>&gt;&gt; the same source... separation of files seems like the cleanest solution.<br>&gt;&gt;<br>&gt;&gt; As others have mentioned, iOS and Mac development (as well as open source<br>&gt;&gt; Swift) seems to be going in the direction of a single application or<br>&gt;&gt; project containing multiple modules. Mac has been doing that with great<br>&gt;&gt; success for a long time. Given that&#39;s the direction things are going,<br>&gt;&gt; private as it exists now even seems a little heavy for a lot of uses. It&#39;s<br>&gt;&gt; completely realistic the projects are going to start separating concerns<br>&gt;&gt; over module boundaries and not just source file boundaries. This proposal<br>&gt;&gt; just seems to be going the opposite way that Swift and Apple platform<br>&gt;&gt; development is going.<br>&gt;&gt;<br>&gt;&gt; Files are easy to understand, and they&#39;re lightweight, and I just haven&#39;t<br>&gt;&gt; been convinced that files with small amount of source are even a bad thing,<br>&gt;&gt; nor have I seen Swift projects out in the wild that have too many short<br>&gt;&gt; Swift source files that is a result of language restrictions. Do you have<br>&gt;&gt; any examples of projects out in the community?<br>&gt;&gt;<br>&gt;&gt; On Dec 14, 2015, at 11:42 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Please take a look at the other posts today. I addressed this concern<br>&gt;&gt; earlier. In one sentence, just like you wouldn&#39;t want to put every<br>&gt;&gt; paragraph of a book or every section of an article in an encyclopedia in a<br>&gt;&gt; separate file, you wouldn&#39;t want to end up with a gazillion files just to<br>&gt;&gt; ensure that implementation details of an API stay hidden in a way that is<br>&gt;&gt; enforced by the compiler.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Ilya Belenkiy<br>&gt;&gt;<br>&gt;&gt; On Mon, Dec 14, 2015 at 2:19 PM Colin Cornaby via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; (I&#39;m reading the upstream discussion but I&#39;ll reply here.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don&#39;t know if I really like the pattern this is trying to support. I<br>&gt;&gt;&gt; like that Swift makes it cleaner to include multiple types in a single<br>&gt;&gt;&gt; Swift file. But I feel like this proposal is trying to take things too far<br>&gt;&gt;&gt; the other way. Types that should should only see each other from a non<br>&gt;&gt;&gt; &quot;friends&quot; role should be in separate files.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What&#39;s proposed doesn&#39;t really harm someone who likes the &quot;multiple<br>&gt;&gt;&gt; file&quot; style directly, but I don&#39;t want to see projects where everything<br>&gt;&gt;&gt; gets jammed into one file. I think keeping the scope of private (with no<br>&gt;&gt;&gt; new keywords) to the same file encourages good coding practices.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;ve really liked the balance Swift strikes in this case. I feel like<br>&gt;&gt;&gt; this discussion is going to come down to opinion, but projects that I&#39;ve<br>&gt;&gt;&gt; worked in that have tried to over compact have always run into issues. I<br>&gt;&gt;&gt; don&#39;t know if it&#39;s the role of the language to push an ideology either way,<br>&gt;&gt;&gt; but personally I like the direction Swift is pushing. Files make for good<br>&gt;&gt;&gt; scope boundaries.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 05, 2015, at 08:40 PM, Ilya via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think the it would help a great deal to have an access level modifier<br>&gt;&gt;&gt; that is really private and visible only inside the class itself. Right now,<br>&gt;&gt;&gt; the only way to hide implementation details for a class is to hide the<br>&gt;&gt;&gt; class code in a separate file, which is very inconvenient for several<br>&gt;&gt;&gt; reasons:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1) the meaning of the code changes depending on which file the class is<br>&gt;&gt;&gt; in. It&#39;s very easy to accidentally expose class internal details and then<br>&gt;&gt;&gt; call class elements that are meant to be used only inside the class. Having<br>&gt;&gt;&gt; a keyword for class internals will allow the compiler to ensure that only<br>&gt;&gt;&gt; the public API for the class is used from the outside world. The user can<br>&gt;&gt;&gt; check types on his own, but it&#39;s better that the compiler does it<br>&gt;&gt;&gt; automatically. Similarly, the user can check that only the proper APIs are<br>&gt;&gt;&gt; called, but it&#39;s better that the compiler does it automatically.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2) accessibility by file structure may cause some really short files.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 3) It&#39;s impossible to group related classes in one file but still hide<br>&gt;&gt;&gt; implementation details inside each class<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think that it the best solution is to make private keyword do what it<br>&gt;&gt;&gt; states -- keep the class element private to the class. But if it&#39;s really<br>&gt;&gt;&gt; important to have a separate keyword for backward compatibility, it would<br>&gt;&gt;&gt; be the next best thing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/88c3ea36/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
