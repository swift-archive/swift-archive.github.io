<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>SE-0005: Ambiguous NS prefix removals</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  4, 2015 at 03:00:00am</p></header><div class="content"><p>SE-0005 in the repository (?Better Translation of Objective-C APIs into Swift?, https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md) discusses plans to remove the NS prefix from many Foundation APIs, but admits that you haven?t yet settled on a way to handle conflicts with the standard library:<br></p><p>&gt; The removal of the &quot;NS&quot; prefix for the Foundation module (or other specifically identified modules) is a mechanical translation for all global symbols defined within that module that can be performed in the Clang importer. Note that this removal can create conflicts with the standard library. For example, NSString and NSArray will become String and Array, respectively, and Foundation&#39;s versions will shadow the standard library&#39;s versions. We are investigating several ways to address this problem, including:<br>&gt; <br>&gt; 	? Retain the NS prefix on such classes.<br>&gt; <br>&gt; 	? Introduce some notion of submodules into Swift, so that these classes would exist in a submodule for reference-semantic types (e.g., one would refer to Foundation.ReferenceTypes.Array or similar).<br></p><p>Since the main difference between e.g. String and NSString is that the latter has reference semantics, why not alter the name to reflect that?<br></p><p>	NSString -&gt; StringRef<br>	NSArray -&gt; ArrayRef<br>	NSDictionary -&gt; DictionaryRef<br></p><p>The resulting type names have a bit of a Core Foundation-y flavor to them, but that?s not necessarily a bad thing?it quietly encourages use of the Swift types just as NSString vs. CFStringRef quietly encourages use of the Foundation type.<br></p><p>Normally this transformation would not apply to types with no corresponding standard library type:<br></p><p>	NSCalendar -&gt; Calendar<br>	NSBundle -&gt; Bundle<br></p><p>However, subclasses of a type with ?Ref? in the name would also have ?Ref&quot; in the subclass name:<br></p><p>	NSMutableString -&gt; MutableStringRef (because its superclass is StringRef)<br>	NSMutableArray -&gt; MutableArrayRef (because its superclass is ArrayRef)<br>	NSMutableDictionary -&gt; MutableDictionaryRef (because its superclass is DictionaryRef)<br></p><p>If you don?t like ?Ref?, ?Object? is wordier but clearer:<br></p><p>	StringObject, MutableStringObject<br>	ArrayObject, MutableArrayObject<br>	DictionaryObject, MutableDictionaryObject<br></p><p>And as long as we?re doing this, it might make sense to add the ?Ref? suffix for a few other types which might naturally have value-typed standard library equivalents someday, even if they don?t right now:<br></p><p>	URLRef (the URL type would have something like NSURLComponents?s mutation APIs)<br>	DateComponentsRef (this is begging to be a struct in Swift)<br>	DateRef (perhaps less important, since it?s immutable and doesn?t really have many natural properties to expose anyway)<br>	NumberRef (a standard library equivalent might be a protocol that all numeric types conform to)<br></p><p>On the other hand, you might just want to cross that bridge when you get to it with a source code migrator in Swift 4 or whatever.<br></p><p>(By the way, I love the rest of this proposal. I?ve always wanted Swift to clean up and reformat API names more when it imports them.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>SE-0005: Ambiguous NS prefix removals</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>December  4, 2015 at 11:00:00am</p></header><div class="content"><p>Hi Brent,<br></p><p>&gt; On Dec 4, 2015, at 3:50 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt; SE-0005 in the repository (?Better Translation of Objective-C APIs into Swift?, https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md) discusses plans to remove the NS prefix from many Foundation APIs, but admits that you haven?t yet settled on a way to handle conflicts with the standard library:<br>&gt; <br>&gt;&gt; The removal of the &quot;NS&quot; prefix for the Foundation module (or other specifically identified modules) is a mechanical translation for all global symbols defined within that module that can be performed in the Clang importer. Note that this removal can create conflicts with the standard library. For example, NSString and NSArray will become String and Array, respectively, and Foundation&#39;s versions will shadow the standard library&#39;s versions. We are investigating several ways to address this problem, including:<br>&gt;&gt; <br>&gt;&gt; 	? Retain the NS prefix on such classes.<br>&gt;&gt; <br>&gt;&gt; 	? Introduce some notion of submodules into Swift, so that these classes would exist in a submodule for reference-semantic types (e.g., one would refer to Foundation.ReferenceTypes.Array or similar).<br>&gt; <br>&gt; Since the main difference between e.g. String and NSString is that the latter has reference semantics, why not alter the name to reflect that?<br>&gt; <br>&gt; 	NSString -&gt; StringRef<br>&gt; 	NSArray -&gt; ArrayRef<br>&gt; 	NSDictionary -&gt; DictionaryRef<br>&gt; <br>&gt; The resulting type names have a bit of a Core Foundation-y flavor to them, but that?s not necessarily a bad thing?it quietly encourages use of the Swift types just as NSString vs. CFStringRef quietly encourages use of the Foundation type.<br>&gt; <br>&gt; Normally this transformation would not apply to types with no corresponding standard library type:<br>&gt; <br>&gt; 	NSCalendar -&gt; Calendar<br>&gt; 	NSBundle -&gt; Bundle<br>&gt; <br>&gt; However, subclasses of a type with ?Ref? in the name would also have ?Ref&quot; in the subclass name:<br>&gt; <br>&gt; 	NSMutableString -&gt; MutableStringRef (because its superclass is StringRef)<br>&gt; 	NSMutableArray -&gt; MutableArrayRef (because its superclass is ArrayRef)<br>&gt; 	NSMutableDictionary -&gt; MutableDictionaryRef (because its superclass is DictionaryRef)<br>&gt; <br>&gt; If you don?t like ?Ref?, ?Object? is wordier but clearer:<br>&gt; <br>&gt; 	StringObject, MutableStringObject<br>&gt; 	ArrayObject, MutableArrayObject<br>&gt; 	DictionaryObject, MutableDictionaryObject<br>&gt; <br>&gt; And as long as we?re doing this, it might make sense to add the ?Ref? suffix for a few other types which might naturally have value-typed standard library equivalents someday, even if they don?t right now:<br>&gt; <br>&gt; 	URLRef (the URL type would have something like NSURLComponents?s mutation APIs)<br>&gt; 	DateComponentsRef (this is begging to be a struct in Swift)<br>&gt; 	DateRef (perhaps less important, since it?s immutable and doesn?t really have many natural properties to expose anyway)<br>&gt; 	NumberRef (a standard library equivalent might be a protocol that all numeric types conform to)<br>&gt; <br>&gt; On the other hand, you might just want to cross that bridge when you get to it with a source code migrator in Swift 4 or whatever.<br>&gt; <br></p><p>We?ve been thinking about exactly what to call this submodule, but haven?t landed on a preferred name yet. For the class names themselves, I don?t think we want to suffix some classes with ?Ref? or ?Object? but not others, because it would lead to either boilerplate names or inconsistency. The idea of the submodule was to avoid the inconsistency but still have something which obviously separates these classes.<br></p><p>e.g.<br></p><p>NSString -&gt; submodule.String<br>NSBundle -&gt; Bundle<br>NSMutableString -&gt; submodule.MutableString<br>NSArray -&gt; submodule.Array<br></p><p>etc.<br></p><p>- Tony<br></p><p>&gt; (By the way, I love the rest of this proposal. I?ve always wanted Swift to clean up and reformat API names more when it imports them.)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>SE-0005: Ambiguous NS prefix removals</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  4, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; We?ve been thinking about exactly what to call this submodule, but haven?t landed on a preferred name yet. For the class names themselves, I don?t think we want to suffix some classes with ?Ref? or ?Object? but not others, because it would lead to either boilerplate names or inconsistency. The idea of the submodule was to avoid the inconsistency but still have something which obviously separates these classes.<br></p><p>But I?m not sure using a submodule really solves either of these problems.<br></p><p>BOILERPLATE: How are you going to address types inside the module? Either you?ll have to always include the prefix?in which case the prefix is boilerplate, but it?s in the wrong place on the type name to read correctly (?reference array? instead of ?array reference?) and requires an extra character due to the ?.??or there will be some way to make Swift favor the reference types over the value types, in which case you won?t even be able to read ?Array? or ?String? in a piece of code without wondering which semantics you?re talking about.<br></p><p>INCONSISTENCY: Not every type in Foundation will be moved into this submodule; some will stay behind in the top-level Foundation module. Doesn?t that mean the submodule approach is inconsistent too?<br></p><p>So is putting these types into a submodule actually fixing these problems, or is it just sticking a dot after them?<br></p><p>Actually, as long as we?re here, here?s a weird idea I just came up with. Why not nest the reference types inside the types they bridge to?<br></p><p>	NSString -&gt; String.Reference<br>	NSMutableString -&gt; String.MutableReference<br>	NSArray&lt;T&gt; -&gt; Array&lt;T&gt;.Reference<br>	NSMutableArray&lt;T&gt; -&gt; Array&lt;T&gt;.MutableReference<br></p><p>This would require you to get a handle on nesting types within generic types, but personally, that?s always been a pain point for me in Swift?s design. With the right type resolution rules, it might also allow you to say something like this and let Swift figure out what you mean:<br></p><p>	let foo = ?foo bar baz? as .Reference	// implicitly means String.Reference<br></p><p>And if this was driven by a protocol with a typealias for the reference type, you could even make this public so users who have their own matching value/reference types can have them autoboxed:<br></p><p>	// Think of this as a cleaned up version of _ObjectiveCBridgeable.<br>	public protocol Referable {<br>		typealias Reference: class<br>		static func referenceType() -&gt; Reference.Type			// or make it possible to get this from the protocol witness<br>		<br>		var reference: Reference { get }<br>		init?(reference: Reference)							// for an as! conversion, this is force-unwrapped by the caller<br>	}<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6e4479b6097e171f8f46de71f35764ba?s=50"></div><header><strong>SE-0005: Ambiguous NS prefix removals</strong> from <string>Nikolai Vazquez</string> &lt;nvazquez1297 at gmail.com&gt;<p>December  4, 2015 at 08:00:00pm</p></header><div class="content"><p>Hey Brent,<br></p><p>I really like the idea you proposed with having a Reference nested type. I<br>prefer a name like Object but that&#39;s just me.<br></p><p>&gt;From my experience, nested types don&#39;t conflict with typealiases for<br>protocol conformance so you could do something similar to:<br></p><p>extension Array: Referable {<br>    class Reference&lt;Element&gt; { ... }<br>    var reference: Reference&lt;Element&gt; { ... }<br>}<br></p><p>I do agree with Tony however that types like NSBundle that have no Swift<br>counterpart could be renamed to simply Bundle.<br></p><p>One thing I&#39;m wondering about is abuse of the Referable protocol. It could<br>lead to developers feeling the need to conform to it when it comes to<br>creating new value types. However, it shouldn&#39;t be an issue.<br></p><p>On Fri, Dec 4, 2015, 3:09 PM Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; We’ve been thinking about exactly what to call this submodule, but<br>&gt; haven’t landed on a preferred name yet. For the class names themselves, I<br>&gt; don’t think we want to suffix some classes with ‘Ref’ or ‘Object’ but not<br>&gt; others, because it would lead to either boilerplate names or inconsistency.<br>&gt; The idea of the submodule was to avoid the inconsistency but still have<br>&gt; something which obviously separates these classes.<br>&gt;<br>&gt; But I’m not sure using a submodule really solves either of these problems.<br>&gt;<br>&gt; BOILERPLATE: How are you going to address types inside the module? Either<br>&gt; you’ll have to always include the prefix—in which case the prefix is<br>&gt; boilerplate, but it’s in the wrong place on the type name to read correctly<br>&gt; (“reference array” instead of “array reference”) and requires an extra<br>&gt; character due to the “.”—or there will be some way to make Swift favor the<br>&gt; reference types over the value types, in which case you won’t even be able<br>&gt; to read “Array” or “String” in a piece of code without wondering which<br>&gt; semantics you’re talking about.<br>&gt;<br>&gt; INCONSISTENCY: Not every type in Foundation will be moved into this<br>&gt; submodule; some will stay behind in the top-level Foundation module.<br>&gt; Doesn’t that mean the submodule approach is inconsistent too?<br>&gt;<br>&gt; So is putting these types into a submodule actually fixing these problems,<br>&gt; or is it just sticking a dot after them?<br>&gt;<br>&gt; Actually, as long as we’re here, here’s a weird idea I just came up with.<br>&gt; Why not nest the reference types inside the types they bridge to?<br>&gt;<br>&gt;         NSString -&gt; String.Reference<br>&gt;         NSMutableString -&gt; String.MutableReference<br>&gt;         NSArray&lt;T&gt; -&gt; Array&lt;T&gt;.Reference<br>&gt;         NSMutableArray&lt;T&gt; -&gt; Array&lt;T&gt;.MutableReference<br>&gt;<br>&gt; This would require you to get a handle on nesting types within generic<br>&gt; types, but personally, that’s always been a pain point for me in Swift’s<br>&gt; design. With the right type resolution rules, it might also allow you to<br>&gt; say something like this and let Swift figure out what you mean:<br>&gt;<br>&gt;         let foo = “foo bar baz” as .Reference   // implicitly means<br>&gt; String.Reference<br>&gt;<br>&gt; And if this was driven by a protocol with a typealias for the reference<br>&gt; type, you could even make this public so users who have their own matching<br>&gt; value/reference types can have them autoboxed:<br>&gt;<br>&gt;         // Think of this as a cleaned up version of _ObjectiveCBridgeable.<br>&gt;         public protocol Referable {<br>&gt;                 typealias Reference: class<br>&gt;                 static func referenceType() -&gt; Reference.Type<br>&gt;      // or make it possible to get this from the protocol witness<br>&gt;<br>&gt;                 var reference: Reference { get }<br>&gt;                 init?(reference: Reference)<br>&gt;                      // for an as! conversion, this is force-unwrapped by<br>&gt; the caller<br>&gt;         }<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/ed6eacb2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>SE-0005: Ambiguous NS prefix removals</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>December  4, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 12:09 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; We’ve been thinking about exactly what to call this submodule, but haven’t landed on a preferred name yet. For the class names themselves, I don’t think we want to suffix some classes with ‘Ref’ or ‘Object’ but not others, because it would lead to either boilerplate names or inconsistency. The idea of the submodule was to avoid the inconsistency but still have something which obviously separates these classes.<br>&gt; <br>&gt; But I’m not sure using a submodule really solves either of these problems.<br>&gt; <br>&gt; BOILERPLATE: How are you going to address types inside the module? Either you’ll have to always include the prefix—in which case the prefix is boilerplate, but it’s in the wrong place on the type name to read correctly (“reference array” instead of “array reference”) and requires an extra character due to the “.”—or there will be some way to make Swift favor the reference types over the value types, in which case you won’t even be able to read “Array” or “String” in a piece of code without wondering which semantics you’re talking about.<br>&gt; <br></p><p>You’re right that there is going to be some boilerplate here. Inside the Foundation module we’re willing to accept the readability hit of using submodule.Array when we mean “NSArray.” Using NSArray outside of Foundation itself should be relatively rare compared to using the standard library Array, so it should not be very prevalent there.<br></p><p>The idea we’ve been thinking about is to add something (in the module map, or in the class interface itself) here which makes the submodule specification required. We don’t have that capability today, so we need a compiler change of some kind to make this work if it is the direction we go. That means that Array always means Array.<br></p><p>&gt; INCONSISTENCY: Not every type in Foundation will be moved into this submodule; some will stay behind in the top-level Foundation module. Doesn’t that mean the submodule approach is inconsistent too?<br>&gt; <br></p><p>It would just be for types which have a value type equivalent in Swift that we would rather be used in most situations. This is why NSString Obj-C API is imported into Swift API as String, for example.<br></p><p>&gt; So is putting these types into a submodule actually fixing these problems, or is it just sticking a dot after them?<br>&gt; <br>&gt; Actually, as long as we’re here, here’s a weird idea I just came up with. Why not nest the reference types inside the types they bridge to?<br>&gt; <br>&gt; 	NSString -&gt; String.Reference<br>&gt; 	NSMutableString -&gt; String.MutableReference<br>&gt; 	NSArray&lt;T&gt; -&gt; Array&lt;T&gt;.Reference<br>&gt; 	NSMutableArray&lt;T&gt; -&gt; Array&lt;T&gt;.MutableReference<br>&gt; <br>&gt; This would require you to get a handle on nesting types within generic types, but personally, that’s always been a pain point for me in Swift’s design. With the right type resolution rules, it might also allow you to say something like this and let Swift figure out what you mean:<br>&gt; <br>&gt; 	let foo = “foo bar baz” as .Reference	// implicitly means String.Reference<br>&gt; <br>&gt; And if this was driven by a protocol with a typealias for the reference type, you could even make this public so users who have their own matching value/reference types can have them autoboxed:<br>&gt; <br>&gt; 	// Think of this as a cleaned up version of _ObjectiveCBridgeable.<br>&gt; 	public protocol Referable {<br>&gt; 		typealias Reference: class<br>&gt; 		static func referenceType() -&gt; Reference.Type			// or make it possible to get this from the protocol witness<br>&gt; 		<br>&gt; 		var reference: Reference { get }<br>&gt; 		init?(reference: Reference)							// for an as! conversion, this is force-unwrapped by the caller<br>&gt; 	}<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>This is an interesting idea; although I think it goes beyond what we had in mind for just the renaming. Even without the casting idea you propose, the names are not too different from calling the submodule ‘Reference’, which is something we considered:<br></p><p>NSString -&gt; Reference.String<br>NSMutableString -&gt; Reference.MutableString<br>NSArray -&gt; Reference.Array<br></p><p>etc. The problem with this in my mind is that ‘Reference’ is not a good enough word to describe the difference between Foundation.NSString and Swift.String.<br></p><p>- Tony<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47e3aeeaf151d4f51ee15fc7871bf584?s=50"></div><header><strong>SE-0005: Ambiguous NS prefix removals</strong> from <string>Rudolf Adamkovič</string> &lt;salutis at me.com&gt;<p>December  4, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; The problem with this in my mind is that ‘Reference’ is not a good enough word to describe the difference between Foundation.NSString and Swift.String.<br>&gt; <br>&gt; - Tony<br></p><p>What about Legacy instead of Reference?<br></p><p>P.S. Hopefully, UI and other prefixes will be removed &quot;soonish&quot; too.<br></p><p>R+<br></p><p>Sent from my iPhone<br></p><p>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
