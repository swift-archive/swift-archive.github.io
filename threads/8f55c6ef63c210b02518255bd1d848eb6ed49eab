<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Allow static protocol extension methods to be called directly on the protocol</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 28, 2016 at 01:00:00am</p></header><div class="content"><p>Rasmus Kjeldsen via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I propose to allow static protocol extension methods to be used directly on the protocol.<br>&gt; This would enable the Factory-pattern to be elegantly implemented as in the example below:<br>&gt; <br>&gt; protocol P {}<br>&gt; <br>&gt; class A : P {}<br>&gt; class B : P {}<br>&gt; <br>&gt; extension P {<br>&gt; 	static func factory(type: Bool) -&gt; P { return type ? A() : B()}<br>&gt; }<br>&gt; <br>&gt; let a = P.factory(false) // &lt;- Not possible in Swift 2, factory() can<br>&gt; only be used on either A or B<br>&gt; <br>&gt; Regards<br>&gt; <br>&gt; Rasmus Friis Kjeldsen<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br></p><p>&#39;extension P&#39; extends all types that conform to P. We could introduce a new<br>syntax for extending the protocol type, maybe:<br></p><p>extension protocol&lt;P&gt; { ... }<br></p><p>This might be an important part of fleshing out our support for protocol<br>existential types. It would offer a way for protocol types to conform to<br>their own protocols even when Self or associated types make that normally<br>impossible. <br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fc538d0a1ad5c1dad7eeb33b55b582c5?s=50"></div><header><strong>[Proposal] Allow static protocol extension methods to be called directly on the protocol</strong> from <string>Rasmus Kjeldsen</string> &lt;rasmus.kjeldsen at gmail.com&gt;<p>March  1, 2016 at 08:00:00am</p></header><div class="content"><p>Maybe the “extension protocol &lt;P&gt;” syntax is more confusing than to just let protocol types implicitly conform to the static methods of their own protocol?<br>Below is an example of what I mean:<br></p><p>protocol P {}<br></p><p>extension P {<br>	static func a() {}<br>}<br></p><p>extension protocol &lt;P&gt; {<br>	static func b() {}<br>}<br></p><p>class C : P { }<br></p><p>C.a() // ok<br>C.b() // ok or not allowed?<br>P.a() // not allowed<br>P.b() // ok<br></p><p>And if C.b() is not allowed, what about if we also do:<br></p><p>extension P {<br>	static func b() {}<br>}<br>C.b() // ok?<br></p><p>Should that be allowed?<br></p><p>Regards<br>Rasmus<br></p><p>&gt; On 28 Feb 2016, at 02:05, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Rasmus Kjeldsen via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I propose to allow static protocol extension methods to be used directly on the protocol.<br>&gt;&gt; This would enable the Factory-pattern to be elegantly implemented as in the example below:<br>&gt;&gt; <br>&gt;&gt; protocol P {}<br>&gt;&gt; <br>&gt;&gt; class A : P {}<br>&gt;&gt; class B : P {}<br>&gt;&gt; <br>&gt;&gt; extension P {<br>&gt;&gt; 	static func factory(type: Bool) -&gt; P { return type ? A() : B()}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let a = P.factory(false) // &lt;- Not possible in Swift 2, factory() can<br>&gt;&gt; only be used on either A or B<br>&gt;&gt; <br>&gt;&gt; Regards<br>&gt;&gt; <br>&gt;&gt; Rasmus Friis Kjeldsen<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; &#39;extension P&#39; extends all types that conform to P. We could introduce a new<br>&gt; syntax for extending the protocol type, maybe:<br>&gt; <br>&gt; extension protocol&lt;P&gt; { ... }<br>&gt; <br>&gt; This might be an important part of fleshing out our support for protocol<br>&gt; existential types. It would offer a way for protocol types to conform to<br>&gt; their own protocols even when Self or associated types make that normally<br>&gt; impossible. <br>&gt; <br>&gt; -Joe <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/c7809277/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Allow static protocol extension methods to be called directly on the protocol</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  1, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Feb 29, 2016, at 11:28 PM, Rasmus Kjeldsen &lt;rasmus.kjeldsen at gmail.com&gt; wrote:<br>&gt; <br>&gt; Maybe the “extension protocol &lt;P&gt;” syntax is more confusing than to just let protocol types implicitly conform to the static methods of their own protocol?<br></p><p>Not every protocol type is a natural model of the protocol it represents. When a protocol has `static` or `init` requirements, for instance, the protocol type can&#39;t conform to its own protocol, since it&#39;s an abstract type with no type-level implementations of its own. Contravariant `Self` and associated type constraints are also problematic. Furthermore, in our resilience model, public protocols are allowed to add new requirements in future versions that cause a formerly self-conforming protocol to no longer conform. For these reasons, we really need the ability to explicitly declare that a protocol type is intended to be usable as a model of its own protocol.<br></p><p>&gt; <br>&gt; protocol P {}<br>&gt; <br>&gt; extension P {<br>&gt; 	static func a() {}<br>&gt; }<br>&gt; <br>&gt; extension protocol &lt;P&gt; {<br>&gt; 	static func b() {}<br>&gt; }<br>&gt; <br>&gt; class C : P { }<br>&gt; <br>&gt; C.a() // ok<br></p><p>Yeah.<br></p><p>&gt; C.b() // ok or not allowed?<br></p><p>Good question. The type object `C.self: C.Type` is a subtype of `P.Type`, so one could argue that this should be allowed by implicit up-conversion.<br></p><p>&gt; P.a() // not allowed<br></p><p>Yeah.<br></p><p>&gt; P.b() // ok<br></p><p>Yeah.<br></p><p>&gt; <br>&gt; And if C.b() is not allowed, what about if we also do:<br>&gt; <br>&gt; extension P {<br>&gt; 	static func b() {}<br>&gt; }<br>&gt; C.b() // ok?<br>&gt; <br>&gt; Should that be allowed?<br></p><p>Yeah, in that case `extension P` is extending all types that conform to P.<br></p><p>-Joe<br></p><p>&gt; <br>&gt; Regards<br>&gt; Rasmus<br>&gt; <br>&gt;&gt; On 28 Feb 2016, at 02:05, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Rasmus Kjeldsen via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose to allow static protocol extension methods to be used directly on the protocol.<br>&gt;&gt;&gt; This would enable the Factory-pattern to be elegantly implemented as in the example below:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class A : P {}<br>&gt;&gt;&gt; class B : P {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension P {<br>&gt;&gt;&gt; 	static func factory(type: Bool) -&gt; P { return type ? A() : B()}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a = P.factory(false) // &lt;- Not possible in Swift 2, factory() can<br>&gt;&gt;&gt; only be used on either A or B<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Regards<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Rasmus Friis Kjeldsen<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &#39;extension P&#39; extends all types that conform to P. We could introduce a new<br>&gt;&gt; syntax for extending the protocol type, maybe:<br>&gt;&gt; <br>&gt;&gt; extension protocol&lt;P&gt; { ... }<br>&gt;&gt; <br>&gt;&gt; This might be an important part of fleshing out our support for protocol<br>&gt;&gt; existential types. It would offer a way for protocol types to conform to<br>&gt;&gt; their own protocols even when Self or associated types make that normally<br>&gt;&gt; impossible. <br>&gt;&gt; <br>&gt;&gt; -Joe <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/0e01ed25/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Proposal] Allow static protocol extension methods to be called directly on the protocol</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>March 23, 2016 at 03:00:00pm</p></header><div class="content"><p>Wouldn&#39;t it be easier (syntax wise) to extend the meta type directly? :<br></p><p>protocol P {}<br>extension P.Type {<br>        static func a() {}<br>}<br></p><p>Kind regards<br>- Maximilian<br></p><p>&gt; Am 28.02.2016 um 02:05 schrieb Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Rasmus Kjeldsen via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I propose to allow static protocol extension methods to be used directly on the protocol.<br>&gt;&gt; This would enable the Factory-pattern to be elegantly implemented as in the example below:<br>&gt;&gt; <br>&gt;&gt; protocol P {}<br>&gt;&gt; <br>&gt;&gt; class A : P {}<br>&gt;&gt; class B : P {}<br>&gt;&gt; <br>&gt;&gt; extension P {<br>&gt;&gt;    static func factory(type: Bool) -&gt; P { return type ? A() : B()}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let a = P.factory(false) // &lt;- Not possible in Swift 2, factory() can<br>&gt;&gt; only be used on either A or B<br>&gt;&gt; <br>&gt;&gt; Regards<br>&gt;&gt; <br>&gt;&gt; Rasmus Friis Kjeldsen<br>&gt; <br>&gt; &#39;extension P&#39; extends all types that conform to P. We could introduce a new<br>&gt; syntax for extending the protocol type, maybe:<br>&gt; <br>&gt; extension protocol&lt;P&gt; { ... }<br>&gt; <br>&gt; This might be an important part of fleshing out our support for protocol<br>&gt; existential types. It would offer a way for protocol types to conform to<br>&gt; their own protocols even when Self or associated types make that normally<br>&gt; impossible. <br>&gt; <br>&gt; -Joe <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Allow static protocol extension methods to be called directly on the protocol</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 23, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Mar 23, 2016, at 7:13 AM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt; <br>&gt; Wouldn&#39;t it be easier (syntax wise) to extend the meta type directly? :<br>&gt; <br>&gt; protocol P {}<br>&gt; extension P.Type {<br>&gt;       static func a() {}<br>&gt; }<br></p><p>Maybe we&#39;d allow that too, but you wouldn&#39;t want &#39;static&#39; there, since that would put methods on P.Type.Type rather than P.Type.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4bb2d8cd29d26d7067e8b62a5e1cbf95?s=50"></div><header><strong>Binding generic types using a metatype parameter</strong> from <string>Joanna Carter</string> &lt;joanna at carterconsulting.org.uk&gt;<p>March 23, 2016 at 05:00:00pm</p></header><div class="content"><p>I&#39;m not sure if this is an appropriate conversation to bring this up on but, here goes.<br></p><p>I have a need, for serialisation and various other uses, to be able to create an instance of a generic type, with the parameter type(s) stored in (a) var(s) of Any.Type.<br></p><p>Typically, the origin of the metatype is something like a Mirror&#39;s subjectType property.<br></p><p>Some of the proposals for Swift 3 seem to touch on similar needs but I was not sure whether to pollute those discussions or not<br></p><p><br>Background…<br></p><p>I am an experienced frameworks developer, with over 20 years experience in the field but much of the first half of that was in C#, where such things are handled very well by the reflection provided in .NET.<br></p><p>I now also have 10 years Objective-C experience and started playing with Swift from the get-go but am finding the limitations of Swift&#39;s reflection to be very frustrating, especially for such a common use case as serialisation.<br></p><p>Joanna<br></p><p>--<br>Joanna Carter<br>Carter Consulting<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4bb2d8cd29d26d7067e8b62a5e1cbf95?s=50"></div><header><strong>Binding generic types using a metatype parameter</strong> from <string>Joanna Carter</string> &lt;joanna at carterconsulting.org.uk&gt;<p>March 23, 2016 at 05:00:00pm</p></header><div class="content"><p>My apologies. I seem to have managed to get this subject as a reply to another. I&#39;m not accustomed to mailing list forums. Could an admin move it if necessary?<br></p><p>Joanna<br></p><p>--<br>Joanna Carter<br>Carter Consulting<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Binding generic types using a metatype parameter</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 23, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 23, 2016, at 10:13 AM, Joanna Carter via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m not sure if this is an appropriate conversation to bring this up on but, here goes.<br>&gt; <br>&gt; I have a need, for serialisation and various other uses, to be able to create an instance of a generic type, with the parameter type(s) stored in (a) var(s) of Any.Type.<br>&gt; <br>&gt; Typically, the origin of the metatype is something like a Mirror&#39;s subjectType property.<br>&gt; <br>&gt; Some of the proposals for Swift 3 seem to touch on similar needs but I was not sure whether to pollute those discussions or not<br></p><p>You can accomplish this with Swift today by casting your Any.Type to a Protocol.Type that provides an initializer:<br></p><p>protocol Deserializable {<br>  init(deserializedFrom stream: DeserializationStream)<br>}<br></p><p>func deserializeValue(type type: Any.Type, from stream: DeserializationStream) -&gt; Any? {<br>  if let deserializableType = type as? Deserializable.Type {<br>    return deserializableType.init(deserializedFrom: stream)<br>  }<br>  return nil<br>}<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4bb2d8cd29d26d7067e8b62a5e1cbf95?s=50"></div><header><strong>Binding generic types using a metatype parameter</strong> from <string>Joanna Carter</string> &lt;joanna at carterconsulting.org.uk&gt;<p>March 23, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi Joe<br></p><p>&gt; <br>&gt; You can accomplish this with Swift today by casting your Any.Type to a Protocol.Type that provides an initializer:<br>&gt; <br>&gt; protocol Deserializable {<br>&gt;  init(deserializedFrom stream: DeserializationStream)<br>&gt; }<br>&gt; <br>&gt; func deserializeValue(type type: Any.Type, from stream: DeserializationStream) -&gt; Any? {<br>&gt;  if let deserializableType = type as? Deserializable.Type {<br>&gt;    return deserializableType.init(deserializedFrom: stream)<br>&gt;  }<br>&gt;  return nil<br>&gt; }<br></p><p>Hmm… I&#39;ve been playing with this for days now and, as useful as your code is for instantiating a given type, what I need to do is instantiate a generic type, bound to that given type.<br></p><p>Something along the lines of…<br></p><p>public protocol PropertyProtocol<br>{<br>  var untypedValue: Any? { get }<br>}<br></p><p>public struct Property&lt;PropertyType : Any&gt;<br>{<br>  public let info: PropertyInfo<br>  <br>  public var name: String<br>  {<br>    return info.name<br>  }<br>  <br>  public var displayName: String<br>  {<br>    return info.displayName<br>  }<br>  <br>  public var value: PropertyType?<br>  <br>  public init()<br>  {<br>    self.init(propertyInfo: PropertyInfo(), value: nil)<br>  }<br>  <br>  init(propertyInfo: PropertyInfo, value: PropertyType?)<br>  {<br>    self.value = value<br>    <br>    self.info = propertyInfo;<br>  }<br>  <br>  init(propertyInfo: PropertyInfo)<br>  {<br>    self.init(propertyInfo: propertyInfo, value: nil)<br>  }<br>  <br>  init(other: Property&lt;PropertyType&gt;)<br>  {<br>    self.init(propertyInfo: other.info, value: other.value)<br>  }<br>}<br></p><p>struct PropertyFactory<br>{<br>  static func createBoundPropertywithValueType(valueType: Any.Type) -&gt; PropertyProtocol<br>  {<br>    return Property&lt;valueType&gt;.init()<br>  }<br>}<br></p><p>Of course, Ive still got a lot of C# cruft in my thinking so I am more than willing to admit I may not be approaching this in the right way ;-)<br></p><p>Joanna<br></p><p>--<br>Joanna Carter<br>Carter Consulting<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4bb2d8cd29d26d7067e8b62a5e1cbf95?s=50"></div><header><strong>Binding generic types using a metatype parameter</strong> from <string>Joanna Carter</string> &lt;joanna at carterconsulting.org.uk&gt;<p>March 24, 2016 at 12:00:00pm</p></header><div class="content"><p>Well, I&#39;ve been playing some more and come up with an idea that seems to be thwarted by the compiler…<br></p><p>protocol PropertyFactory<br>{<br>  <br>}<br></p><p>extension PropertyFactory<br>{<br>  // what I&#39;d like to do but that doesn&#39;t compile<br>  static func createProperty() -&gt; PropertyProtocol<br>  {<br>    return Property&lt;Self.Type&gt;()<br>  }<br>  <br>// what it seems I have to do to satisfy the compiler<br>  static func createProperty(valueType: Any.Type) -&gt; PropertyProtocol<br>  {<br>    switch self // this is a really naff and limited workaround<br>    {<br>      case is Int.Type:<br>        return Property&lt;Int&gt;()<br>      // ...<br>      default: fatalError(&quot;Unexpected type \(self)&quot;)<br>    }<br>  }<br>}<br></p><p>extension Int : PropertyFactory<br>{<br>  <br>}<br></p><p>// calling code works fine<br></p><p>    let type: PropertyFactory.Type = Int.self<br>    <br>    var property = type.createProperty(type) as? Property&lt;Int&gt;<br>      <br>    property?.value = 123<br>      <br>    print(property?.untypedValue)<br>    <br>… but it does mean that all possible types would have to be extended to implement PropertyFactory.<br></p><p>Does this make a case for either :<br></p><p>Extend the generic syntax to allow for something like<br></p><p>struct GenericStruct&lt;ValueType : Any.Type&gt;<br>{<br>  func doSomething&lt;ParamType : MyType.Type&gt;()<br>  {<br>    …<br>  }<br>}<br></p><p>… or having something like the following that knows how to bind a generic type to its parameter types …<br></p><p>protocol AnyGeneric // all generic types implement this protocol<br>{<br></p><p>}<br></p><p>extension AnyGeneric<br>{<br>  static func bindToParameterType(parameterType: Any.Type) -&gt; Any.Type<br>  {<br>    // return something akin to Self&lt;parameterType&gt;<br>  }<br>}<br></p><p>The more I think about it, the latter option seems slightly screwy but I include it as a discussion point.<br></p><p>Joanna<br></p><p>--<br>Joanna Carter<br>Carter Consulting<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4bb2d8cd29d26d7067e8b62a5e1cbf95?s=50"></div><header><strong>Binding generic types using a metatype parameter</strong> from <string>Joanna Carter</string> &lt;joanna at carterconsulting.org.uk&gt;<p>March 24, 2016 at 01:00:00pm</p></header><div class="content"><p>I want to thank you for your &quot;rubber duck&quot; consultancy; I now have a working factory mechanism…<br></p><p>protocol PropertyFactory { }<br></p><p>extension PropertyFactory<br>{<br>  static func createProperty() -&gt; PropertyProtocol<br>  {<br>    typealias ValueType = Self<br>    <br>    return Property&lt;ValueType&gt;()<br>  }<br>}<br></p><p>extension Int : PropertyFactory { }<br></p><p>The key was to typealias Self so that it could then be passed as a type parameter to the generic type.<br></p><p>The problem remains that it is still necessary to implement PropertyFactory on each and every type that is likely to be used for a property.<br></p><p>I would therefore ask if anything that would make life simpler in this regard is a worthwhile candidate for inclusion in the future of Swift?<br></p><p>Joanna<br></p><p>--<br>Joanna Carter<br>Carter Consulting<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Binding generic types using a metatype parameter</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 24, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 23, 2016, at 11:29 AM, Joanna Carter &lt;joanna at carterconsulting.org.uk&gt; wrote:<br>&gt; <br>&gt; Hi Joe<br>&gt; <br>&gt;&gt; <br>&gt;&gt; You can accomplish this with Swift today by casting your Any.Type to a Protocol.Type that provides an initializer:<br>&gt;&gt; <br>&gt;&gt; protocol Deserializable {<br>&gt;&gt; init(deserializedFrom stream: DeserializationStream)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func deserializeValue(type type: Any.Type, from stream: DeserializationStream) -&gt; Any? {<br>&gt;&gt; if let deserializableType = type as? Deserializable.Type {<br>&gt;&gt;   return deserializableType.init(deserializedFrom: stream)<br>&gt;&gt; }<br>&gt;&gt; return nil<br>&gt;&gt; }<br>&gt; <br>&gt; Hmm… I&#39;ve been playing with this for days now and, as useful as your code is for instantiating a given type, what I need to do is instantiate a generic type, bound to that given type.<br>&gt; <br>&gt; Something along the lines of…<br>&gt; <br>&gt; public protocol PropertyProtocol<br>&gt; {<br>&gt;  var untypedValue: Any? { get }<br>&gt; }<br>&gt; <br>&gt; public struct Property&lt;PropertyType : Any&gt;<br>&gt; {<br>&gt;  public let info: PropertyInfo<br>&gt; <br>&gt;  public var name: String<br>&gt;  {<br>&gt;    return info.name<br>&gt;  }<br>&gt; <br>&gt;  public var displayName: String<br>&gt;  {<br>&gt;    return info.displayName<br>&gt;  }<br>&gt; <br>&gt;  public var value: PropertyType?<br>&gt; <br>&gt;  public init()<br>&gt;  {<br>&gt;    self.init(propertyInfo: PropertyInfo(), value: nil)<br>&gt;  }<br>&gt; <br>&gt;  init(propertyInfo: PropertyInfo, value: PropertyType?)<br>&gt;  {<br>&gt;    self.value = value<br>&gt; <br>&gt;    self.info = propertyInfo;<br>&gt;  }<br>&gt; <br>&gt;  init(propertyInfo: PropertyInfo)<br>&gt;  {<br>&gt;    self.init(propertyInfo: propertyInfo, value: nil)<br>&gt;  }<br>&gt; <br>&gt;  init(other: Property&lt;PropertyType&gt;)<br>&gt;  {<br>&gt;    self.init(propertyInfo: other.info, value: other.value)<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; struct PropertyFactory<br>&gt; {<br>&gt;  static func createBoundPropertywithValueType(valueType: Any.Type) -&gt; PropertyProtocol<br>&gt;  {<br>&gt;    return Property&lt;valueType&gt;.init()<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; Of course, Ive still got a lot of C# cruft in my thinking so I am more than willing to admit I may not be approaching this in the right way ;-)<br></p><p>Sorry for not getting back to you sooner. What&#39;s necessary here is a way to &quot;open&quot; the type of Any.Type, turning it back into something the compiler considers as a type instead of a value. This is something we&#39;ve discussed having better support for, but right now there&#39;s only a sneaky way to do it using protocol extensions. If you constrain Property&#39;s type parameter to a protocol:<br></p><p>protocol PropertyType {}<br>struct Property&lt;T: PropertyType&gt;: PropertyProtocol {}<br></p><p>then you can add a static method to PropertyType in an extension, which can use Self as the opened dynamic type:<br></p><p>extension PropertyType {<br>  private static func create() -&gt; Property&lt;Self&gt; {<br>    return Property&lt;Self&gt;.init()<br>  }<br>}<br></p><p>and delegate to that extension method in your factory function:<br></p><p>struct PropertyFactory {<br>  static func createBoundPropertywithValueType(valueType: PropertyType.Type) -&gt; PropertyProtocol<br>  {<br>    return valueType.create()<br>  }<br>}<br></p><p>-Joe<br></p><p>&gt; struct PropertyFactory<br>&gt; {<br>&gt;  static func createBoundPropertywithValueType(valueType: Any.Type) -&gt; PropertyProtocol<br>&gt;  {<br>&gt;    return Property&lt;valueType&gt;.init()<br>&gt;  }<br>&gt; }<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/1753382a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4bb2d8cd29d26d7067e8b62a5e1cbf95?s=50"></div><header><strong>Binding generic types using a metatype parameter</strong> from <string>Joanna Carter</string> &lt;joanna at carterconsulting.org.uk&gt;<p>March 24, 2016 at 11:00:00pm</p></header><div class="content"><p>Hi Joe<br></p><p>&gt; Sorry for not getting back to you sooner.<br></p><p>Hey, I&#39;m guessing you&#39;re busier than I am ;-)<br></p><p>&gt; What&#39;s necessary here is a way to &quot;open&quot; the type of Any.Type, turning it back into something the compiler considers as a type instead of a value.<br></p><p>Yes, that&#39;s what I had in mind<br></p><p>&gt; This is something we&#39;ve discussed having better support for, but right now there&#39;s only a sneaky way to do it using protocol extensions. If you constrain Property&#39;s type parameter to a protocol:<br>&gt; <br>&gt; protocol PropertyType {}<br>&gt; struct Property&lt;T: PropertyType&gt;: PropertyProtocol {}<br>&gt; <br>&gt; then you can add a static method to PropertyType in an extension, which can use Self as the opened dynamic type:<br>&gt; <br>&gt; extension PropertyType {<br>&gt;   private static func create() -&gt; Property&lt;Self&gt; {<br>&gt;     return Property&lt;Self&gt;.init()<br>&gt;   }<br>&gt; }<br></p><p>Unfortunately, this doesn&#39;t compile…<br></p><p>extension PropertyType<br>{<br>  private static func create() -&gt; Property&lt;Self&gt;<br>  {<br>    return Property&lt;Self&gt;.init()<br>                                        ^ &#39;&gt;&#39; is not a postfix unary operator<br>  }<br>}<br></p><p>Which is why I found it necessary to add a typealias like so…<br></p><p>extension PropertyType<br>{<br>  private static func create() -&gt; Property&lt;Self&gt;<br>  {<br>    typealias SelfType = Self<br>    <br>    return Property&lt;SelfType&gt;.init()<br>  }<br>}<br></p><p>&gt; and delegate to that extension method in your factory function:<br>&gt; <br>&gt; struct PropertyFactory {<br>&gt;   static func createBoundPropertywithValueType(valueType: PropertyType.Type) -&gt; PropertyProtocol<br>&gt;   {<br>&gt;     return valueType.create()<br>&gt;   }<br>&gt; }<br></p><p>This doesn&#39;t compile either…<br></p><p>struct PropertyFactory<br>{<br>  static func createBoundPropertywithValueType(valueType: PropertyType.Type) -&gt; PropertyProtocol<br>  {<br>    return valueType.create()<br>                ^ Member &#39;create&#39; cannot be used on value of protocol type &#39;PropertyType&#39;; use a generic constraint instead<br>  }<br>}<br></p><p>For some reason, as soon as you change the PropertyType extension static func to return PropertyProtocol…<br></p><p>extension PropertyType<br>{<br>  private static func create() -&gt; PropertyProtocol<br>  {<br>    typealias SelfType = Self<br>    <br>    return Property&lt;SelfType&gt;.init()<br>  }<br>}<br></p><p>… then, and only then, the factory&#39;s method compiles correctly.<br></p><p>Am I really finding bugs or am I still doing something wrong?<br></p><p>Joanna<br></p><p>--<br>Joanna Carter<br>Carter Consulting<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4bb2d8cd29d26d7067e8b62a5e1cbf95?s=50"></div><header><strong>Binding generic types using a metatype parameter</strong> from <string>Joanna Carter</string> &lt;joanna at carterconsulting.org.uk&gt;<p>March 24, 2016 at 11:00:00pm</p></header><div class="content"><p>Of course, after all this effort, I still have the problem of how to get the Any.Type from the SubjectType property of a Mirror into a PropertyType.Type.<br></p><p>What would really make life easier here would be the ability to extend Any.<br></p><p>Any chance?<br></p><p>Joanna<br></p><p>--<br>Joanna Carter<br>Carter Consulting<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
