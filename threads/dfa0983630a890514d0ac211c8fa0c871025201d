<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d569462ac92d4619342b1c5ff305043?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>frogcjn at 163.com</string> &lt;frogcjn at 163.com&gt;<p>August 11, 2016 at 09:00:00am</p></header><div class="content"><p>Hi all,<br></p><p>I want to make a discussion about union type for swift 4.<br>See https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md &lt;https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md&gt;<br></p><p>Add union type grammar, represents the type which is one of other types.<br></p><p>var stringOrURL: String | URL = &quot;https://www.apple.com&quot;<br>Now, if we using the new union type feature, we can declare type conveniently, No other type declaration, and compiler will automatically calculate the common interface.<br></p><p>func input(value: A | B | C) {<br>    print(value.commonProperty) // type checker will calculate the common interface, developer just use it out of box<br>    switch value {<br>    case let value as A:<br>        // value is type A<br>        print(value.propertyInA)<br>    case let value as B:<br>        // value is type B<br>        print(value.propertyInB)<br>    case let value as C:<br>        // value is type C<br>        print(value.propertyInC)<br>    }<br>    // there is no default case other than A, B or C. we already declared that.<br>}<br>Note: A, B, C can be either class or protocol, or any other types. This leaves developer more freedom.<br></p><p><br>Impact on existing code<br></p><p>This is a new feature, developer who need declare common type will alter to this new grammar.<br>Enum based version optional or IUO will be replaced by Union-based ones. Any optional type will automatically replaced by union type<br></p><p> &lt;https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md#detailed-design&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160811/dfa0201d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5c9df42e3c293e3cdb5f3e1b34d44ef9?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Step C</string> &lt;schristopher at bignerdranch.com&gt;<p>August 10, 2016 at 10:00:00pm</p></header><div class="content"><p>Shouldn&#39;t it be &quot;fn1 = fn0&quot;? Same for the fn2 statements. <br></p><p>`var fn0: A-&gt;Void = {print(v0)} <br>var fn1: (A|B)-&gt;Void = {print(v0)} <br></p><p> fn0 = fn1 // OK, because Original Type and Union Type has a sub-typing relationship var <br></p><p>fn2: (A|B|C)-&gt;Void = {print($0)} <br></p><p> fn0 = fn2 // OK <br> fn1 = fn2 // OK`<br></p><p>&gt; On Aug 10, 2016, at 9:28 PM, Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; I want to make a discussion about union type for swift 4.<br>&gt; See https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md<br>&gt; <br>&gt; Add union type grammar, represents the type which is one of other types.<br>&gt; <br>&gt; var stringOrURL: String | URL = &quot;https://www.apple.com&quot;<br>&gt; Now, if we using the new union type feature, we can declare type conveniently, No other type declaration, and compiler will automatically calculate the common interface.<br>&gt; <br>&gt; func input(value: A | B | C) {<br>&gt;     print(value.commonProperty) // type checker will calculate the common interface, developer just use it out of box<br>&gt;     switch value {<br>&gt;     case let value as A:<br>&gt;         // value is type A<br>&gt;         print(value.propertyInA)<br>&gt;     case let value as B:<br>&gt;         // value is type B<br>&gt;         print(value.propertyInB)<br>&gt;     case let value as C:<br>&gt;         // value is type C<br>&gt;         print(value.propertyInC)<br>&gt;     }<br>&gt;     // there is no default case other than A, B or C. we already declared that.<br>&gt; }<br>&gt; Note: A, B, C can be either class or protocol, or any other types. This leaves developer more freedom.<br>&gt; <br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; This is a new feature, developer who need declare common type will alter to this new grammar.<br>&gt; Enum based version optional or IUO will be replaced by Union-based ones. Any optional type will automatically replaced by union type<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160810/6549a7f1/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Maximilian HÃ¼nenberger</string> &lt;m.huenenberger at me.com&gt;<p>August 12, 2016 at 01:00:00pm</p></header><div class="content"><p>Hi Cao,<br></p><p>I would be in favor until I find another approach to this problem:<br></p><p>Consider you have a geometry framework and two types: Point and Line<br></p><p>An intersection between two lines can be either none, a point or a line (if both are identical).<br></p><p>The return type would probably be (Point | Line)?<br></p><p>I&#39;ve modeled it with an empty protocol &quot;GeometryType&quot;. However this has a major disadvantage:<br>If you have a general &quot;GeometryType?&quot; you have to cast it in a switch to the specific type.<br>In case of (Point| Line)? the switch statement can be checked for exhaustiveness.<br></p><p>For future directions:<br></p><p>There should also be a subtype relationship:<br></p><p>let tu: (T | U) = T()<br>let tuv: (T | U | V) = tu // works<br></p><p><br>Overloaded functions/operators could also take Union types based on their overloads:<br></p><p>func take(_ i: Int) -&gt; String { ... }<br></p><p>func take(_ s: String) -&gt; Int? { ... }<br></p><p>let value: (Int | String) = &quot;1234&quot;<br>let value2 = take(value) // returns (String | Int?)<br></p><p>Best regards<br>Maximilian<br></p><p>&gt; Am 11.08.2016 um 03:28 schrieb Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; I want to make a discussion about union type for swift 4.<br>&gt; See https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md<br>&gt; <br>&gt; Add union type grammar, represents the type which is one of other types.<br>&gt; <br>&gt; var stringOrURL: String | URL = &quot;https://www.apple.com&quot;<br>&gt; Now, if we using the new union type feature, we can declare type conveniently, No other type declaration, and compiler will automatically calculate the common interface.<br>&gt; <br>&gt; func input(value: A | B | C) {<br>&gt;     print(value.commonProperty) // type checker will calculate the common interface, developer just use it out of box<br>&gt;     switch value {<br>&gt;     case let value as A:<br>&gt;         // value is type A<br>&gt;         print(value.propertyInA)<br>&gt;     case let value as B:<br>&gt;         // value is type B<br>&gt;         print(value.propertyInB)<br>&gt;     case let value as C:<br>&gt;         // value is type C<br>&gt;         print(value.propertyInC)<br>&gt;     }<br>&gt;     // there is no default case other than A, B or C. we already declared that.<br>&gt; }<br>&gt; Note: A, B, C can be either class or protocol, or any other types. This leaves developer more freedom.<br>&gt; <br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; This is a new feature, developer who need declare common type will alter to this new grammar.<br>&gt; Enum based version optional or IUO will be replaced by Union-based ones. Any optional type will automatically replaced by union type<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160812/141bcfa4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>August 12, 2016 at 10:00:00am</p></header><div class="content"><p>As an aside, you could use an enum instead of a protocol to avoid the problem of not having exhaustive switches:<br></p><p>enum GeometryValue {<br>  case point(Point)<br>  case line(Line)<br>}<br></p><p>And perhaps (depending on circumstances) you might not even need a Point and Line struct, so you could just put those values inside the enum:<br></p><p>enum GeometryValue {<br>  case point(x: Float, y: Float)<br>  case line(x: Float, y: Float, angle: Float)<br>}<br></p><p>However personally, I think using a protocol is the more Swifty approach to this problem. If I end up not having any common properties or functions that apply to that one umbrella protocol, then I consider that a signal that Iâm modeling my solution incorrectly.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Aug 12, 2016, at 6:24 AM, Maximilian HÃ¼nenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Cao,<br>&gt; <br>&gt; I would be in favor until I find another approach to this problem:<br>&gt; <br>&gt; Consider you have a geometry framework and two types: Point and Line<br>&gt; <br>&gt; An intersection between two lines can be either none, a point or a line (if both are identical).<br>&gt; <br>&gt; The return type would probably be (Point | Line)?<br>&gt; <br>&gt; I&#39;ve modeled it with an empty protocol &quot;GeometryType&quot;. However this has a major disadvantage:<br>&gt; If you have a general &quot;GeometryType?&quot; you have to cast it in a switch to the specific type.<br>&gt; In case of (Point| Line)? the switch statement can be checked for exhaustiveness.<br>&gt; <br>&gt; For future directions:<br>&gt; <br>&gt; There should also be a subtype relationship:<br>&gt; <br>&gt; let tu: (T | U) = T()<br>&gt; let tuv: (T | U | V) = tu // works<br>&gt; <br>&gt; <br>&gt; Overloaded functions/operators could also take Union types based on their overloads:<br>&gt; <br>&gt; func take(_ i: Int) -&gt; String { ... }<br>&gt; <br>&gt; func take(_ s: String) -&gt; Int? { ... }<br>&gt; <br>&gt; let value: (Int | String) = &quot;1234&quot;<br>&gt; let value2 = take(value) // returns (String | Int?)<br>&gt; <br>&gt; Best regards<br>&gt; Maximilian<br>&gt; <br>&gt; Am 11.08.2016 um 03:28 schrieb Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; I want to make a discussion about union type for swift 4.<br>&gt;&gt; See https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md<br>&gt;&gt; <br>&gt;&gt; Add union type grammar, represents the type which is one of other types.<br>&gt;&gt; <br>&gt;&gt; var stringOrURL: String | URL = &quot;https://www.apple.com&quot;<br>&gt;&gt; Now, if we using the new union type feature, we can declare type conveniently, No other type declaration, and compiler will automatically calculate the common interface.<br>&gt;&gt; <br>&gt;&gt; func input(value: A | B |<br>&gt;&gt;  C) {<br>&gt;&gt;     <br>&gt;&gt; print(value.commonProperty) // type checker will calculate the common interface, developer just use it out of box<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; switch<br>&gt;&gt;  value {<br>&gt;&gt;     <br>&gt;&gt; case let value as<br>&gt;&gt;  A:<br>&gt;&gt;         <br>&gt;&gt; // value is type A<br>&gt;&gt; <br>&gt;&gt;         <br>&gt;&gt; print(value.<br>&gt;&gt; propertyInA)<br>&gt;&gt;     <br>&gt;&gt; case let value as<br>&gt;&gt;  B:<br>&gt;&gt;         <br>&gt;&gt; // value is type B<br>&gt;&gt; <br>&gt;&gt;         <br>&gt;&gt; print(value.<br>&gt;&gt; propertyInB)<br>&gt;&gt;     <br>&gt;&gt; case let value as<br>&gt;&gt;  C:<br>&gt;&gt;         <br>&gt;&gt; // value is type C<br>&gt;&gt; <br>&gt;&gt;         <br>&gt;&gt; print(value.<br>&gt;&gt; propertyInC)<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt; // there is no default case other than A, B or C. we already declared that.<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Note: A, B, C can be either class or protocol, or any other types. This leaves developer more freedom.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; 	â¢ This is a new feature, developer who need declare common type will alter to this new grammar.<br>&gt;&gt; 	â¢ Enum based version optional or IUO will be replaced by Union-based ones. Any optional type will automatically replaced by union type<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Maximilian HÃ¼nenberger</string> &lt;m.huenenberger at me.com&gt;<p>August 15, 2016 at 04:00:00pm</p></header><div class="content"><p>I considered the enum approach but it is very tedious to use &quot;space.add(.point(point))&quot; which also doesn&#39;t add any clarity.<br>The other approach where we add the properties of a Point as associated values also has a major drawback:<br></p><p>// you cannot create a point without &quot;erasing&quot; it&#39;s type<br>let point = GeometryValue.point(x: 4, y: 5)<br></p><p>// if you already have a point instance<br>&quot;space.add(.point(x: point.x, y: point.y))&quot;<br></p><p>If the union type feature is implemented the intersection of a Point and a Line returns (Point | Line) which is a subtype of a general GeometryValue eg. (Point | Line | Plane) and additionally cannot be checked for a Plane since it doesn&#39;t make sense.<br></p><p>The problem with a protocol is that there are only a few methods in common and again in a method like intersect there is no exhaustiveness check in switches.<br></p><p>Best regards<br>Maximilian<br></p><p>&gt; Am 12.08.2016 um 17:16 schrieb Sean Heber &lt;sean at fifthace.com&gt;:<br>&gt; <br>&gt; As an aside, you could use an enum instead of a protocol to avoid the problem of not having exhaustive switches:<br>&gt; <br>&gt; enum GeometryValue {<br>&gt;  case point(Point)<br>&gt;  case line(Line)<br>&gt; }<br>&gt; <br>&gt; And perhaps (depending on circumstances) you might not even need a Point and Line struct, so you could just put those values inside the enum:<br>&gt; <br>&gt; enum GeometryValue {<br>&gt;  case point(x: Float, y: Float)<br>&gt;  case line(x: Float, y: Float, angle: Float)<br>&gt; }<br>&gt; <br>&gt; However personally, I think using a protocol is the more Swifty approach to this problem. If I end up not having any common properties or functions that apply to that one umbrella protocol, then I consider that a signal that Iâm modeling my solution incorrectly.<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 12, 2016, at 6:24 AM, Maximilian HÃ¼nenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Cao,<br>&gt;&gt; <br>&gt;&gt; I would be in favor until I find another approach to this problem:<br>&gt;&gt; <br>&gt;&gt; Consider you have a geometry framework and two types: Point and Line<br>&gt;&gt; <br>&gt;&gt; An intersection between two lines can be either none, a point or a line (if both are identical).<br>&gt;&gt; <br>&gt;&gt; The return type would probably be (Point | Line)?<br>&gt;&gt; <br>&gt;&gt; I&#39;ve modeled it with an empty protocol &quot;GeometryType&quot;. However this has a major disadvantage:<br>&gt;&gt; If you have a general &quot;GeometryType?&quot; you have to cast it in a switch to the specific type.<br>&gt;&gt; In case of (Point| Line)? the switch statement can be checked for exhaustiveness.<br>&gt;&gt; <br>&gt;&gt; For future directions:<br>&gt;&gt; <br>&gt;&gt; There should also be a subtype relationship:<br>&gt;&gt; <br>&gt;&gt; let tu: (T | U) = T()<br>&gt;&gt; let tuv: (T | U | V) = tu // works<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Overloaded functions/operators could also take Union types based on their overloads:<br>&gt;&gt; <br>&gt;&gt; func take(_ i: Int) -&gt; String { ... }<br>&gt;&gt; <br>&gt;&gt; func take(_ s: String) -&gt; Int? { ... }<br>&gt;&gt; <br>&gt;&gt; let value: (Int | String) = &quot;1234&quot;<br>&gt;&gt; let value2 = take(value) // returns (String | Int?)<br>&gt;&gt; <br>&gt;&gt; Best regards<br>&gt;&gt; Maximilian<br>&gt;&gt; <br>&gt;&gt;&gt; Am 11.08.2016 um 03:28 schrieb Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I want to make a discussion about union type for swift 4.<br>&gt;&gt;&gt; See https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Add union type grammar, represents the type which is one of other types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var stringOrURL: String | URL = &quot;https://www.apple.com&quot;<br>&gt;&gt;&gt; Now, if we using the new union type feature, we can declare type conveniently, No other type declaration, and compiler will automatically calculate the common interface.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func input(value: A | B |<br>&gt;&gt;&gt; C) {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(value.commonProperty) // type checker will calculate the common interface, developer just use it out of box<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch<br>&gt;&gt;&gt; value {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case let value as<br>&gt;&gt;&gt; A:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // value is type A<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(value.<br>&gt;&gt;&gt; propertyInA)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case let value as<br>&gt;&gt;&gt; B:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // value is type B<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(value.<br>&gt;&gt;&gt; propertyInB)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case let value as<br>&gt;&gt;&gt; C:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // value is type C<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(value.<br>&gt;&gt;&gt; propertyInC)<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // there is no default case other than A, B or C. we already declared that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note: A, B, C can be either class or protocol, or any other types. This leaves developer more freedom.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    â¢ This is a new feature, developer who need declare common type will alter to this new grammar.<br>&gt;&gt;&gt;    â¢ Enum based version optional or IUO will be replaced by Union-based ones. Any optional type will automatically replaced by union type<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>August 18, 2016 at 07:00:00am</p></header><div class="content"><p>While I am a big fan of union types, I think an enum based solution for your problem is not too bad. Just use the enums only for the intersection results, i.e.<br></p><p>enum Intersection1d {<br>    case point(Point)<br>    case line(Line)<br>}<br></p><p>Same for Intersection2d, but adding case plane(Plane) and so on for higher dimensions.<br></p><p>This way the purpose of these types is clear which was not the case for a more general  GeometryValue.<br></p><p>-Thorsten <br></p><p><br></p><p>&gt; Am 15.08.2016 um 16:29 schrieb Maximilian HÃ¼nenberger via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I considered the enum approach but it is very tedious to use &quot;space.add(.point(point))&quot; which also doesn&#39;t add any clarity.<br>&gt; The other approach where we add the properties of a Point as associated values also has a major drawback:<br>&gt; <br>&gt; // you cannot create a point without &quot;erasing&quot; it&#39;s type<br>&gt; let point = GeometryValue.point(x: 4, y: 5)<br>&gt; <br>&gt; // if you already have a point instance<br>&gt; &quot;space.add(.point(x: point.x, y: point.y))&quot;<br>&gt; <br>&gt; If the union type feature is implemented the intersection of a Point and a Line returns (Point | Line) which is a subtype of a general GeometryValue eg. (Point | Line | Plane) and additionally cannot be checked for a Plane since it doesn&#39;t make sense.<br>&gt; <br>&gt; The problem with a protocol is that there are only a few methods in common and again in a method like intersect there is no exhaustiveness check in switches.<br>&gt; <br>&gt; Best regards<br>&gt; Maximilian<br>&gt; <br>&gt;&gt; Am 12.08.2016 um 17:16 schrieb Sean Heber &lt;sean at fifthace.com&gt;:<br>&gt;&gt; <br>&gt;&gt; As an aside, you could use an enum instead of a protocol to avoid the problem of not having exhaustive switches:<br>&gt;&gt; <br>&gt;&gt; enum GeometryValue {<br>&gt;&gt; case point(Point)<br>&gt;&gt; case line(Line)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; And perhaps (depending on circumstances) you might not even need a Point and Line struct, so you could just put those values inside the enum:<br>&gt;&gt; <br>&gt;&gt; enum GeometryValue {<br>&gt;&gt; case point(x: Float, y: Float)<br>&gt;&gt; case line(x: Float, y: Float, angle: Float)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; However personally, I think using a protocol is the more Swifty approach to this problem. If I end up not having any common properties or functions that apply to that one umbrella protocol, then I consider that a signal that Iâm modeling my solution incorrectly.<br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 12, 2016, at 6:24 AM, Maximilian HÃ¼nenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Cao,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would be in favor until I find another approach to this problem:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider you have a geometry framework and two types: Point and Line<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An intersection between two lines can be either none, a point or a line (if both are identical).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The return type would probably be (Point | Line)?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve modeled it with an empty protocol &quot;GeometryType&quot;. However this has a major disadvantage:<br>&gt;&gt;&gt; If you have a general &quot;GeometryType?&quot; you have to cast it in a switch to the specific type.<br>&gt;&gt;&gt; In case of (Point| Line)? the switch statement can be checked for exhaustiveness.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For future directions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There should also be a subtype relationship:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let tu: (T | U) = T()<br>&gt;&gt;&gt; let tuv: (T | U | V) = tu // works<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Overloaded functions/operators could also take Union types based on their overloads:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func take(_ i: Int) -&gt; String { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func take(_ s: String) -&gt; Int? { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let value: (Int | String) = &quot;1234&quot;<br>&gt;&gt;&gt; let value2 = take(value) // returns (String | Int?)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best regards<br>&gt;&gt;&gt; Maximilian<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 11.08.2016 um 03:28 schrieb Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I want to make a discussion about union type for swift 4.<br>&gt;&gt;&gt;&gt; See https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Add union type grammar, represents the type which is one of other types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var stringOrURL: String | URL = &quot;https://www.apple.com&quot;<br>&gt;&gt;&gt;&gt; Now, if we using the new union type feature, we can declare type conveniently, No other type declaration, and compiler will automatically calculate the common interface.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func input(value: A | B |<br>&gt;&gt;&gt;&gt; C) {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; print(value.commonProperty) // type checker will calculate the common interface, developer just use it out of box<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; switch<br>&gt;&gt;&gt;&gt; value {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; case let value as<br>&gt;&gt;&gt;&gt; A:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // value is type A<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; print(value.<br>&gt;&gt;&gt;&gt; propertyInA)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; case let value as<br>&gt;&gt;&gt;&gt; B:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // value is type B<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; print(value.<br>&gt;&gt;&gt;&gt; propertyInB)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; case let value as<br>&gt;&gt;&gt;&gt; C:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // value is type C<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; print(value.<br>&gt;&gt;&gt;&gt; propertyInC)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // there is no default case other than A, B or C. we already declared that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note: A, B, C can be either class or protocol, or any other types. This leaves developer more freedom.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   â¢ This is a new feature, developer who need declare common type will alter to this new grammar.<br>&gt;&gt;&gt;&gt;   â¢ Enum based version optional or IUO will be replaced by Union-based ones. Any optional type will automatically replaced by union type<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Maximilian HÃ¼nenberger</string> &lt;m.huenenberger at me.com&gt;<p>August 18, 2016 at 11:00:00am</p></header><div class="content"><p>While purpose of the types are clear in this case there is not only intersection. I also want to find out the distance between different GeometryTypes and other properties like angels between two lines or a Line and a Plane but this doesn&#39;t make sense for a Point and some other GeometryType.<br></p><p>Therefore a GeometryType with subtypes is almost the perfect solution. I imagine the perfect solution would be to have something like a &quot;newtype&quot; feature which is similar to a protocol but the types which &quot;conform&quot; to it are known at compile time.<br></p><p>Best regards<br>Maximilian<br></p><p>&gt; Am 18.08.2016 um 07:14 schrieb Thorsten Seitz &lt;tseitz42 at icloud.com&gt;:<br>&gt; <br>&gt; While I am a big fan of union types, I think an enum based solution for your problem is not too bad. Just use the enums only for the intersection results, i.e.<br>&gt; <br>&gt; enum Intersection1d {<br>&gt;    case point(Point)<br>&gt;    case line(Line)<br>&gt; }<br>&gt; <br>&gt; Same for Intersection2d, but adding case plane(Plane) and so on for higher dimensions.<br>&gt; <br>&gt; This way the purpose of these types is clear which was not the case for a more general  GeometryValue.<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Am 15.08.2016 um 16:29 schrieb Maximilian HÃ¼nenberger via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; I considered the enum approach but it is very tedious to use &quot;space.add(.point(point))&quot; which also doesn&#39;t add any clarity.<br>&gt;&gt; The other approach where we add the properties of a Point as associated values also has a major drawback:<br>&gt;&gt; <br>&gt;&gt; // you cannot create a point without &quot;erasing&quot; it&#39;s type<br>&gt;&gt; let point = GeometryValue.point(x: 4, y: 5)<br>&gt;&gt; <br>&gt;&gt; // if you already have a point instance<br>&gt;&gt; &quot;space.add(.point(x: point.x, y: point.y))&quot;<br>&gt;&gt; <br>&gt;&gt; If the union type feature is implemented the intersection of a Point and a Line returns (Point | Line) which is a subtype of a general GeometryValue eg. (Point | Line | Plane) and additionally cannot be checked for a Plane since it doesn&#39;t make sense.<br>&gt;&gt; <br>&gt;&gt; The problem with a protocol is that there are only a few methods in common and again in a method like intersect there is no exhaustiveness check in switches.<br>&gt;&gt; <br>&gt;&gt; Best regards<br>&gt;&gt; Maximilian<br>&gt;&gt; <br>&gt;&gt;&gt; Am 12.08.2016 um 17:16 schrieb Sean Heber &lt;sean at fifthace.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As an aside, you could use an enum instead of a protocol to avoid the problem of not having exhaustive switches:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum GeometryValue {<br>&gt;&gt;&gt; case point(Point)<br>&gt;&gt;&gt; case line(Line)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And perhaps (depending on circumstances) you might not even need a Point and Line struct, so you could just put those values inside the enum:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum GeometryValue {<br>&gt;&gt;&gt; case point(x: Float, y: Float)<br>&gt;&gt;&gt; case line(x: Float, y: Float, angle: Float)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However personally, I think using a protocol is the more Swifty approach to this problem. If I end up not having any common properties or functions that apply to that one umbrella protocol, then I consider that a signal that Iâm modeling my solution incorrectly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; l8r<br>&gt;&gt;&gt; Sean<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 12, 2016, at 6:24 AM, Maximilian HÃ¼nenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Cao,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would be in favor until I find another approach to this problem:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Consider you have a geometry framework and two types: Point and Line<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; An intersection between two lines can be either none, a point or a line (if both are identical).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The return type would probably be (Point | Line)?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;ve modeled it with an empty protocol &quot;GeometryType&quot;. However this has a major disadvantage:<br>&gt;&gt;&gt;&gt; If you have a general &quot;GeometryType?&quot; you have to cast it in a switch to the specific type.<br>&gt;&gt;&gt;&gt; In case of (Point| Line)? the switch statement can be checked for exhaustiveness.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For future directions:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There should also be a subtype relationship:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let tu: (T | U) = T()<br>&gt;&gt;&gt;&gt; let tuv: (T | U | V) = tu // works<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Overloaded functions/operators could also take Union types based on their overloads:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func take(_ i: Int) -&gt; String { ... }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func take(_ s: String) -&gt; Int? { ... }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let value: (Int | String) = &quot;1234&quot;<br>&gt;&gt;&gt;&gt; let value2 = take(value) // returns (String | Int?)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Best regards<br>&gt;&gt;&gt;&gt; Maximilian<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 11.08.2016 um 03:28 schrieb Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I want to make a discussion about union type for swift 4.<br>&gt;&gt;&gt;&gt;&gt; See https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Add union type grammar, represents the type which is one of other types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; var stringOrURL: String | URL = &quot;https://www.apple.com&quot;<br>&gt;&gt;&gt;&gt;&gt; Now, if we using the new union type feature, we can declare type conveniently, No other type declaration, and compiler will automatically calculate the common interface.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func input(value: A | B |<br>&gt;&gt;&gt;&gt;&gt; C) {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; print(value.commonProperty) // type checker will calculate the common interface, developer just use it out of box<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; switch<br>&gt;&gt;&gt;&gt;&gt; value {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; case let value as<br>&gt;&gt;&gt;&gt;&gt; A:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // value is type A<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; print(value.<br>&gt;&gt;&gt;&gt;&gt; propertyInA)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; case let value as<br>&gt;&gt;&gt;&gt;&gt; B:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // value is type B<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; print(value.<br>&gt;&gt;&gt;&gt;&gt; propertyInB)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; case let value as<br>&gt;&gt;&gt;&gt;&gt; C:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // value is type C<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; print(value.<br>&gt;&gt;&gt;&gt;&gt; propertyInC)<br>&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // there is no default case other than A, B or C. we already declared that.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Note: A, B, C can be either class or protocol, or any other types. This leaves developer more freedom.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  â¢ This is a new feature, developer who need declare common type will alter to this new grammar.<br>&gt;&gt;&gt;&gt;&gt;  â¢ Enum based version optional or IUO will be replaced by Union-based ones. Any optional type will automatically replaced by union type<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>August 18, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Aug 18, 2016, at 2:05 AM, Maximilian HÃ¼nenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; While purpose of the types are clear in this case there is not only intersection. I also want to find out the distance between different GeometryTypes and other properties like angels between two lines or a Line and a Plane but this doesn&#39;t make sense for a Point and some other GeometryType.<br></p><p>But there are extremely complicated interactions between different pairs of types:<br></p><p>	Line.intersection(with: Line) -&gt; Void | Point | Line<br>	Line.intersection(with: Circle) -&gt; Void | Point | (Point, Point)<br>	Line.intersection(with: Polygon) -&gt; [Point | Line]<br>	<br>	Circle.intersection(with: Line) -&gt; Void | Point | Line<br>	Circle.intersection(with: Circle) -&gt; Void | Point | (Point, Point) | Circle<br>	Circle.intersection(with: Polygon) -&gt; [Point | (Point, Point)]<br>	<br>	Polygon.intersection(with: Line) -&gt; [Point | Line]<br>	Polygon.intersection(with: Circle) -&gt; [Point | (Point, Point)]<br>	Polygon.intersection(with: Polygon) -&gt; [Point | Line] | Polygon<br></p><p>What exactly are you planning to do with a `[Point | Line] | Polygon`? Honestly, your only real option is to test it for specific subtypes and try to use them. But there&#39;s already a type for that kind of thing: an enum. Enums are better for this application because they lend more structure and allow you to explain cases with descriptive labels:<br></p><p>	enum PossiblyCoincidental&lt;CoincidentalType, IntersectingType&gt; {<br>		case coincidental (CoincidentalType)<br>		case intersecting (IntersectingType)<br>	}<br>	<br>	typealias LineIntersection = PossiblyCoincidental&lt;Line, Point&gt;<br></p><p>	enum CircleIntersection {<br>		case tangent (Point)<br>		case secant (Point, Point)<br>	}<br>	<br>	Line.intersection(with: Line) -&gt; LineIntersection?<br>	Line.intersection(with: Circle) -&gt; CircleIntersection?<br>	Line.intersection(with: Polygon) -&gt; [LineIntersection]<br>	<br>	Circle.intersection(with: Line) -&gt; CircleIntersection?<br>	Circle.intersection(with: Circle) -&gt; PossiblyCoincidental&lt;Circle, CircleIntersection&gt;?<br>	Circle.intersection(with: Polygon) -&gt; [CircleIntersection]<br>	<br>	Polygon.intersection(with: Line) -&gt; [LineIntersection]<br>	Polygon.intersection(with: Circle) -&gt; [CircleIntersection]<br>	Polygon.intersection(with: Polygon) -&gt; PossiblyCoincidental&lt;Polygon, [LineIntersection]&gt;<br></p><p>This is more complicated, but it&#39;s also a lot clearer about what each return type actually means. The existence of rich type information also helps you add functionality:<br></p><p>	protocol IntersectionType {<br>		var isEmpty: Bool { get }<br>	}<br>	<br>	extension CircleIntersection: IntersectionType {<br>		var isEmpty: Bool { return false }<br>	}<br>	<br>	extension PossiblyCoincidental: IntersectionType {<br>		var isEmpty: Bool: { return false }<br>	}<br>	<br>	// Cascade inward if IntersectingType happens to itself be an intersection.<br>	extension PossiblyCoincidental where IntersectingType: IntersectionType {<br>		var isEmpty: Bool {<br>			switch self {<br>			case .coincidental:<br>				return false<br>			case .intersecting(let intersection):<br>				return intersection.isEmpty<br>			}<br>		}<br>	}<br>	<br>	// Note: Using future conditional conformances<br>	extension Optional: IntersectionType where Wrapped: IntersectionType {<br>		var isEmpty: Bool {<br>			return map { $0.isEmpty } ?? true<br>		}<br>	}<br>	<br>	// Retroactive modeling yay!<br>	extension Array: IntersectionType where Element: IntersectionType {}<br></p><p>Of course, it might be the case that this is *way* more information than you really need, and you just want to say:<br></p><p>	GeometricElement.intersection(with: GeometricElement) -&gt; [GeometricElement]<br></p><p>But if you want something simple and uniform, you probably don&#39;t want the complex `Void | Point | Line`-type stuff, either. Union types are neither simple and uniform, nor complex and descriptive; they are neither fish nor fowl. I just don&#39;t see a strong reason to prefer them here.<br></p><p>	* * *<br></p><p>I&#39;ll ask again what I think has been the crux of this argument from the beginning, and what hasn&#39;t really been satisfactorily answered in several months of discussions.<br></p><p>**What use cases are better served by union types than by the alternatives?**<br></p><p>Can you show us code where union types are clearly betterânot just shorterâthan an equivalent design based on (depending on the need) protocols, enums, or overloading? What about with minor extensions to these features, like closed protocols (allowing for exhaustive checking of protocol types) or implicit type lifting for enums (allowing you to avoid explicitly constructing the case you need, as Optional.some does)?<br></p><p>There is clearly overlap between union types and some of our other features. When do you expect people would use each feature? Are there other languages which support both union types and sum types (i.e. Swift `enum`s)? When do they use each of these?<br></p><p>(Incidentally, even if we had union types, I don&#39;t think we&#39;d want to change Optional&#39;s definition. Nested optionals are a bit confusing at times, but they&#39;re important for correctness in many cases, like collections of Optionals. If Optional is a union type, you also lose the opportunity to have operations like `map` and `flatMap` on it.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>August 19, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Aug 19, 2016, at 1:20 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 18, 2016, at 2:05 AM, Maximilian HÃ¼nenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; While purpose of the types are clear in this case there is not only intersection. I also want to find out the distance between different GeometryTypes and other properties like angels between two lines or a Line and a Plane but this doesn&#39;t make sense for a Point and some other GeometryType.<br>&gt; <br>&gt; But there are extremely complicated interactions between different pairs of types:<br>&gt; <br>&gt; 	Line.intersection(with: Line) -&gt; Void | Point | Line<br>&gt; 	Line.intersection(with: Circle) -&gt; Void | Point | (Point, Point)<br>&gt; 	Line.intersection(with: Polygon) -&gt; [Point | Line]<br>&gt; 	<br>&gt; 	Circle.intersection(with: Line) -&gt; Void | Point | Line<br>&gt; 	Circle.intersection(with: Circle) -&gt; Void | Point | (Point, Point) | Circle<br>&gt; 	Circle.intersection(with: Polygon) -&gt; [Point | (Point, Point)]<br>&gt; 	<br>&gt; 	Polygon.intersection(with: Line) -&gt; [Point | Line]<br>&gt; 	Polygon.intersection(with: Circle) -&gt; [Point | (Point, Point)]<br>&gt; 	Polygon.intersection(with: Polygon) -&gt; [Point | Line] | Polygon<br>&gt; <br>&gt; What exactly are you planning to do with a `[Point | Line] | Polygon`? Honestly, your only real option is to test it for specific subtypes and try to use them. But there&#39;s already a type for that kind of thing: an enum. Enums are better for this application because they lend more structure and allow you to explain cases with descriptive labels:<br>&gt; <br>&gt; 	enum PossiblyCoincidental&lt;CoincidentalType, IntersectingType&gt; {<br>&gt; 		case coincidental (CoincidentalType)<br>&gt; 		case intersecting (IntersectingType)<br>&gt; 	}<br>&gt; 	<br>&gt; 	typealias LineIntersection = PossiblyCoincidental&lt;Line, Point&gt;<br>&gt; <br>&gt; 	enum CircleIntersection {<br>&gt; 		case tangent (Point)<br>&gt; 		case secant (Point, Point)<br>&gt; 	}<br>&gt; 	<br>&gt; 	Line.intersection(with: Line) -&gt; LineIntersection?<br>&gt; 	Line.intersection(with: Circle) -&gt; CircleIntersection?<br>&gt; 	Line.intersection(with: Polygon) -&gt; [LineIntersection]<br>&gt; 	<br>&gt; 	Circle.intersection(with: Line) -&gt; CircleIntersection?<br>&gt; 	Circle.intersection(with: Circle) -&gt; PossiblyCoincidental&lt;Circle, CircleIntersection&gt;?<br>&gt; 	Circle.intersection(with: Polygon) -&gt; [CircleIntersection]<br>&gt; 	<br>&gt; 	Polygon.intersection(with: Line) -&gt; [LineIntersection]<br>&gt; 	Polygon.intersection(with: Circle) -&gt; [CircleIntersection]<br>&gt; 	Polygon.intersection(with: Polygon) -&gt; PossiblyCoincidental&lt;Polygon, [LineIntersection]&gt;<br>&gt; <br>&gt; This is more complicated, but it&#39;s also a lot clearer about what each return type actually means. The existence of rich type information also helps you add functionality:<br>&gt; <br>&gt; 	protocol IntersectionType {<br>&gt; 		var isEmpty: Bool { get }<br>&gt; 	}<br>&gt; 	<br>&gt; 	extension CircleIntersection: IntersectionType {<br>&gt; 		var isEmpty: Bool { return false }<br>&gt; 	}<br>&gt; 	<br>&gt; 	extension PossiblyCoincidental: IntersectionType {<br>&gt; 		var isEmpty: Bool: { return false }<br>&gt; 	}<br>&gt; 	<br>&gt; 	// Cascade inward if IntersectingType happens to itself be an intersection.<br>&gt; 	extension PossiblyCoincidental where IntersectingType: IntersectionType {<br>&gt; 		var isEmpty: Bool {<br>&gt; 			switch self {<br>&gt; 			case .coincidental:<br>&gt; 				return false<br>&gt; 			case .intersecting(let intersection):<br>&gt; 				return intersection.isEmpty<br>&gt; 			}<br>&gt; 		}<br>&gt; 	}<br>&gt; 	<br>&gt; 	// Note: Using future conditional conformances<br>&gt; 	extension Optional: IntersectionType where Wrapped: IntersectionType {<br>&gt; 		var isEmpty: Bool {<br>&gt; 			return map { $0.isEmpty } ?? true<br>&gt; 		}<br>&gt; 	}<br>&gt; 	<br>&gt; 	// Retroactive modeling yay!<br>&gt; 	extension Array: IntersectionType where Element: IntersectionType {}<br>&gt; <br>&gt; Of course, it might be the case that this is *way* more information than you really need, and you just want to say:<br>&gt; <br>&gt; 	GeometricElement.intersection(with: GeometricElement) -&gt; [GeometricElement]<br>&gt; <br>&gt; But if you want something simple and uniform, you probably don&#39;t want the complex `Void | Point | Line`-type stuff, either. Union types are neither simple and uniform, nor complex and descriptive; they are neither fish nor fowl. I just don&#39;t see a strong reason to prefer them here.<br>&gt; <br>&gt; 	* * *<br>&gt; <br>&gt; I&#39;ll ask again what I think has been the crux of this argument from the beginning, and what hasn&#39;t really been satisfactorily answered in several months of discussions.<br>&gt; <br>&gt; **What use cases are better served by union types than by the alternatives?**<br>&gt; <br>&gt; Can you show us code where union types are clearly betterânot just shorterâthan an equivalent design based on (depending on the need) protocols, enums, or overloading? What about with minor extensions to these features, like closed protocols (allowing for exhaustive checking of protocol types) or implicit type lifting for enums (allowing you to avoid explicitly constructing the case you need, as Optional.some does)?<br></p><p>I think implicit lifting with some additional syntactic sugar would be a very good solution here.<br></p><p>First, an example of an enum with implicit lifting (using the strawman `autolift` modifier which conservatively could be restricted to cases with a single associated value and could not be used on cases with associated values whose type is also the type of an associated value in another case):<br></p><p>enum Foo {<br>    autolift case .string(String)<br>    autolift case .int(Int)<br>    // etc<br>}<br></p><p>func bar(_ foos: [Foo]) {}<br></p><p>// âa stringâ is implicitly lifted to be .string(âa stringâ) and 42 is implicitly lifted to be .int(42)<br>bar([âa stringâ, 42])<br></p><p>This would solve the use case I have run into where I was working on a library design and wanted to accept a heterogeneous collection without requiring callers to have any knowledge beyond what types can be uses (i.e. I donât want them to have to deal with the syntactic noise of manual lifting, but more importantly I would consider an enum like this an implementation detail, not something users should really rely on).  <br></p><p>If we *are* going to support implicit lifting like this, why not also adopt syntactic sugar for creating / referencing them in an ad-hoc manner?  Rather than writing out the enum above, we could just declare:<br></p><p>func bar(_ foos: [String | Int]) {}<br></p><p>The enum would be created âon demandâ each time a distinct set of types was referenced, with implicit lifting for each case.  What is the downside of this syntactic sugar?  It would bring the âlightweightâ feel of union types to Swift while retaining the semantics of enums.  This feels like a nice middle ground to me.<br></p><p>As you mention, closed protocols are another possible solution to the design problem I was working on, although it is somewhat less elegant as it would add conformances to the underlying types which is not necessarily desirable.<br></p><p>&gt; <br>&gt; There is clearly overlap between union types and some of our other features. When do you expect people would use each feature? Are there other languages which support both union types and sum types (i.e. Swift `enum`s)? When do they use each of these?<br>&gt; <br>&gt; (Incidentally, even if we had union types, I don&#39;t think we&#39;d want to change Optional&#39;s definition. Nested optionals are a bit confusing at times, but they&#39;re important for correctness in many cases, like collections of Optionals. If Optional is a union type, you also lose the opportunity to have operations like `map` and `flatMap` on it.)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 19, 2016 at 02:00:00pm</p></header><div class="content"><p>Ad-hoc enums have been discussed already, at length, and all the weaknesses<br>touched on then still apply now. For instance, since they&#39;re ad-hoc, can<br>you pass an instance of type &quot;Int | String&quot; as an argument if the function<br>expects a &quot;String | Int | Float&quot;? Enums don&#39;t have duck typing behavior<br>like that; if your ad-hoc type does, then it&#39;s not very much like an enum;<br>if it doesn&#39;t, it won&#39;t feel much like a union type.<br></p><p>Moreover, an ad-hoc &quot;String | Int&quot; may look like a union type, but until<br>switching over an instance to cast it, you can&#39;t invoke any methods common<br>to String and Int. So it really doesn&#39;t feel like a union type at all.<br></p><p>Don&#39;t get me wrong--like Brent, I&#39;m not convinced I see a scenario in which<br>union types would help write clearly better code, just code that is more<br>&quot;convenient&quot; in the eyes of the beholder. But ad-hoc enums have had their<br>day on this list, and I&#39;m not sure that re-visiting that discussion is<br>going to be very fruitful.<br></p><p>In any case, this all seems very, very out of scope for Swift 4.<br></p><p><br>On Fri, Aug 19, 2016 at 9:07 AM Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Aug 19, 2016, at 1:20 AM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On Aug 18, 2016, at 2:05 AM, Maximilian HÃ¼nenberger via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; While purpose of the types are clear in this case there is not only<br>&gt; intersection. I also want to find out the distance between different<br>&gt; GeometryTypes and other properties like angels between two lines or a Line<br>&gt; and a Plane but this doesn&#39;t make sense for a Point and some other<br>&gt; GeometryType.<br>&gt; &gt;<br>&gt; &gt; But there are extremely complicated interactions between different pairs<br>&gt; of types:<br>&gt; &gt;<br>&gt; &gt;       Line.intersection(with: Line) -&gt; Void | Point | Line<br>&gt; &gt;       Line.intersection(with: Circle) -&gt; Void | Point | (Point, Point)<br>&gt; &gt;       Line.intersection(with: Polygon) -&gt; [Point | Line]<br>&gt; &gt;<br>&gt; &gt;       Circle.intersection(with: Line) -&gt; Void | Point | Line<br>&gt; &gt;       Circle.intersection(with: Circle) -&gt; Void | Point | (Point, Point)<br>&gt; | Circle<br>&gt; &gt;       Circle.intersection(with: Polygon) -&gt; [Point | (Point, Point)]<br>&gt; &gt;<br>&gt; &gt;       Polygon.intersection(with: Line) -&gt; [Point | Line]<br>&gt; &gt;       Polygon.intersection(with: Circle) -&gt; [Point | (Point, Point)]<br>&gt; &gt;       Polygon.intersection(with: Polygon) -&gt; [Point | Line] | Polygon<br>&gt; &gt;<br>&gt; &gt; What exactly are you planning to do with a `[Point | Line] | Polygon`?<br>&gt; Honestly, your only real option is to test it for specific subtypes and try<br>&gt; to use them. But there&#39;s already a type for that kind of thing: an enum.<br>&gt; Enums are better for this application because they lend more structure and<br>&gt; allow you to explain cases with descriptive labels:<br>&gt; &gt;<br>&gt; &gt;       enum PossiblyCoincidental&lt;CoincidentalType, IntersectingType&gt; {<br>&gt; &gt;               case coincidental (CoincidentalType)<br>&gt; &gt;               case intersecting (IntersectingType)<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt;       typealias LineIntersection = PossiblyCoincidental&lt;Line, Point&gt;<br>&gt; &gt;<br>&gt; &gt;       enum CircleIntersection {<br>&gt; &gt;               case tangent (Point)<br>&gt; &gt;               case secant (Point, Point)<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt;       Line.intersection(with: Line) -&gt; LineIntersection?<br>&gt; &gt;       Line.intersection(with: Circle) -&gt; CircleIntersection?<br>&gt; &gt;       Line.intersection(with: Polygon) -&gt; [LineIntersection]<br>&gt; &gt;<br>&gt; &gt;       Circle.intersection(with: Line) -&gt; CircleIntersection?<br>&gt; &gt;       Circle.intersection(with: Circle) -&gt; PossiblyCoincidental&lt;Circle,<br>&gt; CircleIntersection&gt;?<br>&gt; &gt;       Circle.intersection(with: Polygon) -&gt; [CircleIntersection]<br>&gt; &gt;<br>&gt; &gt;       Polygon.intersection(with: Line) -&gt; [LineIntersection]<br>&gt; &gt;       Polygon.intersection(with: Circle) -&gt; [CircleIntersection]<br>&gt; &gt;       Polygon.intersection(with: Polygon) -&gt;<br>&gt; PossiblyCoincidental&lt;Polygon, [LineIntersection]&gt;<br>&gt; &gt;<br>&gt; &gt; This is more complicated, but it&#39;s also a lot clearer about what each<br>&gt; return type actually means. The existence of rich type information also<br>&gt; helps you add functionality:<br>&gt; &gt;<br>&gt; &gt;       protocol IntersectionType {<br>&gt; &gt;               var isEmpty: Bool { get }<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt;       extension CircleIntersection: IntersectionType {<br>&gt; &gt;               var isEmpty: Bool { return false }<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt;       extension PossiblyCoincidental: IntersectionType {<br>&gt; &gt;               var isEmpty: Bool: { return false }<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt;       // Cascade inward if IntersectingType happens to itself be an<br>&gt; intersection.<br>&gt; &gt;       extension PossiblyCoincidental where IntersectingType:<br>&gt; IntersectionType {<br>&gt; &gt;               var isEmpty: Bool {<br>&gt; &gt;                       switch self {<br>&gt; &gt;                       case .coincidental:<br>&gt; &gt;                               return false<br>&gt; &gt;                       case .intersecting(let intersection):<br>&gt; &gt;                               return intersection.isEmpty<br>&gt; &gt;                       }<br>&gt; &gt;               }<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt;       // Note: Using future conditional conformances<br>&gt; &gt;       extension Optional: IntersectionType where Wrapped:<br>&gt; IntersectionType {<br>&gt; &gt;               var isEmpty: Bool {<br>&gt; &gt;                       return map { $0.isEmpty } ?? true<br>&gt; &gt;               }<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt;       // Retroactive modeling yay!<br>&gt; &gt;       extension Array: IntersectionType where Element: IntersectionType<br>&gt; {}<br>&gt; &gt;<br>&gt; &gt; Of course, it might be the case that this is *way* more information than<br>&gt; you really need, and you just want to say:<br>&gt; &gt;<br>&gt; &gt;       GeometricElement.intersection(with: GeometricElement) -&gt;<br>&gt; [GeometricElement]<br>&gt; &gt;<br>&gt; &gt; But if you want something simple and uniform, you probably don&#39;t want<br>&gt; the complex `Void | Point | Line`-type stuff, either. Union types are<br>&gt; neither simple and uniform, nor complex and descriptive; they are neither<br>&gt; fish nor fowl. I just don&#39;t see a strong reason to prefer them here.<br>&gt; &gt;<br>&gt; &gt;       * * *<br>&gt; &gt;<br>&gt; &gt; I&#39;ll ask again what I think has been the crux of this argument from the<br>&gt; beginning, and what hasn&#39;t really been satisfactorily answered in several<br>&gt; months of discussions.<br>&gt; &gt;<br>&gt; &gt; **What use cases are better served by union types than by the<br>&gt; alternatives?**<br>&gt; &gt;<br>&gt; &gt; Can you show us code where union types are clearly betterânot just<br>&gt; shorterâthan an equivalent design based on (depending on the need)<br>&gt; protocols, enums, or overloading? What about with minor extensions to these<br>&gt; features, like closed protocols (allowing for exhaustive checking of<br>&gt; protocol types) or implicit type lifting for enums (allowing you to avoid<br>&gt; explicitly constructing the case you need, as Optional.some does)?<br>&gt;<br>&gt; I think implicit lifting with some additional syntactic sugar would be a<br>&gt; very good solution here.<br>&gt;<br>&gt; First, an example of an enum with implicit lifting (using the strawman<br>&gt; `autolift` modifier which conservatively could be restricted to cases with<br>&gt; a single associated value and could not be used on cases with associated<br>&gt; values whose type is also the type of an associated value in another case):<br>&gt;<br>&gt; enum Foo {<br>&gt;     autolift case .string(String)<br>&gt;     autolift case .int(Int)<br>&gt;     // etc<br>&gt; }<br>&gt;<br>&gt; func bar(_ foos: [Foo]) {}<br>&gt;<br>&gt; // âa stringâ is implicitly lifted to be .string(âa stringâ) and 42 is<br>&gt; implicitly lifted to be .int(42)<br>&gt; bar([âa stringâ, 42])<br>&gt;<br>&gt; This would solve the use case I have run into where I was working on a<br>&gt; library design and wanted to accept a heterogeneous collection without<br>&gt; requiring callers to have any knowledge beyond what types can be uses (i.e.<br>&gt; I donât want them to have to deal with the syntactic noise of manual<br>&gt; lifting, but more importantly I would consider an enum like this an<br>&gt; implementation detail, not something users should really rely on).<br>&gt;<br>&gt; If we *are* going to support implicit lifting like this, why not also<br>&gt; adopt syntactic sugar for creating / referencing them in an ad-hoc manner?<br>&gt; Rather than writing out the enum above, we could just declare:<br>&gt;<br>&gt; func bar(_ foos: [String | Int]) {}<br>&gt;<br>&gt; The enum would be created âon demandâ each time a distinct set of types<br>&gt; was referenced, with implicit lifting for each case.  What is the downside<br>&gt; of this syntactic sugar?  It would bring the âlightweightâ feel of union<br>&gt; types to Swift while retaining the semantics of enums.  This feels like a<br>&gt; nice middle ground to me.<br>&gt;<br>&gt; As you mention, closed protocols are another possible solution to the<br>&gt; design problem I was working on, although it is somewhat less elegant as it<br>&gt; would add conformances to the underlying types which is not necessarily<br>&gt; desirable.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; There is clearly overlap between union types and some of our other<br>&gt; features. When do you expect people would use each feature? Are there other<br>&gt; languages which support both union types and sum types (i.e. Swift<br>&gt; `enum`s)? When do they use each of these?<br>&gt; &gt;<br>&gt; &gt; (Incidentally, even if we had union types, I don&#39;t think we&#39;d want to<br>&gt; change Optional&#39;s definition. Nested optionals are a bit confusing at<br>&gt; times, but they&#39;re important for correctness in many cases, like<br>&gt; collections of Optionals. If Optional is a union type, you also lose the<br>&gt; opportunity to have operations like `map` and `flatMap` on it.)<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160819/aa71cadf/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>August 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Aug 19, 2016, at 9:38 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Ad-hoc enums have been discussed already, at length, and all the weaknesses touched on then still apply now. For instance, since they&#39;re ad-hoc, can you pass an instance of type &quot;Int | String&quot; as an argument if the function expects a &quot;String | Int | Float&quot;? Enums don&#39;t have duck typing behavior like that; if your ad-hoc type does, then it&#39;s not very much like an enum; if it doesn&#39;t, it won&#39;t feel much like a union type.<br></p><p>IMO one of the nice things about modeling this as syntactic sugar over the semantics of enums is that the answer to this is clear.  Right now, no.  In the future we may have value type subtyping, in which case the answer may well be yes.<br></p><p>&gt; <br>&gt; Moreover, an ad-hoc &quot;String | Int&quot; may look like a union type, but until switching over an instance to cast it, you can&#39;t invoke any methods common to String and Int. So it really doesn&#39;t feel like a union type at all.<br></p><p>I am less convinced of the value of duck-typing, âprotocol-likeâ unions that allow you to access common members than I am of the value of having lightweight syntax for enums that are really just wrappers around a set of possible types.<br></p><p>For the sake of discussion, lets say we adopt the âsyntactic sugar over enumsâ approach here.  In cases where accessing common members is really important it will still be possible.<br></p><p>// Remember, `Foo | Bar` is syntactic sugar for a type like `enum FooBar`, but the actual name is anonymous.<br>extension Foo | Bar {<br>    func commonMember() {<br>        switch self {<br>        case let foo as Foo: foo.commonMember()<br>        case let bar as Bar: bar.commonMember()<br>        }<br>    }<br>}<br></p><p>Granted, this is boilerplate.  But that is maybe a good thing.  It will guide people away from abusing this as a duck-typed alternative to real protocols.  When you need access to the common members you probably *should* be using a protocol instead.<br></p><p>&gt; <br>&gt; Don&#39;t get me wrong--like Brent, I&#39;m not convinced I see a scenario in which union types would help write clearly better code, just code that is more &quot;convenient&quot; in the eyes of the beholder. But ad-hoc enums have had their day on this list, and I&#39;m not sure that re-visiting that discussion is going to be very fruitful.<br></p><p>There have been several discussions around ad-hoc enums and union types.  I donât recall seeing any of them specifically focused on lightweight syntax layered over enums.  I *think* this approach avoids many of the reasons the core team has been opposed unions by not exposing any members directly - all you can do with these âunionsâ is pattern match to extract the payload.<br></p><p>I would like to see a discussion of something along these lines happen down the road when the time is right.<br></p><p>As I noted in reply to Brent, adding the ability to implicitly lift cases would be sufficient for the use cases I am aware of right now.  I would be satisfied if we made that change and no other.  But it would always feel like something that is crying out for a bit more syntactic sugar (coming up with names for some of these enums would be awkward - `Foo | Bar` is really what we want and `enum FooOrBar` just obscures the intent).<br></p><p>&gt; <br>&gt; In any case, this all seems very, very out of scope for Swift 4.<br></p><p>I agree with this, certainly for phase 1 in any case.  I donât want to push a distracting discussion right now.  I just wanted to respond to Brent with my thoughts.<br></p><p>&gt; <br>&gt; <br>&gt; On Fri, Aug 19, 2016 at 9:07 AM Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Aug 19, 2016, at 1:20 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On Aug 18, 2016, at 2:05 AM, Maximilian HÃ¼nenberger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; While purpose of the types are clear in this case there is not only intersection. I also want to find out the distance between different GeometryTypes and other properties like angels between two lines or a Line and a Plane but this doesn&#39;t make sense for a Point and some other GeometryType.<br>&gt; &gt;<br>&gt; &gt; But there are extremely complicated interactions between different pairs of types:<br>&gt; &gt;<br>&gt; &gt;       Line.intersection(with: Line) -&gt; Void | Point | Line<br>&gt; &gt;       Line.intersection(with: Circle) -&gt; Void | Point | (Point, Point)<br>&gt; &gt;       Line.intersection(with: Polygon) -&gt; [Point | Line]<br>&gt; &gt;<br>&gt; &gt;       Circle.intersection(with: Line) -&gt; Void | Point | Line<br>&gt; &gt;       Circle.intersection(with: Circle) -&gt; Void | Point | (Point, Point) | Circle<br>&gt; &gt;       Circle.intersection(with: Polygon) -&gt; [Point | (Point, Point)]<br>&gt; &gt;<br>&gt; &gt;       Polygon.intersection(with: Line) -&gt; [Point | Line]<br>&gt; &gt;       Polygon.intersection(with: Circle) -&gt; [Point | (Point, Point)]<br>&gt; &gt;       Polygon.intersection(with: Polygon) -&gt; [Point | Line] | Polygon<br>&gt; &gt;<br>&gt; &gt; What exactly are you planning to do with a `[Point | Line] | Polygon`? Honestly, your only real option is to test it for specific subtypes and try to use them. But there&#39;s already a type for that kind of thing: an enum. Enums are better for this application because they lend more structure and allow you to explain cases with descriptive labels:<br>&gt; &gt;<br>&gt; &gt;       enum PossiblyCoincidental&lt;CoincidentalType, IntersectingType&gt; {<br>&gt; &gt;               case coincidental (CoincidentalType)<br>&gt; &gt;               case intersecting (IntersectingType)<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt;       typealias LineIntersection = PossiblyCoincidental&lt;Line, Point&gt;<br>&gt; &gt;<br>&gt; &gt;       enum CircleIntersection {<br>&gt; &gt;               case tangent (Point)<br>&gt; &gt;               case secant (Point, Point)<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt;       Line.intersection(with: Line) -&gt; LineIntersection?<br>&gt; &gt;       Line.intersection(with: Circle) -&gt; CircleIntersection?<br>&gt; &gt;       Line.intersection(with: Polygon) -&gt; [LineIntersection]<br>&gt; &gt;<br>&gt; &gt;       Circle.intersection(with: Line) -&gt; CircleIntersection?<br>&gt; &gt;       Circle.intersection(with: Circle) -&gt; PossiblyCoincidental&lt;Circle, CircleIntersection&gt;?<br>&gt; &gt;       Circle.intersection(with: Polygon) -&gt; [CircleIntersection]<br>&gt; &gt;<br>&gt; &gt;       Polygon.intersection(with: Line) -&gt; [LineIntersection]<br>&gt; &gt;       Polygon.intersection(with: Circle) -&gt; [CircleIntersection]<br>&gt; &gt;       Polygon.intersection(with: Polygon) -&gt; PossiblyCoincidental&lt;Polygon, [LineIntersection]&gt;<br>&gt; &gt;<br>&gt; &gt; This is more complicated, but it&#39;s also a lot clearer about what each return type actually means. The existence of rich type information also helps you add functionality:<br>&gt; &gt;<br>&gt; &gt;       protocol IntersectionType {<br>&gt; &gt;               var isEmpty: Bool { get }<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt;       extension CircleIntersection: IntersectionType {<br>&gt; &gt;               var isEmpty: Bool { return false }<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt;       extension PossiblyCoincidental: IntersectionType {<br>&gt; &gt;               var isEmpty: Bool: { return false }<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt;       // Cascade inward if IntersectingType happens to itself be an intersection.<br>&gt; &gt;       extension PossiblyCoincidental where IntersectingType: IntersectionType {<br>&gt; &gt;               var isEmpty: Bool {<br>&gt; &gt;                       switch self {<br>&gt; &gt;                       case .coincidental:<br>&gt; &gt;                               return false<br>&gt; &gt;                       case .intersecting(let intersection):<br>&gt; &gt;                               return intersection.isEmpty<br>&gt; &gt;                       }<br>&gt; &gt;               }<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt;       // Note: Using future conditional conformances<br>&gt; &gt;       extension Optional: IntersectionType where Wrapped: IntersectionType {<br>&gt; &gt;               var isEmpty: Bool {<br>&gt; &gt;                       return map { $0.isEmpty } ?? true<br>&gt; &gt;               }<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt;       // Retroactive modeling yay!<br>&gt; &gt;       extension Array: IntersectionType where Element: IntersectionType {}<br>&gt; &gt;<br>&gt; &gt; Of course, it might be the case that this is *way* more information than you really need, and you just want to say:<br>&gt; &gt;<br>&gt; &gt;       GeometricElement.intersection(with: GeometricElement) -&gt; [GeometricElement]<br>&gt; &gt;<br>&gt; &gt; But if you want something simple and uniform, you probably don&#39;t want the complex `Void | Point | Line`-type stuff, either. Union types are neither simple and uniform, nor complex and descriptive; they are neither fish nor fowl. I just don&#39;t see a strong reason to prefer them here.<br>&gt; &gt;<br>&gt; &gt;       * * *<br>&gt; &gt;<br>&gt; &gt; I&#39;ll ask again what I think has been the crux of this argument from the beginning, and what hasn&#39;t really been satisfactorily answered in several months of discussions.<br>&gt; &gt;<br>&gt; &gt; **What use cases are better served by union types than by the alternatives?**<br>&gt; &gt;<br>&gt; &gt; Can you show us code where union types are clearly betterânot just shorterâthan an equivalent design based on (depending on the need) protocols, enums, or overloading? What about with minor extensions to these features, like closed protocols (allowing for exhaustive checking of protocol types) or implicit type lifting for enums (allowing you to avoid explicitly constructing the case you need, as Optional.some does)?<br>&gt; <br>&gt; I think implicit lifting with some additional syntactic sugar would be a very good solution here.<br>&gt; <br>&gt; First, an example of an enum with implicit lifting (using the strawman `autolift` modifier which conservatively could be restricted to cases with a single associated value and could not be used on cases with associated values whose type is also the type of an associated value in another case):<br>&gt; <br>&gt; enum Foo {<br>&gt;     autolift case .string(String)<br>&gt;     autolift case .int(Int)<br>&gt;     // etc<br>&gt; }<br>&gt; <br>&gt; func bar(_ foos: [Foo]) {}<br>&gt; <br>&gt; // âa stringâ is implicitly lifted to be .string(âa stringâ) and 42 is implicitly lifted to be .int(42)<br>&gt; bar([âa stringâ, 42])<br>&gt; <br>&gt; This would solve the use case I have run into where I was working on a library design and wanted to accept a heterogeneous collection without requiring callers to have any knowledge beyond what types can be uses (i.e. I donât want them to have to deal with the syntactic noise of manual lifting, but more importantly I would consider an enum like this an implementation detail, not something users should really rely on).<br>&gt; <br>&gt; If we *are* going to support implicit lifting like this, why not also adopt syntactic sugar for creating / referencing them in an ad-hoc manner?  Rather than writing out the enum above, we could just declare:<br>&gt; <br>&gt; func bar(_ foos: [String | Int]) {}<br>&gt; <br>&gt; The enum would be created âon demandâ each time a distinct set of types was referenced, with implicit lifting for each case.  What is the downside of this syntactic sugar?  It would bring the âlightweightâ feel of union types to Swift while retaining the semantics of enums.  This feels like a nice middle ground to me.<br>&gt; <br>&gt; As you mention, closed protocols are another possible solution to the design problem I was working on, although it is somewhat less elegant as it would add conformances to the underlying types which is not necessarily desirable.<br>&gt; <br>&gt; &gt;<br>&gt; &gt; There is clearly overlap between union types and some of our other features. When do you expect people would use each feature? Are there other languages which support both union types and sum types (i.e. Swift `enum`s)? When do they use each of these?<br>&gt; &gt;<br>&gt; &gt; (Incidentally, even if we had union types, I don&#39;t think we&#39;d want to change Optional&#39;s definition. Nested optionals are a bit confusing at times, but they&#39;re important for correctness in many cases, like collections of Optionals. If Optional is a union type, you also lose the opportunity to have operations like `map` and `flatMap` on it.)<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160819/18a323e7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>August 20, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On 19 Aug 2016, at 15:38, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Ad-hoc enums have been discussed already, at length, and all the weaknesses touched on then still apply now. For instance, since they&#39;re ad-hoc, can you pass an instance of type &quot;Int | String&quot; as an argument if the function expects a &quot;String | Int | Float&quot;? Enums don&#39;t have duck typing behavior like that; if your ad-hoc type does, then it&#39;s not very much like an enum; if it doesn&#39;t, it won&#39;t feel much like a union type.<br></p><p>While ad-hoc enums are certainly similar I don&#39;t think that this problem applies to unions; the problem with ad-hoc enums is that while cases may have the same name, the meaning of a case may not be identical, so compatibility is uncertain. For type unions I&#39;d say this isn&#39;t an issue; I&#39;d say that yes, String | Int is compatible with String | Int | Float as every possible value can be carried over (whereas the reverse is not true), they&#39;re just values of one of several types, so as long as the conversion is possible, it should be fine to pass it on (or rather, repackage it behind the scenes).<br></p><p>&gt; Moreover, an ad-hoc &quot;String | Int&quot; may look like a union type, but until switching over an instance to cast it, you can&#39;t invoke any methods common to String and Int. So it really doesn&#39;t feel like a union type at all.<br></p><p>Could it not do that though? I&#39;d say that a union type should conform to any common protocols that its members conform to; if this can be done in the initial release then great, otherwise it can come later.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>August 20, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Aug 20, 2016, at 10:36, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 19 Aug 2016, at 15:38, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Ad-hoc enums have been discussed already, at length, and all the weaknesses touched on then still apply now. For instance, since they&#39;re ad-hoc, can you pass an instance of type &quot;Int | String&quot; as an argument if the function expects a &quot;String | Int | Float&quot;? Enums don&#39;t have duck typing behavior like that; if your ad-hoc type does, then it&#39;s not very much like an enum; if it doesn&#39;t, it won&#39;t feel much like a union type.<br>&gt; <br>&gt; While ad-hoc enums are certainly similar I don&#39;t think that this problem applies to unions; the problem with ad-hoc enums is that while cases may have the same name, the meaning of a case may not be identical, so compatibility is uncertain. For type unions I&#39;d say this isn&#39;t an issue; I&#39;d say that yes, String | Int is compatible with String | Int | Float as every possible value can be carried over (whereas the reverse is not true), they&#39;re just values of one of several types, so as long as the conversion is possible, it should be fine to pass it on (or rather, repackage it behind the scenes).<br>&gt; <br>&gt;&gt; Moreover, an ad-hoc &quot;String | Int&quot; may look like a union type, but until switching over an instance to cast it, you can&#39;t invoke any methods common to String and Int. So it really doesn&#39;t feel like a union type at all.<br>&gt; <br>&gt; Could it not do that though? I&#39;d say that a union type should conform to any common protocols that its members conform to; if this can be done in the initial release then great, otherwise it can come later.<br></p><p>This exact scenario came up in the context of iterating over the members of a heterogeneous tuple. If I wasn&#39;t on my phone, I&#39;d find a link to the relevant posts, but IIRC the gist of it is (my wording) &quot;it doesn&#39;t work that way&quot;, or at least not without a *lot* of work and a high load on the type-checker.<br></p><p>- Dave Sweeris<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>August 20, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Aug 20, 2016, at 10:36 AM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 19 Aug 2016, at 15:38, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Ad-hoc enums have been discussed already, at length, and all the weaknesses touched on then still apply now. For instance, since they&#39;re ad-hoc, can you pass an instance of type &quot;Int | String&quot; as an argument if the function expects a &quot;String | Int | Float&quot;? Enums don&#39;t have duck typing behavior like that; if your ad-hoc type does, then it&#39;s not very much like an enum; if it doesn&#39;t, it won&#39;t feel much like a union type.<br>&gt; <br>&gt; While ad-hoc enums are certainly similar I don&#39;t think that this problem applies to unions; the problem with ad-hoc enums is that while cases may have the same name, the meaning of a case may not be identical, so compatibility is uncertain. For type unions I&#39;d say this isn&#39;t an issue; I&#39;d say that yes, String | Int is compatible with String | Int | Float as every possible value can be carried over (whereas the reverse is not true), they&#39;re just values of one of several types, so as long as the conversion is possible, it should be fine to pass it on (or rather, repackage it behind the scenes).<br>&gt; <br>&gt;&gt; Moreover, an ad-hoc &quot;String | Int&quot; may look like a union type, but until switching over an instance to cast it, you can&#39;t invoke any methods common to String and Int. So it really doesn&#39;t feel like a union type at all.<br>&gt; <br>&gt; Could it not do that though? I&#39;d say that a union type should conform to any common protocols that its members conform to; if this can be done in the initial release then great, otherwise it can come later.<br></p><p>Conforming to common protocols would be much better than an implicit ad-hoc / duck-typed protocol that simply exposes all common members.  But there is strong opposition to unions, much of which is related to implementation complexity.  It seems to me that the path to having unions or a union-ish feature receiving serious consideration is to demonstrate the value they can offer even with relatively restricted functionality (such as syntactic sugar for enums with implicit lifting).  If that is successful we will have an opportunity to work with them and make a case for enhancements in the future.<br></p><p>Also, it won&#39;t always possible for a union to conform to a protocol conformed to by all member types.  If the protocol has `Self` requirements in argument position it would not be able to conform and if it has associated type requirements which are bound to different concrete types in the types making up the union it would also not be able to conform.<br></p><p>Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 20, 2016 at 05:00:00pm</p></header><div class="content"><p>Maybe I&#39;m not getting something. But if you only want T | U | V to expose<br>members required by common protocols P, Q, and R, since you know the types<br>at compile time, you also know the common protocols. Why wouldn&#39;t you just<br>write P &amp; Q &amp; R, and if necessary precondition(x is T || x is U || x is V)?<br>On Sat, Aug 20, 2016 at 12:35 Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; &gt; On Aug 20, 2016, at 10:36 AM, Haravikk &lt;swift-evolution at haravikk.me&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On 19 Aug 2016, at 15:38, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Ad-hoc enums have been discussed already, at length, and all the<br>&gt; weaknesses touched on then still apply now. For instance, since they&#39;re<br>&gt; ad-hoc, can you pass an instance of type &quot;Int | String&quot; as an argument if<br>&gt; the function expects a &quot;String | Int | Float&quot;? Enums don&#39;t have duck typing<br>&gt; behavior like that; if your ad-hoc type does, then it&#39;s not very much like<br>&gt; an enum; if it doesn&#39;t, it won&#39;t feel much like a union type.<br>&gt; &gt;<br>&gt; &gt; While ad-hoc enums are certainly similar I don&#39;t think that this problem<br>&gt; applies to unions; the problem with ad-hoc enums is that while cases may<br>&gt; have the same name, the meaning of a case may not be identical, so<br>&gt; compatibility is uncertain. For type unions I&#39;d say this isn&#39;t an issue;<br>&gt; I&#39;d say that yes, String | Int is compatible with String | Int | Float as<br>&gt; every possible value can be carried over (whereas the reverse is not true),<br>&gt; they&#39;re just values of one of several types, so as long as the conversion<br>&gt; is possible, it should be fine to pass it on (or rather, repackage it<br>&gt; behind the scenes).<br>&gt; &gt;<br>&gt; &gt;&gt; Moreover, an ad-hoc &quot;String | Int&quot; may look like a union type, but<br>&gt; until switching over an instance to cast it, you can&#39;t invoke any methods<br>&gt; common to String and Int. So it really doesn&#39;t feel like a union type at<br>&gt; all.<br>&gt; &gt;<br>&gt; &gt; Could it not do that though? I&#39;d say that a union type should conform to<br>&gt; any common protocols that its members conform to; if this can be done in<br>&gt; the initial release then great, otherwise it can come later.<br>&gt;<br>&gt; Conforming to common protocols would be much better than an implicit<br>&gt; ad-hoc / duck-typed protocol that simply exposes all common members.  But<br>&gt; there is strong opposition to unions, much of which is related to<br>&gt; implementation complexity.  It seems to me that the path to having unions<br>&gt; or a union-ish feature receiving serious consideration is to demonstrate<br>&gt; the value they can offer even with relatively restricted functionality<br>&gt; (such as syntactic sugar for enums with implicit lifting).  If that is<br>&gt; successful we will have an opportunity to work with them and make a case<br>&gt; for enhancements in the future.<br>&gt;<br>&gt; Also, it won&#39;t always possible for a union to conform to a protocol<br>&gt; conformed to by all member types.  If the protocol has `Self` requirements<br>&gt; in argument position it would not be able to conform and if it has<br>&gt; associated type requirements which are bound to different concrete types in<br>&gt; the types making up the union it would also not be able to conform.<br>&gt;<br>&gt; Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160820/4793ca86/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>August 20, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Aug 20, 2016, at 12:27 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Maybe I&#39;m not getting something. But if you only want T | U | V to expose members required by common protocols P, Q, and R, since you know the types at compile time, you also know the common protocols. Why wouldn&#39;t you just write P &amp; Q &amp; R, and if necessary precondition(x is T || x is U || x is V)?<br></p><p>This isnât something I personally was advocating for (in fact I specifically suggested *not* proposing this would be a better strategy for receiving serious consideration of something union-ish).<br></p><p>However, if we *did* do something like this it would provide a static verification that the precondition is met while still exposing the members of the common protocol(s) directly.  That is substantially better than runtime verification of the precondition or the boilerplate necessary to expose provide forwarding members.<br></p><p>My personal interest in something union-ish is really along the lines of syntactic sugar for enums.<br></p><p>Rather than writing this:<br></p><p>enum StringOrIntOrBool {<br>    case .string(String)<br>    case .int(Int)<br>    case .bool(Bool)<br>}<br></p><p>func foo(values: [StringOrIntOrBool]) {}<br></p><p>foo([.string(âhelloâ), .int(42)])<br></p><p><br>I would prefer to just write:<br></p><p>func foo(values: String | Int | Bool) {}<br></p><p>foo([âhelloâ, 42])<br></p><p><br>The use case for this I found is in designing DSLs of various kinds where you need to accept a heterogenous collection of a specific fixed list of concrete types.  The primary concern is to have static verification of the possible values provided by the caller without requiring callers to manually instantiate cases and without polluting the member types with unwanted conformance to a single-use protocol (which would be an alternative if we get sealed protocols).<br></p><p>If we add automatic lifting as Brent suggested that solves the primary concern I have.  If we do add that, introducing the union-like notation would make sense as convenient syntactic sugar for use in these scenarios where the sugar states the intent more clearly and concisely than something a contrived name like `StringOrIntOrBool`.  But as I have already stated, that is as secondary concern and automatic lifting alone would solve the primary (call site / library user) concern.<br></p><p>Matthew<br></p><p>&gt; On Sat, Aug 20, 2016 at 12:35 Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Aug 20, 2016, at 10:36 AM, Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On 19 Aug 2016, at 15:38, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Ad-hoc enums have been discussed already, at length, and all the weaknesses touched on then still apply now. For instance, since they&#39;re ad-hoc, can you pass an instance of type &quot;Int | String&quot; as an argument if the function expects a &quot;String | Int | Float&quot;? Enums don&#39;t have duck typing behavior like that; if your ad-hoc type does, then it&#39;s not very much like an enum; if it doesn&#39;t, it won&#39;t feel much like a union type.<br>&gt; &gt;<br>&gt; &gt; While ad-hoc enums are certainly similar I don&#39;t think that this problem applies to unions; the problem with ad-hoc enums is that while cases may have the same name, the meaning of a case may not be identical, so compatibility is uncertain. For type unions I&#39;d say this isn&#39;t an issue; I&#39;d say that yes, String | Int is compatible with String | Int | Float as every possible value can be carried over (whereas the reverse is not true), they&#39;re just values of one of several types, so as long as the conversion is possible, it should be fine to pass it on (or rather, repackage it behind the scenes).<br>&gt; &gt;<br>&gt; &gt;&gt; Moreover, an ad-hoc &quot;String | Int&quot; may look like a union type, but until switching over an instance to cast it, you can&#39;t invoke any methods common to String and Int. So it really doesn&#39;t feel like a union type at all.<br>&gt; &gt;<br>&gt; &gt; Could it not do that though? I&#39;d say that a union type should conform to any common protocols that its members conform to; if this can be done in the initial release then great, otherwise it can come later.<br>&gt; <br>&gt; Conforming to common protocols would be much better than an implicit ad-hoc / duck-typed protocol that simply exposes all common members.  But there is strong opposition to unions, much of which is related to implementation complexity.  It seems to me that the path to having unions or a union-ish feature receiving serious consideration is to demonstrate the value they can offer even with relatively restricted functionality (such as syntactic sugar for enums with implicit lifting).  If that is successful we will have an opportunity to work with them and make a case for enhancements in the future.<br>&gt; <br>&gt; Also, it won&#39;t always possible for a union to conform to a protocol conformed to by all member types.  If the protocol has `Self` requirements in argument position it would not be able to conform and if it has associated type requirements which are bound to different concrete types in the types making up the union it would also not be able to conform.<br>&gt; <br>&gt; Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160820/96267255/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 20, 2016 at 06:00:00pm</p></header><div class="content"><p>That&#39;s good information. I guess a partly implied question which I&#39;m not<br>entirely sure of would be:<br></p><p>What are the scenarios you&#39;ve encountered where it actually matters that an<br>algorithm that works with any P &amp; Q &amp; R must ensure that the argument is<br>one of a fixed list of concrete types?<br></p><p>Examples of String, Int, Bool call to mind JSON parsing, but in that<br>scenario I&#39;d expect the fixed list of concrete types would be a constraint<br>of the parsing logic long before you get to any algorithm that operates on<br>a P &amp; Q &amp; R.<br>On Sat, Aug 20, 2016 at 14:09 Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt; On Aug 20, 2016, at 12:27 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; Maybe I&#39;m not getting something. But if you only want T | U | V to expose<br>&gt; members required by common protocols P, Q, and R, since you know the types<br>&gt; at compile time, you also know the common protocols. Why wouldn&#39;t you just<br>&gt; write P &amp; Q &amp; R, and if necessary precondition(x is T || x is U || x is V)?<br>&gt;<br>&gt;<br>&gt; This isnât something I personally was advocating for (in fact I<br>&gt; specifically suggested *not* proposing this would be a better strategy for<br>&gt; receiving serious consideration of something union-ish).<br>&gt;<br>&gt; However, if we *did* do something like this it would provide a static<br>&gt; verification that the precondition is met while still exposing the members<br>&gt; of the common protocol(s) directly.  That is substantially better than<br>&gt; runtime verification of the precondition or the boilerplate necessary to<br>&gt; expose provide forwarding members.<br>&gt;<br>&gt; My personal interest in something union-ish is really along the lines of<br>&gt; syntactic sugar for enums.<br>&gt;<br>&gt; Rather than writing this:<br>&gt;<br>&gt; enum StringOrIntOrBool {<br>&gt;     case .string(String)<br>&gt;     case .int(Int)<br>&gt;     case .bool(Bool)<br>&gt; }<br>&gt;<br>&gt; func foo(values: [StringOrIntOrBool]) {}<br>&gt;<br>&gt; foo([.string(âhelloâ), .int(42)])<br>&gt;<br>&gt;<br>&gt; I would prefer to just write:<br>&gt;<br>&gt; func foo(values: String | Int | Bool) {}<br>&gt;<br>&gt; foo([âhelloâ, 42])<br>&gt;<br>&gt;<br>&gt; The use case for this I found is in designing DSLs of various kinds where<br>&gt; you need to accept a heterogenous collection of a specific fixed list of<br>&gt; concrete types.  The primary concern is to have static verification of the<br>&gt; possible values provided by the caller without requiring callers to<br>&gt; manually instantiate cases and without polluting the member types with<br>&gt; unwanted conformance to a single-use protocol (which would be an<br>&gt; alternative if we get sealed protocols).<br>&gt;<br>&gt; If we add automatic lifting as Brent suggested that solves the primary<br>&gt; concern I have.  If we do add that, introducing the union-like notation<br>&gt; would make sense as convenient syntactic sugar for use in these scenarios<br>&gt; where the sugar states the intent more clearly and concisely than something<br>&gt; a contrived name like `StringOrIntOrBool`.  But as I have already stated,<br>&gt; that is as secondary concern and automatic lifting alone would solve the<br>&gt; primary (call site / library user) concern.<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt; On Sat, Aug 20, 2016 at 12:35 Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Aug 20, 2016, at 10:36 AM, Haravikk &lt;swift-evolution at haravikk.me&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On 19 Aug 2016, at 15:38, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Ad-hoc enums have been discussed already, at length, and all the<br>&gt;&gt; weaknesses touched on then still apply now. For instance, since they&#39;re<br>&gt;&gt; ad-hoc, can you pass an instance of type &quot;Int | String&quot; as an argument if<br>&gt;&gt; the function expects a &quot;String | Int | Float&quot;? Enums don&#39;t have duck typing<br>&gt;&gt; behavior like that; if your ad-hoc type does, then it&#39;s not very much like<br>&gt;&gt; an enum; if it doesn&#39;t, it won&#39;t feel much like a union type.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; While ad-hoc enums are certainly similar I don&#39;t think that this<br>&gt;&gt; problem applies to unions; the problem with ad-hoc enums is that while<br>&gt;&gt; cases may have the same name, the meaning of a case may not be identical,<br>&gt;&gt; so compatibility is uncertain. For type unions I&#39;d say this isn&#39;t an issue;<br>&gt;&gt; I&#39;d say that yes, String | Int is compatible with String | Int | Float as<br>&gt;&gt; every possible value can be carried over (whereas the reverse is not true),<br>&gt;&gt; they&#39;re just values of one of several types, so as long as the conversion<br>&gt;&gt; is possible, it should be fine to pass it on (or rather, repackage it<br>&gt;&gt; behind the scenes).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Moreover, an ad-hoc &quot;String | Int&quot; may look like a union type, but<br>&gt;&gt; until switching over an instance to cast it, you can&#39;t invoke any methods<br>&gt;&gt; common to String and Int. So it really doesn&#39;t feel like a union type at<br>&gt;&gt; all.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Could it not do that though? I&#39;d say that a union type should conform<br>&gt;&gt; to any common protocols that its members conform to; if this can be done in<br>&gt;&gt; the initial release then great, otherwise it can come later.<br>&gt;&gt;<br>&gt;&gt; Conforming to common protocols would be much better than an implicit<br>&gt;&gt; ad-hoc / duck-typed protocol that simply exposes all common members.  But<br>&gt;&gt; there is strong opposition to unions, much of which is related to<br>&gt;&gt; implementation complexity.  It seems to me that the path to having unions<br>&gt;&gt; or a union-ish feature receiving serious consideration is to demonstrate<br>&gt;&gt; the value they can offer even with relatively restricted functionality<br>&gt;&gt; (such as syntactic sugar for enums with implicit lifting).  If that is<br>&gt;&gt; successful we will have an opportunity to work with them and make a case<br>&gt;&gt; for enhancements in the future.<br>&gt;&gt;<br>&gt;&gt; Also, it won&#39;t always possible for a union to conform to a protocol<br>&gt;&gt; conformed to by all member types.  If the protocol has `Self` requirements<br>&gt;&gt; in argument position it would not be able to conform and if it has<br>&gt;&gt; associated type requirements which are bound to different concrete types in<br>&gt;&gt; the types making up the union it would also not be able to conform.<br>&gt;&gt;<br>&gt;&gt; Matthew<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160820/a0b33039/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>August 20, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Aug 20, 2016, at 1:29 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; That&#39;s good information. I guess a partly implied question which I&#39;m not entirely sure of would be:<br>&gt; <br>&gt; What are the scenarios you&#39;ve encountered where it actually matters that an algorithm that works with any P &amp; Q &amp; R must ensure that the argument is one of a fixed list of concrete types?<br>&gt; <br>&gt; Examples of String, Int, Bool call to mind JSON parsing, but in that scenario I&#39;d expect the fixed list of concrete types would be a constraint of the parsing logic long before you get to any algorithm that operates on a P &amp; Q &amp; R.<br></p><p>I was simply responding to Haravikk offering some information on the inherent limitations of unions conforming to common protocols as well as my thought that it probably isnât something to push for if we do officially revisit the topic of a union-like feature.<br></p><p>Nothing in my use case involves protocols at all!  It is strictly defined in terms of the concrete types that are acceptable.  String, Int, and Bool were picked arbitrarily for discussion.  The specific context where I was experimenting with a DSL like this was a view configuration DSL where the types of supported child views are restricted to a specific list of concrete view types.  But this same pattern could be applied to many DSLs that accept hierarchical configuration where some nodes would want to restrict the type of their children.  I might be possible to build a JSON parsing DSL using techniques like this although I have not attempted to do that.<br></p><p>&gt; On Sat, Aug 20, 2016 at 14:09 Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; On Aug 20, 2016, at 12:27 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Maybe I&#39;m not getting something. But if you only want T | U | V to expose members required by common protocols P, Q, and R, since you know the types at compile time, you also know the common protocols. Why wouldn&#39;t you just write P &amp; Q &amp; R, and if necessary precondition(x is T || x is U || x is V)?<br>&gt; <br>&gt; This isnât something I personally was advocating for (in fact I specifically suggested *not* proposing this would be a better strategy for receiving serious consideration of something union-ish).<br>&gt; <br>&gt; However, if we *did* do something like this it would provide a static verification that the precondition is met while still exposing the members of the common protocol(s) directly.  That is substantially better than runtime verification of the precondition or the boilerplate necessary to expose provide forwarding members.<br>&gt; <br>&gt; My personal interest in something union-ish is really along the lines of syntactic sugar for enums.<br>&gt; <br>&gt; Rather than writing this:<br>&gt; <br>&gt; enum StringOrIntOrBool {<br>&gt;     case .string(String)<br>&gt;     case .int(Int)<br>&gt;     case .bool(Bool)<br>&gt; }<br>&gt; <br>&gt; func foo(values: [StringOrIntOrBool]) {}<br>&gt; <br>&gt; foo([.string(âhelloâ), .int(42)])<br>&gt; <br>&gt; <br>&gt; I would prefer to just write:<br>&gt; <br>&gt; func foo(values: String | Int | Bool) {}<br>&gt; <br>&gt; foo([âhelloâ, 42])<br>&gt; <br>&gt; <br>&gt; The use case for this I found is in designing DSLs of various kinds where you need to accept a heterogenous collection of a specific fixed list of concrete types.  The primary concern is to have static verification of the possible values provided by the caller without requiring callers to manually instantiate cases and without polluting the member types with unwanted conformance to a single-use protocol (which would be an alternative if we get sealed protocols).<br>&gt; <br>&gt; If we add automatic lifting as Brent suggested that solves the primary concern I have.  If we do add that, introducing the union-like notation would make sense as convenient syntactic sugar for use in these scenarios where the sugar states the intent more clearly and concisely than something a contrived name like `StringOrIntOrBool`.  But as I have already stated, that is as secondary concern and automatic lifting alone would solve the primary (call site / library user) concern.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt;&gt; On Sat, Aug 20, 2016 at 12:35 Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; On Aug 20, 2016, at 10:36 AM, Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On 19 Aug 2016, at 15:38, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Ad-hoc enums have been discussed already, at length, and all the weaknesses touched on then still apply now. For instance, since they&#39;re ad-hoc, can you pass an instance of type &quot;Int | String&quot; as an argument if the function expects a &quot;String | Int | Float&quot;? Enums don&#39;t have duck typing behavior like that; if your ad-hoc type does, then it&#39;s not very much like an enum; if it doesn&#39;t, it won&#39;t feel much like a union type.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; While ad-hoc enums are certainly similar I don&#39;t think that this problem applies to unions; the problem with ad-hoc enums is that while cases may have the same name, the meaning of a case may not be identical, so compatibility is uncertain. For type unions I&#39;d say this isn&#39;t an issue; I&#39;d say that yes, String | Int is compatible with String | Int | Float as every possible value can be carried over (whereas the reverse is not true), they&#39;re just values of one of several types, so as long as the conversion is possible, it should be fine to pass it on (or rather, repackage it behind the scenes).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Moreover, an ad-hoc &quot;String | Int&quot; may look like a union type, but until switching over an instance to cast it, you can&#39;t invoke any methods common to String and Int. So it really doesn&#39;t feel like a union type at all.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Could it not do that though? I&#39;d say that a union type should conform to any common protocols that its members conform to; if this can be done in the initial release then great, otherwise it can come later.<br>&gt;&gt; <br>&gt;&gt; Conforming to common protocols would be much better than an implicit ad-hoc / duck-typed protocol that simply exposes all common members.  But there is strong opposition to unions, much of which is related to implementation complexity.  It seems to me that the path to having unions or a union-ish feature receiving serious consideration is to demonstrate the value they can offer even with relatively restricted functionality (such as syntactic sugar for enums with implicit lifting).  If that is successful we will have an opportunity to work with them and make a case for enhancements in the future.<br>&gt;&gt; <br>&gt;&gt; Also, it won&#39;t always possible for a union to conform to a protocol conformed to by all member types.  If the protocol has `Self` requirements in argument position it would not be able to conform and if it has associated type requirements which are bound to different concrete types in the types making up the union it would also not be able to conform.<br>&gt;&gt; <br>&gt;&gt; Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160820/cdf874cf/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>August 19, 2016 at 08:00:00am</p></header><div class="content"><p>I&#39;m a +1 for union types.<br></p><p>My main reason for wanting it is to eliminate (some) function overloads; behind the scenes the compiler may still produce one compiled function per union type (for performance), but at a high level we only need to worry about one implementation, and one call signature, which I think is a good thing.<br></p><p>&gt; On 11 Aug 2016, at 02:28, Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; I want to make a discussion about union type for swift 4.<br>&gt; See https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md &lt;https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md&gt;<br>&gt; <br>&gt; Add union type grammar, represents the type which is one of other types.<br>&gt; <br>&gt; var stringOrURL: String | URL = &quot;https://www.apple.com &lt;https://www.apple.com/&gt;&quot;<br>&gt; Now, if we using the new union type feature, we can declare type conveniently, No other type declaration, and compiler will automatically calculate the common interface.<br>&gt; <br>&gt; func input(value: A | B | C) {<br>&gt;     print(value.commonProperty) // type checker will calculate the common interface, developer just use it out of box<br>&gt;     switch value {<br>&gt;     case let value as A:<br>&gt;         // value is type A<br>&gt;         print(value.propertyInA)<br>&gt;     case let value as B:<br>&gt;         // value is type B<br>&gt;         print(value.propertyInB)<br>&gt;     case let value as C:<br>&gt;         // value is type C<br>&gt;         print(value.propertyInC)<br>&gt;     }<br>&gt;     // there is no default case other than A, B or C. we already declared that.<br>&gt; }<br>&gt; Note: A, B, C can be either class or protocol, or any other types. This leaves developer more freedom.<br>&gt; <br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; This is a new feature, developer who need declare common type will alter to this new grammar.<br>&gt; Enum based version optional or IUO will be replaced by Union-based ones. Any optional type will automatically replaced by union type<br>&gt; <br>&gt;  &lt;https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md#detailed-design&gt;_______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160819/37090af7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 19, 2016 at 07:00:00am</p></header><div class="content"><p>But you can do that already with protocols, can&#39;t you?<br>On Fri, Aug 19, 2016 at 2:24 AM Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;m a +1 for union types.<br>&gt;<br>&gt; My main reason for wanting it is to eliminate (some) function overloads;<br>&gt; behind the scenes the compiler may still produce one compiled function per<br>&gt; union type (for performance), but at a high level we only need to worry<br>&gt; about one implementation, and one call signature, which I think is a good<br>&gt; thing.<br>&gt;<br>&gt; On 11 Aug 2016, at 02:28, Cao Jiannan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi all,<br>&gt;<br>&gt; I want to make a discussion about union type for swift 4.<br>&gt; See<br>&gt; https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md<br>&gt;<br>&gt; Add union type grammar, represents the type which is one of other types.<br>&gt;<br>&gt; var stringOrURL: String | URL = &quot;https://www.apple.com&quot;<br>&gt;<br>&gt; Now, if we using the new union type feature, we can declare type<br>&gt; conveniently, No other type declaration, and compiler will automatically<br>&gt; calculate the common interface.<br>&gt;<br>&gt; func input(value: A | B | C) {<br>&gt;     print(value.commonProperty) // type checker will calculate the common interface, developer just use it out of box<br>&gt;     switch value {<br>&gt;     case let value as A:<br>&gt;         // value is type A<br>&gt;         print(value.propertyInA)<br>&gt;     case let value as B:<br>&gt;         // value is type B<br>&gt;         print(value.propertyInB)<br>&gt;     case let value as C:<br>&gt;         // value is type C<br>&gt;         print(value.propertyInC)<br>&gt;     }<br>&gt;     // there is no default case other than A, B or C. we already declared that.<br>&gt; }<br>&gt;<br>&gt; Note: A, B, C can be either class or protocol, or any other types. This<br>&gt; leaves developer more freedom.<br>&gt;<br>&gt; Impact on existing code<br>&gt;<br>&gt;    - This is a new feature, developer who need declare common type will<br>&gt;    alter to this new grammar.<br>&gt;    - Enum based version optional or IUO will be replaced by Union-based<br>&gt;    ones. Any optional type will automatically replaced by union type<br>&gt;<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md#detailed-design&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160819/f0242c39/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>August 19, 2016 at 12:00:00pm</p></header><div class="content"><p>When dealing with your own types, sure, but if you&#39;re talking about standard types or types from other libraries then it would mean extending them with whatever it is you actually need, which I&#39;m not sure is the best way to do it. Type unions are much simpler, and keep all of the code within a single function.<br></p><p>To give a simplistic example, consider a method for adding a property to a property list file. I&#39;m going to trim this down considerably, but it&#39;ll give an idea hopefully:<br></p><p>	func addProperty(key:String, value:Int | String, file:NSFile) {<br>		var xml = &quot;&lt;key&gt;\(key)&lt;/key&gt;\n&quot;<br>		switch value {<br>			case value as Int:<br>				xml += &quot;&lt;number&gt;\(value)&lt;/number&gt;\n&quot;<br>			case value as String:<br>				xml += &quot;&lt;string&gt;\(value)&lt;/string&gt;\n&quot;<br>		}<br></p><p>		// Actually store the xml string in the file here<br>	}<br></p><p>Currently you might instead do this like:<br></p><p>	func addProperty(key:String, value:Int, file:NSFile) {<br>		addProperty(key: key, rawValue: &quot;&lt;number&gt;\(value)&lt;/number&gt;&quot;, file: file)<br>	}<br>	func addProperty(key:String, value:String, file:NSFile) {<br>		addProperty(key: key, rawValue: &quot;&lt;string&gt;\(value)&lt;/string&gt;&quot;, file: file)<br>	}<br>	func addProperty(key:String, rawValue:String, file:NSFile) {<br>		var xml = &quot;&lt;key&gt;\(key)&lt;/key&gt;\n\(rawValue\)\n&quot;<br>		// Actually store the xml string in the file here<br>	}<br></p><p>(apologies for typos, not at my main computer right now, this is just for illustration anyway)<br></p><p>Of course if I were doing a complex property list bridge I would extract some of this out, but if the above is all I need then IMO the union example is more convenient to work with, and produces less pollution of the addProperty signature, while the compiler can still optimise it out into separate functions (by eliminating the switch for each type).<br></p><p>I could alternatively use a protocol to add a .plistValue computed property to all plist compatible types, but again that seems like overkill, and moves the code out of my single function even though that may be all I really need, it also makes it less clear what all of those types are (without building docs to do so). Or I could use an enum, but again, for small use cases that can be a bit overkill, and isn&#39;t as convenient in cases that have similar, but different, union types.<br></p><p><br>Ultimately it&#39;s an issue of choice; not every case will be better using or not using union types, they&#39;re just a convenience that can benefit some cases. If you find yourself using the same union types a lot then, yes, probably time to think about a protocol or an enum, but that&#39;s a big step in simpler cases.<br></p><p>&gt; On 19 Aug 2016, at 08:42, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; But you can do that already with protocols, can&#39;t you?<br>&gt; On Fri, Aug 19, 2016 at 2:24 AM Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I&#39;m a +1 for union types.<br>&gt; <br>&gt; My main reason for wanting it is to eliminate (some) function overloads; behind the scenes the compiler may still produce one compiled function per union type (for performance), but at a high level we only need to worry about one implementation, and one call signature, which I think is a good thing.<br>&gt; <br>&gt;&gt; On 11 Aug 2016, at 02:28, Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; I want to make a discussion about union type for swift 4.<br>&gt;&gt; See https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md &lt;https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md&gt;<br>&gt;&gt; <br>&gt;&gt; Add union type grammar, represents the type which is one of other types.<br>&gt;&gt; <br>&gt;&gt; var stringOrURL: String | URL = &quot;https://www.apple.com &lt;https://www.apple.com/&gt;&quot;<br>&gt;&gt; Now, if we using the new union type feature, we can declare type conveniently, No other type declaration, and compiler will automatically calculate the common interface.<br>&gt;&gt; <br>&gt;&gt; func input(value: A | B | C) {<br>&gt;&gt;     print(value.commonProperty) // type checker will calculate the common interface, developer just use it out of box<br>&gt;&gt;     switch value {<br>&gt;&gt;     case let value as A:<br>&gt;&gt;         // value is type A<br>&gt;&gt;         print(value.propertyInA)<br>&gt;&gt;     case let value as B:<br>&gt;&gt;         // value is type B<br>&gt;&gt;         print(value.propertyInB)<br>&gt;&gt;     case let value as C:<br>&gt;&gt;         // value is type C<br>&gt;&gt;         print(value.propertyInC)<br>&gt;&gt;     }<br>&gt;&gt;     // there is no default case other than A, B or C. we already declared that.<br>&gt;&gt; }<br>&gt;&gt; Note: A, B, C can be either class or protocol, or any other types. This leaves developer more freedom.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This is a new feature, developer who need declare common type will alter to this new grammar.<br>&gt;&gt; Enum based version optional or IUO will be replaced by Union-based ones. Any optional type will automatically replaced by union type<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md#detailed-design&gt;_______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160819/76fcaa04/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>August 19, 2016 at 02:00:00pm</p></header><div class="content"><p>A union in C is a type overlay, not a type selector. The mechanism for what you propose would probably be implemented quite differently (maintaining type safety). As such I believe it should not be called a union as that can put people (with C experience) on the wrong feet. Suggestion: âImplicit Protocolsâ ?<br></p><p>Regards,<br>Rien.<br></p><p>&gt; On 19 Aug 2016, at 13:51, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; When dealing with your own types, sure, but if you&#39;re talking about standard types or types from other libraries then it would mean extending them with whatever it is you actually need, which I&#39;m not sure is the best way to do it. Type unions are much simpler, and keep all of the code within a single function.<br>&gt; <br>&gt; To give a simplistic example, consider a method for adding a property to a property list file. I&#39;m going to trim this down considerably, but it&#39;ll give an idea hopefully:<br>&gt; <br>&gt; 	func addProperty(key:String, value:Int | String, file:NSFile) {<br>&gt; 		var xml = &quot;&lt;key&gt;\(key)&lt;/key&gt;\n&quot;<br>&gt; 		switch value {<br>&gt; 			case value as Int:<br>&gt; 				xml += &quot;&lt;number&gt;\(value)&lt;/number&gt;\n&quot;<br>&gt; 			case value as String:<br>&gt; 				xml += &quot;&lt;string&gt;\(value)&lt;/string&gt;\n&quot;<br>&gt; 		}<br>&gt; <br>&gt; 		// Actually store the xml string in the file here<br>&gt; 	}<br>&gt; <br>&gt; Currently you might instead do this like:<br>&gt; <br>&gt; 	func addProperty(key:String, value:Int, file:NSFile) {<br>&gt; 		addProperty(key: key, rawValue: &quot;&lt;number&gt;\(value)&lt;/number&gt;&quot;, file: file)<br>&gt; 	}<br>&gt; 	func addProperty(key:String, value:String, file:NSFile) {<br>&gt; 		addProperty(key: key, rawValue: &quot;&lt;string&gt;\(value)&lt;/string&gt;&quot;, file: file)<br>&gt; 	}<br>&gt; 	func addProperty(key:String, rawValue:String, file:NSFile) {<br>&gt; 		var xml = &quot;&lt;key&gt;\(key)&lt;/key&gt;\n\(rawValue\)\n&quot;<br>&gt; 		// Actually store the xml string in the file here<br>&gt; 	}<br>&gt; <br>&gt; (apologies for typos, not at my main computer right now, this is just for illustration anyway)<br>&gt; <br>&gt; Of course if I were doing a complex property list bridge I would extract some of this out, but if the above is all I need then IMO the union example is more convenient to work with, and produces less pollution of the addProperty signature, while the compiler can still optimise it out into separate functions (by eliminating the switch for each type).<br>&gt; <br>&gt; I could alternatively use a protocol to add a .plistValue computed property to all plist compatible types, but again that seems like overkill, and moves the code out of my single function even though that may be all I really need, it also makes it less clear what all of those types are (without building docs to do so). Or I could use an enum, but again, for small use cases that can be a bit overkill, and isn&#39;t as convenient in cases that have similar, but different, union types.<br>&gt; <br>&gt; <br>&gt; Ultimately it&#39;s an issue of choice; not every case will be better using or not using union types, they&#39;re just a convenience that can benefit some cases. If you find yourself using the same union types a lot then, yes, probably time to think about a protocol or an enum, but that&#39;s a big step in simpler cases.<br>&gt; <br>&gt;&gt; On 19 Aug 2016, at 08:42, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; But you can do that already with protocols, can&#39;t you?<br>&gt;&gt; On Fri, Aug 19, 2016 at 2:24 AM Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I&#39;m a +1 for union types.<br>&gt;&gt; <br>&gt;&gt; My main reason for wanting it is to eliminate (some) function overloads; behind the scenes the compiler may still produce one compiled function per union type (for performance), but at a high level we only need to worry about one implementation, and one call signature, which I think is a good thing.<br>&gt;&gt; <br>&gt;&gt;&gt; On 11 Aug 2016, at 02:28, Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I want to make a discussion about union type for swift 4.<br>&gt;&gt;&gt; See https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Add union type grammar, represents the type which is one of other types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var stringOrURL: String | URL = &quot;https://www.apple.com&quot;<br>&gt;&gt;&gt; Now, if we using the new union type feature, we can declare type conveniently, No other type declaration, and compiler will automatically calculate the common interface.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func input(value: A | B |<br>&gt;&gt;&gt;  C) {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; print(value.commonProperty) // type checker will calculate the common interface, developer just use it out of box<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; switch<br>&gt;&gt;&gt;  value {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; case let value as<br>&gt;&gt;&gt;  A:<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt; // value is type A<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         <br>&gt;&gt;&gt; print(value.<br>&gt;&gt;&gt; propertyInA)<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; case let value as<br>&gt;&gt;&gt;  B:<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt; // value is type B<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         <br>&gt;&gt;&gt; print(value.<br>&gt;&gt;&gt; propertyInB)<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; case let value as<br>&gt;&gt;&gt;  C:<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt; // value is type C<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         <br>&gt;&gt;&gt; print(value.<br>&gt;&gt;&gt; propertyInC)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; // there is no default case other than A, B or C. we already declared that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note: A, B, C can be either class or protocol, or any other types. This leaves developer more freedom.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	â¢ This is a new feature, developer who need declare common type will alter to this new grammar.<br>&gt;&gt;&gt; 	â¢ Enum based version optional or IUO will be replaced by Union-based ones. Any optional type will automatically replaced by union type<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>August 19, 2016 at 04:00:00pm</p></header><div class="content"><p>On 19.08.2016 14:51, Haravikk via swift-evolution wrote:<br>&gt; When dealing with your own types, sure, but if you&#39;re talking about<br>&gt; standard types or types from other libraries then it would mean extending<br>&gt; them with whatever it is you actually need, which I&#39;m not sure is the best<br>&gt; way to do it. Type unions are much simpler, and keep all of the code within<br>&gt; a single function.<br>&gt;<br>&gt; To give a simplistic example, consider a method for adding a property to a<br>&gt; property list file. I&#39;m going to trim this down considerably, but it&#39;ll<br>&gt; give an idea hopefully:<br></p><p>FWIW, This reminds me a discussion about ad-hoc(anonymous) enums, we had in <br>the list. There were also examples when such ad-hoc enums could be useful <br>within a function/small block of code:<br></p><p>  func scaleAndCropImage(<br>      image: UIImage,<br>      toSize size: CGSize,<br>      *operation: (.fit | .fill) = .fit*<br>      ) -&gt; UIImage {<br></p><p><br>var codePath : (.one | .two | .three) = .one<br>switch codePath {<br>   case .one : ...<br>   case .two : ...<br>   case .three : ...<br>}<br></p><p>etc..<br></p><p>And AFAIR there was no wide support for this feature.<br>I don&#39;t feel like we need the union type as proposed, but I do would like <br>to see such ad-hoc enums in Swift probably with support of associated type <br>for cases, like here:<br></p><p>func addProperty(key:String, value: (.int(Int) | .string(String) | <br>.text(String)), file:NSFile) {<br>..<br>}<br></p><p>so, value will be a standard enum with 3 cases .int/.string/.text, with <br>associated types. IMO this approach is more powerful and useful, *probably* <br>easily to implement than Union types, use already existed abstraction of <br>&#39;enum&#39; etc.<br></p><p>Opinions?<br></p><p>&gt;<br>&gt; func addProperty(key:String, value:Int | String, file:NSFile) {<br>&gt; var xml = &quot;&lt;key&gt;\(key)&lt;/key&gt;\n&quot;<br>&gt; switch value {<br>&gt; case value as Int:<br>&gt; xml += &quot;&lt;number&gt;\(value)&lt;/number&gt;\n&quot;<br>&gt; case value as String:<br>&gt; xml += &quot;&lt;string&gt;\(value)&lt;/string&gt;\n&quot;<br>&gt; }<br>&gt;<br>&gt; // Actually store the xml string in the file here<br>&gt; }<br>&gt;<br>&gt; Currently you might instead do this like:<br>&gt;<br>&gt; func addProperty(key:String, value:Int, file:NSFile) {<br>&gt; addProperty(key: key, rawValue: &quot;&lt;number&gt;\(value)&lt;/number&gt;&quot;, file: file)<br>&gt; }<br>&gt; func addProperty(key:String, value:String, file:NSFile) {<br>&gt; addProperty(key: key, rawValue: &quot;&lt;string&gt;\(value)&lt;/string&gt;&quot;, file: file)<br>&gt; }<br>&gt; func addProperty(key:String, rawValue:String, file:NSFile) {<br>&gt; var xml = &quot;&lt;key&gt;\(key)&lt;/key&gt;\n\(rawValue\)\n&quot;<br>&gt; // Actually store the xml string in the file here<br>&gt; }<br>&gt;<br>&gt; (apologies for typos, not at my main computer right now, this is just for<br>&gt; illustration anyway)<br>&gt;<br>&gt; Of course if I were doing a complex property list bridge I would extract<br>&gt; some of this out, but if the above is all I need then IMO the union example<br>&gt; is more convenient to work with, and produces less pollution of the<br>&gt; addProperty signature, while the compiler can still optimise it out into<br>&gt; separate functions (by eliminating the switch for each type).<br>&gt;<br>&gt; I could alternatively use a protocol to add a .plistValue computed property<br>&gt; to all plist compatible types, but again that seems like overkill, and<br>&gt; moves the code out of my single function even though that may be all I<br>&gt; really need, it also makes it less clear what all of those types are<br>&gt; (without building docs to do so). Or I could use an enum, but again, for<br>&gt; small use cases that can be a bit overkill, and isn&#39;t as convenient in<br>&gt; cases that have similar, but different, union types.<br>&gt;<br>&gt;<br>&gt; Ultimately it&#39;s an issue of choice; not every case will be better using or<br>&gt; not using union types, they&#39;re just a convenience that can benefit some<br>&gt; cases. If you find yourself using the same union types a lot then, yes,<br>&gt; probably time to think about a protocol or an enum, but that&#39;s a big step<br>&gt; in simpler cases.<br>&gt;<br>&gt;&gt; On 19 Aug 2016, at 08:42, Xiaodi Wu &lt;xiaodi.wu at gmail.com<br>&gt;&gt; &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; But you can do that already with protocols, can&#39;t you?<br>&gt;&gt; On Fri, Aug 19, 2016 at 2:24 AM Haravikk via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     I&#39;m a +1 for union types.<br>&gt;&gt;<br>&gt;&gt;     My main reason for wanting it is to eliminate (some) function<br>&gt;&gt;     overloads; behind the scenes the compiler may still produce one<br>&gt;&gt;     compiled function per union type (for performance), but at a high<br>&gt;&gt;     level we only need to worry about one implementation, and one call<br>&gt;&gt;     signature, which I think is a good thing.<br>&gt;&gt;<br>&gt;&gt;&gt;     On 11 Aug 2016, at 02:28, Cao Jiannan via swift-evolution<br>&gt;&gt;&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Hi all,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     I want to make a discussion about union type for swift 4.<br>&gt;&gt;&gt;     See https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Add union type grammar, represents the type which is one of other types.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     var stringOrURL: String | URL = &quot;https://www.apple.com &lt;https://www.apple.com/&gt;&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Now, if we using the new union type feature, we can declare type<br>&gt;&gt;&gt;     conveniently, No other type declaration, and compiler will<br>&gt;&gt;&gt;     automatically calculate the common interface.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func input(value: A | B | C) {<br>&gt;&gt;&gt;         print(value.commonProperty) // type checker will calculate the common interface, developer just<br>&gt;&gt;&gt;     use it out of box<br>&gt;&gt;&gt;         switch value {<br>&gt;&gt;&gt;         case let value as A:<br>&gt;&gt;&gt;             // value is type A<br>&gt;&gt;&gt;             print(value.propertyInA)<br>&gt;&gt;&gt;         case let value as B:<br>&gt;&gt;&gt;             // value is type B<br>&gt;&gt;&gt;             print(value.propertyInB)<br>&gt;&gt;&gt;         case let value as C:<br>&gt;&gt;&gt;             // value is type C<br>&gt;&gt;&gt;             print(value.propertyInC)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         // there is no default case other than A, B or C. we already<br>&gt;&gt;&gt;     declared that.<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Note: A, B, C can be either class or protocol, or any other types.<br>&gt;&gt;&gt;     This leaves developer more freedom.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         Impact on existing code<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       * This is a new feature, developer who need declare common type<br>&gt;&gt;&gt;         will alter to this new grammar.<br>&gt;&gt;&gt;       * Enum based version optional or IUO will be replaced by<br>&gt;&gt;&gt;         Union-based ones. Any optional type will automatically replaced<br>&gt;&gt;&gt;         by union type<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         ________<br>&gt;&gt;&gt;         &lt;https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md#detailed-design&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     _______________________________________________<br>&gt;&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;     _______________________________________________<br>&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
