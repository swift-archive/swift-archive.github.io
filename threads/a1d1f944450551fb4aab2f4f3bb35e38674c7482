<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>Set-uniqueness of instances with distinct hashValue</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>October 23, 2016 at 09:00:00am</p></header><div class="content"><p>Given an array of instances of a `Hashable` value type, all equal <br>according to `Equatable` protocol, but with distinct `hashValue`s, I <br>would expect that initialising a set with that array would preserve all <br>the instances. Instead, running the code below in an iOS playground on <br>Xcode 8.0 (8A218a), results in a behaviour that I cannot explain. If <br>anyone can, I’d be very grateful!<br></p><p>     struct X: Hashable {<br>         let x: Int<br>         let hashValue: Int<br></p><p>         static func == (lhs: X, rhs: X) -&gt; Bool {<br>             return lhs.x == rhs.x<br>         }<br>     }<br></p><p>     let array: [X] = (1...100).map{ X(x: 7, hashValue: $0) } // unique <br>hash values<br>     array.count //→ 100<br></p><p>     let set = Set(array)<br>     set.count //→ 43<br></p><p>     let set2 = Set(Array(set))<br>     set2.count //→ 30<br></p><p>     let set3 = Set(Array(set2))<br>     set3.count //→ 30<br></p><p>     set3.sorted{ $0.hashValue &lt; $1.hashValue }<br>         .forEach{ print(String($0.hashValue, radix: 2), &quot;=&quot;, <br>$0.hashValue) } /*→<br>            1 = 1<br>           11 = 3<br>          101 = 5<br>         1111 = 15<br>        10010 = 18<br>        10011 = 19<br>        11000 = 24<br>        11101 = 29<br>        11111 = 31<br>       100000 = 32<br>       100011 = 35<br>       100100 = 36<br>       100110 = 38<br>       101000 = 40<br>       101001 = 41<br>       101011 = 43<br>       101111 = 47<br>       110010 = 50<br>       110101 = 53<br>       111101 = 61<br>      1000010 = 66<br>      1001011 = 75<br>      1001101 = 77<br>      1001111 = 79<br>      1010000 = 80<br>      1011001 = 89<br>      1011100 = 92<br>      1011110 = 94<br>      1011111 = 95<br>      1100010 = 98<br>     */<br></p><p>Many thanks,<br></p><p>milos<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>Set-uniqueness of instances with distinct hashValue</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>October 23, 2016 at 11:00:00am</p></header><div class="content"><p>If you change the “==“ function to:<br></p><p>func == (lhs: X, rhs: X) -&gt; Bool {<br>    return (lhs.x == rhs.x) &amp;&amp; (lhs.hashValue == rhs.hashValue)<br>}<br></p><p>then the example works as expected.<br></p><p>Apple says this: “A hash value, provided by a type’s hashValue property, is an integer that is the same for any two instances that compare equally.”<br></p><p>You violated this rule in the original example.<br></p><p>Apple says: “Set and dictionary performance depends on hash values that minimize collisions for their associated element and key types, respectively.”<br></p><p>From which I draw the conclusion that there are “under the hood” optimizations at work that produce the results in your example. These can probably change from compiler version to compiler version and are principally unreliable because your example violated the rule for Hashable.<br></p><p>Rien.<br></p><p>&gt; On 23 Oct 2016, at 10:51, milos via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Given an array of instances of a `Hashable` value type, all equal according to `Equatable` protocol, but with distinct `hashValue`s, I would expect that initialising a set with that array would preserve all the instances. Instead, running the code below in an iOS playground on Xcode 8.0 (8A218a), results in a behaviour that I cannot explain. If anyone can, I’d be very grateful!<br>&gt; <br>&gt;    struct X: Hashable {<br>&gt;        let x: Int<br>&gt;        let hashValue: Int<br>&gt; <br>&gt;        static func == (lhs: X, rhs: X) -&gt; Bool {<br>&gt;            return lhs.x == rhs.x<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt;    let array: [X] = (1...100).map{ X(x: 7, hashValue: $0) } // unique hash values<br>&gt;    array.count //→ 100<br>&gt; <br>&gt;    let set = Set(array)<br>&gt;    set.count //→ 43<br>&gt; <br>&gt;    let set2 = Set(Array(set))<br>&gt;    set2.count //→ 30<br>&gt; <br>&gt;    let set3 = Set(Array(set2))<br>&gt;    set3.count //→ 30<br>&gt; <br>&gt;    set3.sorted{ $0.hashValue &lt; $1.hashValue }<br>&gt;        .forEach{ print(String($0.hashValue, radix: 2), &quot;=&quot;, $0.hashValue) } /*→<br>&gt;           1 = 1<br>&gt;          11 = 3<br>&gt;         101 = 5<br>&gt;        1111 = 15<br>&gt;       10010 = 18<br>&gt;       10011 = 19<br>&gt;       11000 = 24<br>&gt;       11101 = 29<br>&gt;       11111 = 31<br>&gt;      100000 = 32<br>&gt;      100011 = 35<br>&gt;      100100 = 36<br>&gt;      100110 = 38<br>&gt;      101000 = 40<br>&gt;      101001 = 41<br>&gt;      101011 = 43<br>&gt;      101111 = 47<br>&gt;      110010 = 50<br>&gt;      110101 = 53<br>&gt;      111101 = 61<br>&gt;     1000010 = 66<br>&gt;     1001011 = 75<br>&gt;     1001101 = 77<br>&gt;     1001111 = 79<br>&gt;     1010000 = 80<br>&gt;     1011001 = 89<br>&gt;     1011100 = 92<br>&gt;     1011110 = 94<br>&gt;     1011111 = 95<br>&gt;     1100010 = 98<br>&gt;    */<br>&gt; <br>&gt; Many thanks,<br>&gt; <br>&gt; milos<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
