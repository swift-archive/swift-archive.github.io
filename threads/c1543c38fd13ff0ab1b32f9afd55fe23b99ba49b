<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-users] Problem with COW optimization</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>September 20, 2016 at 08:00:00am</p></header><div class="content"><p>on Tue Sep 20 2016, Adrian Zubarev &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; True, but how do you traverse back the tree from an inner node?<br>&gt;<br>&gt; Lets look at this simple tree:<br>&gt;<br>&gt; &lt;root&gt;<br>&gt;    &lt;first&gt;<br>&gt;       &lt;second/&gt;<br>&gt;    &lt;/first&gt;<br>&gt; &lt;/root&gt;<br>&gt; let second = /* get the second node */<br>&gt;<br>&gt; second.parent // &lt;— How would you implement this with pure value type?<br></p><p>Two possibilities:<br></p><p>1. You don&#39;t.  Instead your traversal state becomes a path from the root<br>   of the tree.<br></p><p>2. You represent the graph more explicitly, e.g.:<br></p><p>   struct XMLNode {<br>     tag: String<br>     attributes: [String]<br>     parent: Int<br>     children: [Int]<br>   }<br>   typealias XMLTree = [XMLNode]<br></p><p>   where parent and children are indices into XMLTree.<br></p><p>&gt; If parent were only a struct without a reference type behind the<br>&gt; scenes the parent will also contain the current child, where every<br>&gt; child has the parent and so one. The reference type is there as a<br>&gt; layer to achieve this.<br></p><p>A CoW tree that uses references for relationships internally has some<br>interesting limitations:<br></p><p>* you have to choose between the ability to share unmodified subparts of<br>  the tree between copies and the ability to reach a node&#39;s parent.<br></p><p>* if you share unmodified subparts, you need to check uniqueness of<br>  all its ancestors before modifying a node in place<br></p><p>To me, it doesn&#39;t make sense to use references for relationships unless<br>they let you share unmodified subparts.  If you don&#39;t share unmodified<br>subparts, you&#39;ll get much worse performance from such a CoW<br>representation than you would using the array representation I quoted<br>above.<br></p><p>So if you&#39;re really committed to using a reference for a parent<br>relationship, I&#39;d ditch CoW either give the XML tree reference<br>semantics, or make it immutable (in which case its semantics are<br>indistinguishable from value semantics).<br></p><p>Hope this helps,<br>Dave<br></p><p>&gt;<br>&gt;<br>&gt; What kind of a layer does indirect add on enums?<br>&gt; Can indirect solve the problem here and can it be added to structs as well?<br>&gt; If I’m missing here something, and there might be a true value type solution for this problem, I’d throw the whole project away and rebuild it from the beginning. :)<br>&gt;<br>&gt; Best regards,<br>&gt;<br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 20. September 2016 um 08:56:20, Dave Abrahams via swift-evolution (swift-evolution at swift.org) schrieb:<br>&gt;<br>&gt; on Mon Sep 19 2016, Adrian Zubarev &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I think I just found a solution to my problem:<br>&gt;&gt;<br>&gt;&gt; /// - Parameter child: The new `child` to add to the `children` array.<br>&gt;&gt; public mutating func add(_ child: Element) {<br>&gt;&gt;<br>&gt;&gt; let clonedChildReference = Reference(cloning: child.reference)<br>&gt;&gt; let index = self.reference.children.endIndex<br>&gt;&gt;<br>&gt;&gt; self.mutableInsert(clonedChildReference, at: index, isNotOwnReference: child.reference !== self.reference)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; /// Warning: Pass only clonded nodes of type Element to this function!<br>&gt;<br>&gt; I don&#39;t understand why any explicit cloning should be needed. An XML<br>&gt; tree can be modeled perfectly well using arrays of value types, which<br>&gt; will “clone” themselves as needed to maintain value semantics.<br>&gt;<br>&gt;&gt; private mutating func mutableInsert(_ node: XML.Node, at index: Int,<br>&gt;&gt; isNotOwnReference: Bool) {<br>&gt;&gt;<br>&gt;&gt; // * If `self.reference` is NOT uniquely referenced and `node` is a String,<br>&gt;&gt; // we should rebuilt own reference.<br>&gt;&gt; // * If `self.reference` is NOT uniquely referenced and `node` is a Reference<br>&gt;&gt; // `isNotOwnReference` is true, we should rebuilt own reference.<br>&gt;&gt; // * If `self.reference` is NOT uniquely referenced and `node` is a clone  <br>&gt;&gt; // reference to `self.reference` where is `isNotOwnReference` is false, we<br>&gt;&gt; // should check if there are more than **two** strong references to rebuild<br>&gt;&gt; // own reference, otherwise it&#39;s an implementation artifact and we can keep<br>&gt;&gt; // old reference (any `node` of type Reference is cloned before it&#39;s added  <br>&gt;&gt; // to the child array).<br>&gt;&gt; let isNotKnownUniquelyReferenced = !isKnownUniquelyReferenced(&amp;self.reference)<br>&gt;&gt;<br>&gt;&gt; var shouldRebuildReference = false<br>&gt;&gt;<br>&gt;&gt; switch node.kind {<br>&gt;&gt;<br>&gt;&gt; case .element(_):<br>&gt;&gt; let hasMoreThanTwoStrongReferences = (CFGetRetainCount(self.reference) - 1) &gt; 2<br>&gt;&gt; shouldRebuildReference = (isNotKnownUniquelyReferenced &amp;&amp; isNotOwnReference) || hasMoreThanTwoStrongReferences<br>&gt;&gt;<br>&gt;&gt; case .text(_):<br>&gt;&gt; shouldRebuildReference = isNotKnownUniquelyReferenced<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; if shouldRebuildReference {<br>&gt;&gt;<br>&gt;&gt; self.reference = Reference(cloning: self.reference, wholeTree: true)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; self.reference.insert(node, at: index)<br>&gt;&gt; }<br>&gt;&gt; I’m using CFGetRetainCount(self.reference) to catch that implementation artifact.<br>&gt;&gt;<br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt;<br>&gt;&gt; Am 19. September 2016 um 09:59:24, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br>&gt;&gt;<br>&gt;&gt; Hello Dave,<br>&gt;&gt;<br>&gt;&gt; thank you for trying to help me. I’ll try to explain the issue with some more details.<br>&gt;&gt;<br>&gt;&gt; First here is some code:<br>&gt;&gt;<br>&gt;&gt; extension XML {<br>&gt;&gt;<br>&gt;&gt; public struct Element {<br>&gt;&gt;<br>&gt;&gt; // public for testing  <br>&gt;&gt; public var reference: Reference<br>&gt;&gt;<br>&gt;&gt; public var name: String { return self.reference.name }<br>&gt;&gt;<br>&gt;&gt; public var children: [Element] {<br>&gt;&gt;<br>&gt;&gt; return self.reference.children.flatMap {<br>&gt;&gt;<br>&gt;&gt; guard case .element(let element) = $0.kind else { return nil }<br>&gt;&gt; return Element(wrapping: element)<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; public init(name: String) {<br>&gt;&gt;<br>&gt;&gt; self.reference = Reference(name: name)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; public mutating func add(_ child: Element) {<br>&gt;&gt;<br>&gt;&gt; self.mutableInsert(Reference(cloning: child.reference), at: self.reference.children.endIndex)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; // Ignore XML.Node, it&#39;s a String or Reference<br>&gt;&gt; // Parameter `Node` is assumed to be a clone of a reference passed to `add` or `insert` method.<br>&gt;&gt; private mutating func mutableInsert(_ node: XML.Node, at index: Int) {<br>&gt;&gt;<br>&gt;&gt; // Clone own reference all way up to the root<br>&gt;&gt; if !isKnownUniquelyReferenced(&amp;self.reference) {<br>&gt;&gt;<br>&gt;&gt; self.reference = Reference(cloning: self.reference, wholeTree: true)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; // Extract a reference or just insert a string as a child<br>&gt;&gt; guard case .element(let nodeReference) = node.kind else {<br>&gt;&gt;<br>&gt;&gt; self.reference.insert(node, at: index)<br>&gt;&gt; return<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; // Check for possible debelopment bug<br>&gt;&gt; if nodeReference === self.reference {<br>&gt;&gt;<br>&gt;&gt; fatalError(&quot;wrong usage of `mutableInsert` function&quot;)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; self.reference.insert(nodeReference, at: index)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; ...<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension XML.Element {<br>&gt;&gt;<br>&gt;&gt; // public for testing<br>&gt;&gt; public class Reference : XML.Node {<br>&gt;&gt;<br>&gt;&gt; let name: String<br>&gt;&gt;<br>&gt;&gt; private(set) weak var parent: Reference?<br>&gt;&gt;<br>&gt;&gt; private(set) var children: [XML.Node]<br>&gt;&gt;<br>&gt;&gt; var kind: XML.Node.Kind { return .element(self) }<br>&gt;&gt;<br>&gt;&gt; ...<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; Now lets focus on the problem.<br>&gt;&gt;<br>&gt;&gt; Every Element is baked with it’s own Reference to be able to<br>&gt;&gt; traverse the tree from any of it’s node all way up to the root for<br>&gt;&gt; example.<br>&gt;&gt;<br>&gt;&gt; Lets look again at the scenario I already described:<br>&gt;&gt;<br>&gt;&gt; var root = XML.Element(name: &quot;root&quot;)<br>&gt;&gt; var elem = XML.Element(name: &quot;elem&quot;)<br>&gt;&gt;<br>&gt;&gt; ObjectIdentifier(root.reference) // 0x000060000026ab40<br>&gt;&gt; ObjectIdentifier(elem.reference) // 0x000060800026bb00<br>&gt;&gt;<br>&gt;&gt; isKnownUniquelyReferenced(&amp;root.reference) // true<br>&gt;&gt; isKnownUniquelyReferenced(&amp;elem.reference) // true<br>&gt;&gt;<br>&gt;&gt; root.add(elem)<br>&gt;&gt;<br>&gt;&gt; isKnownUniquelyReferenced(&amp;root.reference) // true<br>&gt;&gt;<br>&gt;&gt; root.add(root)<br>&gt;&gt;<br>&gt;&gt; // The reference of root has changed even if the second child  <br>&gt;&gt; // was cloned and added as a new object to the reference.<br>&gt;&gt; // 0x000060000026ab40 &lt;-- was thrown away<br>&gt;&gt; isKnownUniquelyReferenced(&amp;root.reference) // true<br>&gt;&gt;<br>&gt;&gt; ObjectIdentifier(root.reference) // 0x000060000026c680 &lt;— new one<br>&gt;&gt; The way I’m adding children to the tree is that every passed element<br>&gt;&gt; of type XML.Element stores a Reference, which will be cloned and<br>&gt;&gt; added as a new standalone object to the children array.<br>&gt;&gt;<br>&gt;&gt; The same happens when we try adding root as it’s own child. We copy<br>&gt;&gt; root struct which contains the same reference, then we clone it<br>&gt;&gt; inside add method, then we pass the new object to the mutableInsert<br>&gt;&gt; function. At that point we don’t need the old reference anymore, I’m<br>&gt;&gt; speaking of root.add(root). The problem here is that at that time<br>&gt;&gt; root.reference has 2 strong references which I cannot escape.<br>&gt;&gt;<br>&gt;&gt; I could workaround the problem if I knew the reference counter<br>&gt;&gt; value, because I could check if the passed Element contains the same<br>&gt;&gt; reference first. And if it does and we have exactly 2 strong<br>&gt;&gt; references, I don’t need to recreate root.reference here.<br>&gt;&gt;<br>&gt;&gt; But I couldn’t find any API for that. :/<br>&gt;&gt;<br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt;<br>&gt;&gt; Am 19. September 2016 um 05:50:57, Dave Abrahams via swift-users<br>&gt;&gt; (swift-users at swift.org) schrieb:<br>&gt;&gt;<br>&gt;&gt; on Sun Sep 18 2016, Adrian Zubarev &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Dear Swift community,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; currently I’m building a value type XML library which is baked behind<br>&gt;&gt;&gt; the scene with a reference type to manage graph traversing between<br>&gt;&gt;&gt; nodes. I also like to COW optimize the xml graph, but I run into one<br>&gt;&gt;&gt; single problem atm.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Image this xml tree:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;root&gt;<br>&gt;&gt;&gt; &lt;item/&gt;<br>&gt;&gt;&gt; &lt;/root&gt;<br>&gt;&gt;&gt; It’s just a root element with one single child. As for value types it<br>&gt;&gt;&gt; should be totally fine to do something like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // The given xml tree<br>&gt;&gt;&gt; var root = XML.Element(name: &quot;root&quot;)<br>&gt;&gt;&gt; let item = XML.Element(name: &quot;item&quot;)<br>&gt;&gt;&gt; root.add(item)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // The problematic behavior<br>&gt;&gt;&gt; root.add(root)<br>&gt;&gt;&gt; If this would be a simple value type without any references behind the<br>&gt;&gt;&gt; scenes you could imagine that the result of the last code line will<br>&gt;&gt;&gt; look like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;root&gt;<br>&gt;&gt;&gt; &lt;item/&gt;<br>&gt;&gt;&gt; &lt;root&gt;<br>&gt;&gt;&gt; &lt;item/&gt;<br>&gt;&gt;&gt; &lt;/root&gt;<br>&gt;&gt;&gt; &lt;/root&gt;<br>&gt;&gt;<br>&gt;&gt; Yep, that&#39;s exactly the right answer for a tree with value semantics.<br>&gt;&gt; The simplest way to implement this tree is to use an Array for the child<br>&gt;&gt; nodes.<br>&gt;&gt;<br>&gt;&gt;&gt; Basically we copied the whole tree and added it as the second child<br>&gt;&gt;&gt; into the original root element.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As for COW optimization this is a problem, just because the passed<br>&gt;&gt;&gt; root is a copy of a struct that contains the exact same reference as<br>&gt;&gt;&gt; the original root element.<br>&gt;&gt;<br>&gt;&gt; I don&#39;t understand why that&#39;s a problem.<br>&gt;&gt;<br>&gt;&gt;&gt; isKnownUniquelyReferenced(&amp;self.reference) will result in false inside<br>&gt;&gt;&gt; the add method.<br>&gt;&gt;<br>&gt;&gt; ...as it should.<br>&gt;&gt;<br>&gt;&gt;&gt; Is there any chance I could force my program to decrease the reference<br>&gt;&gt;&gt; counter of that last item after I’m sure I don’t need it?!<br>&gt;&gt;<br>&gt;&gt; Which last item? When are you sure you don&#39;t need it? What result do<br>&gt;&gt; you hope for?<br>&gt;&gt;<br>&gt;&gt;&gt; A few more details: inside the add method I’m always cloning the<br>&gt;&gt;&gt; passed reference just because graphs aren’t that trivial and otherwise<br>&gt;&gt;&gt; I could possibly end up with a cycle graph, which would be really<br>&gt;&gt;&gt; bad. After that job I’m sure that I don’t need the passed reference<br>&gt;&gt;&gt; anymore and I need a way to escape from it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’d appreciate any suggestions and help. :)<br>&gt;&gt;<br>&gt;&gt; It&#39;s not clear what you want to acheive nor can I picture the code<br>&gt;&gt; you&#39;re using to acheive it, so it&#39;s hard to give useful feedback.<br>&gt;&gt;<br>&gt;&gt; Sorry,<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; --  <br>&gt; -Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
