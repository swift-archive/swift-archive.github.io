<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1b852c5986959201d1f8eca105491072?s=50"></div><header><strong>Could enums have their rawValue type inferred?</strong> from <string>Eric Miller</string> &lt;hi at simple.gy&gt;<p>May 16, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; automatically cast rawValue when assigning an enum value to<br>a variable or argument of the type of the enum&#39;s raw value<br></p><p>That&#39;s exactly what I&#39;m thinking, Leonardo. I was a little bit trying to<br>avoid specifics because I don&#39;t understand the differences between<br>autocasting and inference.<br></p><p>There&#39;s a small miscommunication though--This api works great since it<br>accepts the enum type, rather than the underlying value type. Signature:<br></p><p>static func fadeIn(view: UIView?, withSpeed: Animate.transitionSpeed =<br>Animate.transitionSpeed.fast)<br></p><p>The goal was to provide my users with a good default and an easy set of<br>configurable options at the call site like `.fast`, `.normal`, `.slow`.<br></p><p>(unrelated: +1 on inferring type of function params with default values, I<br>hit this all the time)<br></p><p>Calling:<br></p><p>Animate.fadeIn(myView, withSpeed: .slow)<br></p><p>Works great.<br></p><p>This library of methods is a facade for CABasicAnimation or UIView<br>animations which take an NSTimeInterval, and that&#39;s where the &quot;autocasting&quot;<br>would come into play.<br></p><p><br></p><p>------------------------------<br></p><p>Message: 31<br>Date: Fri, 13 May 2016 16:58:06 -0300<br>From: Leonardo Pessoa &lt;me at lmpessoa.com&gt;<br>To: Swift-evolution &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] Could enums have their rawValue type<br>        inferred?<br>Message-ID:<br>        &lt;CANTOS57wksMRzUAMq0ncf1QAd82vhudf21tnea6wHjhBOFr1PA at mail.gmail.com&gt;<br>Content-Type: text/plain; charset=&quot;utf-8&quot;<br></p><p>Eric, I think I understood your proposal. If I may explain in other words<br>it would be &quot;to automatically cast rawValue when assigning an enum value to<br>a variable or argument of the type of the enum&#39;s raw value&quot;, am I right? I<br>think this would imply a little more inference and type checking rules from<br>the compiler and maybe even take a little longer to fully compile code. I&#39;m<br>not sure it&#39;s feasible but from your examples, I can see how it enhances<br>readability of the code, so I&#39;m +1 for it. My only concern is that you<br>would still need to fully declare the enum&#39;s name where the value of the<br>enum is used. Taking from your own example<br></p><p>    Animate.fadeIn(view, withSpeed: .fast)<br></p><p>couldn&#39;t be called that way if withSpeed expects and NSTimeInterval because<br>the compiler won&#39;t know whether you&#39;re refering to transitionSpeed or to<br>ambientAnimationSpeed. You would still have to call it like<br></p><p>    Animate.fadeIn(view, withSpeed: transitionSpeed.fast)<br></p><p>even if you had only one possible enum value over all declared enums<br>because that would still force the compiler to search for each value over<br>all known enums to define where the value you&#39;re using comes from and make<br>sure there are no two enums with the same value.<br></p><p>Aside from that, I good with the idea.<br></p><p><br></p><p>On 13 May 2016 at 15:09, Eric Miller via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This might open a larger can of worms than I imagine, but what do you<br>&gt; folks think about using the `rawValue` of an enum when that rawValue is a<br>&gt; fit for the expected type?<br>&gt;<br>&gt; Use case.<br>&gt;<br>&gt; I&#39;m making an animation facade, and it has some speed presets:<br>&gt;<br>&gt; class Animate {<br>&gt;   enum transitionSpeed: NSTimeInterval {<br>&gt;     case fast = 0.15<br>&gt;     case slow = 0.5<br>&gt;   }<br>&gt;   enum ambientAnimationSpeed: NSTimeInterval {<br>&gt;     case fast = 1.0<br>&gt;     case slow = 5.0<br>&gt;   }<br>&gt;   ...<br>&gt; }<br>&gt;<br>&gt; I did them with static variables at first but that made the call site<br>&gt; verbose. Compare:<br>&gt;<br>&gt; Animate.fadeIn(view, withSpeed: Animate.cfg.transitionFast)<br>&gt; Animate.fadeIn(view, withSpeed: .fast)<br>&gt;<br>&gt; So, I like the enum approach better, but my library code has to use<br>&gt; `rawValue` to do anything with the actual value, of course:<br>&gt;<br>&gt; static func fadeIn(view: UIView?, withSpeed duration:transitionSpeed =<br>&gt; .fast) {<br>&gt;   ...<br>&gt;   UIView.animateWithDuration(duration.rawValue, animations: { })<br>&gt; }<br>&gt;<br>&gt; It&#39;s not a serious issue, but the code is more clear and beautiful if it<br>&gt; has just myIntent, rather than myIntent.rawValue.<br>&gt;<br>&gt; I&#39;ve hit this issue when modeling other things, such as:<br>&gt;<br>&gt; * server fault codes<br>&gt; * HTTP status codes<br>&gt; * Currency codes<br>&gt; * Days of the week<br>&gt;<br>&gt; Would it be appropriate to &quot;autocast&quot; to the rawValue of the enum when the<br>&gt; rawValue&#39;s Type matches the type expectation of the API? Or would this<br>&gt; introduce a bunch of type system uncertainty?<br>&gt;<br>&gt; Maybe this could be implemented as a protocol? It feels almost like the<br>&gt; convenience of `CustomStringConvertible`&#39;s `description` property.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/32a6d80c/attachment.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
