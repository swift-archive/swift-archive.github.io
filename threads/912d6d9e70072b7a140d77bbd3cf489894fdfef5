<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 22, 2016 at 04:00:00pm</p></header><div class="content"><p>on Wed Jun 22 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;ll duly oblige with some pushback on `suchThat`. I get that you&#39;re trying<br>&gt; to clarify whether filter retains or gets rid of elements that match the<br>&gt; predicate, but I don&#39;t think &quot;filter such that&quot; expresses this idea at all.<br>&gt;<br>&gt; Comparing to &quot;filter where,&quot; &quot;filter such that&quot; is equally susceptible to<br>&gt; misinterpretation that you are filtering to remove elements that are<br>&gt; matched. For example: &quot;find me some apples, filtering such that are<br>&gt; bruised.&quot;<br></p><p>Hahaha, that&#39;s a very different interpretation of “such” that I hadn&#39;t<br>considered!  OK, suppose it was “soEach:” ?<br></p><p>    let primes = xs.filter(soEach: isPrime)<br></p><p>&gt; I&#39;d suggest that if you want to be perfectly clear, you&#39;d need something<br>&gt; like `filter(keepingWhere:)`.<br></p><p>    let primes = xs.filter(keepingWhere: isPrime)<br></p><p>A slight problem is that filter is nonmutating, so all elements are<br>“kept.”  But maybe that&#39;s just Dave being overly concerned with unlikely<br>misinterpretations at the cost of “naturalness.”<br></p><p>Further thoughts?<br></p><p>&gt; On Wed, Jun 22, 2016 at 18:33 Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Tue Jun 21 2016, Dave Abrahams &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; on Mon Jun 20 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; A couple of weeks ago we started to notice that we had some<br>&gt;&gt; poorly-named<br>&gt;&gt; &gt;&gt;&gt; closure parameters and argument labels in the standard library, so we<br>&gt;&gt; &gt;&gt;&gt; did a complete audit of the standard library&#39;s APIs and came up with a<br>&gt;&gt; &gt;&gt;&gt; preliminary proposal for changes, which we applied in a branch and you<br>&gt;&gt; &gt;&gt;&gt; can review in https://github.com/apple/swift/pull/2981.  Let&#39;s please<br>&gt;&gt; &gt;&gt;&gt; carry on further discussion here rather than in the pull request,<br>&gt;&gt; though.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; In general, I like this; `orderingBy` is a particularly nice<br>&gt;&gt; &gt;&gt; improvement over the old `isOrderedBefore` convention.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I don&#39;t really love the use of “by”, FWIW, but I thought `orderingWith`<br>&gt;&gt; &gt; was more confusable (ordering A with B might swap A and B, whereas the<br>&gt;&gt; &gt; parameter is a closure).  It could be argued, though, that I am being<br>&gt;&gt; &gt; overly concerned with unlikely misinterpretations, at the cost of<br>&gt;&gt; &gt; “naturalness”—a known weakness of mine ;-).  Anyway, as ever I&#39;m open to<br>&gt;&gt; &gt; discussion on this.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; A few specific comments about things I don&#39;t like:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; * In `map` and `flatMap`, I&#39;m not sure how much `transform` buys us<br>&gt;&gt; &gt;&gt;   over `elementTransform`.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I think you mean the converse.  And I agree that `elementTransform`<br>&gt;&gt; &gt; is probably not an improvement over `transform`.<br>&gt;&gt;<br>&gt;&gt; ...and I&#39;ve gone back to `transform` in my PR.<br>&gt;&gt;<br>&gt;&gt; &gt;&gt; * In general, I&#39;m not a fan of most of the changes away from `where`<br>&gt;&gt; &gt;&gt; labels.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The only such changes I can find are in<br>&gt;&gt; &gt;<br>&gt;&gt; https://github.com/apple/swift/pull/2981/commits/3418eede88d724ad23731fe8f412f51e03cf5106<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Note that part of this change was to make all filter closures<br>&gt;&gt; &gt; consistent; in the main `filter` API there was no label at all.<br>&gt;&gt; &gt; However, we felt that there&#39;s a real clarity problem with the polarity<br>&gt;&gt; &gt; of the argument (we talk about “filtering things out” but the closure<br>&gt;&gt; &gt; indicates which elements to keep).  And we couldn&#39;t find a “where”-based<br>&gt;&gt; &gt; name that began to clarify it.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I will argue that even changing to “suchThat,” as in the PR, does not<br>&gt;&gt; &gt; sufficiently clarify the closure&#39;s polarity, and the only true fix for<br>&gt;&gt; &gt; filter is to use a different base name (some have suggested “select,”<br>&gt;&gt; &gt; and I have other ideas), but that is out of scope for this particular<br>&gt;&gt; &gt; set of changes.  So if the community is happier with a “where” label<br>&gt;&gt; &gt; here I can live with it.  I do think “suchThat” is marginally clearer.<br>&gt;&gt;<br>&gt;&gt; I have not received any further pushback on “suchThat,” so I&#39;ve left it<br>&gt;&gt; alone.<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Those are a nice, straightforward convention applied broadly across<br>&gt;&gt; &gt;&gt; the Sequence APIs. (Yes, I criticized `where` as a method name in<br>&gt;&gt; &gt;&gt; another thread, but I don&#39;t think `where` is a problem when there&#39;s a<br>&gt;&gt; &gt;&gt; function base name to give it context.) When they don&#39;t work, that&#39;s<br>&gt;&gt; &gt;&gt; usually because of a less-than-ideal base name. I&#39;m not saying that<br>&gt;&gt; &gt;&gt; *all* base names that aren&#39;t compatible with `where` should be<br>&gt;&gt; &gt;&gt; changed, but rather that if `where` is not enough, that&#39;s an API<br>&gt;&gt; &gt;&gt; smell.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; * In particular, `elementWhere` is not a good label for the same<br>&gt;&gt; &gt;&gt; reason that `removeElement` is not a good name. Session 403 last week<br>&gt;&gt; &gt;&gt; actually talked about this between roughly minutes 8 and 11. (I&#39;m sure<br>&gt;&gt; &gt;&gt; you know about its content; you probably saw it before we did.)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Yes I do, and I think you misinterpreted the message in that session.<br>&gt;&gt; &gt; There&#39;s nothing wrong with repeating type information when it&#39;s<br>&gt;&gt; &gt; necessary for clarity or fluency at the use-site.  In the case of<br>&gt;&gt; &gt; `contains(elementWhere:)`, it&#39;s there for fluency:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;        customers.contains(where: isSingle)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; doesn&#39;t read as well as:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;        customers.contains(elementWhere: isSingle)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The point is not to imagine that every argument should be preceded by<br>&gt;&gt; &gt; a noun, and repetition of type information is often the result of<br>&gt;&gt; &gt; trying to do that.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; * I like `separatedWhere` on `split`, but I think the Equatable<br>&gt;&gt; &gt;&gt; version needs a similar renaming.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; That&#39;s a nice thought; I think it&#39;s arguably out-of-scope here, though.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Perhaps `separatedBy`?  `separatedOn`? The usual opposite of `where`,<br>&gt;&gt; &gt;&gt; `of`, doesn&#39;t work here. (Alternatively, `separatedWhere` could be<br>&gt;&gt; &gt;&gt; `separatorWhere` instead, but that&#39;s not quite as elegant.)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;d want to consider variations of `separatingAt` or `onSeparator` or<br>&gt;&gt; &gt; `atSeparator` too... which makes me thing “separatedWhere” might not be<br>&gt;&gt; &gt; as good as “separatingWhere” for the closure version.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; * I&#39;m very uncomfortable with the amount of weight<br>&gt;&gt; &gt;&gt; `accumulatingResultBy` adds to `reduce`. `combinedBy` seems perfectly<br>&gt;&gt; &gt;&gt; cromulent to me. I&#39;m even more concerned by your suggestion in the<br>&gt;&gt; &gt;&gt; pull request body of<br>&gt;&gt; &gt;&gt; `accumulating(startingFrom:combiningBy:)`. `reduce` is a subtle and<br>&gt;&gt; &gt;&gt; slightly confusing operation; adding more words to its call sites will<br>&gt;&gt; &gt;&gt; not solve that problem. If you want to invent a new name from whole<br>&gt;&gt; &gt;&gt; cloth, I would probably use something like `combining(with<br>&gt;&gt; &gt;&gt; initialResult: T, by nextResult: (T, Element) -&gt; T)`. (For that<br>&gt;&gt; &gt;&gt; matter, while we&#39;re working in this area, `sequence(first:next:)`<br>&gt;&gt; &gt;&gt; could use a similar coat of paint.)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; As with `filter(suchThat:`, `reduce(accumulatingResultBy:` is attempting<br>&gt;&gt; &gt; to solve with an argument label what IMO is a grave weakness in clarity<br>&gt;&gt; &gt; of the base name.  If you read the documentation for `reduce`, you&#39;ll<br>&gt;&gt; &gt; see that it&#39;s all about accumulating a result, and if you consider that<br>&gt;&gt; &gt; its current signature often leads to O(N^2) behavior and we are thinking<br>&gt;&gt; &gt; about adding an overload that takes its “accumulator” inout, the<br>&gt;&gt; &gt; arguments for avoiding the name “accumulate” get progressively weaker.<br>&gt;&gt; &gt; But as noted earlier, changing base names is out-of-scope for this<br>&gt;&gt; &gt; proposal.  As with “filter,” I could live with leaving this alone,<br>&gt;&gt; &gt; though I do believe “accumulatingResultBy:” is a real improvement in<br>&gt;&gt; &gt; clarity.<br>&gt;&gt;<br>&gt;&gt; ...but I think it&#39;s overly specific at the expense of smoothness.  So<br>&gt;&gt; I&#39;ve removed `Result` from that name.<br>&gt;&gt;<br>&gt;&gt; &gt;&gt; * I agree with the comment on GitHub that `invoke` should be<br>&gt;&gt; &gt;&gt; `execute`.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Why?  Rationales help.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; If you see a distinction between the two cases on the number of<br>&gt;&gt; &gt;&gt; arguments, I would then suggest `passTo` as the label on these<br>&gt;&gt; &gt;&gt; methods: `views.forEach(passTo: addSubview)`,<br>&gt;&gt; &gt;&gt; `withUnsafeBufferPointer(&amp;bytes, passTo: Data.init(buffer:))`.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Those are intriguing ideas, but that direction tends to suggest this<br>&gt;&gt; &gt; would be better:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;   views.passEach(to: addSubview)<br>&gt;&gt; &gt;   passUnsafeBufferPointer(to: Data.init(buffer:))<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ...until you pass a trailing closure:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;   views.passEach { addSubView($0) }<br>&gt;&gt; &gt;   passUnsafeBufferPointer { Data.init(buffer:$0) }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; (note: withUnsafeBufferPointer takes only one argument, a closure).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; * It&#39;s a little odd that you&#39;re using `comparingBy` for `Equatable`<br>&gt;&gt; &gt;&gt; and `orderingBy` for `Comparable`. Did you judge `equatingBy` to be<br>&gt;&gt; &gt;&gt; too awkward?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Yes, and because it&#39;s not “equating,” which would mean using equality<br>&gt;&gt; &gt; (==) it&#39;s “testing equivalence” with respect to the predicate.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Perhaps the real problem is that `Equatable` ought to be `Comparable`<br>&gt;&gt; &gt;&gt; and `Comparable` ought to be `Orderable`?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I don&#39;t think so, personally, but regardless I consider such a change<br>&gt;&gt; &gt; out-of-scope for this proposal.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Or maybe `comparingBy` should just be something more general, like<br>&gt;&gt; &gt;&gt; `matchingBy`? That would make perfectly sensible but slightly odd use<br>&gt;&gt; &gt;&gt; cases like this one read better:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;      let isAnIdiot = luggageCombination.starts(with: [1, 2, 3, 4,<br>&gt;&gt; &gt;&gt; 5], matchingBy: &lt;=) // Matches [1,2,3,4,5], but also [1,1,1,1,1],<br>&gt;&gt; &gt;&gt; [1,2,3,2,1], etc.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; That would not be legal, as &lt;= is not an equivalence relation.  You<br>&gt;&gt; &gt; could think about redefining the meaning of `starts(with:` to not<br>&gt;&gt; &gt; require an equivalence relation, but that&#39;s something I&#39;m not confident<br>&gt;&gt; &gt; *I* know how to do meaningfully, and regardless is again out-of-scope.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Very soon (hopefully), I will be posting an early draft of a proposal<br>&gt;&gt; &gt;&gt; renaming the various first/last/prefix/suffix/etc. APIs. I believe the<br>&gt;&gt; &gt;&gt; only place it touches on your proposal is in<br>&gt;&gt; &gt;&gt; `starts(with:isEquivalent:)`, but I think your changes to the second<br>&gt;&gt; &gt;&gt; parameter label can be easily incorporated into what I&#39;m doing.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Great!<br>&gt;&gt;<br>&gt;&gt; I&#39;m going to write up the proposal ASAP based on the current PR unless I<br>&gt;&gt; get more feedback.<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 23, 2016 at 01:00:00am</p></header><div class="content"><p>filter(extractingWhere:)<br>On Wed, Jun 22, 2016 at 18:53 Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Wed Jun 22 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; I&#39;ll duly oblige with some pushback on `suchThat`. I get that you&#39;re<br>&gt; trying<br>&gt; &gt; to clarify whether filter retains or gets rid of elements that match the<br>&gt; &gt; predicate, but I don&#39;t think &quot;filter such that&quot; expresses this idea at<br>&gt; all.<br>&gt; &gt;<br>&gt; &gt; Comparing to &quot;filter where,&quot; &quot;filter such that&quot; is equally susceptible to<br>&gt; &gt; misinterpretation that you are filtering to remove elements that are<br>&gt; &gt; matched. For example: &quot;find me some apples, filtering such that are<br>&gt; &gt; bruised.&quot;<br>&gt;<br>&gt; Hahaha, that&#39;s a very different interpretation of “such” that I hadn&#39;t<br>&gt; considered!  OK, suppose it was “soEach:” ?<br>&gt;<br>&gt;     let primes = xs.filter(soEach: isPrime)<br>&gt;<br>&gt; &gt; I&#39;d suggest that if you want to be perfectly clear, you&#39;d need something<br>&gt; &gt; like `filter(keepingWhere:)`.<br>&gt;<br>&gt;     let primes = xs.filter(keepingWhere: isPrime)<br>&gt;<br>&gt; A slight problem is that filter is nonmutating, so all elements are<br>&gt; “kept.”  But maybe that&#39;s just Dave being overly concerned with unlikely<br>&gt; misinterpretations at the cost of “naturalness.”<br>&gt;<br>&gt; Further thoughts?<br>&gt;<br>&gt; &gt; On Wed, Jun 22, 2016 at 18:33 Dave Abrahams via swift-evolution &lt;<br>&gt; &gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; on Tue Jun 21 2016, Dave Abrahams &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt; on Mon Jun 20 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; wrote:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; A couple of weeks ago we started to notice that we had some<br>&gt; &gt;&gt; poorly-named<br>&gt; &gt;&gt; &gt;&gt;&gt; closure parameters and argument labels in the standard library, so<br>&gt; we<br>&gt; &gt;&gt; &gt;&gt;&gt; did a complete audit of the standard library&#39;s APIs and came up<br>&gt; with a<br>&gt; &gt;&gt; &gt;&gt;&gt; preliminary proposal for changes, which we applied in a branch and<br>&gt; you<br>&gt; &gt;&gt; &gt;&gt;&gt; can review in https://github.com/apple/swift/pull/2981.  Let&#39;s<br>&gt; please<br>&gt; &gt;&gt; &gt;&gt;&gt; carry on further discussion here rather than in the pull request,<br>&gt; &gt;&gt; though.<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; In general, I like this; `orderingBy` is a particularly nice<br>&gt; &gt;&gt; &gt;&gt; improvement over the old `isOrderedBefore` convention.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; I don&#39;t really love the use of “by”, FWIW, but I thought<br>&gt; `orderingWith`<br>&gt; &gt;&gt; &gt; was more confusable (ordering A with B might swap A and B, whereas the<br>&gt; &gt;&gt; &gt; parameter is a closure).  It could be argued, though, that I am being<br>&gt; &gt;&gt; &gt; overly concerned with unlikely misinterpretations, at the cost of<br>&gt; &gt;&gt; &gt; “naturalness”—a known weakness of mine ;-).  Anyway, as ever I&#39;m open<br>&gt; to<br>&gt; &gt;&gt; &gt; discussion on this.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;&gt; A few specific comments about things I don&#39;t like:<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; * In `map` and `flatMap`, I&#39;m not sure how much `transform` buys us<br>&gt; &gt;&gt; &gt;&gt;   over `elementTransform`.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; I think you mean the converse.  And I agree that `elementTransform`<br>&gt; &gt;&gt; &gt; is probably not an improvement over `transform`.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ...and I&#39;ve gone back to `transform` in my PR.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; * In general, I&#39;m not a fan of most of the changes away from `where`<br>&gt; &gt;&gt; &gt;&gt; labels.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; The only such changes I can find are in<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; https://github.com/apple/swift/pull/2981/commits/3418eede88d724ad23731fe8f412f51e03cf5106<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; Note that part of this change was to make all filter closures<br>&gt; &gt;&gt; &gt; consistent; in the main `filter` API there was no label at all.<br>&gt; &gt;&gt; &gt; However, we felt that there&#39;s a real clarity problem with the polarity<br>&gt; &gt;&gt; &gt; of the argument (we talk about “filtering things out” but the closure<br>&gt; &gt;&gt; &gt; indicates which elements to keep).  And we couldn&#39;t find a<br>&gt; “where”-based<br>&gt; &gt;&gt; &gt; name that began to clarify it.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; I will argue that even changing to “suchThat,” as in the PR, does not<br>&gt; &gt;&gt; &gt; sufficiently clarify the closure&#39;s polarity, and the only true fix for<br>&gt; &gt;&gt; &gt; filter is to use a different base name (some have suggested “select,”<br>&gt; &gt;&gt; &gt; and I have other ideas), but that is out of scope for this particular<br>&gt; &gt;&gt; &gt; set of changes.  So if the community is happier with a “where” label<br>&gt; &gt;&gt; &gt; here I can live with it.  I do think “suchThat” is marginally clearer.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I have not received any further pushback on “suchThat,” so I&#39;ve left it<br>&gt; &gt;&gt; alone.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;&gt; Those are a nice, straightforward convention applied broadly across<br>&gt; &gt;&gt; &gt;&gt; the Sequence APIs. (Yes, I criticized `where` as a method name in<br>&gt; &gt;&gt; &gt;&gt; another thread, but I don&#39;t think `where` is a problem when there&#39;s a<br>&gt; &gt;&gt; &gt;&gt; function base name to give it context.) When they don&#39;t work, that&#39;s<br>&gt; &gt;&gt; &gt;&gt; usually because of a less-than-ideal base name. I&#39;m not saying that<br>&gt; &gt;&gt; &gt;&gt; *all* base names that aren&#39;t compatible with `where` should be<br>&gt; &gt;&gt; &gt;&gt; changed, but rather that if `where` is not enough, that&#39;s an API<br>&gt; &gt;&gt; &gt;&gt; smell.<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; * In particular, `elementWhere` is not a good label for the same<br>&gt; &gt;&gt; &gt;&gt; reason that `removeElement` is not a good name. Session 403 last week<br>&gt; &gt;&gt; &gt;&gt; actually talked about this between roughly minutes 8 and 11. (I&#39;m<br>&gt; sure<br>&gt; &gt;&gt; &gt;&gt; you know about its content; you probably saw it before we did.)<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; Yes I do, and I think you misinterpreted the message in that session.<br>&gt; &gt;&gt; &gt; There&#39;s nothing wrong with repeating type information when it&#39;s<br>&gt; &gt;&gt; &gt; necessary for clarity or fluency at the use-site.  In the case of<br>&gt; &gt;&gt; &gt; `contains(elementWhere:)`, it&#39;s there for fluency:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;        customers.contains(where: isSingle)<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; doesn&#39;t read as well as:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;        customers.contains(elementWhere: isSingle)<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; The point is not to imagine that every argument should be preceded by<br>&gt; &gt;&gt; &gt; a noun, and repetition of type information is often the result of<br>&gt; &gt;&gt; &gt; trying to do that.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;&gt; * I like `separatedWhere` on `split`, but I think the Equatable<br>&gt; &gt;&gt; &gt;&gt; version needs a similar renaming.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; That&#39;s a nice thought; I think it&#39;s arguably out-of-scope here,<br>&gt; though.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;&gt; Perhaps `separatedBy`?  `separatedOn`? The usual opposite of `where`,<br>&gt; &gt;&gt; &gt;&gt; `of`, doesn&#39;t work here. (Alternatively, `separatedWhere` could be<br>&gt; &gt;&gt; &gt;&gt; `separatorWhere` instead, but that&#39;s not quite as elegant.)<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; I&#39;d want to consider variations of `separatingAt` or `onSeparator` or<br>&gt; &gt;&gt; &gt; `atSeparator` too... which makes me thing “separatedWhere” might not<br>&gt; be<br>&gt; &gt;&gt; &gt; as good as “separatingWhere” for the closure version.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;&gt; * I&#39;m very uncomfortable with the amount of weight<br>&gt; &gt;&gt; &gt;&gt; `accumulatingResultBy` adds to `reduce`. `combinedBy` seems perfectly<br>&gt; &gt;&gt; &gt;&gt; cromulent to me. I&#39;m even more concerned by your suggestion in the<br>&gt; &gt;&gt; &gt;&gt; pull request body of<br>&gt; &gt;&gt; &gt;&gt; `accumulating(startingFrom:combiningBy:)`. `reduce` is a subtle and<br>&gt; &gt;&gt; &gt;&gt; slightly confusing operation; adding more words to its call sites<br>&gt; will<br>&gt; &gt;&gt; &gt;&gt; not solve that problem. If you want to invent a new name from whole<br>&gt; &gt;&gt; &gt;&gt; cloth, I would probably use something like `combining(with<br>&gt; &gt;&gt; &gt;&gt; initialResult: T, by nextResult: (T, Element) -&gt; T)`. (For that<br>&gt; &gt;&gt; &gt;&gt; matter, while we&#39;re working in this area, `sequence(first:next:)`<br>&gt; &gt;&gt; &gt;&gt; could use a similar coat of paint.)<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; As with `filter(suchThat:`, `reduce(accumulatingResultBy:` is<br>&gt; attempting<br>&gt; &gt;&gt; &gt; to solve with an argument label what IMO is a grave weakness in<br>&gt; clarity<br>&gt; &gt;&gt; &gt; of the base name.  If you read the documentation for `reduce`, you&#39;ll<br>&gt; &gt;&gt; &gt; see that it&#39;s all about accumulating a result, and if you consider<br>&gt; that<br>&gt; &gt;&gt; &gt; its current signature often leads to O(N^2) behavior and we are<br>&gt; thinking<br>&gt; &gt;&gt; &gt; about adding an overload that takes its “accumulator” inout, the<br>&gt; &gt;&gt; &gt; arguments for avoiding the name “accumulate” get progressively weaker.<br>&gt; &gt;&gt; &gt; But as noted earlier, changing base names is out-of-scope for this<br>&gt; &gt;&gt; &gt; proposal.  As with “filter,” I could live with leaving this alone,<br>&gt; &gt;&gt; &gt; though I do believe “accumulatingResultBy:” is a real improvement in<br>&gt; &gt;&gt; &gt; clarity.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ...but I think it&#39;s overly specific at the expense of smoothness.  So<br>&gt; &gt;&gt; I&#39;ve removed `Result` from that name.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; * I agree with the comment on GitHub that `invoke` should be<br>&gt; &gt;&gt; &gt;&gt; `execute`.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; Why?  Rationales help.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;&gt; If you see a distinction between the two cases on the number of<br>&gt; &gt;&gt; &gt;&gt; arguments, I would then suggest `passTo` as the label on these<br>&gt; &gt;&gt; &gt;&gt; methods: `views.forEach(passTo: addSubview)`,<br>&gt; &gt;&gt; &gt;&gt; `withUnsafeBufferPointer(&amp;bytes, passTo: Data.init(buffer:))`.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; Those are intriguing ideas, but that direction tends to suggest this<br>&gt; &gt;&gt; &gt; would be better:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;   views.passEach(to: addSubview)<br>&gt; &gt;&gt; &gt;   passUnsafeBufferPointer(to: Data.init(buffer:))<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; ...until you pass a trailing closure:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;   views.passEach { addSubView($0) }<br>&gt; &gt;&gt; &gt;   passUnsafeBufferPointer { Data.init(buffer:$0) }<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; (note: withUnsafeBufferPointer takes only one argument, a closure).<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; * It&#39;s a little odd that you&#39;re using `comparingBy` for `Equatable`<br>&gt; &gt;&gt; &gt;&gt; and `orderingBy` for `Comparable`. Did you judge `equatingBy` to be<br>&gt; &gt;&gt; &gt;&gt; too awkward?<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; Yes, and because it&#39;s not “equating,” which would mean using equality<br>&gt; &gt;&gt; &gt; (==) it&#39;s “testing equivalence” with respect to the predicate.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;&gt; Perhaps the real problem is that `Equatable` ought to be `Comparable`<br>&gt; &gt;&gt; &gt;&gt; and `Comparable` ought to be `Orderable`?<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; I don&#39;t think so, personally, but regardless I consider such a change<br>&gt; &gt;&gt; &gt; out-of-scope for this proposal.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;&gt; Or maybe `comparingBy` should just be something more general, like<br>&gt; &gt;&gt; &gt;&gt; `matchingBy`? That would make perfectly sensible but slightly odd use<br>&gt; &gt;&gt; &gt;&gt; cases like this one read better:<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;      let isAnIdiot = luggageCombination.starts(with: [1, 2, 3, 4,<br>&gt; &gt;&gt; &gt;&gt; 5], matchingBy: &lt;=) // Matches [1,2,3,4,5], but also [1,1,1,1,1],<br>&gt; &gt;&gt; &gt;&gt; [1,2,3,2,1], etc.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; That would not be legal, as &lt;= is not an equivalence relation.  You<br>&gt; &gt;&gt; &gt; could think about redefining the meaning of `starts(with:` to not<br>&gt; &gt;&gt; &gt; require an equivalence relation, but that&#39;s something I&#39;m not<br>&gt; confident<br>&gt; &gt;&gt; &gt; *I* know how to do meaningfully, and regardless is again out-of-scope.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;&gt; Very soon (hopefully), I will be posting an early draft of a proposal<br>&gt; &gt;&gt; &gt;&gt; renaming the various first/last/prefix/suffix/etc. APIs. I believe<br>&gt; the<br>&gt; &gt;&gt; &gt;&gt; only place it touches on your proposal is in<br>&gt; &gt;&gt; &gt;&gt; `starts(with:isEquivalent:)`, but I think your changes to the second<br>&gt; &gt;&gt; &gt;&gt; parameter label can be easily incorporated into what I&#39;m doing.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; Great!<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I&#39;m going to write up the proposal ASAP based on the current PR unless I<br>&gt; &gt;&gt; get more feedback.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Thanks,<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; Dave<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/8853c49f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June 22, 2016 at 08:00:00pm</p></header><div class="content"><p>How about:<br></p><p>let results = possibilities.where(matching: closure)<br></p><p>:)<br></p><p>l8r<br>Sean <br></p><p>Sent from my iPad<br></p><p>&gt; On Jun 22, 2016, at 8:00 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; filter(extractingWhere:)<br>&gt;&gt; On Wed, Jun 22, 2016 at 18:53 Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; on Wed Jun 22 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; I&#39;ll duly oblige with some pushback on `suchThat`. I get that you&#39;re trying<br>&gt;&gt; &gt; to clarify whether filter retains or gets rid of elements that match the<br>&gt;&gt; &gt; predicate, but I don&#39;t think &quot;filter such that&quot; expresses this idea at all.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Comparing to &quot;filter where,&quot; &quot;filter such that&quot; is equally susceptible to<br>&gt;&gt; &gt; misinterpretation that you are filtering to remove elements that are<br>&gt;&gt; &gt; matched. For example: &quot;find me some apples, filtering such that are<br>&gt;&gt; &gt; bruised.&quot;<br>&gt;&gt; <br>&gt;&gt; Hahaha, that&#39;s a very different interpretation of “such” that I hadn&#39;t<br>&gt;&gt; considered!  OK, suppose it was “soEach:” ?<br>&gt;&gt; <br>&gt;&gt;     let primes = xs.filter(soEach: isPrime)<br>&gt;&gt; <br>&gt;&gt; &gt; I&#39;d suggest that if you want to be perfectly clear, you&#39;d need something<br>&gt;&gt; &gt; like `filter(keepingWhere:)`.<br>&gt;&gt; <br>&gt;&gt;     let primes = xs.filter(keepingWhere: isPrime)<br>&gt;&gt; <br>&gt;&gt; A slight problem is that filter is nonmutating, so all elements are<br>&gt;&gt; “kept.”  But maybe that&#39;s just Dave being overly concerned with unlikely<br>&gt;&gt; misinterpretations at the cost of “naturalness.”<br>&gt;&gt; <br>&gt;&gt; Further thoughts?<br>&gt;&gt; <br>&gt;&gt; &gt; On Wed, Jun 22, 2016 at 18:33 Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; &gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; on Tue Jun 21 2016, Dave Abrahams &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt; on Mon Jun 20 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt; wrote:<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;&gt; A couple of weeks ago we started to notice that we had some<br>&gt;&gt; &gt;&gt; poorly-named<br>&gt;&gt; &gt;&gt; &gt;&gt;&gt; closure parameters and argument labels in the standard library, so we<br>&gt;&gt; &gt;&gt; &gt;&gt;&gt; did a complete audit of the standard library&#39;s APIs and came up with a<br>&gt;&gt; &gt;&gt; &gt;&gt;&gt; preliminary proposal for changes, which we applied in a branch and you<br>&gt;&gt; &gt;&gt; &gt;&gt;&gt; can review in https://github.com/apple/swift/pull/2981.  Let&#39;s please<br>&gt;&gt; &gt;&gt; &gt;&gt;&gt; carry on further discussion here rather than in the pull request,<br>&gt;&gt; &gt;&gt; though.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; In general, I like this; `orderingBy` is a particularly nice<br>&gt;&gt; &gt;&gt; &gt;&gt; improvement over the old `isOrderedBefore` convention.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; I don&#39;t really love the use of “by”, FWIW, but I thought `orderingWith`<br>&gt;&gt; &gt;&gt; &gt; was more confusable (ordering A with B might swap A and B, whereas the<br>&gt;&gt; &gt;&gt; &gt; parameter is a closure).  It could be argued, though, that I am being<br>&gt;&gt; &gt;&gt; &gt; overly concerned with unlikely misinterpretations, at the cost of<br>&gt;&gt; &gt;&gt; &gt; “naturalness”—a known weakness of mine ;-).  Anyway, as ever I&#39;m open to<br>&gt;&gt; &gt;&gt; &gt; discussion on this.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; A few specific comments about things I don&#39;t like:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; * In `map` and `flatMap`, I&#39;m not sure how much `transform` buys us<br>&gt;&gt; &gt;&gt; &gt;&gt;   over `elementTransform`.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; I think you mean the converse.  And I agree that `elementTransform`<br>&gt;&gt; &gt;&gt; &gt; is probably not an improvement over `transform`.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; ...and I&#39;ve gone back to `transform` in my PR.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; * In general, I&#39;m not a fan of most of the changes away from `where`<br>&gt;&gt; &gt;&gt; &gt;&gt; labels.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; The only such changes I can find are in<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; https://github.com/apple/swift/pull/2981/commits/3418eede88d724ad23731fe8f412f51e03cf5106<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Note that part of this change was to make all filter closures<br>&gt;&gt; &gt;&gt; &gt; consistent; in the main `filter` API there was no label at all.<br>&gt;&gt; &gt;&gt; &gt; However, we felt that there&#39;s a real clarity problem with the polarity<br>&gt;&gt; &gt;&gt; &gt; of the argument (we talk about “filtering things out” but the closure<br>&gt;&gt; &gt;&gt; &gt; indicates which elements to keep).  And we couldn&#39;t find a “where”-based<br>&gt;&gt; &gt;&gt; &gt; name that began to clarify it.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; I will argue that even changing to “suchThat,” as in the PR, does not<br>&gt;&gt; &gt;&gt; &gt; sufficiently clarify the closure&#39;s polarity, and the only true fix for<br>&gt;&gt; &gt;&gt; &gt; filter is to use a different base name (some have suggested “select,”<br>&gt;&gt; &gt;&gt; &gt; and I have other ideas), but that is out of scope for this particular<br>&gt;&gt; &gt;&gt; &gt; set of changes.  So if the community is happier with a “where” label<br>&gt;&gt; &gt;&gt; &gt; here I can live with it.  I do think “suchThat” is marginally clearer.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I have not received any further pushback on “suchThat,” so I&#39;ve left it<br>&gt;&gt; &gt;&gt; alone.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Those are a nice, straightforward convention applied broadly across<br>&gt;&gt; &gt;&gt; &gt;&gt; the Sequence APIs. (Yes, I criticized `where` as a method name in<br>&gt;&gt; &gt;&gt; &gt;&gt; another thread, but I don&#39;t think `where` is a problem when there&#39;s a<br>&gt;&gt; &gt;&gt; &gt;&gt; function base name to give it context.) When they don&#39;t work, that&#39;s<br>&gt;&gt; &gt;&gt; &gt;&gt; usually because of a less-than-ideal base name. I&#39;m not saying that<br>&gt;&gt; &gt;&gt; &gt;&gt; *all* base names that aren&#39;t compatible with `where` should be<br>&gt;&gt; &gt;&gt; &gt;&gt; changed, but rather that if `where` is not enough, that&#39;s an API<br>&gt;&gt; &gt;&gt; &gt;&gt; smell.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; * In particular, `elementWhere` is not a good label for the same<br>&gt;&gt; &gt;&gt; &gt;&gt; reason that `removeElement` is not a good name. Session 403 last week<br>&gt;&gt; &gt;&gt; &gt;&gt; actually talked about this between roughly minutes 8 and 11. (I&#39;m sure<br>&gt;&gt; &gt;&gt; &gt;&gt; you know about its content; you probably saw it before we did.)<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Yes I do, and I think you misinterpreted the message in that session.<br>&gt;&gt; &gt;&gt; &gt; There&#39;s nothing wrong with repeating type information when it&#39;s<br>&gt;&gt; &gt;&gt; &gt; necessary for clarity or fluency at the use-site.  In the case of<br>&gt;&gt; &gt;&gt; &gt; `contains(elementWhere:)`, it&#39;s there for fluency:<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;        customers.contains(where: isSingle)<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; doesn&#39;t read as well as:<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;        customers.contains(elementWhere: isSingle)<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; The point is not to imagine that every argument should be preceded by<br>&gt;&gt; &gt;&gt; &gt; a noun, and repetition of type information is often the result of<br>&gt;&gt; &gt;&gt; &gt; trying to do that.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; * I like `separatedWhere` on `split`, but I think the Equatable<br>&gt;&gt; &gt;&gt; &gt;&gt; version needs a similar renaming.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; That&#39;s a nice thought; I think it&#39;s arguably out-of-scope here, though.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Perhaps `separatedBy`?  `separatedOn`? The usual opposite of `where`,<br>&gt;&gt; &gt;&gt; &gt;&gt; `of`, doesn&#39;t work here. (Alternatively, `separatedWhere` could be<br>&gt;&gt; &gt;&gt; &gt;&gt; `separatorWhere` instead, but that&#39;s not quite as elegant.)<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; I&#39;d want to consider variations of `separatingAt` or `onSeparator` or<br>&gt;&gt; &gt;&gt; &gt; `atSeparator` too... which makes me thing “separatedWhere” might not be<br>&gt;&gt; &gt;&gt; &gt; as good as “separatingWhere” for the closure version.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; * I&#39;m very uncomfortable with the amount of weight<br>&gt;&gt; &gt;&gt; &gt;&gt; `accumulatingResultBy` adds to `reduce`. `combinedBy` seems perfectly<br>&gt;&gt; &gt;&gt; &gt;&gt; cromulent to me. I&#39;m even more concerned by your suggestion in the<br>&gt;&gt; &gt;&gt; &gt;&gt; pull request body of<br>&gt;&gt; &gt;&gt; &gt;&gt; `accumulating(startingFrom:combiningBy:)`. `reduce` is a subtle and<br>&gt;&gt; &gt;&gt; &gt;&gt; slightly confusing operation; adding more words to its call sites will<br>&gt;&gt; &gt;&gt; &gt;&gt; not solve that problem. If you want to invent a new name from whole<br>&gt;&gt; &gt;&gt; &gt;&gt; cloth, I would probably use something like `combining(with<br>&gt;&gt; &gt;&gt; &gt;&gt; initialResult: T, by nextResult: (T, Element) -&gt; T)`. (For that<br>&gt;&gt; &gt;&gt; &gt;&gt; matter, while we&#39;re working in this area, `sequence(first:next:)`<br>&gt;&gt; &gt;&gt; &gt;&gt; could use a similar coat of paint.)<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; As with `filter(suchThat:`, `reduce(accumulatingResultBy:` is attempting<br>&gt;&gt; &gt;&gt; &gt; to solve with an argument label what IMO is a grave weakness in clarity<br>&gt;&gt; &gt;&gt; &gt; of the base name.  If you read the documentation for `reduce`, you&#39;ll<br>&gt;&gt; &gt;&gt; &gt; see that it&#39;s all about accumulating a result, and if you consider that<br>&gt;&gt; &gt;&gt; &gt; its current signature often leads to O(N^2) behavior and we are thinking<br>&gt;&gt; &gt;&gt; &gt; about adding an overload that takes its “accumulator” inout, the<br>&gt;&gt; &gt;&gt; &gt; arguments for avoiding the name “accumulate” get progressively weaker.<br>&gt;&gt; &gt;&gt; &gt; But as noted earlier, changing base names is out-of-scope for this<br>&gt;&gt; &gt;&gt; &gt; proposal.  As with “filter,” I could live with leaving this alone,<br>&gt;&gt; &gt;&gt; &gt; though I do believe “accumulatingResultBy:” is a real improvement in<br>&gt;&gt; &gt;&gt; &gt; clarity.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; ...but I think it&#39;s overly specific at the expense of smoothness.  So<br>&gt;&gt; &gt;&gt; I&#39;ve removed `Result` from that name.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; * I agree with the comment on GitHub that `invoke` should be<br>&gt;&gt; &gt;&gt; &gt;&gt; `execute`.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Why?  Rationales help.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; If you see a distinction between the two cases on the number of<br>&gt;&gt; &gt;&gt; &gt;&gt; arguments, I would then suggest `passTo` as the label on these<br>&gt;&gt; &gt;&gt; &gt;&gt; methods: `views.forEach(passTo: addSubview)`,<br>&gt;&gt; &gt;&gt; &gt;&gt; `withUnsafeBufferPointer(&amp;bytes, passTo: Data.init(buffer:))`.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Those are intriguing ideas, but that direction tends to suggest this<br>&gt;&gt; &gt;&gt; &gt; would be better:<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;   views.passEach(to: addSubview)<br>&gt;&gt; &gt;&gt; &gt;   passUnsafeBufferPointer(to: Data.init(buffer:))<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; ...until you pass a trailing closure:<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;   views.passEach { addSubView($0) }<br>&gt;&gt; &gt;&gt; &gt;   passUnsafeBufferPointer { Data.init(buffer:$0) }<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; (note: withUnsafeBufferPointer takes only one argument, a closure).<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; * It&#39;s a little odd that you&#39;re using `comparingBy` for `Equatable`<br>&gt;&gt; &gt;&gt; &gt;&gt; and `orderingBy` for `Comparable`. Did you judge `equatingBy` to be<br>&gt;&gt; &gt;&gt; &gt;&gt; too awkward?<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Yes, and because it&#39;s not “equating,” which would mean using equality<br>&gt;&gt; &gt;&gt; &gt; (==) it&#39;s “testing equivalence” with respect to the predicate.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Perhaps the real problem is that `Equatable` ought to be `Comparable`<br>&gt;&gt; &gt;&gt; &gt;&gt; and `Comparable` ought to be `Orderable`?<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; I don&#39;t think so, personally, but regardless I consider such a change<br>&gt;&gt; &gt;&gt; &gt; out-of-scope for this proposal.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Or maybe `comparingBy` should just be something more general, like<br>&gt;&gt; &gt;&gt; &gt;&gt; `matchingBy`? That would make perfectly sensible but slightly odd use<br>&gt;&gt; &gt;&gt; &gt;&gt; cases like this one read better:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;      let isAnIdiot = luggageCombination.starts(with: [1, 2, 3, 4,<br>&gt;&gt; &gt;&gt; &gt;&gt; 5], matchingBy: &lt;=) // Matches [1,2,3,4,5], but also [1,1,1,1,1],<br>&gt;&gt; &gt;&gt; &gt;&gt; [1,2,3,2,1], etc.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; That would not be legal, as &lt;= is not an equivalence relation.  You<br>&gt;&gt; &gt;&gt; &gt; could think about redefining the meaning of `starts(with:` to not<br>&gt;&gt; &gt;&gt; &gt; require an equivalence relation, but that&#39;s something I&#39;m not confident<br>&gt;&gt; &gt;&gt; &gt; *I* know how to do meaningfully, and regardless is again out-of-scope.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Very soon (hopefully), I will be posting an early draft of a proposal<br>&gt;&gt; &gt;&gt; &gt;&gt; renaming the various first/last/prefix/suffix/etc. APIs. I believe the<br>&gt;&gt; &gt;&gt; &gt;&gt; only place it touches on your proposal is in<br>&gt;&gt; &gt;&gt; &gt;&gt; `starts(with:isEquivalent:)`, but I think your changes to the second<br>&gt;&gt; &gt;&gt; &gt;&gt; parameter label can be easily incorporated into what I&#39;m doing.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Great!<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I&#39;m going to write up the proposal ASAP based on the current PR unless I<br>&gt;&gt; &gt;&gt; get more feedback.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Thanks,<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; --<br>&gt;&gt; &gt;&gt; Dave<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/9c1bd1a8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 22, 2016 at 08:00:00pm</p></header><div class="content"><p>On Wed, Jun 22, 2016 at 8:12 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br></p><p>&gt; How about:<br>&gt;<br>&gt; let results = possibilities.where(matching: closure)<br>&gt;<br></p><p>My understanding is that we&#39;re restricting the bikeshedding here to the<br>closure label. Renaming `filter` is discussed in another thread, though<br>obviously that would change the name of the label as well.<br></p><p><br>&gt;<br>&gt; :)<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Jun 22, 2016, at 8:00 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; filter(extractingWhere:)<br>&gt; On Wed, Jun 22, 2016 at 18:53 Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Wed Jun 22 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; I&#39;ll duly oblige with some pushback on `suchThat`. I get that you&#39;re<br>&gt;&gt; trying<br>&gt;&gt; &gt; to clarify whether filter retains or gets rid of elements that match the<br>&gt;&gt; &gt; predicate, but I don&#39;t think &quot;filter such that&quot; expresses this idea at<br>&gt;&gt; all.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Comparing to &quot;filter where,&quot; &quot;filter such that&quot; is equally susceptible<br>&gt;&gt; to<br>&gt;&gt; &gt; misinterpretation that you are filtering to remove elements that are<br>&gt;&gt; &gt; matched. For example: &quot;find me some apples, filtering such that are<br>&gt;&gt; &gt; bruised.&quot;<br>&gt;&gt;<br>&gt;&gt; Hahaha, that&#39;s a very different interpretation of “such” that I hadn&#39;t<br>&gt;&gt; considered!  OK, suppose it was “soEach:” ?<br>&gt;&gt;<br>&gt;&gt;     let primes = xs.filter(soEach: isPrime)<br>&gt;&gt;<br>&gt;&gt; &gt; I&#39;d suggest that if you want to be perfectly clear, you&#39;d need something<br>&gt;&gt; &gt; like `filter(keepingWhere:)`.<br>&gt;&gt;<br>&gt;&gt;     let primes = xs.filter(keepingWhere: isPrime)<br>&gt;&gt;<br>&gt;&gt; A slight problem is that filter is nonmutating, so all elements are<br>&gt;&gt; “kept.”  But maybe that&#39;s just Dave being overly concerned with unlikely<br>&gt;&gt; misinterpretations at the cost of “naturalness.”<br>&gt;&gt;<br>&gt;&gt; Further thoughts?<br>&gt;&gt;<br>&gt;&gt; &gt; On Wed, Jun 22, 2016 at 18:33 Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; &gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; on Tue Jun 21 2016, Dave Abrahams &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt; on Mon Jun 20 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt; wrote:<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;&gt; A couple of weeks ago we started to notice that we had some<br>&gt;&gt; &gt;&gt; poorly-named<br>&gt;&gt; &gt;&gt; &gt;&gt;&gt; closure parameters and argument labels in the standard library, so<br>&gt;&gt; we<br>&gt;&gt; &gt;&gt; &gt;&gt;&gt; did a complete audit of the standard library&#39;s APIs and came up<br>&gt;&gt; with a<br>&gt;&gt; &gt;&gt; &gt;&gt;&gt; preliminary proposal for changes, which we applied in a branch and<br>&gt;&gt; you<br>&gt;&gt; &gt;&gt; &gt;&gt;&gt; can review in https://github.com/apple/swift/pull/2981.  Let&#39;s<br>&gt;&gt; please<br>&gt;&gt; &gt;&gt; &gt;&gt;&gt; carry on further discussion here rather than in the pull request,<br>&gt;&gt; &gt;&gt; though.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; In general, I like this; `orderingBy` is a particularly nice<br>&gt;&gt; &gt;&gt; &gt;&gt; improvement over the old `isOrderedBefore` convention.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; I don&#39;t really love the use of “by”, FWIW, but I thought<br>&gt;&gt; `orderingWith`<br>&gt;&gt; &gt;&gt; &gt; was more confusable (ordering A with B might swap A and B, whereas<br>&gt;&gt; the<br>&gt;&gt; &gt;&gt; &gt; parameter is a closure).  It could be argued, though, that I am being<br>&gt;&gt; &gt;&gt; &gt; overly concerned with unlikely misinterpretations, at the cost of<br>&gt;&gt; &gt;&gt; &gt; “naturalness”—a known weakness of mine ;-).  Anyway, as ever I&#39;m<br>&gt;&gt; open to<br>&gt;&gt; &gt;&gt; &gt; discussion on this.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; A few specific comments about things I don&#39;t like:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; * In `map` and `flatMap`, I&#39;m not sure how much `transform` buys us<br>&gt;&gt; &gt;&gt; &gt;&gt;   over `elementTransform`.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; I think you mean the converse.  And I agree that `elementTransform`<br>&gt;&gt; &gt;&gt; &gt; is probably not an improvement over `transform`.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; ...and I&#39;ve gone back to `transform` in my PR.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; * In general, I&#39;m not a fan of most of the changes away from `where`<br>&gt;&gt; &gt;&gt; &gt;&gt; labels.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; The only such changes I can find are in<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; https://github.com/apple/swift/pull/2981/commits/3418eede88d724ad23731fe8f412f51e03cf5106<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Note that part of this change was to make all filter closures<br>&gt;&gt; &gt;&gt; &gt; consistent; in the main `filter` API there was no label at all.<br>&gt;&gt; &gt;&gt; &gt; However, we felt that there&#39;s a real clarity problem with the<br>&gt;&gt; polarity<br>&gt;&gt; &gt;&gt; &gt; of the argument (we talk about “filtering things out” but the closure<br>&gt;&gt; &gt;&gt; &gt; indicates which elements to keep).  And we couldn&#39;t find a<br>&gt;&gt; “where”-based<br>&gt;&gt; &gt;&gt; &gt; name that began to clarify it.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; I will argue that even changing to “suchThat,” as in the PR, does not<br>&gt;&gt; &gt;&gt; &gt; sufficiently clarify the closure&#39;s polarity, and the only true fix<br>&gt;&gt; for<br>&gt;&gt; &gt;&gt; &gt; filter is to use a different base name (some have suggested “select,”<br>&gt;&gt; &gt;&gt; &gt; and I have other ideas), but that is out of scope for this particular<br>&gt;&gt; &gt;&gt; &gt; set of changes.  So if the community is happier with a “where” label<br>&gt;&gt; &gt;&gt; &gt; here I can live with it.  I do think “suchThat” is marginally<br>&gt;&gt; clearer.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I have not received any further pushback on “suchThat,” so I&#39;ve left it<br>&gt;&gt; &gt;&gt; alone.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Those are a nice, straightforward convention applied broadly across<br>&gt;&gt; &gt;&gt; &gt;&gt; the Sequence APIs. (Yes, I criticized `where` as a method name in<br>&gt;&gt; &gt;&gt; &gt;&gt; another thread, but I don&#39;t think `where` is a problem when there&#39;s<br>&gt;&gt; a<br>&gt;&gt; &gt;&gt; &gt;&gt; function base name to give it context.) When they don&#39;t work, that&#39;s<br>&gt;&gt; &gt;&gt; &gt;&gt; usually because of a less-than-ideal base name. I&#39;m not saying that<br>&gt;&gt; &gt;&gt; &gt;&gt; *all* base names that aren&#39;t compatible with `where` should be<br>&gt;&gt; &gt;&gt; &gt;&gt; changed, but rather that if `where` is not enough, that&#39;s an API<br>&gt;&gt; &gt;&gt; &gt;&gt; smell.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; * In particular, `elementWhere` is not a good label for the same<br>&gt;&gt; &gt;&gt; &gt;&gt; reason that `removeElement` is not a good name. Session 403 last<br>&gt;&gt; week<br>&gt;&gt; &gt;&gt; &gt;&gt; actually talked about this between roughly minutes 8 and 11. (I&#39;m<br>&gt;&gt; sure<br>&gt;&gt; &gt;&gt; &gt;&gt; you know about its content; you probably saw it before we did.)<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Yes I do, and I think you misinterpreted the message in that session.<br>&gt;&gt; &gt;&gt; &gt; There&#39;s nothing wrong with repeating type information when it&#39;s<br>&gt;&gt; &gt;&gt; &gt; necessary for clarity or fluency at the use-site.  In the case of<br>&gt;&gt; &gt;&gt; &gt; `contains(elementWhere:)`, it&#39;s there for fluency:<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;        customers.contains(where: isSingle)<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; doesn&#39;t read as well as:<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;        customers.contains(elementWhere: isSingle)<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; The point is not to imagine that every argument should be preceded by<br>&gt;&gt; &gt;&gt; &gt; a noun, and repetition of type information is often the result of<br>&gt;&gt; &gt;&gt; &gt; trying to do that.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; * I like `separatedWhere` on `split`, but I think the Equatable<br>&gt;&gt; &gt;&gt; &gt;&gt; version needs a similar renaming.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; That&#39;s a nice thought; I think it&#39;s arguably out-of-scope here,<br>&gt;&gt; though.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Perhaps `separatedBy`?  `separatedOn`? The usual opposite of<br>&gt;&gt; `where`,<br>&gt;&gt; &gt;&gt; &gt;&gt; `of`, doesn&#39;t work here. (Alternatively, `separatedWhere` could be<br>&gt;&gt; &gt;&gt; &gt;&gt; `separatorWhere` instead, but that&#39;s not quite as elegant.)<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; I&#39;d want to consider variations of `separatingAt` or `onSeparator` or<br>&gt;&gt; &gt;&gt; &gt; `atSeparator` too... which makes me thing “separatedWhere” might not<br>&gt;&gt; be<br>&gt;&gt; &gt;&gt; &gt; as good as “separatingWhere” for the closure version.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; * I&#39;m very uncomfortable with the amount of weight<br>&gt;&gt; &gt;&gt; &gt;&gt; `accumulatingResultBy` adds to `reduce`. `combinedBy` seems<br>&gt;&gt; perfectly<br>&gt;&gt; &gt;&gt; &gt;&gt; cromulent to me. I&#39;m even more concerned by your suggestion in the<br>&gt;&gt; &gt;&gt; &gt;&gt; pull request body of<br>&gt;&gt; &gt;&gt; &gt;&gt; `accumulating(startingFrom:combiningBy:)`. `reduce` is a subtle and<br>&gt;&gt; &gt;&gt; &gt;&gt; slightly confusing operation; adding more words to its call sites<br>&gt;&gt; will<br>&gt;&gt; &gt;&gt; &gt;&gt; not solve that problem. If you want to invent a new name from whole<br>&gt;&gt; &gt;&gt; &gt;&gt; cloth, I would probably use something like `combining(with<br>&gt;&gt; &gt;&gt; &gt;&gt; initialResult: T, by nextResult: (T, Element) -&gt; T)`. (For that<br>&gt;&gt; &gt;&gt; &gt;&gt; matter, while we&#39;re working in this area, `sequence(first:next:)`<br>&gt;&gt; &gt;&gt; &gt;&gt; could use a similar coat of paint.)<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; As with `filter(suchThat:`, `reduce(accumulatingResultBy:` is<br>&gt;&gt; attempting<br>&gt;&gt; &gt;&gt; &gt; to solve with an argument label what IMO is a grave weakness in<br>&gt;&gt; clarity<br>&gt;&gt; &gt;&gt; &gt; of the base name.  If you read the documentation for `reduce`, you&#39;ll<br>&gt;&gt; &gt;&gt; &gt; see that it&#39;s all about accumulating a result, and if you consider<br>&gt;&gt; that<br>&gt;&gt; &gt;&gt; &gt; its current signature often leads to O(N^2) behavior and we are<br>&gt;&gt; thinking<br>&gt;&gt; &gt;&gt; &gt; about adding an overload that takes its “accumulator” inout, the<br>&gt;&gt; &gt;&gt; &gt; arguments for avoiding the name “accumulate” get progressively<br>&gt;&gt; weaker.<br>&gt;&gt; &gt;&gt; &gt; But as noted earlier, changing base names is out-of-scope for this<br>&gt;&gt; &gt;&gt; &gt; proposal.  As with “filter,” I could live with leaving this alone,<br>&gt;&gt; &gt;&gt; &gt; though I do believe “accumulatingResultBy:” is a real improvement in<br>&gt;&gt; &gt;&gt; &gt; clarity.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; ...but I think it&#39;s overly specific at the expense of smoothness.  So<br>&gt;&gt; &gt;&gt; I&#39;ve removed `Result` from that name.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; * I agree with the comment on GitHub that `invoke` should be<br>&gt;&gt; &gt;&gt; &gt;&gt; `execute`.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Why?  Rationales help.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; If you see a distinction between the two cases on the number of<br>&gt;&gt; &gt;&gt; &gt;&gt; arguments, I would then suggest `passTo` as the label on these<br>&gt;&gt; &gt;&gt; &gt;&gt; methods: `views.forEach(passTo: addSubview)`,<br>&gt;&gt; &gt;&gt; &gt;&gt; `withUnsafeBufferPointer(&amp;bytes, passTo: Data.init(buffer:))`.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Those are intriguing ideas, but that direction tends to suggest this<br>&gt;&gt; &gt;&gt; &gt; would be better:<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;   views.passEach(to: addSubview)<br>&gt;&gt; &gt;&gt; &gt;   passUnsafeBufferPointer(to: Data.init(buffer:))<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; ...until you pass a trailing closure:<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;   views.passEach { addSubView($0) }<br>&gt;&gt; &gt;&gt; &gt;   passUnsafeBufferPointer { Data.init(buffer:$0) }<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; (note: withUnsafeBufferPointer takes only one argument, a closure).<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; * It&#39;s a little odd that you&#39;re using `comparingBy` for `Equatable`<br>&gt;&gt; &gt;&gt; &gt;&gt; and `orderingBy` for `Comparable`. Did you judge `equatingBy` to be<br>&gt;&gt; &gt;&gt; &gt;&gt; too awkward?<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Yes, and because it&#39;s not “equating,” which would mean using equality<br>&gt;&gt; &gt;&gt; &gt; (==) it&#39;s “testing equivalence” with respect to the predicate.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Perhaps the real problem is that `Equatable` ought to be<br>&gt;&gt; `Comparable`<br>&gt;&gt; &gt;&gt; &gt;&gt; and `Comparable` ought to be `Orderable`?<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; I don&#39;t think so, personally, but regardless I consider such a change<br>&gt;&gt; &gt;&gt; &gt; out-of-scope for this proposal.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Or maybe `comparingBy` should just be something more general, like<br>&gt;&gt; &gt;&gt; &gt;&gt; `matchingBy`? That would make perfectly sensible but slightly odd<br>&gt;&gt; use<br>&gt;&gt; &gt;&gt; &gt;&gt; cases like this one read better:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt;      let isAnIdiot = luggageCombination.starts(with: [1, 2, 3, 4,<br>&gt;&gt; &gt;&gt; &gt;&gt; 5], matchingBy: &lt;=) // Matches [1,2,3,4,5], but also [1,1,1,1,1],<br>&gt;&gt; &gt;&gt; &gt;&gt; [1,2,3,2,1], etc.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; That would not be legal, as &lt;= is not an equivalence relation.  You<br>&gt;&gt; &gt;&gt; &gt; could think about redefining the meaning of `starts(with:` to not<br>&gt;&gt; &gt;&gt; &gt; require an equivalence relation, but that&#39;s something I&#39;m not<br>&gt;&gt; confident<br>&gt;&gt; &gt;&gt; &gt; *I* know how to do meaningfully, and regardless is again<br>&gt;&gt; out-of-scope.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; Very soon (hopefully), I will be posting an early draft of a<br>&gt;&gt; proposal<br>&gt;&gt; &gt;&gt; &gt;&gt; renaming the various first/last/prefix/suffix/etc. APIs. I believe<br>&gt;&gt; the<br>&gt;&gt; &gt;&gt; &gt;&gt; only place it touches on your proposal is in<br>&gt;&gt; &gt;&gt; &gt;&gt; `starts(with:isEquivalent:)`, but I think your changes to the second<br>&gt;&gt; &gt;&gt; &gt;&gt; parameter label can be easily incorporated into what I&#39;m doing.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Great!<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I&#39;m going to write up the proposal ASAP based on the current PR unless<br>&gt;&gt; I<br>&gt;&gt; &gt;&gt; get more feedback.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Thanks,<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; --<br>&gt;&gt; &gt;&gt; Dave<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/2fa06bf9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 25, 2016 at 02:00:00pm</p></header><div class="content"><p>on Wed Jun 22 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; On Wed, Jun 22, 2016 at 8:12 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;<br>&gt;&gt; How about:<br>&gt;&gt;<br>&gt;&gt; let results = possibilities.where(matching: closure)<br>&gt;&gt;<br>&gt;<br>&gt; My understanding is that we&#39;re restricting the bikeshedding here to the<br>&gt; closure label. Renaming `filter` is discussed in another thread, though<br>&gt; obviously that would change the name of the label as well.<br></p><p>Correct, thanks.<br></p><p>&gt;&gt;<br>&gt;&gt; :)<br>&gt;&gt;<br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On Jun 22, 2016, at 8:00 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; filter(extractingWhere:)<br>&gt;&gt; On Wed, Jun 22, 2016 at 18:53 Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; on Wed Jun 22 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; I&#39;ll duly oblige with some pushback on `suchThat`. I get that you&#39;re<br>&gt;&gt;&gt; trying<br>&gt;&gt;&gt; &gt; to clarify whether filter retains or gets rid of elements that match the<br>&gt;&gt;&gt; &gt; predicate, but I don&#39;t think &quot;filter such that&quot; expresses this idea at<br>&gt;&gt;&gt; all.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Comparing to &quot;filter where,&quot; &quot;filter such that&quot; is equally susceptible<br>&gt;&gt;&gt; to<br>&gt;&gt;&gt; &gt; misinterpretation that you are filtering to remove elements that are<br>&gt;&gt;&gt; &gt; matched. For example: &quot;find me some apples, filtering such that are<br>&gt;&gt;&gt; &gt; bruised.&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hahaha, that&#39;s a very different interpretation of “such” that I hadn&#39;t<br>&gt;&gt;&gt; considered!  OK, suppose it was “soEach:” ?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     let primes = xs.filter(soEach: isPrime)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; I&#39;d suggest that if you want to be perfectly clear, you&#39;d need something<br>&gt;&gt;&gt; &gt; like `filter(keepingWhere:)`.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     let primes = xs.filter(keepingWhere: isPrime)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; A slight problem is that filter is nonmutating, so all elements are<br>&gt;&gt;&gt; “kept.”  But maybe that&#39;s just Dave being overly concerned with unlikely<br>&gt;&gt;&gt; misinterpretations at the cost of “naturalness.”<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Further thoughts?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Wed, Jun 22, 2016 at 18:33 Dave Abrahams via swift-evolution &lt;<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; on Tue Jun 21 2016, Dave Abrahams &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; on Mon Jun 20 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;&gt; A couple of weeks ago we started to notice that we had some<br>&gt;&gt;&gt; &gt;&gt; poorly-named<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;&gt; closure parameters and argument labels in the standard library, so<br>&gt;&gt;&gt; we<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;&gt; did a complete audit of the standard library&#39;s APIs and came up<br>&gt;&gt;&gt; with a<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;&gt; preliminary proposal for changes, which we applied in a branch and<br>&gt;&gt;&gt; you<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;&gt; can review in https://github.com/apple/swift/pull/2981.  Let&#39;s<br>&gt;&gt;&gt; please<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;&gt; carry on further discussion here rather than in the pull request,<br>&gt;&gt;&gt; &gt;&gt; though.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; In general, I like this; `orderingBy` is a particularly nice<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; improvement over the old `isOrderedBefore` convention.<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; I don&#39;t really love the use of “by”, FWIW, but I thought<br>&gt;&gt;&gt; `orderingWith`<br>&gt;&gt;&gt; &gt;&gt; &gt; was more confusable (ordering A with B might swap A and B, whereas<br>&gt;&gt;&gt; the<br>&gt;&gt;&gt; &gt;&gt; &gt; parameter is a closure).  It could be argued, though, that I am being<br>&gt;&gt;&gt; &gt;&gt; &gt; overly concerned with unlikely misinterpretations, at the cost of<br>&gt;&gt;&gt; &gt;&gt; &gt; “naturalness”—a known weakness of mine ;-).  Anyway, as ever I&#39;m<br>&gt;&gt;&gt; open to<br>&gt;&gt;&gt; &gt;&gt; &gt; discussion on this.<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; A few specific comments about things I don&#39;t like:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; * In `map` and `flatMap`, I&#39;m not sure how much `transform` buys us<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;   over `elementTransform`.<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; I think you mean the converse.  And I agree that `elementTransform`<br>&gt;&gt;&gt; &gt;&gt; &gt; is probably not an improvement over `transform`.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; ...and I&#39;ve gone back to `transform` in my PR.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; * In general, I&#39;m not a fan of most of the changes away from `where`<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; labels.<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; The only such changes I can find are in<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; https://github.com/apple/swift/pull/2981/commits/3418eede88d724ad23731fe8f412f51e03cf5106<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; Note that part of this change was to make all filter closures<br>&gt;&gt;&gt; &gt;&gt; &gt; consistent; in the main `filter` API there was no label at all.<br>&gt;&gt;&gt; &gt;&gt; &gt; However, we felt that there&#39;s a real clarity problem with the<br>&gt;&gt;&gt; polarity<br>&gt;&gt;&gt; &gt;&gt; &gt; of the argument (we talk about “filtering things out” but the closure<br>&gt;&gt;&gt; &gt;&gt; &gt; indicates which elements to keep).  And we couldn&#39;t find a<br>&gt;&gt;&gt; “where”-based<br>&gt;&gt;&gt; &gt;&gt; &gt; name that began to clarify it.<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; I will argue that even changing to “suchThat,” as in the PR, does not<br>&gt;&gt;&gt; &gt;&gt; &gt; sufficiently clarify the closure&#39;s polarity, and the only true fix<br>&gt;&gt;&gt; for<br>&gt;&gt;&gt; &gt;&gt; &gt; filter is to use a different base name (some have suggested “select,”<br>&gt;&gt;&gt; &gt;&gt; &gt; and I have other ideas), but that is out of scope for this particular<br>&gt;&gt;&gt; &gt;&gt; &gt; set of changes.  So if the community is happier with a “where” label<br>&gt;&gt;&gt; &gt;&gt; &gt; here I can live with it.  I do think “suchThat” is marginally<br>&gt;&gt;&gt; clearer.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; I have not received any further pushback on “suchThat,” so I&#39;ve left it<br>&gt;&gt;&gt; &gt;&gt; alone.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Those are a nice, straightforward convention applied broadly across<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; the Sequence APIs. (Yes, I criticized `where` as a method name in<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; another thread, but I don&#39;t think `where` is a problem when there&#39;s<br>&gt;&gt;&gt; a<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; function base name to give it context.) When they don&#39;t work, that&#39;s<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; usually because of a less-than-ideal base name. I&#39;m not saying that<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; *all* base names that aren&#39;t compatible with `where` should be<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; changed, but rather that if `where` is not enough, that&#39;s an API<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; smell.<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; * In particular, `elementWhere` is not a good label for the same<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; reason that `removeElement` is not a good name. Session 403 last<br>&gt;&gt;&gt; week<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; actually talked about this between roughly minutes 8 and 11. (I&#39;m<br>&gt;&gt;&gt; sure<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; you know about its content; you probably saw it before we did.)<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; Yes I do, and I think you misinterpreted the message in that session.<br>&gt;&gt;&gt; &gt;&gt; &gt; There&#39;s nothing wrong with repeating type information when it&#39;s<br>&gt;&gt;&gt; &gt;&gt; &gt; necessary for clarity or fluency at the use-site.  In the case of<br>&gt;&gt;&gt; &gt;&gt; &gt; `contains(elementWhere:)`, it&#39;s there for fluency:<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;        customers.contains(where: isSingle)<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; doesn&#39;t read as well as:<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;        customers.contains(elementWhere: isSingle)<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; The point is not to imagine that every argument should be preceded by<br>&gt;&gt;&gt; &gt;&gt; &gt; a noun, and repetition of type information is often the result of<br>&gt;&gt;&gt; &gt;&gt; &gt; trying to do that.<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; * I like `separatedWhere` on `split`, but I think the Equatable<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; version needs a similar renaming.<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; That&#39;s a nice thought; I think it&#39;s arguably out-of-scope here,<br>&gt;&gt;&gt; though.<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Perhaps `separatedBy`?  `separatedOn`? The usual opposite of<br>&gt;&gt;&gt; `where`,<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; `of`, doesn&#39;t work here. (Alternatively, `separatedWhere` could be<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; `separatorWhere` instead, but that&#39;s not quite as elegant.)<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; I&#39;d want to consider variations of `separatingAt` or `onSeparator` or<br>&gt;&gt;&gt; &gt;&gt; &gt; `atSeparator` too... which makes me thing “separatedWhere” might not<br>&gt;&gt;&gt; be<br>&gt;&gt;&gt; &gt;&gt; &gt; as good as “separatingWhere” for the closure version.<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; * I&#39;m very uncomfortable with the amount of weight<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; `accumulatingResultBy` adds to `reduce`. `combinedBy` seems<br>&gt;&gt;&gt; perfectly<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; cromulent to me. I&#39;m even more concerned by your suggestion in the<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; pull request body of<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; `accumulating(startingFrom:combiningBy:)`. `reduce` is a subtle and<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; slightly confusing operation; adding more words to its call sites<br>&gt;&gt;&gt; will<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; not solve that problem. If you want to invent a new name from whole<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; cloth, I would probably use something like `combining(with<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; initialResult: T, by nextResult: (T, Element) -&gt; T)`. (For that<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; matter, while we&#39;re working in this area, `sequence(first:next:)`<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; could use a similar coat of paint.)<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; As with `filter(suchThat:`, `reduce(accumulatingResultBy:` is<br>&gt;&gt;&gt; attempting<br>&gt;&gt;&gt; &gt;&gt; &gt; to solve with an argument label what IMO is a grave weakness in<br>&gt;&gt;&gt; clarity<br>&gt;&gt;&gt; &gt;&gt; &gt; of the base name.  If you read the documentation for `reduce`, you&#39;ll<br>&gt;&gt;&gt; &gt;&gt; &gt; see that it&#39;s all about accumulating a result, and if you consider<br>&gt;&gt;&gt; that<br>&gt;&gt;&gt; &gt;&gt; &gt; its current signature often leads to O(N^2) behavior and we are<br>&gt;&gt;&gt; thinking<br>&gt;&gt;&gt; &gt;&gt; &gt; about adding an overload that takes its “accumulator” inout, the<br>&gt;&gt;&gt; &gt;&gt; &gt; arguments for avoiding the name “accumulate” get progressively<br>&gt;&gt;&gt; weaker.<br>&gt;&gt;&gt; &gt;&gt; &gt; But as noted earlier, changing base names is out-of-scope for this<br>&gt;&gt;&gt; &gt;&gt; &gt; proposal.  As with “filter,” I could live with leaving this alone,<br>&gt;&gt;&gt; &gt;&gt; &gt; though I do believe “accumulatingResultBy:” is a real improvement in<br>&gt;&gt;&gt; &gt;&gt; &gt; clarity.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; ...but I think it&#39;s overly specific at the expense of smoothness.  So<br>&gt;&gt;&gt; &gt;&gt; I&#39;ve removed `Result` from that name.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; * I agree with the comment on GitHub that `invoke` should be<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; `execute`.<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; Why?  Rationales help.<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; If you see a distinction between the two cases on the number of<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; arguments, I would then suggest `passTo` as the label on these<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; methods: `views.forEach(passTo: addSubview)`,<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; `withUnsafeBufferPointer(&amp;bytes, passTo: Data.init(buffer:))`.<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; Those are intriguing ideas, but that direction tends to suggest this<br>&gt;&gt;&gt; &gt;&gt; &gt; would be better:<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;   views.passEach(to: addSubview)<br>&gt;&gt;&gt; &gt;&gt; &gt;   passUnsafeBufferPointer(to: Data.init(buffer:))<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; ...until you pass a trailing closure:<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;   views.passEach { addSubView($0) }<br>&gt;&gt;&gt; &gt;&gt; &gt;   passUnsafeBufferPointer { Data.init(buffer:$0) }<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; (note: withUnsafeBufferPointer takes only one argument, a closure).<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; * It&#39;s a little odd that you&#39;re using `comparingBy` for `Equatable`<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; and `orderingBy` for `Comparable`. Did you judge `equatingBy` to be<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; too awkward?<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; Yes, and because it&#39;s not “equating,” which would mean using equality<br>&gt;&gt;&gt; &gt;&gt; &gt; (==) it&#39;s “testing equivalence” with respect to the predicate.<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Perhaps the real problem is that `Equatable` ought to be<br>&gt;&gt;&gt; `Comparable`<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; and `Comparable` ought to be `Orderable`?<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; I don&#39;t think so, personally, but regardless I consider such a change<br>&gt;&gt;&gt; &gt;&gt; &gt; out-of-scope for this proposal.<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Or maybe `comparingBy` should just be something more general, like<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; `matchingBy`? That would make perfectly sensible but slightly odd<br>&gt;&gt;&gt; use<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; cases like this one read better:<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt;      let isAnIdiot = luggageCombination.starts(with: [1, 2, 3, 4,<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; 5], matchingBy: &lt;=) // Matches [1,2,3,4,5], but also [1,1,1,1,1],<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; [1,2,3,2,1], etc.<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; That would not be legal, as &lt;= is not an equivalence relation.  You<br>&gt;&gt;&gt; &gt;&gt; &gt; could think about redefining the meaning of `starts(with:` to not<br>&gt;&gt;&gt; &gt;&gt; &gt; require an equivalence relation, but that&#39;s something I&#39;m not<br>&gt;&gt;&gt; confident<br>&gt;&gt;&gt; &gt;&gt; &gt; *I* know how to do meaningfully, and regardless is again<br>&gt;&gt;&gt; out-of-scope.<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; Very soon (hopefully), I will be posting an early draft of a<br>&gt;&gt;&gt; proposal<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; renaming the various first/last/prefix/suffix/etc. APIs. I believe<br>&gt;&gt;&gt; the<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; only place it touches on your proposal is in<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; `starts(with:isEquivalent:)`, but I think your changes to the second<br>&gt;&gt;&gt; &gt;&gt; &gt;&gt; parameter label can be easily incorporated into what I&#39;m doing.<br>&gt;&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; &gt; Great!<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; I&#39;m going to write up the proposal ASAP based on the current PR unless<br>&gt;&gt;&gt; I<br>&gt;&gt;&gt; &gt;&gt; get more feedback.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Thanks,<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; --<br>&gt;&gt;&gt; &gt;&gt; Dave<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
