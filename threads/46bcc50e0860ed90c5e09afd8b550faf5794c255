<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fd5bd4566ee1f286333b7dbf2df6fadb?s=50"></div><header><strong>[Review] SE-0145: Package Manager Version Pinning</strong> from <string>Anders Bertelrud</string> &lt;anders at apple.com&gt;<p>October 31, 2016 at 02:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of SE-0145 &quot;Package Manager Version Pinning&quot; begins now and runs through November 4. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0145-package-manager-version-pinning.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0145-package-manager-version-pinning.md&gt;<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br></p><p>Thank you,<br></p><p>Anders Bertelrud<br>Review Manager<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161031/46bcc255/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3a28b53f05e7f3067fb104cb78fbb585?s=50"></div><header><strong>[Review] SE-0145: Package Manager Version Pinning</strong> from <string>Kostiantyn Koval</string> &lt;konstantin.koval1 at gmail.com&gt;<p>November  2, 2016 at 07:00:00am</p></header><div class="content"><p>Hi Swift community<br></p><p>&gt; * What is your evaluation of the proposal?<br>The proposal looks good and it solves the addressed problems. Resolving dependency graph is not a trivial problem and I like how this proposal tackles 1 problem at the time.<br></p><p>&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br>Yes it does. With the &quot;Version Pinning&quot; it would be very convenient to share that information with others<br></p><p>&gt;  Does this proposal fit well with the feel and direction of Swift?<br>Yes it does. <br></p><p>&gt;  If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>Some other dependency managers choose to generate pin files by default. I feel it&#39;s a correct choice to make &quot;Pin file&quot; optional since SwiftPM requires a versioning tag for a dependency (which is option in others dependency managers I&#39;ve used)<br></p><p>&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>I tried to study more about dependency pinning and locking, how they are implemented tin other dependency manager and what impact they have.<br></p><p>Additional notes:<br>When I run swift package update on unpinned package, would it be possible to roll back to previously used dependencies?<br></p><p>Use case: Let&#39;s say I have a package with a dependency A<br>.Package(url: &quot;https://A.git&quot;, versions: Version(1,0,0)..&lt;Version(2,0,0)),<br></p><p>At first fetch I get A dependency with v1.0. Then I run `swift package update` and  A gets updated to 1.1 <br>The package is not pinned. If that dependency update break my package is there an easy way for me to roll back?<br></p><p><br>Best Regards<br>Kostiantyn<br></p><p>&gt; On 31 Oct 2016, at 22:23, Anders Bertelrud via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0145 &quot;Package Manager Version Pinning&quot; begins now and runs through November 4. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0145-package-manager-version-pinning.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0145-package-manager-version-pinning.md&gt;<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; Anders Bertelrud<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161102/0b3b8d5c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>[Review] SE-0145: Package Manager Version Pinning</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>November  2, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes, version pinning is very important to dependency management in production environments.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I have used various dependency management systems and had seen some evolving in particular domains (pip’s eventual emergence over the last decade in Python land comes to mind. Linux package managers as found in Debian/CentOS/Arch/Gentoo, albeit less analogous here). Ruby gems, Cocoapods and Carthage are the ones I’m using in production today.<br></p><p>Excluding a few cosmetic differences (.pins extensions, whether to automatically pin, pinning commands etc), the proposed mechanisms are actually very similar to the ones we know and love in iOS/macOS development today: there’s some remote sources where the dependencies reside, most likely version controlled repositories with explicit ways to identify a certain state in their history. Using a text file to record the state identifiers, the manager can ensure shared, reproducible building environment. No surprise here.<br></p><p>As for the difference: I can’t recall a time when I really thought about the file extension of Podfile.lock or Carthage.resolved or Gems.WhatEverTheHeck. The proposal had dedicated a good potion to explain the choice of .pins, that deserves some extra credit IMHO. Explicit pinning commands gives us more control. In a team environment, if you are using a pinning feature, it’s *really* annoying to have accidentally triggers a change in the .lock/.resolved files. This is happens when your team opt-out a latest version of the dependency. Automatic pinning, therefore, is not a feature, it’s the lack of one.<br></p><p><br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br></p><p>Read initial draft of the proposal and its discussions. Read the actual proposal.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161102/4e438e7f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eb0d0358af1f99d8dc5970844e5b8180?s=50"></div><header><strong>[Review] SE-0145: Package Manager Version Pinning</strong> from <string>Martin Waitz</string> &lt;tali at admingilde.org&gt;<p>November  2, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; What is your evaluation of the proposal?<br></p><p>+1 for using reproducible versions of dependencies<br>-1 for the actual proposal<br></p><p>My problem with this proposal is that it tries to please everybody by introducing options everywhere.<br>I think we should try to build a system which is robust and works all of the time.<br></p><p>Being able to reproduce any build is a great value, no matter which package we are working on.<br>We should build our package management in a way that reproducible builds are the default.<br>Therefor I strongly propose to always store the exact version of all dependencies under<br>version control.<br></p><p>Just adding opt-ins (pinning of individual packages) creates new problems:<br>How should the user/maintainer select which packages to pin? How do we maintain this list?<br>E.g. even after the proposed `swift package pin —all`, you can end up with unpinned dependencies<br>after a `swift package --repin` when one dependency introduces some new sub-dependency.<br>Or should we also pin these sub-dependencies when the parent was already pinned?<br>But then what to do when the newly introduces sub-dependency was already part of the<br>closed set of all dependencies before, but was explicitly not pinned?<br></p><p>We should just drop all these problems and design a system which works for all use-cases<br>without having to manually pin dependencies.<br>Just store the version of all dependencies but make it easy to change/update them.<br>Of course, the used versions must be under control of the top-level package which is being built.<br>All the version information stored within dependencies may be a nice hint for the top-level<br>maintainer, but should not be used by the build system.<br>This way, we don’t have to differentiate between top-level and library packages.<br></p><p>I don’t think we have to be worried about weakening semver compatibility.<br>Library packages will be included by many top-level packages, each with their own<br>update cycle. Each update will be performed according to the semver specification.<br>CI systems also do not have to just build the current version, but could also use<br>an extra builder which first updates all dependencies and then does its tests.<br>Not versioning some dependencies does not provide any benefit here.<br>I also agree that it’s good to encouraging frequent updates, but we should find a different means.<br>We should make it easy to update dependencies, but leave it to each package maintainer to control<br>when and what to update.<br></p><p>If we don’t ‚pin‘ individual packages but simply store all versions, then I also propose<br>to use the name `Package.versions` for our new file.<br></p><p><br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>yes.<br>Reproducible builds are important and should be supported by swift-pm.<br></p><p><br>&gt; Does this proposal fit well with the feel and direction of Swift?<br></p><p>Reproducible builds fit well into the safe-by-default approach of Swift.<br></p><p><br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I always hated `npm` and all those node packages which had overly restrictive dependency requirements.<br>I guess these were used in order to have more control about which version to use, but this resulted<br>in both packages which I could not build out of the box (because some dependencies changed),<br>and packages I could not update because of conflicting requirements.<br>Using loose version requirements + semver in `Package.swift` files together with exact versions<br>of all dependencies stored in the top-level package solves everything: you get reproducible builds<br>(based on `Package.versions`) together with easy updates (based on all packages’ `Package.versions`).<br></p><p><br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Read the proposal and the comments.<br></p><p>-- Martin<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>[Review] SE-0145: Package Manager Version Pinning</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>November  2, 2016 at 07:00:00pm</p></header><div class="content"><p>On Nov 2, 2016, at 3:46 PM, Martin Waitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; What is your evaluation of the proposal?<br>&gt; <br>&gt; +1 for using reproducible versions of dependencies<br>&gt; -1 for the actual proposal<br>&gt; <br>&gt; My problem with this proposal is that it tries to please everybody by introducing options everywhere.<br>&gt; …<br>&gt; We should just drop all these problems and design a system which works for all use-cases<br>&gt; without having to manually pin dependencies.<br></p><p>The second half of the sentence contradicts with the first half. What if I need to only pin some of the dependencies, have have the rest update automatically?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eb0d0358af1f99d8dc5970844e5b8180?s=50"></div><header><strong>[Review] SE-0145: Package Manager Version Pinning</strong> from <string>Martin Waitz</string> &lt;tali at admingilde.org&gt;<p>November  3, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Am 03.11.2016 um 03:22 schrieb Daniel Duan &lt;daniel at duan.org&gt;:<br>&gt; On Nov 2, 2016, at 3:46 PM, Martin Waitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; +1 for using reproducible versions of dependencies<br>&gt;&gt; -1 for the actual proposal<br>&gt;&gt; <br>&gt;&gt; My problem with this proposal is that it tries to please everybody by introducing options everywhere.<br>&gt;&gt; …<br>&gt;&gt; We should just drop all these problems and design a system which works for all use-cases<br>&gt;&gt; without having to manually pin dependencies.<br>&gt; <br>&gt; The second half of the sentence contradicts with the first half. What if I need to only pin some of the dependencies, have have the rest update automatically?<br></p><p>No contradiction:<br>Storing versions of all dependencies and having reproducible builds is independent from updating dependencies.<br>What you need is some automatic (e.g. driven by CI) system to update your dependencies.<br></p><p>When performing an update is the right time to select what you want to update.<br>Then you can also test the new set and document that you chose to update them.<br></p><p>Updates should always be explicit actions, not happening randomly at checkout time.<br></p><p>— Martin<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>[Review] SE-0145: Package Manager Version Pinning</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>November  2, 2016 at 11:00:00pm</p></header><div class="content"><p>Daniel Duan<br>Sent from my iPhone<br></p><p>On Nov 2, 2016, at 11:17 PM, Martin Waitz &lt;tali at admingilde.org&gt; wrote:<br></p><p>&gt;&gt; Am 03.11.2016 um 03:22 schrieb Daniel Duan &lt;daniel at duan.org&gt;:<br>&gt;&gt; On Nov 2, 2016, at 3:46 PM, Martin Waitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 for using reproducible versions of dependencies<br>&gt;&gt;&gt; -1 for the actual proposal<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My problem with this proposal is that it tries to please everybody by introducing options everywhere.<br>&gt;&gt;&gt; …<br>&gt;&gt;&gt; We should just drop all these problems and design a system which works for all use-cases<br>&gt;&gt;&gt; without having to manually pin dependencies.<br>&gt;&gt; <br>&gt;&gt; The second half of the sentence contradicts with the first half. What if I need to only pin some of the dependencies, have have the rest update automatically?<br>&gt; <br>&gt; No contradiction:<br>&gt; Storing versions of all dependencies and having reproducible builds is independent from updating dependencies.<br>Ok, agreed.<br></p><p>&gt; What you need is some automatic (e.g. driven by CI) system to update your dependencies.<br>When you say &quot;update&quot;, I assume you mean the action of increasing version numbers of certain dependency? I don&#39;t see how CI is going to help with that.<br></p><p>&gt; When performing an update is the right time to select what you want to update.<br>&gt; Then you can also test the new set and document that you chose to update them.<br>What kind of &quot;documenting&quot; are we talking about? I thought the .pins is a place record precise version of the dependency we need. <br></p><p>&gt; Updates should always be explicit actions, not happening randomly at checkout time.<br>I agree strongly that update should be explicit. Which is why running a pin command for a specific dependency *after* it&#39;s been tested is better. I&#39;m guessing you are saying this because I mentioned dependencies that aren&#39;t pinned. If you have worked with internal frameworks that gets changed frequently with a CI running unit tests and integration tests, you&#39;d realize that pinning it is a waste of your teams time. But there&#39;s nothing to prevent you from doing it with this proposal.<br>&gt; <br>&gt; — Martin<br></p><p>It comes down to this: if you want automatic pinning, your build script should run the pin commands whenever you deem necessary.<br></p><p>The converse isn&#39;t true: if you force everyone to automatically pin, then there&#39;s no way to opt-out. Whether that&#39;s desirable is not up to anyone to decide.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eb0d0358af1f99d8dc5970844e5b8180?s=50"></div><header><strong>[Review] SE-0145: Package Manager Version Pinning</strong> from <string>Martin Waitz</string> &lt;tali at admingilde.org&gt;<p>November  3, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; Am 03.11.2016 um 03:22 schrieb Daniel Duan &lt;daniel at duan.org&gt;:<br>&gt; <br>&gt; On Nov 2, 2016, at 3:46 PM, Martin Waitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; +1 for using reproducible versions of dependencies<br>&gt;&gt; -1 for the actual proposal<br>&gt;&gt; <br>&gt;&gt; My problem with this proposal is that it tries to please everybody by introducing options everywhere.<br>&gt;&gt; …<br>&gt;&gt; We should just drop all these problems and design a system which works for all use-cases<br>&gt;&gt; without having to manually pin dependencies.<br>&gt; <br>&gt; The second half of the sentence contradicts with the first half. What if I need to only pin some of the dependencies, have have the rest update automatically?<br></p><p>Also, we should be really careful with our naming.<br>For me, pin or lock means: don’t touch it, keep this version.<br></p><p>If your use-case really is to keep a specific version, then well you should specify that as a requirement in your dependencies.<br>Then add this information (together with some comment why you absolutely need that version) to your `Package.swift`.<br></p><p>I want reproducible checkouts and builds, but I don’t want to make people feel that versions are set in stone.<br>We should encourage frequent updates. So we should not lock versions, we should just track and manage them.<br></p><p>If a package is actively maintained, then the maintainer will care about updating and adapting to changed dependencies.<br>If the package is not maintained any more, then it will not be adapted to changed dependencies anyway.<br>In this case it does not help to randomly break the build of dependent packages.<br></p><p>The best way out is to give dependent package maintainers the power to:<br> * get enough information to see that there is a problem with a dependency<br> * get enough time to be able to act accordingly (without having to rush because builds are already breaking everywhere)<br></p><p>With proper management of dependency versions, we can provide that.<br>Think of it as the git equivalent in package management :-)<br></p><p>— Martin<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Review] SE-0145: Package Manager Version Pinning</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>November  3, 2016 at 08:00:00am</p></header><div class="content"><p>Could you specify that in the tag of the dependency you need? &gt;= 3.0.0   vs   = 2.0.0  etc... I am not sure why in some cases we need to be unique over state of the art like Cocoapods in some areas. What is the added value (not saying that there is none)?<br></p><p>Sent from my iPhone<br></p><p>&gt; On 3 Nov 2016, at 02:22, Daniel Duan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Nov 2, 2016, at 3:46 PM, Martin Waitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; +1 for using reproducible versions of dependencies<br>&gt;&gt; -1 for the actual proposal<br>&gt;&gt; <br>&gt;&gt; My problem with this proposal is that it tries to please everybody by introducing options everywhere.<br>&gt;&gt; …<br>&gt;&gt; We should just drop all these problems and design a system which works for all use-cases<br>&gt;&gt; without having to manually pin dependencies.<br>&gt; <br>&gt; The second half of the sentence contradicts with the first half. What if I need to only pin some of the dependencies, have have the rest update automatically?<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>[Review] SE-0145: Package Manager Version Pinning</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>November  3, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Nov 3, 2016, at 1:02 AM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; <br>&gt; Could you specify that in the tag of the dependency you need? &gt;= 3.0.0   vs   = 2.0.0  etc… <br></p><p>That’s missing the point of pinning though. You can already do this in Package.swift. Pinning is, in a way, guarding against violation of semvar (in case some packages introduce breaking changes without bumping version).<br></p><p>&gt; I am not sure why in some cases we need to be unique over state of the art like Cocoapods in some areas. What is the added value (not saying that there is none)?<br></p><p>You can combine mechanisms to get your desired policy: get “pin by default” by always running “pin —all” along side other build steps. The converse isn’t true: you cannot get automatically updated dependencies (often your internal packages) at install without changing and checking in Podfile.lock. This issue manifests even more if you try to not distribute Podfile.lock: you get one anyways after your first install, so you’d have to remember to remove it before the next install).<br></p><p>(I’m not criticizing the practice of pinning everything by default, just want to point out it’s not flexible for cases where it’s not flexible. No one should decide those cases for anyone!)<br></p><p>The value added is well explained in the proposal. Simply saying “Cocoapods is good enough, why don’t we copy it” isn’t very constructive and interesting to me.<br></p><p>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 3 Nov 2016, at 02:22, Daniel Duan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Nov 2, 2016, at 3:46 PM, Martin Waitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 for using reproducible versions of dependencies<br>&gt;&gt;&gt; -1 for the actual proposal<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My problem with this proposal is that it tries to please everybody by introducing options everywhere.<br>&gt;&gt;&gt; …<br>&gt;&gt;&gt; We should just drop all these problems and design a system which works for all use-cases<br>&gt;&gt;&gt; without having to manually pin dependencies.<br>&gt;&gt; <br>&gt;&gt; The second half of the sentence contradicts with the first half. What if I need to only pin some of the dependencies, have have the rest update automatically?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bb84c14e99d439d4bfdd409a59f8971d?s=50"></div><header><strong>[Review] SE-0145: Package Manager Version Pinning</strong> from <string>Boris Buegling</string> &lt;bbuegling at apple.com&gt;<p>November  3, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On 3 Nov 2016, at 17:36, Daniel Duan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I am not sure why in some cases we need to be unique over state of the art like Cocoapods in some areas. What is the added value (not saying that there is none)?<br>&gt; <br>&gt; You can combine mechanisms to get your desired policy: get “pin by default” by always running “pin —all” along side other build steps. The converse isn’t true: you cannot get automatically updated dependencies (often your internal packages) at install without changing and checking in Podfile.lock. This issue manifests even more if you try to not distribute Podfile.lock: you get one anyways after your first install, so you’d have to remember to remove it before the next install).<br>&gt; <br>&gt; (I’m not criticizing the practice of pinning everything by default, just want to point out it’s not flexible for cases where it’s not flexible. No one should decide those cases for anyone!)<br>&gt; <br>&gt; The value added is well explained in the proposal. Simply saying “Cocoapods is good enough, why don’t we copy it” isn’t very constructive and interesting to me.<br></p><p>BTW, CocoaPods does not even have a concept of pinning dependencies for libraries and the pod-template does explicitly not commit the Podfile.lock by default for the generated example. Since library packages are currently the prevalent use case of SwiftPM, not pinning by default is actually very similar to CP’s behaviour.<br></p><p>Cheers,<br>Boris<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ad5d998258bab37d23bc9555b0d6c237?s=50"></div><header><strong>[Review] SE-0145: Package Manager Version Pinning</strong> from <string>Max Desiatov</string> &lt;max.desiatov at gmail.com&gt;<p>November  4, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>&gt; On 31 Oct 2016, at 21:23, Anders Bertelrud via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>-1<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes, this is significant problem that basically prevents SwiftPM from being used in production environment due to making builds not consistently reproducible without committing source code of the compiled dependencies.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>No, it doesn&#39;t feel right, as it breaks existing conventions and disregards the experience with other package managers that provide .lock files by default and those that don&#39;t (npm) now have replacements that do lock by default (yarn, https://code.facebook.com/posts/1840075619545360).<br></p><p>I also disagree with the naming of the feature (pinning) as it breaks existing conventions and makes it confusing to people coming from other environments and ecosystems. I use lockfiles (as also most of the developers I know) much more frequently (almost every day) than POSIX locks (almost never, many thanks to GCD and other high-level concurrency features in other languages for that). I&#39;m afraid the argument about overloading doesn&#39;t convince me at all, as many terms are overloaded, but that never was a problem as an established context and conventions matter more.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Yes, I use yarn, CocoaPods and Carthage on daily basis, and locking dependencies by default was never a problem with those. On the contrary, I had a lot of bad experience with npm, which doesn&#39;t lock by default.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I tracked this proposal from the draft version and did and studied how package managers for other ecosystems has evolved. <br></p><p>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; Anders Bertelrud<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161104/5573fd3b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>[Review] SE-0145: Package Manager Version Pinning</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>November  9, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Nov 4, 2016, at 5:28 AM, Max Desiatov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt;&gt; On 31 Oct 2016, at 21:23, Anders Bertelrud via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; -1<br>&gt; <br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes, this is significant problem that basically prevents SwiftPM from being used in production environment due to making builds not consistently reproducible without committing source code of the compiled dependencies.<br>&gt; <br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; No, it doesn&#39;t feel right, as it breaks existing conventions and disregards the experience with other package managers that provide .lock files by default and those that don&#39;t (npm) now have replacements that do lock by default (yarn, https://code.facebook.com/posts/1840075619545360 &lt;https://code.facebook.com/posts/1840075619545360&gt;).<br></p><p>Yarn, however, can include multiple versions of a package. We cannot, and your response doesn&#39;t acknowledge the impact of that.<br></p><p>Note I&#39;m not saying I disagree with you, but this argument isn&#39;t compelling unless you acknowledge the problems particular to Swift.<br></p><p> - Daniel<br></p><p>&gt; <br>&gt; I also disagree with the naming of the feature (pinning) as it breaks existing conventions and makes it confusing to people coming from other environments and ecosystems. I use lockfiles (as also most of the developers I know) much more frequently (almost every day) than POSIX locks (almost never, many thanks to GCD and other high-level concurrency features in other languages for that). I&#39;m afraid the argument about overloading doesn&#39;t convince me at all, as many terms are overloaded, but that never was a problem as an established context and conventions matter more.<br>&gt; <br>&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; Yes, I use yarn, CocoaPods and Carthage on daily basis, and locking dependencies by default was never a problem with those. On the contrary, I had a lot of bad experience with npm, which doesn&#39;t lock by default.<br>&gt; <br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I tracked this proposal from the draft version and did and studied how package managers for other ecosystems has evolved. <br>&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; Anders Bertelrud<br>&gt;&gt; Review Manager<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161109/ada73d48/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Review] SE-0145: Package Manager Version Pinning</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>November  4, 2016 at 11:00:00am</p></header><div class="content"><p>What is your evaluation of the proposal?<br></p><p>General +1, with reservations. Novel elements of the proposed behavior will need careful evaluation and refinement as we see how they plays out in practice, with open-mindedness from both users and the core team.<br></p><p>Breaking it down:<br></p><p>+1 on having this feature in some form. It’s essential.<br></p><p>+1 on making user choice about .gitignore the thing that controls whether and how pinning is shared within a team. That’s simple, clear, accommodates a wide range of needs, and is consistent with other package managers.<br></p><p>+1 that pinfiles have no effect whatsoever on dependent projects. That’s the only sensible way for it to work, but since there was some debate about that, I’ll just reiterate support.<br></p><p>-1 on making dependencies unpinned by default. Trying to induce unexpected behavior to encourage testing can be a good technique — in contexts where testing is the goal. My gut tells me that doing this when building is the goal will cause a lot of confusion and kvetching. I follow the proposal’s argument that unexpected breakages are a nice way to make strict semver a community norm … and I just do not buy it.<br></p><p>However, given that we hashed this out at great length and the core team is still enamored of the idea, I’m willing to give it a try! I’d love to be proved wrong.<br></p><p>+1 on the proposed command structure given that I’ve lost the aforementioned “always pin” argument. Living in a sometimes-pinned-sometimes-not world is going to be confusing, but the proposed commands help as best they can.<br></p><p>¿-1? This is a big one. If I do:<br></p><p>    swift package pin --all<br></p><p>…and then add a new dependency, is the new dependency also pinned? It should be. To pin or not to pin is typically a project- and team-wide policy decision. I do see the use case for pinning just one ill-behaved dependency, but more typically pinning is something that is built in to a team’s testing process and their assumptions about a whole build’s behavior.<br></p><p>The proposal is vague on this point, but could be interpreted to mean that --all does not pin new dependencies: “Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.” (Aside: there should be a semicolon instead of a comma in that sentence.) I assume — hope — that this is not the case! If --all does not affect new dependencies, then I’m -1 on the proposal.<br></p><p>¿-1? The proposal mentions that SwiftPM already effectively performs local pinning, but is ambiguous about whether this behavior remains separate from the new pinfile. I’m dubious about having two separate pinning mechanisms, one visible and one invisible.<br></p><p>+1 to the proposal’s repeated mentions of clear output and helpful diagnostics. Since this proposal introduces behavior that’s somewhat off the beaten path for package managers, this will be essential.<br></p><p>On the pin/lock controversy<br></p><p>I don’t care. Computer science is full of heavily overloaded terms where a loose underlying concept takes on radically different meanings (bridge, channel, dispatch, edge, graph, header, key, model, module, node, open, parameter, port, process, protocol, query, return, row, source, union). We do just fine disambiguating all these in context, thank you very much. Renaming “lock” to “pin” solves a problem that doesn’t exist.<br></p><p>However, we programmers are _also_ used to dealing with synonyms or partially overlapping near-synonyms (nil / null; closure / lambda / block; field / instance variable; tagged union / associated type enum; etc) and we also do just fine with those too. I’m sure we’ll learn to deal with lock / pin, and nobody will care after 6 months.<br></p><p>In short, “pin” is an unobjectionable solution to a non-problem. Core team is excited about “pin?” Grand. It’s a fine term. Do it and move on.<br></p><p><br>Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>It’s essential. SwiftPM will be impractical in many real-world situations until this is sorted out.<br></p><p><br>Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes, it’s consistent with the general approach of SwiftPM.<br></p><p><br>If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I’ve used bundler, Carthage, and CocoaPods extensively. All of them always generate a lockfile (Gemfile.lock, Cartfile.resolved, and Podfile.lock). All of them use these files as the unique mechanism for version locking, and all use version control of that file as the unique mechanism for controlling whether to locked versions are shared across teams.<br></p><p>We have many years of evidence that this model works well.<br></p><p>Note that all of these package managers also work in in environments that do not support using multiple versions of a dependency in the same artifact at the same time. Therefore this statement from the proposal:<br></p><p>&gt; Overconstraint is much more of a risk in Swift than in other languages using this style of package management.<br></p><p><br>…is incorrect.<br></p><p>In particular, note that Ruby does not support using multiple versions of a lib simultaneously, and that fact alone — even in the presence of _ubiquitous_ version pinning — has been sufficient to encourage widespread mindfulness about semver compliance. All of the concerns expressed in the “Pin by default” section of the proposal also apply to Ruby, and have failed to materialize there.<br></p><p>—<br></p><p>I’ve also used npm and bower, which either do not have version locking or only provide it via add-ons. It’s a nightmare. Lack of locking has caused headaches and lost hours — not hypothetic headaches, but real ones on actual projects — in two scenarios:<br></p><p>1. onboarding new developers who get fresh, incompatible dependency versions on initial checkout; and<br>2. picking projects back up for a new round of development.<br></p><p>Are these two situations really the right time for people to accidentally test whether their dependencies have properly followed semantic versioning? No. There are better ways, and better times. I am troubled by the insistence on ignoring experience here. However, as I said above, I’m willing to give it a try. I will keep an open mind in the name of bold experimentation, and would be happy to have my concerns proven wrong.<br></p><p>Please do keep in mind, however, that this is an experiment. Be ready for all that careful theorizing to be falsified by experience. You may have to murder this darling: http://www.slate.com/blogs/browbeat/2013/10/18/_kill_your_darlings_writing_advice_what_writer_really_said_to_murder_your.html<br></p><p><br>How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>In depth, though I only read some of the discussion thread.<br></p><p>Cheers,<br></p><p>Paul<br></p><p><br>&gt; On Oct 31, 2016, at 4:23 PM, Anders Bertelrud via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0145 &quot;Package Manager Version Pinning&quot; begins now and runs through November 4. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0145-package-manager-version-pinning.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0145-package-manager-version-pinning.md&gt;<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; Anders Bertelrud<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161104/47207778/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bb84c14e99d439d4bfdd409a59f8971d?s=50"></div><header><strong>[Review] SE-0145: Package Manager Version Pinning</strong> from <string>Boris Buegling</string> &lt;bbuegling at apple.com&gt;<p>November  4, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 4 Nov 2016, at 17:06, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Overconstraint is much more of a risk in Swift than in other languages using this style of package management.<br>&gt; <br>&gt; …is incorrect.<br>&gt; <br>&gt; In particular, note that Ruby does not support using multiple versions of a lib simultaneously, and that fact alone — even in the presence of _ubiquitous_ version pinning — has been sufficient to encourage widespread mindfulness about semver compliance. All of the concerns expressed in the “Pin by default” section of the proposal also apply to Ruby, and have failed to materialize there.<br></p><p>Note that this only partially true. It is strongly recommended to not check in your Gemfile.lock when developing a gem (see http://yehudakatz.com/2010/12/16/clarifying-the-roles-of-the-gemspec-and-gemfile/), but only when you’re developing an app. This means that pinning by default is effectively not performed when doing library development in the Ruby ecosystem.<br></p><p>Cheers,<br>Boris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Review] SE-0145: Package Manager Version Pinning</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>November  4, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Nov 4, 2016, at 11:20 AM, Boris Buegling &lt;bbuegling at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On 4 Nov 2016, at 17:06, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Overconstraint is much more of a risk in Swift than in other languages using this style of package management.<br>&gt;&gt; <br>&gt;&gt; …is incorrect.<br>&gt;&gt; <br>&gt;&gt; In particular, note that Ruby does not support using multiple versions of a lib simultaneously, and that fact alone — even in the presence of _ubiquitous_ version pinning — has been sufficient to encourage widespread mindfulness about semver compliance. All of the concerns expressed in the “Pin by default” section of the proposal also apply to Ruby, and have failed to materialize there.<br>&gt; <br>&gt; Note that this only partially true. It is strongly recommended to not check in your Gemfile.lock when developing a gem (see http://yehudakatz.com/2010/12/16/clarifying-the-roles-of-the-gemspec-and-gemfile/), but only when you’re developing an app. This means that pinning by default is effectively not performed when doing library development in the Ruby ecosystem.<br></p><p><br>If SwiftPM used that bundler-like behavior, then presumably the same recommendations about what to check in would apply. By “ubiquitous version pinning,” I mean that the package management tool _always_ generates a lock file, and developers decide for themselves how to manage it.<br></p><p>That section in the proposal made the argument that Swift is fundamentally different from other languages in ways that make always generating a pins file uniquely dangerous. That is false.<br></p><p>Cheers, P<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/36f3ec204630839e54fb68c6979e5f78?s=50"></div><header><strong>[Review] SE-0145: Package Manager Version Pinning</strong> from <string>Daniel Resnick</string> &lt;danielzresnick at gmail.com&gt;<p>November  4, 2016 at 11:00:00am</p></header><div class="content"><p>-1, though I do strongly think we should have version pinning.<br></p><p>I agree with the others who believe that dependencies should be pinned by<br>default. This doesn&#39;t mean that you have to check the pin/lock file into<br>source control. I have a good amount of experience developing apps and<br>libraries with Cocoapods, Carthage, and Bundler, and I&#39;ve always found it<br>to be crucial to be able to easily reproduce builds.<br></p><p>Regarding the naming, I don&#39;t have a strong opinion, but I find the<br>argument that the term &quot;lock&quot; is overloaded and therefore confusing to be<br>weak, given that it is a term used by many package managers.<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161104/2f3c95fd/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0145: Package Manager Version Pinning</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>November  5, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Nov 4, 2016, at 9:06 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’ve used bundler, Carthage, and CocoaPods extensively. All of them always generate a lockfile (Gemfile.lock, Cartfile.resolved, and Podfile.lock). All of them use these files as the unique mechanism for version locking, and all use version control of that file as the unique mechanism for controlling whether to locked versions are shared across teams.<br>&gt; <br>&gt; We have many years of evidence that this model works well.<br>&gt; <br>&gt; Note that all of these package managers also work in in environments that do not support using multiple versions of a dependency in the same artifact at the same time. Therefore this statement from the proposal:<br>&gt; <br>&gt;&gt; Overconstraint is much more of a risk in Swift than in other languages using this style of package management.<br>&gt; <br>&gt; …is incorrect.<br>&gt; <br>&gt; In particular, note that Ruby does not support using multiple versions of a lib simultaneously, and that fact alone — even in the presence of _ubiquitous_ version pinning — has been sufficient to encourage widespread mindfulness about semver compliance. All of the concerns expressed in the “Pin by default” section of the proposal also apply to Ruby, and have failed to materialize there.<br>&gt; <br>&gt; —<br>&gt; <br>&gt; I’ve also used npm and bower, which either do not have version locking or only provide it via add-ons. It’s a nightmare. Lack of locking has caused headaches and lost hours — not hypothetic headaches, but real ones on actual projects — in two scenarios:<br>&gt; <br>&gt; 1. onboarding new developers who get fresh, incompatible dependency versions on initial checkout; and<br>&gt; 2. picking projects back up for a new round of development.<br>&gt; <br>&gt; Are these two situations really the right time for people to accidentally test whether their dependencies have properly followed semantic versioning? No. There are better ways, and better times. I am troubled by the insistence on ignoring experience here. However, as I said above, I’m willing to give it a try. I will keep an open mind in the name of bold experimentation, and would be happy to have my concerns proven wrong.<br>&gt; <br>&gt; Please do keep in mind, however, that this is an experiment. Be ready for all that careful theorizing to be falsified by experience. You may have to murder this darling: http://www.slate.com/blogs/browbeat/2013/10/18/_kill_your_darlings_writing_advice_what_writer_really_said_to_murder_your.html<br></p><p>Thank you for articulating this, Paul.<br></p><p>Personally, I think we have all the evidence we need--including languages that have tried both and settled on pin-by-default--to know how this will turn out. But if the default is to not pin, I can simply write a `fish` function to shorthand the pinning commands and forget about this issue. No big deal.<br></p><p>I&#39;m also less agnostic about the &quot;pin&quot; vs. &quot;lock&quot; question: I think &quot;lock&quot; is nearly universal prior art and we ought to stick to it. However, it&#39;s ultimately just a name. People will figure it out.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>[Review] SE-0145: Package Manager Version Pinning</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>November 10, 2016 at 09:00:00am</p></header><div class="content"><p>Thanks to everyone who participated in this review!<br></p><p>Based on the pretty universal negative feedback, we are going to reject this proposal as is, and take it back for another round of revisions.<br></p><p>Our revised plan is:<br>1. To introduce an &quot;autopin&quot; behavior to cover the problem Paul outlined where `pin --all` effectively needs to be &quot;sticky&quot; for any new dependencies which come into play.<br>2. To make auto pinning on by default, with an explicit mechanism for projects to opt out.<br></p><p>I hope to have this written up for review next week.<br></p><p>Thanks!<br> - Daniel<br></p><p>&gt; On Nov 4, 2016, at 9:06 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; <br>&gt; General +1, with reservations. Novel elements of the proposed behavior will need careful evaluation and refinement as we see how they plays out in practice, with open-mindedness from both users and the core team.<br>&gt; <br>&gt; Breaking it down:<br>&gt; <br>&gt; +1 on having this feature in some form. It’s essential.<br>&gt; <br>&gt; +1 on making user choice about .gitignore the thing that controls whether and how pinning is shared within a team. That’s simple, clear, accommodates a wide range of needs, and is consistent with other package managers.<br>&gt; <br>&gt; +1 that pinfiles have no effect whatsoever on dependent projects. That’s the only sensible way for it to work, but since there was some debate about that, I’ll just reiterate support.<br>&gt; <br>&gt; -1 on making dependencies unpinned by default. Trying to induce unexpected behavior to encourage testing can be a good technique — in contexts where testing is the goal. My gut tells me that doing this when building is the goal will cause a lot of confusion and kvetching. I follow the proposal’s argument that unexpected breakages are a nice way to make strict semver a community norm … and I just do not buy it.<br>&gt; <br>&gt; However, given that we hashed this out at great length and the core team is still enamored of the idea, I’m willing to give it a try! I’d love to be proved wrong.<br>&gt; <br>&gt; +1 on the proposed command structure given that I’ve lost the aforementioned “always pin” argument. Living in a sometimes-pinned-sometimes-not world is going to be confusing, but the proposed commands help as best they can.<br>&gt; <br>&gt; ¿-1? This is a big one. If I do:<br>&gt; <br>&gt;     swift package pin --all<br>&gt; <br>&gt; …and then add a new dependency, is the new dependency also pinned? It should be. To pin or not to pin is typically a project- and team-wide policy decision. I do see the use case for pinning just one ill-behaved dependency, but more typically pinning is something that is built in to a team’s testing process and their assumptions about a whole build’s behavior.<br>&gt; <br>&gt; The proposal is vague on this point, but could be interpreted to mean that --all does not pin new dependencies: “Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.” (Aside: there should be a semicolon instead of a comma in that sentence.) I assume — hope — that this is not the case! If --all does not affect new dependencies, then I’m -1 on the proposal.<br>&gt; <br>&gt; ¿-1? The proposal mentions that SwiftPM already effectively performs local pinning, but is ambiguous about whether this behavior remains separate from the new pinfile. I’m dubious about having two separate pinning mechanisms, one visible and one invisible.<br>&gt; <br>&gt; +1 to the proposal’s repeated mentions of clear output and helpful diagnostics. Since this proposal introduces behavior that’s somewhat off the beaten path for package managers, this will be essential.<br>&gt; <br>&gt; On the pin/lock controversy<br>&gt; <br>&gt; I don’t care. Computer science is full of heavily overloaded terms where a loose underlying concept takes on radically different meanings (bridge, channel, dispatch, edge, graph, header, key, model, module, node, open, parameter, port, process, protocol, query, return, row, source, union). We do just fine disambiguating all these in context, thank you very much. Renaming “lock” to “pin” solves a problem that doesn’t exist.<br>&gt; <br>&gt; However, we programmers are _also_ used to dealing with synonyms or partially overlapping near-synonyms (nil / null; closure / lambda / block; field / instance variable; tagged union / associated type enum; etc) and we also do just fine with those too. I’m sure we’ll learn to deal with lock / pin, and nobody will care after 6 months.<br>&gt; <br>&gt; In short, “pin” is an unobjectionable solution to a non-problem. Core team is excited about “pin?” Grand. It’s a fine term. Do it and move on.<br>&gt; <br>&gt; <br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; It’s essential. SwiftPM will be impractical in many real-world situations until this is sorted out.<br>&gt; <br>&gt; <br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Yes, it’s consistent with the general approach of SwiftPM.<br>&gt; <br>&gt; <br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; I’ve used bundler, Carthage, and CocoaPods extensively. All of them always generate a lockfile (Gemfile.lock, Cartfile.resolved, and Podfile.lock). All of them use these files as the unique mechanism for version locking, and all use version control of that file as the unique mechanism for controlling whether to locked versions are shared across teams.<br>&gt; <br>&gt; We have many years of evidence that this model works well.<br>&gt; <br>&gt; Note that all of these package managers also work in in environments that do not support using multiple versions of a dependency in the same artifact at the same time. Therefore this statement from the proposal:<br>&gt; <br>&gt;&gt; Overconstraint is much more of a risk in Swift than in other languages using this style of package management.<br>&gt; <br>&gt; <br>&gt; …is incorrect.<br>&gt; <br>&gt; In particular, note that Ruby does not support using multiple versions of a lib simultaneously, and that fact alone — even in the presence of _ubiquitous_ version pinning — has been sufficient to encourage widespread mindfulness about semver compliance. All of the concerns expressed in the “Pin by default” section of the proposal also apply to Ruby, and have failed to materialize there.<br>&gt; <br>&gt; —<br>&gt; <br>&gt; I’ve also used npm and bower, which either do not have version locking or only provide it via add-ons. It’s a nightmare. Lack of locking has caused headaches and lost hours — not hypothetic headaches, but real ones on actual projects — in two scenarios:<br>&gt; <br>&gt; 1. onboarding new developers who get fresh, incompatible dependency versions on initial checkout; and<br>&gt; 2. picking projects back up for a new round of development.<br>&gt; <br>&gt; Are these two situations really the right time for people to accidentally test whether their dependencies have properly followed semantic versioning? No. There are better ways, and better times. I am troubled by the insistence on ignoring experience here. However, as I said above, I’m willing to give it a try. I will keep an open mind in the name of bold experimentation, and would be happy to have my concerns proven wrong.<br>&gt; <br>&gt; Please do keep in mind, however, that this is an experiment. Be ready for all that careful theorizing to be falsified by experience. You may have to murder this darling: http://www.slate.com/blogs/browbeat/2013/10/18/_kill_your_darlings_writing_advice_what_writer_really_said_to_murder_your.html &lt;http://www.slate.com/blogs/browbeat/2013/10/18/_kill_your_darlings_writing_advice_what_writer_really_said_to_murder_your.html&gt;<br>&gt; <br>&gt; <br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; In depth, though I only read some of the discussion thread.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 31, 2016, at 4:23 PM, Anders Bertelrud via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of SE-0145 &quot;Package Manager Version Pinning&quot; begins now and runs through November 4. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0145-package-manager-version-pinning.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0145-package-manager-version-pinning.md&gt;<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; Anders Bertelrud<br>&gt;&gt; Review Manager<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161110/7d0554f4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fd5bd4566ee1f286333b7dbf2df6fadb?s=50"></div><header><strong>[Review] SE-0145: Package Manager Version Pinning</strong> from <string>Anders Bertelrud</string> &lt;anders at apple.com&gt;<p>November 10, 2016 at 10:00:00am</p></header><div class="content"><p>Thank you, Daniel.  I have marked the SE-0145 as such in the swift-evolution repository.<br></p><p>Anders<br></p><p>&gt; On 2016-11-10, at 09.41, Daniel Dunbar &lt;daniel_dunbar at apple.com&gt; wrote:<br>&gt; <br>&gt; Thanks to everyone who participated in this review!<br>&gt; <br>&gt; Based on the pretty universal negative feedback, we are going to reject this proposal as is, and take it back for another round of revisions.<br>&gt; <br>&gt; Our revised plan is:<br>&gt; 1. To introduce an &quot;autopin&quot; behavior to cover the problem Paul outlined where `pin --all` effectively needs to be &quot;sticky&quot; for any new dependencies which come into play.<br>&gt; 2. To make auto pinning on by default, with an explicit mechanism for projects to opt out.<br>&gt; <br>&gt; I hope to have this written up for review next week.<br>&gt; <br>&gt; Thanks!<br>&gt;  - Daniel<br>&gt; <br>&gt;&gt; On Nov 4, 2016, at 9:06 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; General +1, with reservations. Novel elements of the proposed behavior will need careful evaluation and refinement as we see how they plays out in practice, with open-mindedness from both users and the core team.<br>&gt;&gt; <br>&gt;&gt; Breaking it down:<br>&gt;&gt; <br>&gt;&gt; +1 on having this feature in some form. It’s essential.<br>&gt;&gt; <br>&gt;&gt; +1 on making user choice about .gitignore the thing that controls whether and how pinning is shared within a team. That’s simple, clear, accommodates a wide range of needs, and is consistent with other package managers.<br>&gt;&gt; <br>&gt;&gt; +1 that pinfiles have no effect whatsoever on dependent projects. That’s the only sensible way for it to work, but since there was some debate about that, I’ll just reiterate support.<br>&gt;&gt; <br>&gt;&gt; -1 on making dependencies unpinned by default. Trying to induce unexpected behavior to encourage testing can be a good technique — in contexts where testing is the goal. My gut tells me that doing this when building is the goal will cause a lot of confusion and kvetching. I follow the proposal’s argument that unexpected breakages are a nice way to make strict semver a community norm … and I just do not buy it.<br>&gt;&gt; <br>&gt;&gt; However, given that we hashed this out at great length and the core team is still enamored of the idea, I’m willing to give it a try! I’d love to be proved wrong.<br>&gt;&gt; <br>&gt;&gt; +1 on the proposed command structure given that I’ve lost the aforementioned “always pin” argument. Living in a sometimes-pinned-sometimes-not world is going to be confusing, but the proposed commands help as best they can.<br>&gt;&gt; <br>&gt;&gt; ¿-1? This is a big one. If I do:<br>&gt;&gt; <br>&gt;&gt;     swift package pin --all<br>&gt;&gt; <br>&gt;&gt; …and then add a new dependency, is the new dependency also pinned? It should be. To pin or not to pin is typically a project- and team-wide policy decision. I do see the use case for pinning just one ill-behaved dependency, but more typically pinning is something that is built in to a team’s testing process and their assumptions about a whole build’s behavior.<br>&gt;&gt; <br>&gt;&gt; The proposal is vague on this point, but could be interpreted to mean that --all does not pin new dependencies: “Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.” (Aside: there should be a semicolon instead of a comma in that sentence.) I assume — hope — that this is not the case! If --all does not affect new dependencies, then I’m -1 on the proposal.<br>&gt;&gt; <br>&gt;&gt; ¿-1? The proposal mentions that SwiftPM already effectively performs local pinning, but is ambiguous about whether this behavior remains separate from the new pinfile. I’m dubious about having two separate pinning mechanisms, one visible and one invisible.<br>&gt;&gt; <br>&gt;&gt; +1 to the proposal’s repeated mentions of clear output and helpful diagnostics. Since this proposal introduces behavior that’s somewhat off the beaten path for package managers, this will be essential.<br>&gt;&gt; <br>&gt;&gt; On the pin/lock controversy<br>&gt;&gt; <br>&gt;&gt; I don’t care. Computer science is full of heavily overloaded terms where a loose underlying concept takes on radically different meanings (bridge, channel, dispatch, edge, graph, header, key, model, module, node, open, parameter, port, process, protocol, query, return, row, source, union). We do just fine disambiguating all these in context, thank you very much. Renaming “lock” to “pin” solves a problem that doesn’t exist.<br>&gt;&gt; <br>&gt;&gt; However, we programmers are _also_ used to dealing with synonyms or partially overlapping near-synonyms (nil / null; closure / lambda / block; field / instance variable; tagged union / associated type enum; etc) and we also do just fine with those too. I’m sure we’ll learn to deal with lock / pin, and nobody will care after 6 months.<br>&gt;&gt; <br>&gt;&gt; In short, “pin” is an unobjectionable solution to a non-problem. Core team is excited about “pin?” Grand. It’s a fine term. Do it and move on.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; <br>&gt;&gt; It’s essential. SwiftPM will be impractical in many real-world situations until this is sorted out.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; Yes, it’s consistent with the general approach of SwiftPM.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; <br>&gt;&gt; I’ve used bundler, Carthage, and CocoaPods extensively. All of them always generate a lockfile (Gemfile.lock, Cartfile.resolved, and Podfile.lock). All of them use these files as the unique mechanism for version locking, and all use version control of that file as the unique mechanism for controlling whether to locked versions are shared across teams.<br>&gt;&gt; <br>&gt;&gt; We have many years of evidence that this model works well.<br>&gt;&gt; <br>&gt;&gt; Note that all of these package managers also work in in environments that do not support using multiple versions of a dependency in the same artifact at the same time. Therefore this statement from the proposal:<br>&gt;&gt; <br>&gt;&gt;&gt; Overconstraint is much more of a risk in Swift than in other languages using this style of package management.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; …is incorrect.<br>&gt;&gt; <br>&gt;&gt; In particular, note that Ruby does not support using multiple versions of a lib simultaneously, and that fact alone — even in the presence of _ubiquitous_ version pinning — has been sufficient to encourage widespread mindfulness about semver compliance. All of the concerns expressed in the “Pin by default” section of the proposal also apply to Ruby, and have failed to materialize there.<br>&gt;&gt; <br>&gt;&gt; —<br>&gt;&gt; <br>&gt;&gt; I’ve also used npm and bower, which either do not have version locking or only provide it via add-ons. It’s a nightmare. Lack of locking has caused headaches and lost hours — not hypothetic headaches, but real ones on actual projects — in two scenarios:<br>&gt;&gt; <br>&gt;&gt; 1. onboarding new developers who get fresh, incompatible dependency versions on initial checkout; and<br>&gt;&gt; 2. picking projects back up for a new round of development.<br>&gt;&gt; <br>&gt;&gt; Are these two situations really the right time for people to accidentally test whether their dependencies have properly followed semantic versioning? No. There are better ways, and better times. I am troubled by the insistence on ignoring experience here. However, as I said above, I’m willing to give it a try. I will keep an open mind in the name of bold experimentation, and would be happy to have my concerns proven wrong.<br>&gt;&gt; <br>&gt;&gt; Please do keep in mind, however, that this is an experiment. Be ready for all that careful theorizing to be falsified by experience. You may have to murder this darling: http://www.slate.com/blogs/browbeat/2013/10/18/_kill_your_darlings_writing_advice_what_writer_really_said_to_murder_your.html &lt;http://www.slate.com/blogs/browbeat/2013/10/18/_kill_your_darlings_writing_advice_what_writer_really_said_to_murder_your.html&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; In depth, though I only read some of the discussion thread.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; Paul<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 31, 2016, at 4:23 PM, Anders Bertelrud via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of SE-0145 &quot;Package Manager Version Pinning&quot; begins now and runs through November 4. The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0145-package-manager-version-pinning.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0145-package-manager-version-pinning.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anders Bertelrud<br>&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161110/de6f02a2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Review] SE-0145: Package Manager Version Pinning</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>November 11, 2016 at 11:00:00am</p></header><div class="content"><p>Thanks for being open to feedback, Daniel, even when it’s difficult feedback. :)<br></p><p>Pondering #2: is there a behavioral difference between<br></p><p>1. explicit “do not pin” option in SwiftPM and<br>2. Package.pins added to .gitignore?<br></p><p>(In #2, individual ill-behaved packages would be version-pinned in Package.swift.)<br></p><p>I imagine that the effect of #1 moves version pinning from Package.pins to some local hidden/internal location that isn’t shared across machines. That sounds to me like “there is always a pinfile, it always works the same way, but sometimes teams choose not to share it across machines” — which sounds a lot like #2. But maybe it’s more subtle than that?<br></p><p>Cheers, P<br></p><p><br>&gt; On Nov 10, 2016, at 11:41 AM, Daniel Dunbar &lt;daniel_dunbar at apple.com&gt; wrote:<br>&gt; <br>&gt; Thanks to everyone who participated in this review!<br>&gt; <br>&gt; Based on the pretty universal negative feedback, we are going to reject this proposal as is, and take it back for another round of revisions.<br>&gt; <br>&gt; Our revised plan is:<br>&gt; 1. To introduce an &quot;autopin&quot; behavior to cover the problem Paul outlined where `pin --all` effectively needs to be &quot;sticky&quot; for any new dependencies which come into play.<br>&gt; 2. To make auto pinning on by default, with an explicit mechanism for projects to opt out.<br>&gt; <br>&gt; I hope to have this written up for review next week.<br>&gt; <br>&gt; Thanks!<br>&gt;  - Daniel<br>&gt; <br>&gt;&gt; On Nov 4, 2016, at 9:06 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; General +1, with reservations. Novel elements of the proposed behavior will need careful evaluation and refinement as we see how they plays out in practice, with open-mindedness from both users and the core team.<br>&gt;&gt; <br>&gt;&gt; Breaking it down:<br>&gt;&gt; <br>&gt;&gt; +1 on having this feature in some form. It’s essential.<br>&gt;&gt; <br>&gt;&gt; +1 on making user choice about .gitignore the thing that controls whether and how pinning is shared within a team. That’s simple, clear, accommodates a wide range of needs, and is consistent with other package managers.<br>&gt;&gt; <br>&gt;&gt; +1 that pinfiles have no effect whatsoever on dependent projects. That’s the only sensible way for it to work, but since there was some debate about that, I’ll just reiterate support.<br>&gt;&gt; <br>&gt;&gt; -1 on making dependencies unpinned by default. Trying to induce unexpected behavior to encourage testing can be a good technique — in contexts where testing is the goal. My gut tells me that doing this when building is the goal will cause a lot of confusion and kvetching. I follow the proposal’s argument that unexpected breakages are a nice way to make strict semver a community norm … and I just do not buy it.<br>&gt;&gt; <br>&gt;&gt; However, given that we hashed this out at great length and the core team is still enamored of the idea, I’m willing to give it a try! I’d love to be proved wrong.<br>&gt;&gt; <br>&gt;&gt; +1 on the proposed command structure given that I’ve lost the aforementioned “always pin” argument. Living in a sometimes-pinned-sometimes-not world is going to be confusing, but the proposed commands help as best they can.<br>&gt;&gt; <br>&gt;&gt; ¿-1? This is a big one. If I do:<br>&gt;&gt; <br>&gt;&gt;     swift package pin --all<br>&gt;&gt; <br>&gt;&gt; …and then add a new dependency, is the new dependency also pinned? It should be. To pin or not to pin is typically a project- and team-wide policy decision. I do see the use case for pinning just one ill-behaved dependency, but more typically pinning is something that is built in to a team’s testing process and their assumptions about a whole build’s behavior.<br>&gt;&gt; <br>&gt;&gt; The proposal is vague on this point, but could be interpreted to mean that --all does not pin new dependencies: “Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.” (Aside: there should be a semicolon instead of a comma in that sentence.) I assume — hope — that this is not the case! If --all does not affect new dependencies, then I’m -1 on the proposal.<br>&gt;&gt; <br>&gt;&gt; ¿-1? The proposal mentions that SwiftPM already effectively performs local pinning, but is ambiguous about whether this behavior remains separate from the new pinfile. I’m dubious about having two separate pinning mechanisms, one visible and one invisible.<br>&gt;&gt; <br>&gt;&gt; +1 to the proposal’s repeated mentions of clear output and helpful diagnostics. Since this proposal introduces behavior that’s somewhat off the beaten path for package managers, this will be essential.<br>&gt;&gt; <br>&gt;&gt; On the pin/lock controversy<br>&gt;&gt; <br>&gt;&gt; I don’t care. Computer science is full of heavily overloaded terms where a loose underlying concept takes on radically different meanings (bridge, channel, dispatch, edge, graph, header, key, model, module, node, open, parameter, port, process, protocol, query, return, row, source, union). We do just fine disambiguating all these in context, thank you very much. Renaming “lock” to “pin” solves a problem that doesn’t exist.<br>&gt;&gt; <br>&gt;&gt; However, we programmers are _also_ used to dealing with synonyms or partially overlapping near-synonyms (nil / null; closure / lambda / block; field / instance variable; tagged union / associated type enum; etc) and we also do just fine with those too. I’m sure we’ll learn to deal with lock / pin, and nobody will care after 6 months.<br>&gt;&gt; <br>&gt;&gt; In short, “pin” is an unobjectionable solution to a non-problem. Core team is excited about “pin?” Grand. It’s a fine term. Do it and move on.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; <br>&gt;&gt; It’s essential. SwiftPM will be impractical in many real-world situations until this is sorted out.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; Yes, it’s consistent with the general approach of SwiftPM.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; <br>&gt;&gt; I’ve used bundler, Carthage, and CocoaPods extensively. All of them always generate a lockfile (Gemfile.lock, Cartfile.resolved, and Podfile.lock). All of them use these files as the unique mechanism for version locking, and all use version control of that file as the unique mechanism for controlling whether to locked versions are shared across teams.<br>&gt;&gt; <br>&gt;&gt; We have many years of evidence that this model works well.<br>&gt;&gt; <br>&gt;&gt; Note that all of these package managers also work in in environments that do not support using multiple versions of a dependency in the same artifact at the same time. Therefore this statement from the proposal:<br>&gt;&gt; <br>&gt;&gt;&gt; Overconstraint is much more of a risk in Swift than in other languages using this style of package management.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; …is incorrect.<br>&gt;&gt; <br>&gt;&gt; In particular, note that Ruby does not support using multiple versions of a lib simultaneously, and that fact alone — even in the presence of _ubiquitous_ version pinning — has been sufficient to encourage widespread mindfulness about semver compliance. All of the concerns expressed in the “Pin by default” section of the proposal also apply to Ruby, and have failed to materialize there.<br>&gt;&gt; <br>&gt;&gt; —<br>&gt;&gt; <br>&gt;&gt; I’ve also used npm and bower, which either do not have version locking or only provide it via add-ons. It’s a nightmare. Lack of locking has caused headaches and lost hours — not hypothetic headaches, but real ones on actual projects — in two scenarios:<br>&gt;&gt; <br>&gt;&gt; 1. onboarding new developers who get fresh, incompatible dependency versions on initial checkout; and<br>&gt;&gt; 2. picking projects back up for a new round of development.<br>&gt;&gt; <br>&gt;&gt; Are these two situations really the right time for people to accidentally test whether their dependencies have properly followed semantic versioning? No. There are better ways, and better times. I am troubled by the insistence on ignoring experience here. However, as I said above, I’m willing to give it a try. I will keep an open mind in the name of bold experimentation, and would be happy to have my concerns proven wrong.<br>&gt;&gt; <br>&gt;&gt; Please do keep in mind, however, that this is an experiment. Be ready for all that careful theorizing to be falsified by experience. You may have to murder this darling: http://www.slate.com/blogs/browbeat/2013/10/18/_kill_your_darlings_writing_advice_what_writer_really_said_to_murder_your.html &lt;http://www.slate.com/blogs/browbeat/2013/10/18/_kill_your_darlings_writing_advice_what_writer_really_said_to_murder_your.html&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; In depth, though I only read some of the discussion thread.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; Paul<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 31, 2016, at 4:23 PM, Anders Bertelrud via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of SE-0145 &quot;Package Manager Version Pinning&quot; begins now and runs through November 4. The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0145-package-manager-version-pinning.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0145-package-manager-version-pinning.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anders Bertelrud<br>&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161111/b146a949/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>[Review] SE-0145: Package Manager Version Pinning</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>November 11, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Nov 11, 2016, at 9:28 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt; <br>&gt; Thanks for being open to feedback, Daniel, even when it’s difficult feedback. :)<br>&gt; <br>&gt; Pondering #2: is there a behavioral difference between<br>&gt; <br>&gt; 1. explicit “do not pin” option in SwiftPM and<br>&gt; 2. Package.pins added to .gitignore?<br>&gt; <br>&gt; (In #2, individual ill-behaved packages would be version-pinned in Package.swift.)<br>&gt; <br>&gt; I imagine that the effect of #1 moves version pinning from Package.pins to some local hidden/internal location that isn’t shared across machines. That sounds to me like “there is always a pinfile, it always works the same way, but sometimes teams choose not to share it across machines” — which sounds a lot like #2. But maybe it’s more subtle than that?<br></p><p>I think the behavior difference comes in in how individual commands like `swift package update` behave and what their diagnostics are.<br></p><p>I want it to be possible for developers to, for example, maintain individual pins but not auto-pin everything else (and even potentially check in that configuration).<br></p><p>Hoping to have a concrete proposal written up shortly...<br></p><p> - Daniel<br></p><p>&gt; <br>&gt; Cheers, P<br>&gt; <br>&gt; <br>&gt;&gt; On Nov 10, 2016, at 11:41 AM, Daniel Dunbar &lt;daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks to everyone who participated in this review!<br>&gt;&gt; <br>&gt;&gt; Based on the pretty universal negative feedback, we are going to reject this proposal as is, and take it back for another round of revisions.<br>&gt;&gt; <br>&gt;&gt; Our revised plan is:<br>&gt;&gt; 1. To introduce an &quot;autopin&quot; behavior to cover the problem Paul outlined where `pin --all` effectively needs to be &quot;sticky&quot; for any new dependencies which come into play.<br>&gt;&gt; 2. To make auto pinning on by default, with an explicit mechanism for projects to opt out.<br>&gt;&gt; <br>&gt;&gt; I hope to have this written up for review next week.<br>&gt;&gt; <br>&gt;&gt; Thanks!<br>&gt;&gt;  - Daniel<br>&gt;&gt; <br>&gt;&gt;&gt; On Nov 4, 2016, at 9:06 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; General +1, with reservations. Novel elements of the proposed behavior will need careful evaluation and refinement as we see how they plays out in practice, with open-mindedness from both users and the core team.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Breaking it down:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 on having this feature in some form. It’s essential.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 on making user choice about .gitignore the thing that controls whether and how pinning is shared within a team. That’s simple, clear, accommodates a wide range of needs, and is consistent with other package managers.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 that pinfiles have no effect whatsoever on dependent projects. That’s the only sensible way for it to work, but since there was some debate about that, I’ll just reiterate support.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -1 on making dependencies unpinned by default. Trying to induce unexpected behavior to encourage testing can be a good technique — in contexts where testing is the goal. My gut tells me that doing this when building is the goal will cause a lot of confusion and kvetching. I follow the proposal’s argument that unexpected breakages are a nice way to make strict semver a community norm … and I just do not buy it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, given that we hashed this out at great length and the core team is still enamored of the idea, I’m willing to give it a try! I’d love to be proved wrong.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 on the proposed command structure given that I’ve lost the aforementioned “always pin” argument. Living in a sometimes-pinned-sometimes-not world is going to be confusing, but the proposed commands help as best they can.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ¿-1? This is a big one. If I do:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     swift package pin --all<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …and then add a new dependency, is the new dependency also pinned? It should be. To pin or not to pin is typically a project- and team-wide policy decision. I do see the use case for pinning just one ill-behaved dependency, but more typically pinning is something that is built in to a team’s testing process and their assumptions about a whole build’s behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal is vague on this point, but could be interpreted to mean that --all does not pin new dependencies: “Dependencies are never automatically pinned, pinning is only ever taken as a result of an explicit user action.” (Aside: there should be a semicolon instead of a comma in that sentence.) I assume — hope — that this is not the case! If --all does not affect new dependencies, then I’m -1 on the proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ¿-1? The proposal mentions that SwiftPM already effectively performs local pinning, but is ambiguous about whether this behavior remains separate from the new pinfile. I’m dubious about having two separate pinning mechanisms, one visible and one invisible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 to the proposal’s repeated mentions of clear output and helpful diagnostics. Since this proposal introduces behavior that’s somewhat off the beaten path for package managers, this will be essential.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the pin/lock controversy<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t care. Computer science is full of heavily overloaded terms where a loose underlying concept takes on radically different meanings (bridge, channel, dispatch, edge, graph, header, key, model, module, node, open, parameter, port, process, protocol, query, return, row, source, union). We do just fine disambiguating all these in context, thank you very much. Renaming “lock” to “pin” solves a problem that doesn’t exist.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, we programmers are _also_ used to dealing with synonyms or partially overlapping near-synonyms (nil / null; closure / lambda / block; field / instance variable; tagged union / associated type enum; etc) and we also do just fine with those too. I’m sure we’ll learn to deal with lock / pin, and nobody will care after 6 months.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In short, “pin” is an unobjectionable solution to a non-problem. Core team is excited about “pin?” Grand. It’s a fine term. Do it and move on.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s essential. SwiftPM will be impractical in many real-world situations until this is sorted out.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, it’s consistent with the general approach of SwiftPM.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve used bundler, Carthage, and CocoaPods extensively. All of them always generate a lockfile (Gemfile.lock, Cartfile.resolved, and Podfile.lock). All of them use these files as the unique mechanism for version locking, and all use version control of that file as the unique mechanism for controlling whether to locked versions are shared across teams.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We have many years of evidence that this model works well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that all of these package managers also work in in environments that do not support using multiple versions of a dependency in the same artifact at the same time. Therefore this statement from the proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Overconstraint is much more of a risk in Swift than in other languages using this style of package management.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …is incorrect.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In particular, note that Ruby does not support using multiple versions of a lib simultaneously, and that fact alone — even in the presence of _ubiquitous_ version pinning — has been sufficient to encourage widespread mindfulness about semver compliance. All of the concerns expressed in the “Pin by default” section of the proposal also apply to Ruby, and have failed to materialize there.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; —<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve also used npm and bower, which either do not have version locking or only provide it via add-ons. It’s a nightmare. Lack of locking has caused headaches and lost hours — not hypothetic headaches, but real ones on actual projects — in two scenarios:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. onboarding new developers who get fresh, incompatible dependency versions on initial checkout; and<br>&gt;&gt;&gt; 2. picking projects back up for a new round of development.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Are these two situations really the right time for people to accidentally test whether their dependencies have properly followed semantic versioning? No. There are better ways, and better times. I am troubled by the insistence on ignoring experience here. However, as I said above, I’m willing to give it a try. I will keep an open mind in the name of bold experimentation, and would be happy to have my concerns proven wrong.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Please do keep in mind, however, that this is an experiment. Be ready for all that careful theorizing to be falsified by experience. You may have to murder this darling: http://www.slate.com/blogs/browbeat/2013/10/18/_kill_your_darlings_writing_advice_what_writer_really_said_to_murder_your.html &lt;http://www.slate.com/blogs/browbeat/2013/10/18/_kill_your_darlings_writing_advice_what_writer_really_said_to_murder_your.html&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In depth, though I only read some of the discussion thread.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Paul<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 31, 2016, at 4:23 PM, Anders Bertelrud via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The review of SE-0145 &quot;Package Manager Version Pinning&quot; begins now and runs through November 4. The proposal is available here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0145-package-manager-version-pinning.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0145-package-manager-version-pinning.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Anders Bertelrud<br>&gt;&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161111/b9a24710/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
