<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>[Idea] Omit argument labels from the call site when the argument is the same as the label</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>February  7, 2016 at 11:00:00am</p></header><div class="content"><p>Hi All.<br></p><p>I’m just throwing this out there.<br></p><p>often when I write Objective-C, my method calls end up looking like this:<br></p><p>[you doYourThingWithThis:this that:that these:these those:those other:other];<br></p><p>This reads poorly and requires extra typing. It would be nice if the compiler just assumed that when no label is given, the label is the same as the argument name. The code would be just as understandable (more) than if the argument labels were actually there.<br></p><p>In Swift, this:<br></p><p>you.doYourThingWithThis(this, that:that, these:these, those:those, other:other)<br></p><p>becomes<br></p><p>you.doYourThingWithThis(this, that, these, those, other)<br></p><p>However, if you are the type that likes to name your variables a,b,c,d, no harm done, since then labels would be required, and it would still read OK<br></p><p>you.doYourThingWithThis(a, that:b, these:c, those:d, other:e)<br></p><p>-Kenny<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9ae1f2ed10d2ef77cce06bbb5a2dcf7e?s=50"></div><header><strong>[Idea] Omit argument labels from the call site when the argument is the same as the label</strong> from <string>Alex Hoppen</string> &lt;alex at ateamer.de&gt;<p>February  7, 2016 at 09:00:00pm</p></header><div class="content"><p>I don’t think it is possible to implement this without major changes to the way function overloads are selected.<br></p><p>Consider the following example with where there are multiple functions that can print a Double (yes, the external arguments could be put in the function’s name, but I hope it shows my point):<br></p><p>func myPrint(number: Double) { }<br>func myPrint(withTwoDecimals number: Double) { }<br>func myPrint(withThreeDecimals number: Double) { }<br></p><p>Currently all three of these functions have different signatures. If your syntax would be implemented in Swift, then<br></p><p>myPrint(withTwoDecimals)<br></p><p>would be ambiguous. <br></p><p>Defaulting to the function without external parameter names in case of ambiguity isn’t an option because then the call would change its behaviour the moment a library adds myPrint(number: Double) in addition to the other functions. This is definitely not desirable! The same applies for defaulting to the function with the external parameter name.<br></p><p>I don’t like leaving the function call ambiguous because then the only way to call myPrint(number: Double) would be to change the name of the variable. The name of any variable should by private and therefore not have any effect on how the function is called. (Also think about functions where there is basically only one proper way to name a variable, like x for coordinates. You would have to rename the variable which leads to less descriptive variable names).<br></p><p>Thus, the only way to resolve this issue IMO would be to say that the signatures myPrint(number: Double) and myPrint(withTwoDecimals number: Double) are identical. Then, however, the signatures of myPrint(withTwoDecimals number: Double) and myPrint(withThreeDecimals number: Double) would need to be equivalent as well, which seriously limits the way functions can be overloaded in Swift. I don’t think that the improved syntax is worth paying with the this expressiveness of function overloads.<br></p><p>- Alex<br></p><p>&gt; On 07 Feb 2016, at 20:45, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi All.<br>&gt; <br>&gt; I’m just throwing this out there.<br>&gt; <br>&gt; often when I write Objective-C, my method calls end up looking like this:<br>&gt; <br>&gt; [you doYourThingWithThis:this that:that these:these those:those other:other];<br>&gt; <br>&gt; This reads poorly and requires extra typing. It would be nice if the compiler just assumed that when no label is given, the label is the same as the argument name. The code would be just as understandable (more) than if the argument labels were actually there.<br>&gt; <br>&gt; In Swift, this:<br>&gt; <br>&gt; you.doYourThingWithThis(this, that:that, these:these, those:those, other:other)<br>&gt; <br>&gt; becomes<br>&gt; <br>&gt; you.doYourThingWithThis(this, that, these, those, other)<br>&gt; <br>&gt; However, if you are the type that likes to name your variables a,b,c,d, no harm done, since then labels would be required, and it would still read OK<br>&gt; <br>&gt; you.doYourThingWithThis(a, that:b, these:c, those:d, other:e)<br>&gt; <br>&gt; -Kenny<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160207/a3e3675c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>[Idea] Omit argument labels from the call site when the argument is the same as the label</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>February  7, 2016 at 02:00:00pm</p></header><div class="content"><p>What if the compiler forced you to disambiguate by writing<br></p><p>myPrint(_:withTwoDecimals)<br></p><p>if you wanted to call &quot;func myPrint(number: Double) { }”<br></p><p>-Kenny<br></p><p><br>&gt; On Feb 7, 2016, at 12:41 PM, Alex Hoppen &lt;alex at ateamer.de&gt; wrote:<br>&gt; <br>&gt; I don’t think it is possible to implement this without major changes to the way function overloads are selected.<br>&gt; <br>&gt; Consider the following example with where there are multiple functions that can print a Double (yes, the external arguments could be put in the function’s name, but I hope it shows my point):<br>&gt; <br>&gt; func myPrint(number: Double) { }<br>&gt; func myPrint(withTwoDecimals number: Double) { }<br>&gt; func myPrint(withThreeDecimals number: Double) { }<br>&gt; <br>&gt; Currently all three of these functions have different signatures. If your syntax would be implemented in Swift, then<br>&gt; <br>&gt; myPrint(withTwoDecimals)<br>&gt; <br>&gt; would be ambiguous. <br>&gt; <br>&gt; Defaulting to the function without external parameter names in case of ambiguity isn’t an option because then the call would change its behaviour the moment a library adds myPrint(number: Double) in addition to the other functions. This is definitely not desirable! The same applies for defaulting to the function with the external parameter name.<br>&gt; <br>&gt; I don’t like leaving the function call ambiguous because then the only way to call myPrint(number: Double) would be to change the name of the variable. The name of any variable should by private and therefore not have any effect on how the function is called. (Also think about functions where there is basically only one proper way to name a variable, like x for coordinates. You would have to rename the variable which leads to less descriptive variable names).<br>&gt; <br>&gt; Thus, the only way to resolve this issue IMO would be to say that the signatures myPrint(number: Double) and myPrint(withTwoDecimals number: Double) are identical. Then, however, the signatures of myPrint(withTwoDecimals number: Double) and myPrint(withThreeDecimals number: Double) would need to be equivalent as well, which seriously limits the way functions can be overloaded in Swift. I don’t think that the improved syntax is worth paying with the this expressiveness of function overloads.<br>&gt; <br>&gt; - Alex<br>&gt; <br>&gt;&gt; On 07 Feb 2016, at 20:45, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi All.<br>&gt;&gt; <br>&gt;&gt; I’m just throwing this out there.<br>&gt;&gt; <br>&gt;&gt; often when I write Objective-C, my method calls end up looking like this:<br>&gt;&gt; <br>&gt;&gt; [you doYourThingWithThis:this that:that these:these those:those other:other];<br>&gt;&gt; <br>&gt;&gt; This reads poorly and requires extra typing. It would be nice if the compiler just assumed that when no label is given, the label is the same as the argument name. The code would be just as understandable (more) than if the argument labels were actually there.<br>&gt;&gt; <br>&gt;&gt; In Swift, this:<br>&gt;&gt; <br>&gt;&gt; you.doYourThingWithThis(this, that:that, these:these, those:those, other:other)<br>&gt;&gt; <br>&gt;&gt; becomes<br>&gt;&gt; <br>&gt;&gt; you.doYourThingWithThis(this, that, these, those, other)<br>&gt;&gt; <br>&gt;&gt; However, if you are the type that likes to name your variables a,b,c,d, no harm done, since then labels would be required, and it would still read OK<br>&gt;&gt; <br>&gt;&gt; you.doYourThingWithThis(a, that:b, these:c, those:d, other:e)<br>&gt;&gt; <br>&gt;&gt; -Kenny<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9ae1f2ed10d2ef77cce06bbb5a2dcf7e?s=50"></div><header><strong>[Idea] Omit argument labels from the call site when the argument is the same as the label</strong> from <string>Alex Hoppen</string> &lt;alex at ateamer.de&gt;<p>February  8, 2016 at 08:00:00am</p></header><div class="content"><p>Looks OK to me, but still I don&#39;t like the fact that the name of a local variable can change whether or not this expression is ambiguous. Basically, the function call blocks certain variable names which the caller cannot use without escaping them using &quot;_:&quot;. To me it feels like the function definition can introduce some kind of keyword and that seems weird to me. But that&#39;s of course a matter of taste.<br></p><p>- Alex<br></p><p>&gt; On 07 Feb 2016, at 23:06, Kenny Leung &lt;kenny_leung at pobox.com&gt; wrote:<br>&gt; <br>&gt; What if the compiler forced you to disambiguate by writing<br>&gt; <br>&gt; myPrint(_:withTwoDecimals)<br>&gt; <br>&gt; if you wanted to call &quot;func myPrint(number: Double) { }”<br>&gt; <br>&gt; -Kenny<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 7, 2016, at 12:41 PM, Alex Hoppen &lt;alex at ateamer.de&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I don’t think it is possible to implement this without major changes to the way function overloads are selected.<br>&gt;&gt; <br>&gt;&gt; Consider the following example with where there are multiple functions that can print a Double (yes, the external arguments could be put in the function’s name, but I hope it shows my point):<br>&gt;&gt; <br>&gt;&gt; func myPrint(number: Double) { }<br>&gt;&gt; func myPrint(withTwoDecimals number: Double) { }<br>&gt;&gt; func myPrint(withThreeDecimals number: Double) { }<br>&gt;&gt; <br>&gt;&gt; Currently all three of these functions have different signatures. If your syntax would be implemented in Swift, then<br>&gt;&gt; <br>&gt;&gt; myPrint(withTwoDecimals)<br>&gt;&gt; <br>&gt;&gt; would be ambiguous. <br>&gt;&gt; <br>&gt;&gt; Defaulting to the function without external parameter names in case of ambiguity isn’t an option because then the call would change its behaviour the moment a library adds myPrint(number: Double) in addition to the other functions. This is definitely not desirable! The same applies for defaulting to the function with the external parameter name.<br>&gt;&gt; <br>&gt;&gt; I don’t like leaving the function call ambiguous because then the only way to call myPrint(number: Double) would be to change the name of the variable. The name of any variable should by private and therefore not have any effect on how the function is called. (Also think about functions where there is basically only one proper way to name a variable, like x for coordinates. You would have to rename the variable which leads to less descriptive variable names).<br>&gt;&gt; <br>&gt;&gt; Thus, the only way to resolve this issue IMO would be to say that the signatures myPrint(number: Double) and myPrint(withTwoDecimals number: Double) are identical. Then, however, the signatures of myPrint(withTwoDecimals number: Double) and myPrint(withThreeDecimals number: Double) would need to be equivalent as well, which seriously limits the way functions can be overloaded in Swift. I don’t think that the improved syntax is worth paying with the this expressiveness of function overloads.<br>&gt;&gt; <br>&gt;&gt; - Alex<br>&gt;&gt; <br>&gt;&gt;&gt; On 07 Feb 2016, at 20:45, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi All.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m just throwing this out there.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; often when I write Objective-C, my method calls end up looking like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [you doYourThingWithThis:this that:that these:these those:those other:other];<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This reads poorly and requires extra typing. It would be nice if the compiler just assumed that when no label is given, the label is the same as the argument name. The code would be just as understandable (more) than if the argument labels were actually there.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Swift, this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; you.doYourThingWithThis(this, that:that, these:these, those:those, other:other)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; becomes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; you.doYourThingWithThis(this, that, these, those, other)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, if you are the type that likes to name your variables a,b,c,d, no harm done, since then labels would be required, and it would still read OK<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; you.doYourThingWithThis(a, that:b, these:c, those:d, other:e)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Kenny<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 2366 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/db26a396/attachment.p7s&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Idea] Omit argument labels from the call site when the argument is the same as the label</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>February  8, 2016 at 06:00:00pm</p></header><div class="content"><p>In another discussion, I proposed to make labels optional (call-side only) as long as they are not needed to choose the right method — but as there was no positive feedback from core, I didn&#39;t pursue further on this (although I still think it would be a good move, moving the whole burden of when to have labels and when to skip them out of the language itself)<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>[Idea] Omit argument labels from the call site when the argument is the same as the label</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>February  8, 2016 at 11:00:00am</p></header><div class="content"><p>Hi Tino.<br></p><p>I think my idea is significantly different from yours. Making all labels optional feels more like a “reversion” of coding style to languages that don’t have argument labels. It would still let you call a function like this:<br></p><p>    you.doYourThingWithThis(a, b, c, d, e)<br></p><p>thus making your code harder to read.<br></p><p>I think making them optional only when the variable name is the same as the label does not take away from the reader understanding exactly which method is being referred to.<br></p><p>-Kenny<br></p><p><br>&gt; On Feb 8, 2016, at 9:31 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; In another discussion, I proposed to make labels optional (call-side only) as long as they are not needed to choose the right method — but as there was no positive feedback from core, I didn&#39;t pursue further on this (although I still think it would be a good move, moving the whole burden of when to have labels and when to skip them out of the language itself)<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
