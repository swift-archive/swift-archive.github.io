<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Pitch] Consistent bridging for NSErrors at the language boundary</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May  5, 2016 at 02:00:00pm</p></header><div class="content"><p>I formerly posted a less-fleshed-out version of this in the “Reducing bridging magic” thread, but I thought this might warrant its own pitch. What do you all think?<br></p><p>MOTIVATION:<br></p><p>Over the past couple of years, Swift has made great strides toward seamless interoperability with existing Objective-C APIs, and with SE-0005, SE-0033, SE-0057, SE-0062, SE-0064, and SE-0070, seems poised to become even better in that regard. However, there still exists one major pain point when going back and forth between Swift and Objective-C, and that lies in the area of error reporting. Passing errors between Objective-C and Swift APIs is currently quite awkward, for several reasons:<br></p><p>- The Swift-approved mechanism for reporting errors is a protocol named ErrorType (ErrorProtocol in the latest sources). However, Objective-C represent errors using a class named NSError. In addition to being a reference type, which feels quite unnatural for an error object by Swift’s conventions, NSError follows a completely paradigm from what most ErrorProtocol objects use to store errors, using a string-based domain and and integer code, along with a userInfo dictionary to store information to be presented to the user. While the domain and code are available as methods on ErrorProtocol, they are prefixed with underscores, and there is no direct equivalent to userInfo.<br></p><p>- Unlike other Objective-C classes like NSString and NSArray which are consistently bridged to value types when presenting Objective-C interfaces to Swift, the handling of NSError objects is inconsistent. Objective-C APIs which return an error by reference using an autoreleasing NSError ** pointer are converted to use the Swift try/catch mechanism, presenting the returned error as an ErrorProtocol (which is actually an NSError). Similarly, Swift APIs using try/catch are presented to Objective-C as autoreleasing NSError ** pointers, and the ErrorProtocol-conforming error is converted to an NSError when it is called by Objective-C. However, when passing around error objects in any way other than these, the errors are not bridged. An Objective-C API that takes an NSError, such as NSApp’s -presentError: method, still leaves NSError as the type in the interface presented to Swift, as do the many asynchronous APIs in Cocoa that return an NSError as one of the arguments to a completion handler. Swift APIs that accept ErrorProtocols, on the other hand, are not presented to Objective-C at all, necessitating any such APIs also be declared to take NSErrors.<br></p><p>- To convert ErrorProtocols to NSErrors, Swift provides a bridging mechanism, invoked via “as NSError”, which wraps the error in a private NSError subclass class called _SwiftNativeNSError. This subclass can be cast back to the original error type, thus returning the original wrapped error. When a Swift API that is marked “throws” is called from Objective-C and then throws an error, the same bridging mechanism is invoked. However, this bridging is not very useful, since Cocoa tends to use NSError’s userInfo dictionary to present error information to the user, and ErrorProtocol contains no equivalent to the userInfo dictionary. The result of this is that when a Swift API throws an error, and this error is passed to Cocoa, the user tends to get a generic error message instead of something actually useful.<br></p><p>- The above problem means that a Swift developer must be very careful never to use “as NSError”, and to be sure to construct an NSError when throwing an error in an API that may be called from Objective-C, rather than simply throwing the error directly, or else the error will not be properly presented. If the developer makes a mistake here, it will not be known until runtime. I have personally wasted quite a bit of time trying to hunt down points in a complicated program where an error was accidentally converted to NSError via the bridge rather than explicitly.<br></p><p>- The same problem also puts the Swift developer between a rock and a hard place, if they have other code that wants to check these errors. In a pure-Swift program, checking against a particular error can often be done simply via an equality check. If the error has been converted to NSError via the bridge, this also works, since the bridge will return the original Swift error when casted. However, if the API that threw the error has been conscientious about constructing an NSError to avoid the userInfo issue, the NSError will not be easily castable back to the original Swift error type. Instead, the developer will have to compare the NSError’s error domain and code. The code itself will have to have been assigned by the throwing API. As the domain is stringly-typed and the code will often be extraneous to the actual error definition, this is all very runtime-dependent and can easily become incorrect or out of sync, which will break the program’s error reporting.<br></p><p>- The UI for creating NSError objects is extremely verbose, and eminently un-Swift-like, usually requiring two lines of code: one to construct a dictionary, with an extremely verbose key—NSLocalizedFailureReasonErrorKey—to indicate the actual error message text to the user, and one to construct the NSError object. The latter is itself quite verbose, requiring the developer to enter values for a domain and code which she typically does not care about, since ErrorProtocol provides decent enough default implementations for those values in most cases.<br></p><p>- Due to bugs in the bridging mechanism, it is possible for a _SwiftNativeNSError to get run a second time through the bridge, which removes the userInfo dictionary altogether, once again result in incorrect error reporting.<br></p><p>- The need for the “as NSError” bridging mechanism makes it more difficult to implement otherwise positive changes such as Joe Groff’s proposal to simplify the “as?” keyword (https://github.com/apple/swift-evolution/pull/289 &lt;https://github.com/apple/swift-evolution/pull/289&gt;).<br></p><p>- Finally, the fact that Swift code that deals with errors must always be filled with either “as NSError” statements or explicit NSError initializations sprinkled through results in code that is quite a bit uglier than it needs to be.<br></p><p>PROPOSED APPROACH:<br></p><p>I propose consistently bridging NSError to a value type whenever it is exposed to Swift code via an API signature, and doing the equivalent in the opposite direction, similarly to how NSStrings and Strings are bridged to and from each other in API signatures.<br></p><p>The benefits of this approach are many:<br></p><p>1. This is very similar to the bridging that already exists for String&lt;-&gt;NSString, Array&lt;-&gt;NSArray, when crossing the language boundary, so this improves the consistency of the language.<br></p><p>2. Special-case type checks would be mostly restricted to the special magic that the compiler inserts when crossing the boundary, thus reducing the potential for bugs.<br></p><p>3. NSError is no longer required to conform to ErrorProtocol, reducing the type checking that has to go on during the bridging process, also reducing the potential for bugs.<br></p><p>4. Since the is, as, as?, and as! operators would no longer be needed to bridge NSErrors to native errors and back, improvements to that mechanism such as (https://github.com/apple/swift-evolution/pull/289 &lt;https://github.com/apple/swift-evolution/pull/289&gt;) become viable, and the casting operators can be made to no longer act in ways that are often surprising and confusing.<br></p><p>5. The programmer never has to deal with NSError objects in Swift code again.<br></p><p>DETAILED DESIGN:<br></p><p>1. Extend ErrorProtocol such that it has public, non-underscored methods for the domain, code, and userInfo. The first two of these retain their existing default implementations, whereas the last of these will have a default implementation that just returns an empty dictionary. The user can override any of these to provide more information as needed.<br></p><p>2. NSError’s conformance to ErrorProtocol is removed, since Swift code will generally no longer need to work directly with NSErrors.<br></p><p>3. A new private error value type is introduced that conforms to ErrorProtocol. Since this type will be private, its specific name is up to the implementers, but for the purpose of this example we will assume that it is named _ObjCErrorType. This type wraps an NSError, and forwards its domain, code, and userInfo properties to it.<br></p><p>4. The existing _SwiftNativeNSError class remains, and continues to work as it does currently, although it is extended to forward the userInfo property to the wrapped Swift error. Thus, this class now wraps a native Swift error and forwards the domain, code, and userInfo properties to it.<br></p><p>5. Objective-C APIs that return an NSError object present it as ErrorProtocol in the signature. When called by Swift, the type of the NSError is checked. If the type is _SwiftNativeNSError, the original Swift error is unwrapped and returned. Otherwise, the NSError is wrapped in an instance of _ObjCErrorType and returned as an ErrorProtocol.<br></p><p>6. Objective-C APIs that take NSError objects now show ErrorProtocol in their signatures as well. If an _ObjCErrorType is passed to one of these APIs, its wrapped NSError is unwrapped and passed to the API. Otherwise, the error is wrapped in a _SwiftNativeNSError and passed through to the API.<br></p><p>7. Swift errors would still be convertible to NSError, if the developer needed to do so manually. This could be done either via the current “as NSError” bridge, or via initializers and/or accessors on NSError.<br></p><p>IMPACT ON EXISTING CODE:<br></p><p>Required changes to existing code will mostly involve removing “as NSError” statements. Workarounds to the problem being addressed by this change will probably also want to be removed, as they will no longer be needed.<br></p><p>ALTERNATIVES CONSIDERED:<br></p><p>Do nothing, and let the terrorists win.<br></p><p>Charles<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160505/cae1cbe4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Pitch] Consistent bridging for NSErrors at the language boundary</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May  6, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On May 5, 2016, at 2:06 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I formerly posted a less-fleshed-out version of this in the “Reducing bridging magic” thread, but I thought this might warrant its own pitch. What do you all think?<br>&gt; <br>&gt; MOTIVATION:<br>&gt; <br>&gt; Over the past couple of years, Swift has made great strides toward seamless interoperability with existing Objective-C APIs, and with SE-0005, SE-0033, SE-0057, SE-0062, SE-0064, and SE-0070, seems poised to become even better in that regard. However, there still exists one major pain point when going back and forth between Swift and Objective-C, and that lies in the area of error reporting. Passing errors between Objective-C and Swift APIs is currently quite awkward, for several reasons:<br>&gt; <br>&gt; - The Swift-approved mechanism for reporting errors is a protocol named ErrorType (ErrorProtocol in the latest sources). However, Objective-C represent errors using a class named NSError. In addition to being a reference type, which feels quite unnatural for an error object by Swift’s conventions, NSError follows a completely paradigm from what most ErrorProtocol objects use to store errors, using a string-based domain and and integer code, along with a userInfo dictionary to store information to be presented to the user. While the domain and code are available as methods on ErrorProtocol, they are prefixed with underscores, and there is no direct equivalent to userInfo.<br>&gt; <br>&gt; - Unlike other Objective-C classes like NSString and NSArray which are consistently bridged to value types when presenting Objective-C interfaces to Swift, the handling of NSError objects is inconsistent. Objective-C APIs which return an error by reference using an autoreleasing NSError ** pointer are converted to use the Swift try/catch mechanism, presenting the returned error as an ErrorProtocol (which is actually an NSError). Similarly, Swift APIs using try/catch are presented to Objective-C as autoreleasing NSError ** pointers, and the ErrorProtocol-conforming error is converted to an NSError when it is called by Objective-C. However, when passing around error objects in any way other than these, the errors are not bridged. An Objective-C API that takes an NSError, such as NSApp’s -presentError: method, still leaves NSError as the type in the interface presented to Swift, as do the many asynchronous APIs in Cocoa that return an NSError as one of the arguments to a completion handler. Swift APIs that accept ErrorProtocols, on the other hand, are not presented to Objective-C at all, necessitating any such APIs also be declared to take NSErrors.<br>&gt; <br>&gt; - To convert ErrorProtocols to NSErrors, Swift provides a bridging mechanism, invoked via “as NSError”, which wraps the error in a private NSError subclass class called _SwiftNativeNSError. This subclass can be cast back to the original error type, thus returning the original wrapped error. When a Swift API that is marked “throws” is called from Objective-C and then throws an error, the same bridging mechanism is invoked. However, this bridging is not very useful, since Cocoa tends to use NSError’s userInfo dictionary to present error information to the user, and ErrorProtocol contains no equivalent to the userInfo dictionary. The result of this is that when a Swift API throws an error, and this error is passed to Cocoa, the user tends to get a generic error message instead of something actually useful.<br>&gt; <br>&gt; - The above problem means that a Swift developer must be very careful never to use “as NSError”, and to be sure to construct an NSError when throwing an error in an API that may be called from Objective-C, rather than simply throwing the error directly, or else the error will not be properly presented. If the developer makes a mistake here, it will not be known until runtime. I have personally wasted quite a bit of time trying to hunt down points in a complicated program where an error was accidentally converted to NSError via the bridge rather than explicitly.<br>&gt; <br>&gt; - The same problem also puts the Swift developer between a rock and a hard place, if they have other code that wants to check these errors. In a pure-Swift program, checking against a particular error can often be done simply via an equality check. If the error has been converted to NSError via the bridge, this also works, since the bridge will return the original Swift error when casted. However, if the API that threw the error has been conscientious about constructing an NSError to avoid the userInfo issue, the NSError will not be easily castable back to the original Swift error type. Instead, the developer will have to compare the NSError’s error domain and code. The code itself will have to have been assigned by the throwing API. As the domain is stringly-typed and the code will often be extraneous to the actual error definition, this is all very runtime-dependent and can easily become incorrect or out of sync, which will break the program’s error reporting.<br>&gt; <br>&gt; - The UI for creating NSError objects is extremely verbose, and eminently un-Swift-like, usually requiring two lines of code: one to construct a dictionary, with an extremely verbose key—NSLocalizedFailureReasonErrorKey—to indicate the actual error message text to the user, and one to construct the NSError object. The latter is itself quite verbose, requiring the developer to enter values for a domain and code which she typically does not care about, since ErrorProtocol provides decent enough default implementations for those values in most cases.<br>&gt; <br>&gt; - Due to bugs in the bridging mechanism, it is possible for a _SwiftNativeNSError to get run a second time through the bridge, which removes the userInfo dictionary altogether, once again result in incorrect error reporting.<br>&gt; <br>&gt; - The need for the “as NSError” bridging mechanism makes it more difficult to implement otherwise positive changes such as Joe Groff’s proposal to simplify the “as?” keyword (https://github.com/apple/swift-evolution/pull/289 &lt;https://github.com/apple/swift-evolution/pull/289&gt;).<br>&gt; <br>&gt; - Finally, the fact that Swift code that deals with errors must always be filled with either “as NSError” statements or explicit NSError initializations sprinkled through results in code that is quite a bit uglier than it needs to be.<br>&gt; <br>&gt; PROPOSED APPROACH:<br>&gt; <br>&gt; I propose consistently bridging NSError to a value type whenever it is exposed to Swift code via an API signature, and doing the equivalent in the opposite direction, similarly to how NSStrings and Strings are bridged to and from each other in API signatures.<br>&gt; <br>&gt; The benefits of this approach are many:<br>&gt; <br>&gt; 1. This is very similar to the bridging that already exists for String&lt;-&gt;NSString, Array&lt;-&gt;NSArray, when crossing the language boundary, so this improves the consistency of the language.<br>&gt; <br>&gt; 2. Special-case type checks would be mostly restricted to the special magic that the compiler inserts when crossing the boundary, thus reducing the potential for bugs.<br>&gt; <br>&gt; 3. NSError is no longer required to conform to ErrorProtocol, reducing the type checking that has to go on during the bridging process, also reducing the potential for bugs.<br>&gt; <br>&gt; 4. Since the is, as, as?, and as! operators would no longer be needed to bridge NSErrors to native errors and back, improvements to that mechanism such as (https://github.com/apple/swift-evolution/pull/289 &lt;https://github.com/apple/swift-evolution/pull/289&gt;) become viable, and the casting operators can be made to no longer act in ways that are often surprising and confusing.<br>&gt; <br>&gt; 5. The programmer never has to deal with NSError objects in Swift code again.<br>&gt; <br>&gt; DETAILED DESIGN:<br>&gt; <br>&gt; 1. Extend ErrorProtocol such that it has public, non-underscored methods for the domain, code, and userInfo. The first two of these retain their existing default implementations, whereas the last of these will have a default implementation that just returns an empty dictionary. The user can override any of these to provide more information as needed.<br>&gt; <br>&gt; 2. NSError’s conformance to ErrorProtocol is removed, since Swift code will generally no longer need to work directly with NSErrors.<br>&gt; <br>&gt; 3. A new private error value type is introduced that conforms to ErrorProtocol. Since this type will be private, its specific name is up to the implementers, but for the purpose of this example we will assume that it is named _ObjCErrorType. This type wraps an NSError, and forwards its domain, code, and userInfo properties to it.<br>&gt; <br>&gt; 4. The existing _SwiftNativeNSError class remains, and continues to work as it does currently, although it is extended to forward the userInfo property to the wrapped Swift error. Thus, this class now wraps a native Swift error and forwards the domain, code, and userInfo properties to it.<br>&gt; <br>&gt; 5. Objective-C APIs that return an NSError object present it as ErrorProtocol in the signature. When called by Swift, the type of the NSError is checked. If the type is _SwiftNativeNSError, the original Swift error is unwrapped and returned. Otherwise, the NSError is wrapped in an instance of _ObjCErrorType and returned as an ErrorProtocol.<br>&gt; <br>&gt; 6. Objective-C APIs that take NSError objects now show ErrorProtocol in their signatures as well. If an _ObjCErrorType is passed to one of these APIs, its wrapped NSError is unwrapped and passed to the API. Otherwise, the error is wrapped in a _SwiftNativeNSError and passed through to the API.<br>&gt; <br>&gt; 7. Swift errors would still be convertible to NSError, if the developer needed to do so manually. This could be done either via the current “as NSError” bridge, or via initializers and/or accessors on NSError.<br>&gt; <br>&gt; IMPACT ON EXISTING CODE:<br>&gt; <br>&gt; Required changes to existing code will mostly involve removing “as NSError” statements. Workarounds to the problem being addressed by this change will probably also want to be removed, as they will no longer be needed.<br>&gt; <br>&gt; ALTERNATIVES CONSIDERED:<br>&gt; <br>&gt; Do nothing, and let the terrorists win.<br></p><p>I’ve been asked, off list, to flesh out how this would affect NSErrors that managed to slip in. What I am thinking is that this would be handled very similarly to how other bridged Foundation value types are handled:<br></p><p>let stringGotThrough: NSString = …<br>let errorGotThrough: NSError = …<br>let userInfo: [NSObject : AnyObject] = …<br></p><p>let string = stringGotThrough as String<br>let error = errorGotThrough as ErrorProtocol<br></p><p>if let failureReason = userInfo[NSLocalizedFailureReasonErrorKey] as? String {<br>    print(“Failed because: \(failureReason)”)<br>}<br></p><p>if let underlyingError = userInfo[NSUnderlyingErrorKey] as? ErrorProtocol {<br>    // do something with the underlying error<br>}<br></p><p>The obvious caveat is that since ErrorProtocol is a protocol rather than a concrete type, the bridging magic we have in place probably isn’t able to handle that, and would need to be extended. If I had to guess, I’d suppose this is why this isn’t implemented already. However, if Joe’s bridging magic reduction proposal (https://github.com/apple/swift-evolution/pull/289 &lt;https://github.com/apple/swift-evolution/pull/289&gt;) and Riley’s factory initializers proposal (https://github.com/apple/swift-evolution/pull/247 &lt;https://github.com/apple/swift-evolution/pull/247&gt;), both of which I think would be positive improvements to the language, are implemented, then this actually gets a lot easier (and simpler) to implement, as it would all be done through factory initializers, which thanks to Riley’s proposal, we’d be able to put on a protocol. So in this case, we’d have:<br></p><p>let stringGotThrough: NSString = …<br>let errorGotThrough: NSError = …<br>let userInfo: [NSObject : AnyObject] = …<br></p><p>let string = String(stringGotThrough)<br>let error = ErrorProtocol(errorGotThrough)<br></p><p>if let failureReason = String(userInfo[NSLocalizedFailureReasonWhyIsThisNameSoDamnLongErrorKey]) {<br>    print(“Failed because: \(failureReason)”)<br>}<br></p><p>if let underlyingError = ErrorProtocol(userInfo[NSUnderlyingErrorKey]) {<br>    // do something with the error<br>}<br></p><p>The crux of it for me here is that with either method, the dictionary’s just vending AnyObjects to us and thus we have to cast them anyway. Casting that AnyObject to an ErrorProtocol vs. casting it to an NSError doesn’t seem conceptually different at all to me, other than only needing to keep track of one error paradigm instead of two wildly disparate ones.<br></p><p>The factory initializers (or bridging magic) would work like this:<br></p><p>ErrorProtocol() or “as? ErrorProtocol”: Checks if the object is a _SwiftNativeNSError, and if it is, unwraps the underlying native Swift error. Otherwise, it checks if we have an NSError, and if we do, it wraps it in an _ObjCErrorType. If it’s not an NSError at all, this returns nil.<br></p><p>NSError() or “as? NSError”: Checks if the object is an _ObjCErrorType, and if it is, unwraps the underlying NSError. Otherwise, it checks if we have an ErrorProtocol, and if we do, it wraps it in a _SwiftNativeNSError. If it’s not an ErrorProtocol at all, this returns nil.<br></p><p>The “Alternatives Considered” here would be to go with a public error value type instead of the private _ObjCErrorType. In this case, it would probably just be called something like “Error” to parallel String, Array, etc.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160506/c59d4914/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Pitch] Consistent bridging for NSErrors at the language boundary</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May  9, 2016 at 02:00:00pm</p></header><div class="content"><p>Anyone have any thoughts, opinions, etc. on this? I find it kind of strange that I’ve received off-list feedback from within Apple, but so far it’s been generally ignored publicly on the list. Surely I’m not the only one who cares about the lack of parity between NSError and ErrorProtocol.<br></p><p>Charles<br></p><p>&gt; On May 6, 2016, at 10:16 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt;&gt; On May 5, 2016, at 2:06 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I formerly posted a less-fleshed-out version of this in the “Reducing bridging magic” thread, but I thought this might warrant its own pitch. What do you all think?<br>&gt;&gt; <br>&gt;&gt; MOTIVATION:<br>&gt;&gt; <br>&gt;&gt; Over the past couple of years, Swift has made great strides toward seamless interoperability with existing Objective-C APIs, and with SE-0005, SE-0033, SE-0057, SE-0062, SE-0064, and SE-0070, seems poised to become even better in that regard. However, there still exists one major pain point when going back and forth between Swift and Objective-C, and that lies in the area of error reporting. Passing errors between Objective-C and Swift APIs is currently quite awkward, for several reasons:<br>&gt;&gt; <br>&gt;&gt; - The Swift-approved mechanism for reporting errors is a protocol named ErrorType (ErrorProtocol in the latest sources). However, Objective-C represent errors using a class named NSError. In addition to being a reference type, which feels quite unnatural for an error object by Swift’s conventions, NSError follows a completely paradigm from what most ErrorProtocol objects use to store errors, using a string-based domain and and integer code, along with a userInfo dictionary to store information to be presented to the user. While the domain and code are available as methods on ErrorProtocol, they are prefixed with underscores, and there is no direct equivalent to userInfo.<br>&gt;&gt; <br>&gt;&gt; - Unlike other Objective-C classes like NSString and NSArray which are consistently bridged to value types when presenting Objective-C interfaces to Swift, the handling of NSError objects is inconsistent. Objective-C APIs which return an error by reference using an autoreleasing NSError ** pointer are converted to use the Swift try/catch mechanism, presenting the returned error as an ErrorProtocol (which is actually an NSError). Similarly, Swift APIs using try/catch are presented to Objective-C as autoreleasing NSError ** pointers, and the ErrorProtocol-conforming error is converted to an NSError when it is called by Objective-C. However, when passing around error objects in any way other than these, the errors are not bridged. An Objective-C API that takes an NSError, such as NSApp’s -presentError: method, still leaves NSError as the type in the interface presented to Swift, as do the many asynchronous APIs in Cocoa that return an NSError as one of the arguments to a completion handler. Swift APIs that accept ErrorProtocols, on the other hand, are not presented to Objective-C at all, necessitating any such APIs also be declared to take NSErrors.<br>&gt;&gt; <br>&gt;&gt; - To convert ErrorProtocols to NSErrors, Swift provides a bridging mechanism, invoked via “as NSError”, which wraps the error in a private NSError subclass class called _SwiftNativeNSError. This subclass can be cast back to the original error type, thus returning the original wrapped error. When a Swift API that is marked “throws” is called from Objective-C and then throws an error, the same bridging mechanism is invoked. However, this bridging is not very useful, since Cocoa tends to use NSError’s userInfo dictionary to present error information to the user, and ErrorProtocol contains no equivalent to the userInfo dictionary. The result of this is that when a Swift API throws an error, and this error is passed to Cocoa, the user tends to get a generic error message instead of something actually useful.<br>&gt;&gt; <br>&gt;&gt; - The above problem means that a Swift developer must be very careful never to use “as NSError”, and to be sure to construct an NSError when throwing an error in an API that may be called from Objective-C, rather than simply throwing the error directly, or else the error will not be properly presented. If the developer makes a mistake here, it will not be known until runtime. I have personally wasted quite a bit of time trying to hunt down points in a complicated program where an error was accidentally converted to NSError via the bridge rather than explicitly.<br>&gt;&gt; <br>&gt;&gt; - The same problem also puts the Swift developer between a rock and a hard place, if they have other code that wants to check these errors. In a pure-Swift program, checking against a particular error can often be done simply via an equality check. If the error has been converted to NSError via the bridge, this also works, since the bridge will return the original Swift error when casted. However, if the API that threw the error has been conscientious about constructing an NSError to avoid the userInfo issue, the NSError will not be easily castable back to the original Swift error type. Instead, the developer will have to compare the NSError’s error domain and code. The code itself will have to have been assigned by the throwing API. As the domain is stringly-typed and the code will often be extraneous to the actual error definition, this is all very runtime-dependent and can easily become incorrect or out of sync, which will break the program’s error reporting.<br>&gt;&gt; <br>&gt;&gt; - The UI for creating NSError objects is extremely verbose, and eminently un-Swift-like, usually requiring two lines of code: one to construct a dictionary, with an extremely verbose key—NSLocalizedFailureReasonErrorKey—to indicate the actual error message text to the user, and one to construct the NSError object. The latter is itself quite verbose, requiring the developer to enter values for a domain and code which she typically does not care about, since ErrorProtocol provides decent enough default implementations for those values in most cases.<br>&gt;&gt; <br>&gt;&gt; - Due to bugs in the bridging mechanism, it is possible for a _SwiftNativeNSError to get run a second time through the bridge, which removes the userInfo dictionary altogether, once again result in incorrect error reporting.<br>&gt;&gt; <br>&gt;&gt; - The need for the “as NSError” bridging mechanism makes it more difficult to implement otherwise positive changes such as Joe Groff’s proposal to simplify the “as?” keyword (https://github.com/apple/swift-evolution/pull/289 &lt;https://github.com/apple/swift-evolution/pull/289&gt;).<br>&gt;&gt; <br>&gt;&gt; - Finally, the fact that Swift code that deals with errors must always be filled with either “as NSError” statements or explicit NSError initializations sprinkled through results in code that is quite a bit uglier than it needs to be.<br>&gt;&gt; <br>&gt;&gt; PROPOSED APPROACH:<br>&gt;&gt; <br>&gt;&gt; I propose consistently bridging NSError to a value type whenever it is exposed to Swift code via an API signature, and doing the equivalent in the opposite direction, similarly to how NSStrings and Strings are bridged to and from each other in API signatures.<br>&gt;&gt; <br>&gt;&gt; The benefits of this approach are many:<br>&gt;&gt; <br>&gt;&gt; 1. This is very similar to the bridging that already exists for String&lt;-&gt;NSString, Array&lt;-&gt;NSArray, when crossing the language boundary, so this improves the consistency of the language.<br>&gt;&gt; <br>&gt;&gt; 2. Special-case type checks would be mostly restricted to the special magic that the compiler inserts when crossing the boundary, thus reducing the potential for bugs.<br>&gt;&gt; <br>&gt;&gt; 3. NSError is no longer required to conform to ErrorProtocol, reducing the type checking that has to go on during the bridging process, also reducing the potential for bugs.<br>&gt;&gt; <br>&gt;&gt; 4. Since the is, as, as?, and as! operators would no longer be needed to bridge NSErrors to native errors and back, improvements to that mechanism such as (https://github.com/apple/swift-evolution/pull/289 &lt;https://github.com/apple/swift-evolution/pull/289&gt;) become viable, and the casting operators can be made to no longer act in ways that are often surprising and confusing.<br>&gt;&gt; <br>&gt;&gt; 5. The programmer never has to deal with NSError objects in Swift code again.<br>&gt;&gt; <br>&gt;&gt; DETAILED DESIGN:<br>&gt;&gt; <br>&gt;&gt; 1. Extend ErrorProtocol such that it has public, non-underscored methods for the domain, code, and userInfo. The first two of these retain their existing default implementations, whereas the last of these will have a default implementation that just returns an empty dictionary. The user can override any of these to provide more information as needed.<br>&gt;&gt; <br>&gt;&gt; 2. NSError’s conformance to ErrorProtocol is removed, since Swift code will generally no longer need to work directly with NSErrors.<br>&gt;&gt; <br>&gt;&gt; 3. A new private error value type is introduced that conforms to ErrorProtocol. Since this type will be private, its specific name is up to the implementers, but for the purpose of this example we will assume that it is named _ObjCErrorType. This type wraps an NSError, and forwards its domain, code, and userInfo properties to it.<br>&gt;&gt; <br>&gt;&gt; 4. The existing _SwiftNativeNSError class remains, and continues to work as it does currently, although it is extended to forward the userInfo property to the wrapped Swift error. Thus, this class now wraps a native Swift error and forwards the domain, code, and userInfo properties to it.<br>&gt;&gt; <br>&gt;&gt; 5. Objective-C APIs that return an NSError object present it as ErrorProtocol in the signature. When called by Swift, the type of the NSError is checked. If the type is _SwiftNativeNSError, the original Swift error is unwrapped and returned. Otherwise, the NSError is wrapped in an instance of _ObjCErrorType and returned as an ErrorProtocol.<br>&gt;&gt; <br>&gt;&gt; 6. Objective-C APIs that take NSError objects now show ErrorProtocol in their signatures as well. If an _ObjCErrorType is passed to one of these APIs, its wrapped NSError is unwrapped and passed to the API. Otherwise, the error is wrapped in a _SwiftNativeNSError and passed through to the API.<br>&gt;&gt; <br>&gt;&gt; 7. Swift errors would still be convertible to NSError, if the developer needed to do so manually. This could be done either via the current “as NSError” bridge, or via initializers and/or accessors on NSError.<br>&gt;&gt; <br>&gt;&gt; IMPACT ON EXISTING CODE:<br>&gt;&gt; <br>&gt;&gt; Required changes to existing code will mostly involve removing “as NSError” statements. Workarounds to the problem being addressed by this change will probably also want to be removed, as they will no longer be needed.<br>&gt;&gt; <br>&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt; <br>&gt;&gt; Do nothing, and let the terrorists win.<br>&gt; <br>&gt; I’ve been asked, off list, to flesh out how this would affect NSErrors that managed to slip in. What I am thinking is that this would be handled very similarly to how other bridged Foundation value types are handled:<br>&gt; <br>&gt; let stringGotThrough: NSString = …<br>&gt; let errorGotThrough: NSError = …<br>&gt; let userInfo: [NSObject : AnyObject] = …<br>&gt; <br>&gt; let string = stringGotThrough as String<br>&gt; let error = errorGotThrough as ErrorProtocol<br>&gt; <br>&gt; if let failureReason = userInfo[NSLocalizedFailureReasonErrorKey] as? String {<br>&gt;     print(“Failed because: \(failureReason)”)<br>&gt; }<br>&gt; <br>&gt; if let underlyingError = userInfo[NSUnderlyingErrorKey] as? ErrorProtocol {<br>&gt;     // do something with the underlying error<br>&gt; }<br>&gt; <br>&gt; The obvious caveat is that since ErrorProtocol is a protocol rather than a concrete type, the bridging magic we have in place probably isn’t able to handle that, and would need to be extended. If I had to guess, I’d suppose this is why this isn’t implemented already. However, if Joe’s bridging magic reduction proposal (https://github.com/apple/swift-evolution/pull/289 &lt;https://github.com/apple/swift-evolution/pull/289&gt;) and Riley’s factory initializers proposal (https://github.com/apple/swift-evolution/pull/247 &lt;https://github.com/apple/swift-evolution/pull/247&gt;), both of which I think would be positive improvements to the language, are implemented, then this actually gets a lot easier (and simpler) to implement, as it would all be done through factory initializers, which thanks to Riley’s proposal, we’d be able to put on a protocol. So in this case, we’d have:<br>&gt; <br>&gt; let stringGotThrough: NSString = …<br>&gt; let errorGotThrough: NSError = …<br>&gt; let userInfo: [NSObject : AnyObject] = …<br>&gt; <br>&gt; let string = String(stringGotThrough)<br>&gt; let error = ErrorProtocol(errorGotThrough)<br>&gt; <br>&gt; if let failureReason = String(userInfo[NSLocalizedFailureReasonWhyIsThisNameSoDamnLongErrorKey]) {<br>&gt;     print(“Failed because: \(failureReason)”)<br>&gt; }<br>&gt; <br>&gt; if let underlyingError = ErrorProtocol(userInfo[NSUnderlyingErrorKey]) {<br>&gt;     // do something with the error<br>&gt; }<br>&gt; <br>&gt; The crux of it for me here is that with either method, the dictionary’s just vending AnyObjects to us and thus we have to cast them anyway. Casting that AnyObject to an ErrorProtocol vs. casting it to an NSError doesn’t seem conceptually different at all to me, other than only needing to keep track of one error paradigm instead of two wildly disparate ones.<br>&gt; <br>&gt; The factory initializers (or bridging magic) would work like this:<br>&gt; <br>&gt; ErrorProtocol() or “as? ErrorProtocol”: Checks if the object is a _SwiftNativeNSError, and if it is, unwraps the underlying native Swift error. Otherwise, it checks if we have an NSError, and if we do, it wraps it in an _ObjCErrorType. If it’s not an NSError at all, this returns nil.<br>&gt; <br>&gt; NSError() or “as? NSError”: Checks if the object is an _ObjCErrorType, and if it is, unwraps the underlying NSError. Otherwise, it checks if we have an ErrorProtocol, and if we do, it wraps it in a _SwiftNativeNSError. If it’s not an ErrorProtocol at all, this returns nil.<br>&gt; <br>&gt; The “Alternatives Considered” here would be to go with a public error value type instead of the private _ObjCErrorType. In this case, it would probably just be called something like “Error” to parallel String, Array, etc.<br>&gt; <br>&gt; Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/1f8b57d2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b74cd4039f0c53145a186868ab569c0?s=50"></div><header><strong>[Pitch] Consistent bridging for NSErrors at the language boundary</strong> from <string>Josh Parmenter</string> &lt;jparmenter at vectorform.com&gt;<p>May  9, 2016 at 07:00:00pm</p></header><div class="content"><p>I would support this - but I don’t feel like I have the experience yet to vet the proposal. I agree that the error handling is still something I feel like isn’t as smooth as it should be yet.<br></p><p>I’ll try to take a longer look at this today. Thanks for the reminder.<br></p><p>Best,<br>Josh<br></p><p>On May 9, 2016, at 12:26 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br></p><p>Anyone have any thoughts, opinions, etc. on this? I find it kind of strange that I’ve received off-list feedback from within Apple, but so far it’s been generally ignored publicly on the list. Surely I’m not the only one who cares about the lack of parity between NSError and ErrorProtocol.<br></p><p>Charles<br></p><p>On May 6, 2016, at 10:16 PM, Charles Srstka &lt;cocoadev at charlessoft.com&lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br></p><p>On May 5, 2016, at 2:06 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br></p><p>I formerly posted a less-fleshed-out version of this in the “Reducing bridging magic” thread, but I thought this might warrant its own pitch. What do you all think?<br></p><p>MOTIVATION:<br></p><p>Over the past couple of years, Swift has made great strides toward seamless interoperability with existing Objective-C APIs, and with SE-0005, SE-0033, SE-0057, SE-0062, SE-0064, and SE-0070, seems poised to become even better in that regard. However, there still exists one major pain point when going back and forth between Swift and Objective-C, and that lies in the area of error reporting. Passing errors between Objective-C and Swift APIs is currently quite awkward, for several reasons:<br></p><p>- The Swift-approved mechanism for reporting errors is a protocol named ErrorType (ErrorProtocol in the latest sources). However, Objective-C represent errors using a class named NSError. In addition to being a reference type, which feels quite unnatural for an error object by Swift’s conventions, NSError follows a completely paradigm from what most ErrorProtocol objects use to store errors, using a string-based domain and and integer code, along with a userInfo dictionary to store information to be presented to the user. While the domain and code are available as methods on ErrorProtocol, they are prefixed with underscores, and there is no direct equivalent to userInfo.<br></p><p>- Unlike other Objective-C classes like NSString and NSArray which are consistently bridged to value types when presenting Objective-C interfaces to Swift, the handling of NSError objects is inconsistent. Objective-C APIs which return an error by reference using an autoreleasing NSError ** pointer are converted to use the Swift try/catch mechanism, presenting the returned error as an ErrorProtocol (which is actually an NSError). Similarly, Swift APIs using try/catch are presented to Objective-C as autoreleasing NSError ** pointers, and the ErrorProtocol-conforming error is converted to an NSError when it is called by Objective-C. However, when passing around error objects in any way other than these, the errors are not bridged. An Objective-C API that takes an NSError, such as NSApp’s -presentError: method, still leaves NSError as the type in the interface presented to Swift, as do the many asynchronous APIs in Cocoa that return an NSError as one of the arguments to a completion handler. Swift APIs that accept ErrorProtocols, on the other hand, are not presented to Objective-C at all, necessitating any such APIs also be declared to take NSErrors.<br></p><p>- To convert ErrorProtocols to NSErrors, Swift provides a bridging mechanism, invoked via “as NSError”, which wraps the error in a private NSError subclass class called _SwiftNativeNSError. This subclass can be cast back to the original error type, thus returning the original wrapped error. When a Swift API that is marked “throws” is called from Objective-C and then throws an error, the same bridging mechanism is invoked. However, this bridging is not very useful, since Cocoa tends to use NSError’s userInfo dictionary to present error information to the user, and ErrorProtocol contains no equivalent to the userInfo dictionary. The result of this is that when a Swift API throws an error, and this error is passed to Cocoa, the user tends to get a generic error message instead of something actually useful.<br></p><p>- The above problem means that a Swift developer must be very careful never to use “as NSError”, and to be sure to construct an NSError when throwing an error in an API that may be called from Objective-C, rather than simply throwing the error directly, or else the error will not be properly presented. If the developer makes a mistake here, it will not be known until runtime. I have personally wasted quite a bit of time trying to hunt down points in a complicated program where an error was accidentally converted to NSError via the bridge rather than explicitly.<br></p><p>- The same problem also puts the Swift developer between a rock and a hard place, if they have other code that wants to check these errors. In a pure-Swift program, checking against a particular error can often be done simply via an equality check. If the error has been converted to NSError via the bridge, this also works, since the bridge will return the original Swift error when casted. However, if the API that threw the error has been conscientious about constructing an NSError to avoid the userInfo issue, the NSError will not be easily castable back to the original Swift error type. Instead, the developer will have to compare the NSError’s error domain and code. The code itself will have to have been assigned by the throwing API. As the domain is stringly-typed and the code will often be extraneous to the actual error definition, this is all very runtime-dependent and can easily become incorrect or out of sync, which will break the program’s error reporting.<br></p><p>- The UI for creating NSError objects is extremely verbose, and eminently un-Swift-like, usually requiring two lines of code: one to construct a dictionary, with an extremely verbose key—NSLocalizedFailureReasonErrorKey—to indicate the actual error message text to the user, and one to construct the NSError object. The latter is itself quite verbose, requiring the developer to enter values for a domain and code which she typically does not care about, since ErrorProtocol provides decent enough default implementations for those values in most cases.<br></p><p>- Due to bugs in the bridging mechanism, it is possible for a _SwiftNativeNSError to get run a second time through the bridge, which removes the userInfo dictionary altogether, once again result in incorrect error reporting.<br></p><p>- The need for the “as NSError” bridging mechanism makes it more difficult to implement otherwise positive changes such as Joe Groff’s proposal to simplify the “as?” keyword (https://github.com/apple/swift-evolution/pull/289).<br></p><p>- Finally, the fact that Swift code that deals with errors must always be filled with either “as NSError” statements or explicit NSError initializations sprinkled through results in code that is quite a bit uglier than it needs to be.<br></p><p>PROPOSED APPROACH:<br></p><p>I propose consistently bridging NSError to a value type whenever it is exposed to Swift code via an API signature, and doing the equivalent in the opposite direction, similarly to how NSStrings and Strings are bridged to and from each other in API signatures.<br></p><p>The benefits of this approach are many:<br></p><p>1. This is very similar to the bridging that already exists for String&lt;-&gt;NSString, Array&lt;-&gt;NSArray, when crossing the language boundary, so this improves the consistency of the language.<br></p><p>2. Special-case type checks would be mostly restricted to the special magic that the compiler inserts when crossing the boundary, thus reducing the potential for bugs.<br></p><p>3. NSError is no longer required to conform to ErrorProtocol, reducing the type checking that has to go on during the bridging process, also reducing the potential for bugs.<br></p><p>4. Since the is, as, as?, and as! operators would no longer be needed to bridge NSErrors to native errors and back, improvements to that mechanism such as (https://github.com/apple/swift-evolution/pull/289) become viable, and the casting operators can be made to no longer act in ways that are often surprising and confusing.<br></p><p>5. The programmer never has to deal with NSError objects in Swift code again.<br></p><p>DETAILED DESIGN:<br></p><p>1. Extend ErrorProtocol such that it has public, non-underscored methods for the domain, code, and userInfo. The first two of these retain their existing default implementations, whereas the last of these will have a default implementation that just returns an empty dictionary. The user can override any of these to provide more information as needed.<br></p><p>2. NSError’s conformance to ErrorProtocol is removed, since Swift code will generally no longer need to work directly with NSErrors.<br></p><p>3. A new private error value type is introduced that conforms to ErrorProtocol. Since this type will be private, its specific name is up to the implementers, but for the purpose of this example we will assume that it is named _ObjCErrorType. This type wraps an NSError, and forwards its domain, code, and userInfo properties to it.<br></p><p>4. The existing _SwiftNativeNSError class remains, and continues to work as it does currently, although it is extended to forward the userInfo property to the wrapped Swift error. Thus, this class now wraps a native Swift error and forwards the domain, code, and userInfo properties to it.<br></p><p>5. Objective-C APIs that return an NSError object present it as ErrorProtocol in the signature. When called by Swift, the type of the NSError is checked. If the type is _SwiftNativeNSError, the original Swift error is unwrapped and returned. Otherwise, the NSError is wrapped in an instance of _ObjCErrorType and returned as an ErrorProtocol.<br></p><p>6. Objective-C APIs that take NSError objects now show ErrorProtocol in their signatures as well. If an _ObjCErrorType is passed to one of these APIs, its wrapped NSError is unwrapped and passed to the API. Otherwise, the error is wrapped in a _SwiftNativeNSError and passed through to the API.<br></p><p>7. Swift errors would still be convertible to NSError, if the developer needed to do so manually. This could be done either via the current “as NSError” bridge, or via initializers and/or accessors on NSError.<br></p><p>IMPACT ON EXISTING CODE:<br></p><p>Required changes to existing code will mostly involve removing “as NSError” statements. Workarounds to the problem being addressed by this change will probably also want to be removed, as they will no longer be needed.<br></p><p>ALTERNATIVES CONSIDERED:<br></p><p>Do nothing, and let the terrorists win.<br></p><p>I’ve been asked, off list, to flesh out how this would affect NSErrors that managed to slip in. What I am thinking is that this would be handled very similarly to how other bridged Foundation value types are handled:<br></p><p>let stringGotThrough: NSString = …<br>let errorGotThrough: NSError = …<br>let userInfo: [NSObject : AnyObject] = …<br></p><p>let string = stringGotThrough as String<br>let error = errorGotThrough as ErrorProtocol<br></p><p>if let failureReason = userInfo[NSLocalizedFailureReasonErrorKey] as? String {<br>    print(“Failed because: \(failureReason)”)<br>}<br></p><p>if let underlyingError = userInfo[NSUnderlyingErrorKey] as? ErrorProtocol {<br>    // do something with the underlying error<br>}<br></p><p>The obvious caveat is that since ErrorProtocol is a protocol rather than a concrete type, the bridging magic we have in place probably isn’t able to handle that, and would need to be extended. If I had to guess, I’d suppose this is why this isn’t implemented already. However, if Joe’s bridging magic reduction proposal (https://github.com/apple/swift-evolution/pull/289) and Riley’s factory initializers proposal (https://github.com/apple/swift-evolution/pull/247), both of which I think would be positive improvements to the language, are implemented, then this actually gets a lot easier (and simpler) to implement, as it would all be done through factory initializers, which thanks to Riley’s proposal, we’d be able to put on a protocol. So in this case, we’d have:<br></p><p>let stringGotThrough: NSString = …<br>let errorGotThrough: NSError = …<br>let userInfo: [NSObject : AnyObject] = …<br></p><p>let string = String(stringGotThrough)<br>let error = ErrorProtocol(errorGotThrough)<br></p><p>if let failureReason = String(userInfo[NSLocalizedFailureReasonWhyIsThisNameSoDamnLongErrorKey]) {<br>    print(“Failed because: \(failureReason)”)<br>}<br></p><p>if let underlyingError = ErrorProtocol(userInfo[NSUnderlyingErrorKey]) {<br>    // do something with the error<br>}<br></p><p>The crux of it for me here is that with either method, the dictionary’s just vending AnyObjects to us and thus we have to cast them anyway. Casting that AnyObject to an ErrorProtocol vs. casting it to an NSError doesn’t seem conceptually different at all to me, other than only needing to keep track of one error paradigm instead of two wildly disparate ones.<br></p><p>The factory initializers (or bridging magic) would work like this:<br></p><p>ErrorProtocol() or “as? ErrorProtocol”: Checks if the object is a _SwiftNativeNSError, and if it is, unwraps the underlying native Swift error. Otherwise, it checks if we have an NSError, and if we do, it wraps it in an _ObjCErrorType. If it’s not an NSError at all, this returns nil.<br></p><p>NSError() or “as? NSError”: Checks if the object is an _ObjCErrorType, and if it is, unwraps the underlying NSError. Otherwise, it checks if we have an ErrorProtocol, and if we do, it wraps it in a _SwiftNativeNSError. If it’s not an ErrorProtocol at all, this returns nil.<br></p><p>The “Alternatives Considered” here would be to go with a public error value type instead of the private _ObjCErrorType. In this case, it would probably just be called something like “Error” to parallel String, Array, etc.<br></p><p>Charles<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Pitch] Consistent bridging for NSErrors at the language boundary</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May 12, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On May 6, 2016, at 10:16 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt;&gt; On May 5, 2016, at 2:06 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I formerly posted a less-fleshed-out version of this in the “Reducing bridging magic” thread, but I thought this might warrant its own pitch. What do you all think?<br>&gt;&gt; <br>&gt;&gt; MOTIVATION:<br>&gt;&gt; <br>&gt;&gt; Over the past couple of years, Swift has made great strides toward seamless interoperability with existing Objective-C APIs, and with SE-0005, SE-0033, SE-0057, SE-0062, SE-0064, and SE-0070, seems poised to become even better in that regard. However, there still exists one major pain point when going back and forth between Swift and Objective-C, and that lies in the area of error reporting. Passing errors between Objective-C and Swift APIs is currently quite awkward, for several reasons:<br>&gt;&gt; <br>&gt;&gt; - The Swift-approved mechanism for reporting errors is a protocol named ErrorType (ErrorProtocol in the latest sources). However, Objective-C represent errors using a class named NSError. In addition to being a reference type, which feels quite unnatural for an error object by Swift’s conventions, NSError follows a completely paradigm from what most ErrorProtocol objects use to store errors, using a string-based domain and and integer code, along with a userInfo dictionary to store information to be presented to the user. While the domain and code are available as methods on ErrorProtocol, they are prefixed with underscores, and there is no direct equivalent to userInfo.<br>&gt;&gt; <br>&gt;&gt; - Unlike other Objective-C classes like NSString and NSArray which are consistently bridged to value types when presenting Objective-C interfaces to Swift, the handling of NSError objects is inconsistent. Objective-C APIs which return an error by reference using an autoreleasing NSError ** pointer are converted to use the Swift try/catch mechanism, presenting the returned error as an ErrorProtocol (which is actually an NSError). Similarly, Swift APIs using try/catch are presented to Objective-C as autoreleasing NSError ** pointers, and the ErrorProtocol-conforming error is converted to an NSError when it is called by Objective-C. However, when passing around error objects in any way other than these, the errors are not bridged. An Objective-C API that takes an NSError, such as NSApp’s -presentError: method, still leaves NSError as the type in the interface presented to Swift, as do the many asynchronous APIs in Cocoa that return an NSError as one of the arguments to a completion handler. Swift APIs that accept ErrorProtocols, on the other hand, are not presented to Objective-C at all, necessitating any such APIs also be declared to take NSErrors.<br>&gt;&gt; <br>&gt;&gt; - To convert ErrorProtocols to NSErrors, Swift provides a bridging mechanism, invoked via “as NSError”, which wraps the error in a private NSError subclass class called _SwiftNativeNSError. This subclass can be cast back to the original error type, thus returning the original wrapped error. When a Swift API that is marked “throws” is called from Objective-C and then throws an error, the same bridging mechanism is invoked. However, this bridging is not very useful, since Cocoa tends to use NSError’s userInfo dictionary to present error information to the user, and ErrorProtocol contains no equivalent to the userInfo dictionary. The result of this is that when a Swift API throws an error, and this error is passed to Cocoa, the user tends to get a generic error message instead of something actually useful.<br>&gt;&gt; <br>&gt;&gt; - The above problem means that a Swift developer must be very careful never to use “as NSError”, and to be sure to construct an NSError when throwing an error in an API that may be called from Objective-C, rather than simply throwing the error directly, or else the error will not be properly presented. If the developer makes a mistake here, it will not be known until runtime. I have personally wasted quite a bit of time trying to hunt down points in a complicated program where an error was accidentally converted to NSError via the bridge rather than explicitly.<br>&gt;&gt; <br>&gt;&gt; - The same problem also puts the Swift developer between a rock and a hard place, if they have other code that wants to check these errors. In a pure-Swift program, checking against a particular error can often be done simply via an equality check. If the error has been converted to NSError via the bridge, this also works, since the bridge will return the original Swift error when casted. However, if the API that threw the error has been conscientious about constructing an NSError to avoid the userInfo issue, the NSError will not be easily castable back to the original Swift error type. Instead, the developer will have to compare the NSError’s error domain and code. The code itself will have to have been assigned by the throwing API. As the domain is stringly-typed and the code will often be extraneous to the actual error definition, this is all very runtime-dependent and can easily become incorrect or out of sync, which will break the program’s error reporting.<br>&gt;&gt; <br>&gt;&gt; - The UI for creating NSError objects is extremely verbose, and eminently un-Swift-like, usually requiring two lines of code: one to construct a dictionary, with an extremely verbose key—NSLocalizedFailureReasonErrorKey—to indicate the actual error message text to the user, and one to construct the NSError object. The latter is itself quite verbose, requiring the developer to enter values for a domain and code which she typically does not care about, since ErrorProtocol provides decent enough default implementations for those values in most cases.<br>&gt;&gt; <br>&gt;&gt; - Due to bugs in the bridging mechanism, it is possible for a _SwiftNativeNSError to get run a second time through the bridge, which removes the userInfo dictionary altogether, once again result in incorrect error reporting.<br>&gt;&gt; <br>&gt;&gt; - The need for the “as NSError” bridging mechanism makes it more difficult to implement otherwise positive changes such as Joe Groff’s proposal to simplify the “as?” keyword (https://github.com/apple/swift-evolution/pull/289 &lt;https://github.com/apple/swift-evolution/pull/289&gt;).<br>&gt;&gt; <br>&gt;&gt; - Finally, the fact that Swift code that deals with errors must always be filled with either “as NSError” statements or explicit NSError initializations sprinkled through results in code that is quite a bit uglier than it needs to be.<br>&gt;&gt; <br>&gt;&gt; PROPOSED APPROACH:<br>&gt;&gt; <br>&gt;&gt; I propose consistently bridging NSError to a value type whenever it is exposed to Swift code via an API signature, and doing the equivalent in the opposite direction, similarly to how NSStrings and Strings are bridged to and from each other in API signatures.<br>&gt;&gt; <br>&gt;&gt; The benefits of this approach are many:<br>&gt;&gt; <br>&gt;&gt; 1. This is very similar to the bridging that already exists for String&lt;-&gt;NSString, Array&lt;-&gt;NSArray, when crossing the language boundary, so this improves the consistency of the language.<br>&gt;&gt; <br>&gt;&gt; 2. Special-case type checks would be mostly restricted to the special magic that the compiler inserts when crossing the boundary, thus reducing the potential for bugs.<br>&gt;&gt; <br>&gt;&gt; 3. NSError is no longer required to conform to ErrorProtocol, reducing the type checking that has to go on during the bridging process, also reducing the potential for bugs.<br>&gt;&gt; <br>&gt;&gt; 4. Since the is, as, as?, and as! operators would no longer be needed to bridge NSErrors to native errors and back, improvements to that mechanism such as (https://github.com/apple/swift-evolution/pull/289 &lt;https://github.com/apple/swift-evolution/pull/289&gt;) become viable, and the casting operators can be made to no longer act in ways that are often surprising and confusing.<br>&gt;&gt; <br>&gt;&gt; 5. The programmer never has to deal with NSError objects in Swift code again.<br>&gt;&gt; <br>&gt;&gt; DETAILED DESIGN:<br>&gt;&gt; <br>&gt;&gt; 1. Extend ErrorProtocol such that it has public, non-underscored methods for the domain, code, and userInfo. The first two of these retain their existing default implementations, whereas the last of these will have a default implementation that just returns an empty dictionary. The user can override any of these to provide more information as needed.<br>&gt;&gt; <br>&gt;&gt; 2. NSError’s conformance to ErrorProtocol is removed, since Swift code will generally no longer need to work directly with NSErrors.<br>&gt;&gt; <br>&gt;&gt; 3. A new private error value type is introduced that conforms to ErrorProtocol. Since this type will be private, its specific name is up to the implementers, but for the purpose of this example we will assume that it is named _ObjCErrorType. This type wraps an NSError, and forwards its domain, code, and userInfo properties to it.<br>&gt;&gt; <br>&gt;&gt; 4. The existing _SwiftNativeNSError class remains, and continues to work as it does currently, although it is extended to forward the userInfo property to the wrapped Swift error. Thus, this class now wraps a native Swift error and forwards the domain, code, and userInfo properties to it.<br>&gt;&gt; <br>&gt;&gt; 5. Objective-C APIs that return an NSError object present it as ErrorProtocol in the signature. When called by Swift, the type of the NSError is checked. If the type is _SwiftNativeNSError, the original Swift error is unwrapped and returned. Otherwise, the NSError is wrapped in an instance of _ObjCErrorType and returned as an ErrorProtocol.<br>&gt;&gt; <br>&gt;&gt; 6. Objective-C APIs that take NSError objects now show ErrorProtocol in their signatures as well. If an _ObjCErrorType is passed to one of these APIs, its wrapped NSError is unwrapped and passed to the API. Otherwise, the error is wrapped in a _SwiftNativeNSError and passed through to the API.<br>&gt;&gt; <br>&gt;&gt; 7. Swift errors would still be convertible to NSError, if the developer needed to do so manually. This could be done either via the current “as NSError” bridge, or via initializers and/or accessors on NSError.<br>&gt;&gt; <br>&gt;&gt; IMPACT ON EXISTING CODE:<br>&gt;&gt; <br>&gt;&gt; Required changes to existing code will mostly involve removing “as NSError” statements. Workarounds to the problem being addressed by this change will probably also want to be removed, as they will no longer be needed.<br>&gt;&gt; <br>&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt; <br>&gt;&gt; Do nothing, and let the terrorists win.<br>&gt; <br>&gt; I’ve been asked, off list, to flesh out how this would affect NSErrors that managed to slip in. What I am thinking is that this would be handled very similarly to how other bridged Foundation value types are handled:<br>&gt; <br>&gt; let stringGotThrough: NSString = …<br>&gt; let errorGotThrough: NSError = …<br>&gt; let userInfo: [NSObject : AnyObject] = …<br>&gt; <br>&gt; let string = stringGotThrough as String<br>&gt; let error = errorGotThrough as ErrorProtocol<br>&gt; <br>&gt; if let failureReason = userInfo[NSLocalizedFailureReasonErrorKey] as? String {<br>&gt;     print(“Failed because: \(failureReason)”)<br>&gt; }<br>&gt; <br>&gt; if let underlyingError = userInfo[NSUnderlyingErrorKey] as? ErrorProtocol {<br>&gt;     // do something with the underlying error<br>&gt; }<br>&gt; <br>&gt; The obvious caveat is that since ErrorProtocol is a protocol rather than a concrete type, the bridging magic we have in place probably isn’t able to handle that, and would need to be extended. If I had to guess, I’d suppose this is why this isn’t implemented already. However, if Joe’s bridging magic reduction proposal (https://github.com/apple/swift-evolution/pull/289 &lt;https://github.com/apple/swift-evolution/pull/289&gt;) and Riley’s factory initializers proposal (https://github.com/apple/swift-evolution/pull/247 &lt;https://github.com/apple/swift-evolution/pull/247&gt;), both of which I think would be positive improvements to the language, are implemented, then this actually gets a lot easier (and simpler) to implement, as it would all be done through factory initializers, which thanks to Riley’s proposal, we’d be able to put on a protocol. So in this case, we’d have:<br>&gt; <br>&gt; let stringGotThrough: NSString = …<br>&gt; let errorGotThrough: NSError = …<br>&gt; let userInfo: [NSObject : AnyObject] = …<br>&gt; <br>&gt; let string = String(stringGotThrough)<br>&gt; let error = ErrorProtocol(errorGotThrough)<br>&gt; <br>&gt; if let failureReason = String(userInfo[NSLocalizedFailureReasonWhyIsThisNameSoDamnLongErrorKey]) {<br>&gt;     print(“Failed because: \(failureReason)”)<br>&gt; }<br>&gt; <br>&gt; if let underlyingError = ErrorProtocol(userInfo[NSUnderlyingErrorKey]) {<br>&gt;     // do something with the error<br>&gt; }<br>&gt; <br>&gt; The crux of it for me here is that with either method, the dictionary’s just vending AnyObjects to us and thus we have to cast them anyway. Casting that AnyObject to an ErrorProtocol vs. casting it to an NSError doesn’t seem conceptually different at all to me, other than only needing to keep track of one error paradigm instead of two wildly disparate ones.<br>&gt; <br>&gt; The factory initializers (or bridging magic) would work like this:<br>&gt; <br>&gt; ErrorProtocol() or “as? ErrorProtocol”: Checks if the object is a _SwiftNativeNSError, and if it is, unwraps the underlying native Swift error. Otherwise, it checks if we have an NSError, and if we do, it wraps it in an _ObjCErrorType. If it’s not an NSError at all, this returns nil.<br>&gt; <br>&gt; NSError() or “as? NSError”: Checks if the object is an _ObjCErrorType, and if it is, unwraps the underlying NSError. Otherwise, it checks if we have an ErrorProtocol, and if we do, it wraps it in a _SwiftNativeNSError. If it’s not an ErrorProtocol at all, this returns nil.<br>&gt; <br>&gt; The “Alternatives Considered” here would be to go with a public error value type instead of the private _ObjCErrorType. In this case, it would probably just be called something like “Error” to parallel String, Array, etc.<br>&gt; <br>&gt; Charles<br></p><p>One more bump to solicit feedback before I just go ahead and write up a proposal as is (other than fixing up grammatical mistakes).<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/61bbf4bc/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44b9c3e92a40313850fdbc2cb0abdef7?s=50"></div><header><strong>[Pitch] Consistent bridging for NSErrors at the language boundary</strong> from <string>Jon Shier</string> &lt;jon at jonshier.com&gt;<p>May 14, 2016 at 01:00:00am</p></header><div class="content"><p>Charles:<br>	I appreciate the attempt to minimize a current pain point and I agree on most of your analysis of the current NSError bridging but I think your proposal is fundamentally flawed. By forcing the core error type to have properties from NSError, you’re essentially finalizing what all error types in Swift should look like. Error domains, codes, and info dictionaries are not Swift, and forcing every error produced in Swift to have those properties is a regression from the freedom ErrorType has given us. No native Swift error type I’ve seen so far has chosen to replicate those properties, and for good reason: they are a relic of C which have no place in Swift. There are far better error designs out there. If you want to propose a strong type of error for Swift, go ahead, but it should be thoroughly inspired by Swift, not driven by a desire to ease bridging to NSError.<br></p><p><br></p><p>Jon Shier<br></p><p><br>&gt; On May 5, 2016, at 3:06 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I formerly posted a less-fleshed-out version of this in the “Reducing bridging magic” thread, but I thought this might warrant its own pitch. What do you all think?<br>&gt; <br>&gt; MOTIVATION:<br>&gt; <br>&gt; Over the past couple of years, Swift has made great strides toward seamless interoperability with existing Objective-C APIs, and with SE-0005, SE-0033, SE-0057, SE-0062, SE-0064, and SE-0070, seems poised to become even better in that regard. However, there still exists one major pain point when going back and forth between Swift and Objective-C, and that lies in the area of error reporting. Passing errors between Objective-C and Swift APIs is currently quite awkward, for several reasons:<br>&gt; <br>&gt; - The Swift-approved mechanism for reporting errors is a protocol named ErrorType (ErrorProtocol in the latest sources). However, Objective-C represent errors using a class named NSError. In addition to being a reference type, which feels quite unnatural for an error object by Swift’s conventions, NSError follows a completely paradigm from what most ErrorProtocol objects use to store errors, using a string-based domain and and integer code, along with a userInfo dictionary to store information to be presented to the user. While the domain and code are available as methods on ErrorProtocol, they are prefixed with underscores, and there is no direct equivalent to userInfo.<br>&gt; <br>&gt; - Unlike other Objective-C classes like NSString and NSArray which are consistently bridged to value types when presenting Objective-C interfaces to Swift, the handling of NSError objects is inconsistent. Objective-C APIs which return an error by reference using an autoreleasing NSError ** pointer are converted to use the Swift try/catch mechanism, presenting the returned error as an ErrorProtocol (which is actually an NSError). Similarly, Swift APIs using try/catch are presented to Objective-C as autoreleasing NSError ** pointers, and the ErrorProtocol-conforming error is converted to an NSError when it is called by Objective-C. However, when passing around error objects in any way other than these, the errors are not bridged. An Objective-C API that takes an NSError, such as NSApp’s -presentError: method, still leaves NSError as the type in the interface presented to Swift, as do the many asynchronous APIs in Cocoa that return an NSError as one of the arguments to a completion handler. Swift APIs that accept ErrorProtocols, on the other hand, are not presented to Objective-C at all, necessitating any such APIs also be declared to take NSErrors.<br>&gt; <br>&gt; - To convert ErrorProtocols to NSErrors, Swift provides a bridging mechanism, invoked via “as NSError”, which wraps the error in a private NSError subclass class called _SwiftNativeNSError. This subclass can be cast back to the original error type, thus returning the original wrapped error. When a Swift API that is marked “throws” is called from Objective-C and then throws an error, the same bridging mechanism is invoked. However, this bridging is not very useful, since Cocoa tends to use NSError’s userInfo dictionary to present error information to the user, and ErrorProtocol contains no equivalent to the userInfo dictionary. The result of this is that when a Swift API throws an error, and this error is passed to Cocoa, the user tends to get a generic error message instead of something actually useful.<br>&gt; <br>&gt; - The above problem means that a Swift developer must be very careful never to use “as NSError”, and to be sure to construct an NSError when throwing an error in an API that may be called from Objective-C, rather than simply throwing the error directly, or else the error will not be properly presented. If the developer makes a mistake here, it will not be known until runtime. I have personally wasted quite a bit of time trying to hunt down points in a complicated program where an error was accidentally converted to NSError via the bridge rather than explicitly.<br>&gt; <br>&gt; - The same problem also puts the Swift developer between a rock and a hard place, if they have other code that wants to check these errors. In a pure-Swift program, checking against a particular error can often be done simply via an equality check. If the error has been converted to NSError via the bridge, this also works, since the bridge will return the original Swift error when casted. However, if the API that threw the error has been conscientious about constructing an NSError to avoid the userInfo issue, the NSError will not be easily castable back to the original Swift error type. Instead, the developer will have to compare the NSError’s error domain and code. The code itself will have to have been assigned by the throwing API. As the domain is stringly-typed and the code will often be extraneous to the actual error definition, this is all very runtime-dependent and can easily become incorrect or out of sync, which will break the program’s error reporting.<br>&gt; <br>&gt; - The UI for creating NSError objects is extremely verbose, and eminently un-Swift-like, usually requiring two lines of code: one to construct a dictionary, with an extremely verbose key—NSLocalizedFailureReasonErrorKey—to indicate the actual error message text to the user, and one to construct the NSError object. The latter is itself quite verbose, requiring the developer to enter values for a domain and code which she typically does not care about, since ErrorProtocol provides decent enough default implementations for those values in most cases.<br>&gt; <br>&gt; - Due to bugs in the bridging mechanism, it is possible for a _SwiftNativeNSError to get run a second time through the bridge, which removes the userInfo dictionary altogether, once again result in incorrect error reporting.<br>&gt; <br>&gt; - The need for the “as NSError” bridging mechanism makes it more difficult to implement otherwise positive changes such as Joe Groff’s proposal to simplify the “as?” keyword (https://github.com/apple/swift-evolution/pull/289 &lt;https://github.com/apple/swift-evolution/pull/289&gt;).<br>&gt; <br>&gt; - Finally, the fact that Swift code that deals with errors must always be filled with either “as NSError” statements or explicit NSError initializations sprinkled through results in code that is quite a bit uglier than it needs to be.<br>&gt; <br>&gt; PROPOSED APPROACH:<br>&gt; <br>&gt; I propose consistently bridging NSError to a value type whenever it is exposed to Swift code via an API signature, and doing the equivalent in the opposite direction, similarly to how NSStrings and Strings are bridged to and from each other in API signatures.<br>&gt; <br>&gt; The benefits of this approach are many:<br>&gt; <br>&gt; 1. This is very similar to the bridging that already exists for String&lt;-&gt;NSString, Array&lt;-&gt;NSArray, when crossing the language boundary, so this improves the consistency of the language.<br>&gt; <br>&gt; 2. Special-case type checks would be mostly restricted to the special magic that the compiler inserts when crossing the boundary, thus reducing the potential for bugs.<br>&gt; <br>&gt; 3. NSError is no longer required to conform to ErrorProtocol, reducing the type checking that has to go on during the bridging process, also reducing the potential for bugs.<br>&gt; <br>&gt; 4. Since the is, as, as?, and as! operators would no longer be needed to bridge NSErrors to native errors and back, improvements to that mechanism such as (https://github.com/apple/swift-evolution/pull/289 &lt;https://github.com/apple/swift-evolution/pull/289&gt;) become viable, and the casting operators can be made to no longer act in ways that are often surprising and confusing.<br>&gt; <br>&gt; 5. The programmer never has to deal with NSError objects in Swift code again.<br>&gt; <br>&gt; DETAILED DESIGN:<br>&gt; <br>&gt; 1. Extend ErrorProtocol such that it has public, non-underscored methods for the domain, code, and userInfo. The first two of these retain their existing default implementations, whereas the last of these will have a default implementation that just returns an empty dictionary. The user can override any of these to provide more information as needed.<br>&gt; <br>&gt; 2. NSError’s conformance to ErrorProtocol is removed, since Swift code will generally no longer need to work directly with NSErrors.<br>&gt; <br>&gt; 3. A new private error value type is introduced that conforms to ErrorProtocol. Since this type will be private, its specific name is up to the implementers, but for the purpose of this example we will assume that it is named _ObjCErrorType. This type wraps an NSError, and forwards its domain, code, and userInfo properties to it.<br>&gt; <br>&gt; 4. The existing _SwiftNativeNSError class remains, and continues to work as it does currently, although it is extended to forward the userInfo property to the wrapped Swift error. Thus, this class now wraps a native Swift error and forwards the domain, code, and userInfo properties to it.<br>&gt; <br>&gt; 5. Objective-C APIs that return an NSError object present it as ErrorProtocol in the signature. When called by Swift, the type of the NSError is checked. If the type is _SwiftNativeNSError, the original Swift error is unwrapped and returned. Otherwise, the NSError is wrapped in an instance of _ObjCErrorType and returned as an ErrorProtocol.<br>&gt; <br>&gt; 6. Objective-C APIs that take NSError objects now show ErrorProtocol in their signatures as well. If an _ObjCErrorType is passed to one of these APIs, its wrapped NSError is unwrapped and passed to the API. Otherwise, the error is wrapped in a _SwiftNativeNSError and passed through to the API.<br>&gt; <br>&gt; 7. Swift errors would still be convertible to NSError, if the developer needed to do so manually. This could be done either via the current “as NSError” bridge, or via initializers and/or accessors on NSError.<br>&gt; <br>&gt; IMPACT ON EXISTING CODE:<br>&gt; <br>&gt; Required changes to existing code will mostly involve removing “as NSError” statements. Workarounds to the problem being addressed by this change will probably also want to be removed, as they will no longer be needed.<br>&gt; <br>&gt; ALTERNATIVES CONSIDERED:<br>&gt; <br>&gt; Do nothing, and let the terrorists win.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160514/480f784a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Pitch] Consistent bridging for NSErrors at the language boundary</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May 14, 2016 at 12:00:00am</p></header><div class="content"><p>On May 14, 2016, at 12:19 AM, Jon Shier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Charles:<br>&gt; 	I appreciate the attempt to minimize a current pain point and I agree on most of your analysis of the current NSError bridging but I think your proposal is fundamentally flawed. By forcing the core error type to have properties from NSError, you’re essentially finalizing what all error types in Swift should look like. Error domains, codes, and info dictionaries are not Swift, and forcing every error produced in Swift to have those properties is a regression from the freedom ErrorType has given us. No native Swift error type I’ve seen so far has chosen to replicate those properties, and for good reason: they are a relic of C which have no place in Swift. There are far better error designs out there. If you want to propose a strong type of error for Swift, go ahead, but it should be thoroughly inspired by Swift, not driven by a desire to ease bridging to NSError.<br></p><p>Nothing is forced at all, any more than they are currently. The thing to remember is that ErrorProtocol *already* defines properties for error domains and codes:<br></p><p>public protocol ErrorProtocol {<br>  var _domain: String { get }<br>  var _code: Int { get }<br>}<br></p><p>Thus, the statement that no native Swift error type has these properties could not be farther from the truth, as in fact, *every* Swift error type has these two properties (and several prominent error types in the standard library provide specific values for these properties as well; POSIXError and NSCocoaError come to mind). The reason many Swift developers haven’t noticed this fact is because the properties have default implementations, which means that if you don’t have a specific need to override them, you never have to deal with them. Adding a userInfo property, which also has a default implementation (returning an empty dictionary), will therefore not take away any of the freedom of ErrorType, or really cause any difference at all to a developer who is not interested in providing userInfo values on his/her errors.<br></p><p>What the proposal will do, on the other hand, is give a lot of that freedom *back*. The fact of the matter is that the entire error-reporting mechanism is currently based on NSError. If you have a method which can return an error, and you want that error to be presentable to the user in a form more expressive than “MyApp.MyErrorType error 2”, you currently have only two choices: 1) create some home-grown mechanism to convert your errors to NSErrors, and be sure to invoke that mechanism when throwing from any method that could conceivably be called from Objective-C, or 2) just use NSErrors all the way down, foregoing the use of native Swift errors at all. My proposal would allow the free and unlimited use of Swift native errors everywhere errors are a possibility with no drawbacks, since if an error needed to be made into a human-readable form, this would only be a simple matter of defining a userInfo property on the error type, even if much later down the line, and would not necessitate adding an NSError conversion at every throw-site in the program. Indeed, this proposal will actually *remove* a lot of NSError-based thinking from the actual code, and localize all such considerations to a relatively small area, to such extent as they are needed.<br></p><p>Charles<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44b9c3e92a40313850fdbc2cb0abdef7?s=50"></div><header><strong>[Pitch] Consistent bridging for NSErrors at the language boundary</strong> from <string>Jon Shier</string> &lt;jon at jonshier.com&gt;<p>May 14, 2016 at 02:00:00am</p></header><div class="content"><p>Charles:<br>	Foundation error reporting is based on NSError, nothing else. In none of my apps have I used my own NSError’s and in the few frameworks I use or maintain, few use NSError, and then only to avoid having to declare a custom error type, to make the API perhaps a bit more familiar to consumers. All your concern about conversion to and from NSErrors is largely irrelevant to anyone who isn’t using Swift from Objective-C on a regular basis. It’s utterly irrelevant to the native Swift programmer. I’m not sure where your issue about presenting non-NSError’s come from, since the mechanisms to present an error would have to be custom written no matter the error type. The drawbacks I see with exposing NSError’s properties on every ErrorType is that those properties are only there as a hack to interoperate with NSError. Really they’d go away as Swift evolves it’s own default error representation, or language leaves it to developer to build their own. <br>	Essentially, I think that if you want to improve ErrorType, formalizing its relationship to NSError is the wrong way. NSErrors are not good error representations, especially in Swift, and we should move away from them as soon as possible.<br></p><p><br>Jon<br> <br>&gt; On May 14, 2016, at 1:46 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt; On May 14, 2016, at 12:19 AM, Jon Shier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Charles:<br>&gt;&gt; 	I appreciate the attempt to minimize a current pain point and I agree on most of your analysis of the current NSError bridging but I think your proposal is fundamentally flawed. By forcing the core error type to have properties from NSError, you’re essentially finalizing what all error types in Swift should look like. Error domains, codes, and info dictionaries are not Swift, and forcing every error produced in Swift to have those properties is a regression from the freedom ErrorType has given us. No native Swift error type I’ve seen so far has chosen to replicate those properties, and for good reason: they are a relic of C which have no place in Swift. There are far better error designs out there. If you want to propose a strong type of error for Swift, go ahead, but it should be thoroughly inspired by Swift, not driven by a desire to ease bridging to NSError.<br>&gt; <br>&gt; Nothing is forced at all, any more than they are currently. The thing to remember is that ErrorProtocol *already* defines properties for error domains and codes:<br>&gt; <br>&gt; public protocol ErrorProtocol {<br>&gt;  var _domain: String { get }<br>&gt;  var _code: Int { get }<br>&gt; }<br>&gt; <br>&gt; Thus, the statement that no native Swift error type has these properties could not be farther from the truth, as in fact, *every* Swift error type has these two properties (and several prominent error types in the standard library provide specific values for these properties as well; POSIXError and NSCocoaError come to mind). The reason many Swift developers haven’t noticed this fact is because the properties have default implementations, which means that if you don’t have a specific need to override them, you never have to deal with them. Adding a userInfo property, which also has a default implementation (returning an empty dictionary), will therefore not take away any of the freedom of ErrorType, or really cause any difference at all to a developer who is not interested in providing userInfo values on his/her errors.<br>&gt; <br>&gt; What the proposal will do, on the other hand, is give a lot of that freedom *back*. The fact of the matter is that the entire error-reporting mechanism is currently based on NSError. If you have a method which can return an error, and you want that error to be presentable to the user in a form more expressive than “MyApp.MyErrorType error 2”, you currently have only two choices: 1) create some home-grown mechanism to convert your errors to NSErrors, and be sure to invoke that mechanism when throwing from any method that could conceivably be called from Objective-C, or 2) just use NSErrors all the way down, foregoing the use of native Swift errors at all. My proposal would allow the free and unlimited use of Swift native errors everywhere errors are a possibility with no drawbacks, since if an error needed to be made into a human-readable form, this would only be a simple matter of defining a userInfo property on the error type, even if much later down the line, and would not necessitate adding an NSError conversion at every throw-site in the program. Indeed, this proposal will actually *remove* a lot of NSError-based thinking from the actual code, and localize all such considerations to a relatively small area, to such extent as they are needed.<br>&gt; <br>&gt; Charles<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Pitch] Consistent bridging for NSErrors at the language boundary</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May 14, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; On May 14, 2016, at 1:45 AM, Jon Shier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Charles:<br>&gt; 	Foundation error reporting is based on NSError, nothing else. In none of my apps have I used my own NSError’s and in the few frameworks I use or maintain, few use NSError, and then only to avoid having to declare a custom error type, to make the API perhaps a bit more familiar to consumers.<br></p><p>All of the error-handling mechanisms in Cocoa are NSError-based. -[NSApplication presentError:], -[NSDocument presentError:], and the like all take NSErrors.<br></p><p>&gt; All your concern about conversion to and from NSErrors is largely irrelevant to anyone who isn’t using Swift from Objective-C on a regular basis. It’s utterly irrelevant to the native Swift programmer. I’m not sure where your issue about presenting non-NSError’s come from, since the mechanisms to present an error would have to be custom written no matter the error type.<br></p><p>Anyone who writes Cocoa apps on OS X or iOS using Swift is most certainly using Swift from Objective-C on a regular basis, because all of the underlying frameworks are Objective-C. For example, suppose you have a document-based application:<br></p><p>class MyDocument: NSDocument {<br>    enum Error: ErrorType {<br>        case MadeAMistake<br>        case RanOutOfCake<br>    }<br></p><p>    …<br></p><p>    readFromData(data: NSData, ofType: String) {<br>        …<br></p><p>        if someFailureCondition {<br>            throw Error.RanOutOfCake<br>        }<br></p><p>        ...<br>    }<br></p><p>    ...<br>}<br></p><p>The readFromData method above will be called by Objective-C, since the internal NSDocument mechanism will be the one calling it. Since it will have no idea how to represent that, the error dialog box that appears will simply say something unhelpful like “MyApp.MyDocument.Error error 1”. Now, there are two ways to solve this, both of which involve throwing an NSError rather than a custom error type:<br></p><p>Solution 1: Get rid of the ErrorType.<br></p><p>class MyDocument: NSDocument {<br>    let ErrorDomain = “MyApp.MyDocument”<br>    enum ErrorCode: Int {<br>        case MadeAMistake = 1<br>        case RanOutOfCake = 2<br>    }<br></p><p>    …<br></p><p>    readFromData(data: NSData, ofType: String) {<br>        …<br></p><p>        if someFailureCondition {<br>            let userInfo = [NSLocalizedFailureReasonErrorKey: NSLocalizedString(“Looks like we ran out of cake.”, comment: “Ran out of cake”)]<br>            throw NSError(domain: ErrorDomain, code: ErrorCode.RanOutOfCake.rawValue, userInfo: userInfo)<br>        }<br></p><p>        ...<br>    }<br></p><p>    ...<br>}<br></p><p>This has a couple of problems. First, it forces us to use NSError. Second, it’s ugly. Imagine a method with many possible failure points, all filled with the userInfo building above.<br></p><p>The second solution is a little better:<br></p><p>class MyDocument: NSDocument {<br>    enum Error: ErrorType {<br>        let ErrorDomain = “MyApp.MyDocument”<br></p><p>        case MadeAMistake<br>        case RanOutOfCake<br></p><p>        func toNSError() -&gt; NSError {<br>            let failureReason: String<br>            let code: Int<br></p><p>            switch self {<br>            case .MadeAMistake:<br>                failureReason = NSLocalizedString(“Looks like we made a mistake.”, comment: “Made a mistake”)<br>                code = 1<br>            case .RanOutOfCake:<br>                failureReason = NSLocalizedString(“Looks like we ran out of cake.”, comment: “Ran out of cake”)<br>                code = 2<br>            }<br></p><p>            let userInfo = [NSLocalizedFailureReasonErrorKey: failureReason]<br></p><p>            return NSError(domain: self.ErrorDomain, code: code, userInfo: userInfo)<br>        }<br>    }<br></p><p>    …<br></p><p>    readFromData(data: NSData, ofType: String) {<br>        …<br></p><p>        if someFailureCondition {<br>            throw Error.RanOutOfCake.toNSError()<br>        }<br></p><p>        ...<br>    }<br></p><p>    ...<br>}<br></p><p>The good news is that now the ugliness is removed from the actual program code and confined to the error type’s declaration. The bad news is that if we forget to put .toNSError() on an error we throw somewhere and that bubbles back to Cocoa, the user gets a meaningless error message. Furthermore, if we call through to some other error-throwing method, we have to catch and convert any errors it might throw:<br></p><p>readFromData(data: NSData, ofType: String) {<br>    …<br></p><p>    do {<br>        try somethingThatThrows()<br>    } catch {<br>        if let myError = error as? Error {<br>            throw myError.toNSError()<br>        } else if let someOtherError = error as? SomeOtherErrorType {<br>            // convert to NSError somehow<br>        } else if let yetAnotherError = …<br>            etc. etc. etc.<br>        } else {<br>            throw error<br>        }<br>    }<br></p><p>    …<br></p><p>}<br></p><p>At this point it’s probably just to use NSError all the way through. :-/<br></p><p>With my proposal, all you’d do is this:<br></p><p>class MyDocument: NSDocument {<br>    enum Error: ErrorType {<br>        case MadeAMistake<br>        case RanOutOfCake<br></p><p>        var userInfo: [NSObject : AnyObject] {<br>            let failureReason: String<br></p><p>            switch self {<br>            case .MadeAMistake:<br>                failureReason = NSLocalizedString(“Looks like we made a mistake.”, comment: “Made a mistake”)<br>            case .RanOutOfCake:<br>                failureReason = NSLocalizedString(“Looks like we ran out of cake.”, comment: “Ran out of cake”)<br>            }<br></p><p>            return [NSLocalizedFailureReasonErrorKey: failureReason]<br>        }<br>    }<br></p><p>    …<br></p><p>    readFromData(data: NSData, ofType: String) {<br>        …<br></p><p>        if someFailureCondition {<br>            throw Error.RanOutOfCake<br>        }<br></p><p>        ...<br>    }<br></p><p>    ...<br>}<br></p><p>Much simpler, much, much less failure prone, and cleaner too since we don’t have to worry about domains or codes anymore, as we can just use the default values for those now.<br></p><p>&gt; The drawbacks I see with exposing NSError’s properties on every ErrorType is that those properties are only there as a hack to interoperate with NSError. Really they’d go away as Swift evolves it’s own default error representation, or language leaves it to developer to build their own. <br>&gt; 	Essentially, I think that if you want to improve ErrorType, formalizing its relationship to NSError is the wrong way. NSErrors are not good error representations, especially in Swift, and we should move away from them as soon as possible.<br></p><p><br>I don’t think Cocoa is going away for a very, very long time. Even if it did, you’d still need some consistent way to turn an ErrorType into something human-readable, and currently we don’t have that. NSError’s userInfo field actually does a fairly decent job, aside from the absurdly long constant names.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160514/c15ab948/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Pitch] Consistent bridging for NSErrors at the language boundary</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>May 14, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Am 14.05.2016 um 09:31 schrieb Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I don’t think Cocoa is going away for a very, very long time. Even if it did, you’d still need some consistent way to turn an ErrorType into something human-readable, and currently we don’t have that. NSError’s userInfo field actually does a fairly decent job, aside from the absurdly long constant names.<br></p><p>I think Apple&#39;s Chief Deprecating Officer is already getting nervous and that point in time may be sooner. IMHO it&#39;s one of the big pains of Apple development that you have to learn new stuff every year, because oftentimes APIs are changed for no convincing reasons. Or one API is removed and a new API introduced, with no migration time. It&#39;s one of the reasons why I sometimes think about leaving the Apple platform as a developer (where I could go to is another question..). Having to adapt a program every two years at least just to keep it compiling is not programmer friendly. It&#39;s a good playground for language developers though. With Swift 3 it&#39;s a similar problem. At a company I work, we decided not to use Swift yet, because of Swift 3. Because with Swift 3 everything has to be re-done, so we better wait until Swift 3 comes out. And even after Swift 3 will be released, we will probably wait until the mid of 2017, just to be really sure that no breaking changes are planned and no &quot;Swift 4&quot; is coming. Until that point I&#39;m going to use Swift only for small or educational projects (I&#39;m currently writing a game in Swift on iOS). IMHO it would be nice to have a language that is *stable* and that keeps stable for at least 10 years. But can Swift really ever become fully stable? Or will it be replaced with something else as soon as it becomes stable, in the same way it is happening to Objective-C now?&lt;/rant&gt;<br></p><p>For interoperability, ErrorType and NSError should be toll-free-bridged, like CFStringRef and NSString. Converting between them should be a no-op at runtime. I prefer runtime/ABI consistency over syntax/language consistency. MyErrorType2 should be represented as an NSError with domain @&quot;MyErrorType2&quot;, whatever code is defined in that error type, and if you want userInfo you have to create the beast as an NSError object in the first place. I think userInfo is not visible in the Swift-enum-representation. If you want to have a Swift Error representation that includes userInfo, you&#39;d have to either change the architecture or introduce special support on the language level (e.g. a magic `er.userInfo` of type `Dictionary&lt;String,AnyObject&gt;` for every `er: ErrorType` and a `er.withUserInfo(userInfo)` to add a userInfo dictionary to an error type: e.g. `MyErrorType2.fooConditionFound.withUserInfo([NSLocalizedDescriptionKey: &quot;that was really bad&quot;])` and maybe even a convenience method as a protocol extension like `MyErrorType.fooConditionFound.withLocalizedDescription(localizedString: &quot;ReallyBad&quot;)`. And the key of a dictionary should really always be a String, not just an NSObject.)<br></p><p>(I know if you have something like `case SpecialError(Int)` in your ErrorType declaration, the above method does not work; you&#39;d have to create an NSError-subclass for it. Or maybe not? Just add a &quot;SpecialError_arg0&quot; key to userInfo, value can be an NSNumber? There are more edge cases here but they are all solvable.)<br></p><p>On the other hand, I don&#39;t think that enumerations in general should support instance variables. One of the nice things for an enum is that I as a programmer can always be sure that it *is* just an enum, and nothing else. Adding iVars to enums would effectively turning enums to structs, and each time I see a switch statement I&#39;ll have to think &quot;is this really all? or is there some stealth value attached to this enum? is every .MadeAMistake object always the same?&quot; Keeping the inconsistency constrained to the ErrorType is much nicer than turning every enum into a struct.<br></p><p>There will always be rough edges when converting between two languages, that&#39;s unavoidable. Try to translate a text that contains a lot of the words &quot;safety&quot; and &quot;security&quot; into German. Good luck, they both translate to the same word. And so there also cannot be a perfectly consistent translation between ErrorType and NSError. If you want to achieve a good translation, you&#39;d have to change the ErrorType to something different. E.g. a special language construct `def-error MyErrorType { case MadeAMistake; case RanOutOfCake }` - matching works the same as now and you have a userInfo property. And on non-objc-platforms, the NSError() name becomes unavailable and .userInfo always returns `[:]`. I&#39;m not saying that this would be a beautiful solution; I&#39;m saying that there is no beautiful solution to this problem.<br></p><p>Regards,<br>Michael<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Pitch] Consistent bridging for NSErrors at the language boundary</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May 14, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; On May 14, 2016, at 3:51 AM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt; <br>&gt; For interoperability, ErrorType and NSError should be toll-free-bridged, like CFStringRef and NSString. Converting between them should be a no-op at runtime.<br></p><p>That would be technically infeasible without restricting ErrorType to reference types using the Objective-C runtime, which I don’t think anyone wants to do.<br></p><p>&gt; I prefer runtime/ABI consistency over syntax/language consistency. MyErrorType2 should be represented as an NSError with domain @&quot;MyErrorType2&quot;, whatever code is defined in that error type, and if you want userInfo you have to create the beast as an NSError object in the first place. I think userInfo is not visible in the Swift-enum-representation. If you want to have a Swift Error representation that includes userInfo, you&#39;d have to either change the architecture or introduce special support on the language level (e.g. a magic `er.userInfo` of type `Dictionary&lt;String,AnyObject&gt;` for every `er: ErrorType` and a `er.withUserInfo(userInfo)` to add a userInfo dictionary to an error type: e.g. `MyErrorType2.fooConditionFound.withUserInfo([NSLocalizedDescriptionKey: &quot;that was really bad&quot;])` and maybe even a convenience method as a protocol extension like `MyErrorType.fooConditionFound.withLocalizedDescription(localizedString: &quot;ReallyBad&quot;)`.<br></p><p>Adding a userInfo property to the protocol declaration (with a default implementation for those that don’t want to implement it) would solve this without any low-level hacking.<br></p><p>&gt; And the key of a dictionary should really always be a String, not just an NSObject.)<br></p><p>I actually agree; I used [NSObject : AnyObject] since that’s what NSError’s userInfo is currently defined as. Putting [String : AnyObject] in the protocol instead would be fine, although you’d have to do a little sanity checking in the bridging to filter out non-string keys from the dictionary.<br></p><p>&gt; (I know if you have something like `case SpecialError(Int)` in your ErrorType declaration, the above method does not work; you&#39;d have to create an NSError-subclass for it. Or maybe not? Just add a &quot;SpecialError_arg0&quot; key to userInfo, value can be an NSNumber? There are more edge cases here but they are all solvable.)<br>&gt; <br>&gt; On the other hand, I don&#39;t think that enumerations in general should support instance variables. One of the nice things for an enum is that I as a programmer can always be sure that it *is* just an enum, and nothing else. Adding iVars to enums would effectively turning enums to structs, and each time I see a switch statement I&#39;ll have to think &quot;is this really all? or is there some stealth value attached to this enum? is every .MadeAMistake object always the same?&quot; Keeping the inconsistency constrained to the ErrorType is much nicer than turning every enum into a struct.<br></p><p>Adding instance variables to enums is not necessary for this. The userInfo here can be implemented as a computed property, as it would be in enums (in classes and structs, of course, it would be up to the developer whether to make it a stored or computed property).<br></p><p>&gt; There will always be rough edges when converting between two languages, that&#39;s unavoidable. Try to translate a text that contains a lot of the words &quot;safety&quot; and &quot;security&quot; into German. Good luck, they both translate to the same word. And so there also cannot be a perfectly consistent translation between ErrorType and NSError. If you want to achieve a good translation, you&#39;d have to change the ErrorType to something different. E.g. a special language construct `def-error MyErrorType { case MadeAMistake; case RanOutOfCake }` - matching works the same as now and you have a userInfo property. And on non-objc-platforms, the NSError() name becomes unavailable and .userInfo always returns `[:]`. I&#39;m not saying that this would be a beautiful solution; I&#39;m saying that there is no beautiful solution to this problem.<br></p><p><br>I think that creating wrappers for both directions could work pretty well if we had a userInfo property on ErrorType/Protocol. We’ve got one going in one direction already.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160514/9b706389/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Pitch] Consistent bridging for NSErrors at the language boundary</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>June 20, 2016 at 05:00:00pm</p></header><div class="content"><p>I am curious on the disposition of this discussion / proposal pitch. Has<br>any additional effort taken place since this email thread tampered off?<br></p><p>On Sat, May 14, 2016 at 2:40 AM Charles Srstka via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On May 14, 2016, at 3:51 AM, Michael Peternell &lt;michael.peternell at gmx.at&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt; For interoperability, ErrorType and NSError should be toll-free-bridged,<br>&gt; like CFStringRef and NSString. Converting between them should be a no-op at<br>&gt; runtime.<br>&gt;<br>&gt;<br>&gt; That would be technically infeasible without restricting ErrorType to<br>&gt; reference types using the Objective-C runtime, which I don’t think anyone<br>&gt; wants to do.<br>&gt;<br>&gt; I prefer runtime/ABI consistency over syntax/language consistency.<br>&gt; MyErrorType2 should be represented as an NSError with domain<br>&gt; @&quot;MyErrorType2&quot;, whatever code is defined in that error type, and if you<br>&gt; want userInfo you have to create the beast as an NSError object in the<br>&gt; first place. I think userInfo is not visible in the<br>&gt; Swift-enum-representation. If you want to have a Swift Error representation<br>&gt; that includes userInfo, you&#39;d have to either change the architecture or<br>&gt; introduce special support on the language level (e.g. a magic `er.userInfo`<br>&gt; of type `Dictionary&lt;String,AnyObject&gt;` for every `er: ErrorType` and a<br>&gt; `er.withUserInfo(userInfo)` to add a userInfo dictionary to an error type:<br>&gt; e.g.<br>&gt; `MyErrorType2.fooConditionFound.withUserInfo([NSLocalizedDescriptionKey:<br>&gt; &quot;that was really bad&quot;])` and maybe even a convenience method as a protocol<br>&gt; extension like<br>&gt; `MyErrorType.fooConditionFound.withLocalizedDescription(localizedString:<br>&gt; &quot;ReallyBad&quot;)`.<br>&gt;<br>&gt;<br>&gt; Adding a userInfo property to the protocol declaration (with a default<br>&gt; implementation for those that don’t want to implement it) would solve this<br>&gt; without any low-level hacking.<br>&gt;<br>&gt; And the key of a dictionary should really always be a String, not just an<br>&gt; NSObject.)<br>&gt;<br>&gt;<br>&gt; I actually agree; I used [NSObject : AnyObject] since that’s what<br>&gt; NSError’s userInfo is currently defined as. Putting [String : AnyObject] in<br>&gt; the protocol instead would be fine, although you’d have to do a little<br>&gt; sanity checking in the bridging to filter out non-string keys from the<br>&gt; dictionary.<br>&gt;<br>&gt; (I know if you have something like `case SpecialError(Int)` in your<br>&gt; ErrorType declaration, the above method does not work; you&#39;d have to create<br>&gt; an NSError-subclass for it. Or maybe not? Just add a &quot;SpecialError_arg0&quot;<br>&gt; key to userInfo, value can be an NSNumber? There are more edge cases here<br>&gt; but they are all solvable.)<br>&gt;<br>&gt; On the other hand, I don&#39;t think that enumerations in general should<br>&gt; support instance variables. One of the nice things for an enum is that I as<br>&gt; a programmer can always be sure that it *is* just an enum, and nothing<br>&gt; else. Adding iVars to enums would effectively turning enums to structs, and<br>&gt; each time I see a switch statement I&#39;ll have to think &quot;is this really all?<br>&gt; or is there some stealth value attached to this enum? is every<br>&gt; .MadeAMistake object always the same?&quot; Keeping the inconsistency<br>&gt; constrained to the ErrorType is much nicer than turning every enum into a<br>&gt; struct.<br>&gt;<br>&gt;<br>&gt; Adding instance variables to enums is not necessary for this. The userInfo<br>&gt; here can be implemented as a computed property, as it would be in enums (in<br>&gt; classes and structs, of course, it would be up to the developer whether to<br>&gt; make it a stored or computed property).<br>&gt;<br>&gt; There will always be rough edges when converting between two languages,<br>&gt; that&#39;s unavoidable. Try to translate a text that contains a lot of the<br>&gt; words &quot;safety&quot; and &quot;security&quot; into German. Good luck, they both translate<br>&gt; to the same word. And so there also cannot be a perfectly consistent<br>&gt; translation between ErrorType and NSError. If you want to achieve a good<br>&gt; translation, you&#39;d have to change the ErrorType to something different.<br>&gt; E.g. a special language construct `def-error MyErrorType { case<br>&gt; MadeAMistake; case RanOutOfCake }` - matching works the same as now and you<br>&gt; have a userInfo property. And on non-objc-platforms, the NSError() name<br>&gt; becomes unavailable and .userInfo always returns `[:]`. I&#39;m not saying that<br>&gt; this would be a beautiful solution; I&#39;m saying that there is no beautiful<br>&gt; solution to this problem.<br>&gt;<br>&gt;<br>&gt; I think that creating wrappers for both directions could work pretty well<br>&gt; if we had a userInfo property on ErrorType/Protocol. We’ve got one going in<br>&gt; one direction already.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/76d74157/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Pitch] Consistent bridging for NSErrors at the language boundary</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June 20, 2016 at 01:00:00pm</p></header><div class="content"><p>It was deferred until after Swift 3.0.<br></p><p>https://github.com/apple/swift-evolution/pull/331 &lt;https://github.com/apple/swift-evolution/pull/331&gt;<br></p><p>I plan to resubmit the proposal after Swift 3.0 comes out. Do you have any improvements or suggestions for it?<br></p><p>Charles<br></p><p>&gt; On Jun 20, 2016, at 12:51 PM, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt; <br>&gt; I am curious on the disposition of this discussion / proposal pitch. Has any additional effort taken place since this email thread tampered off?<br>&gt; <br>&gt; On Sat, May 14, 2016 at 2:40 AM Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; On May 14, 2016, at 3:51 AM, Michael Peternell &lt;michael.peternell at gmx.at &lt;mailto:michael.peternell at gmx.at&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; For interoperability, ErrorType and NSError should be toll-free-bridged, like CFStringRef and NSString. Converting between them should be a no-op at runtime.<br>&gt; <br>&gt; That would be technically infeasible without restricting ErrorType to reference types using the Objective-C runtime, which I don’t think anyone wants to do.<br>&gt; <br>&gt;&gt; I prefer runtime/ABI consistency over syntax/language consistency. MyErrorType2 should be represented as an NSError with domain @&quot;MyErrorType2&quot;, whatever code is defined in that error type, and if you want userInfo you have to create the beast as an NSError object in the first place. I think userInfo is not visible in the Swift-enum-representation. If you want to have a Swift Error representation that includes userInfo, you&#39;d have to either change the architecture or introduce special support on the language level (e.g. a magic `er.userInfo` of type `Dictionary&lt;String,AnyObject&gt;` for every `er: ErrorType` and a `er.withUserInfo(userInfo)` to add a userInfo dictionary to an error type: e.g. `MyErrorType2.fooConditionFound.withUserInfo([NSLocalizedDescriptionKey: &quot;that was really bad&quot;])` and maybe even a convenience method as a protocol extension like `MyErrorType.fooConditionFound.withLocalizedDescription(localizedString: &quot;ReallyBad&quot;)`.<br>&gt; <br>&gt; Adding a userInfo property to the protocol declaration (with a default implementation for those that don’t want to implement it) would solve this without any low-level hacking.<br>&gt; <br>&gt;&gt; And the key of a dictionary should really always be a String, not just an NSObject.)<br>&gt; <br>&gt; I actually agree; I used [NSObject : AnyObject] since that’s what NSError’s userInfo is currently defined as. Putting [String : AnyObject] in the protocol instead would be fine, although you’d have to do a little sanity checking in the bridging to filter out non-string keys from the dictionary.<br>&gt; <br>&gt;&gt; (I know if you have something like `case SpecialError(Int)` in your ErrorType declaration, the above method does not work; you&#39;d have to create an NSError-subclass for it. Or maybe not? Just add a &quot;SpecialError_arg0&quot; key to userInfo, value can be an NSNumber? There are more edge cases here but they are all solvable.)<br>&gt;&gt; <br>&gt;&gt; On the other hand, I don&#39;t think that enumerations in general should support instance variables. One of the nice things for an enum is that I as a programmer can always be sure that it *is* just an enum, and nothing else. Adding iVars to enums would effectively turning enums to structs, and each time I see a switch statement I&#39;ll have to think &quot;is this really all? or is there some stealth value attached to this enum? is every .MadeAMistake object always the same?&quot; Keeping the inconsistency constrained to the ErrorType is much nicer than turning every enum into a struct.<br>&gt; <br>&gt; Adding instance variables to enums is not necessary for this. The userInfo here can be implemented as a computed property, as it would be in enums (in classes and structs, of course, it would be up to the developer whether to make it a stored or computed property).<br>&gt; <br>&gt;&gt; There will always be rough edges when converting between two languages, that&#39;s unavoidable. Try to translate a text that contains a lot of the words &quot;safety&quot; and &quot;security&quot; into German. Good luck, they both translate to the same word. And so there also cannot be a perfectly consistent translation between ErrorType and NSError. If you want to achieve a good translation, you&#39;d have to change the ErrorType to something different. E.g. a special language construct `def-error MyErrorType { case MadeAMistake; case RanOutOfCake }` - matching works the same as now and you have a userInfo property. And on non-objc-platforms, the NSError() name becomes unavailable and .userInfo always returns `[:]`. I&#39;m not saying that this would be a beautiful solution; I&#39;m saying that there is no beautiful solution to this problem.<br>&gt; <br>&gt; <br>&gt; I think that creating wrappers for both directions could work pretty well if we had a userInfo property on ErrorType/Protocol. We’ve got one going in one direction already.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/075e0741/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Pitch] Consistent bridging for NSErrors at the language boundary</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>June 20, 2016 at 06:00:00pm</p></header><div class="content"><p>Thanks, overlooked the proposal (or forgot about it)... will try to get<br>some time to look it over.<br></p><p>On Mon, Jun 20, 2016 at 11:03 AM Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; It was deferred until after Swift 3.0.<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/pull/331<br>&gt;<br>&gt; I plan to resubmit the proposal after Swift 3.0 comes out. Do you have any<br>&gt; improvements or suggestions for it?<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt; On Jun 20, 2016, at 12:51 PM, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; I am curious on the disposition of this discussion / proposal pitch. Has<br>&gt; any additional effort taken place since this email thread tampered off?<br>&gt;<br>&gt; On Sat, May 14, 2016 at 2:40 AM Charles Srstka via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On May 14, 2016, at 3:51 AM, Michael Peternell &lt;michael.peternell at gmx.at&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; For interoperability, ErrorType and NSError should be toll-free-bridged,<br>&gt;&gt; like CFStringRef and NSString. Converting between them should be a no-op at<br>&gt;&gt; runtime.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That would be technically infeasible without restricting ErrorType to<br>&gt;&gt; reference types using the Objective-C runtime, which I don’t think anyone<br>&gt;&gt; wants to do.<br>&gt;&gt;<br>&gt;&gt; I prefer runtime/ABI consistency over syntax/language consistency.<br>&gt;&gt; MyErrorType2 should be represented as an NSError with domain<br>&gt;&gt; @&quot;MyErrorType2&quot;, whatever code is defined in that error type, and if you<br>&gt;&gt; want userInfo you have to create the beast as an NSError object in the<br>&gt;&gt; first place. I think userInfo is not visible in the<br>&gt;&gt; Swift-enum-representation. If you want to have a Swift Error representation<br>&gt;&gt; that includes userInfo, you&#39;d have to either change the architecture or<br>&gt;&gt; introduce special support on the language level (e.g. a magic `er.userInfo`<br>&gt;&gt; of type `Dictionary&lt;String,AnyObject&gt;` for every `er: ErrorType` and a<br>&gt;&gt; `er.withUserInfo(userInfo)` to add a userInfo dictionary to an error type:<br>&gt;&gt; e.g.<br>&gt;&gt; `MyErrorType2.fooConditionFound.withUserInfo([NSLocalizedDescriptionKey:<br>&gt;&gt; &quot;that was really bad&quot;])` and maybe even a convenience method as a protocol<br>&gt;&gt; extension like<br>&gt;&gt; `MyErrorType.fooConditionFound.withLocalizedDescription(localizedString:<br>&gt;&gt; &quot;ReallyBad&quot;)`.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Adding a userInfo property to the protocol declaration (with a default<br>&gt;&gt; implementation for those that don’t want to implement it) would solve this<br>&gt;&gt; without any low-level hacking.<br>&gt;&gt;<br>&gt;&gt; And the key of a dictionary should really always be a String, not just an<br>&gt;&gt; NSObject.)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I actually agree; I used [NSObject : AnyObject] since that’s what<br>&gt;&gt; NSError’s userInfo is currently defined as. Putting [String : AnyObject] in<br>&gt;&gt; the protocol instead would be fine, although you’d have to do a little<br>&gt;&gt; sanity checking in the bridging to filter out non-string keys from the<br>&gt;&gt; dictionary.<br>&gt;&gt;<br>&gt;&gt; (I know if you have something like `case SpecialError(Int)` in your<br>&gt;&gt; ErrorType declaration, the above method does not work; you&#39;d have to create<br>&gt;&gt; an NSError-subclass for it. Or maybe not? Just add a &quot;SpecialError_arg0&quot;<br>&gt;&gt; key to userInfo, value can be an NSNumber? There are more edge cases here<br>&gt;&gt; but they are all solvable.)<br>&gt;&gt;<br>&gt;&gt; On the other hand, I don&#39;t think that enumerations in general should<br>&gt;&gt; support instance variables. One of the nice things for an enum is that I as<br>&gt;&gt; a programmer can always be sure that it *is* just an enum, and nothing<br>&gt;&gt; else. Adding iVars to enums would effectively turning enums to structs, and<br>&gt;&gt; each time I see a switch statement I&#39;ll have to think &quot;is this really all?<br>&gt;&gt; or is there some stealth value attached to this enum? is every<br>&gt;&gt; .MadeAMistake object always the same?&quot; Keeping the inconsistency<br>&gt;&gt; constrained to the ErrorType is much nicer than turning every enum into a<br>&gt;&gt; struct.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Adding instance variables to enums is not necessary for this. The<br>&gt;&gt; userInfo here can be implemented as a computed property, as it would be in<br>&gt;&gt; enums (in classes and structs, of course, it would be up to the developer<br>&gt;&gt; whether to make it a stored or computed property).<br>&gt;&gt;<br>&gt;&gt; There will always be rough edges when converting between two languages,<br>&gt;&gt; that&#39;s unavoidable. Try to translate a text that contains a lot of the<br>&gt;&gt; words &quot;safety&quot; and &quot;security&quot; into German. Good luck, they both translate<br>&gt;&gt; to the same word. And so there also cannot be a perfectly consistent<br>&gt;&gt; translation between ErrorType and NSError. If you want to achieve a good<br>&gt;&gt; translation, you&#39;d have to change the ErrorType to something different.<br>&gt;&gt; E.g. a special language construct `def-error MyErrorType { case<br>&gt;&gt; MadeAMistake; case RanOutOfCake }` - matching works the same as now and you<br>&gt;&gt; have a userInfo property. And on non-objc-platforms, the NSError() name<br>&gt;&gt; becomes unavailable and .userInfo always returns `[:]`. I&#39;m not saying that<br>&gt;&gt; this would be a beautiful solution; I&#39;m saying that there is no beautiful<br>&gt;&gt; solution to this problem.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I think that creating wrappers for both directions could work pretty well<br>&gt;&gt; if we had a userInfo property on ErrorType/Protocol. We’ve got one going in<br>&gt;&gt; one direction already.<br>&gt;&gt;<br>&gt;&gt; Charles<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/7eef378f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch] Consistent bridging for NSErrors at the language boundary</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 21, 2016 at 11:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Jun 20, 2016, at 11:03 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It was deferred until after Swift 3.0.<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/pull/331<br>&gt; <br>&gt; I plan to resubmit the proposal after Swift 3.0 comes out. Do you have any improvements or suggestions for it<br></p><p>The core team is reconsidering the deferral, because tackling this completely is a fairly significant source-breaking change that we wouldn&#39;t want to do post-Swift 3. That said, this is a tricky feature to get right, because it involves dealing with intricacies of Swift&#39;s Objective-C interoperability as well as the inner workings of NSError. I&#39;ll have some comments on your proposal as well as my own thoughts on an implement approach in the next few days. Hang in there :)<br></p><p>  - Doug<br></p><p>&gt; <br>&gt; Charles<br>&gt; <br>&gt;&gt; On Jun 20, 2016, at 12:51 PM, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I am curious on the disposition of this discussion / proposal pitch. Has any additional effort taken place since this email thread tampered off?<br>&gt;&gt; <br>&gt;&gt; On Sat, May 14, 2016 at 2:40 AM Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; On May 14, 2016, at 3:51 AM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For interoperability, ErrorType and NSError should be toll-free-bridged, like CFStringRef and NSString. Converting between them should be a no-op at runtime.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That would be technically infeasible without restricting ErrorType to reference types using the Objective-C runtime, which I don’t think anyone wants to do.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I prefer runtime/ABI consistency over syntax/language consistency. MyErrorType2 should be represented as an NSError with domain @&quot;MyErrorType2&quot;, whatever code is defined in that error type, and if you want userInfo you have to create the beast as an NSError object in the first place. I think userInfo is not visible in the Swift-enum-representation. If you want to have a Swift Error representation that includes userInfo, you&#39;d have to either change the architecture or introduce special support on the language level (e.g. a magic `er.userInfo` of type `Dictionary&lt;String,AnyObject&gt;` for every `er: ErrorType` and a `er.withUserInfo(userInfo)` to add a userInfo dictionary to an error type: e.g. `MyErrorType2.fooConditionFound.withUserInfo([NSLocalizedDescriptionKey: &quot;that was really bad&quot;])` and maybe even a convenience method as a protocol extension like `MyErrorType.fooConditionFound.withLocalizedDescription(localizedString: &quot;ReallyBad&quot;)`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Adding a userInfo property to the protocol declaration (with a default implementation for those that don’t want to implement it) would solve this without any low-level hacking.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And the key of a dictionary should really always be a String, not just an NSObject.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I actually agree; I used [NSObject : AnyObject] since that’s what NSError’s userInfo is currently defined as. Putting [String : AnyObject] in the protocol instead would be fine, although you’d have to do a little sanity checking in the bridging to filter out non-string keys from the dictionary.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (I know if you have something like `case SpecialError(Int)` in your ErrorType declaration, the above method does not work; you&#39;d have to create an NSError-subclass for it. Or maybe not? Just add a &quot;SpecialError_arg0&quot; key to userInfo, value can be an NSNumber? There are more edge cases here but they are all solvable.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On the other hand, I don&#39;t think that enumerations in general should support instance variables. One of the nice things for an enum is that I as a programmer can always be sure that it *is* just an enum, and nothing else. Adding iVars to enums would effectively turning enums to structs, and each time I see a switch statement I&#39;ll have to think &quot;is this really all? or is there some stealth value attached to this enum? is every .MadeAMistake object always the same?&quot; Keeping the inconsistency constrained to the ErrorType is much nicer than turning every enum into a struct.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Adding instance variables to enums is not necessary for this. The userInfo here can be implemented as a computed property, as it would be in enums (in classes and structs, of course, it would be up to the developer whether to make it a stored or computed property).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There will always be rough edges when converting between two languages, that&#39;s unavoidable. Try to translate a text that contains a lot of the words &quot;safety&quot; and &quot;security&quot; into German. Good luck, they both translate to the same word. And so there also cannot be a perfectly consistent translation between ErrorType and NSError. If you want to achieve a good translation, you&#39;d have to change the ErrorType to something different. E.g. a special language construct `def-error MyErrorType { case MadeAMistake; case RanOutOfCake }` - matching works the same as now and you have a userInfo property. And on non-objc-platforms, the NSError() name becomes unavailable and .userInfo always returns `[:]`. I&#39;m not saying that this would be a beautiful solution; I&#39;m saying that there is no beautiful solution to this problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think that creating wrappers for both directions could work pretty well if we had a userInfo property on ErrorType/Protocol. We’ve got one going in one direction already.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Charles<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160621/abe8ca54/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Pitch] Consistent bridging for NSErrors at the language boundary</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June 22, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 1:28 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; On Jun 20, 2016, at 11:03 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; It was deferred until after Swift 3.0.<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/pull/331 &lt;https://github.com/apple/swift-evolution/pull/331&gt;<br>&gt;&gt; <br>&gt;&gt; I plan to resubmit the proposal after Swift 3.0 comes out. Do you have any improvements or suggestions for it<br>&gt; <br>&gt; The core team is reconsidering the deferral, because tackling this completely is a fairly significant source-breaking change that we wouldn&#39;t want to do post-Swift 3. That said, this is a tricky feature to get right, because it involves dealing with intricacies of Swift&#39;s Objective-C interoperability as well as the inner workings of NSError. I&#39;ll have some comments on your proposal as well as my own thoughts on an implement approach in the next few days. Hang in there :)<br></p><p>That is great news! This proposal seems like a good fit for Swift 3.0, to my mind, as it is very much along similar lines as the NSURL -&gt; URL, NSDate -&gt; Date, etc. conversions that are already being made.<br></p><p>I look forward to hearing your comments.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/24ba4762/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
